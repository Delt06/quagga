
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgpd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP-4, BGP-4+ daemon program</a>
<a name="ln2">   Copyright (C) 1996, 97, 98, 99, 2000 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;prefix.h&quot;</a>
<a name="ln24">#include &quot;thread.h&quot;</a>
<a name="ln25">#include &quot;buffer.h&quot;</a>
<a name="ln26">#include &quot;stream.h&quot;</a>
<a name="ln27">#include &quot;command.h&quot;</a>
<a name="ln28">#include &quot;sockunion.h&quot;</a>
<a name="ln29">#include &quot;sockopt.h&quot;</a>
<a name="ln30">#include &quot;network.h&quot;</a>
<a name="ln31">#include &quot;memory.h&quot;</a>
<a name="ln32">#include &quot;filter.h&quot;</a>
<a name="ln33">#include &quot;routemap.h&quot;</a>
<a name="ln34">#include &quot;str.h&quot;</a>
<a name="ln35">#include &quot;log.h&quot;</a>
<a name="ln36">#include &quot;plist.h&quot;</a>
<a name="ln37">#include &quot;linklist.h&quot;</a>
<a name="ln38">#include &quot;workqueue.h&quot;</a>
<a name="ln39">#include &quot;table.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln42">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln43">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln44">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln45">#include &quot;bgpd/bgp_dump.h&quot;</a>
<a name="ln46">#include &quot;bgpd/bgp_debug.h&quot;</a>
<a name="ln47">#include &quot;bgpd/bgp_community.h&quot;</a>
<a name="ln48">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln49">#include &quot;bgpd/bgp_regex.h&quot;</a>
<a name="ln50">#include &quot;bgpd/bgp_clist.h&quot;</a>
<a name="ln51">#include &quot;bgpd/bgp_fsm.h&quot;</a>
<a name="ln52">#include &quot;bgpd/bgp_packet.h&quot;</a>
<a name="ln53">#include &quot;bgpd/bgp_zebra.h&quot;</a>
<a name="ln54">#include &quot;bgpd/bgp_open.h&quot;</a>
<a name="ln55">#include &quot;bgpd/bgp_filter.h&quot;</a>
<a name="ln56">#include &quot;bgpd/bgp_nexthop.h&quot;</a>
<a name="ln57">#include &quot;bgpd/bgp_damp.h&quot;</a>
<a name="ln58">#include &quot;bgpd/bgp_mplsvpn.h&quot;</a>
<a name="ln59">#include &quot;bgpd/bgp_encap.h&quot;</a>
<a name="ln60">#include &quot;bgpd/bgp_advertise.h&quot;</a>
<a name="ln61">#include &quot;bgpd/bgp_network.h&quot;</a>
<a name="ln62">#include &quot;bgpd/bgp_vty.h&quot;</a>
<a name="ln63">#include &quot;bgpd/bgp_mpath.h&quot;</a>
<a name="ln64">#include &quot;bgpd/bgp_nht.h&quot;</a>
<a name="ln65">#ifdef HAVE_SNMP</a>
<a name="ln66">#include &quot;bgpd/bgp_snmp.h&quot;</a>
<a name="ln67">#endif /* HAVE_SNMP */</a>
<a name="ln68"> </a>
<a name="ln69">/* BGP process wide configuration.  */</a>
<a name="ln70">static struct bgp_master bgp_master;</a>
<a name="ln71"> </a>
<a name="ln72">extern struct in_addr router_id_zebra;</a>
<a name="ln73"> </a>
<a name="ln74">/* BGP process wide configuration pointer to export.  */</a>
<a name="ln75">struct bgp_master *bm;</a>
<a name="ln76"> </a>
<a name="ln77">/* BGP community-list.  */</a>
<a name="ln78">struct community_list_handler *bgp_clist;</a>
<a name="ln79"> </a>
<a name="ln80">/* BGP global flag manipulation.  */</a>
<a name="ln81">int</a>
<a name="ln82">bgp_option_set (int flag)</a>
<a name="ln83">{</a>
<a name="ln84">  switch (flag)</a>
<a name="ln85">    {</a>
<a name="ln86">    case BGP_OPT_NO_FIB:</a>
<a name="ln87">    case BGP_OPT_MULTIPLE_INSTANCE:</a>
<a name="ln88">    case BGP_OPT_CONFIG_CISCO:</a>
<a name="ln89">    case BGP_OPT_NO_LISTEN:</a>
<a name="ln90">      SET_FLAG (bm-&gt;options, flag);</a>
<a name="ln91">      break;</a>
<a name="ln92">    default:</a>
<a name="ln93">      return BGP_ERR_INVALID_FLAG;</a>
<a name="ln94">    }</a>
<a name="ln95">  return 0;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">int</a>
<a name="ln99">bgp_option_unset (int flag)</a>
<a name="ln100">{</a>
<a name="ln101">  switch (flag)</a>
<a name="ln102">    {</a>
<a name="ln103">    case BGP_OPT_MULTIPLE_INSTANCE:</a>
<a name="ln104">      if (listcount (bm-&gt;bgp) &gt; 1)</a>
<a name="ln105">	return BGP_ERR_MULTIPLE_INSTANCE_USED;</a>
<a name="ln106">      /* Fall through.  */</a>
<a name="ln107">    case BGP_OPT_NO_FIB:</a>
<a name="ln108">    case BGP_OPT_CONFIG_CISCO:</a>
<a name="ln109">      UNSET_FLAG (bm-&gt;options, flag);</a>
<a name="ln110">      break;</a>
<a name="ln111">    default:</a>
<a name="ln112">      return BGP_ERR_INVALID_FLAG;</a>
<a name="ln113">    }</a>
<a name="ln114">  return 0;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">int</a>
<a name="ln118">bgp_option_check (int flag)</a>
<a name="ln119">{</a>
<a name="ln120">  return CHECK_FLAG (bm-&gt;options, flag);</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">/* BGP flag manipulation.  */</a>
<a name="ln124">int</a>
<a name="ln125">bgp_flag_set (struct bgp *bgp, int flag)</a>
<a name="ln126">{</a>
<a name="ln127">  SET_FLAG (bgp-&gt;flags, flag);</a>
<a name="ln128">  return 0;</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">int</a>
<a name="ln132">bgp_flag_unset (struct bgp *bgp, int flag)</a>
<a name="ln133">{</a>
<a name="ln134">  UNSET_FLAG (bgp-&gt;flags, flag);</a>
<a name="ln135">  return 0;</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">int</a>
<a name="ln139">bgp_flag_check (struct bgp *bgp, int flag)</a>
<a name="ln140">{</a>
<a name="ln141">  return CHECK_FLAG (bgp-&gt;flags, flag);</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">/* Internal function to set BGP structure configureation flag.  */</a>
<a name="ln145">static void</a>
<a name="ln146">bgp_config_set (struct bgp *bgp, int config)</a>
<a name="ln147">{</a>
<a name="ln148">  SET_FLAG (bgp-&gt;config, config);</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">static void</a>
<a name="ln152">bgp_config_unset (struct bgp *bgp, int config)</a>
<a name="ln153">{</a>
<a name="ln154">  UNSET_FLAG (bgp-&gt;config, config);</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">static int</a>
<a name="ln158">bgp_config_check (struct bgp *bgp, int config)</a>
<a name="ln159">{</a>
<a name="ln160">  return CHECK_FLAG (bgp-&gt;config, config);</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">/* Set BGP router identifier. */</a>
<a name="ln164">static int</a>
<a name="ln165">bgp_router_id_set (struct bgp *bgp, struct in_addr *id)</a>
<a name="ln166">{</a>
<a name="ln167">  struct peer *peer;</a>
<a name="ln168">  struct listnode *node, *nnode;</a>
<a name="ln169"> </a>
<a name="ln170">  if (bgp_config_check (bgp, BGP_CONFIG_ROUTER_ID)</a>
<a name="ln171">      &amp;&amp; IPV4_ADDR_SAME (&amp;bgp-&gt;router_id, id))</a>
<a name="ln172">    return 0;</a>
<a name="ln173"> </a>
<a name="ln174">  IPV4_ADDR_COPY (&amp;bgp-&gt;router_id, id);</a>
<a name="ln175">  bgp_config_set (bgp, BGP_CONFIG_ROUTER_ID);</a>
<a name="ln176"> </a>
<a name="ln177">  /* Set all peer's local identifier with this value. */</a>
<a name="ln178">  for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln179">    {</a>
<a name="ln180">      IPV4_ADDR_COPY (&amp;peer-&gt;local_id, id);</a>
<a name="ln181"> </a>
<a name="ln182">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln183">       {</a>
<a name="ln184">         peer-&gt;last_reset = PEER_DOWN_RID_CHANGE;</a>
<a name="ln185">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln186">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln187">       }</a>
<a name="ln188">    }</a>
<a name="ln189">  return 0;</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">void</a>
<a name="ln193">bgp_router_id_zebra_bump (void)</a>
<a name="ln194">{</a>
<a name="ln195">  struct listnode *node, *nnode;</a>
<a name="ln196">  struct bgp *bgp;</a>
<a name="ln197"> </a>
<a name="ln198">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, node, nnode, bgp))</a>
<a name="ln199">    {</a>
<a name="ln200">      if (!bgp-&gt;router_id_static.s_addr)</a>
<a name="ln201">        bgp_router_id_set (bgp, &amp;router_id_zebra);</a>
<a name="ln202">    }</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">int</a>
<a name="ln206">bgp_router_id_static_set (struct bgp *bgp, struct in_addr id)</a>
<a name="ln207">{</a>
<a name="ln208">  bgp-&gt;router_id_static = id;</a>
<a name="ln209">  bgp_router_id_set (bgp, id.s_addr ? &amp;id : &amp;router_id_zebra);</a>
<a name="ln210">  return 0;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">/* BGP's cluster-id control. */</a>
<a name="ln214">int</a>
<a name="ln215">bgp_cluster_id_set (struct bgp *bgp, struct in_addr *cluster_id)</a>
<a name="ln216">{</a>
<a name="ln217">  struct peer *peer;</a>
<a name="ln218">  struct listnode *node, *nnode;</a>
<a name="ln219"> </a>
<a name="ln220">  if (bgp_config_check (bgp, BGP_CONFIG_CLUSTER_ID)</a>
<a name="ln221">      &amp;&amp; IPV4_ADDR_SAME (&amp;bgp-&gt;cluster_id, cluster_id))</a>
<a name="ln222">    return 0;</a>
<a name="ln223"> </a>
<a name="ln224">  IPV4_ADDR_COPY (&amp;bgp-&gt;cluster_id, cluster_id);</a>
<a name="ln225">  bgp_config_set (bgp, BGP_CONFIG_CLUSTER_ID);</a>
<a name="ln226"> </a>
<a name="ln227">  /* Clear all IBGP peer. */</a>
<a name="ln228">  for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln229">    {</a>
<a name="ln230">      if (peer-&gt;sort != BGP_PEER_IBGP)</a>
<a name="ln231">	continue;</a>
<a name="ln232"> </a>
<a name="ln233">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln234">       {</a>
<a name="ln235">         peer-&gt;last_reset = PEER_DOWN_CLID_CHANGE;</a>
<a name="ln236">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln237">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln238">       }</a>
<a name="ln239">    }</a>
<a name="ln240">  return 0;</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">int</a>
<a name="ln244">bgp_cluster_id_unset (struct bgp *bgp)</a>
<a name="ln245">{</a>
<a name="ln246">  struct peer *peer;</a>
<a name="ln247">  struct listnode *node, *nnode;</a>
<a name="ln248"> </a>
<a name="ln249">  if (! bgp_config_check (bgp, BGP_CONFIG_CLUSTER_ID))</a>
<a name="ln250">    return 0;</a>
<a name="ln251"> </a>
<a name="ln252">  bgp-&gt;cluster_id.s_addr = 0;</a>
<a name="ln253">  bgp_config_unset (bgp, BGP_CONFIG_CLUSTER_ID);</a>
<a name="ln254"> </a>
<a name="ln255">  /* Clear all IBGP peer. */</a>
<a name="ln256">  for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln257">    {</a>
<a name="ln258">      if (peer-&gt;sort != BGP_PEER_IBGP)</a>
<a name="ln259">	continue;</a>
<a name="ln260"> </a>
<a name="ln261">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln262">       {</a>
<a name="ln263">         peer-&gt;last_reset = PEER_DOWN_CLID_CHANGE;</a>
<a name="ln264">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln265">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln266">       }</a>
<a name="ln267">    }</a>
<a name="ln268">  return 0;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">/* time_t value that is monotonicly increasing</a>
<a name="ln272"> * and uneffected by adjustments to system clock</a>
<a name="ln273"> */</a>
<a name="ln274">time_t bgp_clock (void)</a>
<a name="ln275">{</a>
<a name="ln276">  struct timeval tv;</a>
<a name="ln277"> </a>
<a name="ln278">  quagga_gettime(QUAGGA_CLK_MONOTONIC, &amp;tv);</a>
<a name="ln279">  return tv.tv_sec;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">/* BGP timer configuration.  */</a>
<a name="ln283">int</a>
<a name="ln284">bgp_timers_set (struct bgp *bgp, u_int32_t keepalive, u_int32_t holdtime)</a>
<a name="ln285">{</a>
<a name="ln286">  bgp-&gt;default_keepalive = (keepalive &lt; holdtime / 3 </a>
<a name="ln287">			    ? keepalive : holdtime / 3);</a>
<a name="ln288">  bgp-&gt;default_holdtime = holdtime;</a>
<a name="ln289"> </a>
<a name="ln290">  return 0;</a>
<a name="ln291">}</a>
<a name="ln292"> </a>
<a name="ln293">int</a>
<a name="ln294">bgp_timers_unset (struct bgp *bgp)</a>
<a name="ln295">{</a>
<a name="ln296">  bgp-&gt;default_keepalive = BGP_DEFAULT_KEEPALIVE;</a>
<a name="ln297">  bgp-&gt;default_holdtime = BGP_DEFAULT_HOLDTIME;</a>
<a name="ln298"> </a>
<a name="ln299">  return 0;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">/* BGP confederation configuration.  */</a>
<a name="ln303">int</a>
<a name="ln304">bgp_confederation_id_set (struct bgp *bgp, as_t as)</a>
<a name="ln305">{</a>
<a name="ln306">  struct peer *peer;</a>
<a name="ln307">  struct listnode *node, *nnode;</a>
<a name="ln308">  int already_confed;</a>
<a name="ln309"> </a>
<a name="ln310">  if (as == 0)</a>
<a name="ln311">    return BGP_ERR_INVALID_AS;</a>
<a name="ln312"> </a>
<a name="ln313">  /* Remember - were we doing confederation before? */</a>
<a name="ln314">  already_confed = bgp_config_check (bgp, BGP_CONFIG_CONFEDERATION);</a>
<a name="ln315">  bgp-&gt;confed_id = as;</a>
<a name="ln316">  bgp_config_set (bgp, BGP_CONFIG_CONFEDERATION);</a>
<a name="ln317"> </a>
<a name="ln318">  /* If we were doing confederation already, this is just an external</a>
<a name="ln319">     AS change.  Just Reset EBGP sessions, not CONFED sessions.  If we</a>
<a name="ln320">     were not doing confederation before, reset all EBGP sessions.  */</a>
<a name="ln321">  for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln322">    {</a>
<a name="ln323">      /* We're looking for peers who's AS is not local or part of our</a>
<a name="ln324">	 confederation.  */</a>
<a name="ln325">      if (already_confed)</a>
<a name="ln326">	{</a>
<a name="ln327">	  if (peer_sort (peer) == BGP_PEER_EBGP)</a>
<a name="ln328">	    {</a>
<a name="ln329">	      peer-&gt;local_as = as;</a>
<a name="ln330">	      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln331">               {</a>
<a name="ln332">                 peer-&gt;last_reset = PEER_DOWN_CONFED_ID_CHANGE;</a>
<a name="ln333">                 bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln334">                              BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln335">               }</a>
<a name="ln336"> </a>
<a name="ln337">	      else</a>
<a name="ln338">		BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln339">	    }</a>
<a name="ln340">	}</a>
<a name="ln341">      else</a>
<a name="ln342">	{</a>
<a name="ln343">	  /* Not doign confederation before, so reset every non-local</a>
<a name="ln344">	     session */</a>
<a name="ln345">	  if (peer_sort (peer) != BGP_PEER_IBGP)</a>
<a name="ln346">	    {</a>
<a name="ln347">	      /* Reset the local_as to be our EBGP one */</a>
<a name="ln348">	      if (peer_sort (peer) == BGP_PEER_EBGP)</a>
<a name="ln349">		peer-&gt;local_as = as;</a>
<a name="ln350">	      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln351">               {</a>
<a name="ln352">                 peer-&gt;last_reset = PEER_DOWN_CONFED_ID_CHANGE;</a>
<a name="ln353">                 bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln354">                              BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln355">               }</a>
<a name="ln356">	      else</a>
<a name="ln357">		BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln358">	    }</a>
<a name="ln359">	}</a>
<a name="ln360">    }</a>
<a name="ln361">  return 0;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">int</a>
<a name="ln365">bgp_confederation_id_unset (struct bgp *bgp)</a>
<a name="ln366">{</a>
<a name="ln367">  struct peer *peer;</a>
<a name="ln368">  struct listnode *node, *nnode;</a>
<a name="ln369"> </a>
<a name="ln370">  bgp-&gt;confed_id = 0;</a>
<a name="ln371">  bgp_config_unset (bgp, BGP_CONFIG_CONFEDERATION);</a>
<a name="ln372">      </a>
<a name="ln373">  for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln374">    {</a>
<a name="ln375">      /* We're looking for peers who's AS is not local */</a>
<a name="ln376">      if (peer_sort (peer) != BGP_PEER_IBGP)</a>
<a name="ln377">	{</a>
<a name="ln378">	  peer-&gt;local_as = bgp-&gt;as;</a>
<a name="ln379">	  if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln380">           {</a>
<a name="ln381">             peer-&gt;last_reset = PEER_DOWN_CONFED_ID_CHANGE;</a>
<a name="ln382">             bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln383">                              BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln384">           }</a>
<a name="ln385"> </a>
<a name="ln386">	  else</a>
<a name="ln387">	    BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln388">	}</a>
<a name="ln389">    }</a>
<a name="ln390">  return 0;</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">/* Is an AS part of the confed or not? */</a>
<a name="ln394">int</a>
<a name="ln395">bgp_confederation_peers_check (struct bgp *bgp, as_t as)</a>
<a name="ln396">{</a>
<a name="ln397">  int i;</a>
<a name="ln398"> </a>
<a name="ln399">  if (! bgp)</a>
<a name="ln400">    return 0;</a>
<a name="ln401"> </a>
<a name="ln402">  for (i = 0; i &lt; bgp-&gt;confed_peers_cnt; i++)</a>
<a name="ln403">    if (bgp-&gt;confed_peers[i] == as)</a>
<a name="ln404">      return 1;</a>
<a name="ln405">  </a>
<a name="ln406">  return 0;</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">/* Add an AS to the confederation set.  */</a>
<a name="ln410">int</a>
<a name="ln411">bgp_confederation_peers_add (struct bgp *bgp, as_t as)</a>
<a name="ln412">{</a>
<a name="ln413">  struct peer *peer;</a>
<a name="ln414">  struct listnode *node, *nnode;</a>
<a name="ln415"> </a>
<a name="ln416">  if (! bgp)</a>
<a name="ln417">    return BGP_ERR_INVALID_BGP;</a>
<a name="ln418"> </a>
<a name="ln419">  if (bgp-&gt;as == as)</a>
<a name="ln420">    return BGP_ERR_INVALID_AS;</a>
<a name="ln421"> </a>
<a name="ln422">  if (bgp_confederation_peers_check (bgp, as))</a>
<a name="ln423">    return -1;</a>
<a name="ln424"> </a>
<a name="ln425">  if (bgp-&gt;confed_peers)</a>
<a name="ln426">    bgp-&gt;confed_peers = XREALLOC (MTYPE_BGP_CONFED_LIST, </a>
<a name="ln427">				  bgp-&gt;confed_peers,</a>
<a name="ln428">				  (bgp-&gt;confed_peers_cnt + 1) * sizeof (as_t));</a>
<a name="ln429">  else</a>
<a name="ln430">    bgp-&gt;confed_peers = XMALLOC (MTYPE_BGP_CONFED_LIST, </a>
<a name="ln431">				 (bgp-&gt;confed_peers_cnt + 1) * sizeof (as_t));</a>
<a name="ln432"> </a>
<a name="ln433">  bgp-&gt;confed_peers[bgp-&gt;confed_peers_cnt] = as;</a>
<a name="ln434">  bgp-&gt;confed_peers_cnt++;</a>
<a name="ln435"> </a>
<a name="ln436">  if (bgp_config_check (bgp, BGP_CONFIG_CONFEDERATION))</a>
<a name="ln437">    {</a>
<a name="ln438">      for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln439">	{</a>
<a name="ln440">	  if (peer-&gt;as == as)</a>
<a name="ln441">	    {</a>
<a name="ln442">	      peer-&gt;local_as = bgp-&gt;as;</a>
<a name="ln443">	      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln444">               {</a>
<a name="ln445">                 peer-&gt;last_reset = PEER_DOWN_CONFED_PEER_CHANGE;</a>
<a name="ln446">                 bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln447">                                  BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln448">               }</a>
<a name="ln449">	      else</a>
<a name="ln450">	        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln451">	    }</a>
<a name="ln452">	}</a>
<a name="ln453">    }</a>
<a name="ln454">  return 0;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">/* Delete an AS from the confederation set.  */</a>
<a name="ln458">int</a>
<a name="ln459">bgp_confederation_peers_remove (struct bgp *bgp, as_t as)</a>
<a name="ln460">{</a>
<a name="ln461">  int i;</a>
<a name="ln462">  int j;</a>
<a name="ln463">  struct peer *peer;</a>
<a name="ln464">  struct listnode *node, *nnode;</a>
<a name="ln465"> </a>
<a name="ln466">  if (! bgp)</a>
<a name="ln467">    return -1;</a>
<a name="ln468"> </a>
<a name="ln469">  if (! bgp_confederation_peers_check (bgp, as))</a>
<a name="ln470">    return -1;</a>
<a name="ln471"> </a>
<a name="ln472">  for (i = 0; i &lt; bgp-&gt;confed_peers_cnt; i++)</a>
<a name="ln473">    if (bgp-&gt;confed_peers[i] == as)</a>
<a name="ln474">      for(j = i + 1; j &lt; bgp-&gt;confed_peers_cnt; j++)</a>
<a name="ln475">	bgp-&gt;confed_peers[j - 1] = bgp-&gt;confed_peers[j];</a>
<a name="ln476"> </a>
<a name="ln477">  bgp-&gt;confed_peers_cnt--;</a>
<a name="ln478"> </a>
<a name="ln479">  if (bgp-&gt;confed_peers_cnt == 0)</a>
<a name="ln480">    {</a>
<a name="ln481">      if (bgp-&gt;confed_peers)</a>
<a name="ln482">	XFREE (MTYPE_BGP_CONFED_LIST, bgp-&gt;confed_peers);</a>
<a name="ln483">      bgp-&gt;confed_peers = NULL;</a>
<a name="ln484">    }</a>
<a name="ln485">  else</a>
<a name="ln486">    bgp-&gt;confed_peers = XREALLOC (MTYPE_BGP_CONFED_LIST,</a>
<a name="ln487">				  bgp-&gt;confed_peers,</a>
<a name="ln488">				  bgp-&gt;confed_peers_cnt * sizeof (as_t));</a>
<a name="ln489"> </a>
<a name="ln490">  /* Now reset any peer who's remote AS has just been removed from the</a>
<a name="ln491">     CONFED */</a>
<a name="ln492">  if (bgp_config_check (bgp, BGP_CONFIG_CONFEDERATION))</a>
<a name="ln493">    {</a>
<a name="ln494">      for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln495">	{</a>
<a name="ln496">	  if (peer-&gt;as == as)</a>
<a name="ln497">	    {</a>
<a name="ln498">	      peer-&gt;local_as = bgp-&gt;confed_id;</a>
<a name="ln499">	      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln500">               {</a>
<a name="ln501">                 peer-&gt;last_reset = PEER_DOWN_CONFED_PEER_CHANGE;</a>
<a name="ln502">                 bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln503">                                  BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln504">               }</a>
<a name="ln505">	      else</a>
<a name="ln506">		BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln507">	    }</a>
<a name="ln508">	}</a>
<a name="ln509">    }</a>
<a name="ln510"> </a>
<a name="ln511">  return 0;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/* Local preference configuration.  */</a>
<a name="ln515">int</a>
<a name="ln516">bgp_default_local_preference_set (struct bgp *bgp, u_int32_t local_pref)</a>
<a name="ln517">{</a>
<a name="ln518">  if (! bgp)</a>
<a name="ln519">    return -1;</a>
<a name="ln520"> </a>
<a name="ln521">  bgp-&gt;default_local_pref = local_pref;</a>
<a name="ln522"> </a>
<a name="ln523">  return 0;</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">int</a>
<a name="ln527">bgp_default_local_preference_unset (struct bgp *bgp)</a>
<a name="ln528">{</a>
<a name="ln529">  if (! bgp)</a>
<a name="ln530">    return -1;</a>
<a name="ln531"> </a>
<a name="ln532">  bgp-&gt;default_local_pref = BGP_DEFAULT_LOCAL_PREF;</a>
<a name="ln533"> </a>
<a name="ln534">  return 0;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">/* If peer is RSERVER_CLIENT in at least one address family and is not member</a>
<a name="ln538">    of a peer_group for that family, return 1.</a>
<a name="ln539">    Used to check wether the peer is included in list bgp-&gt;rsclient. */</a>
<a name="ln540">int</a>
<a name="ln541">peer_rsclient_active (struct peer *peer)</a>
<a name="ln542">{</a>
<a name="ln543">  int i;</a>
<a name="ln544">  int j;</a>
<a name="ln545"> </a>
<a name="ln546">  for (i=AFI_IP; i &lt; AFI_MAX; i++)</a>
<a name="ln547">    for (j=SAFI_UNICAST; j &lt; SAFI_MAX; j++)</a>
<a name="ln548">      if (CHECK_FLAG(peer-&gt;af_flags[i][j], PEER_FLAG_RSERVER_CLIENT)</a>
<a name="ln549">            &amp;&amp; ! peer-&gt;af_group[i][j])</a>
<a name="ln550">        return 1;</a>
<a name="ln551">  return 0;</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">/* Peer comparison function for sorting.  */</a>
<a name="ln555">static int</a>
<a name="ln556">peer_cmp (struct peer *p1, struct peer *p2)</a>
<a name="ln557">{</a>
<a name="ln558">  return sockunion_cmp (&amp;p1-&gt;su, &amp;p2-&gt;su);</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">int</a>
<a name="ln562">peer_af_flag_check (struct peer *peer, afi_t afi, safi_t safi, u_int32_t flag)</a>
<a name="ln563">{</a>
<a name="ln564">  return CHECK_FLAG (peer-&gt;af_flags[afi][safi], flag);</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">/* Reset all address family specific configuration.  */</a>
<a name="ln568">static void</a>
<a name="ln569">peer_af_flag_reset (struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln570">{</a>
<a name="ln571">  int i;</a>
<a name="ln572">  struct bgp_filter *filter;</a>
<a name="ln573">  char orf_name[BUFSIZ];</a>
<a name="ln574"> </a>
<a name="ln575">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln576"> </a>
<a name="ln577">  /* Clear neighbor filter and route-map */</a>
<a name="ln578">  for (i = FILTER_IN; i &lt; FILTER_MAX; i++)</a>
<a name="ln579">    {</a>
<a name="ln580">      if (filter-&gt;dlist[i].name)</a>
<a name="ln581">	{</a>
<a name="ln582">	  free (filter-&gt;dlist[i].name);</a>
<a name="ln583">	  filter-&gt;dlist[i].name = NULL;</a>
<a name="ln584">	}</a>
<a name="ln585">      if (filter-&gt;plist[i].name)</a>
<a name="ln586">	{</a>
<a name="ln587">	  free (filter-&gt;plist[i].name);</a>
<a name="ln588">	  filter-&gt;plist[i].name = NULL; </a>
<a name="ln589">	}</a>
<a name="ln590">      if (filter-&gt;aslist[i].name)</a>
<a name="ln591">	{</a>
<a name="ln592">	  free (filter-&gt;aslist[i].name);</a>
<a name="ln593">	  filter-&gt;aslist[i].name = NULL;</a>
<a name="ln594">	}</a>
<a name="ln595">   }</a>
<a name="ln596"> for (i = RMAP_IN; i &lt; RMAP_MAX; i++)</a>
<a name="ln597">       {</a>
<a name="ln598">      if (filter-&gt;map[i].name)</a>
<a name="ln599">	{</a>
<a name="ln600">	  free (filter-&gt;map[i].name);</a>
<a name="ln601">	  filter-&gt;map[i].name = NULL;</a>
<a name="ln602">	}</a>
<a name="ln603">    }</a>
<a name="ln604"> </a>
<a name="ln605">  /* Clear unsuppress map.  */</a>
<a name="ln606">  if (filter-&gt;usmap.name)</a>
<a name="ln607">    free (filter-&gt;usmap.name);</a>
<a name="ln608">  filter-&gt;usmap.name = NULL;</a>
<a name="ln609">  filter-&gt;usmap.map = NULL;</a>
<a name="ln610"> </a>
<a name="ln611">  /* Clear neighbor's all address family flags.  */</a>
<a name="ln612">  peer-&gt;af_flags[afi][safi] = 0;</a>
<a name="ln613"> </a>
<a name="ln614">  /* Clear neighbor's all address family sflags. */</a>
<a name="ln615">  peer-&gt;af_sflags[afi][safi] = 0;</a>
<a name="ln616"> </a>
<a name="ln617">  /* Clear neighbor's all address family capabilities. */</a>
<a name="ln618">  peer-&gt;af_cap[afi][safi] = 0;</a>
<a name="ln619"> </a>
<a name="ln620">  /* Clear ORF info */</a>
<a name="ln621">  peer-&gt;orf_plist[afi][safi] = NULL;</a>
<a name="ln622">  sprintf (orf_name, &quot;%s.%d.%d&quot;, peer-&gt;host, afi, safi);</a>
<a name="ln623">  prefix_bgp_orf_remove_all (afi, orf_name);</a>
<a name="ln624"> </a>
<a name="ln625">  /* Set default neighbor send-community.  */</a>
<a name="ln626">  if (! bgp_option_check (BGP_OPT_CONFIG_CISCO))</a>
<a name="ln627">    {</a>
<a name="ln628">      SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY);</a>
<a name="ln629">      SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY);</a>
<a name="ln630">      SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SEND_LARGE_COMMUNITY);</a>
<a name="ln631">    }</a>
<a name="ln632"> </a>
<a name="ln633">  /* Clear neighbor default_originate_rmap */</a>
<a name="ln634">  if (peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln635">    free (peer-&gt;default_rmap[afi][safi].name);</a>
<a name="ln636">  peer-&gt;default_rmap[afi][safi].name = NULL;</a>
<a name="ln637">  peer-&gt;default_rmap[afi][safi].map = NULL;</a>
<a name="ln638"> </a>
<a name="ln639">  /* Clear neighbor maximum-prefix */</a>
<a name="ln640">  peer-&gt;pmax[afi][safi] = 0;</a>
<a name="ln641">  peer-&gt;pmax_threshold[afi][safi] = MAXIMUM_PREFIX_THRESHOLD_DEFAULT;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">/* peer global config reset */</a>
<a name="ln645">static void</a>
<a name="ln646">peer_global_config_reset (struct peer *peer)</a>
<a name="ln647">{</a>
<a name="ln648">  peer-&gt;weight = 0;</a>
<a name="ln649">  peer-&gt;change_local_as = 0;</a>
<a name="ln650">  peer-&gt;ttl = 0;</a>
<a name="ln651">  peer-&gt;gtsm_hops = 0;</a>
<a name="ln652">  if (peer-&gt;update_source)</a>
<a name="ln653">    {</a>
<a name="ln654">      sockunion_free (peer-&gt;update_source);</a>
<a name="ln655">      peer-&gt;update_source = NULL;</a>
<a name="ln656">    }</a>
<a name="ln657">  if (peer-&gt;update_if)</a>
<a name="ln658">    {</a>
<a name="ln659">      XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln660">      peer-&gt;update_if = NULL;</a>
<a name="ln661">    }</a>
<a name="ln662"> </a>
<a name="ln663">  if (peer_sort (peer) == BGP_PEER_IBGP)</a>
<a name="ln664">    peer-&gt;v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;</a>
<a name="ln665">  else</a>
<a name="ln666">    peer-&gt;v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;</a>
<a name="ln667"> </a>
<a name="ln668">  peer-&gt;flags = 0;</a>
<a name="ln669">  peer-&gt;config = 0;</a>
<a name="ln670">  peer-&gt;holdtime = 0;</a>
<a name="ln671">  peer-&gt;keepalive = 0;</a>
<a name="ln672">  peer-&gt;connect = 0;</a>
<a name="ln673">  peer-&gt;v_connect = BGP_DEFAULT_CONNECT_RETRY;</a>
<a name="ln674">}</a>
<a name="ln675"> </a>
<a name="ln676">/* Check peer's AS number and determines if this peer is IBGP or EBGP */</a>
<a name="ln677">static bgp_peer_sort_t</a>
<a name="ln678">peer_calc_sort (struct peer *peer)</a>
<a name="ln679">{</a>
<a name="ln680">  struct bgp *bgp;</a>
<a name="ln681"> </a>
<a name="ln682">  bgp = peer-&gt;bgp;</a>
<a name="ln683"> </a>
<a name="ln684">  /* Peer-group */</a>
<a name="ln685">  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln686">    {</a>
<a name="ln687">      if (peer-&gt;as)</a>
<a name="ln688">	return (bgp-&gt;as == peer-&gt;as ? BGP_PEER_IBGP : BGP_PEER_EBGP);</a>
<a name="ln689">      else</a>
<a name="ln690">	{</a>
<a name="ln691">	  struct peer *peer1;</a>
<a name="ln692">	  peer1 = listnode_head (peer-&gt;group-&gt;peer);</a>
<a name="ln693">	  if (peer1)</a>
<a name="ln694">	    return (peer1-&gt;local_as == peer1-&gt;as </a>
<a name="ln695">		    ? BGP_PEER_IBGP : BGP_PEER_EBGP);</a>
<a name="ln696">	} </a>
<a name="ln697">      return BGP_PEER_INTERNAL;</a>
<a name="ln698">    }</a>
<a name="ln699"> </a>
<a name="ln700">  /* Normal peer */</a>
<a name="ln701">  if (bgp &amp;&amp; CHECK_FLAG (bgp-&gt;config, BGP_CONFIG_CONFEDERATION))</a>
<a name="ln702">    {</a>
<a name="ln703">      if (peer-&gt;local_as == 0)</a>
<a name="ln704">	return BGP_PEER_INTERNAL;</a>
<a name="ln705"> </a>
<a name="ln706">      if (peer-&gt;local_as == peer-&gt;as)</a>
<a name="ln707">	{</a>
<a name="ln708">	  if (peer-&gt;local_as == bgp-&gt;confed_id)</a>
<a name="ln709">	    return BGP_PEER_EBGP;</a>
<a name="ln710">	  else</a>
<a name="ln711">	    return BGP_PEER_IBGP;</a>
<a name="ln712">	}</a>
<a name="ln713"> </a>
<a name="ln714">      if (bgp_confederation_peers_check (bgp, peer-&gt;as))</a>
<a name="ln715">	return BGP_PEER_CONFED;</a>
<a name="ln716"> </a>
<a name="ln717">      return BGP_PEER_EBGP;</a>
<a name="ln718">    }</a>
<a name="ln719">  else</a>
<a name="ln720">    {</a>
<a name="ln721">      return (peer-&gt;local_as == 0</a>
<a name="ln722">	      ? BGP_PEER_INTERNAL : peer-&gt;local_as == peer-&gt;as</a>
<a name="ln723">	      ? BGP_PEER_IBGP : BGP_PEER_EBGP);</a>
<a name="ln724">    }</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">/* Calculate and cache the peer &quot;sort&quot; */</a>
<a name="ln728">bgp_peer_sort_t</a>
<a name="ln729">peer_sort (struct peer *peer)</a>
<a name="ln730">{</a>
<a name="ln731">  peer-&gt;sort = peer_calc_sort (peer);</a>
<a name="ln732">  return peer-&gt;sort;</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">static void</a>
<a name="ln736">peer_free (struct peer *peer)</a>
<a name="ln737">{</a>
<a name="ln738">  assert (peer-&gt;status == Deleted);</a>
<a name="ln739"> </a>
<a name="ln740">  /* this /ought/ to have been done already through bgp_stop earlier,</a>
<a name="ln741">   * but just to be sure.. </a>
<a name="ln742">   */</a>
<a name="ln743">  bgp_timer_set (peer);</a>
<a name="ln744">  BGP_READ_OFF (peer-&gt;t_read);</a>
<a name="ln745">  BGP_WRITE_OFF (peer-&gt;t_write);</a>
<a name="ln746">  BGP_EVENT_FLUSH (peer);</a>
<a name="ln747">  </a>
<a name="ln748">  if (peer-&gt;desc)</a>
<a name="ln749">    {</a>
<a name="ln750">      XFREE (MTYPE_PEER_DESC, peer-&gt;desc);</a>
<a name="ln751">      peer-&gt;desc = NULL;</a>
<a name="ln752">    }</a>
<a name="ln753">  </a>
<a name="ln754">  /* Free allocated host character. */</a>
<a name="ln755">  if (peer-&gt;host)</a>
<a name="ln756">    {</a>
<a name="ln757">      XFREE (MTYPE_BGP_PEER_HOST, peer-&gt;host);</a>
<a name="ln758">      peer-&gt;host = NULL;</a>
<a name="ln759">    }</a>
<a name="ln760"> </a>
<a name="ln761">  /* Update source configuration.  */</a>
<a name="ln762">  if (peer-&gt;update_source)</a>
<a name="ln763">    {</a>
<a name="ln764">      sockunion_free (peer-&gt;update_source);</a>
<a name="ln765">      peer-&gt;update_source = NULL;</a>
<a name="ln766">    }</a>
<a name="ln767">  </a>
<a name="ln768">  if (peer-&gt;update_if)</a>
<a name="ln769">    {</a>
<a name="ln770">      XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln771">      peer-&gt;update_if = NULL;</a>
<a name="ln772">    }</a>
<a name="ln773">    </a>
<a name="ln774">  if (peer-&gt;clear_node_queue)</a>
<a name="ln775">    {</a>
<a name="ln776">      work_queue_free(peer-&gt;clear_node_queue);</a>
<a name="ln777">      peer-&gt;clear_node_queue = NULL;</a>
<a name="ln778">    }</a>
<a name="ln779">  </a>
<a name="ln780">  if (peer-&gt;notify.data)</a>
<a name="ln781">    XFREE(MTYPE_TMP, peer-&gt;notify.data);</a>
<a name="ln782">  </a>
<a name="ln783">  bgp_sync_delete (peer);</a>
<a name="ln784"> </a>
<a name="ln785">  bgp_unlock(peer-&gt;bgp);</a>
<a name="ln786"> </a>
<a name="ln787">  memset (peer, 0, sizeof (struct peer));</a>
<a name="ln788">  </a>
<a name="ln789">  XFREE (MTYPE_BGP_PEER, peer);</a>
<a name="ln790">}</a>
<a name="ln791">                                                </a>
<a name="ln792">/* increase reference count on a struct peer */</a>
<a name="ln793">struct peer *</a>
<a name="ln794">peer_lock_with_caller (const char *name, struct peer *peer)</a>
<a name="ln795">{</a>
<a name="ln796">  assert (peer &amp;&amp; (peer-&gt;lock &gt;= 0));</a>
<a name="ln797"> </a>
<a name="ln798">#if 0</a>
<a name="ln799">  zlog_debug(&quot;%s peer_lock %p %d&quot;, name, peer, peer-&gt;lock);</a>
<a name="ln800">#endif</a>
<a name="ln801"> </a>
<a name="ln802">  peer-&gt;lock++;</a>
<a name="ln803">  </a>
<a name="ln804">  return peer;</a>
<a name="ln805">}</a>
<a name="ln806"> </a>
<a name="ln807">/* decrease reference count on a struct peer</a>
<a name="ln808"> * struct peer is freed and NULL returned if last reference</a>
<a name="ln809"> */</a>
<a name="ln810">struct peer *</a>
<a name="ln811">peer_unlock_with_caller (const char *name, struct peer *peer)</a>
<a name="ln812">{</a>
<a name="ln813">  assert (peer &amp;&amp; (peer-&gt;lock &gt; 0));</a>
<a name="ln814"> </a>
<a name="ln815">#if 0</a>
<a name="ln816">  zlog_debug(&quot;%s peer_unlock %p %d&quot;, name, peer, peer-&gt;lock);</a>
<a name="ln817">#endif</a>
<a name="ln818"> </a>
<a name="ln819">  peer-&gt;lock--;</a>
<a name="ln820">  </a>
<a name="ln821">  if (peer-&gt;lock == 0)</a>
<a name="ln822">    {</a>
<a name="ln823">      peer_free (peer);</a>
<a name="ln824">      return NULL;</a>
<a name="ln825">    }</a>
<a name="ln826"> </a>
<a name="ln827">  return peer;</a>
<a name="ln828">}</a>
<a name="ln829">  </a>
<a name="ln830">/* Allocate new peer object, implicitely locked.  */</a>
<a name="ln831">static struct peer *</a>
<a name="ln832">peer_new (struct bgp *bgp)</a>
<a name="ln833">{</a>
<a name="ln834">  afi_t afi;</a>
<a name="ln835">  safi_t safi;</a>
<a name="ln836">  struct peer *peer;</a>
<a name="ln837">  struct servent *sp;</a>
<a name="ln838">  </a>
<a name="ln839">  /* bgp argument is absolutely required */</a>
<a name="ln840">  assert (bgp);</a>
<a name="ln841">  if (!bgp)</a>
<a name="ln842">    return NULL;</a>
<a name="ln843">  </a>
<a name="ln844">  /* Allocate new peer. */</a>
<a name="ln845">  peer = XCALLOC (MTYPE_BGP_PEER, sizeof (struct peer));</a>
<a name="ln846"> </a>
<a name="ln847">  /* Set default value. */</a>
<a name="ln848">  peer-&gt;fd = -1;</a>
<a name="ln849">  peer-&gt;v_start = BGP_INIT_START_TIMER;</a>
<a name="ln850">  peer-&gt;v_connect = BGP_DEFAULT_CONNECT_RETRY;</a>
<a name="ln851">  peer-&gt;status = Idle;</a>
<a name="ln852">  peer-&gt;ostatus = Idle;</a>
<a name="ln853">  peer-&gt;weight = 0;</a>
<a name="ln854">  peer-&gt;password = NULL;</a>
<a name="ln855">  peer-&gt;bgp = bgp;</a>
<a name="ln856">  peer = peer_lock (peer); /* initial reference */</a>
<a name="ln857">  bgp_lock (bgp);</a>
<a name="ln858"> </a>
<a name="ln859">  /* Set default flags.  */</a>
<a name="ln860">  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln861">    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln862">      {</a>
<a name="ln863">	if (! bgp_option_check (BGP_OPT_CONFIG_CISCO))</a>
<a name="ln864">	  {</a>
<a name="ln865">	    SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY);</a>
<a name="ln866">	    SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY);</a>
<a name="ln867">	    SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SEND_LARGE_COMMUNITY);</a>
<a name="ln868">	  }</a>
<a name="ln869">	peer-&gt;orf_plist[afi][safi] = NULL;</a>
<a name="ln870">      }</a>
<a name="ln871">  SET_FLAG (peer-&gt;sflags, PEER_STATUS_CAPABILITY_OPEN);</a>
<a name="ln872"> </a>
<a name="ln873">  /* Create buffers.  */</a>
<a name="ln874">  peer-&gt;ibuf = stream_new (BGP_MAX_PACKET_SIZE);</a>
<a name="ln875">  peer-&gt;obuf = stream_fifo_new ();</a>
<a name="ln876"> </a>
<a name="ln877">  /* We use a larger buffer for peer-&gt;work in the event that:</a>
<a name="ln878">   * - We RX a BGP_UPDATE where the attributes alone are just</a>
<a name="ln879">   *   under BGP_MAX_PACKET_SIZE</a>
<a name="ln880">   * - The user configures an outbound route-map that does many as-path</a>
<a name="ln881">   *   prepends or adds many communities.  At most they can have CMD_ARGC_MAX</a>
<a name="ln882">   *   args in a route-map so there is a finite limit on how large they can</a>
<a name="ln883">   *   make the attributes.</a>
<a name="ln884">   *</a>
<a name="ln885">   * Having a buffer with BGP_MAX_PACKET_SIZE_OVERFLOW allows us to avoid bounds</a>
<a name="ln886">   * checking for every single attribute as we construct an UPDATE.</a>
<a name="ln887">   */</a>
<a name="ln888">  peer-&gt;work = stream_new (BGP_MAX_PACKET_SIZE + BGP_MAX_PACKET_SIZE_OVERFLOW);</a>
<a name="ln889">  peer-&gt;scratch = stream_new (BGP_MAX_PACKET_SIZE);</a>
<a name="ln890"> </a>
<a name="ln891">  bgp_sync_init (peer);</a>
<a name="ln892"> </a>
<a name="ln893">  /* Get service port number.  */</a>
<a name="ln894">  sp = getservbyname (&quot;bgp&quot;, &quot;tcp&quot;);</a>
<a name="ln895">  peer-&gt;port = (sp == NULL) ? BGP_PORT_DEFAULT : ntohs (sp-&gt;s_port);</a>
<a name="ln896"> </a>
<a name="ln897">  return peer;</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">/* Create new BGP peer.  */</a>
<a name="ln901">static struct peer *</a>
<a name="ln902">peer_create (union sockunion *su, struct bgp *bgp, as_t local_as,</a>
<a name="ln903">	     as_t remote_as, afi_t afi, safi_t safi)</a>
<a name="ln904">{</a>
<a name="ln905">  int active;</a>
<a name="ln906">  struct peer *peer;</a>
<a name="ln907">  char buf[SU_ADDRSTRLEN];</a>
<a name="ln908"> </a>
<a name="ln909">  peer = peer_new (bgp);</a>
<a name="ln910">  peer-&gt;su = *su;</a>
<a name="ln911">  peer-&gt;local_as = local_as;</a>
<a name="ln912">  peer-&gt;as = remote_as;</a>
<a name="ln913">  peer-&gt;local_id = bgp-&gt;router_id;</a>
<a name="ln914">  peer-&gt;v_holdtime = bgp-&gt;default_holdtime;</a>
<a name="ln915">  peer-&gt;v_keepalive = bgp-&gt;default_keepalive;</a>
<a name="ln916">  if (peer_sort (peer) == BGP_PEER_IBGP)</a>
<a name="ln917">    peer-&gt;v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;</a>
<a name="ln918">  else</a>
<a name="ln919">    peer-&gt;v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;</a>
<a name="ln920">    </a>
<a name="ln921">  peer = peer_lock (peer); /* bgp peer list reference */</a>
<a name="ln922">  listnode_add_sort (bgp-&gt;peer, peer);</a>
<a name="ln923"> </a>
<a name="ln924">  active = peer_active (peer);</a>
<a name="ln925"> </a>
<a name="ln926">  if (afi &amp;&amp; safi)</a>
<a name="ln927">    peer-&gt;afc[afi][safi] = 1;</a>
<a name="ln928"> </a>
<a name="ln929">  /* Last read and reset time set */</a>
<a name="ln930">  peer-&gt;readtime = peer-&gt;resettime = bgp_clock ();</a>
<a name="ln931"> </a>
<a name="ln932">  /* Make peer's address string. */</a>
<a name="ln933">  sockunion2str (su, buf, SU_ADDRSTRLEN);</a>
<a name="ln934">  peer-&gt;host = XSTRDUP (MTYPE_BGP_PEER_HOST, buf);</a>
<a name="ln935"> </a>
<a name="ln936">  /* Set up peer's events and timers. */</a>
<a name="ln937">  if (! active &amp;&amp; peer_active (peer))</a>
<a name="ln938">    bgp_timer_set (peer);</a>
<a name="ln939"> </a>
<a name="ln940">  return peer;</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">/* Make accept BGP peer.  Called from bgp_accept (). */</a>
<a name="ln944">struct peer *</a>
<a name="ln945">peer_create_accept (struct bgp *bgp)</a>
<a name="ln946">{</a>
<a name="ln947">  struct peer *peer;</a>
<a name="ln948"> </a>
<a name="ln949">  peer = peer_new (bgp);</a>
<a name="ln950">  </a>
<a name="ln951">  peer = peer_lock (peer); /* bgp peer list reference */</a>
<a name="ln952">  listnode_add_sort (bgp-&gt;peer, peer);</a>
<a name="ln953"> </a>
<a name="ln954">  return peer;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957">/* Change peer's AS number.  */</a>
<a name="ln958">static void</a>
<a name="ln959">peer_as_change (struct peer *peer, as_t as)</a>
<a name="ln960">{</a>
<a name="ln961">  struct peer *conf;</a>
<a name="ln962"> </a>
<a name="ln963">  /* Stop peer. */</a>
<a name="ln964">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln965">    {</a>
<a name="ln966">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln967">       {</a>
<a name="ln968">         peer-&gt;last_reset = PEER_DOWN_REMOTE_AS_CHANGE;</a>
<a name="ln969">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln970">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln971">       }</a>
<a name="ln972">      else</a>
<a name="ln973">	BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln974">    }</a>
<a name="ln975">  peer-&gt;as = as;</a>
<a name="ln976"> </a>
<a name="ln977">  if (bgp_config_check (peer-&gt;bgp, BGP_CONFIG_CONFEDERATION)</a>
<a name="ln978">      &amp;&amp; ! bgp_confederation_peers_check (peer-&gt;bgp, as)</a>
<a name="ln979">      &amp;&amp; peer-&gt;bgp-&gt;as != as)</a>
<a name="ln980">    peer-&gt;local_as = peer-&gt;bgp-&gt;confed_id;</a>
<a name="ln981">  else</a>
<a name="ln982">    peer-&gt;local_as = peer-&gt;bgp-&gt;as;</a>
<a name="ln983"> </a>
<a name="ln984">  /* Advertisement-interval reset */</a>
<a name="ln985">  conf = NULL;</a>
<a name="ln986">  if (peer-&gt;group)</a>
<a name="ln987">    conf = peer-&gt;group-&gt;conf;</a>
<a name="ln988"> </a>
<a name="ln989">  if (conf &amp;&amp; CHECK_FLAG (conf-&gt;config, PEER_CONFIG_ROUTEADV))</a>
<a name="ln990">      peer-&gt;v_routeadv = conf-&gt;routeadv;</a>
<a name="ln991">  else</a>
<a name="ln992">    if (peer_sort (peer) == BGP_PEER_IBGP)</a>
<a name="ln993">      peer-&gt;v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;</a>
<a name="ln994">    else</a>
<a name="ln995">      peer-&gt;v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;</a>
<a name="ln996"> </a>
<a name="ln997">  /* reflector-client reset */</a>
<a name="ln998">  if (peer_sort (peer) != BGP_PEER_IBGP)</a>
<a name="ln999">    {</a>
<a name="ln1000">      UNSET_FLAG (peer-&gt;af_flags[AFI_IP][SAFI_UNICAST],</a>
<a name="ln1001">		  PEER_FLAG_REFLECTOR_CLIENT);</a>
<a name="ln1002">      UNSET_FLAG (peer-&gt;af_flags[AFI_IP][SAFI_MULTICAST],</a>
<a name="ln1003">		  PEER_FLAG_REFLECTOR_CLIENT);</a>
<a name="ln1004">      UNSET_FLAG (peer-&gt;af_flags[AFI_IP][SAFI_MPLS_VPN],</a>
<a name="ln1005">		  PEER_FLAG_REFLECTOR_CLIENT);</a>
<a name="ln1006">      UNSET_FLAG (peer-&gt;af_flags[AFI_IP][SAFI_ENCAP],</a>
<a name="ln1007">		  PEER_FLAG_REFLECTOR_CLIENT);</a>
<a name="ln1008">      UNSET_FLAG (peer-&gt;af_flags[AFI_IP6][SAFI_UNICAST],</a>
<a name="ln1009">		  PEER_FLAG_REFLECTOR_CLIENT);</a>
<a name="ln1010">      UNSET_FLAG (peer-&gt;af_flags[AFI_IP6][SAFI_MULTICAST],</a>
<a name="ln1011">		  PEER_FLAG_REFLECTOR_CLIENT);</a>
<a name="ln1012">      UNSET_FLAG (peer-&gt;af_flags[AFI_IP6][SAFI_MPLS_VPN],</a>
<a name="ln1013">		  PEER_FLAG_REFLECTOR_CLIENT);</a>
<a name="ln1014">      UNSET_FLAG (peer-&gt;af_flags[AFI_IP6][SAFI_ENCAP],</a>
<a name="ln1015">		  PEER_FLAG_REFLECTOR_CLIENT);</a>
<a name="ln1016">    }</a>
<a name="ln1017"> </a>
<a name="ln1018">  /* local-as reset */</a>
<a name="ln1019">  if (peer_sort (peer) != BGP_PEER_EBGP)</a>
<a name="ln1020">    {</a>
<a name="ln1021">      peer-&gt;change_local_as = 0;</a>
<a name="ln1022">      UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND);</a>
<a name="ln1023">      UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS);</a>
<a name="ln1024">    }</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">/* If peer does not exist, create new one.  If peer already exists,</a>
<a name="ln1028">   set AS number to the peer.  */</a>
<a name="ln1029">int</a>
<a name="ln1030">peer_remote_as (struct bgp *bgp, union sockunion *su, as_t *as,</a>
<a name="ln1031">		afi_t afi, safi_t safi)</a>
<a name="ln1032">{</a>
<a name="ln1033">  struct peer *peer;</a>
<a name="ln1034">  as_t local_as;</a>
<a name="ln1035"> </a>
<a name="ln1036">  peer = peer_lookup (bgp, su);</a>
<a name="ln1037"> </a>
<a name="ln1038">  if (peer)</a>
<a name="ln1039">    {</a>
<a name="ln1040">      /* When this peer is a member of peer-group.  */</a>
<a name="ln1041">      if (peer-&gt;group)</a>
<a name="ln1042">	{</a>
<a name="ln1043">	  if (peer-&gt;group-&gt;conf-&gt;as)</a>
<a name="ln1044">	    {</a>
<a name="ln1045">	      /* Return peer group's AS number.  */</a>
<a name="ln1046">	      *as = peer-&gt;group-&gt;conf-&gt;as;</a>
<a name="ln1047">	      return BGP_ERR_PEER_GROUP_MEMBER;</a>
<a name="ln1048">	    }</a>
<a name="ln1049">	  if (peer_sort (peer-&gt;group-&gt;conf) == BGP_PEER_IBGP)</a>
<a name="ln1050">	    {</a>
<a name="ln1051">	      if (bgp-&gt;as != *as)</a>
<a name="ln1052">		{</a>
<a name="ln1053">		  *as = peer-&gt;as;</a>
<a name="ln1054">		  return BGP_ERR_PEER_GROUP_PEER_TYPE_DIFFERENT;</a>
<a name="ln1055">		}</a>
<a name="ln1056">	    }</a>
<a name="ln1057">	  else</a>
<a name="ln1058">	    {</a>
<a name="ln1059">	      if (bgp-&gt;as == *as)</a>
<a name="ln1060">		{</a>
<a name="ln1061">		  *as = peer-&gt;as;</a>
<a name="ln1062">		  return BGP_ERR_PEER_GROUP_PEER_TYPE_DIFFERENT;</a>
<a name="ln1063">		}</a>
<a name="ln1064">	    }</a>
<a name="ln1065">	}</a>
<a name="ln1066"> </a>
<a name="ln1067">      /* Existing peer's AS number change. */</a>
<a name="ln1068">      if (peer-&gt;as != *as)</a>
<a name="ln1069">	peer_as_change (peer, *as);</a>
<a name="ln1070">    }</a>
<a name="ln1071">  else</a>
<a name="ln1072">    {</a>
<a name="ln1073"> </a>
<a name="ln1074">      /* If the peer is not part of our confederation, and its not an</a>
<a name="ln1075">	 iBGP peer then spoof the source AS */</a>
<a name="ln1076">      if (bgp_config_check (bgp, BGP_CONFIG_CONFEDERATION)</a>
<a name="ln1077">	  &amp;&amp; ! bgp_confederation_peers_check (bgp, *as) </a>
<a name="ln1078">	  &amp;&amp; bgp-&gt;as != *as)</a>
<a name="ln1079">	local_as = bgp-&gt;confed_id;</a>
<a name="ln1080">      else</a>
<a name="ln1081">	local_as = bgp-&gt;as;</a>
<a name="ln1082">      </a>
<a name="ln1083">      /* If this is IPv4 unicast configuration and &quot;no bgp default</a>
<a name="ln1084">         ipv4-unicast&quot; is specified. */</a>
<a name="ln1085"> </a>
<a name="ln1086">      if (bgp_flag_check (bgp, BGP_FLAG_NO_DEFAULT_IPV4)</a>
<a name="ln1087">	  &amp;&amp; afi == AFI_IP &amp;&amp; safi == SAFI_UNICAST)</a>
<a name="ln1088">	peer_create (su, bgp, local_as, *as, 0, 0); </a>
<a name="ln1089">      else</a>
<a name="ln1090">	peer_create (su, bgp, local_as, *as, afi, safi); </a>
<a name="ln1091">    }</a>
<a name="ln1092"> </a>
<a name="ln1093">  return 0;</a>
<a name="ln1094">}</a>
<a name="ln1095"> </a>
<a name="ln1096">/* Activate the peer or peer group for specified AFI and SAFI.  */</a>
<a name="ln1097">int</a>
<a name="ln1098">peer_activate (struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln1099">{</a>
<a name="ln1100">  int active;</a>
<a name="ln1101"> </a>
<a name="ln1102">  if (peer-&gt;afc[afi][safi])</a>
<a name="ln1103">    return 0;</a>
<a name="ln1104"> </a>
<a name="ln1105">  /* Activate the address family configuration. */</a>
<a name="ln1106">  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln1107">    peer-&gt;afc[afi][safi] = 1;</a>
<a name="ln1108">  else</a>
<a name="ln1109">    {</a>
<a name="ln1110">      active = peer_active (peer);</a>
<a name="ln1111"> </a>
<a name="ln1112">      peer-&gt;afc[afi][safi] = 1;</a>
<a name="ln1113"> </a>
<a name="ln1114">      if (! active &amp;&amp; peer_active (peer))</a>
<a name="ln1115">	bgp_timer_set (peer);</a>
<a name="ln1116">      else</a>
<a name="ln1117">	{</a>
<a name="ln1118">	  if (peer-&gt;status == Established)</a>
<a name="ln1119">	    {</a>
<a name="ln1120">	      if (CHECK_FLAG (peer-&gt;cap, PEER_CAP_DYNAMIC_RCV))</a>
<a name="ln1121">		{</a>
<a name="ln1122">		  peer-&gt;afc_adv[afi][safi] = 1;</a>
<a name="ln1123">		  bgp_capability_send (peer, afi, safi,</a>
<a name="ln1124">				       CAPABILITY_CODE_MP,</a>
<a name="ln1125">				       CAPABILITY_ACTION_SET);</a>
<a name="ln1126">		  if (peer-&gt;afc_recv[afi][safi])</a>
<a name="ln1127">		    {</a>
<a name="ln1128">		      peer-&gt;afc_nego[afi][safi] = 1;</a>
<a name="ln1129">		      bgp_announce_route (peer, afi, safi);</a>
<a name="ln1130">		    }</a>
<a name="ln1131">		}</a>
<a name="ln1132">	      else</a>
<a name="ln1133">               {</a>
<a name="ln1134">                 peer-&gt;last_reset = PEER_DOWN_AF_ACTIVATE;</a>
<a name="ln1135">                 bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln1136">                                  BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln1137">               }</a>
<a name="ln1138">	    }</a>
<a name="ln1139">	}</a>
<a name="ln1140">    }</a>
<a name="ln1141">  return 0;</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">int</a>
<a name="ln1145">peer_deactivate (struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln1146">{</a>
<a name="ln1147">  struct peer_group *group;</a>
<a name="ln1148">  struct peer *peer1;</a>
<a name="ln1149">  struct listnode *node, *nnode;</a>
<a name="ln1150"> </a>
<a name="ln1151">  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln1152">    {</a>
<a name="ln1153">      group = peer-&gt;group;</a>
<a name="ln1154"> </a>
<a name="ln1155">      for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer1))</a>
<a name="ln1156">	{</a>
<a name="ln1157">	  if (peer1-&gt;af_group[afi][safi])</a>
<a name="ln1158">	    return BGP_ERR_PEER_GROUP_MEMBER_EXISTS;</a>
<a name="ln1159">	}</a>
<a name="ln1160">    }</a>
<a name="ln1161">  else</a>
<a name="ln1162">    {</a>
<a name="ln1163">      if (peer-&gt;af_group[afi][safi])</a>
<a name="ln1164">	return BGP_ERR_PEER_BELONGS_TO_GROUP;</a>
<a name="ln1165">    }</a>
<a name="ln1166"> </a>
<a name="ln1167">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln1168">    return 0;</a>
<a name="ln1169"> </a>
<a name="ln1170">  /* De-activate the address family configuration. */</a>
<a name="ln1171">  peer-&gt;afc[afi][safi] = 0;</a>
<a name="ln1172">  peer_af_flag_reset (peer, afi, safi);</a>
<a name="ln1173"> </a>
<a name="ln1174">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln1175">    {  </a>
<a name="ln1176">      if (peer-&gt;status == Established)</a>
<a name="ln1177">	{</a>
<a name="ln1178">	  if (CHECK_FLAG (peer-&gt;cap, PEER_CAP_DYNAMIC_RCV))</a>
<a name="ln1179">	    {</a>
<a name="ln1180">	      peer-&gt;afc_adv[afi][safi] = 0;</a>
<a name="ln1181">	      peer-&gt;afc_nego[afi][safi] = 0;</a>
<a name="ln1182"> </a>
<a name="ln1183">	      if (peer_active_nego (peer))</a>
<a name="ln1184">		{</a>
<a name="ln1185">		  bgp_capability_send (peer, afi, safi,</a>
<a name="ln1186">				       CAPABILITY_CODE_MP,</a>
<a name="ln1187">				       CAPABILITY_ACTION_UNSET);</a>
<a name="ln1188">		  bgp_clear_route (peer, afi, safi, BGP_CLEAR_ROUTE_NORMAL);</a>
<a name="ln1189">		  peer-&gt;pcount[afi][safi] = 0;</a>
<a name="ln1190">		}</a>
<a name="ln1191">	      else</a>
<a name="ln1192">               {</a>
<a name="ln1193">                 peer-&gt;last_reset = PEER_DOWN_NEIGHBOR_DELETE;</a>
<a name="ln1194">                 bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln1195">                                  BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln1196">               }</a>
<a name="ln1197">	    }</a>
<a name="ln1198">	  else</a>
<a name="ln1199">           {</a>
<a name="ln1200">             peer-&gt;last_reset = PEER_DOWN_NEIGHBOR_DELETE;</a>
<a name="ln1201">             bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln1202">                              BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln1203">           }</a>
<a name="ln1204">	}</a>
<a name="ln1205">    }</a>
<a name="ln1206">  return 0;</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209">int</a>
<a name="ln1210">peer_afc_set (struct peer *peer, afi_t afi, safi_t safi, int enable)</a>
<a name="ln1211">{</a>
<a name="ln1212">  if (enable)</a>
<a name="ln1213">    return peer_activate (peer, afi, safi);</a>
<a name="ln1214">  else</a>
<a name="ln1215">    return peer_deactivate (peer, afi, safi);</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">static void</a>
<a name="ln1219">peer_nsf_stop (struct peer *peer)</a>
<a name="ln1220">{</a>
<a name="ln1221">  afi_t afi;</a>
<a name="ln1222">  safi_t safi;</a>
<a name="ln1223"> </a>
<a name="ln1224">  UNSET_FLAG (peer-&gt;sflags, PEER_STATUS_NSF_WAIT);</a>
<a name="ln1225">  UNSET_FLAG (peer-&gt;sflags, PEER_STATUS_NSF_MODE);</a>
<a name="ln1226"> </a>
<a name="ln1227">  for (afi = AFI_IP ; afi &lt; AFI_MAX ; afi++)</a>
<a name="ln1228">    for (safi = SAFI_UNICAST ; safi &lt; SAFI_RESERVED_3 ; safi++)</a>
<a name="ln1229">      peer-&gt;nsf[afi][safi] = 0;</a>
<a name="ln1230"> </a>
<a name="ln1231">  if (peer-&gt;t_gr_restart)</a>
<a name="ln1232">    {</a>
<a name="ln1233">      BGP_TIMER_OFF (peer-&gt;t_gr_restart);</a>
<a name="ln1234">      if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln1235">	zlog_debug (&quot;%s graceful restart timer stopped&quot;, peer-&gt;host);</a>
<a name="ln1236">    }</a>
<a name="ln1237">  if (peer-&gt;t_gr_stale)</a>
<a name="ln1238">    {</a>
<a name="ln1239">      BGP_TIMER_OFF (peer-&gt;t_gr_stale);</a>
<a name="ln1240">      if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln1241">	zlog_debug (&quot;%s graceful restart stalepath timer stopped&quot;, peer-&gt;host);</a>
<a name="ln1242">    }</a>
<a name="ln1243">  bgp_clear_route_all (peer);</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246">/* Delete peer from confguration.</a>
<a name="ln1247"> *</a>
<a name="ln1248"> * The peer is moved to a dead-end &quot;Deleted&quot; neighbour-state, to allow</a>
<a name="ln1249"> * it to &quot;cool off&quot; and refcounts to hit 0, at which state it is freed.</a>
<a name="ln1250"> *</a>
<a name="ln1251"> * This function /should/ take care to be idempotent, to guard against</a>
<a name="ln1252"> * it being called multiple times through stray events that come in</a>
<a name="ln1253"> * that happen to result in this function being called again.  That</a>
<a name="ln1254"> * said, getting here for a &quot;Deleted&quot; peer is a bug in the neighbour</a>
<a name="ln1255"> * FSM.</a>
<a name="ln1256"> */</a>
<a name="ln1257">int</a>
<a name="ln1258">peer_delete (struct peer *peer)</a>
<a name="ln1259">{</a>
<a name="ln1260">  int i;</a>
<a name="ln1261">  afi_t afi;</a>
<a name="ln1262">  safi_t safi;</a>
<a name="ln1263">  struct bgp *bgp;</a>
<a name="ln1264">  struct bgp_filter *filter;</a>
<a name="ln1265">  struct listnode *pn;</a>
<a name="ln1266"> </a>
<a name="ln1267">  assert (peer-&gt;status != Deleted);</a>
<a name="ln1268">  </a>
<a name="ln1269">  bgp = peer-&gt;bgp;</a>
<a name="ln1270"> </a>
<a name="ln1271">  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_NSF_WAIT))</a>
<a name="ln1272">    peer_nsf_stop (peer);</a>
<a name="ln1273"> </a>
<a name="ln1274">  /* If this peer belongs to peer group, clear up the</a>
<a name="ln1275">     relationship.  */</a>
<a name="ln1276">  if (peer-&gt;group)</a>
<a name="ln1277">    {</a>
<a name="ln1278">      if ((pn = listnode_lookup (peer-&gt;group-&gt;peer, peer)))</a>
<a name="ln1279">        {</a>
<a name="ln1280">          peer = peer_unlock (peer); /* group-&gt;peer list reference */</a>
<a name="ln1281">          list_delete_node (peer-&gt;group-&gt;peer, pn);</a>
<a name="ln1282">        }</a>
<a name="ln1283">      peer-&gt;group = NULL;</a>
<a name="ln1284">    }</a>
<a name="ln1285">  </a>
<a name="ln1286">  /* Withdraw all information from routing table.  We can not use</a>
<a name="ln1287">   * BGP_EVENT_ADD (peer, BGP_Stop) at here.  Because the event is</a>
<a name="ln1288">   * executed after peer structure is deleted.</a>
<a name="ln1289">   */</a>
<a name="ln1290">  peer-&gt;last_reset = PEER_DOWN_NEIGHBOR_DELETE;</a>
<a name="ln1291">  bgp_stop (peer);</a>
<a name="ln1292">  bgp_fsm_change_status (peer, Deleted);</a>
<a name="ln1293">  </a>
<a name="ln1294">  /* Remove from NHT */</a>
<a name="ln1295">  bgp_unlink_nexthop_by_peer (peer);</a>
<a name="ln1296">  </a>
<a name="ln1297">  /* Password configuration */</a>
<a name="ln1298">  if (peer-&gt;password)</a>
<a name="ln1299">    {</a>
<a name="ln1300">      XFREE (MTYPE_PEER_PASSWORD, peer-&gt;password);</a>
<a name="ln1301">      peer-&gt;password = NULL;</a>
<a name="ln1302"> </a>
<a name="ln1303">      if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln1304">	bgp_md5_set (peer);</a>
<a name="ln1305">    }</a>
<a name="ln1306">  </a>
<a name="ln1307">  bgp_timer_set (peer); /* stops all timers for Deleted */</a>
<a name="ln1308">  </a>
<a name="ln1309">  /* Delete from all peer list. */</a>
<a name="ln1310">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP)</a>
<a name="ln1311">      &amp;&amp; (pn = listnode_lookup (bgp-&gt;peer, peer)))</a>
<a name="ln1312">    {</a>
<a name="ln1313">      peer_unlock (peer); /* bgp peer list reference */</a>
<a name="ln1314">      list_delete_node (bgp-&gt;peer, pn);</a>
<a name="ln1315">    }</a>
<a name="ln1316">      </a>
<a name="ln1317">  if (peer_rsclient_active (peer)</a>
<a name="ln1318">      &amp;&amp; (pn = listnode_lookup (bgp-&gt;rsclient, peer)))</a>
<a name="ln1319">    {</a>
<a name="ln1320">      peer_unlock (peer); /* rsclient list reference */</a>
<a name="ln1321">      list_delete_node (bgp-&gt;rsclient, pn);</a>
<a name="ln1322"> </a>
<a name="ln1323">      /* Clear our own rsclient ribs. */</a>
<a name="ln1324">      for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln1325">        for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln1326">          if (CHECK_FLAG(peer-&gt;af_flags[afi][safi],</a>
<a name="ln1327">                         PEER_FLAG_RSERVER_CLIENT))</a>
<a name="ln1328">            bgp_clear_route (peer, afi, safi, BGP_CLEAR_ROUTE_MY_RSCLIENT);</a>
<a name="ln1329">    }</a>
<a name="ln1330"> </a>
<a name="ln1331">  /* Free RIB for any family in which peer is RSERVER_CLIENT, and is not</a>
<a name="ln1332">      member of a peer_group. */</a>
<a name="ln1333">  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln1334">    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln1335">      if (peer-&gt;rib[afi][safi] &amp;&amp; ! peer-&gt;af_group[afi][safi])</a>
<a name="ln1336">        bgp_table_finish (&amp;peer-&gt;rib[afi][safi]);</a>
<a name="ln1337"> </a>
<a name="ln1338">  /* Buffers.  */</a>
<a name="ln1339">  if (peer-&gt;ibuf)</a>
<a name="ln1340">    {</a>
<a name="ln1341">      stream_free (peer-&gt;ibuf);</a>
<a name="ln1342">      peer-&gt;ibuf = NULL;</a>
<a name="ln1343">    }</a>
<a name="ln1344"> </a>
<a name="ln1345">  if (peer-&gt;obuf)</a>
<a name="ln1346">    {</a>
<a name="ln1347">      stream_fifo_free (peer-&gt;obuf);</a>
<a name="ln1348">      peer-&gt;obuf = NULL;</a>
<a name="ln1349">    }</a>
<a name="ln1350"> </a>
<a name="ln1351">  if (peer-&gt;work)</a>
<a name="ln1352">    {</a>
<a name="ln1353">      stream_free (peer-&gt;work);</a>
<a name="ln1354">      peer-&gt;work = NULL;</a>
<a name="ln1355">    }</a>
<a name="ln1356"> </a>
<a name="ln1357">  if (peer-&gt;scratch)</a>
<a name="ln1358">    {</a>
<a name="ln1359">      stream_free(peer-&gt;scratch);</a>
<a name="ln1360">      peer-&gt;scratch = NULL;</a>
<a name="ln1361">    }</a>
<a name="ln1362"> </a>
<a name="ln1363">  /* Local and remote addresses. */</a>
<a name="ln1364">  if (peer-&gt;su_local)</a>
<a name="ln1365">    {</a>
<a name="ln1366">      sockunion_free (peer-&gt;su_local);</a>
<a name="ln1367">      peer-&gt;su_local = NULL;</a>
<a name="ln1368">    }</a>
<a name="ln1369"> </a>
<a name="ln1370">  if (peer-&gt;su_remote)</a>
<a name="ln1371">    {</a>
<a name="ln1372">      sockunion_free (peer-&gt;su_remote);</a>
<a name="ln1373">      peer-&gt;su_remote = NULL;</a>
<a name="ln1374">    }</a>
<a name="ln1375">  </a>
<a name="ln1376">  /* Free filter related memory.  */</a>
<a name="ln1377">  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln1378">    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln1379">      {</a>
<a name="ln1380">	filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln1381"> </a>
<a name="ln1382">	for (i = FILTER_IN; i &lt; FILTER_MAX; i++)</a>
<a name="ln1383">	  {</a>
<a name="ln1384">	    if (filter-&gt;dlist[i].name)</a>
<a name="ln1385">              {</a>
<a name="ln1386">                free(filter-&gt;dlist[i].name);</a>
<a name="ln1387">                filter-&gt;dlist[i].name = NULL;</a>
<a name="ln1388">              }</a>
<a name="ln1389"> </a>
<a name="ln1390">	    if (filter-&gt;plist[i].name)</a>
<a name="ln1391">              {</a>
<a name="ln1392">                free(filter-&gt;plist[i].name);</a>
<a name="ln1393">                filter-&gt;plist[i].name = NULL;</a>
<a name="ln1394">              }</a>
<a name="ln1395"> </a>
<a name="ln1396">	    if (filter-&gt;aslist[i].name)</a>
<a name="ln1397">              {</a>
<a name="ln1398">                free(filter-&gt;aslist[i].name);</a>
<a name="ln1399">                filter-&gt;aslist[i].name = NULL;</a>
<a name="ln1400">              }</a>
<a name="ln1401">          }</a>
<a name="ln1402"> </a>
<a name="ln1403">        for (i = RMAP_IN; i &lt; RMAP_MAX; i++)</a>
<a name="ln1404">          {</a>
<a name="ln1405">	    if (filter-&gt;map[i].name)</a>
<a name="ln1406">              {</a>
<a name="ln1407">	        free (filter-&gt;map[i].name);</a>
<a name="ln1408">                filter-&gt;map[i].name = NULL;</a>
<a name="ln1409">              }</a>
<a name="ln1410">	  }</a>
<a name="ln1411"> </a>
<a name="ln1412">	if (filter-&gt;usmap.name)</a>
<a name="ln1413">          {</a>
<a name="ln1414">	    free (filter-&gt;usmap.name);</a>
<a name="ln1415">            filter-&gt;usmap.name = NULL;</a>
<a name="ln1416">          }</a>
<a name="ln1417"> </a>
<a name="ln1418">	if (peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln1419">          {</a>
<a name="ln1420">	    free (peer-&gt;default_rmap[afi][safi].name);</a>
<a name="ln1421">            peer-&gt;default_rmap[afi][safi].name = NULL;</a>
<a name="ln1422">          }</a>
<a name="ln1423">      }</a>
<a name="ln1424">  </a>
<a name="ln1425">  if (CHECK_FLAG(bgp-&gt;flags, BGP_FLAG_DELETING))</a>
<a name="ln1426">    bgp_peer_clear_node_queue_drain_immediate(peer);</a>
<a name="ln1427"> </a>
<a name="ln1428">  peer_unlock (peer); /* initial reference */</a>
<a name="ln1429"> </a>
<a name="ln1430">  return 0;</a>
<a name="ln1431">}</a>
<a name="ln1432"> </a>
<a name="ln1433">static int</a>
<a name="ln1434">peer_group_cmp (struct peer_group *g1, struct peer_group *g2)</a>
<a name="ln1435">{</a>
<a name="ln1436">  return strcmp (g1-&gt;name, g2-&gt;name);</a>
<a name="ln1437">}</a>
<a name="ln1438"> </a>
<a name="ln1439">/* If peer is configured at least one address family return 1. */</a>
<a name="ln1440">static int</a>
<a name="ln1441">peer_group_active (struct peer *peer)</a>
<a name="ln1442">{</a>
<a name="ln1443">  if (peer-&gt;af_group[AFI_IP][SAFI_UNICAST]</a>
<a name="ln1444">      || peer-&gt;af_group[AFI_IP][SAFI_MULTICAST]</a>
<a name="ln1445">      || peer-&gt;af_group[AFI_IP][SAFI_MPLS_VPN]</a>
<a name="ln1446">      || peer-&gt;af_group[AFI_IP][SAFI_ENCAP]</a>
<a name="ln1447">      || peer-&gt;af_group[AFI_IP6][SAFI_UNICAST]</a>
<a name="ln1448">      || peer-&gt;af_group[AFI_IP6][SAFI_MULTICAST]</a>
<a name="ln1449">      || peer-&gt;af_group[AFI_IP6][SAFI_MPLS_VPN]</a>
<a name="ln1450">      || peer-&gt;af_group[AFI_IP6][SAFI_ENCAP])</a>
<a name="ln1451">    return 1;</a>
<a name="ln1452">  return 0;</a>
<a name="ln1453">}</a>
<a name="ln1454"> </a>
<a name="ln1455">/* Peer group cofiguration. */</a>
<a name="ln1456">static struct peer_group *</a>
<a name="ln1457">peer_group_new (void)</a>
<a name="ln1458">{</a>
<a name="ln1459">  return (struct peer_group *) XCALLOC (MTYPE_PEER_GROUP,</a>
<a name="ln1460">					sizeof (struct peer_group));</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463">static void</a>
<a name="ln1464">peer_group_free (struct peer_group *group)</a>
<a name="ln1465">{</a>
<a name="ln1466">  XFREE (MTYPE_PEER_GROUP, group);</a>
<a name="ln1467">}</a>
<a name="ln1468"> </a>
<a name="ln1469">struct peer_group *</a>
<a name="ln1470">peer_group_lookup (struct bgp *bgp, const char *name)</a>
<a name="ln1471">{</a>
<a name="ln1472">  struct peer_group *group;</a>
<a name="ln1473">  struct listnode *node, *nnode;</a>
<a name="ln1474"> </a>
<a name="ln1475">  for (ALL_LIST_ELEMENTS (bgp-&gt;group, node, nnode, group))</a>
<a name="ln1476">    {</a>
<a name="ln1477">      if (strcmp (group-&gt;name, name) == 0)</a>
<a name="ln1478">	return group;</a>
<a name="ln1479">    }</a>
<a name="ln1480">  return NULL;</a>
<a name="ln1481">}</a>
<a name="ln1482"> </a>
<a name="ln1483">struct peer_group *</a>
<a name="ln1484">peer_group_get (struct bgp *bgp, const char *name)</a>
<a name="ln1485">{</a>
<a name="ln1486">  struct peer_group *group;</a>
<a name="ln1487"> </a>
<a name="ln1488">  group = peer_group_lookup (bgp, name);</a>
<a name="ln1489">  if (group)</a>
<a name="ln1490">    return group;</a>
<a name="ln1491"> </a>
<a name="ln1492">  group = peer_group_new ();</a>
<a name="ln1493">  group-&gt;bgp = bgp;</a>
<a name="ln1494">  group-&gt;name = strdup (name);</a>
<a name="ln1495">  group-&gt;peer = list_new ();</a>
<a name="ln1496">  group-&gt;conf = peer_new (bgp);</a>
<a name="ln1497">  if (! bgp_flag_check (bgp, BGP_FLAG_NO_DEFAULT_IPV4))</a>
<a name="ln1498">    group-&gt;conf-&gt;afc[AFI_IP][SAFI_UNICAST] = 1;</a>
<a name="ln1499">  group-&gt;conf-&gt;host = XSTRDUP (MTYPE_BGP_PEER_HOST, name);</a>
<a name="ln1500">  group-&gt;conf-&gt;group = group;</a>
<a name="ln1501">  group-&gt;conf-&gt;as = 0; </a>
<a name="ln1502">  group-&gt;conf-&gt;ttl = 0;</a>
<a name="ln1503">  group-&gt;conf-&gt;gtsm_hops = 0;</a>
<a name="ln1504">  group-&gt;conf-&gt;v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;</a>
<a name="ln1505">  UNSET_FLAG (group-&gt;conf-&gt;config, PEER_CONFIG_TIMER);</a>
<a name="ln1506">  UNSET_FLAG (group-&gt;conf-&gt;config, PEER_CONFIG_CONNECT);</a>
<a name="ln1507">  group-&gt;conf-&gt;keepalive = 0;</a>
<a name="ln1508">  group-&gt;conf-&gt;holdtime = 0;</a>
<a name="ln1509">  group-&gt;conf-&gt;connect = 0;</a>
<a name="ln1510">  SET_FLAG (group-&gt;conf-&gt;sflags, PEER_STATUS_GROUP);</a>
<a name="ln1511">  listnode_add_sort (bgp-&gt;group, group);</a>
<a name="ln1512"> </a>
<a name="ln1513">  return 0;</a>
<a name="ln1514">}</a>
<a name="ln1515"> </a>
<a name="ln1516">static void </a>
<a name="ln1517">peer_group2peer_config_copy (struct peer_group *group, struct peer *peer,</a>
<a name="ln1518">			     afi_t afi, safi_t safi)</a>
<a name="ln1519">{</a>
<a name="ln1520">  int in = FILTER_IN;</a>
<a name="ln1521">  int out = FILTER_OUT;</a>
<a name="ln1522">  struct peer *conf;</a>
<a name="ln1523">  struct bgp_filter *pfilter;</a>
<a name="ln1524">  struct bgp_filter *gfilter;</a>
<a name="ln1525"> </a>
<a name="ln1526">  conf = group-&gt;conf;</a>
<a name="ln1527">  pfilter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln1528">  gfilter = &amp;conf-&gt;filter[afi][safi];</a>
<a name="ln1529"> </a>
<a name="ln1530">  /* remote-as */</a>
<a name="ln1531">  if (conf-&gt;as)</a>
<a name="ln1532">    peer-&gt;as = conf-&gt;as;</a>
<a name="ln1533"> </a>
<a name="ln1534">  /* remote-as */</a>
<a name="ln1535">  if (conf-&gt;change_local_as)</a>
<a name="ln1536">    peer-&gt;change_local_as = conf-&gt;change_local_as;</a>
<a name="ln1537"> </a>
<a name="ln1538">  /* TTL */</a>
<a name="ln1539">  peer-&gt;ttl = conf-&gt;ttl;</a>
<a name="ln1540"> </a>
<a name="ln1541">  /* GTSM hops */</a>
<a name="ln1542">  peer-&gt;gtsm_hops = conf-&gt;gtsm_hops;</a>
<a name="ln1543"> </a>
<a name="ln1544">  /* Weight */</a>
<a name="ln1545">  peer-&gt;weight = conf-&gt;weight;</a>
<a name="ln1546"> </a>
<a name="ln1547">  /* peer flags apply */</a>
<a name="ln1548">  peer-&gt;flags = conf-&gt;flags;</a>
<a name="ln1549">  /* peer af_flags apply */</a>
<a name="ln1550">  peer-&gt;af_flags[afi][safi] = conf-&gt;af_flags[afi][safi];</a>
<a name="ln1551">  /* peer config apply */</a>
<a name="ln1552">  peer-&gt;config = conf-&gt;config;</a>
<a name="ln1553"> </a>
<a name="ln1554">  /* peer timers apply */</a>
<a name="ln1555">  peer-&gt;holdtime = conf-&gt;holdtime;</a>
<a name="ln1556">  peer-&gt;keepalive = conf-&gt;keepalive;</a>
<a name="ln1557">  peer-&gt;connect = conf-&gt;connect;</a>
<a name="ln1558">  if (CHECK_FLAG (conf-&gt;config, PEER_CONFIG_CONNECT))</a>
<a name="ln1559">    peer-&gt;v_connect = conf-&gt;connect;</a>
<a name="ln1560">  else</a>
<a name="ln1561">    peer-&gt;v_connect = BGP_DEFAULT_CONNECT_RETRY;</a>
<a name="ln1562"> </a>
<a name="ln1563">  /* advertisement-interval reset */</a>
<a name="ln1564">  if (CHECK_FLAG (conf-&gt;config, PEER_CONFIG_ROUTEADV))</a>
<a name="ln1565">      peer-&gt;v_routeadv = conf-&gt;routeadv;</a>
<a name="ln1566">  else</a>
<a name="ln1567">      if (peer_sort (peer) == BGP_PEER_IBGP)</a>
<a name="ln1568">        peer-&gt;v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;</a>
<a name="ln1569">      else</a>
<a name="ln1570">        peer-&gt;v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;</a>
<a name="ln1571"> </a>
<a name="ln1572">  /* password apply */</a>
<a name="ln1573">  if (conf-&gt;password &amp;&amp; !peer-&gt;password)</a>
<a name="ln1574">    peer-&gt;password =  XSTRDUP (MTYPE_PEER_PASSWORD, conf-&gt;password);</a>
<a name="ln1575"> </a>
<a name="ln1576">  bgp_md5_set (peer);</a>
<a name="ln1577"> </a>
<a name="ln1578">  /* maximum-prefix */</a>
<a name="ln1579">  peer-&gt;pmax[afi][safi] = conf-&gt;pmax[afi][safi];</a>
<a name="ln1580">  peer-&gt;pmax_threshold[afi][safi] = conf-&gt;pmax_threshold[afi][safi];</a>
<a name="ln1581">  peer-&gt;pmax_restart[afi][safi] = conf-&gt;pmax_restart[afi][safi];</a>
<a name="ln1582"> </a>
<a name="ln1583">  /* allowas-in */</a>
<a name="ln1584">  peer-&gt;allowas_in[afi][safi] = conf-&gt;allowas_in[afi][safi];</a>
<a name="ln1585"> </a>
<a name="ln1586">  /* route-server-client */</a>
<a name="ln1587">  if (CHECK_FLAG(conf-&gt;af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))</a>
<a name="ln1588">    {</a>
<a name="ln1589">      /* Make peer's RIB point to group's RIB. */</a>
<a name="ln1590">      peer-&gt;rib[afi][safi] = group-&gt;conf-&gt;rib[afi][safi];</a>
<a name="ln1591"> </a>
<a name="ln1592">      /* Import policy. */</a>
<a name="ln1593">      if (pfilter-&gt;map[RMAP_IMPORT].name)</a>
<a name="ln1594">        free (pfilter-&gt;map[RMAP_IMPORT].name);</a>
<a name="ln1595">      if (gfilter-&gt;map[RMAP_IMPORT].name)</a>
<a name="ln1596">        {</a>
<a name="ln1597">          pfilter-&gt;map[RMAP_IMPORT].name = strdup (gfilter-&gt;map[RMAP_IMPORT].name);</a>
<a name="ln1598">          pfilter-&gt;map[RMAP_IMPORT].map = gfilter-&gt;map[RMAP_IMPORT].map;</a>
<a name="ln1599">        }</a>
<a name="ln1600">      else</a>
<a name="ln1601">        {</a>
<a name="ln1602">          pfilter-&gt;map[RMAP_IMPORT].name = NULL;</a>
<a name="ln1603">          pfilter-&gt;map[RMAP_IMPORT].map = NULL;</a>
<a name="ln1604">        }</a>
<a name="ln1605"> </a>
<a name="ln1606">      /* Export policy. */</a>
<a name="ln1607">      if (gfilter-&gt;map[RMAP_EXPORT].name &amp;&amp; ! pfilter-&gt;map[RMAP_EXPORT].name)</a>
<a name="ln1608">        {</a>
<a name="ln1609">          pfilter-&gt;map[RMAP_EXPORT].name = strdup (gfilter-&gt;map[RMAP_EXPORT].name);</a>
<a name="ln1610">          pfilter-&gt;map[RMAP_EXPORT].map = gfilter-&gt;map[RMAP_EXPORT].map;</a>
<a name="ln1611">        }</a>
<a name="ln1612">    }</a>
<a name="ln1613"> </a>
<a name="ln1614">  /* default-originate route-map */</a>
<a name="ln1615">  if (conf-&gt;default_rmap[afi][safi].name)</a>
<a name="ln1616">    {</a>
<a name="ln1617">      if (peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln1618">	free (peer-&gt;default_rmap[afi][safi].name);</a>
<a name="ln1619">      peer-&gt;default_rmap[afi][safi].name = strdup (conf-&gt;default_rmap[afi][safi].name);</a>
<a name="ln1620">      peer-&gt;default_rmap[afi][safi].map = conf-&gt;default_rmap[afi][safi].map;</a>
<a name="ln1621">    }</a>
<a name="ln1622"> </a>
<a name="ln1623">  /* update-source apply */</a>
<a name="ln1624">  if (conf-&gt;update_source)</a>
<a name="ln1625">    {</a>
<a name="ln1626">      if (peer-&gt;update_source)</a>
<a name="ln1627">	sockunion_free (peer-&gt;update_source);</a>
<a name="ln1628">      if (peer-&gt;update_if)</a>
<a name="ln1629">	{</a>
<a name="ln1630">	  XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln1631">	  peer-&gt;update_if = NULL;</a>
<a name="ln1632">	}</a>
<a name="ln1633">      peer-&gt;update_source = sockunion_dup (conf-&gt;update_source);</a>
<a name="ln1634">    }</a>
<a name="ln1635">  else if (conf-&gt;update_if)</a>
<a name="ln1636">    {</a>
<a name="ln1637">      if (peer-&gt;update_if)</a>
<a name="ln1638">	XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln1639">      if (peer-&gt;update_source)</a>
<a name="ln1640">	{</a>
<a name="ln1641">	  sockunion_free (peer-&gt;update_source);</a>
<a name="ln1642">	  peer-&gt;update_source = NULL;</a>
<a name="ln1643">	}</a>
<a name="ln1644">      peer-&gt;update_if = XSTRDUP (MTYPE_PEER_UPDATE_SOURCE, conf-&gt;update_if);</a>
<a name="ln1645">    }</a>
<a name="ln1646"> </a>
<a name="ln1647">  /* inbound filter apply */</a>
<a name="ln1648">  if (gfilter-&gt;dlist[in].name &amp;&amp; ! pfilter-&gt;dlist[in].name)</a>
<a name="ln1649">    {</a>
<a name="ln1650">      if (pfilter-&gt;dlist[in].name)</a>
<a name="ln1651">	free (pfilter-&gt;dlist[in].name);</a>
<a name="ln1652">      pfilter-&gt;dlist[in].name = strdup (gfilter-&gt;dlist[in].name);</a>
<a name="ln1653">      pfilter-&gt;dlist[in].alist = gfilter-&gt;dlist[in].alist;</a>
<a name="ln1654">    }</a>
<a name="ln1655">  if (gfilter-&gt;plist[in].name &amp;&amp; ! pfilter-&gt;plist[in].name)</a>
<a name="ln1656">    {</a>
<a name="ln1657">      if (pfilter-&gt;plist[in].name)</a>
<a name="ln1658">	free (pfilter-&gt;plist[in].name);</a>
<a name="ln1659">      pfilter-&gt;plist[in].name = strdup (gfilter-&gt;plist[in].name);</a>
<a name="ln1660">      pfilter-&gt;plist[in].plist = gfilter-&gt;plist[in].plist;</a>
<a name="ln1661">    }</a>
<a name="ln1662">  if (gfilter-&gt;aslist[in].name &amp;&amp; ! pfilter-&gt;aslist[in].name)</a>
<a name="ln1663">    {</a>
<a name="ln1664">      if (pfilter-&gt;aslist[in].name)</a>
<a name="ln1665">	free (pfilter-&gt;aslist[in].name);</a>
<a name="ln1666">      pfilter-&gt;aslist[in].name = strdup (gfilter-&gt;aslist[in].name);</a>
<a name="ln1667">      pfilter-&gt;aslist[in].aslist = gfilter-&gt;aslist[in].aslist;</a>
<a name="ln1668">    }</a>
<a name="ln1669">  if (gfilter-&gt;map[RMAP_IN].name &amp;&amp; ! pfilter-&gt;map[RMAP_IN].name)</a>
<a name="ln1670">    {</a>
<a name="ln1671">      if (pfilter-&gt;map[RMAP_IN].name)</a>
<a name="ln1672">        free (pfilter-&gt;map[RMAP_IN].name);</a>
<a name="ln1673">      pfilter-&gt;map[RMAP_IN].name = strdup (gfilter-&gt;map[RMAP_IN].name);</a>
<a name="ln1674">      pfilter-&gt;map[RMAP_IN].map = gfilter-&gt;map[RMAP_IN].map;</a>
<a name="ln1675">    }</a>
<a name="ln1676"> </a>
<a name="ln1677">  /* outbound filter apply */</a>
<a name="ln1678">  if (gfilter-&gt;dlist[out].name)</a>
<a name="ln1679">    {</a>
<a name="ln1680">      if (pfilter-&gt;dlist[out].name)</a>
<a name="ln1681">	free (pfilter-&gt;dlist[out].name);</a>
<a name="ln1682">      pfilter-&gt;dlist[out].name = strdup (gfilter-&gt;dlist[out].name);</a>
<a name="ln1683">      pfilter-&gt;dlist[out].alist = gfilter-&gt;dlist[out].alist;</a>
<a name="ln1684">    }</a>
<a name="ln1685">  else</a>
<a name="ln1686">    {</a>
<a name="ln1687">      if (pfilter-&gt;dlist[out].name)</a>
<a name="ln1688">	free (pfilter-&gt;dlist[out].name);</a>
<a name="ln1689">      pfilter-&gt;dlist[out].name = NULL;</a>
<a name="ln1690">      pfilter-&gt;dlist[out].alist = NULL;</a>
<a name="ln1691">    }</a>
<a name="ln1692">  if (gfilter-&gt;plist[out].name)</a>
<a name="ln1693">    {</a>
<a name="ln1694">      if (pfilter-&gt;plist[out].name)</a>
<a name="ln1695">	free (pfilter-&gt;plist[out].name);</a>
<a name="ln1696">      pfilter-&gt;plist[out].name = strdup (gfilter-&gt;plist[out].name);</a>
<a name="ln1697">      pfilter-&gt;plist[out].plist = gfilter-&gt;plist[out].plist;</a>
<a name="ln1698">    }</a>
<a name="ln1699">  else</a>
<a name="ln1700">    {</a>
<a name="ln1701">      if (pfilter-&gt;plist[out].name)</a>
<a name="ln1702">	free (pfilter-&gt;plist[out].name);</a>
<a name="ln1703">      pfilter-&gt;plist[out].name = NULL;</a>
<a name="ln1704">      pfilter-&gt;plist[out].plist = NULL;</a>
<a name="ln1705">    }</a>
<a name="ln1706">  if (gfilter-&gt;aslist[out].name)</a>
<a name="ln1707">    {</a>
<a name="ln1708">      if (pfilter-&gt;aslist[out].name)</a>
<a name="ln1709">	free (pfilter-&gt;aslist[out].name);</a>
<a name="ln1710">      pfilter-&gt;aslist[out].name = strdup (gfilter-&gt;aslist[out].name);</a>
<a name="ln1711">      pfilter-&gt;aslist[out].aslist = gfilter-&gt;aslist[out].aslist;</a>
<a name="ln1712">    }</a>
<a name="ln1713">  else</a>
<a name="ln1714">    {</a>
<a name="ln1715">      if (pfilter-&gt;aslist[out].name)</a>
<a name="ln1716">	free (pfilter-&gt;aslist[out].name);</a>
<a name="ln1717">      pfilter-&gt;aslist[out].name = NULL;</a>
<a name="ln1718">      pfilter-&gt;aslist[out].aslist = NULL;</a>
<a name="ln1719">    }</a>
<a name="ln1720">  if (gfilter-&gt;map[RMAP_OUT].name)</a>
<a name="ln1721">    {</a>
<a name="ln1722">      if (pfilter-&gt;map[RMAP_OUT].name)</a>
<a name="ln1723">        free (pfilter-&gt;map[RMAP_OUT].name);</a>
<a name="ln1724">      pfilter-&gt;map[RMAP_OUT].name = strdup (gfilter-&gt;map[RMAP_OUT].name);</a>
<a name="ln1725">      pfilter-&gt;map[RMAP_OUT].map = gfilter-&gt;map[RMAP_OUT].map;</a>
<a name="ln1726">    }</a>
<a name="ln1727">  else</a>
<a name="ln1728">    {</a>
<a name="ln1729">      if (pfilter-&gt;map[RMAP_OUT].name)</a>
<a name="ln1730">        free (pfilter-&gt;map[RMAP_OUT].name);</a>
<a name="ln1731">      pfilter-&gt;map[RMAP_OUT].name = NULL;</a>
<a name="ln1732">      pfilter-&gt;map[RMAP_OUT].map = NULL;</a>
<a name="ln1733">    }</a>
<a name="ln1734"> </a>
<a name="ln1735"> /* RS-client's import/export route-maps. */</a>
<a name="ln1736">  if (gfilter-&gt;map[RMAP_IMPORT].name)</a>
<a name="ln1737">    {</a>
<a name="ln1738">      if (pfilter-&gt;map[RMAP_IMPORT].name)</a>
<a name="ln1739">        free (pfilter-&gt;map[RMAP_IMPORT].name);</a>
<a name="ln1740">      pfilter-&gt;map[RMAP_IMPORT].name = strdup (gfilter-&gt;map[RMAP_IMPORT].name);</a>
<a name="ln1741">      pfilter-&gt;map[RMAP_IMPORT].map = gfilter-&gt;map[RMAP_IMPORT].map;</a>
<a name="ln1742">    }</a>
<a name="ln1743">  else</a>
<a name="ln1744">    {</a>
<a name="ln1745">      if (pfilter-&gt;map[RMAP_IMPORT].name)</a>
<a name="ln1746">        free (pfilter-&gt;map[RMAP_IMPORT].name);</a>
<a name="ln1747">      pfilter-&gt;map[RMAP_IMPORT].name = NULL;</a>
<a name="ln1748">      pfilter-&gt;map[RMAP_IMPORT].map = NULL;</a>
<a name="ln1749">    }</a>
<a name="ln1750">  if (gfilter-&gt;map[RMAP_EXPORT].name &amp;&amp; ! pfilter-&gt;map[RMAP_EXPORT].name)</a>
<a name="ln1751">    {</a>
<a name="ln1752">      if (pfilter-&gt;map[RMAP_EXPORT].name)</a>
<a name="ln1753">        free (pfilter-&gt;map[RMAP_EXPORT].name);</a>
<a name="ln1754">      pfilter-&gt;map[RMAP_EXPORT].name = strdup (gfilter-&gt;map[RMAP_EXPORT].name);</a>
<a name="ln1755">      pfilter-&gt;map[RMAP_EXPORT].map = gfilter-&gt;map[RMAP_EXPORT].map;</a>
<a name="ln1756">    }</a>
<a name="ln1757"> </a>
<a name="ln1758">  if (gfilter-&gt;usmap.name)</a>
<a name="ln1759">    {</a>
<a name="ln1760">      if (pfilter-&gt;usmap.name)</a>
<a name="ln1761">	free (pfilter-&gt;usmap.name);</a>
<a name="ln1762">      pfilter-&gt;usmap.name = strdup (gfilter-&gt;usmap.name);</a>
<a name="ln1763">      pfilter-&gt;usmap.map = gfilter-&gt;usmap.map;</a>
<a name="ln1764">    }</a>
<a name="ln1765">  else</a>
<a name="ln1766">    {</a>
<a name="ln1767">      if (pfilter-&gt;usmap.name)</a>
<a name="ln1768">	free (pfilter-&gt;usmap.name);</a>
<a name="ln1769">      pfilter-&gt;usmap.name = NULL;</a>
<a name="ln1770">      pfilter-&gt;usmap.map = NULL;</a>
<a name="ln1771">    }</a>
<a name="ln1772">} </a>
<a name="ln1773"> </a>
<a name="ln1774">/* Peer group's remote AS configuration.  */</a>
<a name="ln1775">int</a>
<a name="ln1776">peer_group_remote_as (struct bgp *bgp, const char *group_name, as_t *as)</a>
<a name="ln1777">{</a>
<a name="ln1778">  struct peer_group *group;</a>
<a name="ln1779">  struct peer *peer;</a>
<a name="ln1780">  struct listnode *node, *nnode;</a>
<a name="ln1781"> </a>
<a name="ln1782">  group = peer_group_lookup (bgp, group_name);</a>
<a name="ln1783">  if (! group)</a>
<a name="ln1784">    return -1;</a>
<a name="ln1785"> </a>
<a name="ln1786">  if (group-&gt;conf-&gt;as == *as)</a>
<a name="ln1787">    return 0;</a>
<a name="ln1788"> </a>
<a name="ln1789">  /* When we setup peer-group AS number all peer group member's AS</a>
<a name="ln1790">     number must be updated to same number.  */</a>
<a name="ln1791">  peer_as_change (group-&gt;conf, *as);</a>
<a name="ln1792"> </a>
<a name="ln1793">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln1794">    {</a>
<a name="ln1795">      if (peer-&gt;as != *as)</a>
<a name="ln1796">	peer_as_change (peer, *as);</a>
<a name="ln1797">    }</a>
<a name="ln1798"> </a>
<a name="ln1799">  return 0;</a>
<a name="ln1800">}</a>
<a name="ln1801"> </a>
<a name="ln1802">int</a>
<a name="ln1803">peer_ttl (struct peer *peer)</a>
<a name="ln1804">{</a>
<a name="ln1805">  if (peer-&gt;ttl)</a>
<a name="ln1806">    return peer-&gt;ttl;</a>
<a name="ln1807">  if (peer-&gt;gtsm_hops || peer-&gt;sort == BGP_PEER_IBGP)</a>
<a name="ln1808">    return 255;</a>
<a name="ln1809">  return 1;</a>
<a name="ln1810">}</a>
<a name="ln1811"> </a>
<a name="ln1812">int</a>
<a name="ln1813">peer_group_delete (struct peer_group *group)</a>
<a name="ln1814">{</a>
<a name="ln1815">  struct bgp *bgp;</a>
<a name="ln1816">  struct peer *peer;</a>
<a name="ln1817">  struct listnode *node, *nnode;</a>
<a name="ln1818"> </a>
<a name="ln1819">  bgp = group-&gt;bgp;</a>
<a name="ln1820"> </a>
<a name="ln1821">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln1822">    {</a>
<a name="ln1823">      peer_delete (peer);</a>
<a name="ln1824">    }</a>
<a name="ln1825">  list_delete (group-&gt;peer);</a>
<a name="ln1826"> </a>
<a name="ln1827">  free (group-&gt;name);</a>
<a name="ln1828">  group-&gt;name = NULL;</a>
<a name="ln1829"> </a>
<a name="ln1830">  group-&gt;conf-&gt;group = NULL;</a>
<a name="ln1831">  peer_delete (group-&gt;conf);</a>
<a name="ln1832"> </a>
<a name="ln1833">  /* Delete from all peer_group list. */</a>
<a name="ln1834">  listnode_delete (bgp-&gt;group, group);</a>
<a name="ln1835"> </a>
<a name="ln1836">  peer_group_free (group);</a>
<a name="ln1837"> </a>
<a name="ln1838">  return 0;</a>
<a name="ln1839">}</a>
<a name="ln1840"> </a>
<a name="ln1841">int</a>
<a name="ln1842">peer_group_remote_as_delete (struct peer_group *group)</a>
<a name="ln1843">{</a>
<a name="ln1844">  struct peer *peer;</a>
<a name="ln1845">  struct listnode *node, *nnode;</a>
<a name="ln1846"> </a>
<a name="ln1847">  if (! group-&gt;conf-&gt;as)</a>
<a name="ln1848">    return 0;</a>
<a name="ln1849"> </a>
<a name="ln1850">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln1851">    {</a>
<a name="ln1852">      peer_delete (peer);</a>
<a name="ln1853">    }</a>
<a name="ln1854">  list_delete_all_node (group-&gt;peer);</a>
<a name="ln1855"> </a>
<a name="ln1856">  group-&gt;conf-&gt;as = 0;</a>
<a name="ln1857"> </a>
<a name="ln1858">  return 0;</a>
<a name="ln1859">}</a>
<a name="ln1860"> </a>
<a name="ln1861">/* Bind specified peer to peer group.  */</a>
<a name="ln1862">int</a>
<a name="ln1863">peer_group_bind (struct bgp *bgp, union sockunion *su,</a>
<a name="ln1864">		 struct peer_group *group, afi_t afi, safi_t safi, as_t *as)</a>
<a name="ln1865">{</a>
<a name="ln1866">  struct peer *peer;</a>
<a name="ln1867">  int first_member = 0;</a>
<a name="ln1868"> </a>
<a name="ln1869">  /* Check peer group's address family.  */</a>
<a name="ln1870">  if (! group-&gt;conf-&gt;afc[afi][safi])</a>
<a name="ln1871">    return BGP_ERR_PEER_GROUP_AF_UNCONFIGURED;</a>
<a name="ln1872"> </a>
<a name="ln1873">  /* Lookup the peer.  */</a>
<a name="ln1874">  peer = peer_lookup (bgp, su);</a>
<a name="ln1875"> </a>
<a name="ln1876">  /* Create a new peer. */</a>
<a name="ln1877">  if (! peer)</a>
<a name="ln1878">    {</a>
<a name="ln1879">      if (! group-&gt;conf-&gt;as)</a>
<a name="ln1880">	return BGP_ERR_PEER_GROUP_NO_REMOTE_AS;</a>
<a name="ln1881"> </a>
<a name="ln1882">      peer = peer_create (su, bgp, bgp-&gt;as, group-&gt;conf-&gt;as, afi, safi);</a>
<a name="ln1883">      peer-&gt;group = group;</a>
<a name="ln1884">      peer-&gt;af_group[afi][safi] = 1;</a>
<a name="ln1885"> </a>
<a name="ln1886">      peer = peer_lock (peer); /* group-&gt;peer list reference */</a>
<a name="ln1887">      listnode_add (group-&gt;peer, peer);</a>
<a name="ln1888">      peer_group2peer_config_copy (group, peer, afi, safi);</a>
<a name="ln1889"> </a>
<a name="ln1890">      return 0;</a>
<a name="ln1891">    }</a>
<a name="ln1892"> </a>
<a name="ln1893">  /* When the peer already belongs to peer group, check the consistency.  */</a>
<a name="ln1894">  if (peer-&gt;af_group[afi][safi])</a>
<a name="ln1895">    {</a>
<a name="ln1896">      if (strcmp (peer-&gt;group-&gt;name, group-&gt;name) != 0)</a>
<a name="ln1897">	return BGP_ERR_PEER_GROUP_CANT_CHANGE;</a>
<a name="ln1898"> </a>
<a name="ln1899">      return 0;</a>
<a name="ln1900">    }</a>
<a name="ln1901"> </a>
<a name="ln1902">  /* Check current peer group configuration.  */</a>
<a name="ln1903">  if (peer_group_active (peer)</a>
<a name="ln1904">      &amp;&amp; strcmp (peer-&gt;group-&gt;name, group-&gt;name) != 0)</a>
<a name="ln1905">    return BGP_ERR_PEER_GROUP_MISMATCH;</a>
<a name="ln1906"> </a>
<a name="ln1907">  if (! group-&gt;conf-&gt;as)</a>
<a name="ln1908">    {</a>
<a name="ln1909">      if (peer_sort (group-&gt;conf) != BGP_PEER_INTERNAL</a>
<a name="ln1910">	  &amp;&amp; peer_sort (group-&gt;conf) != peer_sort (peer))</a>
<a name="ln1911">	{</a>
<a name="ln1912">	  if (as)</a>
<a name="ln1913">	    *as = peer-&gt;as;</a>
<a name="ln1914">	  return BGP_ERR_PEER_GROUP_PEER_TYPE_DIFFERENT;</a>
<a name="ln1915">	}</a>
<a name="ln1916"> </a>
<a name="ln1917">      if (peer_sort (group-&gt;conf) == BGP_PEER_INTERNAL)</a>
<a name="ln1918">	first_member = 1;</a>
<a name="ln1919">    }</a>
<a name="ln1920"> </a>
<a name="ln1921">  peer-&gt;af_group[afi][safi] = 1;</a>
<a name="ln1922">  peer-&gt;afc[afi][safi] = 1;</a>
<a name="ln1923">  if (! peer-&gt;group)</a>
<a name="ln1924">    {</a>
<a name="ln1925">      peer-&gt;group = group;</a>
<a name="ln1926">      </a>
<a name="ln1927">      peer = peer_lock (peer); /* group-&gt;peer list reference */</a>
<a name="ln1928">      listnode_add (group-&gt;peer, peer);</a>
<a name="ln1929">    }</a>
<a name="ln1930">  else</a>
<a name="ln1931">    assert (group &amp;&amp; peer-&gt;group == group);</a>
<a name="ln1932"> </a>
<a name="ln1933">  if (first_member)</a>
<a name="ln1934">    {</a>
<a name="ln1935">      /* Advertisement-interval reset */</a>
<a name="ln1936">      if (! CHECK_FLAG (group-&gt;conf-&gt;config, PEER_CONFIG_ROUTEADV))</a>
<a name="ln1937">	{</a>
<a name="ln1938">	  if (peer_sort (group-&gt;conf) == BGP_PEER_IBGP)</a>
<a name="ln1939">	    group-&gt;conf-&gt;v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;</a>
<a name="ln1940">	  else</a>
<a name="ln1941">	    group-&gt;conf-&gt;v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;</a>
<a name="ln1942">	}</a>
<a name="ln1943"> </a>
<a name="ln1944">      /* local-as reset */</a>
<a name="ln1945">      if (peer_sort (group-&gt;conf) != BGP_PEER_EBGP)</a>
<a name="ln1946">	{</a>
<a name="ln1947">	  group-&gt;conf-&gt;change_local_as = 0;</a>
<a name="ln1948">	  UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND);</a>
<a name="ln1949">	  UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS);</a>
<a name="ln1950">	}</a>
<a name="ln1951">    }</a>
<a name="ln1952"> </a>
<a name="ln1953">  if (CHECK_FLAG(peer-&gt;af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))</a>
<a name="ln1954">    {</a>
<a name="ln1955">      struct listnode *pn;</a>
<a name="ln1956">      </a>
<a name="ln1957">      /* If it's not configured as RSERVER_CLIENT in any other address</a>
<a name="ln1958">          family, without being member of a peer_group, remove it from</a>
<a name="ln1959">          list bgp-&gt;rsclient.*/</a>
<a name="ln1960">      if (! peer_rsclient_active (peer)</a>
<a name="ln1961">          &amp;&amp; (pn = listnode_lookup (bgp-&gt;rsclient, peer)))</a>
<a name="ln1962">        {</a>
<a name="ln1963">          peer_unlock (peer); /* peer rsclient reference */</a>
<a name="ln1964">          list_delete_node (bgp-&gt;rsclient, pn);</a>
<a name="ln1965"> </a>
<a name="ln1966">          /* Clear our own rsclient rib for this afi/safi. */</a>
<a name="ln1967">          bgp_clear_route (peer, afi, safi, BGP_CLEAR_ROUTE_MY_RSCLIENT);</a>
<a name="ln1968">        }</a>
<a name="ln1969"> </a>
<a name="ln1970">      bgp_table_finish (&amp;peer-&gt;rib[afi][safi]);</a>
<a name="ln1971"> </a>
<a name="ln1972">      /* Import policy. */</a>
<a name="ln1973">      if (peer-&gt;filter[afi][safi].map[RMAP_IMPORT].name)</a>
<a name="ln1974">        {</a>
<a name="ln1975">          free (peer-&gt;filter[afi][safi].map[RMAP_IMPORT].name);</a>
<a name="ln1976">          peer-&gt;filter[afi][safi].map[RMAP_IMPORT].name = NULL;</a>
<a name="ln1977">          peer-&gt;filter[afi][safi].map[RMAP_IMPORT].map = NULL;</a>
<a name="ln1978">        }</a>
<a name="ln1979"> </a>
<a name="ln1980">      /* Export policy. */</a>
<a name="ln1981">      if (! CHECK_FLAG(group-&gt;conf-&gt;af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)</a>
<a name="ln1982">              &amp;&amp; peer-&gt;filter[afi][safi].map[RMAP_EXPORT].name)</a>
<a name="ln1983">        {</a>
<a name="ln1984">          free (peer-&gt;filter[afi][safi].map[RMAP_EXPORT].name);</a>
<a name="ln1985">          peer-&gt;filter[afi][safi].map[RMAP_EXPORT].name = NULL;</a>
<a name="ln1986">          peer-&gt;filter[afi][safi].map[RMAP_EXPORT].map = NULL;</a>
<a name="ln1987">        }</a>
<a name="ln1988">    }</a>
<a name="ln1989"> </a>
<a name="ln1990">  peer_group2peer_config_copy (group, peer, afi, safi);</a>
<a name="ln1991"> </a>
<a name="ln1992">  if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln1993">    {</a>
<a name="ln1994">      peer-&gt;last_reset = PEER_DOWN_RMAP_BIND;</a>
<a name="ln1995">      bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln1996">                      BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln1997">    }</a>
<a name="ln1998">  else</a>
<a name="ln1999">    BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln2000"> </a>
<a name="ln2001">  return 0;</a>
<a name="ln2002">}</a>
<a name="ln2003"> </a>
<a name="ln2004">int</a>
<a name="ln2005">peer_group_unbind (struct bgp *bgp, struct peer *peer,</a>
<a name="ln2006">		   struct peer_group *group, afi_t afi, safi_t safi)</a>
<a name="ln2007">{</a>
<a name="ln2008">  if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln2009">      return 0;</a>
<a name="ln2010"> </a>
<a name="ln2011">  if (group != peer-&gt;group)</a>
<a name="ln2012">    return BGP_ERR_PEER_GROUP_MISMATCH;</a>
<a name="ln2013"> </a>
<a name="ln2014">  peer-&gt;af_group[afi][safi] = 0;</a>
<a name="ln2015">  peer-&gt;afc[afi][safi] = 0;</a>
<a name="ln2016">  peer_af_flag_reset (peer, afi, safi);</a>
<a name="ln2017"> </a>
<a name="ln2018">  if (peer-&gt;rib[afi][safi])</a>
<a name="ln2019">    peer-&gt;rib[afi][safi] = NULL;</a>
<a name="ln2020"> </a>
<a name="ln2021">  if (! peer_group_active (peer))</a>
<a name="ln2022">    {</a>
<a name="ln2023">      assert (listnode_lookup (group-&gt;peer, peer));</a>
<a name="ln2024">      peer_unlock (peer); /* peer group list reference */</a>
<a name="ln2025">      listnode_delete (group-&gt;peer, peer);</a>
<a name="ln2026">      peer-&gt;group = NULL;</a>
<a name="ln2027">      if (group-&gt;conf-&gt;as)</a>
<a name="ln2028">	{</a>
<a name="ln2029">	  peer_delete (peer);</a>
<a name="ln2030">	  return 0;</a>
<a name="ln2031">	}</a>
<a name="ln2032">      peer_global_config_reset (peer);</a>
<a name="ln2033">    }</a>
<a name="ln2034"> </a>
<a name="ln2035">  if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln2036">    {</a>
<a name="ln2037">      peer-&gt;last_reset = PEER_DOWN_RMAP_UNBIND;</a>
<a name="ln2038">      bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln2039">                      BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln2040">    }</a>
<a name="ln2041">  else</a>
<a name="ln2042">    BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln2043"> </a>
<a name="ln2044">  return 0;</a>
<a name="ln2045">}</a>
<a name="ln2046"> </a>
<a name="ln2047"> </a>
<a name="ln2048">static int</a>
<a name="ln2049">bgp_startup_timer_expire (struct thread *thread)</a>
<a name="ln2050">{</a>
<a name="ln2051">  struct bgp *bgp;</a>
<a name="ln2052"> </a>
<a name="ln2053">  bgp = THREAD_ARG (thread);</a>
<a name="ln2054">  bgp-&gt;t_startup = NULL;</a>
<a name="ln2055"> </a>
<a name="ln2056">  return 0;</a>
<a name="ln2057">}</a>
<a name="ln2058"> </a>
<a name="ln2059">/* BGP instance creation by `router bgp' commands. */</a>
<a name="ln2060">static struct bgp *</a>
<a name="ln2061">bgp_create (as_t *as, const char *name)</a>
<a name="ln2062">{</a>
<a name="ln2063">  struct bgp *bgp;</a>
<a name="ln2064">  afi_t afi;</a>
<a name="ln2065">  safi_t safi;</a>
<a name="ln2066"> </a>
<a name="ln2067">  if ( (bgp = XCALLOC (MTYPE_BGP, sizeof (struct bgp))) == NULL)</a>
<a name="ln2068">    return NULL;</a>
<a name="ln2069">  </a>
<a name="ln2070">  bgp_lock (bgp);</a>
<a name="ln2071">  bgp-&gt;peer_self = peer_new (bgp);</a>
<a name="ln2072">  bgp-&gt;peer_self-&gt;host = XSTRDUP (MTYPE_BGP_PEER_HOST, &quot;Static announcement&quot;);</a>
<a name="ln2073"> </a>
<a name="ln2074">  bgp-&gt;peer = list_new ();</a>
<a name="ln2075">  bgp-&gt;peer-&gt;cmp = (int (*)(void *, void *)) peer_cmp;</a>
<a name="ln2076"> </a>
<a name="ln2077">  bgp-&gt;group = list_new ();</a>
<a name="ln2078">  bgp-&gt;group-&gt;cmp = (int (*)(void *, void *)) peer_group_cmp;</a>
<a name="ln2079"> </a>
<a name="ln2080">  bgp-&gt;rsclient = list_new ();</a>
<a name="ln2081">  bgp-&gt;rsclient-&gt;cmp = (int (*)(void*, void*)) peer_cmp;</a>
<a name="ln2082"> </a>
<a name="ln2083">  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln2084">    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln2085">      {</a>
<a name="ln2086">	bgp-&gt;route[afi][safi] = bgp_table_init (afi, safi);</a>
<a name="ln2087">	bgp-&gt;aggregate[afi][safi] = bgp_table_init (afi, safi);</a>
<a name="ln2088">	bgp-&gt;rib[afi][safi] = bgp_table_init (afi, safi);</a>
<a name="ln2089">	bgp-&gt;maxpaths[afi][safi].maxpaths_ebgp = BGP_DEFAULT_MAXPATHS;</a>
<a name="ln2090">	bgp-&gt;maxpaths[afi][safi].maxpaths_ibgp = BGP_DEFAULT_MAXPATHS;</a>
<a name="ln2091">      }</a>
<a name="ln2092"> </a>
<a name="ln2093">  bgp-&gt;default_local_pref = BGP_DEFAULT_LOCAL_PREF;</a>
<a name="ln2094">  bgp-&gt;default_holdtime = BGP_DEFAULT_HOLDTIME;</a>
<a name="ln2095">  bgp-&gt;default_keepalive = BGP_DEFAULT_KEEPALIVE;</a>
<a name="ln2096">  bgp-&gt;restart_time = BGP_DEFAULT_RESTART_TIME;</a>
<a name="ln2097">  bgp-&gt;stalepath_time = BGP_DEFAULT_STALEPATH_TIME;</a>
<a name="ln2098">  bgp_flag_set (bgp, BGP_FLAG_LOG_NEIGHBOR_CHANGES);</a>
<a name="ln2099"> </a>
<a name="ln2100">  bgp-&gt;as = *as;</a>
<a name="ln2101"> </a>
<a name="ln2102">  if (name)</a>
<a name="ln2103">    bgp-&gt;name = strdup (name);</a>
<a name="ln2104"> </a>
<a name="ln2105">  THREAD_TIMER_ON (bm-&gt;master, bgp-&gt;t_startup, bgp_startup_timer_expire,</a>
<a name="ln2106">                   bgp, bgp-&gt;restart_time);</a>
<a name="ln2107"> </a>
<a name="ln2108">  return bgp;</a>
<a name="ln2109">}</a>
<a name="ln2110"> </a>
<a name="ln2111">/* Return first entry of BGP. */</a>
<a name="ln2112">struct bgp *</a>
<a name="ln2113">bgp_get_default (void)</a>
<a name="ln2114">{</a>
<a name="ln2115">  if (bm &amp;&amp; bm-&gt;bgp &amp;&amp; bm-&gt;bgp-&gt;head)</a>
<a name="ln2116">    return (listgetdata (listhead (bm-&gt;bgp)));</a>
<a name="ln2117">  return NULL;</a>
<a name="ln2118">}</a>
<a name="ln2119"> </a>
<a name="ln2120">/* Lookup BGP entry. */</a>
<a name="ln2121">struct bgp *</a>
<a name="ln2122">bgp_lookup (as_t as, const char *name)</a>
<a name="ln2123">{</a>
<a name="ln2124">  struct bgp *bgp;</a>
<a name="ln2125">  struct listnode *node, *nnode;</a>
<a name="ln2126"> </a>
<a name="ln2127">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, node, nnode, bgp))</a>
<a name="ln2128">    if (bgp-&gt;as == as</a>
<a name="ln2129">	&amp;&amp; ((bgp-&gt;name == NULL &amp;&amp; name == NULL) </a>
<a name="ln2130">	    || (bgp-&gt;name &amp;&amp; name &amp;&amp; strcmp (bgp-&gt;name, name) == 0)))</a>
<a name="ln2131">      return bgp;</a>
<a name="ln2132">  return NULL;</a>
<a name="ln2133">}</a>
<a name="ln2134"> </a>
<a name="ln2135">/* Lookup BGP structure by view name. */</a>
<a name="ln2136">struct bgp *</a>
<a name="ln2137">bgp_lookup_by_name (const char *name)</a>
<a name="ln2138">{</a>
<a name="ln2139">  struct bgp *bgp;</a>
<a name="ln2140">  struct listnode *node, *nnode;</a>
<a name="ln2141"> </a>
<a name="ln2142">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, node, nnode, bgp))</a>
<a name="ln2143">    if ((bgp-&gt;name == NULL &amp;&amp; name == NULL)</a>
<a name="ln2144">	|| (bgp-&gt;name &amp;&amp; name &amp;&amp; strcmp (bgp-&gt;name, name) == 0))</a>
<a name="ln2145">      return bgp;</a>
<a name="ln2146">  return NULL;</a>
<a name="ln2147">}</a>
<a name="ln2148"> </a>
<a name="ln2149">/* Called from VTY commands. */</a>
<a name="ln2150">int</a>
<a name="ln2151">bgp_get (struct bgp **bgp_val, as_t *as, const char *name)</a>
<a name="ln2152">{</a>
<a name="ln2153">  struct bgp *bgp;</a>
<a name="ln2154"> </a>
<a name="ln2155">  /* Multiple instance check. */</a>
<a name="ln2156">  if (bgp_option_check (BGP_OPT_MULTIPLE_INSTANCE))</a>
<a name="ln2157">    {</a>
<a name="ln2158">      if (name)</a>
<a name="ln2159">	bgp = bgp_lookup_by_name (name);</a>
<a name="ln2160">      else</a>
<a name="ln2161">	bgp = bgp_get_default ();</a>
<a name="ln2162"> </a>
<a name="ln2163">      /* Already exists. */</a>
<a name="ln2164">      if (bgp)</a>
<a name="ln2165">	{</a>
<a name="ln2166">          if (bgp-&gt;as != *as)</a>
<a name="ln2167">	    {</a>
<a name="ln2168">	      *as = bgp-&gt;as;</a>
<a name="ln2169">	      return BGP_ERR_INSTANCE_MISMATCH;</a>
<a name="ln2170">	    }</a>
<a name="ln2171">	  *bgp_val = bgp;</a>
<a name="ln2172">	  return 0;</a>
<a name="ln2173">	}</a>
<a name="ln2174">    }</a>
<a name="ln2175">  else</a>
<a name="ln2176">    {</a>
<a name="ln2177">      /* BGP instance name can not be specified for single instance.  */</a>
<a name="ln2178">      if (name)</a>
<a name="ln2179">	return BGP_ERR_MULTIPLE_INSTANCE_NOT_SET;</a>
<a name="ln2180"> </a>
<a name="ln2181">      /* Get default BGP structure if exists. */</a>
<a name="ln2182">      bgp = bgp_get_default ();</a>
<a name="ln2183"> </a>
<a name="ln2184">      if (bgp)</a>
<a name="ln2185">	{</a>
<a name="ln2186">	  if (bgp-&gt;as != *as)</a>
<a name="ln2187">	    {</a>
<a name="ln2188">	      *as = bgp-&gt;as;</a>
<a name="ln2189">	      return BGP_ERR_AS_MISMATCH;</a>
<a name="ln2190">	    }</a>
<a name="ln2191">	  *bgp_val = bgp;</a>
<a name="ln2192">	  return 0;</a>
<a name="ln2193">	}</a>
<a name="ln2194">    }</a>
<a name="ln2195"> </a>
<a name="ln2196">  bgp = bgp_create (as, name);</a>
<a name="ln2197">  bgp_router_id_set(bgp, &amp;router_id_zebra);</a>
<a name="ln2198">  *bgp_val = bgp;</a>
<a name="ln2199"> </a>
<a name="ln2200">  /* Create BGP server socket, if first instance.  */</a>
<a name="ln2201">  if (list_isempty(bm-&gt;bgp)</a>
<a name="ln2202">      &amp;&amp; !bgp_option_check (BGP_OPT_NO_LISTEN))</a>
<a name="ln2203">    {</a>
<a name="ln2204">      if (bgp_socket (bm-&gt;port, bm-&gt;address) &lt; 0)</a>
<a name="ln2205">	return BGP_ERR_INVALID_VALUE;</a>
<a name="ln2206">    }</a>
<a name="ln2207"> </a>
<a name="ln2208">  listnode_add (bm-&gt;bgp, bgp);</a>
<a name="ln2209"> </a>
<a name="ln2210">  return 0;</a>
<a name="ln2211">}</a>
<a name="ln2212"> </a>
<a name="ln2213">/* Delete BGP instance. */</a>
<a name="ln2214">int</a>
<a name="ln2215">bgp_delete (struct bgp *bgp)</a>
<a name="ln2216">{</a>
<a name="ln2217">  struct peer *peer;</a>
<a name="ln2218">  struct peer_group *group;</a>
<a name="ln2219">  struct listnode *node, *pnode;</a>
<a name="ln2220">  struct listnode *next, *pnext;</a>
<a name="ln2221">  afi_t afi;</a>
<a name="ln2222">  int i;</a>
<a name="ln2223"> </a>
<a name="ln2224">  SET_FLAG(bgp-&gt;flags, BGP_FLAG_DELETING);</a>
<a name="ln2225"> </a>
<a name="ln2226">  THREAD_OFF (bgp-&gt;t_startup);</a>
<a name="ln2227"> </a>
<a name="ln2228">  for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, next, peer))</a>
<a name="ln2229">    {</a>
<a name="ln2230">      if (peer-&gt;status == Established ||</a>
<a name="ln2231">          peer-&gt;status == OpenSent ||</a>
<a name="ln2232">          peer-&gt;status == OpenConfirm)</a>
<a name="ln2233">        {</a>
<a name="ln2234">            bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln2235">                             BGP_NOTIFY_CEASE_PEER_UNCONFIG);</a>
<a name="ln2236">        }</a>
<a name="ln2237">    }</a>
<a name="ln2238"> </a>
<a name="ln2239">  /* Delete static route. */</a>
<a name="ln2240">  bgp_static_delete (bgp);</a>
<a name="ln2241"> </a>
<a name="ln2242">  /* Unset redistribution. */</a>
<a name="ln2243">  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln2244">    for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++) </a>
<a name="ln2245">      if (i != ZEBRA_ROUTE_BGP)</a>
<a name="ln2246">	bgp_redistribute_unset (bgp, afi, i);</a>
<a name="ln2247"> </a>
<a name="ln2248">  for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, next, peer))</a>
<a name="ln2249">    {</a>
<a name="ln2250">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln2251">	{</a>
<a name="ln2252">	  /* Send notify to remote peer. */</a>
<a name="ln2253">	  bgp_notify_send (peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN);</a>
<a name="ln2254">	}</a>
<a name="ln2255"> </a>
<a name="ln2256">      peer_delete (peer);</a>
<a name="ln2257">    }</a>
<a name="ln2258"> </a>
<a name="ln2259">  for (ALL_LIST_ELEMENTS (bgp-&gt;group, node, next, group))</a>
<a name="ln2260">    {</a>
<a name="ln2261">      for (ALL_LIST_ELEMENTS (group-&gt;peer, pnode, pnext, peer))</a>
<a name="ln2262">	{</a>
<a name="ln2263">	  if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln2264">	    {</a>
<a name="ln2265">	      /* Send notify to remote peer. */</a>
<a name="ln2266">	      bgp_notify_send (peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN);</a>
<a name="ln2267">	    }</a>
<a name="ln2268">	}</a>
<a name="ln2269">      peer_group_delete (group);</a>
<a name="ln2270">    }</a>
<a name="ln2271"> </a>
<a name="ln2272">  assert (listcount (bgp-&gt;rsclient) == 0);</a>
<a name="ln2273"> </a>
<a name="ln2274">  if (bgp-&gt;peer_self) {</a>
<a name="ln2275">    peer_delete(bgp-&gt;peer_self);</a>
<a name="ln2276">    bgp-&gt;peer_self = NULL;</a>
<a name="ln2277">  }</a>
<a name="ln2278"> </a>
<a name="ln2279">  /*</a>
<a name="ln2280">   * Free pending deleted routes. Unfortunately, it also has to process</a>
<a name="ln2281">   * all the pending activity for other instances of struct bgp.</a>
<a name="ln2282">   *</a>
<a name="ln2283">   * This call was added to achieve clean memory allocation at exit,</a>
<a name="ln2284">   * for the sake of valgrind.</a>
<a name="ln2285">   */</a>
<a name="ln2286">  bgp_process_queues_drain_immediate();</a>
<a name="ln2287"> </a>
<a name="ln2288">  /* Remove visibility via the master list - there may however still be</a>
<a name="ln2289">   * routes to be processed still referencing the struct bgp.</a>
<a name="ln2290">   */</a>
<a name="ln2291">  listnode_delete (bm-&gt;bgp, bgp);</a>
<a name="ln2292">  if (list_isempty(bm-&gt;bgp))</a>
<a name="ln2293">    bgp_close ();</a>
<a name="ln2294"> </a>
<a name="ln2295">  bgp_unlock(bgp);  /* initial reference */</a>
<a name="ln2296">  </a>
<a name="ln2297">  return 0;</a>
<a name="ln2298">}</a>
<a name="ln2299"> </a>
<a name="ln2300">static void bgp_free (struct bgp *);</a>
<a name="ln2301"> </a>
<a name="ln2302">void</a>
<a name="ln2303">bgp_lock (struct bgp *bgp)</a>
<a name="ln2304">{</a>
<a name="ln2305">  ++bgp-&gt;lock;</a>
<a name="ln2306">}</a>
<a name="ln2307"> </a>
<a name="ln2308">void</a>
<a name="ln2309">bgp_unlock(struct bgp *bgp)</a>
<a name="ln2310">{</a>
<a name="ln2311">  assert(bgp-&gt;lock &gt; 0);</a>
<a name="ln2312">  if (--bgp-&gt;lock == 0)</a>
<a name="ln2313">    bgp_free (bgp);</a>
<a name="ln2314">}</a>
<a name="ln2315"> </a>
<a name="ln2316">static void</a>
<a name="ln2317">bgp_free (struct bgp *bgp)</a>
<a name="ln2318">{</a>
<a name="ln2319">  afi_t afi;</a>
<a name="ln2320">  safi_t safi;</a>
<a name="ln2321"> </a>
<a name="ln2322">  list_delete (bgp-&gt;group);</a>
<a name="ln2323">  list_delete (bgp-&gt;peer);</a>
<a name="ln2324">  list_delete (bgp-&gt;rsclient);</a>
<a name="ln2325"> </a>
<a name="ln2326">  if (bgp-&gt;name)</a>
<a name="ln2327">    free (bgp-&gt;name);</a>
<a name="ln2328">  </a>
<a name="ln2329">  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln2330">    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln2331">      {</a>
<a name="ln2332">	if (bgp-&gt;route[afi][safi])</a>
<a name="ln2333">          bgp_table_finish (&amp;bgp-&gt;route[afi][safi]);</a>
<a name="ln2334">	if (bgp-&gt;aggregate[afi][safi])</a>
<a name="ln2335">          bgp_table_finish (&amp;bgp-&gt;aggregate[afi][safi]) ;</a>
<a name="ln2336">	if (bgp-&gt;rib[afi][safi])</a>
<a name="ln2337">          bgp_table_finish (&amp;bgp-&gt;rib[afi][safi]);</a>
<a name="ln2338">      }</a>
<a name="ln2339">  XFREE (MTYPE_BGP, bgp);</a>
<a name="ln2340">}</a>
<a name="ln2341"> </a>
<a name="ln2342">struct peer *</a>
<a name="ln2343">peer_lookup (struct bgp *bgp, union sockunion *su)</a>
<a name="ln2344">{</a>
<a name="ln2345">  struct peer *peer;</a>
<a name="ln2346">  struct listnode *node, *nnode;</a>
<a name="ln2347"> </a>
<a name="ln2348">  if (bgp != NULL)</a>
<a name="ln2349">    {</a>
<a name="ln2350">      for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln2351">        if (sockunion_same (&amp;peer-&gt;su, su)</a>
<a name="ln2352">            &amp;&amp; ! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_ACCEPT_PEER))</a>
<a name="ln2353">          return peer;</a>
<a name="ln2354">    }</a>
<a name="ln2355">  else if (bm-&gt;bgp != NULL)</a>
<a name="ln2356">    {</a>
<a name="ln2357">      struct listnode *bgpnode, *nbgpnode;</a>
<a name="ln2358">  </a>
<a name="ln2359">      for (ALL_LIST_ELEMENTS (bm-&gt;bgp, bgpnode, nbgpnode, bgp))</a>
<a name="ln2360">        for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln2361">          if (sockunion_same (&amp;peer-&gt;su, su)</a>
<a name="ln2362">              &amp;&amp; ! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_ACCEPT_PEER))</a>
<a name="ln2363">            return peer;</a>
<a name="ln2364">    }</a>
<a name="ln2365">  return NULL;</a>
<a name="ln2366">}</a>
<a name="ln2367"> </a>
<a name="ln2368">struct peer *</a>
<a name="ln2369">peer_lookup_with_open (union sockunion *su, as_t remote_as,</a>
<a name="ln2370">		       struct in_addr *remote_id, int *as)</a>
<a name="ln2371">{</a>
<a name="ln2372">  struct peer *peer;</a>
<a name="ln2373">  struct listnode *node;</a>
<a name="ln2374">  struct listnode *bgpnode;</a>
<a name="ln2375">  struct bgp *bgp;</a>
<a name="ln2376"> </a>
<a name="ln2377">  if (! bm-&gt;bgp)</a>
<a name="ln2378">    return NULL;</a>
<a name="ln2379"> </a>
<a name="ln2380">  for (ALL_LIST_ELEMENTS_RO (bm-&gt;bgp, bgpnode, bgp))</a>
<a name="ln2381">    {</a>
<a name="ln2382">      for (ALL_LIST_ELEMENTS_RO (bgp-&gt;peer, node, peer))</a>
<a name="ln2383">        {</a>
<a name="ln2384">          if (sockunion_same (&amp;peer-&gt;su, su)</a>
<a name="ln2385">              &amp;&amp; ! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_ACCEPT_PEER))</a>
<a name="ln2386">            {</a>
<a name="ln2387">              if (peer-&gt;as == remote_as</a>
<a name="ln2388">                  &amp;&amp; peer-&gt;remote_id.s_addr == remote_id-&gt;s_addr)</a>
<a name="ln2389">                return peer;</a>
<a name="ln2390">              if (peer-&gt;as == remote_as)</a>
<a name="ln2391">                *as = 1;</a>
<a name="ln2392">            }</a>
<a name="ln2393">        }</a>
<a name="ln2394"> </a>
<a name="ln2395">      for (ALL_LIST_ELEMENTS_RO (bgp-&gt;peer, node, peer))</a>
<a name="ln2396">        {</a>
<a name="ln2397">          if (sockunion_same (&amp;peer-&gt;su, su)</a>
<a name="ln2398">              &amp;&amp;  ! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_ACCEPT_PEER))</a>
<a name="ln2399">            {</a>
<a name="ln2400">              if (peer-&gt;as == remote_as</a>
<a name="ln2401">                  &amp;&amp; peer-&gt;remote_id.s_addr == 0)</a>
<a name="ln2402">                return peer;</a>
<a name="ln2403">              if (peer-&gt;as == remote_as)</a>
<a name="ln2404">                *as = 1;</a>
<a name="ln2405">            }</a>
<a name="ln2406">        }</a>
<a name="ln2407">    }</a>
<a name="ln2408">  return NULL;</a>
<a name="ln2409">}</a>
<a name="ln2410"> </a>
<a name="ln2411">/* If peer is configured at least one address family return 1. */</a>
<a name="ln2412">int</a>
<a name="ln2413">peer_active (struct peer *peer)</a>
<a name="ln2414">{</a>
<a name="ln2415">  if (peer-&gt;afc[AFI_IP][SAFI_UNICAST]</a>
<a name="ln2416">      || peer-&gt;afc[AFI_IP][SAFI_MULTICAST]</a>
<a name="ln2417">      || peer-&gt;afc[AFI_IP][SAFI_MPLS_VPN]</a>
<a name="ln2418">      || peer-&gt;afc[AFI_IP][SAFI_ENCAP]</a>
<a name="ln2419">      || peer-&gt;afc[AFI_IP6][SAFI_UNICAST]</a>
<a name="ln2420">      || peer-&gt;afc[AFI_IP6][SAFI_MULTICAST]</a>
<a name="ln2421">      || peer-&gt;afc[AFI_IP6][SAFI_MPLS_VPN]</a>
<a name="ln2422">      || peer-&gt;afc[AFI_IP6][SAFI_ENCAP])</a>
<a name="ln2423">    return 1;</a>
<a name="ln2424">  return 0;</a>
<a name="ln2425">}</a>
<a name="ln2426"> </a>
<a name="ln2427">/* If peer is negotiated at least one address family return 1. */</a>
<a name="ln2428">int</a>
<a name="ln2429">peer_active_nego (struct peer *peer)</a>
<a name="ln2430">{</a>
<a name="ln2431">  if (peer-&gt;afc_nego[AFI_IP][SAFI_UNICAST]</a>
<a name="ln2432">      || peer-&gt;afc_nego[AFI_IP][SAFI_MULTICAST]</a>
<a name="ln2433">      || peer-&gt;afc_nego[AFI_IP][SAFI_MPLS_VPN]</a>
<a name="ln2434">      || peer-&gt;afc_nego[AFI_IP][SAFI_ENCAP]</a>
<a name="ln2435">      || peer-&gt;afc_nego[AFI_IP6][SAFI_UNICAST]</a>
<a name="ln2436">      || peer-&gt;afc_nego[AFI_IP6][SAFI_MULTICAST]</a>
<a name="ln2437">      || peer-&gt;afc_nego[AFI_IP6][SAFI_MPLS_VPN]</a>
<a name="ln2438">      || peer-&gt;afc_nego[AFI_IP6][SAFI_ENCAP])</a>
<a name="ln2439">    return 1;</a>
<a name="ln2440">  return 0;</a>
<a name="ln2441">}</a>
<a name="ln2442"> </a>
<a name="ln2443">/* peer_flag_change_type. */</a>
<a name="ln2444">enum peer_change_type</a>
<a name="ln2445">{</a>
<a name="ln2446">  peer_change_none,</a>
<a name="ln2447">  peer_change_reset,</a>
<a name="ln2448">  peer_change_reset_in,</a>
<a name="ln2449">  peer_change_reset_out,</a>
<a name="ln2450">};</a>
<a name="ln2451"> </a>
<a name="ln2452">static void</a>
<a name="ln2453">peer_change_action (struct peer *peer, afi_t afi, safi_t safi,</a>
<a name="ln2454">		    enum peer_change_type type)</a>
<a name="ln2455">{</a>
<a name="ln2456">  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln2457">    return;</a>
<a name="ln2458"> </a>
<a name="ln2459">  if (peer-&gt;status != Established)</a>
<a name="ln2460">    return;</a>
<a name="ln2461"> </a>
<a name="ln2462">  if (type == peer_change_reset)</a>
<a name="ln2463">    bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln2464">		     BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln2465">  else if (type == peer_change_reset_in)</a>
<a name="ln2466">    {</a>
<a name="ln2467">      if (CHECK_FLAG (peer-&gt;cap, PEER_CAP_REFRESH_OLD_RCV)</a>
<a name="ln2468">	  || CHECK_FLAG (peer-&gt;cap, PEER_CAP_REFRESH_NEW_RCV))</a>
<a name="ln2469">	bgp_route_refresh_send (peer, afi, safi, 0, 0, 0);</a>
<a name="ln2470">      else</a>
<a name="ln2471">	bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln2472">			 BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln2473">    }</a>
<a name="ln2474">  else if (type == peer_change_reset_out)</a>
<a name="ln2475">    bgp_announce_route (peer, afi, safi);</a>
<a name="ln2476">}</a>
<a name="ln2477"> </a>
<a name="ln2478">struct peer_flag_action</a>
<a name="ln2479">{</a>
<a name="ln2480">  /* Peer's flag.  */</a>
<a name="ln2481">  u_int32_t flag;</a>
<a name="ln2482"> </a>
<a name="ln2483">  /* This flag can be set for peer-group member.  */</a>
<a name="ln2484">  u_char not_for_member;</a>
<a name="ln2485"> </a>
<a name="ln2486">  /* Action when the flag is changed.  */</a>
<a name="ln2487">  enum peer_change_type type;</a>
<a name="ln2488"> </a>
<a name="ln2489">  /* Peer down cause */</a>
<a name="ln2490">  u_char peer_down;</a>
<a name="ln2491">};</a>
<a name="ln2492"> </a>
<a name="ln2493">static const struct peer_flag_action peer_flag_action_list[] =</a>
<a name="ln2494">  {</a>
<a name="ln2495">    { PEER_FLAG_PASSIVE,                  0, peer_change_reset },</a>
<a name="ln2496">    { PEER_FLAG_SHUTDOWN,                 0, peer_change_reset },</a>
<a name="ln2497">    { PEER_FLAG_DONT_CAPABILITY,          0, peer_change_none },</a>
<a name="ln2498">    { PEER_FLAG_OVERRIDE_CAPABILITY,      0, peer_change_none },</a>
<a name="ln2499">    { PEER_FLAG_STRICT_CAP_MATCH,         0, peer_change_none },</a>
<a name="ln2500">    { PEER_FLAG_DYNAMIC_CAPABILITY,       0, peer_change_reset },</a>
<a name="ln2501">    { PEER_FLAG_DISABLE_CONNECTED_CHECK,  0, peer_change_reset },</a>
<a name="ln2502">    { 0, 0, 0 }</a>
<a name="ln2503">  };</a>
<a name="ln2504"> </a>
<a name="ln2505">static const struct peer_flag_action peer_af_flag_action_list[] =</a>
<a name="ln2506">  {</a>
<a name="ln2507">    { PEER_FLAG_NEXTHOP_SELF,             1, peer_change_reset_out },</a>
<a name="ln2508">    { PEER_FLAG_SEND_COMMUNITY,           1, peer_change_reset_out },</a>
<a name="ln2509">    { PEER_FLAG_SEND_EXT_COMMUNITY,       1, peer_change_reset_out },</a>
<a name="ln2510">    { PEER_FLAG_SEND_LARGE_COMMUNITY,     1, peer_change_reset_out },</a>
<a name="ln2511">    { PEER_FLAG_SOFT_RECONFIG,            0, peer_change_reset_in },</a>
<a name="ln2512">    { PEER_FLAG_REFLECTOR_CLIENT,         1, peer_change_reset },</a>
<a name="ln2513">    { PEER_FLAG_RSERVER_CLIENT,           1, peer_change_reset },</a>
<a name="ln2514">    { PEER_FLAG_AS_PATH_UNCHANGED,        1, peer_change_reset_out },</a>
<a name="ln2515">    { PEER_FLAG_NEXTHOP_UNCHANGED,        1, peer_change_reset_out },</a>
<a name="ln2516">    { PEER_FLAG_MED_UNCHANGED,            1, peer_change_reset_out },</a>
<a name="ln2517">    { PEER_FLAG_REMOVE_PRIVATE_AS,        1, peer_change_reset_out },</a>
<a name="ln2518">    { PEER_FLAG_ALLOWAS_IN,               0, peer_change_reset_in },</a>
<a name="ln2519">    { PEER_FLAG_ORF_PREFIX_SM,            1, peer_change_reset },</a>
<a name="ln2520">    { PEER_FLAG_ORF_PREFIX_RM,            1, peer_change_reset },</a>
<a name="ln2521">    { PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED,  0, peer_change_reset_out },</a>
<a name="ln2522">    { PEER_FLAG_NEXTHOP_SELF_ALL,         1, peer_change_reset_out },</a>
<a name="ln2523">    { 0, 0, 0 }</a>
<a name="ln2524">  };</a>
<a name="ln2525"> </a>
<a name="ln2526">/* Proper action set. */</a>
<a name="ln2527">static int</a>
<a name="ln2528">peer_flag_action_set (const struct peer_flag_action *action_list, int size,</a>
<a name="ln2529">		      struct peer_flag_action *action, u_int32_t flag)</a>
<a name="ln2530">{</a>
<a name="ln2531">  int i;</a>
<a name="ln2532">  int found = 0;</a>
<a name="ln2533">  int reset_in = 0;</a>
<a name="ln2534">  int reset_out = 0;</a>
<a name="ln2535">  const struct peer_flag_action *match = NULL;</a>
<a name="ln2536"> </a>
<a name="ln2537">  /* Check peer's frag action.  */</a>
<a name="ln2538">  for (i = 0; i &lt; size; i++)</a>
<a name="ln2539">    {</a>
<a name="ln2540">      match = &amp;action_list[i];</a>
<a name="ln2541"> </a>
<a name="ln2542">      if (match-&gt;flag == 0)</a>
<a name="ln2543">	break;</a>
<a name="ln2544"> </a>
<a name="ln2545">      if (match-&gt;flag &amp; flag)</a>
<a name="ln2546">	{</a>
<a name="ln2547">	  found = 1;</a>
<a name="ln2548"> </a>
<a name="ln2549">	  if (match-&gt;type == peer_change_reset_in)</a>
<a name="ln2550">	    reset_in = 1;</a>
<a name="ln2551">	  if (match-&gt;type == peer_change_reset_out)</a>
<a name="ln2552">	    reset_out = 1;</a>
<a name="ln2553">	  if (match-&gt;type == peer_change_reset)</a>
<a name="ln2554">	    {</a>
<a name="ln2555">	      reset_in = 1;</a>
<a name="ln2556">	      reset_out = 1;</a>
<a name="ln2557">	    }</a>
<a name="ln2558">	  if (match-&gt;not_for_member)</a>
<a name="ln2559">	    action-&gt;not_for_member = 1;</a>
<a name="ln2560">	}</a>
<a name="ln2561">    }</a>
<a name="ln2562"> </a>
<a name="ln2563">  /* Set peer clear type.  */</a>
<a name="ln2564">  if (reset_in &amp;&amp; reset_out)</a>
<a name="ln2565">    action-&gt;type = peer_change_reset;</a>
<a name="ln2566">  else if (reset_in)</a>
<a name="ln2567">    action-&gt;type = peer_change_reset_in;</a>
<a name="ln2568">  else if (reset_out)</a>
<a name="ln2569">    action-&gt;type = peer_change_reset_out;</a>
<a name="ln2570">  else</a>
<a name="ln2571">    action-&gt;type = peer_change_none;</a>
<a name="ln2572"> </a>
<a name="ln2573">  return found;</a>
<a name="ln2574">}</a>
<a name="ln2575"> </a>
<a name="ln2576">static void</a>
<a name="ln2577">peer_flag_modify_action (struct peer *peer, u_int32_t flag)</a>
<a name="ln2578">{</a>
<a name="ln2579">  if (flag == PEER_FLAG_SHUTDOWN)</a>
<a name="ln2580">    {</a>
<a name="ln2581">      if (CHECK_FLAG (peer-&gt;flags, flag))</a>
<a name="ln2582">	{</a>
<a name="ln2583">	  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_NSF_WAIT))</a>
<a name="ln2584">	    peer_nsf_stop (peer);</a>
<a name="ln2585"> </a>
<a name="ln2586">	  UNSET_FLAG (peer-&gt;sflags, PEER_STATUS_PREFIX_OVERFLOW);</a>
<a name="ln2587">	  if (peer-&gt;t_pmax_restart)</a>
<a name="ln2588">	    {</a>
<a name="ln2589">	      BGP_TIMER_OFF (peer-&gt;t_pmax_restart);</a>
<a name="ln2590">              if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln2591">		zlog_debug (&quot;%s Maximum-prefix restart timer canceled&quot;,</a>
<a name="ln2592">			    peer-&gt;host);</a>
<a name="ln2593">	    }</a>
<a name="ln2594"> </a>
<a name="ln2595">      if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_NSF_WAIT))</a>
<a name="ln2596">	peer_nsf_stop (peer);</a>
<a name="ln2597"> </a>
<a name="ln2598">	  if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln2599">	    bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln2600">			     BGP_NOTIFY_CEASE_ADMIN_SHUTDOWN);</a>
<a name="ln2601">	  else</a>
<a name="ln2602">	    BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln2603">	}</a>
<a name="ln2604">      else</a>
<a name="ln2605">	{</a>
<a name="ln2606">	  peer-&gt;v_start = BGP_INIT_START_TIMER;</a>
<a name="ln2607">	  BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln2608">	}</a>
<a name="ln2609">    }</a>
<a name="ln2610">  else if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln2611">    {</a>
<a name="ln2612">      if (flag == PEER_FLAG_DYNAMIC_CAPABILITY)</a>
<a name="ln2613">	peer-&gt;last_reset = PEER_DOWN_CAPABILITY_CHANGE;</a>
<a name="ln2614">      else if (flag == PEER_FLAG_PASSIVE)</a>
<a name="ln2615">	peer-&gt;last_reset = PEER_DOWN_PASSIVE_CHANGE;</a>
<a name="ln2616">      else if (flag == PEER_FLAG_DISABLE_CONNECTED_CHECK)</a>
<a name="ln2617">	peer-&gt;last_reset = PEER_DOWN_MULTIHOP_CHANGE;</a>
<a name="ln2618"> </a>
<a name="ln2619">      bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln2620">		       BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln2621">    }</a>
<a name="ln2622">  else</a>
<a name="ln2623">    BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln2624">}</a>
<a name="ln2625"> </a>
<a name="ln2626">/* Change specified peer flag. */</a>
<a name="ln2627">static int</a>
<a name="ln2628">peer_flag_modify (struct peer *peer, u_int32_t flag, int set)</a>
<a name="ln2629">{</a>
<a name="ln2630">  int found;</a>
<a name="ln2631">  int size;</a>
<a name="ln2632">  struct peer_group *group;</a>
<a name="ln2633">  struct listnode *node, *nnode;</a>
<a name="ln2634">  struct peer_flag_action action;</a>
<a name="ln2635"> </a>
<a name="ln2636">  memset (&amp;action, 0, sizeof (struct peer_flag_action));</a>
<a name="ln2637">  size = sizeof peer_flag_action_list / sizeof (struct peer_flag_action);</a>
<a name="ln2638"> </a>
<a name="ln2639">  found = peer_flag_action_set (peer_flag_action_list, size, &amp;action, flag);</a>
<a name="ln2640"> </a>
<a name="ln2641">  /* No flag action is found.  */</a>
<a name="ln2642">  if (! found)</a>
<a name="ln2643">    return BGP_ERR_INVALID_FLAG;    </a>
<a name="ln2644"> </a>
<a name="ln2645">  /* Not for peer-group member.  */</a>
<a name="ln2646">  if (action.not_for_member &amp;&amp; peer_group_active (peer))</a>
<a name="ln2647">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln2648"> </a>
<a name="ln2649">  /* When unset the peer-group member's flag we have to check</a>
<a name="ln2650">     peer-group configuration.  */</a>
<a name="ln2651">  if (! set &amp;&amp; peer_group_active (peer))</a>
<a name="ln2652">    if (CHECK_FLAG (peer-&gt;group-&gt;conf-&gt;flags, flag))</a>
<a name="ln2653">      {</a>
<a name="ln2654">	if (flag == PEER_FLAG_SHUTDOWN)</a>
<a name="ln2655">	  return BGP_ERR_PEER_GROUP_SHUTDOWN;</a>
<a name="ln2656">	else</a>
<a name="ln2657">	  return BGP_ERR_PEER_GROUP_HAS_THE_FLAG;</a>
<a name="ln2658">      }</a>
<a name="ln2659"> </a>
<a name="ln2660">  /* Flag conflict check.  */</a>
<a name="ln2661">  if (set</a>
<a name="ln2662">      &amp;&amp; CHECK_FLAG (peer-&gt;flags | flag, PEER_FLAG_STRICT_CAP_MATCH)</a>
<a name="ln2663">      &amp;&amp; CHECK_FLAG (peer-&gt;flags | flag, PEER_FLAG_OVERRIDE_CAPABILITY))</a>
<a name="ln2664">    return BGP_ERR_PEER_FLAG_CONFLICT;</a>
<a name="ln2665"> </a>
<a name="ln2666">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln2667">    {</a>
<a name="ln2668">      if (set &amp;&amp; CHECK_FLAG (peer-&gt;flags, flag) == flag)</a>
<a name="ln2669">	return 0;</a>
<a name="ln2670">      if (! set &amp;&amp; ! CHECK_FLAG (peer-&gt;flags, flag))</a>
<a name="ln2671">	return 0;</a>
<a name="ln2672">    }</a>
<a name="ln2673"> </a>
<a name="ln2674">  if (set)</a>
<a name="ln2675">    SET_FLAG (peer-&gt;flags, flag);</a>
<a name="ln2676">  else</a>
<a name="ln2677">    UNSET_FLAG (peer-&gt;flags, flag);</a>
<a name="ln2678"> </a>
<a name="ln2679">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln2680">    {</a>
<a name="ln2681">      if (action.type == peer_change_reset)</a>
<a name="ln2682">	peer_flag_modify_action (peer, flag);</a>
<a name="ln2683"> </a>
<a name="ln2684">      return 0;</a>
<a name="ln2685">    }</a>
<a name="ln2686"> </a>
<a name="ln2687">  /* peer-group member updates. */</a>
<a name="ln2688">  group = peer-&gt;group;</a>
<a name="ln2689"> </a>
<a name="ln2690">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln2691">    {</a>
<a name="ln2692">      if (set &amp;&amp; CHECK_FLAG (peer-&gt;flags, flag) == flag)</a>
<a name="ln2693">	continue;</a>
<a name="ln2694"> </a>
<a name="ln2695">      if (! set &amp;&amp; ! CHECK_FLAG (peer-&gt;flags, flag))</a>
<a name="ln2696">	continue;</a>
<a name="ln2697"> </a>
<a name="ln2698">      if (set)</a>
<a name="ln2699">	SET_FLAG (peer-&gt;flags, flag);</a>
<a name="ln2700">      else</a>
<a name="ln2701">	UNSET_FLAG (peer-&gt;flags, flag);</a>
<a name="ln2702"> </a>
<a name="ln2703">      if (action.type == peer_change_reset)</a>
<a name="ln2704">	peer_flag_modify_action (peer, flag);</a>
<a name="ln2705">    }</a>
<a name="ln2706">  return 0;</a>
<a name="ln2707">}</a>
<a name="ln2708"> </a>
<a name="ln2709">int</a>
<a name="ln2710">peer_flag_set (struct peer *peer, u_int32_t flag)</a>
<a name="ln2711">{</a>
<a name="ln2712">  return peer_flag_modify (peer, flag, 1);</a>
<a name="ln2713">}</a>
<a name="ln2714"> </a>
<a name="ln2715">int</a>
<a name="ln2716">peer_flag_unset (struct peer *peer, u_int32_t flag)</a>
<a name="ln2717">{</a>
<a name="ln2718">  return peer_flag_modify (peer, flag, 0);</a>
<a name="ln2719">}</a>
<a name="ln2720"> </a>
<a name="ln2721">static int</a>
<a name="ln2722">peer_is_group_member (struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln2723">{</a>
<a name="ln2724">  if (peer-&gt;af_group[afi][safi])</a>
<a name="ln2725">    return 1;</a>
<a name="ln2726">  return 0;</a>
<a name="ln2727">}</a>
<a name="ln2728"> </a>
<a name="ln2729">static int</a>
<a name="ln2730">peer_af_flag_modify (struct peer *peer, afi_t afi, safi_t safi, u_int32_t flag,</a>
<a name="ln2731">		     int set)</a>
<a name="ln2732">{</a>
<a name="ln2733">  int found;</a>
<a name="ln2734">  int size;</a>
<a name="ln2735">  struct listnode *node, *nnode;</a>
<a name="ln2736">  struct peer_group *group;</a>
<a name="ln2737">  struct peer_flag_action action;</a>
<a name="ln2738"> </a>
<a name="ln2739">  memset (&amp;action, 0, sizeof (struct peer_flag_action));</a>
<a name="ln2740">  size = sizeof peer_af_flag_action_list / sizeof (struct peer_flag_action);</a>
<a name="ln2741">  </a>
<a name="ln2742">  found = peer_flag_action_set (peer_af_flag_action_list, size, &amp;action, flag);</a>
<a name="ln2743">  </a>
<a name="ln2744">  /* No flag action is found.  */</a>
<a name="ln2745">  if (! found)</a>
<a name="ln2746">    return BGP_ERR_INVALID_FLAG;    </a>
<a name="ln2747"> </a>
<a name="ln2748">  /* Adress family must be activated.  */</a>
<a name="ln2749">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln2750">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln2751"> </a>
<a name="ln2752">  /* Not for peer-group member.  */</a>
<a name="ln2753">  if (action.not_for_member &amp;&amp; peer_is_group_member (peer, afi, safi))</a>
<a name="ln2754">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln2755"> </a>
<a name="ln2756"> /* Spcecial check for reflector client.  */</a>
<a name="ln2757">  if (flag &amp; PEER_FLAG_REFLECTOR_CLIENT</a>
<a name="ln2758">      &amp;&amp; peer_sort (peer) != BGP_PEER_IBGP)</a>
<a name="ln2759">    return BGP_ERR_NOT_INTERNAL_PEER;</a>
<a name="ln2760"> </a>
<a name="ln2761">  /* Spcecial check for remove-private-AS.  */</a>
<a name="ln2762">  if (flag &amp; PEER_FLAG_REMOVE_PRIVATE_AS</a>
<a name="ln2763">      &amp;&amp; peer_sort (peer) == BGP_PEER_IBGP)</a>
<a name="ln2764">    return BGP_ERR_REMOVE_PRIVATE_AS;</a>
<a name="ln2765"> </a>
<a name="ln2766">  /* When unset the peer-group member's flag we have to check</a>
<a name="ln2767">     peer-group configuration.  */</a>
<a name="ln2768">  if (! set &amp;&amp; peer-&gt;af_group[afi][safi])</a>
<a name="ln2769">    if (CHECK_FLAG (peer-&gt;group-&gt;conf-&gt;af_flags[afi][safi], flag))</a>
<a name="ln2770">      return BGP_ERR_PEER_GROUP_HAS_THE_FLAG;</a>
<a name="ln2771"> </a>
<a name="ln2772">  /* When current flag configuration is same as requested one.  */</a>
<a name="ln2773">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln2774">    {</a>
<a name="ln2775">      if (set &amp;&amp; CHECK_FLAG (peer-&gt;af_flags[afi][safi], flag) == flag)</a>
<a name="ln2776">	return 0;</a>
<a name="ln2777">      if (! set &amp;&amp; ! CHECK_FLAG (peer-&gt;af_flags[afi][safi], flag))</a>
<a name="ln2778">	return 0;</a>
<a name="ln2779">    }</a>
<a name="ln2780"> </a>
<a name="ln2781">  if (set)</a>
<a name="ln2782">    SET_FLAG (peer-&gt;af_flags[afi][safi], flag);</a>
<a name="ln2783">  else</a>
<a name="ln2784">    UNSET_FLAG (peer-&gt;af_flags[afi][safi], flag);</a>
<a name="ln2785"> </a>
<a name="ln2786">  /* Execute action when peer is established.  */</a>
<a name="ln2787">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP)</a>
<a name="ln2788">      &amp;&amp; peer-&gt;status == Established)</a>
<a name="ln2789">    {</a>
<a name="ln2790">      if (! set &amp;&amp; flag == PEER_FLAG_SOFT_RECONFIG)</a>
<a name="ln2791">	bgp_clear_adj_in (peer, afi, safi);</a>
<a name="ln2792">      else</a>
<a name="ln2793">       {</a>
<a name="ln2794">         if (flag == PEER_FLAG_REFLECTOR_CLIENT)</a>
<a name="ln2795">           peer-&gt;last_reset = PEER_DOWN_RR_CLIENT_CHANGE;</a>
<a name="ln2796">         else if (flag == PEER_FLAG_RSERVER_CLIENT)</a>
<a name="ln2797">           peer-&gt;last_reset = PEER_DOWN_RS_CLIENT_CHANGE;</a>
<a name="ln2798">         else if (flag == PEER_FLAG_ORF_PREFIX_SM)</a>
<a name="ln2799">           peer-&gt;last_reset = PEER_DOWN_CAPABILITY_CHANGE;</a>
<a name="ln2800">         else if (flag == PEER_FLAG_ORF_PREFIX_RM)</a>
<a name="ln2801">           peer-&gt;last_reset = PEER_DOWN_CAPABILITY_CHANGE;</a>
<a name="ln2802"> </a>
<a name="ln2803">         peer_change_action (peer, afi, safi, action.type);</a>
<a name="ln2804">       }</a>
<a name="ln2805"> </a>
<a name="ln2806">    }</a>
<a name="ln2807"> </a>
<a name="ln2808">  /* Peer group member updates.  */</a>
<a name="ln2809">  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln2810">    {</a>
<a name="ln2811">      group = peer-&gt;group;</a>
<a name="ln2812">      </a>
<a name="ln2813">      for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln2814">	{</a>
<a name="ln2815">	  if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln2816">	    continue;</a>
<a name="ln2817"> </a>
<a name="ln2818">	  if (set &amp;&amp; CHECK_FLAG (peer-&gt;af_flags[afi][safi], flag) == flag)</a>
<a name="ln2819">	    continue;</a>
<a name="ln2820"> </a>
<a name="ln2821">	  if (! set &amp;&amp; ! CHECK_FLAG (peer-&gt;af_flags[afi][safi], flag))</a>
<a name="ln2822">	    continue;</a>
<a name="ln2823"> </a>
<a name="ln2824">	  if (set)</a>
<a name="ln2825">	    SET_FLAG (peer-&gt;af_flags[afi][safi], flag);</a>
<a name="ln2826">	  else</a>
<a name="ln2827">	    UNSET_FLAG (peer-&gt;af_flags[afi][safi], flag);</a>
<a name="ln2828"> </a>
<a name="ln2829">	  if (peer-&gt;status == Established)</a>
<a name="ln2830">	    {</a>
<a name="ln2831">	      if (! set &amp;&amp; flag == PEER_FLAG_SOFT_RECONFIG)</a>
<a name="ln2832">		bgp_clear_adj_in (peer, afi, safi);</a>
<a name="ln2833">	      else</a>
<a name="ln2834">               {</a>
<a name="ln2835">                 if (flag == PEER_FLAG_REFLECTOR_CLIENT)</a>
<a name="ln2836">                   peer-&gt;last_reset = PEER_DOWN_RR_CLIENT_CHANGE;</a>
<a name="ln2837">                 else if (flag == PEER_FLAG_RSERVER_CLIENT)</a>
<a name="ln2838">                   peer-&gt;last_reset = PEER_DOWN_RS_CLIENT_CHANGE;</a>
<a name="ln2839">                 else if (flag == PEER_FLAG_ORF_PREFIX_SM)</a>
<a name="ln2840">                   peer-&gt;last_reset = PEER_DOWN_CAPABILITY_CHANGE;</a>
<a name="ln2841">                 else if (flag == PEER_FLAG_ORF_PREFIX_RM)</a>
<a name="ln2842">                   peer-&gt;last_reset = PEER_DOWN_CAPABILITY_CHANGE;</a>
<a name="ln2843"> </a>
<a name="ln2844">                 peer_change_action (peer, afi, safi, action.type);</a>
<a name="ln2845">               }</a>
<a name="ln2846">	    }</a>
<a name="ln2847">	}</a>
<a name="ln2848">    }</a>
<a name="ln2849">  return 0;</a>
<a name="ln2850">}</a>
<a name="ln2851"> </a>
<a name="ln2852">int</a>
<a name="ln2853">peer_af_flag_set (struct peer *peer, afi_t afi, safi_t safi, u_int32_t flag)</a>
<a name="ln2854">{</a>
<a name="ln2855">  return peer_af_flag_modify (peer, afi, safi, flag, 1);</a>
<a name="ln2856">}</a>
<a name="ln2857"> </a>
<a name="ln2858">int</a>
<a name="ln2859">peer_af_flag_unset (struct peer *peer, afi_t afi, safi_t safi, u_int32_t flag)</a>
<a name="ln2860">{</a>
<a name="ln2861">  return peer_af_flag_modify (peer, afi, safi, flag, 0);</a>
<a name="ln2862">}</a>
<a name="ln2863"> </a>
<a name="ln2864">/* EBGP multihop configuration. */</a>
<a name="ln2865">int</a>
<a name="ln2866">peer_ebgp_multihop_set (struct peer *peer, int ttl)</a>
<a name="ln2867">{</a>
<a name="ln2868">  struct peer_group *group;</a>
<a name="ln2869">  struct listnode *node, *nnode;</a>
<a name="ln2870">  struct peer *peer1;</a>
<a name="ln2871"> </a>
<a name="ln2872">  if (peer-&gt;sort == BGP_PEER_IBGP)</a>
<a name="ln2873">    return BGP_ERR_NO_IBGP_WITH_TTLHACK;</a>
<a name="ln2874"> </a>
<a name="ln2875">  if (peer-&gt;gtsm_hops != 0)</a>
<a name="ln2876">    return BGP_ERR_NO_EBGP_MULTIHOP_WITH_TTLHACK;</a>
<a name="ln2877"> </a>
<a name="ln2878">  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln2879">    {</a>
<a name="ln2880">      group = peer-&gt;group;</a>
<a name="ln2881">      for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer1))</a>
<a name="ln2882">        {</a>
<a name="ln2883">          if (peer1-&gt;gtsm_hops != 0)</a>
<a name="ln2884">            return BGP_ERR_NO_EBGP_MULTIHOP_WITH_TTLHACK;</a>
<a name="ln2885">        }</a>
<a name="ln2886">    }</a>
<a name="ln2887"> </a>
<a name="ln2888">  peer-&gt;ttl = ttl;</a>
<a name="ln2889"> </a>
<a name="ln2890">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln2891">    {</a>
<a name="ln2892">      bgp_set_socket_ttl (peer, peer-&gt;fd);</a>
<a name="ln2893">    }</a>
<a name="ln2894">  else</a>
<a name="ln2895">    {</a>
<a name="ln2896">      group = peer-&gt;group;</a>
<a name="ln2897">      for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln2898">        {</a>
<a name="ln2899">          peer-&gt;ttl = ttl;</a>
<a name="ln2900">          bgp_set_socket_ttl (peer, peer-&gt;fd);</a>
<a name="ln2901">        }</a>
<a name="ln2902">    }</a>
<a name="ln2903"> </a>
<a name="ln2904">  return 0;</a>
<a name="ln2905">}</a>
<a name="ln2906"> </a>
<a name="ln2907">/* Neighbor description. */</a>
<a name="ln2908">int</a>
<a name="ln2909">peer_description_set (struct peer *peer, const char *desc)</a>
<a name="ln2910">{</a>
<a name="ln2911">  if (peer-&gt;desc)</a>
<a name="ln2912">    XFREE (MTYPE_PEER_DESC, peer-&gt;desc);</a>
<a name="ln2913"> </a>
<a name="ln2914">  peer-&gt;desc = XSTRDUP (MTYPE_PEER_DESC, desc);</a>
<a name="ln2915"> </a>
<a name="ln2916">  return 0;</a>
<a name="ln2917">}</a>
<a name="ln2918"> </a>
<a name="ln2919">int</a>
<a name="ln2920">peer_description_unset (struct peer *peer)</a>
<a name="ln2921">{</a>
<a name="ln2922">  if (peer-&gt;desc)</a>
<a name="ln2923">    XFREE (MTYPE_PEER_DESC, peer-&gt;desc);</a>
<a name="ln2924"> </a>
<a name="ln2925">  peer-&gt;desc = NULL;</a>
<a name="ln2926"> </a>
<a name="ln2927">  return 0;</a>
<a name="ln2928">}</a>
<a name="ln2929"> </a>
<a name="ln2930">/* Neighbor update-source. */</a>
<a name="ln2931">int</a>
<a name="ln2932">peer_update_source_if_set (struct peer *peer, const char *ifname)</a>
<a name="ln2933">{</a>
<a name="ln2934">  struct peer_group *group;</a>
<a name="ln2935">  struct listnode *node, *nnode;</a>
<a name="ln2936"> </a>
<a name="ln2937">  if (peer-&gt;update_if)</a>
<a name="ln2938">    {</a>
<a name="ln2939">      if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP)</a>
<a name="ln2940">	  &amp;&amp; strcmp (peer-&gt;update_if, ifname) == 0)</a>
<a name="ln2941">	return 0;</a>
<a name="ln2942"> </a>
<a name="ln2943">      XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln2944">      peer-&gt;update_if = NULL;</a>
<a name="ln2945">    }</a>
<a name="ln2946"> </a>
<a name="ln2947">  if (peer-&gt;update_source)</a>
<a name="ln2948">    {</a>
<a name="ln2949">      sockunion_free (peer-&gt;update_source);</a>
<a name="ln2950">      peer-&gt;update_source = NULL;</a>
<a name="ln2951">    }</a>
<a name="ln2952"> </a>
<a name="ln2953">  peer-&gt;update_if = XSTRDUP (MTYPE_PEER_UPDATE_SOURCE, ifname);</a>
<a name="ln2954"> </a>
<a name="ln2955">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln2956">    {</a>
<a name="ln2957">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln2958">       {</a>
<a name="ln2959">         peer-&gt;last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;</a>
<a name="ln2960">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln2961">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln2962">       }</a>
<a name="ln2963">      else</a>
<a name="ln2964">	BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln2965">      return 0;</a>
<a name="ln2966">    }</a>
<a name="ln2967"> </a>
<a name="ln2968">  /* peer-group member updates. */</a>
<a name="ln2969">  group = peer-&gt;group;</a>
<a name="ln2970">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln2971">    {</a>
<a name="ln2972">      if (peer-&gt;update_if)</a>
<a name="ln2973">	{</a>
<a name="ln2974">	  if (strcmp (peer-&gt;update_if, ifname) == 0)</a>
<a name="ln2975">	    continue;</a>
<a name="ln2976"> </a>
<a name="ln2977">	  XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln2978">	  peer-&gt;update_if = NULL;</a>
<a name="ln2979">	}</a>
<a name="ln2980"> </a>
<a name="ln2981">      if (peer-&gt;update_source)</a>
<a name="ln2982">	{</a>
<a name="ln2983">	  sockunion_free (peer-&gt;update_source);</a>
<a name="ln2984">	  peer-&gt;update_source = NULL;</a>
<a name="ln2985">	}</a>
<a name="ln2986"> </a>
<a name="ln2987">      peer-&gt;update_if = XSTRDUP (MTYPE_PEER_UPDATE_SOURCE, ifname);</a>
<a name="ln2988"> </a>
<a name="ln2989">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln2990">       {</a>
<a name="ln2991">         peer-&gt;last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;</a>
<a name="ln2992">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln2993">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln2994">       }</a>
<a name="ln2995">      else</a>
<a name="ln2996">	BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln2997">    }</a>
<a name="ln2998">  return 0;</a>
<a name="ln2999">}</a>
<a name="ln3000"> </a>
<a name="ln3001">int</a>
<a name="ln3002">peer_update_source_addr_set (struct peer *peer, const union sockunion *su)</a>
<a name="ln3003">{</a>
<a name="ln3004">  struct peer_group *group;</a>
<a name="ln3005">  struct listnode *node, *nnode;</a>
<a name="ln3006"> </a>
<a name="ln3007">  if (peer-&gt;update_source)</a>
<a name="ln3008">    {</a>
<a name="ln3009">      if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP)</a>
<a name="ln3010">	  &amp;&amp; sockunion_cmp (peer-&gt;update_source, su) == 0)</a>
<a name="ln3011">	return 0;</a>
<a name="ln3012">      sockunion_free (peer-&gt;update_source);</a>
<a name="ln3013">      peer-&gt;update_source = NULL;</a>
<a name="ln3014">    }</a>
<a name="ln3015"> </a>
<a name="ln3016">  if (peer-&gt;update_if)</a>
<a name="ln3017">    {</a>
<a name="ln3018">      XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln3019">      peer-&gt;update_if = NULL;</a>
<a name="ln3020">    }</a>
<a name="ln3021"> </a>
<a name="ln3022">  peer-&gt;update_source = sockunion_dup (su);</a>
<a name="ln3023"> </a>
<a name="ln3024">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3025">    {</a>
<a name="ln3026">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3027">       {</a>
<a name="ln3028">         peer-&gt;last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;</a>
<a name="ln3029">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln3030">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3031">       }</a>
<a name="ln3032">      else</a>
<a name="ln3033">	BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3034">      return 0;</a>
<a name="ln3035">    }</a>
<a name="ln3036"> </a>
<a name="ln3037">  /* peer-group member updates. */</a>
<a name="ln3038">  group = peer-&gt;group;</a>
<a name="ln3039">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3040">    {</a>
<a name="ln3041">      if (peer-&gt;update_source)</a>
<a name="ln3042">	{</a>
<a name="ln3043">	  if (sockunion_cmp (peer-&gt;update_source, su) == 0)</a>
<a name="ln3044">	    continue;</a>
<a name="ln3045">	  sockunion_free (peer-&gt;update_source);</a>
<a name="ln3046">	  peer-&gt;update_source = NULL;</a>
<a name="ln3047">	}</a>
<a name="ln3048"> </a>
<a name="ln3049">      if (peer-&gt;update_if)</a>
<a name="ln3050">	{</a>
<a name="ln3051">	  XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln3052">	  peer-&gt;update_if = NULL;</a>
<a name="ln3053">	}</a>
<a name="ln3054"> </a>
<a name="ln3055">      peer-&gt;update_source = sockunion_dup (su);</a>
<a name="ln3056"> </a>
<a name="ln3057">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3058">       {</a>
<a name="ln3059">         peer-&gt;last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;</a>
<a name="ln3060">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln3061">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3062">       }</a>
<a name="ln3063">      else</a>
<a name="ln3064">	BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3065">    }</a>
<a name="ln3066">  return 0;</a>
<a name="ln3067">}</a>
<a name="ln3068"> </a>
<a name="ln3069">int</a>
<a name="ln3070">peer_update_source_unset (struct peer *peer)</a>
<a name="ln3071">{</a>
<a name="ln3072">  union sockunion *su;</a>
<a name="ln3073">  struct peer_group *group;</a>
<a name="ln3074">  struct listnode *node, *nnode;</a>
<a name="ln3075"> </a>
<a name="ln3076">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP)</a>
<a name="ln3077">      &amp;&amp; ! peer-&gt;update_source</a>
<a name="ln3078">      &amp;&amp; ! peer-&gt;update_if)</a>
<a name="ln3079">    return 0;</a>
<a name="ln3080"> </a>
<a name="ln3081">  if (peer-&gt;update_source)</a>
<a name="ln3082">    {</a>
<a name="ln3083">      sockunion_free (peer-&gt;update_source);</a>
<a name="ln3084">      peer-&gt;update_source = NULL;</a>
<a name="ln3085">    }</a>
<a name="ln3086">  if (peer-&gt;update_if)</a>
<a name="ln3087">    {</a>
<a name="ln3088">      XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln3089">      peer-&gt;update_if = NULL;</a>
<a name="ln3090">    }</a>
<a name="ln3091"> </a>
<a name="ln3092">  if (peer_group_active (peer))</a>
<a name="ln3093">    {</a>
<a name="ln3094">      group = peer-&gt;group;</a>
<a name="ln3095"> </a>
<a name="ln3096">      if (group-&gt;conf-&gt;update_source)</a>
<a name="ln3097">	{</a>
<a name="ln3098">	  su = sockunion_dup (group-&gt;conf-&gt;update_source);</a>
<a name="ln3099">	  peer-&gt;update_source = su;</a>
<a name="ln3100">	}</a>
<a name="ln3101">      else if (group-&gt;conf-&gt;update_if)</a>
<a name="ln3102">	peer-&gt;update_if = </a>
<a name="ln3103">	  XSTRDUP (MTYPE_PEER_UPDATE_SOURCE, group-&gt;conf-&gt;update_if);</a>
<a name="ln3104">    }</a>
<a name="ln3105"> </a>
<a name="ln3106">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3107">    {</a>
<a name="ln3108">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3109">       {</a>
<a name="ln3110">         peer-&gt;last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;</a>
<a name="ln3111">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln3112">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3113">       }</a>
<a name="ln3114">      else</a>
<a name="ln3115">	BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3116">      return 0;</a>
<a name="ln3117">    }</a>
<a name="ln3118"> </a>
<a name="ln3119">  /* peer-group member updates. */</a>
<a name="ln3120">  group = peer-&gt;group;</a>
<a name="ln3121">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3122">    {</a>
<a name="ln3123">      if (! peer-&gt;update_source &amp;&amp; ! peer-&gt;update_if)</a>
<a name="ln3124">	continue;</a>
<a name="ln3125"> </a>
<a name="ln3126">      if (peer-&gt;update_source)</a>
<a name="ln3127">	{</a>
<a name="ln3128">	  sockunion_free (peer-&gt;update_source);</a>
<a name="ln3129">	  peer-&gt;update_source = NULL;</a>
<a name="ln3130">	}</a>
<a name="ln3131"> </a>
<a name="ln3132">      if (peer-&gt;update_if)</a>
<a name="ln3133">	{</a>
<a name="ln3134">	  XFREE (MTYPE_PEER_UPDATE_SOURCE, peer-&gt;update_if);</a>
<a name="ln3135">	  peer-&gt;update_if = NULL;</a>
<a name="ln3136">	}</a>
<a name="ln3137"> </a>
<a name="ln3138">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3139">       {</a>
<a name="ln3140">         peer-&gt;last_reset = PEER_DOWN_UPDATE_SOURCE_CHANGE;</a>
<a name="ln3141">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln3142">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3143">       }</a>
<a name="ln3144">      else</a>
<a name="ln3145">	BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3146">    }</a>
<a name="ln3147">  return 0;</a>
<a name="ln3148">}</a>
<a name="ln3149"> </a>
<a name="ln3150">int</a>
<a name="ln3151">peer_default_originate_set (struct peer *peer, afi_t afi, safi_t safi,</a>
<a name="ln3152">			    const char *rmap)</a>
<a name="ln3153">{</a>
<a name="ln3154">  struct peer_group *group;</a>
<a name="ln3155">  struct listnode *node, *nnode;</a>
<a name="ln3156"> </a>
<a name="ln3157">  /* Adress family must be activated.  */</a>
<a name="ln3158">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln3159">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln3160"> </a>
<a name="ln3161">  /* Default originate can't be used for peer group memeber.  */</a>
<a name="ln3162">  if (peer_is_group_member (peer, afi, safi))</a>
<a name="ln3163">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3164"> </a>
<a name="ln3165">  if (! CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_DEFAULT_ORIGINATE)</a>
<a name="ln3166">      || (rmap &amp;&amp; ! peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln3167">      || (rmap &amp;&amp; strcmp (rmap, peer-&gt;default_rmap[afi][safi].name) != 0))</a>
<a name="ln3168">    { </a>
<a name="ln3169">      SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_DEFAULT_ORIGINATE);</a>
<a name="ln3170"> </a>
<a name="ln3171">      if (rmap)</a>
<a name="ln3172">	{</a>
<a name="ln3173">	  if (peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln3174">	    free (peer-&gt;default_rmap[afi][safi].name);</a>
<a name="ln3175">	  peer-&gt;default_rmap[afi][safi].name = strdup (rmap);</a>
<a name="ln3176">	  peer-&gt;default_rmap[afi][safi].map = route_map_lookup_by_name (rmap);</a>
<a name="ln3177">	}</a>
<a name="ln3178">    }</a>
<a name="ln3179"> </a>
<a name="ln3180">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3181">    {</a>
<a name="ln3182">      if (peer-&gt;status == Established &amp;&amp; peer-&gt;afc_nego[afi][safi])</a>
<a name="ln3183">	bgp_default_originate (peer, afi, safi, 0);</a>
<a name="ln3184">      return 0;</a>
<a name="ln3185">    }</a>
<a name="ln3186"> </a>
<a name="ln3187">  /* peer-group member updates. */</a>
<a name="ln3188">  group = peer-&gt;group;</a>
<a name="ln3189">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3190">    {</a>
<a name="ln3191">      SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_DEFAULT_ORIGINATE);</a>
<a name="ln3192"> </a>
<a name="ln3193">      if (rmap)</a>
<a name="ln3194">	{</a>
<a name="ln3195">	  if (peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln3196">	    free (peer-&gt;default_rmap[afi][safi].name);</a>
<a name="ln3197">	  peer-&gt;default_rmap[afi][safi].name = strdup (rmap);</a>
<a name="ln3198">	  peer-&gt;default_rmap[afi][safi].map = route_map_lookup_by_name (rmap);</a>
<a name="ln3199">	}</a>
<a name="ln3200"> </a>
<a name="ln3201">      if (peer-&gt;status == Established &amp;&amp; peer-&gt;afc_nego[afi][safi])</a>
<a name="ln3202">	bgp_default_originate (peer, afi, safi, 0);</a>
<a name="ln3203">    }</a>
<a name="ln3204">  return 0;</a>
<a name="ln3205">}</a>
<a name="ln3206"> </a>
<a name="ln3207">int</a>
<a name="ln3208">peer_default_originate_unset (struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln3209">{</a>
<a name="ln3210">  struct peer_group *group;</a>
<a name="ln3211">  struct listnode *node, *nnode;</a>
<a name="ln3212"> </a>
<a name="ln3213">  /* Adress family must be activated.  */</a>
<a name="ln3214">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln3215">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln3216"> </a>
<a name="ln3217">  /* Default originate can't be used for peer group memeber.  */</a>
<a name="ln3218">  if (peer_is_group_member (peer, afi, safi))</a>
<a name="ln3219">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3220"> </a>
<a name="ln3221">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_DEFAULT_ORIGINATE))</a>
<a name="ln3222">    { </a>
<a name="ln3223">      UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_DEFAULT_ORIGINATE);</a>
<a name="ln3224"> </a>
<a name="ln3225">      if (peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln3226">	free (peer-&gt;default_rmap[afi][safi].name);</a>
<a name="ln3227">      peer-&gt;default_rmap[afi][safi].name = NULL;</a>
<a name="ln3228">      peer-&gt;default_rmap[afi][safi].map = NULL;</a>
<a name="ln3229">    }</a>
<a name="ln3230"> </a>
<a name="ln3231">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3232">    {</a>
<a name="ln3233">      if (peer-&gt;status == Established &amp;&amp; peer-&gt;afc_nego[afi][safi])</a>
<a name="ln3234">	bgp_default_originate (peer, afi, safi, 1);</a>
<a name="ln3235">      return 0;</a>
<a name="ln3236">    }</a>
<a name="ln3237"> </a>
<a name="ln3238">  /* peer-group member updates. */</a>
<a name="ln3239">  group = peer-&gt;group;</a>
<a name="ln3240">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3241">    {</a>
<a name="ln3242">      UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_DEFAULT_ORIGINATE);</a>
<a name="ln3243"> </a>
<a name="ln3244">      if (peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln3245">	free (peer-&gt;default_rmap[afi][safi].name);</a>
<a name="ln3246">      peer-&gt;default_rmap[afi][safi].name = NULL;</a>
<a name="ln3247">      peer-&gt;default_rmap[afi][safi].map = NULL;</a>
<a name="ln3248"> </a>
<a name="ln3249">      if (peer-&gt;status == Established &amp;&amp; peer-&gt;afc_nego[afi][safi])</a>
<a name="ln3250">	bgp_default_originate (peer, afi, safi, 1);</a>
<a name="ln3251">    }</a>
<a name="ln3252">  return 0;</a>
<a name="ln3253">}</a>
<a name="ln3254"> </a>
<a name="ln3255">int</a>
<a name="ln3256">peer_port_set (struct peer *peer, u_int16_t port)</a>
<a name="ln3257">{</a>
<a name="ln3258">  peer-&gt;port = port;</a>
<a name="ln3259">  return 0;</a>
<a name="ln3260">}</a>
<a name="ln3261"> </a>
<a name="ln3262">int</a>
<a name="ln3263">peer_port_unset (struct peer *peer)</a>
<a name="ln3264">{</a>
<a name="ln3265">  peer-&gt;port = BGP_PORT_DEFAULT;</a>
<a name="ln3266">  return 0;</a>
<a name="ln3267">}</a>
<a name="ln3268"> </a>
<a name="ln3269">/* neighbor weight. */</a>
<a name="ln3270">int</a>
<a name="ln3271">peer_weight_set (struct peer *peer, u_int16_t weight)</a>
<a name="ln3272">{</a>
<a name="ln3273">  struct peer_group *group;</a>
<a name="ln3274">  struct listnode *node, *nnode;</a>
<a name="ln3275"> </a>
<a name="ln3276">  SET_FLAG (peer-&gt;config, PEER_CONFIG_WEIGHT);</a>
<a name="ln3277">  peer-&gt;weight = weight;</a>
<a name="ln3278"> </a>
<a name="ln3279">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3280">    return 0;</a>
<a name="ln3281"> </a>
<a name="ln3282">  /* peer-group member updates. */</a>
<a name="ln3283">  group = peer-&gt;group;</a>
<a name="ln3284">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3285">    {</a>
<a name="ln3286">      peer-&gt;weight = group-&gt;conf-&gt;weight;</a>
<a name="ln3287">    }</a>
<a name="ln3288">  return 0;</a>
<a name="ln3289">}</a>
<a name="ln3290"> </a>
<a name="ln3291">int</a>
<a name="ln3292">peer_weight_unset (struct peer *peer)</a>
<a name="ln3293">{</a>
<a name="ln3294">  struct peer_group *group;</a>
<a name="ln3295">  struct listnode *node, *nnode;</a>
<a name="ln3296"> </a>
<a name="ln3297">  /* Set default weight. */</a>
<a name="ln3298">  if (peer_group_active (peer))</a>
<a name="ln3299">    peer-&gt;weight = peer-&gt;group-&gt;conf-&gt;weight;</a>
<a name="ln3300">  else</a>
<a name="ln3301">    peer-&gt;weight = 0;</a>
<a name="ln3302"> </a>
<a name="ln3303">  UNSET_FLAG (peer-&gt;config, PEER_CONFIG_WEIGHT);</a>
<a name="ln3304"> </a>
<a name="ln3305">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3306">    return 0;</a>
<a name="ln3307"> </a>
<a name="ln3308">  /* peer-group member updates. */</a>
<a name="ln3309">  group = peer-&gt;group;</a>
<a name="ln3310">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3311">    {</a>
<a name="ln3312">      peer-&gt;weight = 0;</a>
<a name="ln3313">    }</a>
<a name="ln3314">  return 0;</a>
<a name="ln3315">}</a>
<a name="ln3316"> </a>
<a name="ln3317">int</a>
<a name="ln3318">peer_timers_set (struct peer *peer, u_int32_t keepalive, u_int32_t holdtime)</a>
<a name="ln3319">{</a>
<a name="ln3320">  struct peer_group *group;</a>
<a name="ln3321">  struct listnode *node, *nnode;</a>
<a name="ln3322"> </a>
<a name="ln3323">  /* Not for peer group memeber.  */</a>
<a name="ln3324">  if (peer_group_active (peer))</a>
<a name="ln3325">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3326"> </a>
<a name="ln3327">  /* keepalive value check.  */</a>
<a name="ln3328">  if (keepalive &gt; 65535)</a>
<a name="ln3329">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln3330"> </a>
<a name="ln3331">  /* Holdtime value check.  */</a>
<a name="ln3332">  if (holdtime &gt; 65535)</a>
<a name="ln3333">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln3334"> </a>
<a name="ln3335">  /* Holdtime value must be either 0 or greater than 3.  */</a>
<a name="ln3336">  if (holdtime &lt; 3 &amp;&amp; holdtime != 0)</a>
<a name="ln3337">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln3338"> </a>
<a name="ln3339">  /* Set value to the configuration. */</a>
<a name="ln3340">  SET_FLAG (peer-&gt;config, PEER_CONFIG_TIMER);</a>
<a name="ln3341">  peer-&gt;holdtime = holdtime;</a>
<a name="ln3342">  peer-&gt;keepalive = (keepalive &lt; holdtime / 3 ? keepalive : holdtime / 3);</a>
<a name="ln3343"> </a>
<a name="ln3344">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3345">    return 0;</a>
<a name="ln3346"> </a>
<a name="ln3347">  /* peer-group member updates. */</a>
<a name="ln3348">  group = peer-&gt;group;</a>
<a name="ln3349">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3350">    {</a>
<a name="ln3351">      SET_FLAG (peer-&gt;config, PEER_CONFIG_TIMER);</a>
<a name="ln3352">      peer-&gt;holdtime = group-&gt;conf-&gt;holdtime;</a>
<a name="ln3353">      peer-&gt;keepalive = group-&gt;conf-&gt;keepalive;</a>
<a name="ln3354">    }</a>
<a name="ln3355">  return 0;</a>
<a name="ln3356">}</a>
<a name="ln3357"> </a>
<a name="ln3358">int</a>
<a name="ln3359">peer_timers_unset (struct peer *peer)</a>
<a name="ln3360">{</a>
<a name="ln3361">  struct peer_group *group;</a>
<a name="ln3362">  struct listnode *node, *nnode;</a>
<a name="ln3363"> </a>
<a name="ln3364">  if (peer_group_active (peer))</a>
<a name="ln3365">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3366"> </a>
<a name="ln3367">  /* Clear configuration. */</a>
<a name="ln3368">  UNSET_FLAG (peer-&gt;config, PEER_CONFIG_TIMER);</a>
<a name="ln3369">  peer-&gt;keepalive = 0;</a>
<a name="ln3370">  peer-&gt;holdtime = 0;</a>
<a name="ln3371"> </a>
<a name="ln3372">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3373">    return 0;</a>
<a name="ln3374"> </a>
<a name="ln3375">  /* peer-group member updates. */</a>
<a name="ln3376">  group = peer-&gt;group;</a>
<a name="ln3377">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3378">    {</a>
<a name="ln3379">      UNSET_FLAG (peer-&gt;config, PEER_CONFIG_TIMER);</a>
<a name="ln3380">      peer-&gt;holdtime = 0;</a>
<a name="ln3381">      peer-&gt;keepalive = 0;</a>
<a name="ln3382">    }</a>
<a name="ln3383"> </a>
<a name="ln3384">  return 0;</a>
<a name="ln3385">}</a>
<a name="ln3386"> </a>
<a name="ln3387">int</a>
<a name="ln3388">peer_timers_connect_set (struct peer *peer, u_int32_t connect)</a>
<a name="ln3389">{</a>
<a name="ln3390">  struct peer_group *group;</a>
<a name="ln3391">  struct listnode *node, *nnode;</a>
<a name="ln3392"> </a>
<a name="ln3393">  if (peer_group_active (peer))</a>
<a name="ln3394">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3395"> </a>
<a name="ln3396">  if (connect &gt; 65535)</a>
<a name="ln3397">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln3398"> </a>
<a name="ln3399">  /* Set value to the configuration. */</a>
<a name="ln3400">  SET_FLAG (peer-&gt;config, PEER_CONFIG_CONNECT);</a>
<a name="ln3401">  peer-&gt;connect = connect;</a>
<a name="ln3402"> </a>
<a name="ln3403">  /* Set value to timer setting. */</a>
<a name="ln3404">  peer-&gt;v_connect = connect;</a>
<a name="ln3405"> </a>
<a name="ln3406">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3407">    return 0;</a>
<a name="ln3408"> </a>
<a name="ln3409">  /* peer-group member updates. */</a>
<a name="ln3410">  group = peer-&gt;group;</a>
<a name="ln3411">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3412">    {</a>
<a name="ln3413">      SET_FLAG (peer-&gt;config, PEER_CONFIG_CONNECT);</a>
<a name="ln3414">      peer-&gt;connect = connect;</a>
<a name="ln3415">      peer-&gt;v_connect = connect;</a>
<a name="ln3416">    }</a>
<a name="ln3417">  return 0;</a>
<a name="ln3418">}</a>
<a name="ln3419"> </a>
<a name="ln3420">int</a>
<a name="ln3421">peer_timers_connect_unset (struct peer *peer)</a>
<a name="ln3422">{</a>
<a name="ln3423">  struct peer_group *group;</a>
<a name="ln3424">  struct listnode *node, *nnode;</a>
<a name="ln3425"> </a>
<a name="ln3426">  if (peer_group_active (peer))</a>
<a name="ln3427">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3428"> </a>
<a name="ln3429">  /* Clear configuration. */</a>
<a name="ln3430">  UNSET_FLAG (peer-&gt;config, PEER_CONFIG_CONNECT);</a>
<a name="ln3431">  peer-&gt;connect = 0;</a>
<a name="ln3432"> </a>
<a name="ln3433">  /* Set timer setting to default value. */</a>
<a name="ln3434">  peer-&gt;v_connect = BGP_DEFAULT_CONNECT_RETRY;</a>
<a name="ln3435"> </a>
<a name="ln3436">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3437">    return 0;</a>
<a name="ln3438"> </a>
<a name="ln3439">  /* peer-group member updates. */</a>
<a name="ln3440">  group = peer-&gt;group;</a>
<a name="ln3441">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3442">    {</a>
<a name="ln3443">      UNSET_FLAG (peer-&gt;config, PEER_CONFIG_CONNECT);</a>
<a name="ln3444">      peer-&gt;connect = 0;</a>
<a name="ln3445">      peer-&gt;v_connect = BGP_DEFAULT_CONNECT_RETRY;</a>
<a name="ln3446">    }</a>
<a name="ln3447">   return 0;</a>
<a name="ln3448">}</a>
<a name="ln3449"> </a>
<a name="ln3450">int</a>
<a name="ln3451">peer_advertise_interval_set (struct peer *peer, u_int32_t routeadv)</a>
<a name="ln3452">{</a>
<a name="ln3453">  struct peer_group *group;</a>
<a name="ln3454">  struct listnode *node, *nnode;</a>
<a name="ln3455"> </a>
<a name="ln3456">  if (peer_group_active (peer))</a>
<a name="ln3457">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3458"> </a>
<a name="ln3459">  if (routeadv &gt; 600)</a>
<a name="ln3460">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln3461"> </a>
<a name="ln3462">  SET_FLAG (peer-&gt;config, PEER_CONFIG_ROUTEADV);</a>
<a name="ln3463">  peer-&gt;routeadv = routeadv;</a>
<a name="ln3464">  peer-&gt;v_routeadv = routeadv;</a>
<a name="ln3465"> </a>
<a name="ln3466">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3467">    return 0;</a>
<a name="ln3468"> </a>
<a name="ln3469">  /* peer-group member updates. */</a>
<a name="ln3470">  group = peer-&gt;group;</a>
<a name="ln3471">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3472">    {</a>
<a name="ln3473">      SET_FLAG (peer-&gt;config, PEER_CONFIG_ROUTEADV);</a>
<a name="ln3474">      peer-&gt;routeadv = routeadv;</a>
<a name="ln3475">      peer-&gt;v_routeadv = routeadv;</a>
<a name="ln3476">    }</a>
<a name="ln3477"> </a>
<a name="ln3478">  return 0;</a>
<a name="ln3479">}</a>
<a name="ln3480"> </a>
<a name="ln3481">int</a>
<a name="ln3482">peer_advertise_interval_unset (struct peer *peer)</a>
<a name="ln3483">{</a>
<a name="ln3484">  struct peer_group *group;</a>
<a name="ln3485">  struct listnode *node, *nnode;</a>
<a name="ln3486"> </a>
<a name="ln3487">  if (peer_group_active (peer))</a>
<a name="ln3488">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3489"> </a>
<a name="ln3490">  UNSET_FLAG (peer-&gt;config, PEER_CONFIG_ROUTEADV);</a>
<a name="ln3491">  peer-&gt;routeadv = 0;</a>
<a name="ln3492"> </a>
<a name="ln3493">  if (peer-&gt;sort == BGP_PEER_IBGP)</a>
<a name="ln3494">    peer-&gt;v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;</a>
<a name="ln3495">  else</a>
<a name="ln3496">    peer-&gt;v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;</a>
<a name="ln3497"> </a>
<a name="ln3498">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3499">    return 0;</a>
<a name="ln3500"> </a>
<a name="ln3501">  /* peer-group member updates. */</a>
<a name="ln3502">  group = peer-&gt;group;</a>
<a name="ln3503">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3504">    {</a>
<a name="ln3505">      UNSET_FLAG (peer-&gt;config, PEER_CONFIG_ROUTEADV);</a>
<a name="ln3506">      peer-&gt;routeadv = 0;</a>
<a name="ln3507"> </a>
<a name="ln3508">      if (peer-&gt;sort == BGP_PEER_IBGP)</a>
<a name="ln3509">        peer-&gt;v_routeadv = BGP_DEFAULT_IBGP_ROUTEADV;</a>
<a name="ln3510">      else</a>
<a name="ln3511">        peer-&gt;v_routeadv = BGP_DEFAULT_EBGP_ROUTEADV;</a>
<a name="ln3512">    }</a>
<a name="ln3513">  </a>
<a name="ln3514">  return 0;</a>
<a name="ln3515">}</a>
<a name="ln3516"> </a>
<a name="ln3517">/* neighbor interface */</a>
<a name="ln3518">int</a>
<a name="ln3519">peer_interface_set (struct peer *peer, const char *str)</a>
<a name="ln3520">{</a>
<a name="ln3521">  if (peer-&gt;ifname)</a>
<a name="ln3522">    free (peer-&gt;ifname);</a>
<a name="ln3523">  peer-&gt;ifname = strdup (str);</a>
<a name="ln3524"> </a>
<a name="ln3525">  return 0;</a>
<a name="ln3526">}</a>
<a name="ln3527"> </a>
<a name="ln3528">int</a>
<a name="ln3529">peer_interface_unset (struct peer *peer)</a>
<a name="ln3530">{</a>
<a name="ln3531">  if (peer-&gt;ifname)</a>
<a name="ln3532">    free (peer-&gt;ifname);</a>
<a name="ln3533">  peer-&gt;ifname = NULL;</a>
<a name="ln3534"> </a>
<a name="ln3535">  return 0;</a>
<a name="ln3536">}</a>
<a name="ln3537"> </a>
<a name="ln3538">/* Allow-as in.  */</a>
<a name="ln3539">int</a>
<a name="ln3540">peer_allowas_in_set (struct peer *peer, afi_t afi, safi_t safi, int allow_num)</a>
<a name="ln3541">{</a>
<a name="ln3542">  struct peer_group *group;</a>
<a name="ln3543">  struct listnode *node, *nnode;</a>
<a name="ln3544"> </a>
<a name="ln3545">  if (allow_num &lt; 1 || allow_num &gt; 10)</a>
<a name="ln3546">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln3547"> </a>
<a name="ln3548">  if (peer-&gt;allowas_in[afi][safi] != allow_num)</a>
<a name="ln3549">    {</a>
<a name="ln3550">      peer-&gt;allowas_in[afi][safi] = allow_num;</a>
<a name="ln3551">      SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ALLOWAS_IN);</a>
<a name="ln3552">      peer_change_action (peer, afi, safi, peer_change_reset_in);</a>
<a name="ln3553">    }</a>
<a name="ln3554"> </a>
<a name="ln3555">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3556">    return 0;</a>
<a name="ln3557"> </a>
<a name="ln3558">  group = peer-&gt;group;</a>
<a name="ln3559">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3560">    {</a>
<a name="ln3561">      if (peer-&gt;allowas_in[afi][safi] != allow_num)</a>
<a name="ln3562">	{</a>
<a name="ln3563">	  peer-&gt;allowas_in[afi][safi] = allow_num;</a>
<a name="ln3564">	  SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ALLOWAS_IN);</a>
<a name="ln3565">	  peer_change_action (peer, afi, safi, peer_change_reset_in);</a>
<a name="ln3566">	}</a>
<a name="ln3567">	  </a>
<a name="ln3568">    }</a>
<a name="ln3569">  return 0;</a>
<a name="ln3570">}</a>
<a name="ln3571"> </a>
<a name="ln3572">int</a>
<a name="ln3573">peer_allowas_in_unset (struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln3574">{</a>
<a name="ln3575">  struct peer_group *group;</a>
<a name="ln3576">  struct listnode *node, *nnode;</a>
<a name="ln3577"> </a>
<a name="ln3578">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ALLOWAS_IN))</a>
<a name="ln3579">    {</a>
<a name="ln3580">      peer-&gt;allowas_in[afi][safi] = 0;</a>
<a name="ln3581">      peer_af_flag_unset (peer, afi, safi, PEER_FLAG_ALLOWAS_IN);</a>
<a name="ln3582">    }</a>
<a name="ln3583"> </a>
<a name="ln3584">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3585">    return 0;</a>
<a name="ln3586"> </a>
<a name="ln3587">  group = peer-&gt;group;</a>
<a name="ln3588">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3589">    {</a>
<a name="ln3590">      if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ALLOWAS_IN))</a>
<a name="ln3591">	{</a>
<a name="ln3592">	  peer-&gt;allowas_in[afi][safi] = 0;</a>
<a name="ln3593">	  peer_af_flag_unset (peer, afi, safi, PEER_FLAG_ALLOWAS_IN);</a>
<a name="ln3594">	}</a>
<a name="ln3595">    }</a>
<a name="ln3596">  return 0;</a>
<a name="ln3597">}</a>
<a name="ln3598"> </a>
<a name="ln3599">int</a>
<a name="ln3600">peer_local_as_set (struct peer *peer, as_t as, int no_prepend, int replace_as)</a>
<a name="ln3601">{</a>
<a name="ln3602">  struct bgp *bgp = peer-&gt;bgp;</a>
<a name="ln3603">  struct peer_group *group;</a>
<a name="ln3604">  struct listnode *node, *nnode;</a>
<a name="ln3605"> </a>
<a name="ln3606">  if (peer_sort (peer) != BGP_PEER_EBGP</a>
<a name="ln3607">      &amp;&amp; peer_sort (peer) != BGP_PEER_INTERNAL)</a>
<a name="ln3608">    return BGP_ERR_LOCAL_AS_ALLOWED_ONLY_FOR_EBGP;</a>
<a name="ln3609"> </a>
<a name="ln3610">  if (bgp-&gt;as == as)</a>
<a name="ln3611">    return BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS;</a>
<a name="ln3612"> </a>
<a name="ln3613">  if (peer_group_active (peer))</a>
<a name="ln3614">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3615"> </a>
<a name="ln3616">  if (peer-&gt;as == as)</a>
<a name="ln3617">    return BGP_ERR_CANNOT_HAVE_LOCAL_AS_SAME_AS_REMOTE_AS;</a>
<a name="ln3618"> </a>
<a name="ln3619">  if (peer-&gt;change_local_as == as &amp;&amp;</a>
<a name="ln3620">      ((CHECK_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND) &amp;&amp; no_prepend)</a>
<a name="ln3621">       || (! CHECK_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND) &amp;&amp; ! no_prepend)) &amp;&amp;</a>
<a name="ln3622">      ((CHECK_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS) &amp;&amp; replace_as)</a>
<a name="ln3623">       || (! CHECK_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS) &amp;&amp; ! replace_as)))</a>
<a name="ln3624">    return 0;</a>
<a name="ln3625"> </a>
<a name="ln3626">  peer-&gt;change_local_as = as;</a>
<a name="ln3627">  if (no_prepend)</a>
<a name="ln3628">    SET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND);</a>
<a name="ln3629">  else</a>
<a name="ln3630">    UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND);</a>
<a name="ln3631"> </a>
<a name="ln3632">  if (replace_as)</a>
<a name="ln3633">    SET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS);</a>
<a name="ln3634">  else</a>
<a name="ln3635">    UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS);</a>
<a name="ln3636"> </a>
<a name="ln3637">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3638">    {</a>
<a name="ln3639">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3640">       {</a>
<a name="ln3641">         peer-&gt;last_reset = PEER_DOWN_LOCAL_AS_CHANGE;</a>
<a name="ln3642">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln3643">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3644">       }</a>
<a name="ln3645">      else</a>
<a name="ln3646">        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3647"> </a>
<a name="ln3648">      return 0;</a>
<a name="ln3649">    }</a>
<a name="ln3650"> </a>
<a name="ln3651">  group = peer-&gt;group;</a>
<a name="ln3652">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3653">    {</a>
<a name="ln3654">      peer-&gt;change_local_as = as;</a>
<a name="ln3655">      if (no_prepend)</a>
<a name="ln3656">	SET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND);</a>
<a name="ln3657">      else</a>
<a name="ln3658">	UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND);</a>
<a name="ln3659"> </a>
<a name="ln3660">      if (replace_as)</a>
<a name="ln3661">        SET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS);</a>
<a name="ln3662">      else</a>
<a name="ln3663">        UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS);</a>
<a name="ln3664"> </a>
<a name="ln3665">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3666">       {</a>
<a name="ln3667">         peer-&gt;last_reset = PEER_DOWN_LOCAL_AS_CHANGE;</a>
<a name="ln3668">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln3669">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3670">       }</a>
<a name="ln3671">      else</a>
<a name="ln3672">        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3673">    }</a>
<a name="ln3674"> </a>
<a name="ln3675">  return 0;</a>
<a name="ln3676">}</a>
<a name="ln3677"> </a>
<a name="ln3678">int</a>
<a name="ln3679">peer_local_as_unset (struct peer *peer)</a>
<a name="ln3680">{</a>
<a name="ln3681">  struct peer_group *group;</a>
<a name="ln3682">  struct listnode *node, *nnode;</a>
<a name="ln3683"> </a>
<a name="ln3684">  if (peer_group_active (peer))</a>
<a name="ln3685">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3686"> </a>
<a name="ln3687">  if (! peer-&gt;change_local_as)</a>
<a name="ln3688">    return 0;</a>
<a name="ln3689"> </a>
<a name="ln3690">  peer-&gt;change_local_as = 0;</a>
<a name="ln3691">  UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND);</a>
<a name="ln3692">  UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS);</a>
<a name="ln3693"> </a>
<a name="ln3694">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3695">    {</a>
<a name="ln3696">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3697">       {</a>
<a name="ln3698">         peer-&gt;last_reset = PEER_DOWN_LOCAL_AS_CHANGE;</a>
<a name="ln3699">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln3700">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3701">       }</a>
<a name="ln3702">      else</a>
<a name="ln3703">        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3704"> </a>
<a name="ln3705">      return 0;</a>
<a name="ln3706">    }</a>
<a name="ln3707"> </a>
<a name="ln3708">  group = peer-&gt;group;</a>
<a name="ln3709">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3710">    {</a>
<a name="ln3711">      peer-&gt;change_local_as = 0;</a>
<a name="ln3712">      UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND);</a>
<a name="ln3713">      UNSET_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS);</a>
<a name="ln3714"> </a>
<a name="ln3715">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3716">       {</a>
<a name="ln3717">         peer-&gt;last_reset = PEER_DOWN_LOCAL_AS_CHANGE;</a>
<a name="ln3718">         bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln3719">                          BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3720">       }</a>
<a name="ln3721">      else</a>
<a name="ln3722">        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3723">    }</a>
<a name="ln3724">  return 0;</a>
<a name="ln3725">}</a>
<a name="ln3726"> </a>
<a name="ln3727">/* Set password for authenticating with the peer. */</a>
<a name="ln3728">int</a>
<a name="ln3729">peer_password_set (struct peer *peer, const char *password)</a>
<a name="ln3730">{</a>
<a name="ln3731">  struct listnode *nn, *nnode;</a>
<a name="ln3732">  int len = password ? strlen(password) : 0;</a>
<a name="ln3733">  int ret = BGP_SUCCESS;</a>
<a name="ln3734"> </a>
<a name="ln3735">  if ((len &lt; PEER_PASSWORD_MINLEN) || (len &gt; PEER_PASSWORD_MAXLEN))</a>
<a name="ln3736">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln3737"> </a>
<a name="ln3738">  if (peer-&gt;password &amp;&amp; strcmp (peer-&gt;password, password) == 0</a>
<a name="ln3739">      &amp;&amp; ! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3740">    return 0;</a>
<a name="ln3741"> </a>
<a name="ln3742">  if (peer-&gt;password)</a>
<a name="ln3743">    XFREE (MTYPE_PEER_PASSWORD, peer-&gt;password);</a>
<a name="ln3744">  </a>
<a name="ln3745">  peer-&gt;password = XSTRDUP (MTYPE_PEER_PASSWORD, password);</a>
<a name="ln3746"> </a>
<a name="ln3747">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3748">    {</a>
<a name="ln3749">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3750">        bgp_notify_send (peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3751">      else</a>
<a name="ln3752">        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3753">        </a>
<a name="ln3754">      return (bgp_md5_set (peer) &gt;= 0) ? BGP_SUCCESS : BGP_ERR_TCPSIG_FAILED;</a>
<a name="ln3755">    }</a>
<a name="ln3756"> </a>
<a name="ln3757">  for (ALL_LIST_ELEMENTS (peer-&gt;group-&gt;peer, nn, nnode, peer))</a>
<a name="ln3758">    {</a>
<a name="ln3759">      if (peer-&gt;password &amp;&amp; strcmp (peer-&gt;password, password) == 0)</a>
<a name="ln3760">	continue;</a>
<a name="ln3761">      </a>
<a name="ln3762">      if (peer-&gt;password)</a>
<a name="ln3763">        XFREE (MTYPE_PEER_PASSWORD, peer-&gt;password);</a>
<a name="ln3764">      </a>
<a name="ln3765">      peer-&gt;password = XSTRDUP(MTYPE_PEER_PASSWORD, password);</a>
<a name="ln3766"> </a>
<a name="ln3767">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3768">        bgp_notify_send (peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3769">      else</a>
<a name="ln3770">        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3771">      </a>
<a name="ln3772">      if (bgp_md5_set (peer) &lt; 0)</a>
<a name="ln3773">        ret = BGP_ERR_TCPSIG_FAILED;</a>
<a name="ln3774">    }</a>
<a name="ln3775"> </a>
<a name="ln3776">  return ret;</a>
<a name="ln3777">}</a>
<a name="ln3778"> </a>
<a name="ln3779">int</a>
<a name="ln3780">peer_password_unset (struct peer *peer)</a>
<a name="ln3781">{</a>
<a name="ln3782">  struct listnode *nn, *nnode;</a>
<a name="ln3783"> </a>
<a name="ln3784">  if (!peer-&gt;password</a>
<a name="ln3785">      &amp;&amp; !CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3786">    return 0;</a>
<a name="ln3787"> </a>
<a name="ln3788">  if (!CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3789">    {</a>
<a name="ln3790">      if (peer_group_active (peer)</a>
<a name="ln3791">	  &amp;&amp; peer-&gt;group-&gt;conf-&gt;password</a>
<a name="ln3792">	  &amp;&amp; strcmp (peer-&gt;group-&gt;conf-&gt;password, peer-&gt;password) == 0)</a>
<a name="ln3793">	return BGP_ERR_PEER_GROUP_HAS_THE_FLAG;</a>
<a name="ln3794"> </a>
<a name="ln3795">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3796">        bgp_notify_send (peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3797">      else</a>
<a name="ln3798">        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3799"> </a>
<a name="ln3800">      if (peer-&gt;password)</a>
<a name="ln3801">        XFREE (MTYPE_PEER_PASSWORD, peer-&gt;password);</a>
<a name="ln3802">      </a>
<a name="ln3803">      peer-&gt;password = NULL;</a>
<a name="ln3804">      </a>
<a name="ln3805">      bgp_md5_set (peer);</a>
<a name="ln3806"> </a>
<a name="ln3807">      return 0;</a>
<a name="ln3808">    }</a>
<a name="ln3809"> </a>
<a name="ln3810">  XFREE (MTYPE_PEER_PASSWORD, peer-&gt;password);</a>
<a name="ln3811">  peer-&gt;password = NULL;</a>
<a name="ln3812"> </a>
<a name="ln3813">  for (ALL_LIST_ELEMENTS (peer-&gt;group-&gt;peer, nn, nnode, peer))</a>
<a name="ln3814">    {</a>
<a name="ln3815">      if (!peer-&gt;password)</a>
<a name="ln3816">	continue;</a>
<a name="ln3817"> </a>
<a name="ln3818">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln3819">        bgp_notify_send (peer, BGP_NOTIFY_CEASE, BGP_NOTIFY_CEASE_CONFIG_CHANGE);</a>
<a name="ln3820">      else</a>
<a name="ln3821">        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln3822">      </a>
<a name="ln3823">      XFREE (MTYPE_PEER_PASSWORD, peer-&gt;password);</a>
<a name="ln3824">      peer-&gt;password = NULL;</a>
<a name="ln3825"> </a>
<a name="ln3826">      bgp_md5_set (peer);</a>
<a name="ln3827">    }</a>
<a name="ln3828"> </a>
<a name="ln3829">  return 0;</a>
<a name="ln3830">}</a>
<a name="ln3831"> </a>
<a name="ln3832">/* Set distribute list to the peer. */</a>
<a name="ln3833">int</a>
<a name="ln3834">peer_distribute_set (struct peer *peer, afi_t afi, safi_t safi, int direct, </a>
<a name="ln3835">		     const char *name)</a>
<a name="ln3836">{</a>
<a name="ln3837">  struct bgp_filter *filter;</a>
<a name="ln3838">  struct peer_group *group;</a>
<a name="ln3839">  struct listnode *node, *nnode;</a>
<a name="ln3840"> </a>
<a name="ln3841">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln3842">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln3843"> </a>
<a name="ln3844">  if (direct != FILTER_IN &amp;&amp; direct != FILTER_OUT)</a>
<a name="ln3845">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln3846"> </a>
<a name="ln3847">  if (direct == FILTER_OUT &amp;&amp; peer_is_group_member (peer, afi, safi))</a>
<a name="ln3848">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3849"> </a>
<a name="ln3850">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln3851"> </a>
<a name="ln3852">  if (filter-&gt;plist[direct].name)</a>
<a name="ln3853">    return BGP_ERR_PEER_FILTER_CONFLICT;</a>
<a name="ln3854"> </a>
<a name="ln3855">  if (filter-&gt;dlist[direct].name)</a>
<a name="ln3856">    free (filter-&gt;dlist[direct].name);</a>
<a name="ln3857">  filter-&gt;dlist[direct].name = strdup (name);</a>
<a name="ln3858">  filter-&gt;dlist[direct].alist = access_list_lookup (afi, name);</a>
<a name="ln3859"> </a>
<a name="ln3860">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3861">    return 0;</a>
<a name="ln3862"> </a>
<a name="ln3863">  group = peer-&gt;group;</a>
<a name="ln3864">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3865">    {</a>
<a name="ln3866">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln3867"> </a>
<a name="ln3868">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln3869">	continue;</a>
<a name="ln3870"> </a>
<a name="ln3871">      if (filter-&gt;dlist[direct].name)</a>
<a name="ln3872">	free (filter-&gt;dlist[direct].name);</a>
<a name="ln3873">      filter-&gt;dlist[direct].name = strdup (name);</a>
<a name="ln3874">      filter-&gt;dlist[direct].alist = access_list_lookup (afi, name);</a>
<a name="ln3875">    }</a>
<a name="ln3876"> </a>
<a name="ln3877">  return 0;</a>
<a name="ln3878">}</a>
<a name="ln3879"> </a>
<a name="ln3880">int</a>
<a name="ln3881">peer_distribute_unset (struct peer *peer, afi_t afi, safi_t safi, int direct)</a>
<a name="ln3882">{</a>
<a name="ln3883">  struct bgp_filter *filter;</a>
<a name="ln3884">  struct bgp_filter *gfilter;</a>
<a name="ln3885">  struct peer_group *group;</a>
<a name="ln3886">  struct listnode *node, *nnode;</a>
<a name="ln3887"> </a>
<a name="ln3888">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln3889">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln3890"> </a>
<a name="ln3891">  if (direct != FILTER_IN &amp;&amp; direct != FILTER_OUT)</a>
<a name="ln3892">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln3893"> </a>
<a name="ln3894">  if (direct == FILTER_OUT &amp;&amp; peer_is_group_member (peer, afi, safi))</a>
<a name="ln3895">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln3896"> </a>
<a name="ln3897">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln3898"> </a>
<a name="ln3899">  /* apply peer-group filter */</a>
<a name="ln3900">  if (peer-&gt;af_group[afi][safi])</a>
<a name="ln3901">    {</a>
<a name="ln3902">      gfilter = &amp;peer-&gt;group-&gt;conf-&gt;filter[afi][safi];</a>
<a name="ln3903"> </a>
<a name="ln3904">      if (gfilter-&gt;dlist[direct].name)</a>
<a name="ln3905">	{</a>
<a name="ln3906">	  if (filter-&gt;dlist[direct].name)</a>
<a name="ln3907">	    free (filter-&gt;dlist[direct].name);</a>
<a name="ln3908">	  filter-&gt;dlist[direct].name = strdup (gfilter-&gt;dlist[direct].name);</a>
<a name="ln3909">	  filter-&gt;dlist[direct].alist = gfilter-&gt;dlist[direct].alist;</a>
<a name="ln3910">	  return 0;</a>
<a name="ln3911">	}</a>
<a name="ln3912">    }</a>
<a name="ln3913"> </a>
<a name="ln3914">  if (filter-&gt;dlist[direct].name)</a>
<a name="ln3915">    free (filter-&gt;dlist[direct].name);</a>
<a name="ln3916">  filter-&gt;dlist[direct].name = NULL;</a>
<a name="ln3917">  filter-&gt;dlist[direct].alist = NULL;</a>
<a name="ln3918"> </a>
<a name="ln3919">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln3920">    return 0;</a>
<a name="ln3921"> </a>
<a name="ln3922">  group = peer-&gt;group;</a>
<a name="ln3923">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln3924">    {</a>
<a name="ln3925">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln3926"> </a>
<a name="ln3927">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln3928">        continue;</a>
<a name="ln3929"> </a>
<a name="ln3930">      if (filter-&gt;dlist[direct].name)</a>
<a name="ln3931">        free (filter-&gt;dlist[direct].name);</a>
<a name="ln3932">      filter-&gt;dlist[direct].name = NULL;</a>
<a name="ln3933">      filter-&gt;dlist[direct].alist = NULL;</a>
<a name="ln3934">    }</a>
<a name="ln3935"> </a>
<a name="ln3936">  return 0;</a>
<a name="ln3937">}</a>
<a name="ln3938"> </a>
<a name="ln3939">/* Update distribute list. */</a>
<a name="ln3940">static void</a>
<a name="ln3941">peer_distribute_update (const char *name)</a>
<a name="ln3942">{</a>
<a name="ln3943">  afi_t afi;</a>
<a name="ln3944">  safi_t safi;</a>
<a name="ln3945">  int direct;</a>
<a name="ln3946">  struct listnode *mnode, *mnnode;</a>
<a name="ln3947">  struct listnode *node, *nnode;</a>
<a name="ln3948">  struct bgp *bgp;</a>
<a name="ln3949">  struct peer *peer;</a>
<a name="ln3950">  struct peer_group *group;</a>
<a name="ln3951">  struct bgp_filter *filter;</a>
<a name="ln3952"> </a>
<a name="ln3953">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, mnode, mnnode, bgp))</a>
<a name="ln3954">    {</a>
<a name="ln3955">      for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln3956">	{</a>
<a name="ln3957">	  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln3958">	    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln3959">	      {</a>
<a name="ln3960">		filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln3961"> </a>
<a name="ln3962">		for (direct = FILTER_IN; direct &lt; FILTER_MAX; direct++)</a>
<a name="ln3963">		  {</a>
<a name="ln3964">		    if (filter-&gt;dlist[direct].name)</a>
<a name="ln3965">		      filter-&gt;dlist[direct].alist = </a>
<a name="ln3966">			access_list_lookup (afi, filter-&gt;dlist[direct].name);</a>
<a name="ln3967">		    else</a>
<a name="ln3968">		      filter-&gt;dlist[direct].alist = NULL;</a>
<a name="ln3969">		  }</a>
<a name="ln3970">	      }</a>
<a name="ln3971">	}</a>
<a name="ln3972">      for (ALL_LIST_ELEMENTS (bgp-&gt;group, node, nnode, group))</a>
<a name="ln3973">	{</a>
<a name="ln3974">	  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln3975">	    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln3976">	      {</a>
<a name="ln3977">		filter = &amp;group-&gt;conf-&gt;filter[afi][safi];</a>
<a name="ln3978"> </a>
<a name="ln3979">		for (direct = FILTER_IN; direct &lt; FILTER_MAX; direct++)</a>
<a name="ln3980">		  {</a>
<a name="ln3981">		    if (filter-&gt;dlist[direct].name)</a>
<a name="ln3982">		      filter-&gt;dlist[direct].alist = </a>
<a name="ln3983">			access_list_lookup (afi, filter-&gt;dlist[direct].name);</a>
<a name="ln3984">		    else</a>
<a name="ln3985">		      filter-&gt;dlist[direct].alist = NULL;</a>
<a name="ln3986">		  }</a>
<a name="ln3987">	      }</a>
<a name="ln3988">	}</a>
<a name="ln3989">    }</a>
<a name="ln3990">}</a>
<a name="ln3991"> </a>
<a name="ln3992">/* Set prefix list to the peer. */</a>
<a name="ln3993">int</a>
<a name="ln3994">peer_prefix_list_set (struct peer *peer, afi_t afi, safi_t safi, int direct, </a>
<a name="ln3995">		      const char *name)</a>
<a name="ln3996">{</a>
<a name="ln3997">  struct bgp_filter *filter;</a>
<a name="ln3998">  struct peer_group *group;</a>
<a name="ln3999">  struct listnode *node, *nnode;</a>
<a name="ln4000"> </a>
<a name="ln4001">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4002">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4003"> </a>
<a name="ln4004">  if (direct != FILTER_IN &amp;&amp; direct != FILTER_OUT)</a>
<a name="ln4005">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln4006"> </a>
<a name="ln4007">  if (direct == FILTER_OUT &amp;&amp; peer_is_group_member (peer, afi, safi))</a>
<a name="ln4008">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln4009"> </a>
<a name="ln4010">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4011"> </a>
<a name="ln4012">  if (filter-&gt;dlist[direct].name)</a>
<a name="ln4013">    return BGP_ERR_PEER_FILTER_CONFLICT;</a>
<a name="ln4014"> </a>
<a name="ln4015">  if (filter-&gt;plist[direct].name)</a>
<a name="ln4016">    free (filter-&gt;plist[direct].name);</a>
<a name="ln4017">  filter-&gt;plist[direct].name = strdup (name);</a>
<a name="ln4018">  filter-&gt;plist[direct].plist = prefix_list_lookup (afi, name);</a>
<a name="ln4019"> </a>
<a name="ln4020">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4021">    return 0;</a>
<a name="ln4022"> </a>
<a name="ln4023">  group = peer-&gt;group;</a>
<a name="ln4024">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4025">    {</a>
<a name="ln4026">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4027"> </a>
<a name="ln4028">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4029">	continue;</a>
<a name="ln4030"> </a>
<a name="ln4031">      if (filter-&gt;plist[direct].name)</a>
<a name="ln4032">	free (filter-&gt;plist[direct].name);</a>
<a name="ln4033">      filter-&gt;plist[direct].name = strdup (name);</a>
<a name="ln4034">      filter-&gt;plist[direct].plist = prefix_list_lookup (afi, name);</a>
<a name="ln4035">    }</a>
<a name="ln4036">  return 0;</a>
<a name="ln4037">}</a>
<a name="ln4038"> </a>
<a name="ln4039">int</a>
<a name="ln4040">peer_prefix_list_unset (struct peer *peer, afi_t afi, safi_t safi, int direct)</a>
<a name="ln4041">{</a>
<a name="ln4042">  struct bgp_filter *filter;</a>
<a name="ln4043">  struct bgp_filter *gfilter;</a>
<a name="ln4044">  struct peer_group *group;</a>
<a name="ln4045">  struct listnode *node, *nnode;</a>
<a name="ln4046"> </a>
<a name="ln4047">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4048">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4049"> </a>
<a name="ln4050">  if (direct != FILTER_IN &amp;&amp; direct != FILTER_OUT)</a>
<a name="ln4051">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln4052"> </a>
<a name="ln4053">  if (direct == FILTER_OUT &amp;&amp; peer_is_group_member (peer, afi, safi))</a>
<a name="ln4054">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln4055"> </a>
<a name="ln4056">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4057"> </a>
<a name="ln4058">  /* apply peer-group filter */</a>
<a name="ln4059">  if (peer-&gt;af_group[afi][safi])</a>
<a name="ln4060">    {</a>
<a name="ln4061">      gfilter = &amp;peer-&gt;group-&gt;conf-&gt;filter[afi][safi];</a>
<a name="ln4062"> </a>
<a name="ln4063">      if (gfilter-&gt;plist[direct].name)</a>
<a name="ln4064">	{</a>
<a name="ln4065">	  if (filter-&gt;plist[direct].name)</a>
<a name="ln4066">	    free (filter-&gt;plist[direct].name);</a>
<a name="ln4067">	  filter-&gt;plist[direct].name = strdup (gfilter-&gt;plist[direct].name);</a>
<a name="ln4068">	  filter-&gt;plist[direct].plist = gfilter-&gt;plist[direct].plist;</a>
<a name="ln4069">	  return 0;</a>
<a name="ln4070">	}</a>
<a name="ln4071">    }</a>
<a name="ln4072"> </a>
<a name="ln4073">  if (filter-&gt;plist[direct].name)</a>
<a name="ln4074">    free (filter-&gt;plist[direct].name);</a>
<a name="ln4075">  filter-&gt;plist[direct].name = NULL;</a>
<a name="ln4076">  filter-&gt;plist[direct].plist = NULL;</a>
<a name="ln4077"> </a>
<a name="ln4078">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4079">    return 0;</a>
<a name="ln4080"> </a>
<a name="ln4081">  group = peer-&gt;group;</a>
<a name="ln4082">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4083">    {</a>
<a name="ln4084">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4085"> </a>
<a name="ln4086">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4087">	continue;</a>
<a name="ln4088"> </a>
<a name="ln4089">      if (filter-&gt;plist[direct].name)</a>
<a name="ln4090">	free (filter-&gt;plist[direct].name);</a>
<a name="ln4091">      filter-&gt;plist[direct].name = NULL;</a>
<a name="ln4092">      filter-&gt;plist[direct].plist = NULL;</a>
<a name="ln4093">    }</a>
<a name="ln4094"> </a>
<a name="ln4095">  return 0;</a>
<a name="ln4096">}</a>
<a name="ln4097"> </a>
<a name="ln4098">/* Update prefix-list list. */</a>
<a name="ln4099">static void</a>
<a name="ln4100">peer_prefix_list_update (struct prefix_list *plist)</a>
<a name="ln4101">{</a>
<a name="ln4102">  struct listnode *mnode, *mnnode;</a>
<a name="ln4103">  struct listnode *node, *nnode;</a>
<a name="ln4104">  struct bgp *bgp;</a>
<a name="ln4105">  struct peer *peer;</a>
<a name="ln4106">  struct peer_group *group;</a>
<a name="ln4107">  struct bgp_filter *filter;</a>
<a name="ln4108">  afi_t afi;</a>
<a name="ln4109">  safi_t safi;</a>
<a name="ln4110">  int direct;</a>
<a name="ln4111"> </a>
<a name="ln4112">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, mnode, mnnode, bgp))</a>
<a name="ln4113">    {</a>
<a name="ln4114">      for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln4115">	{</a>
<a name="ln4116">	  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln4117">	    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln4118">	      {</a>
<a name="ln4119">		filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4120"> </a>
<a name="ln4121">		for (direct = FILTER_IN; direct &lt; FILTER_MAX; direct++)</a>
<a name="ln4122">		  {</a>
<a name="ln4123">		    if (filter-&gt;plist[direct].name)</a>
<a name="ln4124">		      filter-&gt;plist[direct].plist = </a>
<a name="ln4125">			prefix_list_lookup (afi, filter-&gt;plist[direct].name);</a>
<a name="ln4126">		    else</a>
<a name="ln4127">		      filter-&gt;plist[direct].plist = NULL;</a>
<a name="ln4128">		  }</a>
<a name="ln4129">	      }</a>
<a name="ln4130">	}</a>
<a name="ln4131">      for (ALL_LIST_ELEMENTS (bgp-&gt;group, node, nnode, group))</a>
<a name="ln4132">	{</a>
<a name="ln4133">	  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln4134">	    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln4135">	      {</a>
<a name="ln4136">		filter = &amp;group-&gt;conf-&gt;filter[afi][safi];</a>
<a name="ln4137"> </a>
<a name="ln4138">		for (direct = FILTER_IN; direct &lt; FILTER_MAX; direct++)</a>
<a name="ln4139">		  {</a>
<a name="ln4140">		    if (filter-&gt;plist[direct].name)</a>
<a name="ln4141">		      filter-&gt;plist[direct].plist = </a>
<a name="ln4142">			prefix_list_lookup (afi, filter-&gt;plist[direct].name);</a>
<a name="ln4143">		    else</a>
<a name="ln4144">		      filter-&gt;plist[direct].plist = NULL;</a>
<a name="ln4145">		  }</a>
<a name="ln4146">	      }</a>
<a name="ln4147">	}</a>
<a name="ln4148">    }</a>
<a name="ln4149">}</a>
<a name="ln4150"> </a>
<a name="ln4151">int</a>
<a name="ln4152">peer_aslist_set (struct peer *peer, afi_t afi, safi_t safi, int direct,</a>
<a name="ln4153">		 const char *name)</a>
<a name="ln4154">{</a>
<a name="ln4155">  struct bgp_filter *filter;</a>
<a name="ln4156">  struct peer_group *group;</a>
<a name="ln4157">  struct listnode *node, *nnode;</a>
<a name="ln4158"> </a>
<a name="ln4159">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4160">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4161"> </a>
<a name="ln4162">  if (direct != FILTER_IN &amp;&amp; direct != FILTER_OUT)</a>
<a name="ln4163">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln4164"> </a>
<a name="ln4165">  if (direct == FILTER_OUT &amp;&amp; peer_is_group_member (peer, afi, safi))</a>
<a name="ln4166">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln4167"> </a>
<a name="ln4168">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4169"> </a>
<a name="ln4170">  if (filter-&gt;aslist[direct].name)</a>
<a name="ln4171">    free (filter-&gt;aslist[direct].name);</a>
<a name="ln4172">  filter-&gt;aslist[direct].name = strdup (name);</a>
<a name="ln4173">  filter-&gt;aslist[direct].aslist = as_list_lookup (name);</a>
<a name="ln4174"> </a>
<a name="ln4175">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4176">    return 0;</a>
<a name="ln4177"> </a>
<a name="ln4178">  group = peer-&gt;group;</a>
<a name="ln4179">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4180">    {</a>
<a name="ln4181">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4182"> </a>
<a name="ln4183">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4184">	continue;</a>
<a name="ln4185"> </a>
<a name="ln4186">      if (filter-&gt;aslist[direct].name)</a>
<a name="ln4187">	free (filter-&gt;aslist[direct].name);</a>
<a name="ln4188">      filter-&gt;aslist[direct].name = strdup (name);</a>
<a name="ln4189">      filter-&gt;aslist[direct].aslist = as_list_lookup (name);</a>
<a name="ln4190">    }</a>
<a name="ln4191">  return 0;</a>
<a name="ln4192">}</a>
<a name="ln4193"> </a>
<a name="ln4194">int</a>
<a name="ln4195">peer_aslist_unset (struct peer *peer,afi_t afi, safi_t safi, int direct)</a>
<a name="ln4196">{</a>
<a name="ln4197">  struct bgp_filter *filter;</a>
<a name="ln4198">  struct bgp_filter *gfilter;</a>
<a name="ln4199">  struct peer_group *group;</a>
<a name="ln4200">  struct listnode *node, *nnode;</a>
<a name="ln4201"> </a>
<a name="ln4202">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4203">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4204"> </a>
<a name="ln4205">  if (direct != FILTER_IN &amp;&amp; direct != FILTER_OUT)</a>
<a name="ln4206">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln4207"> </a>
<a name="ln4208">  if (direct == FILTER_OUT &amp;&amp; peer_is_group_member (peer, afi, safi))</a>
<a name="ln4209">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln4210"> </a>
<a name="ln4211">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4212"> </a>
<a name="ln4213">  /* apply peer-group filter */</a>
<a name="ln4214">  if (peer-&gt;af_group[afi][safi])</a>
<a name="ln4215">    {</a>
<a name="ln4216">      gfilter = &amp;peer-&gt;group-&gt;conf-&gt;filter[afi][safi];</a>
<a name="ln4217"> </a>
<a name="ln4218">      if (gfilter-&gt;aslist[direct].name)</a>
<a name="ln4219">	{</a>
<a name="ln4220">	  if (filter-&gt;aslist[direct].name)</a>
<a name="ln4221">	    free (filter-&gt;aslist[direct].name);</a>
<a name="ln4222">	  filter-&gt;aslist[direct].name = strdup (gfilter-&gt;aslist[direct].name);</a>
<a name="ln4223">	  filter-&gt;aslist[direct].aslist = gfilter-&gt;aslist[direct].aslist;</a>
<a name="ln4224">	  return 0;</a>
<a name="ln4225">	}</a>
<a name="ln4226">    }</a>
<a name="ln4227"> </a>
<a name="ln4228">  if (filter-&gt;aslist[direct].name)</a>
<a name="ln4229">    free (filter-&gt;aslist[direct].name);</a>
<a name="ln4230">  filter-&gt;aslist[direct].name = NULL;</a>
<a name="ln4231">  filter-&gt;aslist[direct].aslist = NULL;</a>
<a name="ln4232"> </a>
<a name="ln4233">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4234">    return 0;</a>
<a name="ln4235"> </a>
<a name="ln4236">  group = peer-&gt;group;</a>
<a name="ln4237">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4238">    {</a>
<a name="ln4239">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4240"> </a>
<a name="ln4241">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4242">	continue;</a>
<a name="ln4243"> </a>
<a name="ln4244">      if (filter-&gt;aslist[direct].name)</a>
<a name="ln4245">	free (filter-&gt;aslist[direct].name);</a>
<a name="ln4246">      filter-&gt;aslist[direct].name = NULL;</a>
<a name="ln4247">      filter-&gt;aslist[direct].aslist = NULL;</a>
<a name="ln4248">    }</a>
<a name="ln4249"> </a>
<a name="ln4250">  return 0;</a>
<a name="ln4251">}</a>
<a name="ln4252"> </a>
<a name="ln4253">static void</a>
<a name="ln4254">peer_aslist_update (void)</a>
<a name="ln4255">{</a>
<a name="ln4256">  afi_t afi;</a>
<a name="ln4257">  safi_t safi;</a>
<a name="ln4258">  int direct;</a>
<a name="ln4259">  struct listnode *mnode, *mnnode;</a>
<a name="ln4260">  struct listnode *node, *nnode;</a>
<a name="ln4261">  struct bgp *bgp;</a>
<a name="ln4262">  struct peer *peer;</a>
<a name="ln4263">  struct peer_group *group;</a>
<a name="ln4264">  struct bgp_filter *filter;</a>
<a name="ln4265"> </a>
<a name="ln4266">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, mnode, mnnode, bgp))</a>
<a name="ln4267">    {</a>
<a name="ln4268">      for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln4269">	{</a>
<a name="ln4270">	  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln4271">	    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln4272">	      {</a>
<a name="ln4273">		filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4274"> </a>
<a name="ln4275">		for (direct = FILTER_IN; direct &lt; FILTER_MAX; direct++)</a>
<a name="ln4276">		  {</a>
<a name="ln4277">		    if (filter-&gt;aslist[direct].name)</a>
<a name="ln4278">		      filter-&gt;aslist[direct].aslist = </a>
<a name="ln4279">			as_list_lookup (filter-&gt;aslist[direct].name);</a>
<a name="ln4280">		    else</a>
<a name="ln4281">		      filter-&gt;aslist[direct].aslist = NULL;</a>
<a name="ln4282">		  }</a>
<a name="ln4283">	      }</a>
<a name="ln4284">	}</a>
<a name="ln4285">      for (ALL_LIST_ELEMENTS (bgp-&gt;group, node, nnode, group))</a>
<a name="ln4286">	{</a>
<a name="ln4287">	  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln4288">	    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln4289">	      {</a>
<a name="ln4290">		filter = &amp;group-&gt;conf-&gt;filter[afi][safi];</a>
<a name="ln4291"> </a>
<a name="ln4292">		for (direct = FILTER_IN; direct &lt; FILTER_MAX; direct++)</a>
<a name="ln4293">		  {</a>
<a name="ln4294">		    if (filter-&gt;aslist[direct].name)</a>
<a name="ln4295">		      filter-&gt;aslist[direct].aslist = </a>
<a name="ln4296">			as_list_lookup (filter-&gt;aslist[direct].name);</a>
<a name="ln4297">		    else</a>
<a name="ln4298">		      filter-&gt;aslist[direct].aslist = NULL;</a>
<a name="ln4299">		  }</a>
<a name="ln4300">	      }</a>
<a name="ln4301">	}</a>
<a name="ln4302">    }</a>
<a name="ln4303">}</a>
<a name="ln4304"> </a>
<a name="ln4305">/* Set route-map to the peer. */</a>
<a name="ln4306">int</a>
<a name="ln4307">peer_route_map_set (struct peer *peer, afi_t afi, safi_t safi, int direct, </a>
<a name="ln4308">		    const char *name)</a>
<a name="ln4309">{</a>
<a name="ln4310">  struct bgp_filter *filter;</a>
<a name="ln4311">  struct peer_group *group;</a>
<a name="ln4312">  struct listnode *node, *nnode;</a>
<a name="ln4313"> </a>
<a name="ln4314">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4315">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4316"> </a>
<a name="ln4317">  if (direct != RMAP_IN &amp;&amp; direct != RMAP_OUT &amp;&amp;</a>
<a name="ln4318">      direct != RMAP_IMPORT &amp;&amp; direct != RMAP_EXPORT)</a>
<a name="ln4319">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln4320"> </a>
<a name="ln4321">  if ( (direct == RMAP_OUT || direct == RMAP_IMPORT)</a>
<a name="ln4322">      &amp;&amp; peer_is_group_member (peer, afi, safi))</a>
<a name="ln4323">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln4324"> </a>
<a name="ln4325">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4326"> </a>
<a name="ln4327">  if (filter-&gt;map[direct].name)</a>
<a name="ln4328">    free (filter-&gt;map[direct].name);</a>
<a name="ln4329">  </a>
<a name="ln4330">  filter-&gt;map[direct].name = strdup (name);</a>
<a name="ln4331">  filter-&gt;map[direct].map = route_map_lookup_by_name (name);</a>
<a name="ln4332"> </a>
<a name="ln4333">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4334">    return 0;</a>
<a name="ln4335"> </a>
<a name="ln4336">  group = peer-&gt;group;</a>
<a name="ln4337">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4338">    {</a>
<a name="ln4339">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4340"> </a>
<a name="ln4341">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4342">	continue;</a>
<a name="ln4343"> </a>
<a name="ln4344">      if (filter-&gt;map[direct].name)</a>
<a name="ln4345">	free (filter-&gt;map[direct].name);</a>
<a name="ln4346">      filter-&gt;map[direct].name = strdup (name);</a>
<a name="ln4347">      filter-&gt;map[direct].map = route_map_lookup_by_name (name);</a>
<a name="ln4348">    }</a>
<a name="ln4349">  return 0;</a>
<a name="ln4350">}</a>
<a name="ln4351"> </a>
<a name="ln4352">/* Unset route-map from the peer. */</a>
<a name="ln4353">int</a>
<a name="ln4354">peer_route_map_unset (struct peer *peer, afi_t afi, safi_t safi, int direct)</a>
<a name="ln4355">{</a>
<a name="ln4356">  struct bgp_filter *filter;</a>
<a name="ln4357">  struct bgp_filter *gfilter;</a>
<a name="ln4358">  struct peer_group *group;</a>
<a name="ln4359">  struct listnode *node, *nnode;</a>
<a name="ln4360"> </a>
<a name="ln4361">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4362">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4363"> </a>
<a name="ln4364">  if (direct != RMAP_IN &amp;&amp; direct != RMAP_OUT &amp;&amp;</a>
<a name="ln4365">      direct != RMAP_IMPORT &amp;&amp; direct != RMAP_EXPORT)</a>
<a name="ln4366">    return BGP_ERR_INVALID_VALUE;</a>
<a name="ln4367"> </a>
<a name="ln4368">  if ( (direct == RMAP_OUT || direct == RMAP_IMPORT)</a>
<a name="ln4369">      &amp;&amp; peer_is_group_member (peer, afi, safi))</a>
<a name="ln4370">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln4371"> </a>
<a name="ln4372">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4373"> </a>
<a name="ln4374">  /* apply peer-group filter */</a>
<a name="ln4375">  if (peer-&gt;af_group[afi][safi])</a>
<a name="ln4376">    {</a>
<a name="ln4377">      gfilter = &amp;peer-&gt;group-&gt;conf-&gt;filter[afi][safi];</a>
<a name="ln4378"> </a>
<a name="ln4379">      if (gfilter-&gt;map[direct].name)</a>
<a name="ln4380">	{</a>
<a name="ln4381">	  if (filter-&gt;map[direct].name)</a>
<a name="ln4382">	    free (filter-&gt;map[direct].name);</a>
<a name="ln4383">	  filter-&gt;map[direct].name = strdup (gfilter-&gt;map[direct].name);</a>
<a name="ln4384">	  filter-&gt;map[direct].map = gfilter-&gt;map[direct].map;</a>
<a name="ln4385">	  return 0;</a>
<a name="ln4386">	}</a>
<a name="ln4387">    }</a>
<a name="ln4388"> </a>
<a name="ln4389">  if (filter-&gt;map[direct].name)</a>
<a name="ln4390">    free (filter-&gt;map[direct].name);</a>
<a name="ln4391">  filter-&gt;map[direct].name = NULL;</a>
<a name="ln4392">  filter-&gt;map[direct].map = NULL;</a>
<a name="ln4393"> </a>
<a name="ln4394">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4395">    return 0;</a>
<a name="ln4396"> </a>
<a name="ln4397">  group = peer-&gt;group;</a>
<a name="ln4398">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4399">    {</a>
<a name="ln4400">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4401"> </a>
<a name="ln4402">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4403">	continue;</a>
<a name="ln4404"> </a>
<a name="ln4405">      if (filter-&gt;map[direct].name)</a>
<a name="ln4406">	free (filter-&gt;map[direct].name);</a>
<a name="ln4407">      filter-&gt;map[direct].name = NULL;</a>
<a name="ln4408">      filter-&gt;map[direct].map = NULL;</a>
<a name="ln4409">    }</a>
<a name="ln4410">  return 0;</a>
<a name="ln4411">}</a>
<a name="ln4412"> </a>
<a name="ln4413">/* Set unsuppress-map to the peer. */</a>
<a name="ln4414">int</a>
<a name="ln4415">peer_unsuppress_map_set (struct peer *peer, afi_t afi, safi_t safi, </a>
<a name="ln4416">                         const char *name)</a>
<a name="ln4417">{</a>
<a name="ln4418">  struct bgp_filter *filter;</a>
<a name="ln4419">  struct peer_group *group;</a>
<a name="ln4420">  struct listnode *node, *nnode;</a>
<a name="ln4421"> </a>
<a name="ln4422">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4423">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4424"> </a>
<a name="ln4425">  if (peer_is_group_member (peer, afi, safi))</a>
<a name="ln4426">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln4427">      </a>
<a name="ln4428">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4429"> </a>
<a name="ln4430">  if (filter-&gt;usmap.name)</a>
<a name="ln4431">    free (filter-&gt;usmap.name);</a>
<a name="ln4432">  </a>
<a name="ln4433">  filter-&gt;usmap.name = strdup (name);</a>
<a name="ln4434">  filter-&gt;usmap.map = route_map_lookup_by_name (name);</a>
<a name="ln4435"> </a>
<a name="ln4436">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4437">    return 0;</a>
<a name="ln4438"> </a>
<a name="ln4439">  group = peer-&gt;group;</a>
<a name="ln4440">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4441">    {</a>
<a name="ln4442">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4443"> </a>
<a name="ln4444">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4445">	continue;</a>
<a name="ln4446"> </a>
<a name="ln4447">      if (filter-&gt;usmap.name)</a>
<a name="ln4448">	free (filter-&gt;usmap.name);</a>
<a name="ln4449">      filter-&gt;usmap.name = strdup (name);</a>
<a name="ln4450">      filter-&gt;usmap.map = route_map_lookup_by_name (name);</a>
<a name="ln4451">    }</a>
<a name="ln4452">  return 0;</a>
<a name="ln4453">}</a>
<a name="ln4454"> </a>
<a name="ln4455">/* Unset route-map from the peer. */</a>
<a name="ln4456">int</a>
<a name="ln4457">peer_unsuppress_map_unset (struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln4458">{</a>
<a name="ln4459">  struct bgp_filter *filter;</a>
<a name="ln4460">  struct peer_group *group;</a>
<a name="ln4461">  struct listnode *node, *nnode;</a>
<a name="ln4462"> </a>
<a name="ln4463">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4464">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4465">  </a>
<a name="ln4466">  if (peer_is_group_member (peer, afi, safi))</a>
<a name="ln4467">    return BGP_ERR_INVALID_FOR_PEER_GROUP_MEMBER;</a>
<a name="ln4468"> </a>
<a name="ln4469">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4470"> </a>
<a name="ln4471">  if (filter-&gt;usmap.name)</a>
<a name="ln4472">    free (filter-&gt;usmap.name);</a>
<a name="ln4473">  filter-&gt;usmap.name = NULL;</a>
<a name="ln4474">  filter-&gt;usmap.map = NULL;</a>
<a name="ln4475"> </a>
<a name="ln4476">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4477">    return 0;</a>
<a name="ln4478"> </a>
<a name="ln4479">  group = peer-&gt;group;</a>
<a name="ln4480">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4481">    {</a>
<a name="ln4482">      filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4483"> </a>
<a name="ln4484">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4485">	continue;</a>
<a name="ln4486"> </a>
<a name="ln4487">      if (filter-&gt;usmap.name)</a>
<a name="ln4488">	free (filter-&gt;usmap.name);</a>
<a name="ln4489">      filter-&gt;usmap.name = NULL;</a>
<a name="ln4490">      filter-&gt;usmap.map = NULL;</a>
<a name="ln4491">    }</a>
<a name="ln4492">  return 0;</a>
<a name="ln4493">}</a>
<a name="ln4494"> </a>
<a name="ln4495">int</a>
<a name="ln4496">peer_maximum_prefix_set (struct peer *peer, afi_t afi, safi_t safi,</a>
<a name="ln4497">			 u_int32_t max, u_char threshold,</a>
<a name="ln4498">			 int warning, u_int16_t restart)</a>
<a name="ln4499">{</a>
<a name="ln4500">  struct peer_group *group;</a>
<a name="ln4501">  struct listnode *node, *nnode;</a>
<a name="ln4502"> </a>
<a name="ln4503">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4504">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4505"> </a>
<a name="ln4506">  SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX);</a>
<a name="ln4507">  peer-&gt;pmax[afi][safi] = max;</a>
<a name="ln4508">  peer-&gt;pmax_threshold[afi][safi] = threshold;</a>
<a name="ln4509">  peer-&gt;pmax_restart[afi][safi] = restart;</a>
<a name="ln4510">  if (warning)</a>
<a name="ln4511">    SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING);</a>
<a name="ln4512">  else</a>
<a name="ln4513">    UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING);</a>
<a name="ln4514"> </a>
<a name="ln4515">  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4516">    {</a>
<a name="ln4517">      group = peer-&gt;group;</a>
<a name="ln4518">      for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4519">	{</a>
<a name="ln4520">	  if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4521">	    continue;</a>
<a name="ln4522"> </a>
<a name="ln4523">	  SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX);</a>
<a name="ln4524">	  peer-&gt;pmax[afi][safi] = max;</a>
<a name="ln4525">	  peer-&gt;pmax_threshold[afi][safi] = threshold;</a>
<a name="ln4526">	  peer-&gt;pmax_restart[afi][safi] = restart;</a>
<a name="ln4527">	  if (warning)</a>
<a name="ln4528">	    SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING);</a>
<a name="ln4529">	  else</a>
<a name="ln4530">	    UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING);</a>
<a name="ln4531"> </a>
<a name="ln4532">	  if ((peer-&gt;status == Established) &amp;&amp; (peer-&gt;afc[afi][safi]))</a>
<a name="ln4533">	    bgp_maximum_prefix_overflow (peer, afi, safi, 1);</a>
<a name="ln4534">	}</a>
<a name="ln4535">    }</a>
<a name="ln4536">  else</a>
<a name="ln4537">    {</a>
<a name="ln4538">      if ((peer-&gt;status == Established) &amp;&amp; (peer-&gt;afc[afi][safi]))</a>
<a name="ln4539">	bgp_maximum_prefix_overflow (peer, afi, safi, 1);</a>
<a name="ln4540">    }</a>
<a name="ln4541"> </a>
<a name="ln4542">  return 0;</a>
<a name="ln4543">}</a>
<a name="ln4544"> </a>
<a name="ln4545">int</a>
<a name="ln4546">peer_maximum_prefix_unset (struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln4547">{</a>
<a name="ln4548">  struct peer_group *group;</a>
<a name="ln4549">  struct listnode *node, *nnode;</a>
<a name="ln4550"> </a>
<a name="ln4551">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4552">    return BGP_ERR_PEER_INACTIVE;</a>
<a name="ln4553"> </a>
<a name="ln4554">  /* apply peer-group config */</a>
<a name="ln4555">  if (peer-&gt;af_group[afi][safi])</a>
<a name="ln4556">    {</a>
<a name="ln4557">      if (CHECK_FLAG (peer-&gt;group-&gt;conf-&gt;af_flags[afi][safi],</a>
<a name="ln4558">	  PEER_FLAG_MAX_PREFIX))</a>
<a name="ln4559">	SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX);</a>
<a name="ln4560">      else</a>
<a name="ln4561">	UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX);</a>
<a name="ln4562"> </a>
<a name="ln4563">      if (CHECK_FLAG (peer-&gt;group-&gt;conf-&gt;af_flags[afi][safi],</a>
<a name="ln4564">	  PEER_FLAG_MAX_PREFIX_WARNING))</a>
<a name="ln4565">	SET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING);</a>
<a name="ln4566">      else</a>
<a name="ln4567">	UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING);</a>
<a name="ln4568"> </a>
<a name="ln4569">      peer-&gt;pmax[afi][safi] = peer-&gt;group-&gt;conf-&gt;pmax[afi][safi];</a>
<a name="ln4570">      peer-&gt;pmax_threshold[afi][safi] = peer-&gt;group-&gt;conf-&gt;pmax_threshold[afi][safi];</a>
<a name="ln4571">      peer-&gt;pmax_restart[afi][safi] = peer-&gt;group-&gt;conf-&gt;pmax_restart[afi][safi];</a>
<a name="ln4572">      return 0;</a>
<a name="ln4573">    }</a>
<a name="ln4574"> </a>
<a name="ln4575">  UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX);</a>
<a name="ln4576">  UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING);</a>
<a name="ln4577">  peer-&gt;pmax[afi][safi] = 0;</a>
<a name="ln4578">  peer-&gt;pmax_threshold[afi][safi] = 0;</a>
<a name="ln4579">  peer-&gt;pmax_restart[afi][safi] = 0;</a>
<a name="ln4580"> </a>
<a name="ln4581">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4582">    return 0;</a>
<a name="ln4583"> </a>
<a name="ln4584">  group = peer-&gt;group;</a>
<a name="ln4585">  for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4586">    {</a>
<a name="ln4587">      if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln4588">	continue;</a>
<a name="ln4589"> </a>
<a name="ln4590">      UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX);</a>
<a name="ln4591">      UNSET_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING);</a>
<a name="ln4592">      peer-&gt;pmax[afi][safi] = 0;</a>
<a name="ln4593">      peer-&gt;pmax_threshold[afi][safi] = 0;</a>
<a name="ln4594">      peer-&gt;pmax_restart[afi][safi] = 0;</a>
<a name="ln4595">    }</a>
<a name="ln4596">  return 0;</a>
<a name="ln4597">}</a>
<a name="ln4598"> </a>
<a name="ln4599">/* Set # of hops between us and BGP peer. */</a>
<a name="ln4600">int</a>
<a name="ln4601">peer_ttl_security_hops_set (struct peer *peer, int gtsm_hops)</a>
<a name="ln4602">{</a>
<a name="ln4603">  struct peer_group *group;</a>
<a name="ln4604">  struct listnode *node, *nnode;</a>
<a name="ln4605">  struct peer *peer1;</a>
<a name="ln4606"> </a>
<a name="ln4607">  zlog_debug (&quot;peer_ttl_security_hops_set: set gtsm_hops to %d for %s&quot;, gtsm_hops, peer-&gt;host);</a>
<a name="ln4608"> </a>
<a name="ln4609">  if (peer-&gt;ttl != 0)</a>
<a name="ln4610">    return BGP_ERR_NO_EBGP_MULTIHOP_WITH_TTLHACK;</a>
<a name="ln4611"> </a>
<a name="ln4612">  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4613">    {</a>
<a name="ln4614">      group = peer-&gt;group;</a>
<a name="ln4615">      for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer1))</a>
<a name="ln4616">        {</a>
<a name="ln4617">          if (peer1-&gt;ttl != 0)</a>
<a name="ln4618">            return BGP_ERR_NO_EBGP_MULTIHOP_WITH_TTLHACK;</a>
<a name="ln4619">        }</a>
<a name="ln4620">    }</a>
<a name="ln4621"> </a>
<a name="ln4622">  peer-&gt;gtsm_hops = gtsm_hops;</a>
<a name="ln4623"> </a>
<a name="ln4624">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4625">    {</a>
<a name="ln4626">      bgp_set_socket_ttl (peer, peer-&gt;fd);</a>
<a name="ln4627">    }</a>
<a name="ln4628">  else</a>
<a name="ln4629">    {</a>
<a name="ln4630">      group = peer-&gt;group;</a>
<a name="ln4631">      for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln4632">	{</a>
<a name="ln4633">	  peer-&gt;gtsm_hops = gtsm_hops;</a>
<a name="ln4634"> </a>
<a name="ln4635">	  /* Change setting of existing peer</a>
<a name="ln4636">	   *   established then change value (may break connectivity)</a>
<a name="ln4637">	   *   not established yet (teardown session and restart)</a>
<a name="ln4638">	   *   no session then do nothing (will get handled by next connection)</a>
<a name="ln4639">	   */</a>
<a name="ln4640">	  if (peer-&gt;status == Established)</a>
<a name="ln4641">	    {</a>
<a name="ln4642">              bgp_set_socket_ttl (peer, peer-&gt;fd);</a>
<a name="ln4643">	    }</a>
<a name="ln4644">	  else if (peer-&gt;status &lt; Established)</a>
<a name="ln4645">	    {</a>
<a name="ln4646">	      if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln4647">		zlog_debug (&quot;%s Min-ttl changed&quot;, peer-&gt;host);</a>
<a name="ln4648">	      BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln4649">	    }</a>
<a name="ln4650">	}</a>
<a name="ln4651">    }</a>
<a name="ln4652"> </a>
<a name="ln4653">  return 0;</a>
<a name="ln4654">}</a>
<a name="ln4655"> </a>
<a name="ln4656">int</a>
<a name="ln4657">peer_clear (struct peer *peer)</a>
<a name="ln4658">{</a>
<a name="ln4659">  if (! CHECK_FLAG (peer-&gt;flags, PEER_FLAG_SHUTDOWN))</a>
<a name="ln4660">    {</a>
<a name="ln4661">      if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_PREFIX_OVERFLOW))</a>
<a name="ln4662">	{</a>
<a name="ln4663">	  UNSET_FLAG (peer-&gt;sflags, PEER_STATUS_PREFIX_OVERFLOW);</a>
<a name="ln4664">	  if (peer-&gt;t_pmax_restart)</a>
<a name="ln4665">	    {</a>
<a name="ln4666">	      BGP_TIMER_OFF (peer-&gt;t_pmax_restart);</a>
<a name="ln4667">	      if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln4668">		zlog_debug (&quot;%s Maximum-prefix restart timer canceled&quot;,</a>
<a name="ln4669">			    peer-&gt;host);</a>
<a name="ln4670">	    }</a>
<a name="ln4671">	  BGP_EVENT_ADD (peer, BGP_Start);</a>
<a name="ln4672">	  return 0;</a>
<a name="ln4673">	}</a>
<a name="ln4674"> </a>
<a name="ln4675">      peer-&gt;v_start = BGP_INIT_START_TIMER;</a>
<a name="ln4676">      if (BGP_IS_VALID_STATE_FOR_NOTIF(peer-&gt;status))</a>
<a name="ln4677">	bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln4678">			 BGP_NOTIFY_CEASE_ADMIN_RESET);</a>
<a name="ln4679">      else</a>
<a name="ln4680">        BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln4681">    }</a>
<a name="ln4682">  return 0;</a>
<a name="ln4683">}</a>
<a name="ln4684"> </a>
<a name="ln4685">int</a>
<a name="ln4686">peer_clear_soft (struct peer *peer, afi_t afi, safi_t safi,</a>
<a name="ln4687">		 enum bgp_clear_type stype)</a>
<a name="ln4688">{</a>
<a name="ln4689">  if (peer-&gt;status != Established)</a>
<a name="ln4690">    return 0;</a>
<a name="ln4691"> </a>
<a name="ln4692">  if (! peer-&gt;afc[afi][safi])</a>
<a name="ln4693">    return BGP_ERR_AF_UNCONFIGURED;</a>
<a name="ln4694"> </a>
<a name="ln4695">  peer-&gt;rtt = sockopt_tcp_rtt (peer-&gt;fd);</a>
<a name="ln4696"> </a>
<a name="ln4697">  if (stype == BGP_CLEAR_SOFT_RSCLIENT)</a>
<a name="ln4698">    {</a>
<a name="ln4699">      if (! CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT))</a>
<a name="ln4700">        return 0;</a>
<a name="ln4701">      bgp_check_local_routes_rsclient (peer, afi, safi);</a>
<a name="ln4702">      bgp_soft_reconfig_rsclient (peer, afi, safi);</a>
<a name="ln4703">    }</a>
<a name="ln4704"> </a>
<a name="ln4705">  if (stype == BGP_CLEAR_SOFT_OUT || stype == BGP_CLEAR_SOFT_BOTH)</a>
<a name="ln4706">    bgp_announce_route (peer, afi, safi);</a>
<a name="ln4707"> </a>
<a name="ln4708">  if (stype == BGP_CLEAR_SOFT_IN_ORF_PREFIX)</a>
<a name="ln4709">    {</a>
<a name="ln4710">      if (CHECK_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV)</a>
<a name="ln4711">	  &amp;&amp; (CHECK_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_RCV)</a>
<a name="ln4712">	      || CHECK_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_OLD_RCV)))</a>
<a name="ln4713">	{</a>
<a name="ln4714">	  struct bgp_filter *filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4715">	  u_char prefix_type;</a>
<a name="ln4716"> </a>
<a name="ln4717">	  if (CHECK_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_RCV))</a>
<a name="ln4718">	    prefix_type = ORF_TYPE_PREFIX;</a>
<a name="ln4719">	  else</a>
<a name="ln4720">	    prefix_type = ORF_TYPE_PREFIX_OLD;</a>
<a name="ln4721"> </a>
<a name="ln4722">	  if (filter-&gt;plist[FILTER_IN].plist)</a>
<a name="ln4723">	    {</a>
<a name="ln4724">	      if (CHECK_FLAG (peer-&gt;af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND))</a>
<a name="ln4725">		bgp_route_refresh_send (peer, afi, safi,</a>
<a name="ln4726">					prefix_type, REFRESH_DEFER, 1);</a>
<a name="ln4727">	      bgp_route_refresh_send (peer, afi, safi, prefix_type,</a>
<a name="ln4728">				      REFRESH_IMMEDIATE, 0);</a>
<a name="ln4729">	    }</a>
<a name="ln4730">	  else</a>
<a name="ln4731">	    {</a>
<a name="ln4732">	      if (CHECK_FLAG (peer-&gt;af_sflags[afi][safi], PEER_STATUS_ORF_PREFIX_SEND))</a>
<a name="ln4733">		bgp_route_refresh_send (peer, afi, safi,</a>
<a name="ln4734">					prefix_type, REFRESH_IMMEDIATE, 1);</a>
<a name="ln4735">	      else</a>
<a name="ln4736">		bgp_route_refresh_send (peer, afi, safi, 0, 0, 0);</a>
<a name="ln4737">	    }</a>
<a name="ln4738">	  return 0;</a>
<a name="ln4739">	}</a>
<a name="ln4740">    }</a>
<a name="ln4741"> </a>
<a name="ln4742">  if (stype == BGP_CLEAR_SOFT_IN || stype == BGP_CLEAR_SOFT_BOTH</a>
<a name="ln4743">      || stype == BGP_CLEAR_SOFT_IN_ORF_PREFIX)</a>
<a name="ln4744">    {</a>
<a name="ln4745">      /* If neighbor has soft reconfiguration inbound flag.</a>
<a name="ln4746">	 Use Adj-RIB-In database. */</a>
<a name="ln4747">      if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))</a>
<a name="ln4748">	bgp_soft_reconfig_in (peer, afi, safi);</a>
<a name="ln4749">      else</a>
<a name="ln4750">	{</a>
<a name="ln4751">	  /* If neighbor has route refresh capability, send route refresh</a>
<a name="ln4752">	     message to the peer. */</a>
<a name="ln4753">	  if (CHECK_FLAG (peer-&gt;cap, PEER_CAP_REFRESH_OLD_RCV)</a>
<a name="ln4754">	      || CHECK_FLAG (peer-&gt;cap, PEER_CAP_REFRESH_NEW_RCV))</a>
<a name="ln4755">	    bgp_route_refresh_send (peer, afi, safi, 0, 0, 0);</a>
<a name="ln4756">	  else</a>
<a name="ln4757">	    return BGP_ERR_SOFT_RECONFIG_UNCONFIGURED;</a>
<a name="ln4758">	}</a>
<a name="ln4759">    }</a>
<a name="ln4760">  return 0;</a>
<a name="ln4761">}</a>
<a name="ln4762"> </a>
<a name="ln4763">/* Display peer uptime.*/</a>
<a name="ln4764">/* XXX: why does this function return char * when it takes buffer? */</a>
<a name="ln4765">char *</a>
<a name="ln4766">peer_uptime (time_t uptime2, char *buf, size_t len)</a>
<a name="ln4767">{</a>
<a name="ln4768">  time_t uptime1;</a>
<a name="ln4769">  struct tm *tm;</a>
<a name="ln4770"> </a>
<a name="ln4771">  /* Check buffer length. */</a>
<a name="ln4772">  if (len &lt; BGP_UPTIME_LEN)</a>
<a name="ln4773">    {</a>
<a name="ln4774">      zlog_warn (&quot;peer_uptime (): buffer shortage %lu&quot;, (u_long)len);</a>
<a name="ln4775">      /* XXX: should return status instead of buf... */</a>
<a name="ln4776">      snprintf (buf, len, &quot;&lt;error&gt; &quot;); </a>
<a name="ln4777">      return buf;</a>
<a name="ln4778">    }</a>
<a name="ln4779"> </a>
<a name="ln4780">  /* If there is no connection has been done before print `never'. */</a>
<a name="ln4781">  if (uptime2 == 0)</a>
<a name="ln4782">    {</a>
<a name="ln4783">      snprintf (buf, len, &quot;never   &quot;);</a>
<a name="ln4784">      return buf;</a>
<a name="ln4785">    }</a>
<a name="ln4786"> </a>
<a name="ln4787">  /* Get current time. */</a>
<a name="ln4788">  uptime1 = bgp_clock ();</a>
<a name="ln4789">  uptime1 -= uptime2;</a>
<a name="ln4790">  tm = gmtime (&amp;uptime1);</a>
<a name="ln4791">  </a>
<a name="ln4792">  /* Making formatted timer strings. */</a>
<a name="ln4793">#define ONE_DAY_SECOND 60*60*24</a>
<a name="ln4794">#define ONE_WEEK_SECOND ONE_DAY_SECOND*7</a>
<a name="ln4795">#define ONE_YEAR_SECOND ONE_DAY_SECOND*365</a>
<a name="ln4796"> </a>
<a name="ln4797">  if (uptime1 &lt; ONE_DAY_SECOND)</a>
<a name="ln4798">    snprintf (buf, len, &quot;%02d:%02d:%02d&quot;, </a>
<a name="ln4799">	      tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);</a>
<a name="ln4800">  else if (uptime1 &lt; ONE_WEEK_SECOND)</a>
<a name="ln4801">    snprintf (buf, len, &quot;%dd%02dh%02dm&quot;, </a>
<a name="ln4802">	      tm-&gt;tm_yday, tm-&gt;tm_hour, tm-&gt;tm_min);</a>
<a name="ln4803">  else if (uptime1 &lt; ONE_YEAR_SECOND)</a>
<a name="ln4804">    snprintf (buf, len, &quot;%02dw%dd%02dh&quot;, </a>
<a name="ln4805">	      tm-&gt;tm_yday/7, tm-&gt;tm_yday - ((tm-&gt;tm_yday/7) * 7), tm-&gt;tm_hour);</a>
<a name="ln4806">  else</a>
<a name="ln4807">    snprintf (buf, len, &quot;%02dy%02dw%dd&quot;, </a>
<a name="ln4808">	      tm-&gt;tm_year - 70, tm-&gt;tm_yday/7, </a>
<a name="ln4809">	      tm-&gt;tm_yday - ((tm-&gt;tm_yday/7) * 7));</a>
<a name="ln4810">  return buf;</a>
<a name="ln4811">}</a>
<a name="ln4812"> </a>
<a name="ln4813">static void</a>
<a name="ln4814">bgp_config_write_filter (struct vty *vty, struct peer *peer,</a>
<a name="ln4815">			 afi_t afi, safi_t safi)</a>
<a name="ln4816">{</a>
<a name="ln4817">  struct bgp_filter *filter;</a>
<a name="ln4818">  struct bgp_filter *gfilter = NULL;</a>
<a name="ln4819">  char *addr;</a>
<a name="ln4820">  int in = FILTER_IN;</a>
<a name="ln4821">  int out = FILTER_OUT;</a>
<a name="ln4822"> </a>
<a name="ln4823">  addr = peer-&gt;host;</a>
<a name="ln4824">  filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln4825">  if (peer-&gt;af_group[afi][safi])</a>
<a name="ln4826">    gfilter = &amp;peer-&gt;group-&gt;conf-&gt;filter[afi][safi];</a>
<a name="ln4827"> </a>
<a name="ln4828">  /* distribute-list. */</a>
<a name="ln4829">  if (filter-&gt;dlist[in].name)</a>
<a name="ln4830">    if (! gfilter || ! gfilter-&gt;dlist[in].name</a>
<a name="ln4831">	|| strcmp (filter-&gt;dlist[in].name, gfilter-&gt;dlist[in].name) != 0)</a>
<a name="ln4832">    vty_out (vty, &quot; neighbor %s distribute-list %s in%s&quot;, addr, </a>
<a name="ln4833">	     filter-&gt;dlist[in].name, VTY_NEWLINE);</a>
<a name="ln4834">  if (filter-&gt;dlist[out].name &amp;&amp; ! gfilter)</a>
<a name="ln4835">    vty_out (vty, &quot; neighbor %s distribute-list %s out%s&quot;, addr, </a>
<a name="ln4836">	     filter-&gt;dlist[out].name, VTY_NEWLINE);</a>
<a name="ln4837"> </a>
<a name="ln4838">  /* prefix-list. */</a>
<a name="ln4839">  if (filter-&gt;plist[in].name)</a>
<a name="ln4840">    if (! gfilter || ! gfilter-&gt;plist[in].name</a>
<a name="ln4841">	|| strcmp (filter-&gt;plist[in].name, gfilter-&gt;plist[in].name) != 0)</a>
<a name="ln4842">    vty_out (vty, &quot; neighbor %s prefix-list %s in%s&quot;, addr, </a>
<a name="ln4843">	     filter-&gt;plist[in].name, VTY_NEWLINE);</a>
<a name="ln4844">  if (filter-&gt;plist[out].name &amp;&amp; ! gfilter)</a>
<a name="ln4845">    vty_out (vty, &quot; neighbor %s prefix-list %s out%s&quot;, addr, </a>
<a name="ln4846">	     filter-&gt;plist[out].name, VTY_NEWLINE);</a>
<a name="ln4847"> </a>
<a name="ln4848">  /* route-map. */</a>
<a name="ln4849">  if (filter-&gt;map[RMAP_IN].name)</a>
<a name="ln4850">    if (! gfilter || ! gfilter-&gt;map[RMAP_IN].name</a>
<a name="ln4851">       || strcmp (filter-&gt;map[RMAP_IN].name, gfilter-&gt;map[RMAP_IN].name) != 0)</a>
<a name="ln4852">      vty_out (vty, &quot; neighbor %s route-map %s in%s&quot;, addr, </a>
<a name="ln4853">              filter-&gt;map[RMAP_IN].name, VTY_NEWLINE);</a>
<a name="ln4854">  if (filter-&gt;map[RMAP_OUT].name &amp;&amp; ! gfilter)</a>
<a name="ln4855">    vty_out (vty, &quot; neighbor %s route-map %s out%s&quot;, addr, </a>
<a name="ln4856">            filter-&gt;map[RMAP_OUT].name, VTY_NEWLINE);</a>
<a name="ln4857">  if (filter-&gt;map[RMAP_IMPORT].name &amp;&amp; ! gfilter)</a>
<a name="ln4858">    vty_out (vty, &quot; neighbor %s route-map %s import%s&quot;, addr,</a>
<a name="ln4859">        filter-&gt;map[RMAP_IMPORT].name, VTY_NEWLINE);</a>
<a name="ln4860">  if (filter-&gt;map[RMAP_EXPORT].name)</a>
<a name="ln4861">    if (! gfilter || ! gfilter-&gt;map[RMAP_EXPORT].name</a>
<a name="ln4862">    || strcmp (filter-&gt;map[RMAP_EXPORT].name,</a>
<a name="ln4863">                    gfilter-&gt;map[RMAP_EXPORT].name) != 0)</a>
<a name="ln4864">    vty_out (vty, &quot; neighbor %s route-map %s export%s&quot;, addr,</a>
<a name="ln4865">        filter-&gt;map[RMAP_EXPORT].name, VTY_NEWLINE);</a>
<a name="ln4866"> </a>
<a name="ln4867">  /* unsuppress-map */</a>
<a name="ln4868">  if (filter-&gt;usmap.name &amp;&amp; ! gfilter)</a>
<a name="ln4869">    vty_out (vty, &quot; neighbor %s unsuppress-map %s%s&quot;, addr,</a>
<a name="ln4870">	     filter-&gt;usmap.name, VTY_NEWLINE);</a>
<a name="ln4871"> </a>
<a name="ln4872">  /* filter-list. */</a>
<a name="ln4873">  if (filter-&gt;aslist[in].name)</a>
<a name="ln4874">    if (! gfilter || ! gfilter-&gt;aslist[in].name</a>
<a name="ln4875">	|| strcmp (filter-&gt;aslist[in].name, gfilter-&gt;aslist[in].name) != 0)</a>
<a name="ln4876">      vty_out (vty, &quot; neighbor %s filter-list %s in%s&quot;, addr, </a>
<a name="ln4877">	       filter-&gt;aslist[in].name, VTY_NEWLINE);</a>
<a name="ln4878">  if (filter-&gt;aslist[out].name &amp;&amp; ! gfilter)</a>
<a name="ln4879">    vty_out (vty, &quot; neighbor %s filter-list %s out%s&quot;, addr, </a>
<a name="ln4880">	     filter-&gt;aslist[out].name, VTY_NEWLINE);</a>
<a name="ln4881">}</a>
<a name="ln4882"> </a>
<a name="ln4883">/* BGP peer configuration display function. */</a>
<a name="ln4884">static void</a>
<a name="ln4885">bgp_config_write_peer (struct vty *vty, struct bgp *bgp,</a>
<a name="ln4886">		       struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln4887">{</a>
<a name="ln4888">  struct peer *g_peer = NULL;</a>
<a name="ln4889">  char buf[SU_ADDRSTRLEN];</a>
<a name="ln4890">  char *addr;</a>
<a name="ln4891"> </a>
<a name="ln4892">  addr = peer-&gt;host;</a>
<a name="ln4893">  if (peer_group_active (peer))</a>
<a name="ln4894">    g_peer = peer-&gt;group-&gt;conf;</a>
<a name="ln4895"> </a>
<a name="ln4896">  /************************************</a>
<a name="ln4897">   ****** Global to the neighbor ******</a>
<a name="ln4898">   ************************************/</a>
<a name="ln4899">  if (afi == AFI_IP &amp;&amp; safi == SAFI_UNICAST)</a>
<a name="ln4900">    {</a>
<a name="ln4901">      /* remote-as. */</a>
<a name="ln4902">      if (! peer_group_active (peer))</a>
<a name="ln4903">	{</a>
<a name="ln4904">	  if (CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln4905">	    vty_out (vty, &quot; neighbor %s peer-group%s&quot;, addr,</a>
<a name="ln4906">		     VTY_NEWLINE);</a>
<a name="ln4907">	  if (peer-&gt;as)</a>
<a name="ln4908">	    vty_out (vty, &quot; neighbor %s remote-as %u%s&quot;, addr, peer-&gt;as,</a>
<a name="ln4909">		     VTY_NEWLINE);</a>
<a name="ln4910">	}</a>
<a name="ln4911">      else</a>
<a name="ln4912">	{</a>
<a name="ln4913">	  if (! g_peer-&gt;as)</a>
<a name="ln4914">	    vty_out (vty, &quot; neighbor %s remote-as %u%s&quot;, addr, peer-&gt;as,</a>
<a name="ln4915">		     VTY_NEWLINE);</a>
<a name="ln4916">	  if (peer-&gt;af_group[AFI_IP][SAFI_UNICAST])</a>
<a name="ln4917">	    vty_out (vty, &quot; neighbor %s peer-group %s%s&quot;, addr,</a>
<a name="ln4918">		     peer-&gt;group-&gt;name, VTY_NEWLINE);</a>
<a name="ln4919">	}</a>
<a name="ln4920"> </a>
<a name="ln4921">      /* local-as. */</a>
<a name="ln4922">      if (peer-&gt;change_local_as)</a>
<a name="ln4923">	if (! peer_group_active (peer))</a>
<a name="ln4924">	  vty_out (vty, &quot; neighbor %s local-as %u%s%s%s&quot;, addr,</a>
<a name="ln4925">		   peer-&gt;change_local_as,</a>
<a name="ln4926">		   CHECK_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND) ?</a>
<a name="ln4927">		   &quot; no-prepend&quot; : &quot;&quot;,</a>
<a name="ln4928">		   CHECK_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS) ?</a>
<a name="ln4929">		   &quot; replace-as&quot; : &quot;&quot;, VTY_NEWLINE);</a>
<a name="ln4930"> </a>
<a name="ln4931">      /* Description. */</a>
<a name="ln4932">      if (peer-&gt;desc)</a>
<a name="ln4933">	vty_out (vty, &quot; neighbor %s description %s%s&quot;, addr, peer-&gt;desc,</a>
<a name="ln4934">		 VTY_NEWLINE);</a>
<a name="ln4935"> </a>
<a name="ln4936">      /* Shutdown. */</a>
<a name="ln4937">      if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_SHUTDOWN))</a>
<a name="ln4938">        if (! peer_group_active (peer) ||</a>
<a name="ln4939">	    ! CHECK_FLAG (g_peer-&gt;flags, PEER_FLAG_SHUTDOWN))</a>
<a name="ln4940">	  vty_out (vty, &quot; neighbor %s shutdown%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln4941"> </a>
<a name="ln4942">      /* Password. */</a>
<a name="ln4943">      if (peer-&gt;password)</a>
<a name="ln4944">	if (!peer_group_active (peer)</a>
<a name="ln4945">	    || ! g_peer-&gt;password</a>
<a name="ln4946">	    || strcmp (peer-&gt;password, g_peer-&gt;password) != 0)</a>
<a name="ln4947">	  vty_out (vty, &quot; neighbor %s password %s%s&quot;, addr, peer-&gt;password,</a>
<a name="ln4948">		   VTY_NEWLINE);</a>
<a name="ln4949"> </a>
<a name="ln4950">      /* BGP port. */</a>
<a name="ln4951">      if (peer-&gt;port != BGP_PORT_DEFAULT)</a>
<a name="ln4952">	vty_out (vty, &quot; neighbor %s port %d%s&quot;, addr, peer-&gt;port,</a>
<a name="ln4953">		 VTY_NEWLINE);</a>
<a name="ln4954"> </a>
<a name="ln4955">      /* Local interface name. */</a>
<a name="ln4956">      if (peer-&gt;ifname)</a>
<a name="ln4957">	vty_out (vty, &quot; neighbor %s interface %s%s&quot;, addr, peer-&gt;ifname,</a>
<a name="ln4958">		 VTY_NEWLINE);</a>
<a name="ln4959">  </a>
<a name="ln4960">      /* Passive. */</a>
<a name="ln4961">      if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_PASSIVE))</a>
<a name="ln4962">        if (! peer_group_active (peer) ||</a>
<a name="ln4963">	    ! CHECK_FLAG (g_peer-&gt;flags, PEER_FLAG_PASSIVE))</a>
<a name="ln4964">	  vty_out (vty, &quot; neighbor %s passive%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln4965"> </a>
<a name="ln4966">      /* TTL option */</a>
<a name="ln4967">      if (peer-&gt;gtsm_hops &amp;&amp; ! peer_group_active (peer))</a>
<a name="ln4968">        vty_out (vty, &quot; neighbor %s ttl-security hops %d%s&quot;, addr,</a>
<a name="ln4969">                 peer-&gt;gtsm_hops, VTY_NEWLINE);</a>
<a name="ln4970">      else if (peer-&gt;ttl &amp;&amp; ! peer_group_active (peer))</a>
<a name="ln4971">        vty_out (vty, &quot; neighbor %s ebgp-multihop %d%s&quot;, addr, peer-&gt;ttl,</a>
<a name="ln4972">                 VTY_NEWLINE);</a>
<a name="ln4973"> </a>
<a name="ln4974">      /* disable-connected-check.  */</a>
<a name="ln4975">      if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_DISABLE_CONNECTED_CHECK))</a>
<a name="ln4976">	if (! peer_group_active (peer) ||</a>
<a name="ln4977">	    ! CHECK_FLAG (g_peer-&gt;flags, PEER_FLAG_DISABLE_CONNECTED_CHECK))</a>
<a name="ln4978">	  vty_out (vty, &quot; neighbor %s disable-connected-check%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln4979"> </a>
<a name="ln4980">      /* Update-source. */</a>
<a name="ln4981">      if (peer-&gt;update_if)</a>
<a name="ln4982">	if (! peer_group_active (peer) || ! g_peer-&gt;update_if</a>
<a name="ln4983">	    || strcmp (g_peer-&gt;update_if, peer-&gt;update_if) != 0)</a>
<a name="ln4984">	  vty_out (vty, &quot; neighbor %s update-source %s%s&quot;, addr,</a>
<a name="ln4985">		   peer-&gt;update_if, VTY_NEWLINE);</a>
<a name="ln4986">      if (peer-&gt;update_source)</a>
<a name="ln4987">	if (! peer_group_active (peer) || ! g_peer-&gt;update_source</a>
<a name="ln4988">	    || sockunion_cmp (g_peer-&gt;update_source,</a>
<a name="ln4989">			      peer-&gt;update_source) != 0)</a>
<a name="ln4990">	  vty_out (vty, &quot; neighbor %s update-source %s%s&quot;, addr,</a>
<a name="ln4991">		   sockunion2str (peer-&gt;update_source, buf, SU_ADDRSTRLEN),</a>
<a name="ln4992">		   VTY_NEWLINE);</a>
<a name="ln4993"> </a>
<a name="ln4994">      /* advertisement-interval */</a>
<a name="ln4995">      if (CHECK_FLAG (peer-&gt;config, PEER_CONFIG_ROUTEADV) &amp;&amp;</a>
<a name="ln4996">          ! peer_group_active (peer))</a>
<a name="ln4997">	vty_out (vty, &quot; neighbor %s advertisement-interval %d%s&quot;,</a>
<a name="ln4998">		 addr, peer-&gt;v_routeadv, VTY_NEWLINE); </a>
<a name="ln4999"> </a>
<a name="ln5000">      /* timers. */</a>
<a name="ln5001">      if (CHECK_FLAG (peer-&gt;config, PEER_CONFIG_TIMER)</a>
<a name="ln5002">	  &amp;&amp; ! peer_group_active (peer))</a>
<a name="ln5003">	  vty_out (vty, &quot; neighbor %s timers %d %d%s&quot;, addr, </a>
<a name="ln5004">	  peer-&gt;keepalive, peer-&gt;holdtime, VTY_NEWLINE);</a>
<a name="ln5005"> </a>
<a name="ln5006">      if (CHECK_FLAG (peer-&gt;config, PEER_CONFIG_CONNECT) &amp;&amp;</a>
<a name="ln5007">          ! peer_group_active (peer))</a>
<a name="ln5008">	  vty_out (vty, &quot; neighbor %s timers connect %d%s&quot;, addr, </a>
<a name="ln5009">	  peer-&gt;connect, VTY_NEWLINE);</a>
<a name="ln5010"> </a>
<a name="ln5011">      /* Default weight. */</a>
<a name="ln5012">      if (CHECK_FLAG (peer-&gt;config, PEER_CONFIG_WEIGHT))</a>
<a name="ln5013">        if (! peer_group_active (peer) ||</a>
<a name="ln5014">	    g_peer-&gt;weight != peer-&gt;weight)</a>
<a name="ln5015">	  vty_out (vty, &quot; neighbor %s weight %d%s&quot;, addr, peer-&gt;weight,</a>
<a name="ln5016">		   VTY_NEWLINE);</a>
<a name="ln5017"> </a>
<a name="ln5018">      /* Dynamic capability.  */</a>
<a name="ln5019">      if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_DYNAMIC_CAPABILITY))</a>
<a name="ln5020">        if (! peer_group_active (peer) ||</a>
<a name="ln5021">	    ! CHECK_FLAG (g_peer-&gt;flags, PEER_FLAG_DYNAMIC_CAPABILITY))</a>
<a name="ln5022">	vty_out (vty, &quot; neighbor %s capability dynamic%s&quot;, addr,</a>
<a name="ln5023">	     VTY_NEWLINE);</a>
<a name="ln5024"> </a>
<a name="ln5025">      /* dont capability negotiation. */</a>
<a name="ln5026">      if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_DONT_CAPABILITY))</a>
<a name="ln5027">        if (! peer_group_active (peer) ||</a>
<a name="ln5028">	    ! CHECK_FLAG (g_peer-&gt;flags, PEER_FLAG_DONT_CAPABILITY))</a>
<a name="ln5029">	vty_out (vty, &quot; neighbor %s dont-capability-negotiate%s&quot;, addr,</a>
<a name="ln5030">		 VTY_NEWLINE);</a>
<a name="ln5031"> </a>
<a name="ln5032">      /* override capability negotiation. */</a>
<a name="ln5033">      if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_OVERRIDE_CAPABILITY))</a>
<a name="ln5034">        if (! peer_group_active (peer) ||</a>
<a name="ln5035">	    ! CHECK_FLAG (g_peer-&gt;flags, PEER_FLAG_OVERRIDE_CAPABILITY))</a>
<a name="ln5036">	vty_out (vty, &quot; neighbor %s override-capability%s&quot;, addr,</a>
<a name="ln5037">		 VTY_NEWLINE);</a>
<a name="ln5038"> </a>
<a name="ln5039">      /* strict capability negotiation. */</a>
<a name="ln5040">      if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_STRICT_CAP_MATCH))</a>
<a name="ln5041">        if (! peer_group_active (peer) ||</a>
<a name="ln5042">	    ! CHECK_FLAG (g_peer-&gt;flags, PEER_FLAG_STRICT_CAP_MATCH))</a>
<a name="ln5043">	vty_out (vty, &quot; neighbor %s strict-capability-match%s&quot;, addr,</a>
<a name="ln5044">	     VTY_NEWLINE);</a>
<a name="ln5045"> </a>
<a name="ln5046">      if (! peer-&gt;af_group[AFI_IP][SAFI_UNICAST])</a>
<a name="ln5047">	{</a>
<a name="ln5048">	  if (bgp_flag_check (bgp, BGP_FLAG_NO_DEFAULT_IPV4))</a>
<a name="ln5049">	    {</a>
<a name="ln5050">	      if (peer-&gt;afc[AFI_IP][SAFI_UNICAST])</a>
<a name="ln5051">		vty_out (vty, &quot; neighbor %s activate%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln5052">	    }</a>
<a name="ln5053">          else</a>
<a name="ln5054">	    {</a>
<a name="ln5055">	      if (! peer-&gt;afc[AFI_IP][SAFI_UNICAST])</a>
<a name="ln5056">		vty_out (vty, &quot; no neighbor %s activate%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln5057">	    }</a>
<a name="ln5058">	}</a>
<a name="ln5059">    }</a>
<a name="ln5060"> </a>
<a name="ln5061"> </a>
<a name="ln5062">  /************************************</a>
<a name="ln5063">   ****** Per AF to the neighbor ******</a>
<a name="ln5064">   ************************************/</a>
<a name="ln5065"> </a>
<a name="ln5066">  if (! (afi == AFI_IP &amp;&amp; safi == SAFI_UNICAST))</a>
<a name="ln5067">    {</a>
<a name="ln5068">      if (peer-&gt;af_group[afi][safi])</a>
<a name="ln5069">	vty_out (vty, &quot; neighbor %s peer-group %s%s&quot;, addr,</a>
<a name="ln5070">		 peer-&gt;group-&gt;name, VTY_NEWLINE);</a>
<a name="ln5071">      else</a>
<a name="ln5072">	vty_out (vty, &quot; neighbor %s activate%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln5073">    }</a>
<a name="ln5074"> </a>
<a name="ln5075">  /* ORF capability.  */</a>
<a name="ln5076">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)</a>
<a name="ln5077">      || CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))</a>
<a name="ln5078">    if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln5079">    {</a>
<a name="ln5080">      vty_out (vty, &quot; neighbor %s capability orf prefix-list&quot;, addr);</a>
<a name="ln5081"> </a>
<a name="ln5082">      if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)</a>
<a name="ln5083">	  &amp;&amp; CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))</a>
<a name="ln5084">	vty_out (vty, &quot; both&quot;);</a>
<a name="ln5085">      else if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM))</a>
<a name="ln5086">	vty_out (vty, &quot; send&quot;);</a>
<a name="ln5087">      else</a>
<a name="ln5088">	vty_out (vty, &quot; receive&quot;);</a>
<a name="ln5089">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln5090">    }</a>
<a name="ln5091"> </a>
<a name="ln5092">  /* Route reflector client. */</a>
<a name="ln5093">  if (peer_af_flag_check (peer, afi, safi, PEER_FLAG_REFLECTOR_CLIENT)</a>
<a name="ln5094">      &amp;&amp; ! peer-&gt;af_group[afi][safi])</a>
<a name="ln5095">    vty_out (vty, &quot; neighbor %s route-reflector-client%s&quot;, addr, </a>
<a name="ln5096">	     VTY_NEWLINE);</a>
<a name="ln5097"> </a>
<a name="ln5098">  /* Nexthop self. */</a>
<a name="ln5099">  if (peer_af_flag_check (peer, afi, safi, PEER_FLAG_NEXTHOP_SELF)</a>
<a name="ln5100">      &amp;&amp; ! peer-&gt;af_group[afi][safi])</a>
<a name="ln5101">    vty_out (vty, &quot; neighbor %s next-hop-self%s%s&quot;, addr,</a>
<a name="ln5102">	     peer_af_flag_check (peer, afi, safi, PEER_FLAG_NEXTHOP_SELF_ALL) ?</a>
<a name="ln5103">	     &quot; all&quot; : &quot;&quot;, VTY_NEWLINE);</a>
<a name="ln5104"> </a>
<a name="ln5105">  /* Remove private AS. */</a>
<a name="ln5106">  if (peer_af_flag_check (peer, afi, safi, PEER_FLAG_REMOVE_PRIVATE_AS)</a>
<a name="ln5107">      &amp;&amp; ! peer-&gt;af_group[afi][safi])</a>
<a name="ln5108">    vty_out (vty, &quot; neighbor %s remove-private-AS%s&quot;,</a>
<a name="ln5109">	     addr, VTY_NEWLINE);</a>
<a name="ln5110"> </a>
<a name="ln5111">  /* send-community print. */</a>
<a name="ln5112">  if (! peer-&gt;af_group[afi][safi])</a>
<a name="ln5113">    {</a>
<a name="ln5114">      if (bgp_option_check (BGP_OPT_CONFIG_CISCO))</a>
<a name="ln5115">	{</a>
<a name="ln5116">	  if (peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_COMMUNITY)</a>
<a name="ln5117">	      &amp;&amp; peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_EXT_COMMUNITY)</a>
<a name="ln5118">	      &amp;&amp; peer_af_flag_check(peer, afi, safi, PEER_FLAG_SEND_LARGE_COMMUNITY))</a>
<a name="ln5119">	    vty_out (vty, &quot; neighbor %s send-community all%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln5120">	  else if (peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_EXT_COMMUNITY))	</a>
<a name="ln5121">	    vty_out (vty, &quot; neighbor %s send-community extended%s&quot;,</a>
<a name="ln5122">		     addr, VTY_NEWLINE);</a>
<a name="ln5123">	  else if (peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_LARGE_COMMUNITY))</a>
<a name="ln5124">	    vty_out (vty, &quot; neighbor %s send-community large%s&quot;,</a>
<a name="ln5125">		     addr, VTY_NEWLINE);</a>
<a name="ln5126">	  else if (peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_COMMUNITY))</a>
<a name="ln5127">	    vty_out (vty, &quot; neighbor %s send-community%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln5128">	}</a>
<a name="ln5129">      else</a>
<a name="ln5130">	{</a>
<a name="ln5131">	  if (! peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_COMMUNITY)</a>
<a name="ln5132">	      &amp;&amp; ! peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_EXT_COMMUNITY)</a>
<a name="ln5133">	      &amp;&amp; ! peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_LARGE_COMMUNITY))</a>
<a name="ln5134">	    vty_out (vty, &quot; no neighbor %s send-community all%s&quot;,</a>
<a name="ln5135">		     addr, VTY_NEWLINE);</a>
<a name="ln5136">	  else if (! peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_EXT_COMMUNITY))</a>
<a name="ln5137">	    vty_out (vty, &quot; no neighbor %s send-community extended%s&quot;,</a>
<a name="ln5138">		     addr, VTY_NEWLINE);</a>
<a name="ln5139">	  else if (! peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_LARGE_COMMUNITY))</a>
<a name="ln5140">	    vty_out (vty, &quot; no neighbor %s send-community large%s&quot;,</a>
<a name="ln5141">		     addr, VTY_NEWLINE);</a>
<a name="ln5142">	  else if (! peer_af_flag_check (peer, afi, safi, PEER_FLAG_SEND_COMMUNITY))</a>
<a name="ln5143">	    vty_out (vty, &quot; no neighbor %s send-community%s&quot;,</a>
<a name="ln5144">		     addr, VTY_NEWLINE);</a>
<a name="ln5145">	}</a>
<a name="ln5146">    }</a>
<a name="ln5147"> </a>
<a name="ln5148">  /* Default information */</a>
<a name="ln5149">  if (peer_af_flag_check (peer, afi, safi, PEER_FLAG_DEFAULT_ORIGINATE)</a>
<a name="ln5150">      &amp;&amp; ! peer-&gt;af_group[afi][safi])</a>
<a name="ln5151">    {</a>
<a name="ln5152">      vty_out (vty, &quot; neighbor %s default-originate&quot;, addr);</a>
<a name="ln5153">      if (peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln5154">	vty_out (vty, &quot; route-map %s&quot;, peer-&gt;default_rmap[afi][safi].name);</a>
<a name="ln5155">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln5156">    }</a>
<a name="ln5157"> </a>
<a name="ln5158">  /* Soft reconfiguration inbound. */</a>
<a name="ln5159">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))</a>
<a name="ln5160">    if (! peer-&gt;af_group[afi][safi] ||</a>
<a name="ln5161">	! CHECK_FLAG (g_peer-&gt;af_flags[afi][safi], PEER_FLAG_SOFT_RECONFIG))</a>
<a name="ln5162">    vty_out (vty, &quot; neighbor %s soft-reconfiguration inbound%s&quot;, addr,</a>
<a name="ln5163">	     VTY_NEWLINE);</a>
<a name="ln5164"> </a>
<a name="ln5165">  /* maximum-prefix. */</a>
<a name="ln5166">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX))</a>
<a name="ln5167">    if (! peer-&gt;af_group[afi][safi]</a>
<a name="ln5168">	|| g_peer-&gt;pmax[afi][safi] != peer-&gt;pmax[afi][safi]</a>
<a name="ln5169">        || g_peer-&gt;pmax_threshold[afi][safi] != peer-&gt;pmax_threshold[afi][safi]</a>
<a name="ln5170">	|| CHECK_FLAG (g_peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING)</a>
<a name="ln5171">	   != CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING))</a>
<a name="ln5172">      {</a>
<a name="ln5173">	vty_out (vty, &quot; neighbor %s maximum-prefix %ld&quot;, addr, peer-&gt;pmax[afi][safi]);</a>
<a name="ln5174">	if (peer-&gt;pmax_threshold[afi][safi] != MAXIMUM_PREFIX_THRESHOLD_DEFAULT)</a>
<a name="ln5175">	  vty_out (vty, &quot; %d&quot;, peer-&gt;pmax_threshold[afi][safi]);</a>
<a name="ln5176">	if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MAX_PREFIX_WARNING))</a>
<a name="ln5177">	  vty_out (vty, &quot; warning-only&quot;);</a>
<a name="ln5178">	if (peer-&gt;pmax_restart[afi][safi])</a>
<a name="ln5179">	  vty_out (vty, &quot; restart %d&quot;, peer-&gt;pmax_restart[afi][safi]);</a>
<a name="ln5180">	vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln5181">      }</a>
<a name="ln5182"> </a>
<a name="ln5183">  /* Route server client. */</a>
<a name="ln5184">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)</a>
<a name="ln5185">      &amp;&amp; ! peer-&gt;af_group[afi][safi])</a>
<a name="ln5186">    vty_out (vty, &quot; neighbor %s route-server-client%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln5187"> </a>
<a name="ln5188">  /* Nexthop-local unchanged. */</a>
<a name="ln5189">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_NEXTHOP_LOCAL_UNCHANGED)</a>
<a name="ln5190">      &amp;&amp; ! peer-&gt;af_group[afi][safi])</a>
<a name="ln5191">    vty_out (vty, &quot; neighbor %s nexthop-local unchanged%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln5192"> </a>
<a name="ln5193">  /* Allow AS in.  */</a>
<a name="ln5194">  if (peer_af_flag_check (peer, afi, safi, PEER_FLAG_ALLOWAS_IN))</a>
<a name="ln5195">    if (! peer_group_active (peer)</a>
<a name="ln5196">	|| ! peer_af_flag_check (g_peer, afi, safi, PEER_FLAG_ALLOWAS_IN)</a>
<a name="ln5197">	|| peer-&gt;allowas_in[afi][safi] != g_peer-&gt;allowas_in[afi][safi])</a>
<a name="ln5198">      {</a>
<a name="ln5199">	if (peer-&gt;allowas_in[afi][safi] == 3)</a>
<a name="ln5200">	  vty_out (vty, &quot; neighbor %s allowas-in%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln5201">	else</a>
<a name="ln5202">	  vty_out (vty, &quot; neighbor %s allowas-in %d%s&quot;, addr,</a>
<a name="ln5203">		   peer-&gt;allowas_in[afi][safi], VTY_NEWLINE);</a>
<a name="ln5204">      }</a>
<a name="ln5205"> </a>
<a name="ln5206">  /* Filter. */</a>
<a name="ln5207">  bgp_config_write_filter (vty, peer, afi, safi);</a>
<a name="ln5208"> </a>
<a name="ln5209">  /* atribute-unchanged. */</a>
<a name="ln5210">  if ((CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED)</a>
<a name="ln5211">      || CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_NEXTHOP_UNCHANGED)</a>
<a name="ln5212">      || CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MED_UNCHANGED))</a>
<a name="ln5213">      &amp;&amp; ! peer-&gt;af_group[afi][safi])</a>
<a name="ln5214">    {</a>
<a name="ln5215">      if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED)</a>
<a name="ln5216">          &amp;&amp; CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_NEXTHOP_UNCHANGED)</a>
<a name="ln5217">          &amp;&amp; CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MED_UNCHANGED))</a>
<a name="ln5218">	vty_out (vty, &quot; neighbor %s attribute-unchanged%s&quot;, addr, VTY_NEWLINE);</a>
<a name="ln5219">      else</a>
<a name="ln5220">	vty_out (vty, &quot; neighbor %s attribute-unchanged%s%s%s%s&quot;, addr, </a>
<a name="ln5221">	     (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED)) ?</a>
<a name="ln5222">	     &quot; as-path&quot; : &quot;&quot;,</a>
<a name="ln5223">	     (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_NEXTHOP_UNCHANGED)) ?</a>
<a name="ln5224">	     &quot; next-hop&quot; : &quot;&quot;,</a>
<a name="ln5225">	     (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_MED_UNCHANGED)) ?</a>
<a name="ln5226">	     &quot; med&quot; : &quot;&quot;, VTY_NEWLINE);</a>
<a name="ln5227">    }</a>
<a name="ln5228">}</a>
<a name="ln5229"> </a>
<a name="ln5230">/* Display &quot;address-family&quot; configuration header. */</a>
<a name="ln5231">void</a>
<a name="ln5232">bgp_config_write_family_header (struct vty *vty, afi_t afi, safi_t safi,</a>
<a name="ln5233">				int *write)</a>
<a name="ln5234">{</a>
<a name="ln5235">  if (*write)</a>
<a name="ln5236">    return;</a>
<a name="ln5237"> </a>
<a name="ln5238">  if (afi == AFI_IP &amp;&amp; safi == SAFI_UNICAST)</a>
<a name="ln5239">    return;</a>
<a name="ln5240"> </a>
<a name="ln5241">  vty_out (vty, &quot;!%s address-family &quot;, VTY_NEWLINE);</a>
<a name="ln5242"> </a>
<a name="ln5243">  if (afi == AFI_IP)</a>
<a name="ln5244">    {</a>
<a name="ln5245">      if (safi == SAFI_MULTICAST)</a>
<a name="ln5246">	vty_out (vty, &quot;ipv4 multicast&quot;);</a>
<a name="ln5247">      else if (safi == SAFI_MPLS_VPN)</a>
<a name="ln5248">	vty_out (vty, &quot;vpnv4&quot;);</a>
<a name="ln5249">      else if (safi == SAFI_ENCAP)</a>
<a name="ln5250">	vty_out (vty, &quot;encap&quot;);</a>
<a name="ln5251">    }</a>
<a name="ln5252">  else if (afi == AFI_IP6)</a>
<a name="ln5253">    {</a>
<a name="ln5254">      if (safi == SAFI_MPLS_VPN)</a>
<a name="ln5255">        vty_out (vty, &quot;vpnv6&quot;);</a>
<a name="ln5256">      else if (safi == SAFI_ENCAP)</a>
<a name="ln5257">        vty_out (vty, &quot;encapv6&quot;);</a>
<a name="ln5258">      else</a>
<a name="ln5259">        {</a>
<a name="ln5260">          vty_out (vty, &quot;ipv6&quot;);</a>
<a name="ln5261">          if (safi == SAFI_MULTICAST)</a>
<a name="ln5262">            vty_out (vty, &quot; multicast&quot;);</a>
<a name="ln5263">        }</a>
<a name="ln5264">    }</a>
<a name="ln5265"> </a>
<a name="ln5266">  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln5267"> </a>
<a name="ln5268">  *write = 1;</a>
<a name="ln5269">}</a>
<a name="ln5270"> </a>
<a name="ln5271">/* Address family based peer configuration display.  */</a>
<a name="ln5272">static int</a>
<a name="ln5273">bgp_config_write_family (struct vty *vty, struct bgp *bgp, afi_t afi,</a>
<a name="ln5274">			 safi_t safi)</a>
<a name="ln5275">{</a>
<a name="ln5276">  int write = 0;</a>
<a name="ln5277">  struct peer *peer;</a>
<a name="ln5278">  struct peer_group *group;</a>
<a name="ln5279">  struct listnode *node, *nnode;</a>
<a name="ln5280"> </a>
<a name="ln5281">  bgp_config_write_network (vty, bgp, afi, safi, &amp;write);</a>
<a name="ln5282"> </a>
<a name="ln5283">  bgp_config_write_redistribute (vty, bgp, afi, safi, &amp;write);</a>
<a name="ln5284"> </a>
<a name="ln5285">  for (ALL_LIST_ELEMENTS (bgp-&gt;group, node, nnode, group))</a>
<a name="ln5286">    {</a>
<a name="ln5287">      if (group-&gt;conf-&gt;afc[afi][safi])</a>
<a name="ln5288">	{</a>
<a name="ln5289">	  bgp_config_write_family_header (vty, afi, safi, &amp;write);</a>
<a name="ln5290">	  bgp_config_write_peer (vty, bgp, group-&gt;conf, afi, safi);</a>
<a name="ln5291">	}</a>
<a name="ln5292">    }</a>
<a name="ln5293">  for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln5294">    {</a>
<a name="ln5295">      if (peer-&gt;afc[afi][safi])</a>
<a name="ln5296">	{</a>
<a name="ln5297">	  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_ACCEPT_PEER))</a>
<a name="ln5298">	    {</a>
<a name="ln5299">	      bgp_config_write_family_header (vty, afi, safi, &amp;write);</a>
<a name="ln5300">	      bgp_config_write_peer (vty, bgp, peer, afi, safi);</a>
<a name="ln5301">	    }</a>
<a name="ln5302">	}</a>
<a name="ln5303">    }</a>
<a name="ln5304"> </a>
<a name="ln5305">  bgp_config_write_maxpaths (vty, bgp, afi, safi, &amp;write);</a>
<a name="ln5306"> </a>
<a name="ln5307">  bgp_config_write_distance (vty, bgp, afi, safi, &amp;write);</a>
<a name="ln5308"> </a>
<a name="ln5309">  if (write)</a>
<a name="ln5310">    vty_out (vty, &quot; exit-address-family%s&quot;, VTY_NEWLINE);</a>
<a name="ln5311"> </a>
<a name="ln5312">  return write;</a>
<a name="ln5313">}</a>
<a name="ln5314"> </a>
<a name="ln5315">int</a>
<a name="ln5316">bgp_config_write (struct vty *vty)</a>
<a name="ln5317">{</a>
<a name="ln5318">  int write = 0;</a>
<a name="ln5319">  struct bgp *bgp;</a>
<a name="ln5320">  struct peer_group *group;</a>
<a name="ln5321">  struct peer *peer;</a>
<a name="ln5322">  struct listnode *node, *nnode;</a>
<a name="ln5323">  struct listnode *mnode, *mnnode;</a>
<a name="ln5324"> </a>
<a name="ln5325">  /* BGP Multiple instance. */</a>
<a name="ln5326">  if (bgp_option_check (BGP_OPT_MULTIPLE_INSTANCE))</a>
<a name="ln5327">    {    </a>
<a name="ln5328">      vty_out (vty, &quot;bgp multiple-instance%s&quot;, VTY_NEWLINE);</a>
<a name="ln5329">      write++;</a>
<a name="ln5330">    }</a>
<a name="ln5331"> </a>
<a name="ln5332">  /* BGP Config type. */</a>
<a name="ln5333">  if (bgp_option_check (BGP_OPT_CONFIG_CISCO))</a>
<a name="ln5334">    {    </a>
<a name="ln5335">      vty_out (vty, &quot;bgp config-type cisco%s&quot;, VTY_NEWLINE);</a>
<a name="ln5336">      write++;</a>
<a name="ln5337">    }</a>
<a name="ln5338"> </a>
<a name="ln5339">  /* BGP configuration. */</a>
<a name="ln5340">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, mnode, mnnode, bgp))</a>
<a name="ln5341">    {</a>
<a name="ln5342">      if (write)</a>
<a name="ln5343">	vty_out (vty, &quot;!%s&quot;, VTY_NEWLINE);</a>
<a name="ln5344"> </a>
<a name="ln5345">      /* Router bgp ASN */</a>
<a name="ln5346">      vty_out (vty, &quot;router bgp %u&quot;, bgp-&gt;as);</a>
<a name="ln5347"> </a>
<a name="ln5348">      if (bgp_option_check (BGP_OPT_MULTIPLE_INSTANCE))</a>
<a name="ln5349">	{</a>
<a name="ln5350">	  if (bgp-&gt;name)</a>
<a name="ln5351">	    vty_out (vty, &quot; view %s&quot;, bgp-&gt;name);</a>
<a name="ln5352">	}</a>
<a name="ln5353">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln5354"> </a>
<a name="ln5355">      /* No Synchronization */</a>
<a name="ln5356">      if (bgp_option_check (BGP_OPT_CONFIG_CISCO))</a>
<a name="ln5357">	vty_out (vty, &quot; no synchronization%s&quot;, VTY_NEWLINE);</a>
<a name="ln5358"> </a>
<a name="ln5359">      /* BGP fast-external-failover. */</a>
<a name="ln5360">      if (CHECK_FLAG (bgp-&gt;flags, BGP_FLAG_NO_FAST_EXT_FAILOVER))</a>
<a name="ln5361">	vty_out (vty, &quot; no bgp fast-external-failover%s&quot;, VTY_NEWLINE); </a>
<a name="ln5362"> </a>
<a name="ln5363">      /* BGP router ID. */</a>
<a name="ln5364">      if (CHECK_FLAG (bgp-&gt;config, BGP_CONFIG_ROUTER_ID))</a>
<a name="ln5365">	vty_out (vty, &quot; bgp router-id %s%s&quot;, inet_ntoa (bgp-&gt;router_id), </a>
<a name="ln5366">		 VTY_NEWLINE);</a>
<a name="ln5367"> </a>
<a name="ln5368">      /* BGP log-neighbor-changes. */</a>
<a name="ln5369">      if (!bgp_flag_check (bgp, BGP_FLAG_LOG_NEIGHBOR_CHANGES))</a>
<a name="ln5370">	vty_out (vty, &quot; no bgp log-neighbor-changes%s&quot;, VTY_NEWLINE);</a>
<a name="ln5371"> </a>
<a name="ln5372">      /* BGP configuration. */</a>
<a name="ln5373">      if (bgp_flag_check (bgp, BGP_FLAG_ALWAYS_COMPARE_MED))</a>
<a name="ln5374">	vty_out (vty, &quot; bgp always-compare-med%s&quot;, VTY_NEWLINE);</a>
<a name="ln5375"> </a>
<a name="ln5376">      /* BGP default ipv4-unicast. */</a>
<a name="ln5377">      if (bgp_flag_check (bgp, BGP_FLAG_NO_DEFAULT_IPV4))</a>
<a name="ln5378">	vty_out (vty, &quot; no bgp default ipv4-unicast%s&quot;, VTY_NEWLINE);</a>
<a name="ln5379"> </a>
<a name="ln5380">      /* BGP default local-preference. */</a>
<a name="ln5381">      if (bgp-&gt;default_local_pref != BGP_DEFAULT_LOCAL_PREF)</a>
<a name="ln5382">	vty_out (vty, &quot; bgp default local-preference %d%s&quot;,</a>
<a name="ln5383">		 bgp-&gt;default_local_pref, VTY_NEWLINE);</a>
<a name="ln5384"> </a>
<a name="ln5385">      /* BGP client-to-client reflection. */</a>
<a name="ln5386">      if (bgp_flag_check (bgp, BGP_FLAG_NO_CLIENT_TO_CLIENT))</a>
<a name="ln5387">	vty_out (vty, &quot; no bgp client-to-client reflection%s&quot;, VTY_NEWLINE);</a>
<a name="ln5388">      </a>
<a name="ln5389">      /* BGP cluster ID. */</a>
<a name="ln5390">      if (CHECK_FLAG (bgp-&gt;config, BGP_CONFIG_CLUSTER_ID))</a>
<a name="ln5391">	vty_out (vty, &quot; bgp cluster-id %s%s&quot;, inet_ntoa (bgp-&gt;cluster_id),</a>
<a name="ln5392">		 VTY_NEWLINE);</a>
<a name="ln5393"> </a>
<a name="ln5394">      /* Confederation identifier*/</a>
<a name="ln5395">      if (CHECK_FLAG (bgp-&gt;config, BGP_CONFIG_CONFEDERATION))</a>
<a name="ln5396">       vty_out (vty, &quot; bgp confederation identifier %i%s&quot;, bgp-&gt;confed_id,</a>
<a name="ln5397">                VTY_NEWLINE);</a>
<a name="ln5398"> </a>
<a name="ln5399">      /* Confederation peer */</a>
<a name="ln5400">      if (bgp-&gt;confed_peers_cnt &gt; 0)</a>
<a name="ln5401">	{</a>
<a name="ln5402">	  int i;</a>
<a name="ln5403"> </a>
<a name="ln5404">	  vty_out (vty, &quot; bgp confederation peers&quot;);</a>
<a name="ln5405"> </a>
<a name="ln5406">         for (i = 0; i &lt; bgp-&gt;confed_peers_cnt; i++)</a>
<a name="ln5407">           vty_out(vty, &quot; %u&quot;, bgp-&gt;confed_peers[i]);</a>
<a name="ln5408"> </a>
<a name="ln5409">          vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln5410">	}</a>
<a name="ln5411"> </a>
<a name="ln5412">      /* BGP enforce-first-as. */</a>
<a name="ln5413">      if (bgp_flag_check (bgp, BGP_FLAG_ENFORCE_FIRST_AS))</a>
<a name="ln5414">	vty_out (vty, &quot; bgp enforce-first-as%s&quot;, VTY_NEWLINE);</a>
<a name="ln5415"> </a>
<a name="ln5416">      /* BGP deterministic-med. */</a>
<a name="ln5417">      if (bgp_flag_check (bgp, BGP_FLAG_DETERMINISTIC_MED))</a>
<a name="ln5418">	vty_out (vty, &quot; bgp deterministic-med%s&quot;, VTY_NEWLINE);</a>
<a name="ln5419"> </a>
<a name="ln5420">      /* BGP graceful-restart. */</a>
<a name="ln5421">      if (bgp-&gt;stalepath_time != BGP_DEFAULT_STALEPATH_TIME)</a>
<a name="ln5422">	vty_out (vty, &quot; bgp graceful-restart stalepath-time %d%s&quot;,</a>
<a name="ln5423">		 bgp-&gt;stalepath_time, VTY_NEWLINE);</a>
<a name="ln5424">      if (bgp-&gt;restart_time != BGP_DEFAULT_RESTART_TIME)</a>
<a name="ln5425">	vty_out (vty, &quot; bgp graceful-restart restart-time %d%s&quot;,</a>
<a name="ln5426">		 bgp-&gt;restart_time, VTY_NEWLINE);</a>
<a name="ln5427">      if (bgp_flag_check (bgp, BGP_FLAG_GRACEFUL_RESTART))</a>
<a name="ln5428">       vty_out (vty, &quot; bgp graceful-restart%s&quot;, VTY_NEWLINE);</a>
<a name="ln5429"> </a>
<a name="ln5430">      /* BGP bestpath method. */</a>
<a name="ln5431">      if (bgp_flag_check (bgp, BGP_FLAG_ASPATH_IGNORE))</a>
<a name="ln5432">	vty_out (vty, &quot; bgp bestpath as-path ignore%s&quot;, VTY_NEWLINE);</a>
<a name="ln5433">      if (bgp_flag_check (bgp, BGP_FLAG_ASPATH_CONFED))</a>
<a name="ln5434">	vty_out (vty, &quot; bgp bestpath as-path confed%s&quot;, VTY_NEWLINE);</a>
<a name="ln5435">      if (bgp_flag_check (bgp, BGP_FLAG_ASPATH_MULTIPATH_RELAX)) {</a>
<a name="ln5436">	vty_out (vty, &quot; bgp bestpath as-path multipath-relax%s&quot;, VTY_NEWLINE);</a>
<a name="ln5437">      }</a>
<a name="ln5438">      if (bgp_flag_check (bgp, BGP_FLAG_RR_ALLOW_OUTBOUND_POLICY)) {</a>
<a name="ln5439">	vty_out (vty, &quot; bgp route-reflector allow-outbound-policy%s&quot;,</a>
<a name="ln5440">		 VTY_NEWLINE);</a>
<a name="ln5441">      }</a>
<a name="ln5442">      if (bgp_flag_check (bgp, BGP_FLAG_COMPARE_ROUTER_ID))</a>
<a name="ln5443">	vty_out (vty, &quot; bgp bestpath compare-routerid%s&quot;, VTY_NEWLINE);</a>
<a name="ln5444">      if (bgp_flag_check (bgp, BGP_FLAG_MED_CONFED)</a>
<a name="ln5445">	  || bgp_flag_check (bgp, BGP_FLAG_MED_MISSING_AS_WORST))</a>
<a name="ln5446">	{</a>
<a name="ln5447">	  vty_out (vty, &quot; bgp bestpath med&quot;);</a>
<a name="ln5448">	  if (bgp_flag_check (bgp, BGP_FLAG_MED_CONFED))</a>
<a name="ln5449">	    vty_out (vty, &quot; confed&quot;);</a>
<a name="ln5450">	  if (bgp_flag_check (bgp, BGP_FLAG_MED_MISSING_AS_WORST))</a>
<a name="ln5451">	    vty_out (vty, &quot; missing-as-worst&quot;);</a>
<a name="ln5452">	  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln5453">	}</a>
<a name="ln5454"> </a>
<a name="ln5455">      /* BGP network import check. */</a>
<a name="ln5456">      if (bgp_flag_check (bgp, BGP_FLAG_IMPORT_CHECK))</a>
<a name="ln5457">	vty_out (vty, &quot; bgp network import-check%s&quot;, VTY_NEWLINE);</a>
<a name="ln5458"> </a>
<a name="ln5459">      /* BGP flag dampening. */</a>
<a name="ln5460">      if (CHECK_FLAG (bgp-&gt;af_flags[AFI_IP][SAFI_UNICAST],</a>
<a name="ln5461">	  BGP_CONFIG_DAMPENING))</a>
<a name="ln5462">	bgp_config_write_damp (vty);</a>
<a name="ln5463"> </a>
<a name="ln5464">      /* BGP static route configuration. */</a>
<a name="ln5465">      bgp_config_write_network (vty, bgp, AFI_IP, SAFI_UNICAST, &amp;write);</a>
<a name="ln5466"> </a>
<a name="ln5467">      /* BGP redistribute configuration. */</a>
<a name="ln5468">      bgp_config_write_redistribute (vty, bgp, AFI_IP, SAFI_UNICAST, &amp;write);</a>
<a name="ln5469"> </a>
<a name="ln5470">      /* BGP timers configuration. */</a>
<a name="ln5471">      if (bgp-&gt;default_keepalive != BGP_DEFAULT_KEEPALIVE</a>
<a name="ln5472">	  &amp;&amp; bgp-&gt;default_holdtime != BGP_DEFAULT_HOLDTIME)</a>
<a name="ln5473">	vty_out (vty, &quot; timers bgp %d %d%s&quot;, bgp-&gt;default_keepalive, </a>
<a name="ln5474">		 bgp-&gt;default_holdtime, VTY_NEWLINE);</a>
<a name="ln5475"> </a>
<a name="ln5476">      /* peer-group */</a>
<a name="ln5477">      for (ALL_LIST_ELEMENTS (bgp-&gt;group, node, nnode, group))</a>
<a name="ln5478">	{</a>
<a name="ln5479">	  bgp_config_write_peer (vty, bgp, group-&gt;conf, AFI_IP, SAFI_UNICAST);</a>
<a name="ln5480">	}</a>
<a name="ln5481"> </a>
<a name="ln5482">      /* Normal neighbor configuration. */</a>
<a name="ln5483">      for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln5484">	{</a>
<a name="ln5485">	  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_ACCEPT_PEER))</a>
<a name="ln5486">	    bgp_config_write_peer (vty, bgp, peer, AFI_IP, SAFI_UNICAST);</a>
<a name="ln5487">	}</a>
<a name="ln5488"> </a>
<a name="ln5489">      /* maximum-paths */</a>
<a name="ln5490">      bgp_config_write_maxpaths (vty, bgp, AFI_IP, SAFI_UNICAST, &amp;write);</a>
<a name="ln5491"> </a>
<a name="ln5492">      /* Distance configuration. */</a>
<a name="ln5493">      bgp_config_write_distance (vty, bgp, AFI_IP, SAFI_UNICAST, &amp;write);</a>
<a name="ln5494">      </a>
<a name="ln5495">      /* No auto-summary */</a>
<a name="ln5496">      if (bgp_option_check (BGP_OPT_CONFIG_CISCO))</a>
<a name="ln5497">	vty_out (vty, &quot; no auto-summary%s&quot;, VTY_NEWLINE);</a>
<a name="ln5498"> </a>
<a name="ln5499">      /* IPv4 multicast configuration.  */</a>
<a name="ln5500">      write += bgp_config_write_family (vty, bgp, AFI_IP, SAFI_MULTICAST);</a>
<a name="ln5501"> </a>
<a name="ln5502">      /* IPv4 VPN configuration.  */</a>
<a name="ln5503">      write += bgp_config_write_family (vty, bgp, AFI_IP, SAFI_MPLS_VPN);</a>
<a name="ln5504"> </a>
<a name="ln5505">      /* ENCAPv4 configuration.  */</a>
<a name="ln5506">      write += bgp_config_write_family (vty, bgp, AFI_IP, SAFI_ENCAP);</a>
<a name="ln5507"> </a>
<a name="ln5508">      /* IPv6 unicast configuration.  */</a>
<a name="ln5509">      write += bgp_config_write_family (vty, bgp, AFI_IP6, SAFI_UNICAST);</a>
<a name="ln5510"> </a>
<a name="ln5511">      /* IPv6 multicast configuration.  */</a>
<a name="ln5512">      write += bgp_config_write_family (vty, bgp, AFI_IP6, SAFI_MULTICAST);</a>
<a name="ln5513"> </a>
<a name="ln5514">      /* IPv6 VPN configuration.  */</a>
<a name="ln5515">      write += bgp_config_write_family (vty, bgp, AFI_IP6, SAFI_MPLS_VPN);</a>
<a name="ln5516"> </a>
<a name="ln5517">      /* ENCAPv6 configuration.  */</a>
<a name="ln5518">      write += bgp_config_write_family (vty, bgp, AFI_IP6, SAFI_ENCAP);</a>
<a name="ln5519"> </a>
<a name="ln5520">      vty_out (vty, &quot; exit%s&quot;, VTY_NEWLINE);</a>
<a name="ln5521"> </a>
<a name="ln5522">      write++;</a>
<a name="ln5523">    }</a>
<a name="ln5524">  return write;</a>
<a name="ln5525">}</a>
<a name="ln5526"> </a>
<a name="ln5527">void</a>
<a name="ln5528">bgp_master_init (void)</a>
<a name="ln5529">{</a>
<a name="ln5530">  memset (&amp;bgp_master, 0, sizeof (struct bgp_master));</a>
<a name="ln5531"> </a>
<a name="ln5532">  bm = &amp;bgp_master;</a>
<a name="ln5533">  bm-&gt;bgp = list_new ();</a>
<a name="ln5534">  bm-&gt;listen_sockets = list_new ();</a>
<a name="ln5535">  bm-&gt;port = BGP_PORT_DEFAULT;</a>
<a name="ln5536">  bm-&gt;master = thread_master_create ();</a>
<a name="ln5537">  bm-&gt;start_time = bgp_clock ();</a>
<a name="ln5538">}</a>
<a name="ln5539"> </a>
<a name="ln5540"> </a>
<a name="ln5541">void</a>
<a name="ln5542">bgp_init (void)</a>
<a name="ln5543">{</a>
<a name="ln5544"> </a>
<a name="ln5545">  /* allocates some vital data structures used by peer commands in vty_init */</a>
<a name="ln5546">  bgp_scan_init ();</a>
<a name="ln5547"> </a>
<a name="ln5548">  /* Init zebra. */</a>
<a name="ln5549">  bgp_zebra_init (bm-&gt;master);</a>
<a name="ln5550"> </a>
<a name="ln5551">  /* BGP VTY commands installation.  */</a>
<a name="ln5552">  bgp_vty_init ();</a>
<a name="ln5553"> </a>
<a name="ln5554">  /* BGP inits. */</a>
<a name="ln5555">  bgp_attr_init ();</a>
<a name="ln5556">  bgp_debug_init ();</a>
<a name="ln5557">  bgp_dump_init ();</a>
<a name="ln5558">  bgp_route_init ();</a>
<a name="ln5559">  bgp_route_map_init ();</a>
<a name="ln5560">  bgp_address_init ();</a>
<a name="ln5561">  bgp_scan_vty_init();</a>
<a name="ln5562">  bgp_mplsvpn_init ();</a>
<a name="ln5563">  bgp_encap_init ();</a>
<a name="ln5564"> </a>
<a name="ln5565">  /* Access list initialize. */</a>
<a name="ln5566">  access_list_init ();</a>
<a name="ln5567">  access_list_add_hook (peer_distribute_update);</a>
<a name="ln5568">  access_list_delete_hook (peer_distribute_update);</a>
<a name="ln5569"> </a>
<a name="ln5570">  /* Filter list initialize. */</a>
<a name="ln5571">  bgp_filter_init ();</a>
<a name="ln5572">  as_list_add_hook (peer_aslist_update);</a>
<a name="ln5573">  as_list_delete_hook (peer_aslist_update);</a>
<a name="ln5574"> </a>
<a name="ln5575">  /* Prefix list initialize.*/</a>
<a name="ln5576">  prefix_list_init ();</a>
<a name="ln5577">  prefix_list_add_hook (peer_prefix_list_update);</a>
<a name="ln5578">  prefix_list_delete_hook (peer_prefix_list_update);</a>
<a name="ln5579"> </a>
<a name="ln5580">  /* Community list initialize. */</a>
<a name="ln5581">  bgp_clist = community_list_init ();</a>
<a name="ln5582"> </a>
<a name="ln5583">#ifdef HAVE_SNMP</a>
<a name="ln5584">  bgp_snmp_init ();</a>
<a name="ln5585">#endif /* HAVE_SNMP */</a>
<a name="ln5586">}</a>
<a name="ln5587"> </a>
<a name="ln5588">void</a>
<a name="ln5589">bgp_terminate (void)</a>
<a name="ln5590">{</a>
<a name="ln5591">  struct bgp *bgp;</a>
<a name="ln5592">  struct peer *peer;</a>
<a name="ln5593">  struct listnode *node, *nnode;</a>
<a name="ln5594">  struct listnode *mnode, *mnnode;</a>
<a name="ln5595"> </a>
<a name="ln5596">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, mnode, mnnode, bgp))</a>
<a name="ln5597">    for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln5598">      if (peer-&gt;status == Established)</a>
<a name="ln5599">          bgp_notify_send (peer, BGP_NOTIFY_CEASE,</a>
<a name="ln5600">                           BGP_NOTIFY_CEASE_PEER_UNCONFIG);</a>
<a name="ln5601">  </a>
<a name="ln5602">  bgp_cleanup_routes ();</a>
<a name="ln5603">  </a>
<a name="ln5604">  if (bm-&gt;process_main_queue)</a>
<a name="ln5605">    {</a>
<a name="ln5606">      work_queue_free (bm-&gt;process_main_queue);</a>
<a name="ln5607">      bm-&gt;process_main_queue = NULL;</a>
<a name="ln5608">    }</a>
<a name="ln5609">  if (bm-&gt;process_rsclient_queue)</a>
<a name="ln5610">    {</a>
<a name="ln5611">      work_queue_free (bm-&gt;process_rsclient_queue);</a>
<a name="ln5612">      bm-&gt;process_rsclient_queue = NULL;</a>
<a name="ln5613">    }</a>
<a name="ln5614">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="75"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'bm' variable.</p></div>
<div class="balloon" rel="475"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'bgp->confed_peers' pointer was utilized before it was verified against nullptr. Check lines: 475, 481.</p></div>
<div class="balloon" rel="688"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'bgp' pointer was utilized before it was verified against nullptr. Check lines: 688, 701.</p></div>
<div class="balloon" rel="841"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!bgp' is always false.</p></div>
<div class="balloon" rel="926"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v768/" target="_blank">V768</a> The variable 'afi' is of enum type. It is odd that it is used as a variable of a Boolean-type.</p></div>
<div class="balloon" rel="1650"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'pfilter->dlist[in].name' is always false.</p></div>
<div class="balloon" rel="1657"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'pfilter->plist[in].name' is always false.</p></div>
<div class="balloon" rel="1664"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'pfilter->aslist[in].name' is always false.</p></div>
<div class="balloon" rel="1671"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'pfilter->map[0].name' is always false.</p></div>
<div class="balloon" rel="1752"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'pfilter->map[3].name' is always false.</p></div>
<div class="balloon" rel="4538"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (peer->afc[afi][safi]).</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
