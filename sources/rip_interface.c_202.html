
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>rip_interface.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Interface related function for RIP.</a>
<a name="ln2"> * Copyright (C) 1997, 98 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;command.h&quot;</a>
<a name="ln25">#include &quot;if.h&quot;</a>
<a name="ln26">#include &quot;sockunion.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;memory.h&quot;</a>
<a name="ln29">#include &quot;network.h&quot;</a>
<a name="ln30">#include &quot;table.h&quot;</a>
<a name="ln31">#include &quot;log.h&quot;</a>
<a name="ln32">#include &quot;stream.h&quot;</a>
<a name="ln33">#include &quot;thread.h&quot;</a>
<a name="ln34">#include &quot;zclient.h&quot;</a>
<a name="ln35">#include &quot;filter.h&quot;</a>
<a name="ln36">#include &quot;sockopt.h&quot;</a>
<a name="ln37">#include &quot;privs.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;zebra/connected.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;ripd/ripd.h&quot;</a>
<a name="ln42">#include &quot;ripd/rip_debug.h&quot;</a>
<a name="ln43">#include &quot;ripd/rip_interface.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">/* static prototypes */</a>
<a name="ln46">static void rip_enable_apply (struct interface *);</a>
<a name="ln47">static void rip_passive_interface_apply (struct interface *);</a>
<a name="ln48">static int rip_if_down(struct interface *ifp);</a>
<a name="ln49">static int rip_enable_if_lookup (const char *ifname);</a>
<a name="ln50">static int rip_enable_network_lookup2 (struct connected *connected);</a>
<a name="ln51">static void rip_enable_apply_all (void);</a>
<a name="ln52"> </a>
<a name="ln53">const struct message ri_version_msg[] =</a>
<a name="ln54">{</a>
<a name="ln55">  {RI_RIP_VERSION_1,       &quot;1&quot;},</a>
<a name="ln56">  {RI_RIP_VERSION_2,       &quot;2&quot;},</a>
<a name="ln57">  {RI_RIP_VERSION_1_AND_2, &quot;1 2&quot;},</a>
<a name="ln58">};</a>
<a name="ln59"> </a>
<a name="ln60">extern struct zebra_privs_t ripd_privs;</a>
<a name="ln61"> </a>
<a name="ln62">/* RIP enabled network vector. */</a>
<a name="ln63">vector rip_enable_interface;</a>
<a name="ln64"> </a>
<a name="ln65">/* RIP enabled interface table. */</a>
<a name="ln66">struct route_table *rip_enable_network;</a>
<a name="ln67"> </a>
<a name="ln68">/* Vector to store passive-interface name. */</a>
<a name="ln69">static int passive_default;	/* are we in passive-interface default mode? */</a>
<a name="ln70">vector Vrip_passive_nondefault;</a>
<a name="ln71"> </a>
<a name="ln72">/* Join to the RIP version 2 multicast group. */</a>
<a name="ln73">static int</a>
<a name="ln74">ipv4_multicast_join (int sock, </a>
<a name="ln75">		     struct in_addr group, </a>
<a name="ln76">		     struct in_addr ifa,</a>
<a name="ln77">		     ifindex_t ifindex)</a>
<a name="ln78">{</a>
<a name="ln79">  int ret;</a>
<a name="ln80"> </a>
<a name="ln81">  ret = setsockopt_ipv4_multicast (sock,</a>
<a name="ln82">				   IP_ADD_MEMBERSHIP, </a>
<a name="ln83">				   group.s_addr, </a>
<a name="ln84">				   ifindex); </a>
<a name="ln85"> </a>
<a name="ln86">  if (ret &lt; 0) </a>
<a name="ln87">    zlog (NULL, LOG_INFO, &quot;can't setsockopt IP_ADD_MEMBERSHIP %s&quot;,</a>
<a name="ln88">	  safe_strerror (errno));</a>
<a name="ln89"> </a>
<a name="ln90">  return ret;</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">/* Leave from the RIP version 2 multicast group. */</a>
<a name="ln94">static int</a>
<a name="ln95">ipv4_multicast_leave (int sock, </a>
<a name="ln96">		      struct in_addr group, </a>
<a name="ln97">		      struct in_addr ifa,</a>
<a name="ln98">		      ifindex_t ifindex)</a>
<a name="ln99">{</a>
<a name="ln100">  int ret;</a>
<a name="ln101"> </a>
<a name="ln102">  ret = setsockopt_ipv4_multicast (sock,</a>
<a name="ln103">				   IP_DROP_MEMBERSHIP, </a>
<a name="ln104">				   group.s_addr, </a>
<a name="ln105">				   ifindex);</a>
<a name="ln106"> </a>
<a name="ln107">  if (ret &lt; 0) </a>
<a name="ln108">    zlog (NULL, LOG_INFO, &quot;can't setsockopt IP_DROP_MEMBERSHIP&quot;);</a>
<a name="ln109"> </a>
<a name="ln110">  return ret;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">static void rip_interface_reset (struct rip_interface *);</a>
<a name="ln114"> </a>
<a name="ln115">/* Allocate new RIP's interface configuration. */</a>
<a name="ln116">static struct rip_interface *</a>
<a name="ln117">rip_interface_new (void)</a>
<a name="ln118">{</a>
<a name="ln119">  struct rip_interface *ri;</a>
<a name="ln120"> </a>
<a name="ln121">  ri = XCALLOC (MTYPE_RIP_INTERFACE, sizeof (struct rip_interface));</a>
<a name="ln122">  </a>
<a name="ln123">  rip_interface_reset (ri);</a>
<a name="ln124">  </a>
<a name="ln125">  return ri;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">void</a>
<a name="ln129">rip_interface_multicast_set (int sock, struct connected *connected)</a>
<a name="ln130">{</a>
<a name="ln131">  assert (connected != NULL);</a>
<a name="ln132">  </a>
<a name="ln133">  if (setsockopt_ipv4_multicast_if (sock, connected-&gt;ifp-&gt;ifindex) &lt; 0)</a>
<a name="ln134">    {</a>
<a name="ln135">      zlog_warn (&quot;Can't setsockopt IP_MULTICAST_IF on fd %d to &quot;</a>
<a name="ln136">		 &quot;ifindex %d for interface %s&quot;,</a>
<a name="ln137">		 sock, connected-&gt;ifp-&gt;ifindex,</a>
<a name="ln138">		 connected-&gt;ifp-&gt;name);</a>
<a name="ln139">    }</a>
<a name="ln140">  </a>
<a name="ln141">  return;</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">/* Send RIP request packet to specified interface. */</a>
<a name="ln145">static void</a>
<a name="ln146">rip_request_interface_send (struct interface *ifp, u_char version)</a>
<a name="ln147">{</a>
<a name="ln148">  struct sockaddr_in to;</a>
<a name="ln149"> </a>
<a name="ln150">  /* RIPv2 support multicast. */</a>
<a name="ln151">  if (version == RIPv2 &amp;&amp; if_is_multicast (ifp))</a>
<a name="ln152">    {</a>
<a name="ln153">      </a>
<a name="ln154">      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln155">	zlog_debug (&quot;multicast request on %s&quot;, ifp-&gt;name);</a>
<a name="ln156"> </a>
<a name="ln157">      rip_request_send (NULL, ifp, version, NULL);</a>
<a name="ln158">      return;</a>
<a name="ln159">    }</a>
<a name="ln160"> </a>
<a name="ln161">  /* RIPv1 and non multicast interface. */</a>
<a name="ln162">  if (if_is_pointopoint (ifp) || if_is_broadcast (ifp))</a>
<a name="ln163">    {</a>
<a name="ln164">      struct listnode *cnode, *cnnode;</a>
<a name="ln165">      struct connected *connected;</a>
<a name="ln166"> </a>
<a name="ln167">      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln168">	zlog_debug (&quot;broadcast request to %s&quot;, ifp-&gt;name);</a>
<a name="ln169"> </a>
<a name="ln170">      for (ALL_LIST_ELEMENTS (ifp-&gt;connected, cnode, cnnode, connected))</a>
<a name="ln171">	{</a>
<a name="ln172">	  if (connected-&gt;address-&gt;family == AF_INET)</a>
<a name="ln173">	    {</a>
<a name="ln174">	      memset (&amp;to, 0, sizeof (struct sockaddr_in));</a>
<a name="ln175">	      to.sin_port = htons (RIP_PORT_DEFAULT);</a>
<a name="ln176">              if (connected-&gt;destination)</a>
<a name="ln177">                /* use specified broadcast or peer destination addr */</a>
<a name="ln178">                to.sin_addr = connected-&gt;destination-&gt;u.prefix4;</a>
<a name="ln179">              else if (connected-&gt;address-&gt;prefixlen &lt; IPV4_MAX_PREFIXLEN)</a>
<a name="ln180">	        /* calculate the appropriate broadcast address */</a>
<a name="ln181">                to.sin_addr.s_addr =</a>
<a name="ln182">		  ipv4_broadcast_addr(connected-&gt;address-&gt;u.prefix4.s_addr,</a>
<a name="ln183">				      connected-&gt;address-&gt;prefixlen);</a>
<a name="ln184">	      else</a>
<a name="ln185">		/* do not know where to send the packet */</a>
<a name="ln186">	        continue;</a>
<a name="ln187"> </a>
<a name="ln188">	      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln189">		zlog_debug (&quot;SEND request to %s&quot;, inet_ntoa (to.sin_addr));</a>
<a name="ln190">	      </a>
<a name="ln191">	      rip_request_send (&amp;to, ifp, version, connected);</a>
<a name="ln192">	    }</a>
<a name="ln193">	}</a>
<a name="ln194">    }</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">/* This will be executed when interface goes up. */</a>
<a name="ln198">static void</a>
<a name="ln199">rip_request_interface (struct interface *ifp)</a>
<a name="ln200">{</a>
<a name="ln201">  struct rip_interface *ri;</a>
<a name="ln202"> </a>
<a name="ln203">  /* In default ripd doesn't send RIP_REQUEST to the loopback interface. */</a>
<a name="ln204">  if (if_is_loopback (ifp))</a>
<a name="ln205">    return;</a>
<a name="ln206"> </a>
<a name="ln207">  /* If interface is down, don't send RIP packet. */</a>
<a name="ln208">  if (! if_is_operative (ifp))</a>
<a name="ln209">    return;</a>
<a name="ln210"> </a>
<a name="ln211">  /* Fetch RIP interface information. */</a>
<a name="ln212">  ri = ifp-&gt;info;</a>
<a name="ln213"> </a>
<a name="ln214"> </a>
<a name="ln215">  /* If there is no version configuration in the interface,</a>
<a name="ln216">     use rip's version setting. */</a>
<a name="ln217">  {</a>
<a name="ln218">    int vsend = ((ri-&gt;ri_send == RI_RIP_UNSPEC) ?</a>
<a name="ln219">		 rip-&gt;version_send : ri-&gt;ri_send);</a>
<a name="ln220">    if (vsend &amp; RIPv1)</a>
<a name="ln221">      rip_request_interface_send (ifp, RIPv1);</a>
<a name="ln222">    if (vsend &amp; RIPv2)</a>
<a name="ln223">      rip_request_interface_send (ifp, RIPv2);</a>
<a name="ln224">  }</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">#if 0</a>
<a name="ln228">/* Send RIP request to the neighbor. */</a>
<a name="ln229">static void</a>
<a name="ln230">rip_request_neighbor (struct in_addr addr)</a>
<a name="ln231">{</a>
<a name="ln232">  struct sockaddr_in to;</a>
<a name="ln233"> </a>
<a name="ln234">  memset (&amp;to, 0, sizeof (struct sockaddr_in));</a>
<a name="ln235">  to.sin_port = htons (RIP_PORT_DEFAULT);</a>
<a name="ln236">  to.sin_addr = addr;</a>
<a name="ln237"> </a>
<a name="ln238">  rip_request_send (&amp;to, NULL, rip-&gt;version_send, NULL);</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">/* Request routes at all interfaces. */</a>
<a name="ln242">static void</a>
<a name="ln243">rip_request_neighbor_all (void)</a>
<a name="ln244">{</a>
<a name="ln245">  struct route_node *rp;</a>
<a name="ln246"> </a>
<a name="ln247">  if (! rip)</a>
<a name="ln248">    return;</a>
<a name="ln249"> </a>
<a name="ln250">  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln251">    zlog_debug (&quot;request to the all neighbor&quot;);</a>
<a name="ln252"> </a>
<a name="ln253">  /* Send request to all neighbor. */</a>
<a name="ln254">  for (rp = route_top (rip-&gt;neighbor); rp; rp = route_next (rp))</a>
<a name="ln255">    if (rp-&gt;info)</a>
<a name="ln256">      rip_request_neighbor (rp-&gt;p.u.prefix4);</a>
<a name="ln257">}</a>
<a name="ln258">#endif</a>
<a name="ln259"> </a>
<a name="ln260">/* Multicast packet receive socket. */</a>
<a name="ln261">static int</a>
<a name="ln262">rip_multicast_join (struct interface *ifp, int sock)</a>
<a name="ln263">{</a>
<a name="ln264">  struct listnode *cnode;</a>
<a name="ln265">  struct connected *ifc;</a>
<a name="ln266"> </a>
<a name="ln267">  if (if_is_operative (ifp) &amp;&amp; if_is_multicast (ifp))</a>
<a name="ln268">    {</a>
<a name="ln269">      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln270">	zlog_debug (&quot;multicast join at %s&quot;, ifp-&gt;name);</a>
<a name="ln271"> </a>
<a name="ln272">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, ifc))</a>
<a name="ln273">	{</a>
<a name="ln274">	  struct prefix_ipv4 *p;</a>
<a name="ln275">	  struct in_addr group;</a>
<a name="ln276">	      </a>
<a name="ln277">	  p = (struct prefix_ipv4 *) ifc-&gt;address;</a>
<a name="ln278">      </a>
<a name="ln279">	  if (p-&gt;family != AF_INET)</a>
<a name="ln280">	    continue;</a>
<a name="ln281">      </a>
<a name="ln282">	  group.s_addr = htonl (INADDR_RIP_GROUP);</a>
<a name="ln283">	  if (ipv4_multicast_join (sock, group, p-&gt;prefix, ifp-&gt;ifindex) &lt; 0)</a>
<a name="ln284">	    return -1;</a>
<a name="ln285">	  else</a>
<a name="ln286">	    return 0;</a>
<a name="ln287">	}</a>
<a name="ln288">    }</a>
<a name="ln289">  return 0;</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">/* Leave from multicast group. */</a>
<a name="ln293">static void</a>
<a name="ln294">rip_multicast_leave (struct interface *ifp, int sock)</a>
<a name="ln295">{</a>
<a name="ln296">  struct listnode *cnode;</a>
<a name="ln297">  struct connected *connected;</a>
<a name="ln298"> </a>
<a name="ln299">  if (if_is_up (ifp) &amp;&amp; if_is_multicast (ifp))</a>
<a name="ln300">    {</a>
<a name="ln301">      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln302">	zlog_debug (&quot;multicast leave from %s&quot;, ifp-&gt;name);</a>
<a name="ln303"> </a>
<a name="ln304">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, connected))</a>
<a name="ln305">	{</a>
<a name="ln306">	  struct prefix_ipv4 *p;</a>
<a name="ln307">	  struct in_addr group;</a>
<a name="ln308">          </a>
<a name="ln309">	  p = (struct prefix_ipv4 *) connected-&gt;address;</a>
<a name="ln310">	  </a>
<a name="ln311">	  if (p-&gt;family != AF_INET)</a>
<a name="ln312">	    continue;</a>
<a name="ln313">      </a>
<a name="ln314">	  group.s_addr = htonl (INADDR_RIP_GROUP);</a>
<a name="ln315">          if (ipv4_multicast_leave (sock, group, p-&gt;prefix, ifp-&gt;ifindex) == 0)</a>
<a name="ln316">	    return;</a>
<a name="ln317">        }</a>
<a name="ln318">    }</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">/* Is there and address on interface that I could use ? */</a>
<a name="ln322">static int</a>
<a name="ln323">rip_if_ipv4_address_check (struct interface *ifp)</a>
<a name="ln324">{</a>
<a name="ln325">  struct listnode *nn;</a>
<a name="ln326">  struct connected *connected;</a>
<a name="ln327">  int count = 0;</a>
<a name="ln328"> </a>
<a name="ln329">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, nn, connected))</a>
<a name="ln330">    {</a>
<a name="ln331">      struct prefix *p;</a>
<a name="ln332"> </a>
<a name="ln333">      p = connected-&gt;address;</a>
<a name="ln334"> </a>
<a name="ln335">      if (p-&gt;family == AF_INET)</a>
<a name="ln336">        count++;</a>
<a name="ln337">    }</a>
<a name="ln338">						</a>
<a name="ln339">  return count;</a>
<a name="ln340">}</a>
<a name="ln341">						</a>
<a name="ln342">						</a>
<a name="ln343">						</a>
<a name="ln344"> </a>
<a name="ln345">/* Does this address belongs to me ? */</a>
<a name="ln346">int</a>
<a name="ln347">if_check_address (struct in_addr addr)</a>
<a name="ln348">{</a>
<a name="ln349">  struct listnode *node;</a>
<a name="ln350">  struct interface *ifp;</a>
<a name="ln351">  </a>
<a name="ln352">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln353">    {</a>
<a name="ln354">      struct listnode *cnode;</a>
<a name="ln355">      struct connected *connected;</a>
<a name="ln356"> </a>
<a name="ln357">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, connected))</a>
<a name="ln358">	{</a>
<a name="ln359">	  struct prefix_ipv4 *p;</a>
<a name="ln360"> </a>
<a name="ln361">	  p = (struct prefix_ipv4 *) connected-&gt;address;</a>
<a name="ln362"> </a>
<a name="ln363">	  if (p-&gt;family != AF_INET)</a>
<a name="ln364">	    continue;</a>
<a name="ln365"> </a>
<a name="ln366">	  if (IPV4_ADDR_CMP (&amp;p-&gt;prefix, &amp;addr) == 0)</a>
<a name="ln367">	    return 1;</a>
<a name="ln368">	}</a>
<a name="ln369">    }</a>
<a name="ln370">  return 0;</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">/* Inteface link down message processing. */</a>
<a name="ln374">int</a>
<a name="ln375">rip_interface_down (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln376">    vrf_id_t vrf_id)</a>
<a name="ln377">{</a>
<a name="ln378">  struct interface *ifp;</a>
<a name="ln379">  struct stream *s;</a>
<a name="ln380"> </a>
<a name="ln381">  s = zclient-&gt;ibuf;  </a>
<a name="ln382"> </a>
<a name="ln383">  /* zebra_interface_state_read() updates interface structure in</a>
<a name="ln384">     iflist. */</a>
<a name="ln385">  ifp = zebra_interface_state_read (s, vrf_id);</a>
<a name="ln386"> </a>
<a name="ln387">  if (ifp == NULL)</a>
<a name="ln388">    return 0;</a>
<a name="ln389"> </a>
<a name="ln390">  rip_if_down(ifp);</a>
<a name="ln391"> </a>
<a name="ln392">  if (IS_RIP_DEBUG_ZEBRA)</a>
<a name="ln393">    zlog_debug (&quot;interface %s index %d flags %llx metric %d mtu %d is down&quot;,</a>
<a name="ln394">	       ifp-&gt;name, ifp-&gt;ifindex, (unsigned long long)ifp-&gt;flags,</a>
<a name="ln395">	       ifp-&gt;metric, ifp-&gt;mtu);</a>
<a name="ln396"> </a>
<a name="ln397">  return 0;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">/* Inteface link up message processing */</a>
<a name="ln401">int</a>
<a name="ln402">rip_interface_up (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln403">    vrf_id_t vrf_id)</a>
<a name="ln404">{</a>
<a name="ln405">  struct interface *ifp;</a>
<a name="ln406"> </a>
<a name="ln407">  /* zebra_interface_state_read () updates interface structure in</a>
<a name="ln408">     iflist. */</a>
<a name="ln409">  ifp = zebra_interface_state_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln410"> </a>
<a name="ln411">  if (ifp == NULL)</a>
<a name="ln412">    return 0;</a>
<a name="ln413"> </a>
<a name="ln414">  if (IS_RIP_DEBUG_ZEBRA)</a>
<a name="ln415">    zlog_debug (&quot;interface %s index %d flags %#llx metric %d mtu %d is up&quot;,</a>
<a name="ln416">	       ifp-&gt;name, ifp-&gt;ifindex, (unsigned long long) ifp-&gt;flags,</a>
<a name="ln417">	       ifp-&gt;metric, ifp-&gt;mtu);</a>
<a name="ln418"> </a>
<a name="ln419">  /* Check if this interface is RIP enabled or not.*/</a>
<a name="ln420">  rip_enable_apply (ifp);</a>
<a name="ln421"> </a>
<a name="ln422">  /* Check for a passive interface */</a>
<a name="ln423">  rip_passive_interface_apply (ifp);</a>
<a name="ln424"> </a>
<a name="ln425">  /* Apply distribute list to the all interface. */</a>
<a name="ln426">  rip_distribute_update_interface (ifp);</a>
<a name="ln427"> </a>
<a name="ln428">  return 0;</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">/* Inteface addition message from zebra. */</a>
<a name="ln432">int</a>
<a name="ln433">rip_interface_add (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln434">    vrf_id_t vrf_id)</a>
<a name="ln435">{</a>
<a name="ln436">  struct interface *ifp;</a>
<a name="ln437"> </a>
<a name="ln438">  ifp = zebra_interface_add_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln439"> </a>
<a name="ln440">  if (IS_RIP_DEBUG_ZEBRA)</a>
<a name="ln441">    zlog_debug (&quot;interface add %s index %d flags %#llx metric %d mtu %d&quot;,</a>
<a name="ln442">		ifp-&gt;name, ifp-&gt;ifindex, (unsigned long long) ifp-&gt;flags,</a>
<a name="ln443">		ifp-&gt;metric, ifp-&gt;mtu);</a>
<a name="ln444"> </a>
<a name="ln445">  /* Check if this interface is RIP enabled or not.*/</a>
<a name="ln446">  rip_enable_apply (ifp);</a>
<a name="ln447"> </a>
<a name="ln448">  /* Check for a passive interface */</a>
<a name="ln449">  rip_passive_interface_apply (ifp);</a>
<a name="ln450"> </a>
<a name="ln451">  /* Apply distribute list to the all interface. */</a>
<a name="ln452">  rip_distribute_update_interface (ifp);</a>
<a name="ln453"> </a>
<a name="ln454">  /* rip_request_neighbor_all (); */</a>
<a name="ln455"> </a>
<a name="ln456">  /* Check interface routemap. */</a>
<a name="ln457">  rip_if_rmap_update_interface (ifp);</a>
<a name="ln458"> </a>
<a name="ln459">  return 0;</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">int</a>
<a name="ln463">rip_interface_delete (int command, struct zclient *zclient,</a>
<a name="ln464">		      zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln465">{</a>
<a name="ln466">  struct interface *ifp;</a>
<a name="ln467">  struct stream *s;</a>
<a name="ln468"> </a>
<a name="ln469"> </a>
<a name="ln470">  s = zclient-&gt;ibuf;  </a>
<a name="ln471">  /* zebra_interface_state_read() updates interface structure in iflist */</a>
<a name="ln472">  ifp = zebra_interface_state_read (s, vrf_id);</a>
<a name="ln473"> </a>
<a name="ln474">  if (ifp == NULL)</a>
<a name="ln475">    return 0;</a>
<a name="ln476"> </a>
<a name="ln477">  if (if_is_up (ifp)) {</a>
<a name="ln478">    rip_if_down(ifp);</a>
<a name="ln479">  } </a>
<a name="ln480">  </a>
<a name="ln481">  zlog_info(&quot;interface delete %s index %d flags %#llx metric %d mtu %d&quot;,</a>
<a name="ln482">	    ifp-&gt;name, ifp-&gt;ifindex, (unsigned long long) ifp-&gt;flags,</a>
<a name="ln483">	    ifp-&gt;metric, ifp-&gt;mtu);</a>
<a name="ln484">  </a>
<a name="ln485">  /* To support pseudo interface do not free interface structure.  */</a>
<a name="ln486">  /* if_delete(ifp); */</a>
<a name="ln487">  ifp-&gt;ifindex = IFINDEX_INTERNAL;</a>
<a name="ln488"> </a>
<a name="ln489">  return 0;</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">static void</a>
<a name="ln493">rip_interface_clean (struct rip_interface *ri)</a>
<a name="ln494">{</a>
<a name="ln495">  ri-&gt;enable_network = 0;</a>
<a name="ln496">  ri-&gt;enable_interface = 0;</a>
<a name="ln497">  ri-&gt;running = 0;</a>
<a name="ln498"> </a>
<a name="ln499">  if (ri-&gt;t_wakeup)</a>
<a name="ln500">    {</a>
<a name="ln501">      thread_cancel (ri-&gt;t_wakeup);</a>
<a name="ln502">      ri-&gt;t_wakeup = NULL;</a>
<a name="ln503">    }</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">void</a>
<a name="ln507">rip_interfaces_clean (void)</a>
<a name="ln508">{</a>
<a name="ln509">  struct listnode *node;</a>
<a name="ln510">  struct interface *ifp;</a>
<a name="ln511"> </a>
<a name="ln512">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln513">    rip_interface_clean (ifp-&gt;info);</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">static void</a>
<a name="ln517">rip_interface_reset (struct rip_interface *ri)</a>
<a name="ln518">{</a>
<a name="ln519">  /* Default authentication type is simple password for Cisco</a>
<a name="ln520">     compatibility. */</a>
<a name="ln521">  ri-&gt;auth_type = RIP_NO_AUTH;</a>
<a name="ln522">  ri-&gt;md5_auth_len = RIP_AUTH_MD5_COMPAT_SIZE;</a>
<a name="ln523"> </a>
<a name="ln524">  /* Set default split-horizon behavior.  If the interface is Frame</a>
<a name="ln525">     Relay or SMDS is enabled, the default value for split-horizon is</a>
<a name="ln526">     off.  But currently Zebra does detect Frame Relay or SMDS</a>
<a name="ln527">     interface.  So all interface is set to split horizon.  */</a>
<a name="ln528">  ri-&gt;split_horizon_default = RIP_SPLIT_HORIZON;</a>
<a name="ln529">  ri-&gt;split_horizon = ri-&gt;split_horizon_default;</a>
<a name="ln530"> </a>
<a name="ln531">  ri-&gt;ri_send = RI_RIP_UNSPEC;</a>
<a name="ln532">  ri-&gt;ri_receive = RI_RIP_UNSPEC;</a>
<a name="ln533">  </a>
<a name="ln534">  if (ri-&gt;auth_str)</a>
<a name="ln535">    {</a>
<a name="ln536">      free (ri-&gt;auth_str);</a>
<a name="ln537">      ri-&gt;auth_str = NULL;</a>
<a name="ln538">    }</a>
<a name="ln539">  if (ri-&gt;key_chain)</a>
<a name="ln540">    {</a>
<a name="ln541">      free (ri-&gt;key_chain);</a>
<a name="ln542">      ri-&gt;key_chain = NULL;</a>
<a name="ln543">    }</a>
<a name="ln544"> </a>
<a name="ln545">  ri-&gt;list[RIP_FILTER_IN] = NULL;</a>
<a name="ln546">  ri-&gt;list[RIP_FILTER_OUT] = NULL;</a>
<a name="ln547"> </a>
<a name="ln548">  ri-&gt;prefix[RIP_FILTER_IN] = NULL;</a>
<a name="ln549">  ri-&gt;prefix[RIP_FILTER_OUT] = NULL;</a>
<a name="ln550">  </a>
<a name="ln551">  ri-&gt;recv_badpackets = 0;</a>
<a name="ln552">  ri-&gt;recv_badroutes = 0;</a>
<a name="ln553">  ri-&gt;sent_updates = 0;</a>
<a name="ln554"> </a>
<a name="ln555">  ri-&gt;passive = 0;</a>
<a name="ln556">  </a>
<a name="ln557">  rip_interface_clean (ri);</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">void</a>
<a name="ln561">rip_interfaces_reset (void)</a>
<a name="ln562">{</a>
<a name="ln563">  struct listnode *node;</a>
<a name="ln564">  struct interface *ifp;</a>
<a name="ln565"> </a>
<a name="ln566">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln567">    rip_interface_reset (ifp-&gt;info);</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">int</a>
<a name="ln571">rip_if_down(struct interface *ifp)</a>
<a name="ln572">{</a>
<a name="ln573">  struct route_node *rp;</a>
<a name="ln574">  struct rip_info *rinfo;</a>
<a name="ln575">  struct rip_interface *ri = NULL;</a>
<a name="ln576">  struct list *list = NULL;</a>
<a name="ln577">  struct listnode *listnode = NULL, *nextnode = NULL;</a>
<a name="ln578">  if (rip)</a>
<a name="ln579">    for (rp = route_top (rip-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln580">      if ((list = rp-&gt;info) != NULL)</a>
<a name="ln581">        for (ALL_LIST_ELEMENTS (list, listnode, nextnode, rinfo))</a>
<a name="ln582">          if (rinfo-&gt;ifindex == ifp-&gt;ifindex)</a>
<a name="ln583">            rip_ecmp_delete (rinfo);</a>
<a name="ln584"> </a>
<a name="ln585">  ri = ifp-&gt;info;</a>
<a name="ln586">  </a>
<a name="ln587">  if (ri-&gt;running)</a>
<a name="ln588">   {</a>
<a name="ln589">     if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln590">       zlog_debug (&quot;turn off %s&quot;, ifp-&gt;name);</a>
<a name="ln591"> </a>
<a name="ln592">     /* Leave from multicast group. */</a>
<a name="ln593">     rip_multicast_leave (ifp, rip-&gt;sock);</a>
<a name="ln594"> </a>
<a name="ln595">     ri-&gt;running = 0;</a>
<a name="ln596">   }</a>
<a name="ln597"> </a>
<a name="ln598">  return 0;</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">/* Needed for stop RIP process. */</a>
<a name="ln602">void</a>
<a name="ln603">rip_if_down_all ()</a>
<a name="ln604">{</a>
<a name="ln605">  struct interface *ifp;</a>
<a name="ln606">  struct listnode *node, *nnode;</a>
<a name="ln607"> </a>
<a name="ln608">  for (ALL_LIST_ELEMENTS (iflist, node, nnode, ifp))</a>
<a name="ln609">    rip_if_down (ifp);</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">static void</a>
<a name="ln613">rip_apply_address_add (struct connected *ifc)</a>
<a name="ln614">{</a>
<a name="ln615">  struct prefix_ipv4 address;</a>
<a name="ln616">  struct prefix *p;</a>
<a name="ln617"> </a>
<a name="ln618">  if (!rip)</a>
<a name="ln619">    return;</a>
<a name="ln620"> </a>
<a name="ln621">  if (! if_is_up(ifc-&gt;ifp))</a>
<a name="ln622">    return;</a>
<a name="ln623"> </a>
<a name="ln624">  p = ifc-&gt;address;</a>
<a name="ln625"> </a>
<a name="ln626">  memset (&amp;address, 0, sizeof (address));</a>
<a name="ln627">  address.family = p-&gt;family;</a>
<a name="ln628">  address.prefix = p-&gt;u.prefix4;</a>
<a name="ln629">  address.prefixlen = p-&gt;prefixlen;</a>
<a name="ln630">  apply_mask_ipv4(&amp;address);</a>
<a name="ln631"> </a>
<a name="ln632">  /* Check if this interface is RIP enabled or not</a>
<a name="ln633">     or  Check if this address's prefix is RIP enabled */</a>
<a name="ln634">  if ((rip_enable_if_lookup(ifc-&gt;ifp-&gt;name) &gt;= 0) ||</a>
<a name="ln635">      (rip_enable_network_lookup2(ifc) &gt;= 0))</a>
<a name="ln636">    rip_redistribute_add(ZEBRA_ROUTE_CONNECT, RIP_ROUTE_INTERFACE,</a>
<a name="ln637">                         &amp;address, ifc-&gt;ifp-&gt;ifindex, NULL, 0, 0, 0);</a>
<a name="ln638"> </a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">int</a>
<a name="ln642">rip_interface_address_add (int command, struct zclient *zclient,</a>
<a name="ln643">			   zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln644">{</a>
<a name="ln645">  struct connected *ifc;</a>
<a name="ln646">  struct prefix *p;</a>
<a name="ln647"> </a>
<a name="ln648">  ifc = zebra_interface_address_read (ZEBRA_INTERFACE_ADDRESS_ADD, </a>
<a name="ln649">                                      zclient-&gt;ibuf, vrf_id);</a>
<a name="ln650"> </a>
<a name="ln651">  if (ifc == NULL)</a>
<a name="ln652">    return 0;</a>
<a name="ln653"> </a>
<a name="ln654">  p = ifc-&gt;address;</a>
<a name="ln655"> </a>
<a name="ln656">  if (p-&gt;family == AF_INET)</a>
<a name="ln657">    {</a>
<a name="ln658">      if (IS_RIP_DEBUG_ZEBRA)</a>
<a name="ln659">	zlog_debug (&quot;connected address %s/%d is added&quot;, </a>
<a name="ln660">		   inet_ntoa (p-&gt;u.prefix4), p-&gt;prefixlen);</a>
<a name="ln661"> </a>
<a name="ln662">      rip_enable_apply(ifc-&gt;ifp);</a>
<a name="ln663">      /* Check if this prefix needs to be redistributed */</a>
<a name="ln664">      rip_apply_address_add(ifc);</a>
<a name="ln665"> </a>
<a name="ln666">#ifdef HAVE_SNMP</a>
<a name="ln667">      rip_ifaddr_add (ifc-&gt;ifp, ifc);</a>
<a name="ln668">#endif /* HAVE_SNMP */</a>
<a name="ln669">    }</a>
<a name="ln670"> </a>
<a name="ln671">  return 0;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">static void</a>
<a name="ln675">rip_apply_address_del (struct connected *ifc) {</a>
<a name="ln676">  struct prefix_ipv4 address;</a>
<a name="ln677">  struct prefix *p;</a>
<a name="ln678"> </a>
<a name="ln679">  if (!rip)</a>
<a name="ln680">    return;</a>
<a name="ln681"> </a>
<a name="ln682">  if (! if_is_up(ifc-&gt;ifp))</a>
<a name="ln683">    return;</a>
<a name="ln684"> </a>
<a name="ln685">  p = ifc-&gt;address;</a>
<a name="ln686"> </a>
<a name="ln687">  memset (&amp;address, 0, sizeof (address));</a>
<a name="ln688">  address.family = p-&gt;family;</a>
<a name="ln689">  address.prefix = p-&gt;u.prefix4;</a>
<a name="ln690">  address.prefixlen = p-&gt;prefixlen;</a>
<a name="ln691">  apply_mask_ipv4(&amp;address);</a>
<a name="ln692"> </a>
<a name="ln693">  rip_redistribute_delete(ZEBRA_ROUTE_CONNECT, RIP_ROUTE_INTERFACE,</a>
<a name="ln694">                          &amp;address, ifc-&gt;ifp-&gt;ifindex);</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">int</a>
<a name="ln698">rip_interface_address_delete (int command, struct zclient *zclient,</a>
<a name="ln699">			      zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln700">{</a>
<a name="ln701">  struct connected *ifc;</a>
<a name="ln702">  struct prefix *p;</a>
<a name="ln703"> </a>
<a name="ln704">  ifc = zebra_interface_address_read (ZEBRA_INTERFACE_ADDRESS_DELETE,</a>
<a name="ln705">                                      zclient-&gt;ibuf, vrf_id);</a>
<a name="ln706">  </a>
<a name="ln707">  if (ifc)</a>
<a name="ln708">    {</a>
<a name="ln709">      p = ifc-&gt;address;</a>
<a name="ln710">      if (p-&gt;family == AF_INET)</a>
<a name="ln711">	{</a>
<a name="ln712">	  if (IS_RIP_DEBUG_ZEBRA)</a>
<a name="ln713">	    zlog_debug (&quot;connected address %s/%d is deleted&quot;,</a>
<a name="ln714">		       inet_ntoa (p-&gt;u.prefix4), p-&gt;prefixlen);</a>
<a name="ln715"> </a>
<a name="ln716">#ifdef HAVE_SNMP</a>
<a name="ln717">	  rip_ifaddr_delete (ifc-&gt;ifp, ifc);</a>
<a name="ln718">#endif /* HAVE_SNMP */</a>
<a name="ln719"> </a>
<a name="ln720">	  /* Chech wether this prefix needs to be removed */</a>
<a name="ln721">          rip_apply_address_del(ifc);</a>
<a name="ln722"> </a>
<a name="ln723">	}</a>
<a name="ln724"> </a>
<a name="ln725">      connected_free (ifc);</a>
<a name="ln726"> </a>
<a name="ln727">    }</a>
<a name="ln728"> </a>
<a name="ln729">  return 0;</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">/* Check interface is enabled by network statement. */</a>
<a name="ln733">/* Check wether the interface has at least a connected prefix that</a>
<a name="ln734"> * is within the ripng_enable_network table. */</a>
<a name="ln735">static int</a>
<a name="ln736">rip_enable_network_lookup_if (struct interface *ifp)</a>
<a name="ln737">{</a>
<a name="ln738">  struct listnode *node, *nnode;</a>
<a name="ln739">  struct connected *connected;</a>
<a name="ln740">  struct prefix_ipv4 address;</a>
<a name="ln741"> </a>
<a name="ln742">  for (ALL_LIST_ELEMENTS (ifp-&gt;connected, node, nnode, connected))</a>
<a name="ln743">    {</a>
<a name="ln744">      struct prefix *p; </a>
<a name="ln745">      struct route_node *node;</a>
<a name="ln746"> </a>
<a name="ln747">      p = connected-&gt;address;</a>
<a name="ln748"> </a>
<a name="ln749">      if (p-&gt;family == AF_INET)</a>
<a name="ln750">        {</a>
<a name="ln751">          address.family = AF_INET;</a>
<a name="ln752">          address.prefix = p-&gt;u.prefix4;</a>
<a name="ln753">          address.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln754">          </a>
<a name="ln755">          node = route_node_match (rip_enable_network,</a>
<a name="ln756">                                   (struct prefix *)&amp;address);</a>
<a name="ln757">          if (node)</a>
<a name="ln758">            {</a>
<a name="ln759">              route_unlock_node (node);</a>
<a name="ln760">              return 1;</a>
<a name="ln761">            }</a>
<a name="ln762">        }</a>
<a name="ln763">    }</a>
<a name="ln764">  return -1;</a>
<a name="ln765">}</a>
<a name="ln766"> </a>
<a name="ln767">/* Check wether connected is within the ripng_enable_network table. */</a>
<a name="ln768">int</a>
<a name="ln769">rip_enable_network_lookup2 (struct connected *connected)</a>
<a name="ln770">{</a>
<a name="ln771">  struct prefix_ipv4 address;</a>
<a name="ln772">  struct prefix *p;</a>
<a name="ln773"> </a>
<a name="ln774">  p = connected-&gt;address;</a>
<a name="ln775"> </a>
<a name="ln776">  if (p-&gt;family == AF_INET) {</a>
<a name="ln777">    struct route_node *node;</a>
<a name="ln778"> </a>
<a name="ln779">    address.family = p-&gt;family;</a>
<a name="ln780">    address.prefix = p-&gt;u.prefix4;</a>
<a name="ln781">    address.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln782"> </a>
<a name="ln783">    /* LPM on p-&gt;family, p-&gt;u.prefix4/IPV4_MAX_BITLEN within rip_enable_network */</a>
<a name="ln784">    node = route_node_match (rip_enable_network,</a>
<a name="ln785">                             (struct prefix *)&amp;address);</a>
<a name="ln786"> </a>
<a name="ln787">    if (node) {</a>
<a name="ln788">      route_unlock_node (node);</a>
<a name="ln789">      return 1;</a>
<a name="ln790">    }</a>
<a name="ln791">  }</a>
<a name="ln792"> </a>
<a name="ln793">  return -1;</a>
<a name="ln794">}</a>
<a name="ln795">/* Add RIP enable network. */</a>
<a name="ln796">static int</a>
<a name="ln797">rip_enable_network_add (struct prefix *p)</a>
<a name="ln798">{</a>
<a name="ln799">  struct route_node *node;</a>
<a name="ln800"> </a>
<a name="ln801">  node = route_node_get (rip_enable_network, p);</a>
<a name="ln802"> </a>
<a name="ln803">  if (node-&gt;info)</a>
<a name="ln804">    {</a>
<a name="ln805">      route_unlock_node (node);</a>
<a name="ln806">      return -1;</a>
<a name="ln807">    }</a>
<a name="ln808">  else</a>
<a name="ln809">    node-&gt;info = (char *) &quot;enabled&quot;;</a>
<a name="ln810"> </a>
<a name="ln811">  /* XXX: One should find a better solution than a generic one */</a>
<a name="ln812">  rip_enable_apply_all();</a>
<a name="ln813"> </a>
<a name="ln814">  return 1;</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">/* Delete RIP enable network. */</a>
<a name="ln818">static int</a>
<a name="ln819">rip_enable_network_delete (struct prefix *p)</a>
<a name="ln820">{</a>
<a name="ln821">  struct route_node *node;</a>
<a name="ln822"> </a>
<a name="ln823">  node = route_node_lookup (rip_enable_network, p);</a>
<a name="ln824">  if (node)</a>
<a name="ln825">    {</a>
<a name="ln826">      node-&gt;info = NULL;</a>
<a name="ln827"> </a>
<a name="ln828">      /* Unlock info lock. */</a>
<a name="ln829">      route_unlock_node (node);</a>
<a name="ln830"> </a>
<a name="ln831">      /* Unlock lookup lock. */</a>
<a name="ln832">      route_unlock_node (node);</a>
<a name="ln833"> </a>
<a name="ln834">      /* XXX: One should find a better solution than a generic one */</a>
<a name="ln835">      rip_enable_apply_all ();</a>
<a name="ln836"> </a>
<a name="ln837">      return 1;</a>
<a name="ln838">    }</a>
<a name="ln839">  return -1;</a>
<a name="ln840">}</a>
<a name="ln841"> </a>
<a name="ln842">/* Check interface is enabled by ifname statement. */</a>
<a name="ln843">static int</a>
<a name="ln844">rip_enable_if_lookup (const char *ifname)</a>
<a name="ln845">{</a>
<a name="ln846">  unsigned int i;</a>
<a name="ln847">  char *str;</a>
<a name="ln848"> </a>
<a name="ln849">  for (i = 0; i &lt; vector_active (rip_enable_interface); i++)</a>
<a name="ln850">    if ((str = vector_slot (rip_enable_interface, i)) != NULL)</a>
<a name="ln851">      if (strcmp (str, ifname) == 0)</a>
<a name="ln852">	return i;</a>
<a name="ln853">  return -1;</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">/* Add interface to rip_enable_if. */</a>
<a name="ln857">static int</a>
<a name="ln858">rip_enable_if_add (const char *ifname)</a>
<a name="ln859">{</a>
<a name="ln860">  int ret;</a>
<a name="ln861"> </a>
<a name="ln862">  ret = rip_enable_if_lookup (ifname);</a>
<a name="ln863">  if (ret &gt;= 0)</a>
<a name="ln864">    return -1;</a>
<a name="ln865"> </a>
<a name="ln866">  vector_set (rip_enable_interface, strdup (ifname));</a>
<a name="ln867"> </a>
<a name="ln868">  rip_enable_apply_all(); /* TODOVJ */</a>
<a name="ln869"> </a>
<a name="ln870">  return 1;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/* Delete interface from rip_enable_if. */</a>
<a name="ln874">static int</a>
<a name="ln875">rip_enable_if_delete (const char *ifname)</a>
<a name="ln876">{</a>
<a name="ln877">  int index;</a>
<a name="ln878">  char *str;</a>
<a name="ln879"> </a>
<a name="ln880">  index = rip_enable_if_lookup (ifname);</a>
<a name="ln881">  if (index &lt; 0)</a>
<a name="ln882">    return -1;</a>
<a name="ln883"> </a>
<a name="ln884">  str = vector_slot (rip_enable_interface, index);</a>
<a name="ln885">  free (str);</a>
<a name="ln886">  vector_unset (rip_enable_interface, index);</a>
<a name="ln887"> </a>
<a name="ln888">  rip_enable_apply_all(); /* TODOVJ */</a>
<a name="ln889"> </a>
<a name="ln890">  return 1;</a>
<a name="ln891">}</a>
<a name="ln892"> </a>
<a name="ln893">/* Join to multicast group and send request to the interface. */</a>
<a name="ln894">static int</a>
<a name="ln895">rip_interface_wakeup (struct thread *t)</a>
<a name="ln896">{</a>
<a name="ln897">  struct interface *ifp;</a>
<a name="ln898">  struct rip_interface *ri;</a>
<a name="ln899"> </a>
<a name="ln900">  /* Get interface. */</a>
<a name="ln901">  ifp = THREAD_ARG (t);</a>
<a name="ln902"> </a>
<a name="ln903">  ri = ifp-&gt;info;</a>
<a name="ln904">  ri-&gt;t_wakeup = NULL;</a>
<a name="ln905"> </a>
<a name="ln906">  /* Join to multicast group. */</a>
<a name="ln907">  if (rip_multicast_join (ifp, rip-&gt;sock) &lt; 0)</a>
<a name="ln908">    {</a>
<a name="ln909">      zlog_err (&quot;multicast join failed, interface %s not running&quot;, ifp-&gt;name);</a>
<a name="ln910">      return 0;</a>
<a name="ln911">    }</a>
<a name="ln912"> </a>
<a name="ln913">  /* Set running flag. */</a>
<a name="ln914">  ri-&gt;running = 1;</a>
<a name="ln915"> </a>
<a name="ln916">  /* Send RIP request to the interface. */</a>
<a name="ln917">  rip_request_interface (ifp);</a>
<a name="ln918"> </a>
<a name="ln919">  return 0;</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">static void</a>
<a name="ln923">rip_connect_set (struct interface *ifp, int set)</a>
<a name="ln924">{</a>
<a name="ln925">  struct listnode *node, *nnode;</a>
<a name="ln926">  struct connected *connected;</a>
<a name="ln927">  struct prefix_ipv4 address;</a>
<a name="ln928"> </a>
<a name="ln929">  for (ALL_LIST_ELEMENTS (ifp-&gt;connected, node, nnode, connected))</a>
<a name="ln930">    {</a>
<a name="ln931">      struct prefix *p; </a>
<a name="ln932">      p = connected-&gt;address;</a>
<a name="ln933"> </a>
<a name="ln934">      if (p-&gt;family != AF_INET)</a>
<a name="ln935">        continue;</a>
<a name="ln936"> </a>
<a name="ln937">      address.family = AF_INET;</a>
<a name="ln938">      address.prefix = p-&gt;u.prefix4;</a>
<a name="ln939">      address.prefixlen = p-&gt;prefixlen;</a>
<a name="ln940">      apply_mask_ipv4 (&amp;address);</a>
<a name="ln941"> </a>
<a name="ln942">      if (set) {</a>
<a name="ln943">        /* Check once more wether this prefix is within a &quot;network IF_OR_PREF&quot; one */</a>
<a name="ln944">        if ((rip_enable_if_lookup(connected-&gt;ifp-&gt;name) &gt;= 0) ||</a>
<a name="ln945">            (rip_enable_network_lookup2(connected) &gt;= 0))</a>
<a name="ln946">          rip_redistribute_add (ZEBRA_ROUTE_CONNECT, RIP_ROUTE_INTERFACE,</a>
<a name="ln947">                                &amp;address, connected-&gt;ifp-&gt;ifindex, </a>
<a name="ln948">                                NULL, 0, 0, 0);</a>
<a name="ln949">      } else</a>
<a name="ln950">        {</a>
<a name="ln951">          rip_redistribute_delete (ZEBRA_ROUTE_CONNECT, RIP_ROUTE_INTERFACE,</a>
<a name="ln952">                                   &amp;address, connected-&gt;ifp-&gt;ifindex);</a>
<a name="ln953">          if (rip_redistribute_check (ZEBRA_ROUTE_CONNECT))</a>
<a name="ln954">            rip_redistribute_add (ZEBRA_ROUTE_CONNECT, RIP_ROUTE_REDISTRIBUTE,</a>
<a name="ln955">                                  &amp;address, connected-&gt;ifp-&gt;ifindex,</a>
<a name="ln956">                                  NULL, 0, 0, 0);</a>
<a name="ln957">        }</a>
<a name="ln958">    }</a>
<a name="ln959">}</a>
<a name="ln960"> </a>
<a name="ln961">/* Update interface status. */</a>
<a name="ln962">void</a>
<a name="ln963">rip_enable_apply (struct interface *ifp)</a>
<a name="ln964">{</a>
<a name="ln965">  int ret;</a>
<a name="ln966">  struct rip_interface *ri = NULL;</a>
<a name="ln967"> </a>
<a name="ln968">  /* Check interface. */</a>
<a name="ln969">  if (! if_is_operative (ifp))</a>
<a name="ln970">    return;</a>
<a name="ln971"> </a>
<a name="ln972">  ri = ifp-&gt;info;</a>
<a name="ln973"> </a>
<a name="ln974">  /* Check network configuration. */</a>
<a name="ln975">  ret = rip_enable_network_lookup_if (ifp);</a>
<a name="ln976"> </a>
<a name="ln977">  /* If the interface is matched. */</a>
<a name="ln978">  if (ret &gt; 0)</a>
<a name="ln979">    ri-&gt;enable_network = 1;</a>
<a name="ln980">  else</a>
<a name="ln981">    ri-&gt;enable_network = 0;</a>
<a name="ln982"> </a>
<a name="ln983">  /* Check interface name configuration. */</a>
<a name="ln984">  ret = rip_enable_if_lookup (ifp-&gt;name);</a>
<a name="ln985">  if (ret &gt;= 0)</a>
<a name="ln986">    ri-&gt;enable_interface = 1;</a>
<a name="ln987">  else</a>
<a name="ln988">    ri-&gt;enable_interface = 0;</a>
<a name="ln989"> </a>
<a name="ln990">  /* any interface MUST have an IPv4 address */</a>
<a name="ln991">  if ( ! rip_if_ipv4_address_check (ifp) )</a>
<a name="ln992">    {</a>
<a name="ln993">      ri-&gt;enable_network = 0;</a>
<a name="ln994">      ri-&gt;enable_interface = 0;</a>
<a name="ln995">    }</a>
<a name="ln996"> </a>
<a name="ln997">  /* Update running status of the interface. */</a>
<a name="ln998">  if (ri-&gt;enable_network || ri-&gt;enable_interface)</a>
<a name="ln999">    {</a>
<a name="ln1000">	{</a>
<a name="ln1001">	  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1002">	    zlog_debug (&quot;turn on %s&quot;, ifp-&gt;name);</a>
<a name="ln1003"> </a>
<a name="ln1004">	  /* Add interface wake up thread. */</a>
<a name="ln1005">	  if (! ri-&gt;t_wakeup)</a>
<a name="ln1006">	    ri-&gt;t_wakeup = thread_add_timer (master, rip_interface_wakeup,</a>
<a name="ln1007">					     ifp, 1);</a>
<a name="ln1008">          rip_connect_set (ifp, 1);</a>
<a name="ln1009">	}</a>
<a name="ln1010">    }</a>
<a name="ln1011">  else</a>
<a name="ln1012">    {</a>
<a name="ln1013">      if (ri-&gt;running)</a>
<a name="ln1014">	{</a>
<a name="ln1015">	  /* Might as well clean up the route table as well</a>
<a name="ln1016">	   * rip_if_down sets to 0 ri-&gt;running, and displays &quot;turn off %s&quot;</a>
<a name="ln1017">	   **/ </a>
<a name="ln1018">	  rip_if_down(ifp);</a>
<a name="ln1019"> </a>
<a name="ln1020">          rip_connect_set (ifp, 0);</a>
<a name="ln1021">	}</a>
<a name="ln1022">    }</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">/* Apply network configuration to all interface. */</a>
<a name="ln1026">void</a>
<a name="ln1027">rip_enable_apply_all ()</a>
<a name="ln1028">{</a>
<a name="ln1029">  struct interface *ifp;</a>
<a name="ln1030">  struct listnode *node, *nnode;</a>
<a name="ln1031"> </a>
<a name="ln1032">  /* Check each interface. */</a>
<a name="ln1033">  for (ALL_LIST_ELEMENTS (iflist, node, nnode, ifp))</a>
<a name="ln1034">    rip_enable_apply (ifp);</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037">int</a>
<a name="ln1038">rip_neighbor_lookup (struct sockaddr_in *from)</a>
<a name="ln1039">{</a>
<a name="ln1040">  struct prefix_ipv4 p;</a>
<a name="ln1041">  struct route_node *node;</a>
<a name="ln1042"> </a>
<a name="ln1043">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln1044">  p.family = AF_INET;</a>
<a name="ln1045">  p.prefix = from-&gt;sin_addr;</a>
<a name="ln1046">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln1047"> </a>
<a name="ln1048">  node = route_node_lookup (rip-&gt;neighbor, (struct prefix *) &amp;p);</a>
<a name="ln1049">  if (node)</a>
<a name="ln1050">    {</a>
<a name="ln1051">      route_unlock_node (node);</a>
<a name="ln1052">      return 1;</a>
<a name="ln1053">    }</a>
<a name="ln1054">  return 0;</a>
<a name="ln1055">}</a>
<a name="ln1056"> </a>
<a name="ln1057">/* Add new RIP neighbor to the neighbor tree. */</a>
<a name="ln1058">static int</a>
<a name="ln1059">rip_neighbor_add (struct prefix_ipv4 *p)</a>
<a name="ln1060">{</a>
<a name="ln1061">  struct route_node *node;</a>
<a name="ln1062"> </a>
<a name="ln1063">  node = route_node_get (rip-&gt;neighbor, (struct prefix *) p);</a>
<a name="ln1064"> </a>
<a name="ln1065">  if (node-&gt;info)</a>
<a name="ln1066">    return -1;</a>
<a name="ln1067"> </a>
<a name="ln1068">  node-&gt;info = rip-&gt;neighbor;</a>
<a name="ln1069"> </a>
<a name="ln1070">  return 0;</a>
<a name="ln1071">}</a>
<a name="ln1072"> </a>
<a name="ln1073">/* Delete RIP neighbor from the neighbor tree. */</a>
<a name="ln1074">static int</a>
<a name="ln1075">rip_neighbor_delete (struct prefix_ipv4 *p)</a>
<a name="ln1076">{</a>
<a name="ln1077">  struct route_node *node;</a>
<a name="ln1078"> </a>
<a name="ln1079">  /* Lock for look up. */</a>
<a name="ln1080">  node = route_node_lookup (rip-&gt;neighbor, (struct prefix *) p);</a>
<a name="ln1081">  if (! node)</a>
<a name="ln1082">    return -1;</a>
<a name="ln1083">  </a>
<a name="ln1084">  node-&gt;info = NULL;</a>
<a name="ln1085"> </a>
<a name="ln1086">  /* Unlock lookup lock. */</a>
<a name="ln1087">  route_unlock_node (node);</a>
<a name="ln1088"> </a>
<a name="ln1089">  /* Unlock real neighbor information lock. */</a>
<a name="ln1090">  route_unlock_node (node);</a>
<a name="ln1091"> </a>
<a name="ln1092">  return 0;</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">/* Clear all network and neighbor configuration. */</a>
<a name="ln1096">void</a>
<a name="ln1097">rip_clean_network ()</a>
<a name="ln1098">{</a>
<a name="ln1099">  unsigned int i;</a>
<a name="ln1100">  char *str;</a>
<a name="ln1101">  struct route_node *rn;</a>
<a name="ln1102"> </a>
<a name="ln1103">  /* rip_enable_network. */</a>
<a name="ln1104">  for (rn = route_top (rip_enable_network); rn; rn = route_next (rn))</a>
<a name="ln1105">    if (rn-&gt;info)</a>
<a name="ln1106">      {</a>
<a name="ln1107">	rn-&gt;info = NULL;</a>
<a name="ln1108">	route_unlock_node (rn);</a>
<a name="ln1109">      }</a>
<a name="ln1110"> </a>
<a name="ln1111">  /* rip_enable_interface. */</a>
<a name="ln1112">  for (i = 0; i &lt; vector_active (rip_enable_interface); i++)</a>
<a name="ln1113">    if ((str = vector_slot (rip_enable_interface, i)) != NULL)</a>
<a name="ln1114">      {</a>
<a name="ln1115">	free (str);</a>
<a name="ln1116">	vector_slot (rip_enable_interface, i) = NULL;</a>
<a name="ln1117">      }</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">/* Utility function for looking up passive interface settings. */</a>
<a name="ln1121">static int</a>
<a name="ln1122">rip_passive_nondefault_lookup (const char *ifname)</a>
<a name="ln1123">{</a>
<a name="ln1124">  unsigned int i;</a>
<a name="ln1125">  char *str;</a>
<a name="ln1126"> </a>
<a name="ln1127">  for (i = 0; i &lt; vector_active (Vrip_passive_nondefault); i++)</a>
<a name="ln1128">    if ((str = vector_slot (Vrip_passive_nondefault, i)) != NULL)</a>
<a name="ln1129">      if (strcmp (str, ifname) == 0)</a>
<a name="ln1130">	return i;</a>
<a name="ln1131">  return -1;</a>
<a name="ln1132">}</a>
<a name="ln1133"> </a>
<a name="ln1134">void</a>
<a name="ln1135">rip_passive_interface_apply (struct interface *ifp)</a>
<a name="ln1136">{</a>
<a name="ln1137">  struct rip_interface *ri;</a>
<a name="ln1138"> </a>
<a name="ln1139">  ri = ifp-&gt;info;</a>
<a name="ln1140"> </a>
<a name="ln1141">  ri-&gt;passive = ((rip_passive_nondefault_lookup (ifp-&gt;name) &lt; 0) ?</a>
<a name="ln1142">		 passive_default : !passive_default);</a>
<a name="ln1143"> </a>
<a name="ln1144">  if (IS_RIP_DEBUG_ZEBRA)</a>
<a name="ln1145">    zlog_debug (&quot;interface %s: passive = %d&quot;,ifp-&gt;name,ri-&gt;passive);</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148">static void</a>
<a name="ln1149">rip_passive_interface_apply_all (void)</a>
<a name="ln1150">{</a>
<a name="ln1151">  struct interface *ifp;</a>
<a name="ln1152">  struct listnode *node, *nnode;</a>
<a name="ln1153"> </a>
<a name="ln1154">  for (ALL_LIST_ELEMENTS (iflist, node, nnode, ifp))</a>
<a name="ln1155">    rip_passive_interface_apply (ifp);</a>
<a name="ln1156">}</a>
<a name="ln1157"> </a>
<a name="ln1158">/* Passive interface. */</a>
<a name="ln1159">static int</a>
<a name="ln1160">rip_passive_nondefault_set (struct vty *vty, const char *ifname)</a>
<a name="ln1161">{</a>
<a name="ln1162">  if (rip_passive_nondefault_lookup (ifname) &gt;= 0)</a>
<a name="ln1163">    return CMD_WARNING;</a>
<a name="ln1164"> </a>
<a name="ln1165">  vector_set (Vrip_passive_nondefault, strdup (ifname));</a>
<a name="ln1166"> </a>
<a name="ln1167">  rip_passive_interface_apply_all ();</a>
<a name="ln1168"> </a>
<a name="ln1169">  return CMD_SUCCESS;</a>
<a name="ln1170">}</a>
<a name="ln1171"> </a>
<a name="ln1172">static int</a>
<a name="ln1173">rip_passive_nondefault_unset (struct vty *vty, const char *ifname)</a>
<a name="ln1174">{</a>
<a name="ln1175">  int i;</a>
<a name="ln1176">  char *str;</a>
<a name="ln1177"> </a>
<a name="ln1178">  i = rip_passive_nondefault_lookup (ifname);</a>
<a name="ln1179">  if (i &lt; 0)</a>
<a name="ln1180">    return CMD_WARNING;</a>
<a name="ln1181"> </a>
<a name="ln1182">  str = vector_slot (Vrip_passive_nondefault, i);</a>
<a name="ln1183">  free (str);</a>
<a name="ln1184">  vector_unset (Vrip_passive_nondefault, i);</a>
<a name="ln1185"> </a>
<a name="ln1186">  rip_passive_interface_apply_all ();</a>
<a name="ln1187"> </a>
<a name="ln1188">  return CMD_SUCCESS;</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191">/* Free all configured RIP passive-interface settings. */</a>
<a name="ln1192">void</a>
<a name="ln1193">rip_passive_nondefault_clean (void)</a>
<a name="ln1194">{</a>
<a name="ln1195">  unsigned int i;</a>
<a name="ln1196">  char *str;</a>
<a name="ln1197"> </a>
<a name="ln1198">  for (i = 0; i &lt; vector_active (Vrip_passive_nondefault); i++)</a>
<a name="ln1199">    if ((str = vector_slot (Vrip_passive_nondefault, i)) != NULL)</a>
<a name="ln1200">      {</a>
<a name="ln1201">	free (str);</a>
<a name="ln1202">	vector_slot (Vrip_passive_nondefault, i) = NULL;</a>
<a name="ln1203">      }</a>
<a name="ln1204">  rip_passive_interface_apply_all ();</a>
<a name="ln1205">}</a>
<a name="ln1206"> </a>
<a name="ln1207">/* RIP enable network or interface configuration. */</a>
<a name="ln1208">DEFUN (rip_network,</a>
<a name="ln1209">       rip_network_cmd,</a>
<a name="ln1210">       &quot;network (A.B.C.D/M|WORD)&quot;,</a>
<a name="ln1211">       &quot;Enable routing on an IP network\n&quot;</a>
<a name="ln1212">       &quot;IP prefix &lt;network&gt;/&lt;length&gt;, e.g., 35.0.0.0/8\n&quot;</a>
<a name="ln1213">       &quot;Interface name\n&quot;)</a>
<a name="ln1214">{</a>
<a name="ln1215">  int ret;</a>
<a name="ln1216">  struct prefix_ipv4 p;</a>
<a name="ln1217"> </a>
<a name="ln1218">  ret = str2prefix_ipv4 (argv[0], &amp;p);</a>
<a name="ln1219"> </a>
<a name="ln1220">  if (ret)</a>
<a name="ln1221">    ret = rip_enable_network_add ((struct prefix *) &amp;p);</a>
<a name="ln1222">  else</a>
<a name="ln1223">    ret = rip_enable_if_add (argv[0]);</a>
<a name="ln1224"> </a>
<a name="ln1225">  if (ret &lt; 0)</a>
<a name="ln1226">    {</a>
<a name="ln1227">      vty_out (vty, &quot;There is a same network configuration %s%s&quot;, argv[0],</a>
<a name="ln1228">	       VTY_NEWLINE);</a>
<a name="ln1229">      return CMD_WARNING;</a>
<a name="ln1230">    }</a>
<a name="ln1231"> </a>
<a name="ln1232">  return CMD_SUCCESS;</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235">/* RIP enable network or interface configuration. */</a>
<a name="ln1236">DEFUN (no_rip_network,</a>
<a name="ln1237">       no_rip_network_cmd,</a>
<a name="ln1238">       &quot;no network (A.B.C.D/M|WORD)&quot;,</a>
<a name="ln1239">       NO_STR</a>
<a name="ln1240">       &quot;Enable routing on an IP network\n&quot;</a>
<a name="ln1241">       &quot;IP prefix &lt;network&gt;/&lt;length&gt;, e.g., 35.0.0.0/8\n&quot;</a>
<a name="ln1242">       &quot;Interface name\n&quot;)</a>
<a name="ln1243">{</a>
<a name="ln1244">  int ret;</a>
<a name="ln1245">  struct prefix_ipv4 p;</a>
<a name="ln1246"> </a>
<a name="ln1247">  ret = str2prefix_ipv4 (argv[0], &amp;p);</a>
<a name="ln1248"> </a>
<a name="ln1249">  if (ret)</a>
<a name="ln1250">    ret = rip_enable_network_delete ((struct prefix *) &amp;p);</a>
<a name="ln1251">  else</a>
<a name="ln1252">    ret = rip_enable_if_delete (argv[0]);</a>
<a name="ln1253"> </a>
<a name="ln1254">  if (ret &lt; 0)</a>
<a name="ln1255">    {</a>
<a name="ln1256">      vty_out (vty, &quot;Can't find network configuration %s%s&quot;, argv[0],</a>
<a name="ln1257">	       VTY_NEWLINE);</a>
<a name="ln1258">      return CMD_WARNING;</a>
<a name="ln1259">    }</a>
<a name="ln1260"> </a>
<a name="ln1261">  return CMD_SUCCESS;</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">/* RIP neighbor configuration set. */</a>
<a name="ln1265">DEFUN (rip_neighbor,</a>
<a name="ln1266">       rip_neighbor_cmd,</a>
<a name="ln1267">       &quot;neighbor A.B.C.D&quot;,</a>
<a name="ln1268">       &quot;Specify a neighbor router\n&quot;</a>
<a name="ln1269">       &quot;Neighbor address\n&quot;)</a>
<a name="ln1270">{</a>
<a name="ln1271">  int ret;</a>
<a name="ln1272">  struct prefix_ipv4 p;</a>
<a name="ln1273"> </a>
<a name="ln1274">  ret = str2prefix_ipv4 (argv[0], &amp;p);</a>
<a name="ln1275"> </a>
<a name="ln1276">  if (ret &lt;= 0)</a>
<a name="ln1277">    {</a>
<a name="ln1278">      vty_out (vty, &quot;Please specify address by A.B.C.D%s&quot;, VTY_NEWLINE);</a>
<a name="ln1279">      return CMD_WARNING;</a>
<a name="ln1280">    }</a>
<a name="ln1281"> </a>
<a name="ln1282">  rip_neighbor_add (&amp;p);</a>
<a name="ln1283">  </a>
<a name="ln1284">  return CMD_SUCCESS;</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">/* RIP neighbor configuration unset. */</a>
<a name="ln1288">DEFUN (no_rip_neighbor,</a>
<a name="ln1289">       no_rip_neighbor_cmd,</a>
<a name="ln1290">       &quot;no neighbor A.B.C.D&quot;,</a>
<a name="ln1291">       NO_STR</a>
<a name="ln1292">       &quot;Specify a neighbor router\n&quot;</a>
<a name="ln1293">       &quot;Neighbor address\n&quot;)</a>
<a name="ln1294">{</a>
<a name="ln1295">  int ret;</a>
<a name="ln1296">  struct prefix_ipv4 p;</a>
<a name="ln1297"> </a>
<a name="ln1298">  ret = str2prefix_ipv4 (argv[0], &amp;p);</a>
<a name="ln1299"> </a>
<a name="ln1300">  if (ret &lt;= 0)</a>
<a name="ln1301">    {</a>
<a name="ln1302">      vty_out (vty, &quot;Please specify address by A.B.C.D%s&quot;, VTY_NEWLINE);</a>
<a name="ln1303">      return CMD_WARNING;</a>
<a name="ln1304">    }</a>
<a name="ln1305"> </a>
<a name="ln1306">  rip_neighbor_delete (&amp;p);</a>
<a name="ln1307">  </a>
<a name="ln1308">  return CMD_SUCCESS;</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>
<a name="ln1311">DEFUN (ip_rip_receive_version,</a>
<a name="ln1312">       ip_rip_receive_version_cmd,</a>
<a name="ln1313">       &quot;ip rip receive version (1|2)&quot;,</a>
<a name="ln1314">       IP_STR</a>
<a name="ln1315">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1316">       &quot;Advertisement reception\n&quot;</a>
<a name="ln1317">       &quot;Version control\n&quot;</a>
<a name="ln1318">       &quot;RIP version 1\n&quot;</a>
<a name="ln1319">       &quot;RIP version 2\n&quot;)</a>
<a name="ln1320">{</a>
<a name="ln1321">  struct interface *ifp;</a>
<a name="ln1322">  struct rip_interface *ri;</a>
<a name="ln1323"> </a>
<a name="ln1324">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1325">  ri = ifp-&gt;info;</a>
<a name="ln1326"> </a>
<a name="ln1327">  /* Version 1. */</a>
<a name="ln1328">  if (atoi (argv[0]) == 1)</a>
<a name="ln1329">    {</a>
<a name="ln1330">      ri-&gt;ri_receive = RI_RIP_VERSION_1;</a>
<a name="ln1331">      return CMD_SUCCESS;</a>
<a name="ln1332">    }</a>
<a name="ln1333">  if (atoi (argv[0]) == 2)</a>
<a name="ln1334">    {</a>
<a name="ln1335">      ri-&gt;ri_receive = RI_RIP_VERSION_2;</a>
<a name="ln1336">      return CMD_SUCCESS;</a>
<a name="ln1337">    }</a>
<a name="ln1338">  return CMD_WARNING;</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">DEFUN (ip_rip_receive_version_1,</a>
<a name="ln1342">       ip_rip_receive_version_1_cmd,</a>
<a name="ln1343">       &quot;ip rip receive version 1 2&quot;,</a>
<a name="ln1344">       IP_STR</a>
<a name="ln1345">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1346">       &quot;Advertisement reception\n&quot;</a>
<a name="ln1347">       &quot;Version control\n&quot;</a>
<a name="ln1348">       &quot;RIP version 1\n&quot;</a>
<a name="ln1349">       &quot;RIP version 2\n&quot;)</a>
<a name="ln1350">{</a>
<a name="ln1351">  struct interface *ifp;</a>
<a name="ln1352">  struct rip_interface *ri;</a>
<a name="ln1353"> </a>
<a name="ln1354">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1355">  ri = ifp-&gt;info;</a>
<a name="ln1356"> </a>
<a name="ln1357">  /* Version 1 and 2. */</a>
<a name="ln1358">  ri-&gt;ri_receive = RI_RIP_VERSION_1_AND_2;</a>
<a name="ln1359">  return CMD_SUCCESS;</a>
<a name="ln1360">}</a>
<a name="ln1361"> </a>
<a name="ln1362">DEFUN (ip_rip_receive_version_2,</a>
<a name="ln1363">       ip_rip_receive_version_2_cmd,</a>
<a name="ln1364">       &quot;ip rip receive version 2 1&quot;,</a>
<a name="ln1365">       IP_STR</a>
<a name="ln1366">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1367">       &quot;Advertisement reception\n&quot;</a>
<a name="ln1368">       &quot;Version control\n&quot;</a>
<a name="ln1369">       &quot;RIP version 2\n&quot;</a>
<a name="ln1370">       &quot;RIP version 1\n&quot;)</a>
<a name="ln1371">{</a>
<a name="ln1372">  struct interface *ifp;</a>
<a name="ln1373">  struct rip_interface *ri;</a>
<a name="ln1374"> </a>
<a name="ln1375">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1376">  ri = ifp-&gt;info;</a>
<a name="ln1377"> </a>
<a name="ln1378">  /* Version 1 and 2. */</a>
<a name="ln1379">  ri-&gt;ri_receive = RI_RIP_VERSION_1_AND_2;</a>
<a name="ln1380">  return CMD_SUCCESS;</a>
<a name="ln1381">}</a>
<a name="ln1382"> </a>
<a name="ln1383">DEFUN (no_ip_rip_receive_version,</a>
<a name="ln1384">       no_ip_rip_receive_version_cmd,</a>
<a name="ln1385">       &quot;no ip rip receive version&quot;,</a>
<a name="ln1386">       NO_STR</a>
<a name="ln1387">       IP_STR</a>
<a name="ln1388">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1389">       &quot;Advertisement reception\n&quot;</a>
<a name="ln1390">       &quot;Version control\n&quot;)</a>
<a name="ln1391">{</a>
<a name="ln1392">  struct interface *ifp;</a>
<a name="ln1393">  struct rip_interface *ri;</a>
<a name="ln1394"> </a>
<a name="ln1395">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1396">  ri = ifp-&gt;info;</a>
<a name="ln1397"> </a>
<a name="ln1398">  ri-&gt;ri_receive = RI_RIP_UNSPEC;</a>
<a name="ln1399">  return CMD_SUCCESS;</a>
<a name="ln1400">}</a>
<a name="ln1401"> </a>
<a name="ln1402">ALIAS (no_ip_rip_receive_version,</a>
<a name="ln1403">       no_ip_rip_receive_version_num_cmd,</a>
<a name="ln1404">       &quot;no ip rip receive version (1|2)&quot;,</a>
<a name="ln1405">       NO_STR</a>
<a name="ln1406">       IP_STR</a>
<a name="ln1407">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1408">       &quot;Advertisement reception\n&quot;</a>
<a name="ln1409">       &quot;Version control\n&quot;</a>
<a name="ln1410">       &quot;Version 1\n&quot;</a>
<a name="ln1411">       &quot;Version 2\n&quot;)</a>
<a name="ln1412"> </a>
<a name="ln1413">DEFUN (ip_rip_send_version,</a>
<a name="ln1414">       ip_rip_send_version_cmd,</a>
<a name="ln1415">       &quot;ip rip send version (1|2)&quot;,</a>
<a name="ln1416">       IP_STR</a>
<a name="ln1417">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1418">       &quot;Advertisement transmission\n&quot;</a>
<a name="ln1419">       &quot;Version control\n&quot;</a>
<a name="ln1420">       &quot;RIP version 1\n&quot;</a>
<a name="ln1421">       &quot;RIP version 2\n&quot;)</a>
<a name="ln1422">{</a>
<a name="ln1423">  struct interface *ifp;</a>
<a name="ln1424">  struct rip_interface *ri;</a>
<a name="ln1425"> </a>
<a name="ln1426">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1427">  ri = ifp-&gt;info;</a>
<a name="ln1428"> </a>
<a name="ln1429">  /* Version 1. */</a>
<a name="ln1430">  if (atoi (argv[0]) == 1)</a>
<a name="ln1431">    {</a>
<a name="ln1432">      ri-&gt;ri_send = RI_RIP_VERSION_1;</a>
<a name="ln1433">      return CMD_SUCCESS;</a>
<a name="ln1434">    }</a>
<a name="ln1435">  if (atoi (argv[0]) == 2)</a>
<a name="ln1436">    {</a>
<a name="ln1437">      ri-&gt;ri_send = RI_RIP_VERSION_2;</a>
<a name="ln1438">      return CMD_SUCCESS;</a>
<a name="ln1439">    }</a>
<a name="ln1440">  return CMD_WARNING;</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">DEFUN (ip_rip_send_version_1,</a>
<a name="ln1444">       ip_rip_send_version_1_cmd,</a>
<a name="ln1445">       &quot;ip rip send version 1 2&quot;,</a>
<a name="ln1446">       IP_STR</a>
<a name="ln1447">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1448">       &quot;Advertisement transmission\n&quot;</a>
<a name="ln1449">       &quot;Version control\n&quot;</a>
<a name="ln1450">       &quot;RIP version 1\n&quot;</a>
<a name="ln1451">       &quot;RIP version 2\n&quot;)</a>
<a name="ln1452">{</a>
<a name="ln1453">  struct interface *ifp;</a>
<a name="ln1454">  struct rip_interface *ri;</a>
<a name="ln1455"> </a>
<a name="ln1456">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1457">  ri = ifp-&gt;info;</a>
<a name="ln1458"> </a>
<a name="ln1459">  /* Version 1 and 2. */</a>
<a name="ln1460">  ri-&gt;ri_send = RI_RIP_VERSION_1_AND_2;</a>
<a name="ln1461">  return CMD_SUCCESS;</a>
<a name="ln1462">}</a>
<a name="ln1463"> </a>
<a name="ln1464">DEFUN (ip_rip_send_version_2,</a>
<a name="ln1465">       ip_rip_send_version_2_cmd,</a>
<a name="ln1466">       &quot;ip rip send version 2 1&quot;,</a>
<a name="ln1467">       IP_STR</a>
<a name="ln1468">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1469">       &quot;Advertisement transmission\n&quot;</a>
<a name="ln1470">       &quot;Version control\n&quot;</a>
<a name="ln1471">       &quot;RIP version 2\n&quot;</a>
<a name="ln1472">       &quot;RIP version 1\n&quot;)</a>
<a name="ln1473">{</a>
<a name="ln1474">  struct interface *ifp;</a>
<a name="ln1475">  struct rip_interface *ri;</a>
<a name="ln1476"> </a>
<a name="ln1477">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1478">  ri = ifp-&gt;info;</a>
<a name="ln1479"> </a>
<a name="ln1480">  /* Version 1 and 2. */</a>
<a name="ln1481">  ri-&gt;ri_send = RI_RIP_VERSION_1_AND_2;</a>
<a name="ln1482">  return CMD_SUCCESS;</a>
<a name="ln1483">}</a>
<a name="ln1484"> </a>
<a name="ln1485">DEFUN (no_ip_rip_send_version,</a>
<a name="ln1486">       no_ip_rip_send_version_cmd,</a>
<a name="ln1487">       &quot;no ip rip send version&quot;,</a>
<a name="ln1488">       NO_STR</a>
<a name="ln1489">       IP_STR</a>
<a name="ln1490">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1491">       &quot;Advertisement transmission\n&quot;</a>
<a name="ln1492">       &quot;Version control\n&quot;)</a>
<a name="ln1493">{</a>
<a name="ln1494">  struct interface *ifp;</a>
<a name="ln1495">  struct rip_interface *ri;</a>
<a name="ln1496"> </a>
<a name="ln1497">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1498">  ri = ifp-&gt;info;</a>
<a name="ln1499"> </a>
<a name="ln1500">  ri-&gt;ri_send = RI_RIP_UNSPEC;</a>
<a name="ln1501">  return CMD_SUCCESS;</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">ALIAS (no_ip_rip_send_version,</a>
<a name="ln1505">       no_ip_rip_send_version_num_cmd,</a>
<a name="ln1506">       &quot;no ip rip send version (1|2)&quot;,</a>
<a name="ln1507">       NO_STR</a>
<a name="ln1508">       IP_STR</a>
<a name="ln1509">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1510">       &quot;Advertisement transmission\n&quot;</a>
<a name="ln1511">       &quot;Version control\n&quot;</a>
<a name="ln1512">       &quot;Version 1\n&quot;</a>
<a name="ln1513">       &quot;Version 2\n&quot;)</a>
<a name="ln1514"> </a>
<a name="ln1515">DEFUN (ip_rip_authentication_mode,</a>
<a name="ln1516">       ip_rip_authentication_mode_cmd,</a>
<a name="ln1517">       &quot;ip rip authentication mode (md5|text)&quot;,</a>
<a name="ln1518">       IP_STR</a>
<a name="ln1519">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1520">       &quot;Authentication control\n&quot;</a>
<a name="ln1521">       &quot;Authentication mode\n&quot;</a>
<a name="ln1522">       &quot;Keyed message digest\n&quot;</a>
<a name="ln1523">       &quot;Clear text authentication\n&quot;)</a>
<a name="ln1524">{</a>
<a name="ln1525">  struct interface *ifp;</a>
<a name="ln1526">  struct rip_interface *ri;</a>
<a name="ln1527">  int auth_type;</a>
<a name="ln1528"> </a>
<a name="ln1529">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1530">  ri = ifp-&gt;info;</a>
<a name="ln1531"> </a>
<a name="ln1532">  if ( (argc &lt; 1) || (argc &gt; 2) )</a>
<a name="ln1533">    {</a>
<a name="ln1534">      vty_out (vty, &quot;incorrect argument count%s&quot;, VTY_NEWLINE);</a>
<a name="ln1535">      return CMD_WARNING;</a>
<a name="ln1536">    }</a>
<a name="ln1537">    </a>
<a name="ln1538">  if (strncmp (&quot;md5&quot;, argv[0], strlen (argv[0])) == 0)</a>
<a name="ln1539">    auth_type = RIP_AUTH_MD5;</a>
<a name="ln1540">  else if (strncmp (&quot;text&quot;, argv[0], strlen (argv[0])) == 0)</a>
<a name="ln1541">    auth_type = RIP_AUTH_SIMPLE_PASSWORD;</a>
<a name="ln1542">  else</a>
<a name="ln1543">    {</a>
<a name="ln1544">      vty_out (vty, &quot;mode should be md5 or text%s&quot;, VTY_NEWLINE);</a>
<a name="ln1545">      return CMD_WARNING;</a>
<a name="ln1546">    }</a>
<a name="ln1547"> </a>
<a name="ln1548">  if (argc == 1)</a>
<a name="ln1549">    {</a>
<a name="ln1550">      ri-&gt;auth_type = auth_type;</a>
<a name="ln1551">      return CMD_SUCCESS;</a>
<a name="ln1552">    }</a>
<a name="ln1553"> </a>
<a name="ln1554">  if ( (argc == 2) &amp;&amp; (auth_type != RIP_AUTH_MD5) )</a>
<a name="ln1555">    {</a>
<a name="ln1556">      vty_out (vty, &quot;auth length argument only valid for md5%s&quot;, VTY_NEWLINE);</a>
<a name="ln1557">      return CMD_WARNING;</a>
<a name="ln1558">    }</a>
<a name="ln1559"> </a>
<a name="ln1560">  if (strncmp (&quot;r&quot;, argv[1], 1) == 0)</a>
<a name="ln1561">    ri-&gt;md5_auth_len = RIP_AUTH_MD5_SIZE;</a>
<a name="ln1562">  else if (strncmp (&quot;o&quot;, argv[1], 1) == 0)</a>
<a name="ln1563">    ri-&gt;md5_auth_len = RIP_AUTH_MD5_COMPAT_SIZE;</a>
<a name="ln1564">  else </a>
<a name="ln1565">    return CMD_WARNING;</a>
<a name="ln1566">    </a>
<a name="ln1567">  ri-&gt;auth_type = auth_type;</a>
<a name="ln1568">  </a>
<a name="ln1569">  return CMD_SUCCESS;</a>
<a name="ln1570">}</a>
<a name="ln1571"> </a>
<a name="ln1572">ALIAS (ip_rip_authentication_mode,</a>
<a name="ln1573">       ip_rip_authentication_mode_authlen_cmd,</a>
<a name="ln1574">       &quot;ip rip authentication mode (md5|text) auth-length (rfc|old-ripd)&quot;,</a>
<a name="ln1575">       IP_STR</a>
<a name="ln1576">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1577">       &quot;Authentication control\n&quot;</a>
<a name="ln1578">       &quot;Authentication mode\n&quot;</a>
<a name="ln1579">       &quot;Keyed message digest\n&quot;</a>
<a name="ln1580">       &quot;Clear text authentication\n&quot;</a>
<a name="ln1581">       &quot;MD5 authentication data length\n&quot;</a>
<a name="ln1582">       &quot;RFC compatible\n&quot;</a>
<a name="ln1583">       &quot;Old ripd compatible\n&quot;)</a>
<a name="ln1584"> </a>
<a name="ln1585">DEFUN (no_ip_rip_authentication_mode,</a>
<a name="ln1586">       no_ip_rip_authentication_mode_cmd,</a>
<a name="ln1587">       &quot;no ip rip authentication mode&quot;,</a>
<a name="ln1588">       NO_STR</a>
<a name="ln1589">       IP_STR</a>
<a name="ln1590">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1591">       &quot;Authentication control\n&quot;</a>
<a name="ln1592">       &quot;Authentication mode\n&quot;)</a>
<a name="ln1593">{</a>
<a name="ln1594">  struct interface *ifp;</a>
<a name="ln1595">  struct rip_interface *ri;</a>
<a name="ln1596"> </a>
<a name="ln1597">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1598">  ri = ifp-&gt;info;</a>
<a name="ln1599"> </a>
<a name="ln1600">  ri-&gt;auth_type = RIP_NO_AUTH;</a>
<a name="ln1601">  ri-&gt;md5_auth_len = RIP_AUTH_MD5_COMPAT_SIZE;</a>
<a name="ln1602"> </a>
<a name="ln1603">  return CMD_SUCCESS;</a>
<a name="ln1604">}</a>
<a name="ln1605"> </a>
<a name="ln1606">ALIAS (no_ip_rip_authentication_mode,</a>
<a name="ln1607">       no_ip_rip_authentication_mode_type_cmd,</a>
<a name="ln1608">       &quot;no ip rip authentication mode (md5|text)&quot;,</a>
<a name="ln1609">       NO_STR</a>
<a name="ln1610">       IP_STR</a>
<a name="ln1611">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1612">       &quot;Authentication control\n&quot;</a>
<a name="ln1613">       &quot;Authentication mode\n&quot;</a>
<a name="ln1614">       &quot;Keyed message digest\n&quot;</a>
<a name="ln1615">       &quot;Clear text authentication\n&quot;)</a>
<a name="ln1616"> </a>
<a name="ln1617">ALIAS (no_ip_rip_authentication_mode,</a>
<a name="ln1618">       no_ip_rip_authentication_mode_type_authlen_cmd,</a>
<a name="ln1619">       &quot;no ip rip authentication mode (md5|text) auth-length (rfc|old-ripd)&quot;,</a>
<a name="ln1620">       NO_STR</a>
<a name="ln1621">       IP_STR</a>
<a name="ln1622">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1623">       &quot;Authentication control\n&quot;</a>
<a name="ln1624">       &quot;Authentication mode\n&quot;</a>
<a name="ln1625">       &quot;Keyed message digest\n&quot;</a>
<a name="ln1626">       &quot;Clear text authentication\n&quot;</a>
<a name="ln1627">       &quot;MD5 authentication data length\n&quot;</a>
<a name="ln1628">       &quot;RFC compatible\n&quot;</a>
<a name="ln1629">       &quot;Old ripd compatible\n&quot;)</a>
<a name="ln1630"> </a>
<a name="ln1631">DEFUN (ip_rip_authentication_string,</a>
<a name="ln1632">       ip_rip_authentication_string_cmd,</a>
<a name="ln1633">       &quot;ip rip authentication string LINE&quot;,</a>
<a name="ln1634">       IP_STR</a>
<a name="ln1635">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1636">       &quot;Authentication control\n&quot;</a>
<a name="ln1637">       &quot;Authentication string\n&quot;</a>
<a name="ln1638">       &quot;Authentication string\n&quot;)</a>
<a name="ln1639">{</a>
<a name="ln1640">  struct interface *ifp;</a>
<a name="ln1641">  struct rip_interface *ri;</a>
<a name="ln1642"> </a>
<a name="ln1643">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1644">  ri = ifp-&gt;info;</a>
<a name="ln1645"> </a>
<a name="ln1646">  if (strlen (argv[0]) &gt; 16)</a>
<a name="ln1647">    {</a>
<a name="ln1648">      vty_out (vty, &quot;%% RIPv2 authentication string must be shorter than 16%s&quot;,</a>
<a name="ln1649">	       VTY_NEWLINE);</a>
<a name="ln1650">      return CMD_WARNING;</a>
<a name="ln1651">    }</a>
<a name="ln1652"> </a>
<a name="ln1653">  if (ri-&gt;key_chain)</a>
<a name="ln1654">    {</a>
<a name="ln1655">      vty_out (vty, &quot;%% key-chain configuration exists%s&quot;, VTY_NEWLINE);</a>
<a name="ln1656">      return CMD_WARNING;</a>
<a name="ln1657">    }</a>
<a name="ln1658"> </a>
<a name="ln1659">  if (ri-&gt;auth_str)</a>
<a name="ln1660">    free (ri-&gt;auth_str);</a>
<a name="ln1661"> </a>
<a name="ln1662">  ri-&gt;auth_str = strdup (argv[0]);</a>
<a name="ln1663"> </a>
<a name="ln1664">  return CMD_SUCCESS;</a>
<a name="ln1665">}</a>
<a name="ln1666"> </a>
<a name="ln1667">DEFUN (no_ip_rip_authentication_string,</a>
<a name="ln1668">       no_ip_rip_authentication_string_cmd,</a>
<a name="ln1669">       &quot;no ip rip authentication string&quot;,</a>
<a name="ln1670">       NO_STR</a>
<a name="ln1671">       IP_STR</a>
<a name="ln1672">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1673">       &quot;Authentication control\n&quot;</a>
<a name="ln1674">       &quot;Authentication string\n&quot;)</a>
<a name="ln1675">{</a>
<a name="ln1676">  struct interface *ifp;</a>
<a name="ln1677">  struct rip_interface *ri;</a>
<a name="ln1678"> </a>
<a name="ln1679">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1680">  ri = ifp-&gt;info;</a>
<a name="ln1681"> </a>
<a name="ln1682">  if (ri-&gt;auth_str)</a>
<a name="ln1683">    free (ri-&gt;auth_str);</a>
<a name="ln1684"> </a>
<a name="ln1685">  ri-&gt;auth_str = NULL;</a>
<a name="ln1686"> </a>
<a name="ln1687">  return CMD_SUCCESS;</a>
<a name="ln1688">}</a>
<a name="ln1689"> </a>
<a name="ln1690">ALIAS (no_ip_rip_authentication_string,</a>
<a name="ln1691">       no_ip_rip_authentication_string2_cmd,</a>
<a name="ln1692">       &quot;no ip rip authentication string LINE&quot;,</a>
<a name="ln1693">       NO_STR</a>
<a name="ln1694">       IP_STR</a>
<a name="ln1695">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1696">       &quot;Authentication control\n&quot;</a>
<a name="ln1697">       &quot;Authentication string\n&quot;</a>
<a name="ln1698">       &quot;Authentication string\n&quot;)</a>
<a name="ln1699"> </a>
<a name="ln1700">DEFUN (ip_rip_authentication_key_chain,</a>
<a name="ln1701">       ip_rip_authentication_key_chain_cmd,</a>
<a name="ln1702">       &quot;ip rip authentication key-chain LINE&quot;,</a>
<a name="ln1703">       IP_STR</a>
<a name="ln1704">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1705">       &quot;Authentication control\n&quot;</a>
<a name="ln1706">       &quot;Authentication key-chain\n&quot;</a>
<a name="ln1707">       &quot;name of key-chain\n&quot;)</a>
<a name="ln1708">{</a>
<a name="ln1709">  struct interface *ifp;</a>
<a name="ln1710">  struct rip_interface *ri;</a>
<a name="ln1711"> </a>
<a name="ln1712">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1713">  ri = ifp-&gt;info;</a>
<a name="ln1714"> </a>
<a name="ln1715">  if (ri-&gt;auth_str)</a>
<a name="ln1716">    {</a>
<a name="ln1717">      vty_out (vty, &quot;%% authentication string configuration exists%s&quot;,</a>
<a name="ln1718">	       VTY_NEWLINE);</a>
<a name="ln1719">      return CMD_WARNING;</a>
<a name="ln1720">    }</a>
<a name="ln1721"> </a>
<a name="ln1722">  if (ri-&gt;key_chain)</a>
<a name="ln1723">    free (ri-&gt;key_chain);</a>
<a name="ln1724"> </a>
<a name="ln1725">  ri-&gt;key_chain = strdup (argv[0]);</a>
<a name="ln1726"> </a>
<a name="ln1727">  return CMD_SUCCESS;</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">DEFUN (no_ip_rip_authentication_key_chain,</a>
<a name="ln1731">       no_ip_rip_authentication_key_chain_cmd,</a>
<a name="ln1732">       &quot;no ip rip authentication key-chain&quot;,</a>
<a name="ln1733">       NO_STR</a>
<a name="ln1734">       IP_STR</a>
<a name="ln1735">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1736">       &quot;Authentication control\n&quot;</a>
<a name="ln1737">       &quot;Authentication key-chain\n&quot;)</a>
<a name="ln1738">{</a>
<a name="ln1739">  struct interface *ifp;</a>
<a name="ln1740">  struct rip_interface *ri;</a>
<a name="ln1741"> </a>
<a name="ln1742">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1743">  ri = ifp-&gt;info;</a>
<a name="ln1744"> </a>
<a name="ln1745">  if (ri-&gt;key_chain)</a>
<a name="ln1746">    free (ri-&gt;key_chain);</a>
<a name="ln1747"> </a>
<a name="ln1748">  ri-&gt;key_chain = NULL;</a>
<a name="ln1749"> </a>
<a name="ln1750">  return CMD_SUCCESS;</a>
<a name="ln1751">}</a>
<a name="ln1752"> </a>
<a name="ln1753">ALIAS (no_ip_rip_authentication_key_chain,</a>
<a name="ln1754">       no_ip_rip_authentication_key_chain2_cmd,</a>
<a name="ln1755">       &quot;no ip rip authentication key-chain LINE&quot;,</a>
<a name="ln1756">       NO_STR</a>
<a name="ln1757">       IP_STR</a>
<a name="ln1758">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1759">       &quot;Authentication control\n&quot;</a>
<a name="ln1760">       &quot;Authentication key-chain\n&quot;</a>
<a name="ln1761">       &quot;name of key-chain\n&quot;)</a>
<a name="ln1762"> </a>
<a name="ln1763">/* CHANGED: ip rip split-horizon</a>
<a name="ln1764">   Cisco and Zebra's command is</a>
<a name="ln1765">   ip split-horizon</a>
<a name="ln1766"> */</a>
<a name="ln1767">DEFUN (ip_rip_split_horizon,</a>
<a name="ln1768">       ip_rip_split_horizon_cmd,</a>
<a name="ln1769">       &quot;ip rip split-horizon&quot;,</a>
<a name="ln1770">       IP_STR</a>
<a name="ln1771">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1772">       &quot;Perform split horizon\n&quot;)</a>
<a name="ln1773">{</a>
<a name="ln1774">  struct interface *ifp;</a>
<a name="ln1775">  struct rip_interface *ri;</a>
<a name="ln1776"> </a>
<a name="ln1777">  ifp = vty-&gt;index;</a>
<a name="ln1778">  ri = ifp-&gt;info;</a>
<a name="ln1779"> </a>
<a name="ln1780">  ri-&gt;split_horizon = RIP_SPLIT_HORIZON;</a>
<a name="ln1781">  return CMD_SUCCESS;</a>
<a name="ln1782">}</a>
<a name="ln1783"> </a>
<a name="ln1784">DEFUN (ip_rip_split_horizon_poisoned_reverse,</a>
<a name="ln1785">       ip_rip_split_horizon_poisoned_reverse_cmd,</a>
<a name="ln1786">       &quot;ip rip split-horizon poisoned-reverse&quot;,</a>
<a name="ln1787">       IP_STR</a>
<a name="ln1788">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1789">       &quot;Perform split horizon\n&quot;</a>
<a name="ln1790">       &quot;With poisoned-reverse\n&quot;)</a>
<a name="ln1791">{</a>
<a name="ln1792">  struct interface *ifp;</a>
<a name="ln1793">  struct rip_interface *ri;</a>
<a name="ln1794"> </a>
<a name="ln1795">  ifp = vty-&gt;index;</a>
<a name="ln1796">  ri = ifp-&gt;info;</a>
<a name="ln1797"> </a>
<a name="ln1798">  ri-&gt;split_horizon = RIP_SPLIT_HORIZON_POISONED_REVERSE;</a>
<a name="ln1799">  return CMD_SUCCESS;</a>
<a name="ln1800">}</a>
<a name="ln1801"> </a>
<a name="ln1802">/* CHANGED: no ip rip split-horizon</a>
<a name="ln1803">   Cisco and Zebra's command is</a>
<a name="ln1804">   no ip split-horizon</a>
<a name="ln1805"> */</a>
<a name="ln1806">DEFUN (no_ip_rip_split_horizon,</a>
<a name="ln1807">       no_ip_rip_split_horizon_cmd,</a>
<a name="ln1808">       &quot;no ip rip split-horizon&quot;,</a>
<a name="ln1809">       NO_STR</a>
<a name="ln1810">       IP_STR</a>
<a name="ln1811">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1812">       &quot;Perform split horizon\n&quot;)</a>
<a name="ln1813">{</a>
<a name="ln1814">  struct interface *ifp;</a>
<a name="ln1815">  struct rip_interface *ri;</a>
<a name="ln1816"> </a>
<a name="ln1817">  ifp = vty-&gt;index;</a>
<a name="ln1818">  ri = ifp-&gt;info;</a>
<a name="ln1819"> </a>
<a name="ln1820">  ri-&gt;split_horizon = RIP_NO_SPLIT_HORIZON;</a>
<a name="ln1821">  return CMD_SUCCESS;</a>
<a name="ln1822">}</a>
<a name="ln1823"> </a>
<a name="ln1824">DEFUN (no_ip_rip_split_horizon_poisoned_reverse,</a>
<a name="ln1825">       no_ip_rip_split_horizon_poisoned_reverse_cmd,</a>
<a name="ln1826">       &quot;no ip rip split-horizon poisoned-reverse&quot;,</a>
<a name="ln1827">       NO_STR</a>
<a name="ln1828">       IP_STR</a>
<a name="ln1829">       &quot;Routing Information Protocol\n&quot;</a>
<a name="ln1830">       &quot;Perform split horizon\n&quot;</a>
<a name="ln1831">       &quot;With poisoned-reverse\n&quot;)</a>
<a name="ln1832">{</a>
<a name="ln1833">  struct interface *ifp;</a>
<a name="ln1834">  struct rip_interface *ri;</a>
<a name="ln1835"> </a>
<a name="ln1836">  ifp = vty-&gt;index;</a>
<a name="ln1837">  ri = ifp-&gt;info;</a>
<a name="ln1838"> </a>
<a name="ln1839">  switch( ri-&gt;split_horizon )</a>
<a name="ln1840">  {</a>
<a name="ln1841">	case RIP_SPLIT_HORIZON_POISONED_REVERSE:</a>
<a name="ln1842">		ri-&gt;split_horizon = RIP_SPLIT_HORIZON;</a>
<a name="ln1843">	default:</a>
<a name="ln1844">		break;</a>
<a name="ln1845">  }</a>
<a name="ln1846"> </a>
<a name="ln1847">  return CMD_SUCCESS;</a>
<a name="ln1848">}</a>
<a name="ln1849"> </a>
<a name="ln1850">DEFUN (rip_passive_interface,</a>
<a name="ln1851">       rip_passive_interface_cmd,</a>
<a name="ln1852">       &quot;passive-interface (IFNAME|default)&quot;,</a>
<a name="ln1853">       &quot;Suppress routing updates on an interface\n&quot;</a>
<a name="ln1854">       &quot;Interface name\n&quot;</a>
<a name="ln1855">       &quot;default for all interfaces\n&quot;)</a>
<a name="ln1856">{</a>
<a name="ln1857">  const char *ifname = argv[0];</a>
<a name="ln1858"> </a>
<a name="ln1859">  if (!strcmp(ifname,&quot;default&quot;)) {</a>
<a name="ln1860">    passive_default = 1;</a>
<a name="ln1861">    rip_passive_nondefault_clean();</a>
<a name="ln1862">    return CMD_SUCCESS;</a>
<a name="ln1863">  }</a>
<a name="ln1864">  if (passive_default)</a>
<a name="ln1865">    return rip_passive_nondefault_unset (vty, ifname);</a>
<a name="ln1866">  else</a>
<a name="ln1867">    return rip_passive_nondefault_set (vty, ifname);</a>
<a name="ln1868">}</a>
<a name="ln1869"> </a>
<a name="ln1870">DEFUN (no_rip_passive_interface,</a>
<a name="ln1871">       no_rip_passive_interface_cmd,</a>
<a name="ln1872">       &quot;no passive-interface (IFNAME|default)&quot;,</a>
<a name="ln1873">       NO_STR</a>
<a name="ln1874">       &quot;Suppress routing updates on an interface\n&quot;</a>
<a name="ln1875">       &quot;Interface name\n&quot;</a>
<a name="ln1876">       &quot;default for all interfaces\n&quot;)</a>
<a name="ln1877">{</a>
<a name="ln1878">  const char *ifname = argv[0];</a>
<a name="ln1879"> </a>
<a name="ln1880">  if (!strcmp(ifname,&quot;default&quot;)) {</a>
<a name="ln1881">    passive_default = 0;</a>
<a name="ln1882">    rip_passive_nondefault_clean();</a>
<a name="ln1883">    return CMD_SUCCESS;</a>
<a name="ln1884">  }</a>
<a name="ln1885">  if (passive_default)</a>
<a name="ln1886">    return rip_passive_nondefault_set (vty, ifname);</a>
<a name="ln1887">  else</a>
<a name="ln1888">    return rip_passive_nondefault_unset (vty, ifname);</a>
<a name="ln1889">}</a>
<a name="ln1890"> </a>
<a name="ln1891">/* Write rip configuration of each interface. */</a>
<a name="ln1892">static int</a>
<a name="ln1893">rip_interface_config_write (struct vty *vty)</a>
<a name="ln1894">{</a>
<a name="ln1895">  struct listnode *node;</a>
<a name="ln1896">  struct interface *ifp;</a>
<a name="ln1897"> </a>
<a name="ln1898">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln1899">    {</a>
<a name="ln1900">      struct rip_interface *ri;</a>
<a name="ln1901"> </a>
<a name="ln1902">      ri = ifp-&gt;info;</a>
<a name="ln1903"> </a>
<a name="ln1904">      /* Do not display the interface if there is no</a>
<a name="ln1905">       * configuration about it.</a>
<a name="ln1906">       **/</a>
<a name="ln1907">      if ((!ifp-&gt;desc)                                     &amp;&amp;</a>
<a name="ln1908">          (ri-&gt;split_horizon == ri-&gt;split_horizon_default) &amp;&amp;</a>
<a name="ln1909">          (ri-&gt;ri_send == RI_RIP_UNSPEC)                   &amp;&amp;</a>
<a name="ln1910">          (ri-&gt;ri_receive == RI_RIP_UNSPEC)                &amp;&amp;</a>
<a name="ln1911">          (ri-&gt;auth_type != RIP_AUTH_MD5)                  &amp;&amp;</a>
<a name="ln1912">          (ri-&gt;md5_auth_len != RIP_AUTH_MD5_SIZE)          &amp;&amp;</a>
<a name="ln1913">          (!ri-&gt;auth_str)                                  &amp;&amp;</a>
<a name="ln1914">          (!ri-&gt;key_chain)                                 )</a>
<a name="ln1915">        continue;</a>
<a name="ln1916"> </a>
<a name="ln1917">      vty_out (vty, &quot;interface %s%s&quot;, ifp-&gt;name,</a>
<a name="ln1918">	       VTY_NEWLINE);</a>
<a name="ln1919"> </a>
<a name="ln1920">      if (ifp-&gt;desc)</a>
<a name="ln1921">	vty_out (vty, &quot; description %s%s&quot;, ifp-&gt;desc,</a>
<a name="ln1922">		 VTY_NEWLINE);</a>
<a name="ln1923"> </a>
<a name="ln1924">      /* Split horizon. */</a>
<a name="ln1925">      if (ri-&gt;split_horizon != ri-&gt;split_horizon_default)</a>
<a name="ln1926">	{</a>
<a name="ln1927">          switch (ri-&gt;split_horizon) {</a>
<a name="ln1928">          case RIP_SPLIT_HORIZON:</a>
<a name="ln1929">            vty_out (vty, &quot; ip rip split-horizon%s&quot;, VTY_NEWLINE);</a>
<a name="ln1930">            break;</a>
<a name="ln1931">          case RIP_SPLIT_HORIZON_POISONED_REVERSE:</a>
<a name="ln1932">            vty_out (vty, &quot; ip rip split-horizon poisoned-reverse%s&quot;,</a>
<a name="ln1933">                          VTY_NEWLINE);</a>
<a name="ln1934">            break;</a>
<a name="ln1935">          case RIP_NO_SPLIT_HORIZON:</a>
<a name="ln1936">          default:</a>
<a name="ln1937">            vty_out (vty, &quot; no ip rip split-horizon%s&quot;, VTY_NEWLINE);</a>
<a name="ln1938">            break;</a>
<a name="ln1939">          }</a>
<a name="ln1940">	}</a>
<a name="ln1941"> </a>
<a name="ln1942">      /* RIP version setting. */</a>
<a name="ln1943">      if (ri-&gt;ri_send != RI_RIP_UNSPEC)</a>
<a name="ln1944">	vty_out (vty, &quot; ip rip send version %s%s&quot;,</a>
<a name="ln1945">		 lookup (ri_version_msg, ri-&gt;ri_send),</a>
<a name="ln1946">		 VTY_NEWLINE);</a>
<a name="ln1947"> </a>
<a name="ln1948">      if (ri-&gt;ri_receive != RI_RIP_UNSPEC)</a>
<a name="ln1949">	vty_out (vty, &quot; ip rip receive version %s%s&quot;,</a>
<a name="ln1950">		 lookup (ri_version_msg, ri-&gt;ri_receive),</a>
<a name="ln1951">		 VTY_NEWLINE);</a>
<a name="ln1952"> </a>
<a name="ln1953">      /* RIP authentication. */</a>
<a name="ln1954">      if (ri-&gt;auth_type == RIP_AUTH_SIMPLE_PASSWORD)</a>
<a name="ln1955">	vty_out (vty, &quot; ip rip authentication mode text%s&quot;, VTY_NEWLINE);</a>
<a name="ln1956"> </a>
<a name="ln1957">      if (ri-&gt;auth_type == RIP_AUTH_MD5)</a>
<a name="ln1958">        {</a>
<a name="ln1959">          vty_out (vty, &quot; ip rip authentication mode md5&quot;);</a>
<a name="ln1960">          if (ri-&gt;md5_auth_len == RIP_AUTH_MD5_COMPAT_SIZE)</a>
<a name="ln1961">            vty_out (vty, &quot; auth-length old-ripd&quot;);</a>
<a name="ln1962">          else </a>
<a name="ln1963">            vty_out (vty, &quot; auth-length rfc&quot;);</a>
<a name="ln1964">          vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1965">        }</a>
<a name="ln1966"> </a>
<a name="ln1967">      if (ri-&gt;auth_str)</a>
<a name="ln1968">	vty_out (vty, &quot; ip rip authentication string %s%s&quot;,</a>
<a name="ln1969">		 ri-&gt;auth_str, VTY_NEWLINE);</a>
<a name="ln1970"> </a>
<a name="ln1971">      if (ri-&gt;key_chain)</a>
<a name="ln1972">	vty_out (vty, &quot; ip rip authentication key-chain %s%s&quot;,</a>
<a name="ln1973">		 ri-&gt;key_chain, VTY_NEWLINE);</a>
<a name="ln1974"> </a>
<a name="ln1975">      vty_out (vty, &quot;!%s&quot;, VTY_NEWLINE);</a>
<a name="ln1976">    }</a>
<a name="ln1977">  return 0;</a>
<a name="ln1978">}</a>
<a name="ln1979"> </a>
<a name="ln1980">int</a>
<a name="ln1981">config_write_rip_network (struct vty *vty, int config_mode)</a>
<a name="ln1982">{</a>
<a name="ln1983">  unsigned int i;</a>
<a name="ln1984">  char *ifname;</a>
<a name="ln1985">  struct route_node *node;</a>
<a name="ln1986"> </a>
<a name="ln1987">  /* Network type RIP enable interface statement. */</a>
<a name="ln1988">  for (node = route_top (rip_enable_network); node; node = route_next (node))</a>
<a name="ln1989">    if (node-&gt;info)</a>
<a name="ln1990">      vty_out (vty, &quot;%s%s/%d%s&quot;, </a>
<a name="ln1991">	       config_mode ? &quot; network &quot; : &quot;    &quot;,</a>
<a name="ln1992">	       inet_ntoa (node-&gt;p.u.prefix4),</a>
<a name="ln1993">	       node-&gt;p.prefixlen,</a>
<a name="ln1994">	       VTY_NEWLINE);</a>
<a name="ln1995"> </a>
<a name="ln1996">  /* Interface name RIP enable statement. */</a>
<a name="ln1997">  for (i = 0; i &lt; vector_active (rip_enable_interface); i++)</a>
<a name="ln1998">    if ((ifname = vector_slot (rip_enable_interface, i)) != NULL)</a>
<a name="ln1999">      vty_out (vty, &quot;%s%s%s&quot;,</a>
<a name="ln2000">	       config_mode ? &quot; network &quot; : &quot;    &quot;,</a>
<a name="ln2001">	       ifname,</a>
<a name="ln2002">	       VTY_NEWLINE);</a>
<a name="ln2003"> </a>
<a name="ln2004">  /* RIP neighbors listing. */</a>
<a name="ln2005">  for (node = route_top (rip-&gt;neighbor); node; node = route_next (node))</a>
<a name="ln2006">    if (node-&gt;info)</a>
<a name="ln2007">      vty_out (vty, &quot;%s%s%s&quot;, </a>
<a name="ln2008">	       config_mode ? &quot; neighbor &quot; : &quot;    &quot;,</a>
<a name="ln2009">	       inet_ntoa (node-&gt;p.u.prefix4),</a>
<a name="ln2010">	       VTY_NEWLINE);</a>
<a name="ln2011"> </a>
<a name="ln2012">  /* RIP passive interface listing. */</a>
<a name="ln2013">  if (config_mode) {</a>
<a name="ln2014">    if (passive_default)</a>
<a name="ln2015">      vty_out (vty, &quot; passive-interface default%s&quot;, VTY_NEWLINE);</a>
<a name="ln2016">    for (i = 0; i &lt; vector_active (Vrip_passive_nondefault); i++)</a>
<a name="ln2017">      if ((ifname = vector_slot (Vrip_passive_nondefault, i)) != NULL)</a>
<a name="ln2018">	vty_out (vty, &quot; %spassive-interface %s%s&quot;,</a>
<a name="ln2019">		 (passive_default ? &quot;no &quot; : &quot;&quot;), ifname, VTY_NEWLINE);</a>
<a name="ln2020">  }</a>
<a name="ln2021"> </a>
<a name="ln2022">  return 0;</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025">static struct cmd_node interface_node =</a>
<a name="ln2026">{</a>
<a name="ln2027">  INTERFACE_NODE,</a>
<a name="ln2028">  &quot;%s(config-if)# &quot;,</a>
<a name="ln2029">  1,</a>
<a name="ln2030">};</a>
<a name="ln2031"> </a>
<a name="ln2032">/* Called when interface structure allocated. */</a>
<a name="ln2033">static int</a>
<a name="ln2034">rip_interface_new_hook (struct interface *ifp)</a>
<a name="ln2035">{</a>
<a name="ln2036">  ifp-&gt;info = rip_interface_new ();</a>
<a name="ln2037">  return 0;</a>
<a name="ln2038">}</a>
<a name="ln2039"> </a>
<a name="ln2040">/* Called when interface structure deleted. */</a>
<a name="ln2041">static int</a>
<a name="ln2042">rip_interface_delete_hook (struct interface *ifp)</a>
<a name="ln2043">{</a>
<a name="ln2044">  XFREE (MTYPE_RIP_INTERFACE, ifp-&gt;info);</a>
<a name="ln2045">  ifp-&gt;info = NULL;</a>
<a name="ln2046">  return 0;</a>
<a name="ln2047">}</a>
<a name="ln2048"> </a>
<a name="ln2049">/* Allocate and initialize interface vector. */</a>
<a name="ln2050">void</a>
<a name="ln2051">rip_if_init (void)</a>
<a name="ln2052">{</a>
<a name="ln2053">  /* Default initial size of interface vector. */</a>
<a name="ln2054">  if_add_hook (IF_NEW_HOOK, rip_interface_new_hook);</a>
<a name="ln2055">  if_add_hook (IF_DELETE_HOOK, rip_interface_delete_hook);</a>
<a name="ln2056">  </a>
<a name="ln2057">  /* RIP network init. */</a>
<a name="ln2058">  rip_enable_interface = vector_init (1);</a>
<a name="ln2059">  rip_enable_network = route_table_init ();</a>
<a name="ln2060"> </a>
<a name="ln2061">  /* RIP passive interface. */</a>
<a name="ln2062">  Vrip_passive_nondefault = vector_init (1);</a>
<a name="ln2063"> </a>
<a name="ln2064">  /* Install interface node. */</a>
<a name="ln2065">  install_node (&amp;interface_node, rip_interface_config_write);</a>
<a name="ln2066"> </a>
<a name="ln2067">  /* Install commands. */</a>
<a name="ln2068">  install_element (CONFIG_NODE, &amp;interface_cmd);</a>
<a name="ln2069">  install_element (CONFIG_NODE, &amp;no_interface_cmd);</a>
<a name="ln2070">  install_default (INTERFACE_NODE);</a>
<a name="ln2071">  install_element (INTERFACE_NODE, &amp;interface_desc_cmd);</a>
<a name="ln2072">  install_element (INTERFACE_NODE, &amp;no_interface_desc_cmd);</a>
<a name="ln2073">  install_element (RIP_NODE, &amp;rip_network_cmd);</a>
<a name="ln2074">  install_element (RIP_NODE, &amp;no_rip_network_cmd);</a>
<a name="ln2075">  install_element (RIP_NODE, &amp;rip_neighbor_cmd);</a>
<a name="ln2076">  install_element (RIP_NODE, &amp;no_rip_neighbor_cmd);</a>
<a name="ln2077"> </a>
<a name="ln2078">  install_element (RIP_NODE, &amp;rip_passive_interface_cmd);</a>
<a name="ln2079">  install_element (RIP_NODE, &amp;no_rip_passive_interface_cmd);</a>
<a name="ln2080"> </a>
<a name="ln2081">  install_element (INTERFACE_NODE, &amp;ip_rip_send_version_cmd);</a>
<a name="ln2082">  install_element (INTERFACE_NODE, &amp;ip_rip_send_version_1_cmd);</a>
<a name="ln2083">  install_element (INTERFACE_NODE, &amp;ip_rip_send_version_2_cmd);</a>
<a name="ln2084">  install_element (INTERFACE_NODE, &amp;no_ip_rip_send_version_cmd);</a>
<a name="ln2085">  install_element (INTERFACE_NODE, &amp;no_ip_rip_send_version_num_cmd);</a>
<a name="ln2086"> </a>
<a name="ln2087">  install_element (INTERFACE_NODE, &amp;ip_rip_receive_version_cmd);</a>
<a name="ln2088">  install_element (INTERFACE_NODE, &amp;ip_rip_receive_version_1_cmd);</a>
<a name="ln2089">  install_element (INTERFACE_NODE, &amp;ip_rip_receive_version_2_cmd);</a>
<a name="ln2090">  install_element (INTERFACE_NODE, &amp;no_ip_rip_receive_version_cmd);</a>
<a name="ln2091">  install_element (INTERFACE_NODE, &amp;no_ip_rip_receive_version_num_cmd);</a>
<a name="ln2092"> </a>
<a name="ln2093">  install_element (INTERFACE_NODE, &amp;ip_rip_authentication_mode_cmd);</a>
<a name="ln2094">  install_element (INTERFACE_NODE, &amp;ip_rip_authentication_mode_authlen_cmd);</a>
<a name="ln2095">  install_element (INTERFACE_NODE, &amp;no_ip_rip_authentication_mode_cmd);</a>
<a name="ln2096">  install_element (INTERFACE_NODE, &amp;no_ip_rip_authentication_mode_type_cmd);</a>
<a name="ln2097">  install_element (INTERFACE_NODE, &amp;no_ip_rip_authentication_mode_type_authlen_cmd);</a>
<a name="ln2098"> </a>
<a name="ln2099">  install_element (INTERFACE_NODE, &amp;ip_rip_authentication_key_chain_cmd);</a>
<a name="ln2100">  install_element (INTERFACE_NODE, &amp;no_ip_rip_authentication_key_chain_cmd);</a>
<a name="ln2101">  install_element (INTERFACE_NODE, &amp;no_ip_rip_authentication_key_chain2_cmd);</a>
<a name="ln2102"> </a>
<a name="ln2103">  install_element (INTERFACE_NODE, &amp;ip_rip_authentication_string_cmd);</a>
<a name="ln2104">  install_element (INTERFACE_NODE, &amp;no_ip_rip_authentication_string_cmd);</a>
<a name="ln2105">  install_element (INTERFACE_NODE, &amp;no_ip_rip_authentication_string2_cmd);</a>
<a name="ln2106"> </a>
<a name="ln2107">  install_element (INTERFACE_NODE, &amp;ip_rip_split_horizon_cmd);</a>
<a name="ln2108">  install_element (INTERFACE_NODE, &amp;ip_rip_split_horizon_poisoned_reverse_cmd);</a>
<a name="ln2109">  install_element (INTERFACE_NODE, &amp;no_ip_rip_split_horizon_cmd);</a>
<a name="ln2110">  install_element (INTERFACE_NODE, &amp;no_ip_rip_split_horizon_poisoned_reverse_cmd);</a>
<a name="ln2111">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="745"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v711/" target="_blank">V711</a> It is dangerous to create a local variable within a loop with a same name as a variable controlling this loop.</p></div>
<div class="balloon" rel="1554"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (argc == 2).</p></div>
<div class="balloon" rel="1362"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v524/" target="_blank">V524</a> It is odd that the body of 'ip_rip_receive_version_2' function is fully equivalent to the body of 'ip_rip_receive_version_1' function.</p></div>
<div class="balloon" rel="1464"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v524/" target="_blank">V524</a> It is odd that the body of 'ip_rip_send_version_2' function is fully equivalent to the body of 'ip_rip_send_version_1' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
