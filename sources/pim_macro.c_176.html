
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_macro.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;log.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;pim_macro.h&quot;</a>
<a name="ln28">#include &quot;pimd.h&quot;</a>
<a name="ln29">#include &quot;pim_str.h&quot;</a>
<a name="ln30">#include &quot;pim_iface.h&quot;</a>
<a name="ln31">#include &quot;pim_ifchannel.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#define PIM_IFP_I_am_DR(pim_ifp) ((pim_ifp)-&gt;pim_dr_addr.s_addr == (pim_ifp)-&gt;primary_address.s_addr)</a>
<a name="ln34"> </a>
<a name="ln35">/*</a>
<a name="ln36">  DownstreamJPState(S,G,I) is the per-interface state machine for</a>
<a name="ln37">  receiving (S,G) Join/Prune messages.</a>
<a name="ln38"> </a>
<a name="ln39">  DownstreamJPState(S,G,I) is either Join or Prune-Pending ?</a>
<a name="ln40">*/</a>
<a name="ln41">static int downstream_jpstate_isjoined(const struct pim_ifchannel *ch)</a>
<a name="ln42">{</a>
<a name="ln43">  return ch-&gt;ifjoin_state != PIM_IFJOIN_NOINFO;</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">/*</a>
<a name="ln47">  The clause &quot;local_receiver_include(S,G,I)&quot; is true if the IGMP/MLD</a>
<a name="ln48">  module or other local membership mechanism has determined that local</a>
<a name="ln49">  members on interface I desire to receive traffic sent specifically</a>
<a name="ln50">  by S to G.</a>
<a name="ln51">*/</a>
<a name="ln52">static int local_receiver_include(const struct pim_ifchannel *ch)</a>
<a name="ln53">{</a>
<a name="ln54">  /* local_receiver_include(S,G,I) ? */</a>
<a name="ln55">  return ch-&gt;local_ifmembership == PIM_IFMEMBERSHIP_INCLUDE;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">/*</a>
<a name="ln59">  RFC 4601: 4.1.6.  State Summarization Macros</a>
<a name="ln60"> </a>
<a name="ln61">   The set &quot;joins(S,G)&quot; is the set of all interfaces on which the</a>
<a name="ln62">   router has received (S,G) Joins:</a>
<a name="ln63"> </a>
<a name="ln64">   joins(S,G) =</a>
<a name="ln65">       { all interfaces I such that</a>
<a name="ln66">         DownstreamJPState(S,G,I) is either Join or Prune-Pending }</a>
<a name="ln67"> </a>
<a name="ln68">  DownstreamJPState(S,G,I) is either Join or Prune-Pending ?</a>
<a name="ln69">*/</a>
<a name="ln70">int pim_macro_chisin_joins(const struct pim_ifchannel *ch)</a>
<a name="ln71">{</a>
<a name="ln72">  return downstream_jpstate_isjoined(ch);</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">/*</a>
<a name="ln76">  RFC 4601: 4.6.5.  Assert State Macros</a>
<a name="ln77"> </a>
<a name="ln78">   The set &quot;lost_assert(S,G)&quot; is the set of all interfaces on which the</a>
<a name="ln79">   router has received (S,G) joins but has lost an (S,G) assert.</a>
<a name="ln80"> </a>
<a name="ln81">   lost_assert(S,G) =</a>
<a name="ln82">       { all interfaces I such that</a>
<a name="ln83">         lost_assert(S,G,I) == TRUE }</a>
<a name="ln84"> </a>
<a name="ln85">     bool lost_assert(S,G,I) {</a>
<a name="ln86">       if ( RPF_interface(S) == I ) {</a>
<a name="ln87">          return FALSE</a>
<a name="ln88">       } else {</a>
<a name="ln89">          return ( AssertWinner(S,G,I) != NULL AND</a>
<a name="ln90">                   AssertWinner(S,G,I) != me  AND</a>
<a name="ln91">                   (AssertWinnerMetric(S,G,I) is better</a>
<a name="ln92">                      than spt_assert_metric(S,I) )</a>
<a name="ln93">       }</a>
<a name="ln94">     }</a>
<a name="ln95"> </a>
<a name="ln96">  AssertWinner(S,G,I) is the IP source address of the Assert(S,G)</a>
<a name="ln97">  packet that won an Assert.</a>
<a name="ln98">*/</a>
<a name="ln99">int pim_macro_ch_lost_assert(const struct pim_ifchannel *ch)</a>
<a name="ln100">{</a>
<a name="ln101">  struct interface *ifp;</a>
<a name="ln102">  struct pim_interface *pim_ifp;</a>
<a name="ln103">  struct pim_assert_metric spt_assert_metric;</a>
<a name="ln104"> </a>
<a name="ln105">  ifp = ch-&gt;interface;</a>
<a name="ln106">  if (!ifp) {</a>
<a name="ln107">    char src_str[100];</a>
<a name="ln108">    char grp_str[100];</a>
<a name="ln109">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln110">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln111">    zlog_warn(&quot;%s: (S,G)=(%s,%s): null interface&quot;,</a>
<a name="ln112">	      __PRETTY_FUNCTION__,</a>
<a name="ln113">	      src_str, grp_str);</a>
<a name="ln114">    return 0; /* false */</a>
<a name="ln115">  }</a>
<a name="ln116"> </a>
<a name="ln117">  /* RPF_interface(S) == I ? */</a>
<a name="ln118">  if (ch-&gt;upstream-&gt;rpf.source_nexthop.interface == ifp)</a>
<a name="ln119">    return 0; /* false */</a>
<a name="ln120"> </a>
<a name="ln121">  pim_ifp = ifp-&gt;info;</a>
<a name="ln122">  if (!pim_ifp) {</a>
<a name="ln123">    char src_str[100];</a>
<a name="ln124">    char grp_str[100];</a>
<a name="ln125">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln126">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln127">    zlog_warn(&quot;%s: (S,G)=(%s,%s): multicast not enabled on interface %s&quot;,</a>
<a name="ln128">	      __PRETTY_FUNCTION__,</a>
<a name="ln129">	      src_str, grp_str, ifp-&gt;name);</a>
<a name="ln130">    return 0; /* false */</a>
<a name="ln131">  }</a>
<a name="ln132"> </a>
<a name="ln133">  if (PIM_INADDR_IS_ANY(ch-&gt;ifassert_winner))</a>
<a name="ln134">    return 0; /* false */</a>
<a name="ln135"> </a>
<a name="ln136">  /* AssertWinner(S,G,I) == me ? */</a>
<a name="ln137">  if (ch-&gt;ifassert_winner.s_addr == pim_ifp-&gt;primary_address.s_addr)</a>
<a name="ln138">    return 0; /* false */</a>
<a name="ln139"> </a>
<a name="ln140">  spt_assert_metric = pim_macro_spt_assert_metric(&amp;ch-&gt;upstream-&gt;rpf,</a>
<a name="ln141">						  pim_ifp-&gt;primary_address);</a>
<a name="ln142"> </a>
<a name="ln143">  return pim_assert_metric_better(&amp;ch-&gt;ifassert_winner_metric,</a>
<a name="ln144">				  &amp;spt_assert_metric);</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">/*</a>
<a name="ln148">  RFC 4601: 4.1.6.  State Summarization Macros</a>
<a name="ln149"> </a>
<a name="ln150">   pim_include(S,G) =</a>
<a name="ln151">       { all interfaces I such that:</a>
<a name="ln152">         ( (I_am_DR( I ) AND lost_assert(S,G,I) == FALSE )</a>
<a name="ln153">           OR AssertWinner(S,G,I) == me )</a>
<a name="ln154">          AND  local_receiver_include(S,G,I) }</a>
<a name="ln155"> </a>
<a name="ln156">   AssertWinner(S,G,I) is the IP source address of the Assert(S,G)</a>
<a name="ln157">   packet that won an Assert.</a>
<a name="ln158">*/</a>
<a name="ln159">int pim_macro_chisin_pim_include(const struct pim_ifchannel *ch)</a>
<a name="ln160">{</a>
<a name="ln161">  struct pim_interface *pim_ifp = ch-&gt;interface-&gt;info;</a>
<a name="ln162"> </a>
<a name="ln163">  if (!pim_ifp) {</a>
<a name="ln164">    char src_str[100];</a>
<a name="ln165">    char grp_str[100];</a>
<a name="ln166">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln167">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln168">    zlog_warn(&quot;%s: (S,G)=(%s,%s): multicast not enabled on interface %s&quot;,</a>
<a name="ln169">	      __PRETTY_FUNCTION__,</a>
<a name="ln170">	      src_str, grp_str, ch-&gt;interface-&gt;name);</a>
<a name="ln171">    return 0; /* false */</a>
<a name="ln172">  }</a>
<a name="ln173"> </a>
<a name="ln174">  /* local_receiver_include(S,G,I) ? */</a>
<a name="ln175">  if (!local_receiver_include(ch))</a>
<a name="ln176">    return 0; /* false */</a>
<a name="ln177">    </a>
<a name="ln178">  /* OR AssertWinner(S,G,I) == me ? */</a>
<a name="ln179">  if (ch-&gt;ifassert_winner.s_addr == pim_ifp-&gt;primary_address.s_addr)</a>
<a name="ln180">    return 1; /* true */</a>
<a name="ln181">    </a>
<a name="ln182">  return (</a>
<a name="ln183">	  /* I_am_DR( I ) ? */</a>
<a name="ln184">	  PIM_IFP_I_am_DR(pim_ifp)</a>
<a name="ln185">	  &amp;&amp;</a>
<a name="ln186">	  /* lost_assert(S,G,I) == FALSE ? */</a>
<a name="ln187">	  (!pim_macro_ch_lost_assert(ch))</a>
<a name="ln188">	  );</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">int pim_macro_chisin_joins_or_include(const struct pim_ifchannel *ch)</a>
<a name="ln192">{</a>
<a name="ln193">  if (pim_macro_chisin_joins(ch))</a>
<a name="ln194">    return 1; /* true */</a>
<a name="ln195"> </a>
<a name="ln196">  return pim_macro_chisin_pim_include(ch);</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">/*</a>
<a name="ln200">  RFC 4601: 4.6.1.  (S,G) Assert Message State Machine</a>
<a name="ln201"> </a>
<a name="ln202">  CouldAssert(S,G,I) =</a>
<a name="ln203">  SPTbit(S,G)==TRUE</a>
<a name="ln204">  AND (RPF_interface(S) != I)</a>
<a name="ln205">  AND (I in ( ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )</a>
<a name="ln206">                 (+) ( pim_include(*,G) (-) pim_exclude(S,G) )</a>
<a name="ln207">                 (-) lost_assert(*,G)</a>
<a name="ln208">                 (+) joins(S,G) (+) pim_include(S,G) ) )</a>
<a name="ln209"> </a>
<a name="ln210">  CouldAssert(S,G,I) is true for downstream interfaces that would be in</a>
<a name="ln211">  the inherited_olist(S,G) if (S,G) assert information was not taken</a>
<a name="ln212">  into account.</a>
<a name="ln213"> </a>
<a name="ln214">  CouldAssert(S,G,I) may be affected by changes in the following:</a>
<a name="ln215"> </a>
<a name="ln216">  pim_ifp-&gt;primary_address</a>
<a name="ln217">  pim_ifp-&gt;pim_dr_addr</a>
<a name="ln218">  ch-&gt;ifassert_winner_metric</a>
<a name="ln219">  ch-&gt;ifassert_winner</a>
<a name="ln220">  ch-&gt;local_ifmembership</a>
<a name="ln221">  ch-&gt;ifjoin_state</a>
<a name="ln222">  ch-&gt;upstream-&gt;rpf.source_nexthop.mrib_metric_preference</a>
<a name="ln223">  ch-&gt;upstream-&gt;rpf.source_nexthop.mrib_route_metric</a>
<a name="ln224">  ch-&gt;upstream-&gt;rpf.source_nexthop.interface</a>
<a name="ln225">*/</a>
<a name="ln226">int pim_macro_ch_could_assert_eval(const struct pim_ifchannel *ch)</a>
<a name="ln227">{</a>
<a name="ln228">  struct interface *ifp;</a>
<a name="ln229"> </a>
<a name="ln230">  /* SPTbit(S,G) is always true for PIM-SSM-Only Routers */</a>
<a name="ln231"> </a>
<a name="ln232">  ifp = ch-&gt;interface;</a>
<a name="ln233">  if (!ifp) {</a>
<a name="ln234">    char src_str[100];</a>
<a name="ln235">    char grp_str[100];</a>
<a name="ln236">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln237">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln238">    zlog_warn(&quot;%s: (S,G)=(%s,%s): null interface&quot;,</a>
<a name="ln239">	      __PRETTY_FUNCTION__,</a>
<a name="ln240">	      src_str, grp_str);</a>
<a name="ln241">    return 0; /* false */</a>
<a name="ln242">  }</a>
<a name="ln243"> </a>
<a name="ln244">  /* RPF_interface(S) != I ? */</a>
<a name="ln245">  if (ch-&gt;upstream-&gt;rpf.source_nexthop.interface == ifp)</a>
<a name="ln246">    return 0; /* false */</a>
<a name="ln247"> </a>
<a name="ln248">  /* I in joins(S,G) (+) pim_include(S,G) ? */</a>
<a name="ln249">  return pim_macro_chisin_joins_or_include(ch);</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">/*</a>
<a name="ln253">  RFC 4601: 4.6.3.  Assert Metrics</a>
<a name="ln254"> </a>
<a name="ln255">   spt_assert_metric(S,I) gives the assert metric we use if we're</a>
<a name="ln256">   sending an assert based on active (S,G) forwarding state:</a>
<a name="ln257"> </a>
<a name="ln258">    assert_metric</a>
<a name="ln259">    spt_assert_metric(S,I) {</a>
<a name="ln260">      return {0,MRIB.pref(S),MRIB.metric(S),my_ip_address(I)}</a>
<a name="ln261">    }</a>
<a name="ln262">*/</a>
<a name="ln263">struct pim_assert_metric pim_macro_spt_assert_metric(const struct pim_rpf *rpf,</a>
<a name="ln264">						     struct in_addr ifaddr)</a>
<a name="ln265">{</a>
<a name="ln266">  struct pim_assert_metric metric;</a>
<a name="ln267"> </a>
<a name="ln268">  metric.rpt_bit_flag      = 0;</a>
<a name="ln269">  metric.metric_preference = rpf-&gt;source_nexthop.mrib_metric_preference;</a>
<a name="ln270">  metric.route_metric      = rpf-&gt;source_nexthop.mrib_route_metric;</a>
<a name="ln271">  metric.ip_address        = ifaddr;</a>
<a name="ln272"> </a>
<a name="ln273">  return metric;</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">/*</a>
<a name="ln277">  RFC 4601: 4.6.3.  Assert Metrics</a>
<a name="ln278"> </a>
<a name="ln279">   An assert metric for (S,G) to include in (or compare against) an</a>
<a name="ln280">   Assert message sent on interface I should be computed using the</a>
<a name="ln281">   following pseudocode:</a>
<a name="ln282"> </a>
<a name="ln283">  assert_metric  my_assert_metric(S,G,I) {</a>
<a name="ln284">    if( CouldAssert(S,G,I) == TRUE ) {</a>
<a name="ln285">      return spt_assert_metric(S,I)</a>
<a name="ln286">    } else if( CouldAssert(*,G,I) == TRUE ) {</a>
<a name="ln287">      return rpt_assert_metric(G,I)</a>
<a name="ln288">    } else {</a>
<a name="ln289">      return infinite_assert_metric()</a>
<a name="ln290">    }</a>
<a name="ln291">  }</a>
<a name="ln292">*/</a>
<a name="ln293">struct pim_assert_metric pim_macro_ch_my_assert_metric_eval(const struct pim_ifchannel *ch)</a>
<a name="ln294">{</a>
<a name="ln295">  struct pim_interface *pim_ifp;</a>
<a name="ln296"> </a>
<a name="ln297">  pim_ifp = ch-&gt;interface-&gt;info;</a>
<a name="ln298"> </a>
<a name="ln299">  if (pim_ifp) {</a>
<a name="ln300">    if (PIM_IF_FLAG_TEST_COULD_ASSERT(ch-&gt;flags)) {</a>
<a name="ln301">      return pim_macro_spt_assert_metric(&amp;ch-&gt;upstream-&gt;rpf, pim_ifp-&gt;primary_address);</a>
<a name="ln302">    }</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  return qpim_infinite_assert_metric;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">/*</a>
<a name="ln309">  RFC 4601 4.2.  Data Packet Forwarding Rules</a>
<a name="ln310">  RFC 4601 4.8.2.  PIM-SSM-Only Routers</a>
<a name="ln311">  </a>
<a name="ln312">  Macro:</a>
<a name="ln313">  inherited_olist(S,G) =</a>
<a name="ln314">    joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)</a>
<a name="ln315">*/</a>
<a name="ln316">static int pim_macro_chisin_inherited_olist(const struct pim_ifchannel *ch)</a>
<a name="ln317">{</a>
<a name="ln318">  if (pim_macro_ch_lost_assert(ch))</a>
<a name="ln319">    return 0; /* false */</a>
<a name="ln320"> </a>
<a name="ln321">  return pim_macro_chisin_joins_or_include(ch);</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">/*</a>
<a name="ln325">  RFC 4601 4.2.  Data Packet Forwarding Rules</a>
<a name="ln326">  RFC 4601 4.8.2.  PIM-SSM-Only Routers</a>
<a name="ln327"> </a>
<a name="ln328">  Additionally, the Packet forwarding rules of Section 4.2 can be</a>
<a name="ln329">  simplified in a PIM-SSM-only router:</a>
<a name="ln330">  </a>
<a name="ln331">  iif is the incoming interface of the packet.</a>
<a name="ln332">  oiflist = NULL</a>
<a name="ln333">  if (iif == RPF_interface(S) AND UpstreamJPState(S,G) == Joined) {</a>
<a name="ln334">    oiflist = inherited_olist(S,G)</a>
<a name="ln335">  } else if (iif is in inherited_olist(S,G)) {</a>
<a name="ln336">    send Assert(S,G) on iif</a>
<a name="ln337">  }</a>
<a name="ln338">  oiflist = oiflist (-) iif</a>
<a name="ln339">  forward packet on all interfaces in oiflist</a>
<a name="ln340">  </a>
<a name="ln341">  Macro:</a>
<a name="ln342">  inherited_olist(S,G) =</a>
<a name="ln343">    joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)</a>
<a name="ln344"> </a>
<a name="ln345">  Note:</a>
<a name="ln346">  - The following test is performed as response to WRONGVIF kernel</a>
<a name="ln347">    upcall:</a>
<a name="ln348">    if (iif is in inherited_olist(S,G)) {</a>
<a name="ln349">      send Assert(S,G) on iif</a>
<a name="ln350">    }</a>
<a name="ln351">    See pim_mroute.c mroute_msg().</a>
<a name="ln352">*/</a>
<a name="ln353">int pim_macro_chisin_oiflist(const struct pim_ifchannel *ch)</a>
<a name="ln354">{</a>
<a name="ln355">  if (ch-&gt;upstream-&gt;join_state != PIM_UPSTREAM_JOINED) {</a>
<a name="ln356">    /* oiflist is NULL */</a>
<a name="ln357">    return 0; /* false */</a>
<a name="ln358">  }</a>
<a name="ln359"> </a>
<a name="ln360">  /* oiflist = oiflist (-) iif */</a>
<a name="ln361">  if (ch-&gt;interface == ch-&gt;upstream-&gt;rpf.source_nexthop.interface)</a>
<a name="ln362">    return 0; /* false */</a>
<a name="ln363"> </a>
<a name="ln364">  return pim_macro_chisin_inherited_olist(ch);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">/*</a>
<a name="ln368">  RFC 4601: 4.6.1.  (S,G) Assert Message State Machine</a>
<a name="ln369"> </a>
<a name="ln370">  AssertTrackingDesired(S,G,I) =</a>
<a name="ln371">  (I in ( ( joins(*,*,RP(G)) (+) joins(*,G) (-) prunes(S,G,rpt) )</a>
<a name="ln372">	(+) ( pim_include(*,G) (-) pim_exclude(S,G) )</a>
<a name="ln373">	(-) lost_assert(*,G)</a>
<a name="ln374">	(+) joins(S,G) ) )</a>
<a name="ln375">     OR (local_receiver_include(S,G,I) == TRUE</a>
<a name="ln376">	 AND (I_am_DR(I) OR (AssertWinner(S,G,I) == me)))</a>
<a name="ln377">     OR ((RPF_interface(S) == I) AND (JoinDesired(S,G) == TRUE))</a>
<a name="ln378">     OR ((RPF_interface(RP(G)) == I) AND (JoinDesired(*,G) == TRUE)</a>
<a name="ln379">	 AND (SPTbit(S,G) == FALSE))</a>
<a name="ln380"> </a>
<a name="ln381">  AssertTrackingDesired(S,G,I) is true on any interface in which an</a>
<a name="ln382">  (S,G) assert might affect our behavior.</a>
<a name="ln383">*/</a>
<a name="ln384">int pim_macro_assert_tracking_desired_eval(const struct pim_ifchannel *ch)</a>
<a name="ln385">{</a>
<a name="ln386">  struct pim_interface *pim_ifp;</a>
<a name="ln387">  struct interface *ifp;</a>
<a name="ln388"> </a>
<a name="ln389">  ifp = ch-&gt;interface;</a>
<a name="ln390">  if (!ifp) {</a>
<a name="ln391">    char src_str[100];</a>
<a name="ln392">    char grp_str[100];</a>
<a name="ln393">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln394">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln395">    zlog_warn(&quot;%s: (S,G)=(%s,%s): null interface&quot;,</a>
<a name="ln396">	      __PRETTY_FUNCTION__,</a>
<a name="ln397">	      src_str, grp_str);</a>
<a name="ln398">    return 0; /* false */</a>
<a name="ln399">  }</a>
<a name="ln400"> </a>
<a name="ln401">  pim_ifp = ifp-&gt;info;</a>
<a name="ln402">  if (!pim_ifp) {</a>
<a name="ln403">    char src_str[100];</a>
<a name="ln404">    char grp_str[100];</a>
<a name="ln405">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln406">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln407">    zlog_warn(&quot;%s: (S,G)=(%s,%s): multicast not enabled on interface %s&quot;,</a>
<a name="ln408">	      __PRETTY_FUNCTION__,</a>
<a name="ln409">	      src_str, grp_str, ch-&gt;interface-&gt;name);</a>
<a name="ln410">    return 0; /* false */</a>
<a name="ln411">  }</a>
<a name="ln412"> </a>
<a name="ln413">  /* I in joins(S,G) ? */</a>
<a name="ln414">  if (pim_macro_chisin_joins(ch))</a>
<a name="ln415">    return 1; /* true */</a>
<a name="ln416"> </a>
<a name="ln417">  /* local_receiver_include(S,G,I) ? */</a>
<a name="ln418">  if (local_receiver_include(ch)) {</a>
<a name="ln419">    /* I_am_DR(I) ? */</a>
<a name="ln420">    if (PIM_IFP_I_am_DR(pim_ifp))</a>
<a name="ln421">      return 1; /* true */</a>
<a name="ln422"> </a>
<a name="ln423">    /* AssertWinner(S,G,I) == me ? */</a>
<a name="ln424">    if (ch-&gt;ifassert_winner.s_addr == pim_ifp-&gt;primary_address.s_addr)</a>
<a name="ln425">      return 1; /* true */</a>
<a name="ln426">  }</a>
<a name="ln427"> </a>
<a name="ln428">  /* RPF_interface(S) == I ? */</a>
<a name="ln429">  if (ch-&gt;upstream-&gt;rpf.source_nexthop.interface == ifp) {</a>
<a name="ln430">    /* JoinDesired(S,G) ? */</a>
<a name="ln431">    if (PIM_UPSTREAM_FLAG_TEST_DR_JOIN_DESIRED(ch-&gt;upstream-&gt;flags))</a>
<a name="ln432">      return 1; /* true */</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435">  return 0; /* false */</a>
<a name="ln436">}</a>
<a name="ln437"> </a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
