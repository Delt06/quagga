
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_neighbor.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;log.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;pimd.h&quot;</a>
<a name="ln30">#include &quot;pim_neighbor.h&quot;</a>
<a name="ln31">#include &quot;pim_time.h&quot;</a>
<a name="ln32">#include &quot;pim_str.h&quot;</a>
<a name="ln33">#include &quot;pim_iface.h&quot;</a>
<a name="ln34">#include &quot;pim_pim.h&quot;</a>
<a name="ln35">#include &quot;pim_upstream.h&quot;</a>
<a name="ln36">#include &quot;pim_ifchannel.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">static void dr_election_by_addr(struct interface *ifp)</a>
<a name="ln39">{</a>
<a name="ln40">  struct pim_interface *pim_ifp;</a>
<a name="ln41">  struct listnode      *node;</a>
<a name="ln42">  struct pim_neighbor  *neigh;</a>
<a name="ln43"> </a>
<a name="ln44">  pim_ifp = ifp-&gt;info;</a>
<a name="ln45">  zassert(pim_ifp);</a>
<a name="ln46"> </a>
<a name="ln47">  pim_ifp-&gt;pim_dr_addr = pim_ifp-&gt;primary_address;</a>
<a name="ln48"> </a>
<a name="ln49">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln50">    zlog_debug(&quot;%s: on interface %s&quot;,</a>
<a name="ln51">	       __PRETTY_FUNCTION__,</a>
<a name="ln52">	       ifp-&gt;name);</a>
<a name="ln53">  }</a>
<a name="ln54"> </a>
<a name="ln55">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_neighbor_list, node, neigh)) {</a>
<a name="ln56">    if (ntohl(neigh-&gt;source_addr.s_addr) &gt; ntohl(pim_ifp-&gt;pim_dr_addr.s_addr)) {</a>
<a name="ln57">      pim_ifp-&gt;pim_dr_addr = neigh-&gt;source_addr;</a>
<a name="ln58">    }</a>
<a name="ln59">  }</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">static void dr_election_by_pri(struct interface *ifp)</a>
<a name="ln63">{</a>
<a name="ln64">  struct pim_interface *pim_ifp;</a>
<a name="ln65">  struct listnode      *node;</a>
<a name="ln66">  struct pim_neighbor  *neigh;</a>
<a name="ln67">  uint32_t              dr_pri;</a>
<a name="ln68"> </a>
<a name="ln69">  pim_ifp = ifp-&gt;info;</a>
<a name="ln70">  zassert(pim_ifp);</a>
<a name="ln71"> </a>
<a name="ln72">  pim_ifp-&gt;pim_dr_addr = pim_ifp-&gt;primary_address;</a>
<a name="ln73">  dr_pri = pim_ifp-&gt;pim_dr_priority;</a>
<a name="ln74"> </a>
<a name="ln75">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln76">    zlog_debug(&quot;%s: dr pri %u on interface %s&quot;,</a>
<a name="ln77">	       __PRETTY_FUNCTION__,</a>
<a name="ln78">	       dr_pri, ifp-&gt;name);</a>
<a name="ln79">  }</a>
<a name="ln80"> </a>
<a name="ln81">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_neighbor_list, node, neigh)) {</a>
<a name="ln82">    if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln83">      zlog_info(&quot;%s: neigh pri %u addr %x if dr addr %x&quot;,</a>
<a name="ln84">		__PRETTY_FUNCTION__,</a>
<a name="ln85">		neigh-&gt;dr_priority,</a>
<a name="ln86">		ntohl(neigh-&gt;source_addr.s_addr),</a>
<a name="ln87">		ntohl(pim_ifp-&gt;pim_dr_addr.s_addr));</a>
<a name="ln88">    }</a>
<a name="ln89">    if (</a>
<a name="ln90">	(neigh-&gt;dr_priority &gt; dr_pri) ||</a>
<a name="ln91">	(</a>
<a name="ln92">	 (neigh-&gt;dr_priority == dr_pri) &amp;&amp;</a>
<a name="ln93">	 (ntohl(neigh-&gt;source_addr.s_addr) &gt; ntohl(pim_ifp-&gt;pim_dr_addr.s_addr))</a>
<a name="ln94">	 )</a>
<a name="ln95">	) {</a>
<a name="ln96">      pim_ifp-&gt;pim_dr_addr = neigh-&gt;source_addr;</a>
<a name="ln97">      dr_pri               = neigh-&gt;dr_priority;</a>
<a name="ln98">    }</a>
<a name="ln99">  }</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">/*</a>
<a name="ln103">  RFC 4601: 4.3.2.  DR Election</a>
<a name="ln104"> </a>
<a name="ln105">  A router's idea of the current DR on an interface can change when a</a>
<a name="ln106">  PIM Hello message is received, when a neighbor times out, or when a</a>
<a name="ln107">  router's own DR Priority changes.</a>
<a name="ln108"> */</a>
<a name="ln109">int pim_if_dr_election(struct interface *ifp)</a>
<a name="ln110">{</a>
<a name="ln111">  struct pim_interface *pim_ifp = ifp-&gt;info;</a>
<a name="ln112">  struct in_addr old_dr_addr;</a>
<a name="ln113"> </a>
<a name="ln114">  ++pim_ifp-&gt;pim_dr_election_count;</a>
<a name="ln115"> </a>
<a name="ln116">  old_dr_addr = pim_ifp-&gt;pim_dr_addr;</a>
<a name="ln117"> </a>
<a name="ln118">  if (pim_ifp-&gt;pim_dr_num_nondrpri_neighbors) {</a>
<a name="ln119">    dr_election_by_addr(ifp);</a>
<a name="ln120">  }</a>
<a name="ln121">  else {</a>
<a name="ln122">    dr_election_by_pri(ifp);</a>
<a name="ln123">  }</a>
<a name="ln124"> </a>
<a name="ln125">  /* DR changed ? */</a>
<a name="ln126">  if (old_dr_addr.s_addr != pim_ifp-&gt;pim_dr_addr.s_addr) {</a>
<a name="ln127"> </a>
<a name="ln128">    if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln129">      char dr_old_str[100];</a>
<a name="ln130">      char dr_new_str[100];</a>
<a name="ln131">      pim_inet4_dump(&quot;&lt;old_dr?&gt;&quot;, old_dr_addr, dr_old_str, sizeof(dr_old_str));</a>
<a name="ln132">      pim_inet4_dump(&quot;&lt;new_dr?&gt;&quot;, pim_ifp-&gt;pim_dr_addr, dr_new_str, sizeof(dr_new_str));</a>
<a name="ln133">      zlog_debug(&quot;%s: DR was %s now is %s on interface %s&quot;,</a>
<a name="ln134">		 __PRETTY_FUNCTION__,</a>
<a name="ln135">		 dr_old_str, dr_new_str, ifp-&gt;name);</a>
<a name="ln136">    }</a>
<a name="ln137"> </a>
<a name="ln138">    pim_ifp-&gt;pim_dr_election_last = pim_time_monotonic_sec(); /* timestamp */</a>
<a name="ln139">    ++pim_ifp-&gt;pim_dr_election_changes; </a>
<a name="ln140">    pim_if_update_join_desired(pim_ifp);</a>
<a name="ln141">    pim_if_update_could_assert(ifp);</a>
<a name="ln142">    pim_if_update_assert_tracking_desired(ifp);</a>
<a name="ln143">    return 1;</a>
<a name="ln144">  }</a>
<a name="ln145"> </a>
<a name="ln146">  return 0;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">static void update_dr_priority(struct pim_neighbor *neigh,</a>
<a name="ln150">			       pim_hello_options hello_options,</a>
<a name="ln151">			       uint32_t dr_priority)</a>
<a name="ln152">{</a>
<a name="ln153">  pim_hello_options will_set_pri; /* boolean */</a>
<a name="ln154">  pim_hello_options bit_flip;     /* boolean */</a>
<a name="ln155">  pim_hello_options pri_change;   /* boolean */</a>
<a name="ln156"> </a>
<a name="ln157">  will_set_pri = PIM_OPTION_IS_SET(hello_options,</a>
<a name="ln158">				   PIM_OPTION_MASK_DR_PRIORITY);</a>
<a name="ln159"> </a>
<a name="ln160">  bit_flip =</a>
<a name="ln161">    (</a>
<a name="ln162">     will_set_pri !=</a>
<a name="ln163">     PIM_OPTION_IS_SET(neigh-&gt;hello_options, PIM_OPTION_MASK_DR_PRIORITY)</a>
<a name="ln164">     );</a>
<a name="ln165"> </a>
<a name="ln166">  if (bit_flip) {</a>
<a name="ln167">    struct pim_interface *pim_ifp = neigh-&gt;interface-&gt;info;</a>
<a name="ln168"> </a>
<a name="ln169">    /* update num. of neighbors without dr_pri */</a>
<a name="ln170"> </a>
<a name="ln171">    if (will_set_pri) {</a>
<a name="ln172">      --pim_ifp-&gt;pim_dr_num_nondrpri_neighbors; </a>
<a name="ln173">    }</a>
<a name="ln174">    else {</a>
<a name="ln175">      ++pim_ifp-&gt;pim_dr_num_nondrpri_neighbors; </a>
<a name="ln176">    }</a>
<a name="ln177">  }</a>
<a name="ln178"> </a>
<a name="ln179">  pri_change = </a>
<a name="ln180">    (</a>
<a name="ln181">     bit_flip</a>
<a name="ln182">     ||</a>
<a name="ln183">     (neigh-&gt;dr_priority != dr_priority)</a>
<a name="ln184">     );</a>
<a name="ln185"> </a>
<a name="ln186">  if (will_set_pri) {</a>
<a name="ln187">    neigh-&gt;dr_priority = dr_priority;</a>
<a name="ln188">  }</a>
<a name="ln189">  else {</a>
<a name="ln190">    neigh-&gt;dr_priority = 0; /* cosmetic unset */</a>
<a name="ln191">  }</a>
<a name="ln192"> </a>
<a name="ln193">  if (pri_change) {</a>
<a name="ln194">    /*</a>
<a name="ln195">      RFC 4601: 4.3.2.  DR Election</a>
<a name="ln196">      </a>
<a name="ln197">      A router's idea of the current DR on an interface can change when a</a>
<a name="ln198">      PIM Hello message is received, when a neighbor times out, or when a</a>
<a name="ln199">      router's own DR Priority changes.</a>
<a name="ln200">    */</a>
<a name="ln201">    pim_if_dr_election(neigh-&gt;interface); // router's own DR Priority changes</a>
<a name="ln202">  }</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">static int on_neighbor_timer(struct thread *t)</a>
<a name="ln206">{</a>
<a name="ln207">  struct pim_neighbor *neigh;</a>
<a name="ln208">  struct interface *ifp;</a>
<a name="ln209">  char msg[100];</a>
<a name="ln210"> </a>
<a name="ln211">  zassert(t);</a>
<a name="ln212">  neigh = THREAD_ARG(t);</a>
<a name="ln213">  zassert(neigh);</a>
<a name="ln214"> </a>
<a name="ln215">  ifp = neigh-&gt;interface;</a>
<a name="ln216"> </a>
<a name="ln217">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln218">    char src_str[100];</a>
<a name="ln219">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, neigh-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln220">    zlog_debug(&quot;Expired %d sec holdtime for neighbor %s on interface %s&quot;,</a>
<a name="ln221">	       neigh-&gt;holdtime, src_str, ifp-&gt;name);</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  neigh-&gt;t_expire_timer = 0;</a>
<a name="ln225"> </a>
<a name="ln226">  snprintf(msg, sizeof(msg), &quot;%d-sec holdtime expired&quot;, neigh-&gt;holdtime);</a>
<a name="ln227">  pim_neighbor_delete(ifp, neigh, msg);</a>
<a name="ln228"> </a>
<a name="ln229">  /*</a>
<a name="ln230">    RFC 4601: 4.3.2.  DR Election</a>
<a name="ln231">    </a>
<a name="ln232">    A router's idea of the current DR on an interface can change when a</a>
<a name="ln233">    PIM Hello message is received, when a neighbor times out, or when a</a>
<a name="ln234">    router's own DR Priority changes.</a>
<a name="ln235">  */</a>
<a name="ln236">  pim_if_dr_election(ifp); // neighbor times out</a>
<a name="ln237"> </a>
<a name="ln238">  return 0;</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">static void neighbor_timer_off(struct pim_neighbor *neigh)</a>
<a name="ln242">{</a>
<a name="ln243">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln244">    if (neigh-&gt;t_expire_timer) {</a>
<a name="ln245">      char src_str[100];</a>
<a name="ln246">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, neigh-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln247">      zlog_debug(&quot;%s: cancelling timer for neighbor %s on %s&quot;,</a>
<a name="ln248">		 __PRETTY_FUNCTION__,</a>
<a name="ln249">		 src_str, neigh-&gt;interface-&gt;name);</a>
<a name="ln250">    }</a>
<a name="ln251">  }</a>
<a name="ln252">  THREAD_OFF(neigh-&gt;t_expire_timer);</a>
<a name="ln253">  zassert(!neigh-&gt;t_expire_timer);</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">void pim_neighbor_timer_reset(struct pim_neighbor *neigh, uint16_t holdtime)</a>
<a name="ln257">{</a>
<a name="ln258">  neigh-&gt;holdtime = holdtime;</a>
<a name="ln259"> </a>
<a name="ln260">  neighbor_timer_off(neigh);</a>
<a name="ln261"> </a>
<a name="ln262">  /*</a>
<a name="ln263">    0xFFFF is request for no holdtime</a>
<a name="ln264">   */</a>
<a name="ln265">  if (neigh-&gt;holdtime == 0xFFFF) {</a>
<a name="ln266">    return;</a>
<a name="ln267">  }</a>
<a name="ln268"> </a>
<a name="ln269">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln270">    char src_str[100];</a>
<a name="ln271">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, neigh-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln272">    zlog_debug(&quot;%s: starting %u sec timer for neighbor %s on %s&quot;,</a>
<a name="ln273">	       __PRETTY_FUNCTION__,</a>
<a name="ln274">	       neigh-&gt;holdtime, src_str, neigh-&gt;interface-&gt;name);</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  THREAD_TIMER_ON(master, neigh-&gt;t_expire_timer,</a>
<a name="ln278">		  on_neighbor_timer,</a>
<a name="ln279">		  neigh, neigh-&gt;holdtime);</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">static struct pim_neighbor *pim_neighbor_new(struct interface *ifp,</a>
<a name="ln283">					     struct in_addr source_addr,</a>
<a name="ln284">					     pim_hello_options hello_options,</a>
<a name="ln285">					     uint16_t holdtime,</a>
<a name="ln286">					     uint16_t propagation_delay,</a>
<a name="ln287">					     uint16_t override_interval,</a>
<a name="ln288">					     uint32_t dr_priority,</a>
<a name="ln289">					     uint32_t generation_id,</a>
<a name="ln290">					     struct list *addr_list)</a>
<a name="ln291">{</a>
<a name="ln292">  struct pim_interface *pim_ifp;</a>
<a name="ln293">  struct pim_neighbor *neigh;</a>
<a name="ln294">  char src_str[100];</a>
<a name="ln295"> </a>
<a name="ln296">  zassert(ifp);</a>
<a name="ln297">  pim_ifp = ifp-&gt;info;</a>
<a name="ln298">  zassert(pim_ifp);</a>
<a name="ln299"> </a>
<a name="ln300">  neigh = XMALLOC(MTYPE_PIM_NEIGHBOR, sizeof(*neigh));</a>
<a name="ln301">  if (!neigh) {</a>
<a name="ln302">    zlog_err(&quot;%s: PIM XMALLOC(%zu) failure&quot;,</a>
<a name="ln303">	     __PRETTY_FUNCTION__, sizeof(*neigh));</a>
<a name="ln304">    return 0;</a>
<a name="ln305">  }</a>
<a name="ln306"> </a>
<a name="ln307">  neigh-&gt;creation               = pim_time_monotonic_sec();</a>
<a name="ln308">  neigh-&gt;source_addr            = source_addr;</a>
<a name="ln309">  neigh-&gt;hello_options          = hello_options;</a>
<a name="ln310">  neigh-&gt;propagation_delay_msec = propagation_delay;</a>
<a name="ln311">  neigh-&gt;override_interval_msec = override_interval;</a>
<a name="ln312">  neigh-&gt;dr_priority            = dr_priority;</a>
<a name="ln313">  neigh-&gt;generation_id          = generation_id;</a>
<a name="ln314">  neigh-&gt;prefix_list            = addr_list;</a>
<a name="ln315">  neigh-&gt;t_expire_timer         = 0;</a>
<a name="ln316">  neigh-&gt;interface              = ifp;</a>
<a name="ln317"> </a>
<a name="ln318">  pim_neighbor_timer_reset(neigh, holdtime);</a>
<a name="ln319"> </a>
<a name="ln320">  pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, src_str, sizeof(src_str));</a>
<a name="ln321"> </a>
<a name="ln322">  if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln323">    zlog_debug(&quot;%s: creating PIM neighbor %s on interface %s&quot;,</a>
<a name="ln324">	       __PRETTY_FUNCTION__,</a>
<a name="ln325">	       src_str, ifp-&gt;name);</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  zlog_info(&quot;PIM NEIGHBOR UP: neighbor %s on interface %s&quot;,</a>
<a name="ln329">	    src_str, ifp-&gt;name);</a>
<a name="ln330"> </a>
<a name="ln331">  if (neigh-&gt;propagation_delay_msec &gt; pim_ifp-&gt;pim_neighbors_highest_propagation_delay_msec) {</a>
<a name="ln332">    pim_ifp-&gt;pim_neighbors_highest_propagation_delay_msec = neigh-&gt;propagation_delay_msec;</a>
<a name="ln333">  }</a>
<a name="ln334">  if (neigh-&gt;override_interval_msec &gt; pim_ifp-&gt;pim_neighbors_highest_override_interval_msec) {</a>
<a name="ln335">    pim_ifp-&gt;pim_neighbors_highest_override_interval_msec = neigh-&gt;override_interval_msec;</a>
<a name="ln336">  }</a>
<a name="ln337"> </a>
<a name="ln338">  if (!PIM_OPTION_IS_SET(neigh-&gt;hello_options,</a>
<a name="ln339">			 PIM_OPTION_MASK_LAN_PRUNE_DELAY)) {</a>
<a name="ln340">    /* update num. of neighbors without hello option lan_delay */</a>
<a name="ln341">    ++pim_ifp-&gt;pim_number_of_nonlandelay_neighbors; </a>
<a name="ln342">  }</a>
<a name="ln343"> </a>
<a name="ln344">  if (!PIM_OPTION_IS_SET(neigh-&gt;hello_options,</a>
<a name="ln345">			 PIM_OPTION_MASK_DR_PRIORITY)) {</a>
<a name="ln346">    /* update num. of neighbors without hello option dr_pri */</a>
<a name="ln347">    ++pim_ifp-&gt;pim_dr_num_nondrpri_neighbors; </a>
<a name="ln348">  }</a>
<a name="ln349"> </a>
<a name="ln350">  return neigh;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">static void delete_prefix_list(struct pim_neighbor *neigh)</a>
<a name="ln354">{</a>
<a name="ln355">  if (neigh-&gt;prefix_list) {</a>
<a name="ln356"> </a>
<a name="ln357">#ifdef DUMP_PREFIX_LIST</a>
<a name="ln358">    struct listnode *p_node;</a>
<a name="ln359">    struct prefix *p;</a>
<a name="ln360">    char addr_str[10];</a>
<a name="ln361">    int list_size = neigh-&gt;prefix_list ? (int) listcount(neigh-&gt;prefix_list) : -1;</a>
<a name="ln362">    int i = 0;</a>
<a name="ln363">    for (ALL_LIST_ELEMENTS_RO(neigh-&gt;prefix_list, p_node, p)) {</a>
<a name="ln364">      pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, p-&gt;u.prefix4, addr_str, sizeof(addr_str));</a>
<a name="ln365">      zlog_debug(&quot;%s: DUMP_PREFIX_LIST neigh=%x prefix_list=%x prefix=%x addr=%s [%d/%d]&quot;,</a>
<a name="ln366">		 __PRETTY_FUNCTION__,</a>
<a name="ln367">		 (unsigned) neigh, (unsigned) neigh-&gt;prefix_list, (unsigned) p,</a>
<a name="ln368">		 addr_str, i, list_size);</a>
<a name="ln369">      ++i;</a>
<a name="ln370">    }</a>
<a name="ln371">#endif</a>
<a name="ln372"> </a>
<a name="ln373">    list_delete(neigh-&gt;prefix_list);</a>
<a name="ln374">    neigh-&gt;prefix_list = 0;</a>
<a name="ln375">  }</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">void pim_neighbor_free(struct pim_neighbor *neigh)</a>
<a name="ln379">{</a>
<a name="ln380">  zassert(!neigh-&gt;t_expire_timer);</a>
<a name="ln381"> </a>
<a name="ln382">  delete_prefix_list(neigh);</a>
<a name="ln383"> </a>
<a name="ln384">  XFREE(MTYPE_PIM_NEIGHBOR, neigh);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">struct pim_neighbor *pim_neighbor_find(struct interface *ifp,</a>
<a name="ln388">				       struct in_addr source_addr)</a>
<a name="ln389">{</a>
<a name="ln390">  struct pim_interface *pim_ifp;</a>
<a name="ln391">  struct listnode      *node;</a>
<a name="ln392">  struct pim_neighbor  *neigh;</a>
<a name="ln393"> </a>
<a name="ln394">  pim_ifp = ifp-&gt;info;</a>
<a name="ln395">  zassert(pim_ifp);</a>
<a name="ln396"> </a>
<a name="ln397">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_neighbor_list, node, neigh)) {</a>
<a name="ln398">    if (source_addr.s_addr == neigh-&gt;source_addr.s_addr) {</a>
<a name="ln399">      return neigh;</a>
<a name="ln400">    }</a>
<a name="ln401">  }</a>
<a name="ln402"> </a>
<a name="ln403">  return 0;</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">struct pim_neighbor *pim_neighbor_add(struct interface *ifp,</a>
<a name="ln407">				      struct in_addr source_addr,</a>
<a name="ln408">				      pim_hello_options hello_options,</a>
<a name="ln409">				      uint16_t holdtime,</a>
<a name="ln410">				      uint16_t propagation_delay,</a>
<a name="ln411">				      uint16_t override_interval,</a>
<a name="ln412">				      uint32_t dr_priority,</a>
<a name="ln413">				      uint32_t generation_id,</a>
<a name="ln414">				      struct list *addr_list)</a>
<a name="ln415">{</a>
<a name="ln416">  struct pim_interface *pim_ifp;</a>
<a name="ln417">  struct pim_neighbor *neigh;</a>
<a name="ln418"> </a>
<a name="ln419">  neigh = pim_neighbor_new(ifp, source_addr,</a>
<a name="ln420">			   hello_options,</a>
<a name="ln421">			   holdtime,</a>
<a name="ln422">			   propagation_delay,</a>
<a name="ln423">			   override_interval,</a>
<a name="ln424">			   dr_priority,</a>
<a name="ln425">			   generation_id,</a>
<a name="ln426">			   addr_list);</a>
<a name="ln427">  if (!neigh) {</a>
<a name="ln428">    return 0;</a>
<a name="ln429">  }</a>
<a name="ln430"> </a>
<a name="ln431">  pim_ifp = ifp-&gt;info;</a>
<a name="ln432">  zassert(pim_ifp);</a>
<a name="ln433"> </a>
<a name="ln434">  listnode_add(pim_ifp-&gt;pim_neighbor_list, neigh);</a>
<a name="ln435"> </a>
<a name="ln436">  /*</a>
<a name="ln437">    RFC 4601: 4.3.2.  DR Election</a>
<a name="ln438"> </a>
<a name="ln439">    A router's idea of the current DR on an interface can change when a</a>
<a name="ln440">    PIM Hello message is received, when a neighbor times out, or when a</a>
<a name="ln441">    router's own DR Priority changes.</a>
<a name="ln442">  */</a>
<a name="ln443">  pim_if_dr_election(neigh-&gt;interface); // new neighbor -- should not trigger dr election...</a>
<a name="ln444"> </a>
<a name="ln445">  /*</a>
<a name="ln446">    RFC 4601: 4.3.1.  Sending Hello Messages</a>
<a name="ln447"> </a>
<a name="ln448">    To allow new or rebooting routers to learn of PIM neighbors quickly,</a>
<a name="ln449">    when a Hello message is received from a new neighbor, or a Hello</a>
<a name="ln450">    message with a new GenID is received from an existing neighbor, a</a>
<a name="ln451">    new Hello message should be sent on this interface after a</a>
<a name="ln452">    randomized delay between 0 and Triggered_Hello_Delay.</a>
<a name="ln453">  */</a>
<a name="ln454">  pim_hello_restart_triggered(neigh-&gt;interface);</a>
<a name="ln455"> </a>
<a name="ln456">  return neigh;</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">static uint16_t</a>
<a name="ln460">find_neighbors_next_highest_propagation_delay_msec(struct interface *ifp,</a>
<a name="ln461">						   struct pim_neighbor *highest_neigh)</a>
<a name="ln462">{</a>
<a name="ln463">  struct pim_interface *pim_ifp;</a>
<a name="ln464">  struct listnode *neigh_node;</a>
<a name="ln465">  struct pim_neighbor *neigh;</a>
<a name="ln466">  uint16_t next_highest_delay_msec;</a>
<a name="ln467"> </a>
<a name="ln468">  pim_ifp = ifp-&gt;info;</a>
<a name="ln469">  zassert(pim_ifp);</a>
<a name="ln470"> </a>
<a name="ln471">  next_highest_delay_msec = pim_ifp-&gt;pim_propagation_delay_msec;</a>
<a name="ln472"> </a>
<a name="ln473">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_neighbor_list, neigh_node, neigh)) {</a>
<a name="ln474">    if (neigh == highest_neigh)</a>
<a name="ln475">      continue;</a>
<a name="ln476">    if (neigh-&gt;propagation_delay_msec &gt; next_highest_delay_msec)</a>
<a name="ln477">      next_highest_delay_msec = neigh-&gt;propagation_delay_msec;</a>
<a name="ln478">  }</a>
<a name="ln479"> </a>
<a name="ln480">  return next_highest_delay_msec;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">static uint16_t</a>
<a name="ln484">find_neighbors_next_highest_override_interval_msec(struct interface *ifp,</a>
<a name="ln485">						   struct pim_neighbor *highest_neigh)</a>
<a name="ln486">{</a>
<a name="ln487">  struct pim_interface *pim_ifp;</a>
<a name="ln488">  struct listnode *neigh_node;</a>
<a name="ln489">  struct pim_neighbor *neigh;</a>
<a name="ln490">  uint16_t next_highest_interval_msec;</a>
<a name="ln491"> </a>
<a name="ln492">  pim_ifp = ifp-&gt;info;</a>
<a name="ln493">  zassert(pim_ifp);</a>
<a name="ln494"> </a>
<a name="ln495">  next_highest_interval_msec = pim_ifp-&gt;pim_override_interval_msec;</a>
<a name="ln496"> </a>
<a name="ln497">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_neighbor_list, neigh_node, neigh)) {</a>
<a name="ln498">    if (neigh == highest_neigh)</a>
<a name="ln499">      continue;</a>
<a name="ln500">    if (neigh-&gt;override_interval_msec &gt; next_highest_interval_msec)</a>
<a name="ln501">      next_highest_interval_msec = neigh-&gt;override_interval_msec;</a>
<a name="ln502">  }</a>
<a name="ln503"> </a>
<a name="ln504">  return next_highest_interval_msec;</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">void pim_neighbor_delete(struct interface *ifp,</a>
<a name="ln508">			 struct pim_neighbor *neigh,</a>
<a name="ln509">			 const char *delete_message)</a>
<a name="ln510">{</a>
<a name="ln511">  struct pim_interface *pim_ifp;</a>
<a name="ln512">  char src_str[100];</a>
<a name="ln513"> </a>
<a name="ln514">  pim_ifp = ifp-&gt;info;</a>
<a name="ln515">  zassert(pim_ifp);</a>
<a name="ln516"> </a>
<a name="ln517">  pim_inet4_dump(&quot;&lt;src?&gt;&quot;, neigh-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln518">  zlog_info(&quot;PIM NEIGHBOR DOWN: neighbor %s on interface %s: %s&quot;,</a>
<a name="ln519">	    src_str, ifp-&gt;name, delete_message);</a>
<a name="ln520"> </a>
<a name="ln521">  neighbor_timer_off(neigh);</a>
<a name="ln522"> </a>
<a name="ln523">  pim_if_assert_on_neighbor_down(ifp, neigh-&gt;source_addr);</a>
<a name="ln524"> </a>
<a name="ln525">  if (!PIM_OPTION_IS_SET(neigh-&gt;hello_options,</a>
<a name="ln526">                         PIM_OPTION_MASK_LAN_PRUNE_DELAY)) {</a>
<a name="ln527">    /* update num. of neighbors without hello option lan_delay */</a>
<a name="ln528"> </a>
<a name="ln529">    --pim_ifp-&gt;pim_number_of_nonlandelay_neighbors;</a>
<a name="ln530">  }</a>
<a name="ln531"> </a>
<a name="ln532">  if (!PIM_OPTION_IS_SET(neigh-&gt;hello_options,</a>
<a name="ln533">			 PIM_OPTION_MASK_DR_PRIORITY)) {</a>
<a name="ln534">    /* update num. of neighbors without dr_pri */</a>
<a name="ln535"> </a>
<a name="ln536">    --pim_ifp-&gt;pim_dr_num_nondrpri_neighbors; </a>
<a name="ln537">  }</a>
<a name="ln538"> </a>
<a name="ln539">  zassert(neigh-&gt;propagation_delay_msec &lt;= pim_ifp-&gt;pim_neighbors_highest_propagation_delay_msec);</a>
<a name="ln540">  zassert(neigh-&gt;override_interval_msec &lt;= pim_ifp-&gt;pim_neighbors_highest_override_interval_msec);</a>
<a name="ln541"> </a>
<a name="ln542">  if (pim_if_lan_delay_enabled(ifp)) {</a>
<a name="ln543"> </a>
<a name="ln544">    /* will delete a neighbor with highest propagation delay? */</a>
<a name="ln545">    if (neigh-&gt;propagation_delay_msec == pim_ifp-&gt;pim_neighbors_highest_propagation_delay_msec) {</a>
<a name="ln546">      /* then find the next highest propagation delay */</a>
<a name="ln547">      pim_ifp-&gt;pim_neighbors_highest_propagation_delay_msec =</a>
<a name="ln548">	find_neighbors_next_highest_propagation_delay_msec(ifp, neigh);</a>
<a name="ln549">    }</a>
<a name="ln550"> </a>
<a name="ln551">    /* will delete a neighbor with highest override interval? */</a>
<a name="ln552">    if (neigh-&gt;override_interval_msec == pim_ifp-&gt;pim_neighbors_highest_override_interval_msec) {</a>
<a name="ln553">      /* then find the next highest propagation delay */</a>
<a name="ln554">      pim_ifp-&gt;pim_neighbors_highest_override_interval_msec =</a>
<a name="ln555">	find_neighbors_next_highest_override_interval_msec(ifp, neigh);</a>
<a name="ln556">    }</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln560">    zlog_debug(&quot;%s: deleting PIM neighbor %s on interface %s&quot;,</a>
<a name="ln561">	       __PRETTY_FUNCTION__,</a>
<a name="ln562">	       src_str, ifp-&gt;name);</a>
<a name="ln563">  }</a>
<a name="ln564"> </a>
<a name="ln565">  listnode_delete(pim_ifp-&gt;pim_neighbor_list, neigh);</a>
<a name="ln566"> </a>
<a name="ln567">  pim_neighbor_free(neigh);</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">void pim_neighbor_delete_all(struct interface *ifp,</a>
<a name="ln571">			     const char *delete_message)</a>
<a name="ln572">{</a>
<a name="ln573">  struct pim_interface *pim_ifp;</a>
<a name="ln574">  struct listnode *neigh_node;</a>
<a name="ln575">  struct listnode *neigh_nextnode;</a>
<a name="ln576">  struct pim_neighbor *neigh;</a>
<a name="ln577"> </a>
<a name="ln578">  pim_ifp = ifp-&gt;info;</a>
<a name="ln579">  zassert(pim_ifp);</a>
<a name="ln580"> </a>
<a name="ln581">  for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_neighbor_list, neigh_node,</a>
<a name="ln582">			 neigh_nextnode, neigh)) {</a>
<a name="ln583">    pim_neighbor_delete(ifp, neigh, delete_message);</a>
<a name="ln584">  }</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">struct prefix *pim_neighbor_find_secondary(struct pim_neighbor *neigh,</a>
<a name="ln588">					   struct in_addr addr)</a>
<a name="ln589">{</a>
<a name="ln590">  struct listnode *node;</a>
<a name="ln591">  struct prefix   *p;</a>
<a name="ln592"> </a>
<a name="ln593">  if (!neigh-&gt;prefix_list)</a>
<a name="ln594">    return 0;</a>
<a name="ln595"> </a>
<a name="ln596">  for (ALL_LIST_ELEMENTS_RO(neigh-&gt;prefix_list, node, p)) {</a>
<a name="ln597">    if (p-&gt;family == AF_INET) {</a>
<a name="ln598">      if (addr.s_addr == p-&gt;u.prefix4.s_addr) {</a>
<a name="ln599">	return p;</a>
<a name="ln600">      }</a>
<a name="ln601">    }</a>
<a name="ln602">  }</a>
<a name="ln603"> </a>
<a name="ln604">  return 0;</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">/*</a>
<a name="ln608">  RFC 4601: 4.3.4.  Maintaining Secondary Address Lists</a>
<a name="ln609">  </a>
<a name="ln610">  All the advertised secondary addresses in received Hello messages</a>
<a name="ln611">  must be checked against those previously advertised by all other</a>
<a name="ln612">  PIM neighbors on that interface.  If there is a conflict and the</a>
<a name="ln613">  same secondary address was previously advertised by another</a>
<a name="ln614">  neighbor, then only the most recently received mapping MUST be</a>
<a name="ln615">  maintained, and an error message SHOULD be logged to the</a>
<a name="ln616">  administrator in a rate-limited manner.</a>
<a name="ln617">*/</a>
<a name="ln618">static void delete_from_neigh_addr(struct interface *ifp,</a>
<a name="ln619">				   struct list *addr_list,</a>
<a name="ln620">				   struct in_addr neigh_addr)</a>
<a name="ln621">{</a>
<a name="ln622">  struct listnode      *addr_node;</a>
<a name="ln623">  struct prefix        *addr;</a>
<a name="ln624">  struct pim_interface *pim_ifp;</a>
<a name="ln625"> </a>
<a name="ln626">  pim_ifp = ifp-&gt;info;</a>
<a name="ln627">  zassert(pim_ifp);</a>
<a name="ln628"> </a>
<a name="ln629">  zassert(addr_list);</a>
<a name="ln630"> </a>
<a name="ln631">  /*</a>
<a name="ln632">    Scan secondary address list</a>
<a name="ln633">  */</a>
<a name="ln634">  for (ALL_LIST_ELEMENTS_RO(addr_list, addr_node,</a>
<a name="ln635">			    addr)) {</a>
<a name="ln636">    struct listnode      *neigh_node;</a>
<a name="ln637">    struct pim_neighbor  *neigh;</a>
<a name="ln638"> </a>
<a name="ln639">    if (addr-&gt;family != AF_INET)</a>
<a name="ln640">      continue;</a>
<a name="ln641"> </a>
<a name="ln642">    /*</a>
<a name="ln643">      Scan neighbors</a>
<a name="ln644">    */</a>
<a name="ln645">    for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_neighbor_list, neigh_node,</a>
<a name="ln646">			      neigh)) {</a>
<a name="ln647">      {</a>
<a name="ln648">	struct prefix *p = pim_neighbor_find_secondary(neigh, addr-&gt;u.prefix4);</a>
<a name="ln649">	if (p) {</a>
<a name="ln650">	  char addr_str[100];</a>
<a name="ln651">	  char this_neigh_str[100];</a>
<a name="ln652">	  char other_neigh_str[100];</a>
<a name="ln653">	  </a>
<a name="ln654">	  pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr-&gt;u.prefix4, addr_str, sizeof(addr_str));</a>
<a name="ln655">	  pim_inet4_dump(&quot;&lt;neigh1?&gt;&quot;, neigh_addr, this_neigh_str, sizeof(this_neigh_str));</a>
<a name="ln656">	  pim_inet4_dump(&quot;&lt;neigh2?&gt;&quot;, neigh-&gt;source_addr, other_neigh_str, sizeof(other_neigh_str));</a>
<a name="ln657">	  </a>
<a name="ln658">	  zlog_info(&quot;secondary addr %s recvd from neigh %s deleted from neigh %s on %s&quot;,</a>
<a name="ln659">		    addr_str, this_neigh_str, other_neigh_str, ifp-&gt;name);</a>
<a name="ln660">	  </a>
<a name="ln661">	  listnode_delete(neigh-&gt;prefix_list, p);</a>
<a name="ln662">	  prefix_free(p);</a>
<a name="ln663">	}</a>
<a name="ln664">      }</a>
<a name="ln665"> </a>
<a name="ln666">    } /* scan neighbors */</a>
<a name="ln667">    </a>
<a name="ln668">  } /* scan addr list */</a>
<a name="ln669"> </a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">void pim_neighbor_update(struct pim_neighbor *neigh,</a>
<a name="ln673">			 pim_hello_options hello_options,</a>
<a name="ln674">			 uint16_t holdtime,</a>
<a name="ln675">			 uint32_t dr_priority,</a>
<a name="ln676">			 struct list *addr_list)</a>
<a name="ln677">{</a>
<a name="ln678">  struct pim_interface *pim_ifp = neigh-&gt;interface-&gt;info;</a>
<a name="ln679"> </a>
<a name="ln680">  /* Received holdtime ? */</a>
<a name="ln681">  if (PIM_OPTION_IS_SET(hello_options, PIM_OPTION_MASK_HOLDTIME)) {</a>
<a name="ln682">    pim_neighbor_timer_reset(neigh, holdtime);</a>
<a name="ln683">  }</a>
<a name="ln684">  else {</a>
<a name="ln685">    pim_neighbor_timer_reset(neigh, PIM_IF_DEFAULT_HOLDTIME(pim_ifp));</a>
<a name="ln686">  }</a>
<a name="ln687"> </a>
<a name="ln688">#ifdef DUMP_PREFIX_LIST</a>
<a name="ln689">  zlog_debug(&quot;%s: DUMP_PREFIX_LIST old_prefix_list=%x old_size=%d new_prefix_list=%x new_size=%d&quot;,</a>
<a name="ln690">	     __PRETTY_FUNCTION__,</a>
<a name="ln691">	     (unsigned) neigh-&gt;prefix_list,</a>
<a name="ln692">	     neigh-&gt;prefix_list ? (int) listcount(neigh-&gt;prefix_list) : -1,</a>
<a name="ln693">	     (unsigned) addr_list,</a>
<a name="ln694">	     addr_list ? (int) listcount(addr_list) : -1);</a>
<a name="ln695">#endif</a>
<a name="ln696"> </a>
<a name="ln697">  if (neigh-&gt;prefix_list == addr_list) {</a>
<a name="ln698">    if (addr_list) {</a>
<a name="ln699">      zlog_err(&quot;%s: internal error: trying to replace same prefix list=%p&quot;,</a>
<a name="ln700">	       __PRETTY_FUNCTION__, (void *) addr_list);</a>
<a name="ln701">    }</a>
<a name="ln702">  }</a>
<a name="ln703">  else {</a>
<a name="ln704">    /* Delete existing secondary address list */</a>
<a name="ln705">    delete_prefix_list(neigh);</a>
<a name="ln706">  }</a>
<a name="ln707"> </a>
<a name="ln708">  if (addr_list) {</a>
<a name="ln709">    delete_from_neigh_addr(neigh-&gt;interface, addr_list, neigh-&gt;source_addr);</a>
<a name="ln710">  }</a>
<a name="ln711"> </a>
<a name="ln712">  /* Replace secondary address list */</a>
<a name="ln713">  neigh-&gt;prefix_list = addr_list;</a>
<a name="ln714"> </a>
<a name="ln715">  update_dr_priority(neigh,</a>
<a name="ln716">		     hello_options,</a>
<a name="ln717">		     dr_priority);</a>
<a name="ln718">  /*</a>
<a name="ln719">    Copy flags</a>
<a name="ln720">   */</a>
<a name="ln721">  neigh-&gt;hello_options = hello_options;</a>
<a name="ln722">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
