
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_packet.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF Sending and Receiving OSPF Packets.</a>
<a name="ln3"> * Copyright (C) 1999, 2000 Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;table.h&quot;</a>
<a name="ln31">#include &quot;sockunion.h&quot;</a>
<a name="ln32">#include &quot;stream.h&quot;</a>
<a name="ln33">#include &quot;log.h&quot;</a>
<a name="ln34">#include &quot;sockopt.h&quot;</a>
<a name="ln35">#include &quot;checksum.h&quot;</a>
<a name="ln36">#include &quot;md5.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_network.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln48">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln49">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln50">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">/* Packet Type String. */</a>
<a name="ln53">const struct message ospf_packet_type_str[] =</a>
<a name="ln54">{</a>
<a name="ln55">  { OSPF_MSG_HELLO,   &quot;Hello&quot;                     },</a>
<a name="ln56">  { OSPF_MSG_DB_DESC, &quot;Database Description&quot;      },</a>
<a name="ln57">  { OSPF_MSG_LS_REQ,  &quot;Link State Request&quot;        },</a>
<a name="ln58">  { OSPF_MSG_LS_UPD,  &quot;Link State Update&quot;         },</a>
<a name="ln59">  { OSPF_MSG_LS_ACK,  &quot;Link State Acknowledgment&quot; },</a>
<a name="ln60">};</a>
<a name="ln61">const size_t ospf_packet_type_str_max = sizeof (ospf_packet_type_str) /</a>
<a name="ln62">  sizeof (ospf_packet_type_str[0]);</a>
<a name="ln63"> </a>
<a name="ln64">/* Minimum (besides OSPF_HEADER_SIZE) lengths for OSPF packets of</a>
<a name="ln65">   particular types, offset is the &quot;type&quot; field of a packet. */</a>
<a name="ln66">static const u_int16_t ospf_packet_minlen[] =</a>
<a name="ln67">{</a>
<a name="ln68">  0,</a>
<a name="ln69">  OSPF_HELLO_MIN_SIZE,</a>
<a name="ln70">  OSPF_DB_DESC_MIN_SIZE,</a>
<a name="ln71">  OSPF_LS_REQ_MIN_SIZE,</a>
<a name="ln72">  OSPF_LS_UPD_MIN_SIZE,</a>
<a name="ln73">  OSPF_LS_ACK_MIN_SIZE,</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">/* Minimum (besides OSPF_LSA_HEADER_SIZE) lengths for LSAs of particular</a>
<a name="ln77">   types, offset is the &quot;LSA type&quot; field. */</a>
<a name="ln78">static const u_int16_t ospf_lsa_minlen[] =</a>
<a name="ln79">{</a>
<a name="ln80">  0,</a>
<a name="ln81">  OSPF_ROUTER_LSA_MIN_SIZE,</a>
<a name="ln82">  OSPF_NETWORK_LSA_MIN_SIZE,</a>
<a name="ln83">  OSPF_SUMMARY_LSA_MIN_SIZE,</a>
<a name="ln84">  OSPF_SUMMARY_LSA_MIN_SIZE,</a>
<a name="ln85">  OSPF_AS_EXTERNAL_LSA_MIN_SIZE,</a>
<a name="ln86">  0,</a>
<a name="ln87">  OSPF_AS_EXTERNAL_LSA_MIN_SIZE,</a>
<a name="ln88">  0,</a>
<a name="ln89">  0,</a>
<a name="ln90">  0,</a>
<a name="ln91">  0,</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94">/* for ospf_check_auth() */</a>
<a name="ln95">static int ospf_check_sum (struct ospf_header *);</a>
<a name="ln96"> </a>
<a name="ln97">/* OSPF authentication checking function */</a>
<a name="ln98">static int</a>
<a name="ln99">ospf_auth_type (struct ospf_interface *oi)</a>
<a name="ln100">{</a>
<a name="ln101">  int auth_type;</a>
<a name="ln102"> </a>
<a name="ln103">  if (OSPF_IF_PARAM (oi, auth_type) == OSPF_AUTH_NOTSET)</a>
<a name="ln104">    auth_type = oi-&gt;area-&gt;auth_type;</a>
<a name="ln105">  else</a>
<a name="ln106">    auth_type = OSPF_IF_PARAM (oi, auth_type);</a>
<a name="ln107"> </a>
<a name="ln108">  /* Handle case where MD5 key list is not configured aka Cisco */</a>
<a name="ln109">  if (auth_type == OSPF_AUTH_CRYPTOGRAPHIC &amp;&amp;</a>
<a name="ln110">      list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))</a>
<a name="ln111">    return OSPF_AUTH_NULL;</a>
<a name="ln112">  </a>
<a name="ln113">  return auth_type;</a>
<a name="ln114"> </a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">struct ospf_packet *</a>
<a name="ln118">ospf_packet_new (size_t size)</a>
<a name="ln119">{</a>
<a name="ln120">  struct ospf_packet *new;</a>
<a name="ln121"> </a>
<a name="ln122">  new = XCALLOC (MTYPE_OSPF_PACKET, sizeof (struct ospf_packet));</a>
<a name="ln123">  new-&gt;s = stream_new (size);</a>
<a name="ln124"> </a>
<a name="ln125">  return new;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">void</a>
<a name="ln129">ospf_packet_free (struct ospf_packet *op)</a>
<a name="ln130">{</a>
<a name="ln131">  if (op-&gt;s)</a>
<a name="ln132">    stream_free (op-&gt;s);</a>
<a name="ln133"> </a>
<a name="ln134">  XFREE (MTYPE_OSPF_PACKET, op);</a>
<a name="ln135"> </a>
<a name="ln136">  op = NULL;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">struct ospf_fifo *</a>
<a name="ln140">ospf_fifo_new ()</a>
<a name="ln141">{</a>
<a name="ln142">  struct ospf_fifo *new;</a>
<a name="ln143"> </a>
<a name="ln144">  new = XCALLOC (MTYPE_OSPF_FIFO, sizeof (struct ospf_fifo));</a>
<a name="ln145">  return new;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">/* Add new packet to fifo. */</a>
<a name="ln149">void</a>
<a name="ln150">ospf_fifo_push (struct ospf_fifo *fifo, struct ospf_packet *op)</a>
<a name="ln151">{</a>
<a name="ln152">  if (fifo-&gt;tail)</a>
<a name="ln153">    fifo-&gt;tail-&gt;next = op;</a>
<a name="ln154">  else</a>
<a name="ln155">    fifo-&gt;head = op;</a>
<a name="ln156"> </a>
<a name="ln157">  fifo-&gt;tail = op;</a>
<a name="ln158"> </a>
<a name="ln159">  fifo-&gt;count++;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">/* Add new packet to head of fifo. */</a>
<a name="ln163">static void</a>
<a name="ln164">ospf_fifo_push_head (struct ospf_fifo *fifo, struct ospf_packet *op)</a>
<a name="ln165">{</a>
<a name="ln166">  op-&gt;next = fifo-&gt;head;</a>
<a name="ln167">  </a>
<a name="ln168">  if (fifo-&gt;tail == NULL)</a>
<a name="ln169">    fifo-&gt;tail = op;</a>
<a name="ln170">  </a>
<a name="ln171">  fifo-&gt;head = op;</a>
<a name="ln172">  </a>
<a name="ln173">  fifo-&gt;count++;</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">/* Delete first packet from fifo. */</a>
<a name="ln177">struct ospf_packet *</a>
<a name="ln178">ospf_fifo_pop (struct ospf_fifo *fifo)</a>
<a name="ln179">{</a>
<a name="ln180">  struct ospf_packet *op;</a>
<a name="ln181"> </a>
<a name="ln182">  op = fifo-&gt;head;</a>
<a name="ln183"> </a>
<a name="ln184">  if (op)</a>
<a name="ln185">    {</a>
<a name="ln186">      fifo-&gt;head = op-&gt;next;</a>
<a name="ln187"> </a>
<a name="ln188">      if (fifo-&gt;head == NULL)</a>
<a name="ln189">	fifo-&gt;tail = NULL;</a>
<a name="ln190"> </a>
<a name="ln191">      fifo-&gt;count--;</a>
<a name="ln192">    }</a>
<a name="ln193"> </a>
<a name="ln194">  return op;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">/* Return first fifo entry. */</a>
<a name="ln198">struct ospf_packet *</a>
<a name="ln199">ospf_fifo_head (struct ospf_fifo *fifo)</a>
<a name="ln200">{</a>
<a name="ln201">  return fifo-&gt;head;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">/* Flush ospf packet fifo. */</a>
<a name="ln205">void</a>
<a name="ln206">ospf_fifo_flush (struct ospf_fifo *fifo)</a>
<a name="ln207">{</a>
<a name="ln208">  struct ospf_packet *op;</a>
<a name="ln209">  struct ospf_packet *next;</a>
<a name="ln210"> </a>
<a name="ln211">  for (op = fifo-&gt;head; op; op = next)</a>
<a name="ln212">    {</a>
<a name="ln213">      next = op-&gt;next;</a>
<a name="ln214">      ospf_packet_free (op);</a>
<a name="ln215">    }</a>
<a name="ln216">  fifo-&gt;head = fifo-&gt;tail = NULL;</a>
<a name="ln217">  fifo-&gt;count = 0;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">/* Free ospf packet fifo. */</a>
<a name="ln221">void</a>
<a name="ln222">ospf_fifo_free (struct ospf_fifo *fifo)</a>
<a name="ln223">{</a>
<a name="ln224">  ospf_fifo_flush (fifo);</a>
<a name="ln225"> </a>
<a name="ln226">  XFREE (MTYPE_OSPF_FIFO, fifo);</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">void</a>
<a name="ln230">ospf_packet_add (struct ospf_interface *oi, struct ospf_packet *op)</a>
<a name="ln231">{</a>
<a name="ln232">  if (!oi-&gt;obuf)</a>
<a name="ln233">    {</a>
<a name="ln234">      zlog_err(&quot;ospf_packet_add(interface %s in state %d [%s], packet type %s, &quot;</a>
<a name="ln235">	       &quot;destination %s) called with NULL obuf, ignoring &quot;</a>
<a name="ln236">	       &quot;(please report this bug)!\n&quot;,</a>
<a name="ln237">	       IF_NAME(oi), oi-&gt;state, LOOKUP (ospf_ism_state_msg, oi-&gt;state),</a>
<a name="ln238">	       LOOKUP (ospf_packet_type_str, stream_getc_from(op-&gt;s, 1)),</a>
<a name="ln239">	       inet_ntoa (op-&gt;dst));</a>
<a name="ln240">      return;</a>
<a name="ln241">    }</a>
<a name="ln242"> </a>
<a name="ln243">  /* Add packet to end of queue. */</a>
<a name="ln244">  ospf_fifo_push (oi-&gt;obuf, op);</a>
<a name="ln245"> </a>
<a name="ln246">  /* Debug of packet fifo*/</a>
<a name="ln247">  /* ospf_fifo_debug (oi-&gt;obuf); */</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">static void</a>
<a name="ln251">ospf_packet_add_top (struct ospf_interface *oi, struct ospf_packet *op)</a>
<a name="ln252">{</a>
<a name="ln253">  if (!oi-&gt;obuf)</a>
<a name="ln254">    {</a>
<a name="ln255">      zlog_err(&quot;ospf_packet_add(interface %s in state %d [%s], packet type %s, &quot;</a>
<a name="ln256">	       &quot;destination %s) called with NULL obuf, ignoring &quot;</a>
<a name="ln257">	       &quot;(please report this bug)!\n&quot;,</a>
<a name="ln258">	       IF_NAME(oi), oi-&gt;state, LOOKUP (ospf_ism_state_msg, oi-&gt;state),</a>
<a name="ln259">	       LOOKUP (ospf_packet_type_str, stream_getc_from(op-&gt;s, 1)),</a>
<a name="ln260">	       inet_ntoa (op-&gt;dst));</a>
<a name="ln261">      return;</a>
<a name="ln262">    }</a>
<a name="ln263"> </a>
<a name="ln264">  /* Add packet to head of queue. */</a>
<a name="ln265">  ospf_fifo_push_head (oi-&gt;obuf, op);</a>
<a name="ln266"> </a>
<a name="ln267">  /* Debug of packet fifo*/</a>
<a name="ln268">  /* ospf_fifo_debug (oi-&gt;obuf); */</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">void</a>
<a name="ln272">ospf_packet_delete (struct ospf_interface *oi)</a>
<a name="ln273">{</a>
<a name="ln274">  struct ospf_packet *op;</a>
<a name="ln275">  </a>
<a name="ln276">  op = ospf_fifo_pop (oi-&gt;obuf);</a>
<a name="ln277"> </a>
<a name="ln278">  if (op)</a>
<a name="ln279">    ospf_packet_free (op);</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">struct ospf_packet *</a>
<a name="ln283">ospf_packet_dup (struct ospf_packet *op)</a>
<a name="ln284">{</a>
<a name="ln285">  struct ospf_packet *new;</a>
<a name="ln286"> </a>
<a name="ln287">  if (stream_get_endp(op-&gt;s) != op-&gt;length)</a>
<a name="ln288">    /* XXX size_t */</a>
<a name="ln289">    zlog_warn (&quot;ospf_packet_dup stream %lu ospf_packet %u size mismatch&quot;,</a>
<a name="ln290">	       (u_long)STREAM_SIZE(op-&gt;s), op-&gt;length);</a>
<a name="ln291"> </a>
<a name="ln292">  /* Reserve space for MD5 authentication that may be added later. */</a>
<a name="ln293">  new = ospf_packet_new (stream_get_endp(op-&gt;s) + OSPF_AUTH_MD5_SIZE);</a>
<a name="ln294">  stream_copy (new-&gt;s, op-&gt;s);</a>
<a name="ln295"> </a>
<a name="ln296">  new-&gt;dst = op-&gt;dst;</a>
<a name="ln297">  new-&gt;length = op-&gt;length;</a>
<a name="ln298"> </a>
<a name="ln299">  return new;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">/* XXX inline */</a>
<a name="ln303">static unsigned int</a>
<a name="ln304">ospf_packet_authspace (struct ospf_interface *oi)</a>
<a name="ln305">{</a>
<a name="ln306">  int auth = 0;</a>
<a name="ln307"> </a>
<a name="ln308">  if ( ospf_auth_type (oi) == OSPF_AUTH_CRYPTOGRAPHIC)</a>
<a name="ln309">    auth = OSPF_AUTH_MD5_SIZE;</a>
<a name="ln310"> </a>
<a name="ln311">  return auth;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">static unsigned int</a>
<a name="ln315">ospf_packet_max (struct ospf_interface *oi)</a>
<a name="ln316">{</a>
<a name="ln317">  int max;</a>
<a name="ln318"> </a>
<a name="ln319">  max = oi-&gt;ifp-&gt;mtu - ospf_packet_authspace(oi);</a>
<a name="ln320"> </a>
<a name="ln321">  max -= (OSPF_HEADER_SIZE + sizeof (struct ip));</a>
<a name="ln322"> </a>
<a name="ln323">  return max;</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326"> </a>
<a name="ln327">static int</a>
<a name="ln328">ospf_check_md5_digest (struct ospf_interface *oi, struct ospf_header *ospfh)</a>
<a name="ln329">{</a>
<a name="ln330">  MD5_CTX ctx;</a>
<a name="ln331">  unsigned char digest[OSPF_AUTH_MD5_SIZE];</a>
<a name="ln332">  struct crypt_key *ck;</a>
<a name="ln333">  struct ospf_neighbor *nbr;</a>
<a name="ln334">  u_int16_t length = ntohs (ospfh-&gt;length);</a>
<a name="ln335">  </a>
<a name="ln336">  /* Get secret key. */</a>
<a name="ln337">  ck = ospf_crypt_key_lookup (OSPF_IF_PARAM (oi, auth_crypt),</a>
<a name="ln338">			      ospfh-&gt;u.crypt.key_id);</a>
<a name="ln339">  if (ck == NULL)</a>
<a name="ln340">    {</a>
<a name="ln341">      zlog_warn (&quot;interface %s: ospf_check_md5 no key %d&quot;,</a>
<a name="ln342">		 IF_NAME (oi), ospfh-&gt;u.crypt.key_id);</a>
<a name="ln343">      return 0;</a>
<a name="ln344">    }</a>
<a name="ln345"> </a>
<a name="ln346">  /* check crypto seqnum. */</a>
<a name="ln347">  nbr = ospf_nbr_lookup_by_routerid (oi-&gt;nbrs, &amp;ospfh-&gt;router_id);</a>
<a name="ln348"> </a>
<a name="ln349">  if (nbr &amp;&amp; ntohl(nbr-&gt;crypt_seqnum) &gt; ntohl(ospfh-&gt;u.crypt.crypt_seqnum))</a>
<a name="ln350">    {</a>
<a name="ln351">      zlog_warn (&quot;interface %s: ospf_check_md5 bad sequence %d (expect %d)&quot;,</a>
<a name="ln352">		 IF_NAME (oi),</a>
<a name="ln353">		 ntohl(ospfh-&gt;u.crypt.crypt_seqnum),</a>
<a name="ln354">		 ntohl(nbr-&gt;crypt_seqnum));</a>
<a name="ln355">      return 0;</a>
<a name="ln356">    }</a>
<a name="ln357">      </a>
<a name="ln358">  /* Generate a digest for the ospf packet - their digest + our digest. */</a>
<a name="ln359">  memset(&amp;ctx, 0, sizeof(ctx));</a>
<a name="ln360">  MD5Init(&amp;ctx);</a>
<a name="ln361">  MD5Update(&amp;ctx, ospfh, length);</a>
<a name="ln362">  MD5Update(&amp;ctx, ck-&gt;auth_key, OSPF_AUTH_MD5_SIZE);</a>
<a name="ln363">  MD5Final(digest, &amp;ctx);</a>
<a name="ln364"> </a>
<a name="ln365">  /* compare the two */</a>
<a name="ln366">  if (memcmp ((caddr_t)ospfh + length, digest, OSPF_AUTH_MD5_SIZE))</a>
<a name="ln367">    {</a>
<a name="ln368">      zlog_warn (&quot;interface %s: ospf_check_md5 checksum mismatch&quot;,</a>
<a name="ln369">		 IF_NAME (oi));</a>
<a name="ln370">      return 0;</a>
<a name="ln371">    }</a>
<a name="ln372"> </a>
<a name="ln373">  /* save neighbor's crypt_seqnum */</a>
<a name="ln374">  if (nbr)</a>
<a name="ln375">    nbr-&gt;crypt_seqnum = ospfh-&gt;u.crypt.crypt_seqnum;</a>
<a name="ln376">  return 1;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">/* This function is called from ospf_write(), it will detect the</a>
<a name="ln380">   authentication scheme and if it is MD5, it will change the sequence</a>
<a name="ln381">   and update the MD5 digest. */</a>
<a name="ln382">static int</a>
<a name="ln383">ospf_make_md5_digest (struct ospf_interface *oi, struct ospf_packet *op)</a>
<a name="ln384">{</a>
<a name="ln385">  struct ospf_header *ospfh;</a>
<a name="ln386">  unsigned char digest[OSPF_AUTH_MD5_SIZE] = {0};</a>
<a name="ln387">  MD5_CTX ctx;</a>
<a name="ln388">  void *ibuf;</a>
<a name="ln389">  u_int32_t t;</a>
<a name="ln390">  struct crypt_key *ck;</a>
<a name="ln391">  const u_int8_t *auth_key;</a>
<a name="ln392"> </a>
<a name="ln393">  ibuf = STREAM_DATA (op-&gt;s);</a>
<a name="ln394">  ospfh = (struct ospf_header *) ibuf;</a>
<a name="ln395"> </a>
<a name="ln396">  if (ntohs (ospfh-&gt;auth_type) != OSPF_AUTH_CRYPTOGRAPHIC)</a>
<a name="ln397">    return 0;</a>
<a name="ln398"> </a>
<a name="ln399">  /* We do this here so when we dup a packet, we don't have to</a>
<a name="ln400">     waste CPU rewriting other headers.</a>
<a name="ln401">     </a>
<a name="ln402">     Note that quagga_time /deliberately/ is not used here */</a>
<a name="ln403">  t = (time(NULL) &amp; 0xFFFFFFFF);</a>
<a name="ln404">  if (t &gt; oi-&gt;crypt_seqnum)</a>
<a name="ln405">    oi-&gt;crypt_seqnum = t;</a>
<a name="ln406">  else</a>
<a name="ln407">    oi-&gt;crypt_seqnum++;</a>
<a name="ln408">  </a>
<a name="ln409">  ospfh-&gt;u.crypt.crypt_seqnum = htonl (oi-&gt;crypt_seqnum); </a>
<a name="ln410"> </a>
<a name="ln411">  /* Get MD5 Authentication key from auth_key list. */</a>
<a name="ln412">  if (list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))</a>
<a name="ln413">    auth_key = (const u_int8_t *) digest;</a>
<a name="ln414">  else</a>
<a name="ln415">    {</a>
<a name="ln416">      ck = listgetdata (listtail(OSPF_IF_PARAM (oi, auth_crypt)));</a>
<a name="ln417">      auth_key = ck-&gt;auth_key;</a>
<a name="ln418">    }</a>
<a name="ln419"> </a>
<a name="ln420">  /* Generate a digest for the entire packet + our secret key. */</a>
<a name="ln421">  memset(&amp;ctx, 0, sizeof(ctx));</a>
<a name="ln422">  MD5Init(&amp;ctx);</a>
<a name="ln423">  MD5Update(&amp;ctx, ibuf, ntohs (ospfh-&gt;length));</a>
<a name="ln424">  MD5Update(&amp;ctx, auth_key, OSPF_AUTH_MD5_SIZE);</a>
<a name="ln425">  MD5Final(digest, &amp;ctx);</a>
<a name="ln426"> </a>
<a name="ln427">  /* Append md5 digest to the end of the stream. */</a>
<a name="ln428">  stream_put (op-&gt;s, digest, OSPF_AUTH_MD5_SIZE);</a>
<a name="ln429"> </a>
<a name="ln430">  /* We do *NOT* increment the OSPF header length. */</a>
<a name="ln431">  op-&gt;length = ntohs (ospfh-&gt;length) + OSPF_AUTH_MD5_SIZE;</a>
<a name="ln432"> </a>
<a name="ln433">  if (stream_get_endp(op-&gt;s) != op-&gt;length)</a>
<a name="ln434">    /* XXX size_t */</a>
<a name="ln435">    zlog_warn(&quot;ospf_make_md5_digest: length mismatch stream %lu ospf_packet %u&quot;,</a>
<a name="ln436">	      (u_long)stream_get_endp(op-&gt;s), op-&gt;length);</a>
<a name="ln437"> </a>
<a name="ln438">  return OSPF_AUTH_MD5_SIZE;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441"> </a>
<a name="ln442">static int</a>
<a name="ln443">ospf_ls_req_timer (struct thread *thread)</a>
<a name="ln444">{</a>
<a name="ln445">  struct ospf_neighbor *nbr;</a>
<a name="ln446"> </a>
<a name="ln447">  nbr = THREAD_ARG (thread);</a>
<a name="ln448">  nbr-&gt;t_ls_req = NULL;</a>
<a name="ln449"> </a>
<a name="ln450">  /* Send Link State Request. */</a>
<a name="ln451">  if (ospf_ls_request_count (nbr))</a>
<a name="ln452">    ospf_ls_req_send (nbr);</a>
<a name="ln453"> </a>
<a name="ln454">  /* Set Link State Request retransmission timer. */</a>
<a name="ln455">  OSPF_NSM_TIMER_ON (nbr-&gt;t_ls_req, ospf_ls_req_timer, nbr-&gt;v_ls_req);</a>
<a name="ln456"> </a>
<a name="ln457">  return 0;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">void</a>
<a name="ln461">ospf_ls_req_event (struct ospf_neighbor *nbr)</a>
<a name="ln462">{</a>
<a name="ln463">  if (nbr-&gt;t_ls_req)</a>
<a name="ln464">    {</a>
<a name="ln465">      thread_cancel (nbr-&gt;t_ls_req);</a>
<a name="ln466">      nbr-&gt;t_ls_req = NULL;</a>
<a name="ln467">    }</a>
<a name="ln468">  nbr-&gt;t_ls_req = thread_add_event (master, ospf_ls_req_timer, nbr, 0);</a>
<a name="ln469">}</a>
<a name="ln470"> </a>
<a name="ln471">/* Cyclic timer function.  Fist registered in ospf_nbr_new () in</a>
<a name="ln472">   ospf_neighbor.c  */</a>
<a name="ln473">int</a>
<a name="ln474">ospf_ls_upd_timer (struct thread *thread)</a>
<a name="ln475">{</a>
<a name="ln476">  struct ospf_neighbor *nbr;</a>
<a name="ln477"> </a>
<a name="ln478">  nbr = THREAD_ARG (thread);</a>
<a name="ln479">  nbr-&gt;t_ls_upd = NULL;</a>
<a name="ln480"> </a>
<a name="ln481">  /* Send Link State Update. */</a>
<a name="ln482">  if (ospf_ls_retransmit_count (nbr) &gt; 0)</a>
<a name="ln483">    {</a>
<a name="ln484">      struct list *update;</a>
<a name="ln485">      struct ospf_lsdb *lsdb;</a>
<a name="ln486">      int i;</a>
<a name="ln487">      int retransmit_interval;</a>
<a name="ln488"> </a>
<a name="ln489">      retransmit_interval = OSPF_IF_PARAM (nbr-&gt;oi, retransmit_interval);</a>
<a name="ln490"> </a>
<a name="ln491">      lsdb = &amp;nbr-&gt;ls_rxmt;</a>
<a name="ln492">      update = list_new ();</a>
<a name="ln493"> </a>
<a name="ln494">      for (i = OSPF_MIN_LSA; i &lt; OSPF_MAX_LSA; i++)</a>
<a name="ln495">	{</a>
<a name="ln496">	  struct route_table *table = lsdb-&gt;type[i].db;</a>
<a name="ln497">	  struct route_node *rn;</a>
<a name="ln498">	  </a>
<a name="ln499">	  for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln500">	    {</a>
<a name="ln501">	      struct ospf_lsa *lsa;</a>
<a name="ln502">	      </a>
<a name="ln503">	      if ((lsa = rn-&gt;info) != NULL)</a>
<a name="ln504">		/* Don't retransmit an LSA if we received it within</a>
<a name="ln505">		  the last RxmtInterval seconds - this is to allow the</a>
<a name="ln506">		  neighbour a chance to acknowledge the LSA as it may</a>
<a name="ln507">		  have ben just received before the retransmit timer</a>
<a name="ln508">		  fired.  This is a small tweak to what is in the RFC,</a>
<a name="ln509">		  but it will cut out out a lot of retransmit traffic</a>
<a name="ln510">		  - MAG */</a>
<a name="ln511">		if (tv_cmp (tv_sub (recent_relative_time (), lsa-&gt;tv_recv), </a>
<a name="ln512">			    int2tv (retransmit_interval)) &gt;= 0)</a>
<a name="ln513">		  listnode_add (update, rn-&gt;info);</a>
<a name="ln514">	    }</a>
<a name="ln515">	}</a>
<a name="ln516"> </a>
<a name="ln517">      if (listcount (update) &gt; 0)</a>
<a name="ln518">	ospf_ls_upd_send (nbr, update, OSPF_SEND_PACKET_DIRECT);</a>
<a name="ln519">      list_delete (update);</a>
<a name="ln520">    }</a>
<a name="ln521"> </a>
<a name="ln522">  /* Set LS Update retransmission timer. */</a>
<a name="ln523">  OSPF_NSM_TIMER_ON (nbr-&gt;t_ls_upd, ospf_ls_upd_timer, nbr-&gt;v_ls_upd);</a>
<a name="ln524"> </a>
<a name="ln525">  return 0;</a>
<a name="ln526">}</a>
<a name="ln527"> </a>
<a name="ln528">int</a>
<a name="ln529">ospf_ls_ack_timer (struct thread *thread)</a>
<a name="ln530">{</a>
<a name="ln531">  struct ospf_interface *oi;</a>
<a name="ln532"> </a>
<a name="ln533">  oi = THREAD_ARG (thread);</a>
<a name="ln534">  oi-&gt;t_ls_ack = NULL;</a>
<a name="ln535"> </a>
<a name="ln536">  /* Send Link State Acknowledgment. */</a>
<a name="ln537">  if (listcount (oi-&gt;ls_ack) &gt; 0)</a>
<a name="ln538">    ospf_ls_ack_send_delayed (oi);</a>
<a name="ln539"> </a>
<a name="ln540">  /* Set LS Ack timer. */</a>
<a name="ln541">  OSPF_ISM_TIMER_ON (oi-&gt;t_ls_ack, ospf_ls_ack_timer, oi-&gt;v_ls_ack);</a>
<a name="ln542"> </a>
<a name="ln543">  return 0;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">#ifdef WANT_OSPF_WRITE_FRAGMENT</a>
<a name="ln547">static void</a>
<a name="ln548">ospf_write_frags (int fd, struct ospf_packet *op, struct ip *iph, </a>
<a name="ln549">                  struct msghdr *msg, unsigned int maxdatasize, </a>
<a name="ln550">                  unsigned int mtu, int flags, u_char type)</a>
<a name="ln551">{</a>
<a name="ln552">#define OSPF_WRITE_FRAG_SHIFT 3</a>
<a name="ln553">  u_int16_t offset;</a>
<a name="ln554">  struct iovec *iovp;</a>
<a name="ln555">  int ret;</a>
<a name="ln556"> </a>
<a name="ln557">  assert ( op-&gt;length == stream_get_endp(op-&gt;s) );</a>
<a name="ln558">  assert (msg-&gt;msg_iovlen == 2);</a>
<a name="ln559"> </a>
<a name="ln560">  /* we can but try.</a>
<a name="ln561">   *</a>
<a name="ln562">   * SunOS, BSD and BSD derived kernels likely will clear ip_id, as</a>
<a name="ln563">   * well as the IP_MF flag, making this all quite pointless.</a>
<a name="ln564">   *</a>
<a name="ln565">   * However, for a system on which IP_MF is left alone, and ip_id left</a>
<a name="ln566">   * alone or else which sets same ip_id for each fragment this might</a>
<a name="ln567">   * work, eg linux.</a>
<a name="ln568">   *</a>
<a name="ln569">   * XXX-TODO: It would be much nicer to have the kernel's use their</a>
<a name="ln570">   * existing fragmentation support to do this for us. Bugs/RFEs need to</a>
<a name="ln571">   * be raised against the various kernels.</a>
<a name="ln572">   */</a>
<a name="ln573">  </a>
<a name="ln574">  /* set More Frag */</a>
<a name="ln575">  iph-&gt;ip_off |= IP_MF;</a>
<a name="ln576">  </a>
<a name="ln577">  /* ip frag offset is expressed in units of 8byte words */</a>
<a name="ln578">  offset = maxdatasize &gt;&gt; OSPF_WRITE_FRAG_SHIFT;</a>
<a name="ln579">  </a>
<a name="ln580">  iovp = &amp;msg-&gt;msg_iov[1];</a>
<a name="ln581">  </a>
<a name="ln582">  while ( (stream_get_endp(op-&gt;s) - stream_get_getp (op-&gt;s)) </a>
<a name="ln583">         &gt; maxdatasize )</a>
<a name="ln584">    {</a>
<a name="ln585">      /* data length of this frag is to next offset value */</a>
<a name="ln586">      iovp-&gt;iov_len = offset &lt;&lt; OSPF_WRITE_FRAG_SHIFT;</a>
<a name="ln587">      iph-&gt;ip_len = iovp-&gt;iov_len + sizeof (struct ip);</a>
<a name="ln588">      assert (iph-&gt;ip_len &lt;= mtu);</a>
<a name="ln589"> </a>
<a name="ln590">      sockopt_iphdrincl_swab_htosys (iph);</a>
<a name="ln591"> </a>
<a name="ln592">      ret = sendmsg (fd, msg, flags);</a>
<a name="ln593">      </a>
<a name="ln594">      sockopt_iphdrincl_swab_systoh (iph);</a>
<a name="ln595">      </a>
<a name="ln596">      if (ret &lt; 0)</a>
<a name="ln597">        zlog_warn (&quot;*** ospf_write_frags: sendmsg failed to %s,&quot;</a>
<a name="ln598">		   &quot; id %d, off %d, len %d, mtu %u failed with %s&quot;,</a>
<a name="ln599">		   inet_ntoa (iph-&gt;ip_dst),</a>
<a name="ln600">		   iph-&gt;ip_id,</a>
<a name="ln601">		   iph-&gt;ip_off,</a>
<a name="ln602">		   iph-&gt;ip_len,</a>
<a name="ln603">		   mtu,</a>
<a name="ln604">		   safe_strerror (errno));</a>
<a name="ln605">      </a>
<a name="ln606">      if (IS_DEBUG_OSPF_PACKET (type - 1, SEND))</a>
<a name="ln607">        {</a>
<a name="ln608">          zlog_debug (&quot;ospf_write_frags: sent id %d, off %d, len %d to %s\n&quot;,</a>
<a name="ln609">                     iph-&gt;ip_id, iph-&gt;ip_off, iph-&gt;ip_len,</a>
<a name="ln610">                     inet_ntoa (iph-&gt;ip_dst));</a>
<a name="ln611">          if (IS_DEBUG_OSPF_PACKET (type - 1, DETAIL))</a>
<a name="ln612">            {</a>
<a name="ln613">              zlog_debug (&quot;-----------------IP Header Dump----------------------&quot;);</a>
<a name="ln614">              ospf_ip_header_dump (iph);</a>
<a name="ln615">              zlog_debug (&quot;-----------------------------------------------------&quot;);</a>
<a name="ln616">            }</a>
<a name="ln617">        }</a>
<a name="ln618">      </a>
<a name="ln619">      iph-&gt;ip_off += offset;</a>
<a name="ln620">      stream_forward_getp (op-&gt;s, iovp-&gt;iov_len);</a>
<a name="ln621">      iovp-&gt;iov_base = STREAM_PNT (op-&gt;s); </a>
<a name="ln622">    }</a>
<a name="ln623">    </a>
<a name="ln624">  /* setup for final fragment */</a>
<a name="ln625">  iovp-&gt;iov_len = stream_get_endp(op-&gt;s) - stream_get_getp (op-&gt;s);</a>
<a name="ln626">  iph-&gt;ip_len = iovp-&gt;iov_len + sizeof (struct ip);</a>
<a name="ln627">  iph-&gt;ip_off &amp;= (~IP_MF);</a>
<a name="ln628">}</a>
<a name="ln629">#endif /* WANT_OSPF_WRITE_FRAGMENT */</a>
<a name="ln630"> </a>
<a name="ln631">static int</a>
<a name="ln632">ospf_write (struct thread *thread)</a>
<a name="ln633">{</a>
<a name="ln634">  struct ospf *ospf = THREAD_ARG (thread);</a>
<a name="ln635">  struct ospf_interface *oi;</a>
<a name="ln636">  struct ospf_packet *op;</a>
<a name="ln637">  struct sockaddr_in sa_dst;</a>
<a name="ln638">  struct ip iph;</a>
<a name="ln639">  struct msghdr msg;</a>
<a name="ln640">  struct iovec iov[2];</a>
<a name="ln641">  u_char type;</a>
<a name="ln642">  int ret;</a>
<a name="ln643">  int flags = 0;</a>
<a name="ln644">  struct listnode *node;</a>
<a name="ln645">#ifdef WANT_OSPF_WRITE_FRAGMENT</a>
<a name="ln646">  static u_int16_t ipid = 0;</a>
<a name="ln647">  u_int16_t maxdatasize;</a>
<a name="ln648">#endif /* WANT_OSPF_WRITE_FRAGMENT */</a>
<a name="ln649">#define OSPF_WRITE_IPHL_SHIFT 2</a>
<a name="ln650">  </a>
<a name="ln651">  ospf-&gt;t_write = NULL;</a>
<a name="ln652"> </a>
<a name="ln653">  node = listhead (ospf-&gt;oi_write_q);</a>
<a name="ln654">  assert (node);</a>
<a name="ln655">  oi = listgetdata (node);</a>
<a name="ln656">  assert (oi);</a>
<a name="ln657"> </a>
<a name="ln658">#ifdef WANT_OSPF_WRITE_FRAGMENT</a>
<a name="ln659">  /* seed ipid static with low order bits of time */</a>
<a name="ln660">  if (ipid == 0)</a>
<a name="ln661">    ipid = (time(NULL) &amp; 0xffff);</a>
<a name="ln662"> </a>
<a name="ln663">  /* convenience - max OSPF data per packet,</a>
<a name="ln664">   * and reliability - not more data, than our</a>
<a name="ln665">   * socket can accept</a>
<a name="ln666">   */</a>
<a name="ln667">  maxdatasize = MIN (oi-&gt;ifp-&gt;mtu, ospf-&gt;maxsndbuflen) -</a>
<a name="ln668">    sizeof (struct ip);</a>
<a name="ln669">#endif /* WANT_OSPF_WRITE_FRAGMENT */</a>
<a name="ln670">  </a>
<a name="ln671">  /* Get one packet from queue. */</a>
<a name="ln672">  op = ospf_fifo_head (oi-&gt;obuf);</a>
<a name="ln673">  assert (op);</a>
<a name="ln674">  assert (op-&gt;length &gt;= OSPF_HEADER_SIZE);</a>
<a name="ln675"> </a>
<a name="ln676">  if (op-&gt;dst.s_addr == htonl (OSPF_ALLSPFROUTERS)</a>
<a name="ln677">      || op-&gt;dst.s_addr == htonl (OSPF_ALLDROUTERS))</a>
<a name="ln678">      ospf_if_ipmulticast (ospf, oi-&gt;address, oi-&gt;ifp-&gt;ifindex);</a>
<a name="ln679">    </a>
<a name="ln680">  /* Rewrite the md5 signature &amp; update the seq */</a>
<a name="ln681">  ospf_make_md5_digest (oi, op);</a>
<a name="ln682"> </a>
<a name="ln683">  /* Retrieve OSPF packet type. */</a>
<a name="ln684">  stream_set_getp (op-&gt;s, 1);</a>
<a name="ln685">  type = stream_getc (op-&gt;s);</a>
<a name="ln686">  </a>
<a name="ln687">  /* reset get pointer */</a>
<a name="ln688">  stream_set_getp (op-&gt;s, 0);</a>
<a name="ln689"> </a>
<a name="ln690">  memset (&amp;iph, 0, sizeof (struct ip));</a>
<a name="ln691">  memset (&amp;sa_dst, 0, sizeof (sa_dst));</a>
<a name="ln692">  </a>
<a name="ln693">  sa_dst.sin_family = AF_INET;</a>
<a name="ln694">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln695">  sa_dst.sin_len = sizeof(sa_dst);</a>
<a name="ln696">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln697">  sa_dst.sin_addr = op-&gt;dst;</a>
<a name="ln698">  sa_dst.sin_port = htons (0);</a>
<a name="ln699"> </a>
<a name="ln700">  /* Set DONTROUTE flag if dst is unicast. */</a>
<a name="ln701">  if (oi-&gt;type != OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln702">    if (!IN_MULTICAST (htonl (op-&gt;dst.s_addr)))</a>
<a name="ln703">      flags = MSG_DONTROUTE;</a>
<a name="ln704"> </a>
<a name="ln705">  iph.ip_hl = sizeof (struct ip) &gt;&gt; OSPF_WRITE_IPHL_SHIFT;</a>
<a name="ln706">  /* it'd be very strange for header to not be 4byte-word aligned but.. */</a>
<a name="ln707">  if ( sizeof (struct ip) </a>
<a name="ln708">        &gt; (unsigned int)(iph.ip_hl &lt;&lt; OSPF_WRITE_IPHL_SHIFT) )</a>
<a name="ln709">    iph.ip_hl++; /* we presume sizeof struct ip cant overflow ip_hl.. */</a>
<a name="ln710">  </a>
<a name="ln711">  iph.ip_v = IPVERSION;</a>
<a name="ln712">  iph.ip_tos = IPTOS_PREC_INTERNETCONTROL;</a>
<a name="ln713">  iph.ip_len = (iph.ip_hl &lt;&lt; OSPF_WRITE_IPHL_SHIFT) + op-&gt;length;</a>
<a name="ln714"> </a>
<a name="ln715">#if defined(__DragonFly__)</a>
<a name="ln716">  /*</a>
<a name="ln717">   * DragonFly's raw socket expects ip_len/ip_off in network byte order.</a>
<a name="ln718">   */</a>
<a name="ln719">  iph.ip_len = htons(iph.ip_len);</a>
<a name="ln720">#endif</a>
<a name="ln721"> </a>
<a name="ln722">#ifdef WANT_OSPF_WRITE_FRAGMENT</a>
<a name="ln723">  /* XXX-MT: not thread-safe at all..</a>
<a name="ln724">   * XXX: this presumes this is only programme sending OSPF packets </a>
<a name="ln725">   * otherwise, no guarantee ipid will be unique</a>
<a name="ln726">   */</a>
<a name="ln727">  iph.ip_id = ++ipid;</a>
<a name="ln728">#endif /* WANT_OSPF_WRITE_FRAGMENT */</a>
<a name="ln729"> </a>
<a name="ln730">  iph.ip_off = 0;</a>
<a name="ln731">  if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln732">    iph.ip_ttl = OSPF_VL_IP_TTL;</a>
<a name="ln733">  else</a>
<a name="ln734">    iph.ip_ttl = OSPF_IP_TTL;</a>
<a name="ln735">  iph.ip_p = IPPROTO_OSPFIGP;</a>
<a name="ln736">  iph.ip_sum = 0;</a>
<a name="ln737">  iph.ip_src.s_addr = oi-&gt;address-&gt;u.prefix4.s_addr;</a>
<a name="ln738">  iph.ip_dst.s_addr = op-&gt;dst.s_addr;</a>
<a name="ln739"> </a>
<a name="ln740">  memset (&amp;msg, 0, sizeof (msg));</a>
<a name="ln741">  msg.msg_name = (caddr_t) &amp;sa_dst;</a>
<a name="ln742">  msg.msg_namelen = sizeof (sa_dst); </a>
<a name="ln743">  msg.msg_iov = iov;</a>
<a name="ln744">  msg.msg_iovlen = 2;</a>
<a name="ln745">  iov[0].iov_base = (char*)&amp;iph;</a>
<a name="ln746">  iov[0].iov_len = iph.ip_hl &lt;&lt; OSPF_WRITE_IPHL_SHIFT;</a>
<a name="ln747">  iov[1].iov_base = STREAM_PNT (op-&gt;s);</a>
<a name="ln748">  iov[1].iov_len = op-&gt;length;</a>
<a name="ln749">  </a>
<a name="ln750">  /* Sadly we can not rely on kernels to fragment packets because of either</a>
<a name="ln751">   * IP_HDRINCL and/or multicast destination being set.</a>
<a name="ln752">   */</a>
<a name="ln753">#ifdef WANT_OSPF_WRITE_FRAGMENT</a>
<a name="ln754">  if ( op-&gt;length &gt; maxdatasize )</a>
<a name="ln755">    ospf_write_frags (ospf-&gt;fd, op, &amp;iph, &amp;msg, maxdatasize, </a>
<a name="ln756">                      oi-&gt;ifp-&gt;mtu, flags, type);</a>
<a name="ln757">#endif /* WANT_OSPF_WRITE_FRAGMENT */</a>
<a name="ln758"> </a>
<a name="ln759">  /* send final fragment (could be first) */</a>
<a name="ln760">  sockopt_iphdrincl_swab_htosys (&amp;iph);</a>
<a name="ln761">  ret = sendmsg (ospf-&gt;fd, &amp;msg, flags);</a>
<a name="ln762">  sockopt_iphdrincl_swab_systoh (&amp;iph);</a>
<a name="ln763">  </a>
<a name="ln764">  if (ret &lt; 0)</a>
<a name="ln765">    zlog_warn (&quot;*** sendmsg in ospf_write failed to %s, &quot;</a>
<a name="ln766">	       &quot;id %d, off %d, len %d, interface %s, mtu %u: %s&quot;,</a>
<a name="ln767">	       inet_ntoa (iph.ip_dst), iph.ip_id, iph.ip_off, iph.ip_len,</a>
<a name="ln768">	       oi-&gt;ifp-&gt;name, oi-&gt;ifp-&gt;mtu, safe_strerror (errno));</a>
<a name="ln769"> </a>
<a name="ln770">  /* Show debug sending packet. */</a>
<a name="ln771">  if (IS_DEBUG_OSPF_PACKET (type - 1, SEND))</a>
<a name="ln772">    {</a>
<a name="ln773">      if (IS_DEBUG_OSPF_PACKET (type - 1, DETAIL))</a>
<a name="ln774">	{</a>
<a name="ln775">	  zlog_debug (&quot;-----------------------------------------------------&quot;);</a>
<a name="ln776">	  ospf_ip_header_dump (&amp;iph);</a>
<a name="ln777">	  stream_set_getp (op-&gt;s, 0);</a>
<a name="ln778">	  ospf_packet_dump (op-&gt;s);</a>
<a name="ln779">	}</a>
<a name="ln780"> </a>
<a name="ln781">      zlog_debug (&quot;%s sent to [%s] via [%s].&quot;,</a>
<a name="ln782">		 LOOKUP (ospf_packet_type_str, type), inet_ntoa (op-&gt;dst),</a>
<a name="ln783">		 IF_NAME (oi));</a>
<a name="ln784"> </a>
<a name="ln785">      if (IS_DEBUG_OSPF_PACKET (type - 1, DETAIL))</a>
<a name="ln786">	zlog_debug (&quot;-----------------------------------------------------&quot;);</a>
<a name="ln787">    }</a>
<a name="ln788"> </a>
<a name="ln789">  /* Now delete packet from queue. */</a>
<a name="ln790">  ospf_packet_delete (oi);</a>
<a name="ln791"> </a>
<a name="ln792">  /* Move this interface to the tail of write_q to</a>
<a name="ln793">	 serve everyone in a round robin fashion */</a>
<a name="ln794">  listnode_move_to_tail (ospf-&gt;oi_write_q, node);</a>
<a name="ln795">  if (ospf_fifo_head (oi-&gt;obuf) == NULL)</a>
<a name="ln796">    {</a>
<a name="ln797">      oi-&gt;on_write_q = 0;</a>
<a name="ln798">      list_delete_node (ospf-&gt;oi_write_q, node);</a>
<a name="ln799">    }</a>
<a name="ln800">  </a>
<a name="ln801">  /* If packets still remain in queue, call write thread. */</a>
<a name="ln802">  if (!list_isempty (ospf-&gt;oi_write_q))</a>
<a name="ln803">    ospf-&gt;t_write =                                              </a>
<a name="ln804">      thread_add_write (master, ospf_write, ospf, ospf-&gt;fd);</a>
<a name="ln805"> </a>
<a name="ln806">  return 0;</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">/* OSPF Hello message read -- RFC2328 Section 10.5. */</a>
<a name="ln810">static void</a>
<a name="ln811">ospf_hello (struct ip *iph, struct ospf_header *ospfh,</a>
<a name="ln812">	    struct stream * s, struct ospf_interface *oi, int size)</a>
<a name="ln813">{</a>
<a name="ln814">  struct ospf_hello *hello;</a>
<a name="ln815">  struct ospf_neighbor *nbr;</a>
<a name="ln816">  int old_state;</a>
<a name="ln817">  struct prefix p;</a>
<a name="ln818"> </a>
<a name="ln819">  /* increment statistics. */</a>
<a name="ln820">  oi-&gt;hello_in++;</a>
<a name="ln821"> </a>
<a name="ln822">  hello = (struct ospf_hello *) STREAM_PNT (s);</a>
<a name="ln823"> </a>
<a name="ln824">  /* If Hello is myself, silently discard. */</a>
<a name="ln825">  if (IPV4_ADDR_SAME (&amp;ospfh-&gt;router_id, &amp;oi-&gt;ospf-&gt;router_id))</a>
<a name="ln826">    {</a>
<a name="ln827">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln828">        {</a>
<a name="ln829">          zlog_debug (&quot;ospf_header[%s/%s]: selforiginated, &quot;</a>
<a name="ln830">                     &quot;dropping.&quot;,</a>
<a name="ln831">                     LOOKUP (ospf_packet_type_str, ospfh-&gt;type),</a>
<a name="ln832">                     inet_ntoa (iph-&gt;ip_src));</a>
<a name="ln833">        }</a>
<a name="ln834">      return;</a>
<a name="ln835">    }</a>
<a name="ln836"> </a>
<a name="ln837">  /* get neighbor prefix. */</a>
<a name="ln838">  p.family = AF_INET;</a>
<a name="ln839">  p.prefixlen = ip_masklen (hello-&gt;network_mask);</a>
<a name="ln840">  p.u.prefix4 = iph-&gt;ip_src;</a>
<a name="ln841"> </a>
<a name="ln842">  /* Compare network mask. */</a>
<a name="ln843">  /* Checking is ignored for Point-to-Point and Virtual link. */</a>
<a name="ln844">  if (oi-&gt;type != OSPF_IFTYPE_POINTOPOINT </a>
<a name="ln845">      &amp;&amp; oi-&gt;type != OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln846">    if (oi-&gt;address-&gt;prefixlen != p.prefixlen)</a>
<a name="ln847">      {</a>
<a name="ln848">	zlog_warn (&quot;Packet %s [Hello:RECV]: NetworkMask mismatch on %s (configured prefix length is %d, but hello packet indicates %d).&quot;,</a>
<a name="ln849">		   inet_ntoa(ospfh-&gt;router_id), IF_NAME(oi),</a>
<a name="ln850">		   (int)oi-&gt;address-&gt;prefixlen, (int)p.prefixlen);</a>
<a name="ln851">	return;</a>
<a name="ln852">      }</a>
<a name="ln853"> </a>
<a name="ln854">  /* Compare Router Dead Interval. */</a>
<a name="ln855">  if (OSPF_IF_PARAM (oi, v_wait) != ntohl (hello-&gt;dead_interval))</a>
<a name="ln856">    {</a>
<a name="ln857">      zlog_warn (&quot;Packet %s [Hello:RECV]: RouterDeadInterval mismatch &quot;</a>
<a name="ln858">      		 &quot;(expected %u, but received %u).&quot;,</a>
<a name="ln859">		 inet_ntoa(ospfh-&gt;router_id),</a>
<a name="ln860">		 OSPF_IF_PARAM(oi, v_wait), ntohl(hello-&gt;dead_interval));</a>
<a name="ln861">      return;</a>
<a name="ln862">    }</a>
<a name="ln863"> </a>
<a name="ln864">  /* Compare Hello Interval - ignored if fast-hellos are set. */</a>
<a name="ln865">  if (OSPF_IF_PARAM (oi, fast_hello) == 0)</a>
<a name="ln866">    {</a>
<a name="ln867">      if (OSPF_IF_PARAM (oi, v_hello) != ntohs (hello-&gt;hello_interval))</a>
<a name="ln868">        {</a>
<a name="ln869">          zlog_warn (&quot;Packet %s [Hello:RECV]: HelloInterval mismatch &quot;</a>
<a name="ln870">		     &quot;(expected %u, but received %u).&quot;,</a>
<a name="ln871">		     inet_ntoa(ospfh-&gt;router_id),</a>
<a name="ln872">		     OSPF_IF_PARAM(oi, v_hello), ntohs(hello-&gt;hello_interval));</a>
<a name="ln873">          return;</a>
<a name="ln874">        }</a>
<a name="ln875">    }</a>
<a name="ln876">  </a>
<a name="ln877">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln878">    zlog_debug (&quot;Packet %s [Hello:RECV]: Options %s&quot;,</a>
<a name="ln879">	       inet_ntoa (ospfh-&gt;router_id),</a>
<a name="ln880">	       ospf_options_dump (hello-&gt;options));</a>
<a name="ln881"> </a>
<a name="ln882">  /* Compare options. */</a>
<a name="ln883">#define REJECT_IF_TBIT_ON	1 /* XXX */</a>
<a name="ln884">#ifdef REJECT_IF_TBIT_ON</a>
<a name="ln885">  if (CHECK_FLAG (hello-&gt;options, OSPF_OPTION_MT))</a>
<a name="ln886">    {</a>
<a name="ln887">      /*</a>
<a name="ln888">       * This router does not support non-zero TOS.</a>
<a name="ln889">       * Drop this Hello packet not to establish neighbor relationship.</a>
<a name="ln890">       */</a>
<a name="ln891">      zlog_warn (&quot;Packet %s [Hello:RECV]: T-bit on, drop it.&quot;,</a>
<a name="ln892">		 inet_ntoa (ospfh-&gt;router_id));</a>
<a name="ln893">      return;</a>
<a name="ln894">    }</a>
<a name="ln895">#endif /* REJECT_IF_TBIT_ON */</a>
<a name="ln896"> </a>
<a name="ln897">  if (CHECK_FLAG (oi-&gt;ospf-&gt;config, OSPF_OPAQUE_CAPABLE)</a>
<a name="ln898">      &amp;&amp; CHECK_FLAG (hello-&gt;options, OSPF_OPTION_O))</a>
<a name="ln899">    {</a>
<a name="ln900">      /*</a>
<a name="ln901">       * This router does know the correct usage of O-bit</a>
<a name="ln902">       * the bit should be set in DD packet only.</a>
<a name="ln903">       */</a>
<a name="ln904">      zlog_warn (&quot;Packet %s [Hello:RECV]: O-bit abuse?&quot;,</a>
<a name="ln905">		 inet_ntoa (ospfh-&gt;router_id));</a>
<a name="ln906">#ifdef STRICT_OBIT_USAGE_CHECK</a>
<a name="ln907">      return;                                     /* Reject this packet. */</a>
<a name="ln908">#else /* STRICT_OBIT_USAGE_CHECK */</a>
<a name="ln909">      UNSET_FLAG (hello-&gt;options, OSPF_OPTION_O); /* Ignore O-bit. */</a>
<a name="ln910">#endif /* STRICT_OBIT_USAGE_CHECK */</a>
<a name="ln911">    }</a>
<a name="ln912"> </a>
<a name="ln913">  /* new for NSSA is to ensure that NP is on and E is off */</a>
<a name="ln914"> </a>
<a name="ln915">  if (oi-&gt;area-&gt;external_routing == OSPF_AREA_NSSA) </a>
<a name="ln916">    {</a>
<a name="ln917">      if (! (CHECK_FLAG (OPTIONS (oi), OSPF_OPTION_NP)</a>
<a name="ln918">	     &amp;&amp; CHECK_FLAG (hello-&gt;options, OSPF_OPTION_NP)</a>
<a name="ln919">	     &amp;&amp; ! CHECK_FLAG (OPTIONS (oi), OSPF_OPTION_E)</a>
<a name="ln920">	     &amp;&amp; ! CHECK_FLAG (hello-&gt;options, OSPF_OPTION_E)))</a>
<a name="ln921">	{</a>
<a name="ln922">	  zlog_warn (&quot;NSSA-Packet-%s[Hello:RECV]: my options: %x, his options %x&quot;, inet_ntoa (ospfh-&gt;router_id), OPTIONS (oi), hello-&gt;options);</a>
<a name="ln923">	  return;</a>
<a name="ln924">	}</a>
<a name="ln925">      if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln926">        zlog_debug (&quot;NSSA-Hello:RECV:Packet from %s:&quot;, inet_ntoa(ospfh-&gt;router_id));</a>
<a name="ln927">    }</a>
<a name="ln928">  else    </a>
<a name="ln929">    /* The setting of the E-bit found in the Hello Packet's Options</a>
<a name="ln930">       field must match this area's ExternalRoutingCapability A</a>
<a name="ln931">       mismatch causes processing to stop and the packet to be</a>
<a name="ln932">       dropped. The setting of the rest of the bits in the Hello</a>
<a name="ln933">       Packet's Options field should be ignored. */</a>
<a name="ln934">    if (CHECK_FLAG (OPTIONS (oi), OSPF_OPTION_E) !=</a>
<a name="ln935">	CHECK_FLAG (hello-&gt;options, OSPF_OPTION_E))</a>
<a name="ln936">      {</a>
<a name="ln937">	zlog_warn (&quot;Packet %s [Hello:RECV]: my options: %x, his options %x&quot;,</a>
<a name="ln938">		   inet_ntoa(ospfh-&gt;router_id), OPTIONS (oi), hello-&gt;options);</a>
<a name="ln939">	return;</a>
<a name="ln940">      }</a>
<a name="ln941">  </a>
<a name="ln942">  /* get neighbour struct */</a>
<a name="ln943">  nbr = ospf_nbr_get (oi, ospfh, iph, &amp;p);</a>
<a name="ln944"> </a>
<a name="ln945">  /* neighbour must be valid, ospf_nbr_get creates if none existed */</a>
<a name="ln946">  assert (nbr);</a>
<a name="ln947"> </a>
<a name="ln948">  old_state = nbr-&gt;state;</a>
<a name="ln949"> </a>
<a name="ln950">  /* Add event to thread. */</a>
<a name="ln951">  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);</a>
<a name="ln952"> </a>
<a name="ln953">  /*  RFC2328  Section 9.5.1</a>
<a name="ln954">      If the router is not eligible to become Designated Router,</a>
<a name="ln955">      (snip)   It	must also send an Hello	Packet in reply	to an</a>
<a name="ln956">      Hello Packet received from any eligible neighbor (other than</a>
<a name="ln957">      the	current	Designated Router and Backup Designated	Router).  */</a>
<a name="ln958">  if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln959">    if (PRIORITY(oi) == 0 &amp;&amp; hello-&gt;priority &gt; 0</a>
<a name="ln960">	&amp;&amp; IPV4_ADDR_CMP(&amp;DR(oi),  &amp;iph-&gt;ip_src)</a>
<a name="ln961">	&amp;&amp; IPV4_ADDR_CMP(&amp;BDR(oi), &amp;iph-&gt;ip_src))</a>
<a name="ln962">      OSPF_NSM_TIMER_ON (nbr-&gt;t_hello_reply, ospf_hello_reply_timer,</a>
<a name="ln963">			 OSPF_HELLO_REPLY_DELAY);</a>
<a name="ln964"> </a>
<a name="ln965">  /* on NBMA network type, it happens to receive bidirectional Hello packet</a>
<a name="ln966">     without advance 1-Way Received event.</a>
<a name="ln967">     To avoid incorrect DR-seletion, raise 1-Way Received event.*/</a>
<a name="ln968">  if (oi-&gt;type == OSPF_IFTYPE_NBMA &amp;&amp;</a>
<a name="ln969">      (old_state == NSM_Down || old_state == NSM_Attempt))</a>
<a name="ln970">    {</a>
<a name="ln971">      OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_OneWayReceived);</a>
<a name="ln972">      nbr-&gt;priority = hello-&gt;priority;</a>
<a name="ln973">      nbr-&gt;d_router = hello-&gt;d_router;</a>
<a name="ln974">      nbr-&gt;bd_router = hello-&gt;bd_router;</a>
<a name="ln975">      return;</a>
<a name="ln976">    }</a>
<a name="ln977"> </a>
<a name="ln978">  if (ospf_nbr_bidirectional (&amp;oi-&gt;ospf-&gt;router_id, hello-&gt;neighbors,</a>
<a name="ln979">			      size - OSPF_HELLO_MIN_SIZE))</a>
<a name="ln980">    {</a>
<a name="ln981">      OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_TwoWayReceived);</a>
<a name="ln982">      nbr-&gt;options |= hello-&gt;options;</a>
<a name="ln983">    }</a>
<a name="ln984">  else</a>
<a name="ln985">    {</a>
<a name="ln986">      OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_OneWayReceived);</a>
<a name="ln987">      /* Set neighbor information. */</a>
<a name="ln988">      nbr-&gt;priority = hello-&gt;priority;</a>
<a name="ln989">      nbr-&gt;d_router = hello-&gt;d_router;</a>
<a name="ln990">      nbr-&gt;bd_router = hello-&gt;bd_router;</a>
<a name="ln991">      return;</a>
<a name="ln992">    }</a>
<a name="ln993"> </a>
<a name="ln994">  /* If neighbor itself declares DR and no BDR exists,</a>
<a name="ln995">     cause event BackupSeen */</a>
<a name="ln996">  if (IPV4_ADDR_SAME (&amp;nbr-&gt;address.u.prefix4, &amp;hello-&gt;d_router))</a>
<a name="ln997">    if (hello-&gt;bd_router.s_addr == 0 &amp;&amp; oi-&gt;state == ISM_Waiting)</a>
<a name="ln998">      OSPF_ISM_EVENT_SCHEDULE (oi, ISM_BackupSeen);</a>
<a name="ln999"> </a>
<a name="ln1000">  /* neighbor itself declares BDR. */</a>
<a name="ln1001">  if (oi-&gt;state == ISM_Waiting &amp;&amp;</a>
<a name="ln1002">      IPV4_ADDR_SAME (&amp;nbr-&gt;address.u.prefix4, &amp;hello-&gt;bd_router))</a>
<a name="ln1003">    OSPF_ISM_EVENT_SCHEDULE (oi, ISM_BackupSeen);</a>
<a name="ln1004"> </a>
<a name="ln1005">  /* had not previously. */</a>
<a name="ln1006">  if ((IPV4_ADDR_SAME (&amp;nbr-&gt;address.u.prefix4, &amp;hello-&gt;d_router) &amp;&amp;</a>
<a name="ln1007">       IPV4_ADDR_CMP (&amp;nbr-&gt;address.u.prefix4, &amp;nbr-&gt;d_router)) ||</a>
<a name="ln1008">      (IPV4_ADDR_CMP (&amp;nbr-&gt;address.u.prefix4, &amp;hello-&gt;d_router) &amp;&amp;</a>
<a name="ln1009">       IPV4_ADDR_SAME (&amp;nbr-&gt;address.u.prefix4, &amp;nbr-&gt;d_router)))</a>
<a name="ln1010">    OSPF_ISM_EVENT_SCHEDULE (oi, ISM_NeighborChange);</a>
<a name="ln1011"> </a>
<a name="ln1012">  /* had not previously. */</a>
<a name="ln1013">  if ((IPV4_ADDR_SAME (&amp;nbr-&gt;address.u.prefix4, &amp;hello-&gt;bd_router) &amp;&amp;</a>
<a name="ln1014">       IPV4_ADDR_CMP (&amp;nbr-&gt;address.u.prefix4, &amp;nbr-&gt;bd_router)) ||</a>
<a name="ln1015">      (IPV4_ADDR_CMP (&amp;nbr-&gt;address.u.prefix4, &amp;hello-&gt;bd_router) &amp;&amp;</a>
<a name="ln1016">       IPV4_ADDR_SAME (&amp;nbr-&gt;address.u.prefix4, &amp;nbr-&gt;bd_router)))</a>
<a name="ln1017">    OSPF_ISM_EVENT_SCHEDULE (oi, ISM_NeighborChange);</a>
<a name="ln1018"> </a>
<a name="ln1019">  /* Neighbor priority check. */</a>
<a name="ln1020">  if (nbr-&gt;priority &gt;= 0 &amp;&amp; nbr-&gt;priority != hello-&gt;priority)</a>
<a name="ln1021">    OSPF_ISM_EVENT_SCHEDULE (oi, ISM_NeighborChange);</a>
<a name="ln1022"> </a>
<a name="ln1023">  /* Set neighbor information. */</a>
<a name="ln1024">  nbr-&gt;priority = hello-&gt;priority;</a>
<a name="ln1025">  nbr-&gt;d_router = hello-&gt;d_router;</a>
<a name="ln1026">  nbr-&gt;bd_router = hello-&gt;bd_router;</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029">/* Save DD flags/options/Seqnum received. */</a>
<a name="ln1030">static void</a>
<a name="ln1031">ospf_db_desc_save_current (struct ospf_neighbor *nbr,</a>
<a name="ln1032">			   struct ospf_db_desc *dd)</a>
<a name="ln1033">{</a>
<a name="ln1034">  nbr-&gt;last_recv.flags = dd-&gt;flags;</a>
<a name="ln1035">  nbr-&gt;last_recv.options = dd-&gt;options;</a>
<a name="ln1036">  nbr-&gt;last_recv.dd_seqnum = ntohl (dd-&gt;dd_seqnum);</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">/* Process rest of DD packet. */</a>
<a name="ln1040">static void</a>
<a name="ln1041">ospf_db_desc_proc (struct stream *s, struct ospf_interface *oi,</a>
<a name="ln1042">		   struct ospf_neighbor *nbr, struct ospf_db_desc *dd,</a>
<a name="ln1043">		   u_int16_t size)</a>
<a name="ln1044">{</a>
<a name="ln1045">  struct ospf_lsa *new, *find;</a>
<a name="ln1046">  struct lsa_header *lsah;</a>
<a name="ln1047"> </a>
<a name="ln1048">  stream_forward_getp (s, OSPF_DB_DESC_MIN_SIZE);</a>
<a name="ln1049">  for (size -= OSPF_DB_DESC_MIN_SIZE;</a>
<a name="ln1050">       size &gt;= OSPF_LSA_HEADER_SIZE; size -= OSPF_LSA_HEADER_SIZE) </a>
<a name="ln1051">    {</a>
<a name="ln1052">      lsah = (struct lsa_header *) STREAM_PNT (s);</a>
<a name="ln1053">      stream_forward_getp (s, OSPF_LSA_HEADER_SIZE);</a>
<a name="ln1054"> </a>
<a name="ln1055">      /* Unknown LS type. */</a>
<a name="ln1056">      if (lsah-&gt;type &lt; OSPF_MIN_LSA || lsah-&gt;type &gt;= OSPF_MAX_LSA)</a>
<a name="ln1057">	{</a>
<a name="ln1058">	  zlog_warn (&quot;Packet [DD:RECV]: Unknown LS type %d.&quot;, lsah-&gt;type);</a>
<a name="ln1059">	  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_SeqNumberMismatch);</a>
<a name="ln1060">	  return;</a>
<a name="ln1061">	}</a>
<a name="ln1062"> </a>
<a name="ln1063">      if (IS_OPAQUE_LSA (lsah-&gt;type)</a>
<a name="ln1064">      &amp;&amp;  ! CHECK_FLAG (nbr-&gt;options, OSPF_OPTION_O))</a>
<a name="ln1065">        {</a>
<a name="ln1066">          zlog_warn (&quot;LSA[Type%d:%s]: Opaque capability mismatch?&quot;, lsah-&gt;type, inet_ntoa (lsah-&gt;id));</a>
<a name="ln1067">          OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_SeqNumberMismatch);</a>
<a name="ln1068">          return;</a>
<a name="ln1069">        }</a>
<a name="ln1070"> </a>
<a name="ln1071">      switch (lsah-&gt;type)</a>
<a name="ln1072">        {</a>
<a name="ln1073">        case OSPF_AS_EXTERNAL_LSA:</a>
<a name="ln1074">	case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln1075">          /* Check for stub area.  Reject if AS-External from stub but</a>
<a name="ln1076">             allow if from NSSA. */</a>
<a name="ln1077">          if (oi-&gt;area-&gt;external_routing == OSPF_AREA_STUB)</a>
<a name="ln1078">            {</a>
<a name="ln1079">              zlog_warn (&quot;Packet [DD:RECV]: LSA[Type%d:%s] from %s area.&quot;,</a>
<a name="ln1080">                         lsah-&gt;type, inet_ntoa (lsah-&gt;id),</a>
<a name="ln1081">                         (oi-&gt;area-&gt;external_routing == OSPF_AREA_STUB) ?\</a>
<a name="ln1082">                         &quot;STUB&quot; : &quot;NSSA&quot;);</a>
<a name="ln1083">              OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_SeqNumberMismatch);</a>
<a name="ln1084">              return;</a>
<a name="ln1085">            }</a>
<a name="ln1086">          break;</a>
<a name="ln1087">	default:</a>
<a name="ln1088">	  break;</a>
<a name="ln1089">        }</a>
<a name="ln1090"> </a>
<a name="ln1091">      /* Create LS-request object. */</a>
<a name="ln1092">      new = ospf_ls_request_new (lsah);</a>
<a name="ln1093"> </a>
<a name="ln1094">      /* Lookup received LSA, then add LS request list. */</a>
<a name="ln1095">      find = ospf_lsa_lookup_by_header (oi-&gt;area, lsah);</a>
<a name="ln1096">      </a>
<a name="ln1097">      /* ospf_lsa_more_recent is fine with NULL pointers */</a>
<a name="ln1098">      switch (ospf_lsa_more_recent (find, new))</a>
<a name="ln1099">        {</a>
<a name="ln1100">          case -1:</a>
<a name="ln1101">            /* Neighbour has a more recent LSA, we must request it */</a>
<a name="ln1102">            ospf_ls_request_add (nbr, new);</a>
<a name="ln1103">          case 0:</a>
<a name="ln1104">            /* If we have a copy of this LSA, it's either less recent</a>
<a name="ln1105">             * and we're requesting it from neighbour (the case above), or</a>
<a name="ln1106">             * it's as recent and we both have same copy (this case).</a>
<a name="ln1107">             *</a>
<a name="ln1108">             * In neither of these two cases is there any point in</a>
<a name="ln1109">             * describing our copy of the LSA to the neighbour in a</a>
<a name="ln1110">             * DB-Summary packet, if we're still intending to do so.</a>
<a name="ln1111">             *</a>
<a name="ln1112">             * See: draft-ogier-ospf-dbex-opt-00.txt, describing the</a>
<a name="ln1113">             * backward compatible optimisation to OSPF DB Exchange /</a>
<a name="ln1114">             * DB Description process implemented here.</a>
<a name="ln1115">             */</a>
<a name="ln1116">            if (find)</a>
<a name="ln1117">              ospf_lsdb_delete (&amp;nbr-&gt;db_sum, find);</a>
<a name="ln1118">            ospf_lsa_discard (new);</a>
<a name="ln1119">            break;</a>
<a name="ln1120">          default:</a>
<a name="ln1121">            /* We have the more recent copy, nothing specific to do:</a>
<a name="ln1122">             * - no need to request neighbours stale copy</a>
<a name="ln1123">             * - must leave DB summary list copy alone</a>
<a name="ln1124">             */</a>
<a name="ln1125">            if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1126">              zlog_debug (&quot;Packet [DD:RECV]: LSA received Type %d, &quot;</a>
<a name="ln1127">                         &quot;ID %s is not recent.&quot;, lsah-&gt;type, inet_ntoa (lsah-&gt;id));</a>
<a name="ln1128">            ospf_lsa_discard (new);</a>
<a name="ln1129">        }</a>
<a name="ln1130">    }</a>
<a name="ln1131"> </a>
<a name="ln1132">  /* Master */</a>
<a name="ln1133">  if (IS_SET_DD_MS (nbr-&gt;dd_flags))</a>
<a name="ln1134">    {</a>
<a name="ln1135">      nbr-&gt;dd_seqnum++;</a>
<a name="ln1136"> </a>
<a name="ln1137">      /* Both sides have no More, then we're done with Exchange */</a>
<a name="ln1138">      if (!IS_SET_DD_M (dd-&gt;flags) &amp;&amp; !IS_SET_DD_M (nbr-&gt;dd_flags))</a>
<a name="ln1139">	OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_ExchangeDone);</a>
<a name="ln1140">      else</a>
<a name="ln1141">	ospf_db_desc_send (nbr);</a>
<a name="ln1142">    }</a>
<a name="ln1143">  /* Slave */</a>
<a name="ln1144">  else</a>
<a name="ln1145">    {</a>
<a name="ln1146">      nbr-&gt;dd_seqnum = ntohl (dd-&gt;dd_seqnum);</a>
<a name="ln1147"> </a>
<a name="ln1148">      /* Send DD packet in reply. </a>
<a name="ln1149">       * </a>
<a name="ln1150">       * Must be done to acknowledge the Master's DD, regardless of</a>
<a name="ln1151">       * whether we have more LSAs ourselves to describe.</a>
<a name="ln1152">       *</a>
<a name="ln1153">       * This function will clear the 'More' bit, if after this DD</a>
<a name="ln1154">       * we have no more LSAs to describe to the master..</a>
<a name="ln1155">       */</a>
<a name="ln1156">      ospf_db_desc_send (nbr);</a>
<a name="ln1157">      </a>
<a name="ln1158">      /* Slave can raise ExchangeDone now, if master is also done */</a>
<a name="ln1159">      if (!IS_SET_DD_M (dd-&gt;flags) &amp;&amp; !IS_SET_DD_M (nbr-&gt;dd_flags))</a>
<a name="ln1160">	OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_ExchangeDone);</a>
<a name="ln1161">    }</a>
<a name="ln1162">  </a>
<a name="ln1163">  /* Save received neighbor values from DD. */</a>
<a name="ln1164">  ospf_db_desc_save_current (nbr, dd);</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167">static int</a>
<a name="ln1168">ospf_db_desc_is_dup (struct ospf_db_desc *dd, struct ospf_neighbor *nbr)</a>
<a name="ln1169">{</a>
<a name="ln1170">  /* Is DD duplicated? */</a>
<a name="ln1171">  if (dd-&gt;options == nbr-&gt;last_recv.options &amp;&amp;</a>
<a name="ln1172">      dd-&gt;flags == nbr-&gt;last_recv.flags &amp;&amp;</a>
<a name="ln1173">      dd-&gt;dd_seqnum == htonl (nbr-&gt;last_recv.dd_seqnum))</a>
<a name="ln1174">    return 1;</a>
<a name="ln1175"> </a>
<a name="ln1176">  return 0;</a>
<a name="ln1177">}</a>
<a name="ln1178"> </a>
<a name="ln1179">/* OSPF Database Description message read -- RFC2328 Section 10.6. */</a>
<a name="ln1180">static void</a>
<a name="ln1181">ospf_db_desc (struct ip *iph, struct ospf_header *ospfh,</a>
<a name="ln1182">	      struct stream *s, struct ospf_interface *oi, u_int16_t size)</a>
<a name="ln1183">{</a>
<a name="ln1184">  struct ospf_db_desc *dd;</a>
<a name="ln1185">  struct ospf_neighbor *nbr;</a>
<a name="ln1186"> </a>
<a name="ln1187">  /* Increment statistics. */</a>
<a name="ln1188">  oi-&gt;db_desc_in++;</a>
<a name="ln1189"> </a>
<a name="ln1190">  dd = (struct ospf_db_desc *) STREAM_PNT (s);</a>
<a name="ln1191"> </a>
<a name="ln1192">  nbr = ospf_nbr_lookup (oi, iph, ospfh);</a>
<a name="ln1193">  if (nbr == NULL)</a>
<a name="ln1194">    {</a>
<a name="ln1195">      zlog_warn (&quot;Packet[DD]: Unknown Neighbor %s&quot;,</a>
<a name="ln1196">		 inet_ntoa (ospfh-&gt;router_id));</a>
<a name="ln1197">      return;</a>
<a name="ln1198">    }</a>
<a name="ln1199"> </a>
<a name="ln1200">  /* Check MTU. */</a>
<a name="ln1201">  if ((OSPF_IF_PARAM (oi, mtu_ignore) == 0) &amp;&amp; </a>
<a name="ln1202">      (ntohs (dd-&gt;mtu) &gt; oi-&gt;ifp-&gt;mtu))</a>
<a name="ln1203">    {</a>
<a name="ln1204">      zlog_warn (&quot;Packet[DD]: Neighbor %s MTU %u is larger than [%s]'s MTU %u&quot;,</a>
<a name="ln1205">		 inet_ntoa (nbr-&gt;router_id), ntohs (dd-&gt;mtu),</a>
<a name="ln1206">		 IF_NAME (oi), oi-&gt;ifp-&gt;mtu);</a>
<a name="ln1207">      return;</a>
<a name="ln1208">    }</a>
<a name="ln1209"> </a>
<a name="ln1210">  /* </a>
<a name="ln1211">   * XXX HACK by Hasso Tepper. Setting N/P bit in NSSA area DD packets is not</a>
<a name="ln1212">   * required. In fact at least JunOS sends DD packets with P bit clear. </a>
<a name="ln1213">   * Until proper solution is developped, this hack should help.</a>
<a name="ln1214">   *</a>
<a name="ln1215">   * Update: According to the RFCs, N bit is specified /only/ for Hello</a>
<a name="ln1216">   * options, unfortunately its use in DD options is not specified. Hence some</a>
<a name="ln1217">   * implementations follow E-bit semantics and set it in DD options, and some</a>
<a name="ln1218">   * treat it as unspecified and hence follow the directive &quot;default for </a>
<a name="ln1219">   * options is clear&quot;, ie unset.</a>
<a name="ln1220">   *</a>
<a name="ln1221">   * Reset the flag, as ospfd follows E-bit semantics.</a>
<a name="ln1222">   */</a>
<a name="ln1223">  if ( (oi-&gt;area-&gt;external_routing == OSPF_AREA_NSSA)</a>
<a name="ln1224">       &amp;&amp; (CHECK_FLAG (nbr-&gt;options, OSPF_OPTION_NP))</a>
<a name="ln1225">       &amp;&amp; (!CHECK_FLAG (dd-&gt;options, OSPF_OPTION_NP)) )</a>
<a name="ln1226">    {</a>
<a name="ln1227">      if (IS_DEBUG_OSPF_EVENT) </a>
<a name="ln1228">        zlog_debug (&quot;Packet[DD]: Neighbour %s: Has NSSA capability, sends with N bit clear in DD options&quot;,</a>
<a name="ln1229">                    inet_ntoa (nbr-&gt;router_id) );</a>
<a name="ln1230">      SET_FLAG (dd-&gt;options, OSPF_OPTION_NP);</a>
<a name="ln1231">    }</a>
<a name="ln1232"> </a>
<a name="ln1233">#ifdef REJECT_IF_TBIT_ON</a>
<a name="ln1234">  if (CHECK_FLAG (dd-&gt;options, OSPF_OPTION_MT))</a>
<a name="ln1235">    {</a>
<a name="ln1236">      /*</a>
<a name="ln1237">       * In Hello protocol, optional capability must have checked</a>
<a name="ln1238">       * to prevent this T-bit enabled router be my neighbor.</a>
<a name="ln1239">       */</a>
<a name="ln1240">      zlog_warn (&quot;Packet[DD]: Neighbor %s: T-bit on?&quot;, inet_ntoa (nbr-&gt;router_id));</a>
<a name="ln1241">      return;</a>
<a name="ln1242">    }</a>
<a name="ln1243">#endif /* REJECT_IF_TBIT_ON */</a>
<a name="ln1244"> </a>
<a name="ln1245">  if (CHECK_FLAG (dd-&gt;options, OSPF_OPTION_O)</a>
<a name="ln1246">      &amp;&amp; !CHECK_FLAG (oi-&gt;ospf-&gt;config, OSPF_OPAQUE_CAPABLE))</a>
<a name="ln1247">    {</a>
<a name="ln1248">      /*</a>
<a name="ln1249">       * This node is not configured to handle O-bit, for now.</a>
<a name="ln1250">       * Clear it to ignore unsupported capability proposed by neighbor.</a>
<a name="ln1251">       */</a>
<a name="ln1252">      UNSET_FLAG (dd-&gt;options, OSPF_OPTION_O);</a>
<a name="ln1253">    }</a>
<a name="ln1254"> </a>
<a name="ln1255">  /* Add event to thread. */</a>
<a name="ln1256">  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);</a>
<a name="ln1257"> </a>
<a name="ln1258">  /* Process DD packet by neighbor status. */</a>
<a name="ln1259">  switch (nbr-&gt;state)</a>
<a name="ln1260">    {</a>
<a name="ln1261">    case NSM_Down:</a>
<a name="ln1262">    case NSM_Attempt:</a>
<a name="ln1263">    case NSM_TwoWay:</a>
<a name="ln1264">      zlog_warn (&quot;Packet[DD]: Neighbor %s state is %s, packet discarded.&quot;,</a>
<a name="ln1265">		 inet_ntoa(nbr-&gt;router_id),</a>
<a name="ln1266">		 LOOKUP (ospf_nsm_state_msg, nbr-&gt;state));</a>
<a name="ln1267">      break;</a>
<a name="ln1268">    case NSM_Init:</a>
<a name="ln1269">      OSPF_NSM_EVENT_EXECUTE (nbr, NSM_TwoWayReceived);</a>
<a name="ln1270">      /* If the new state is ExStart, the processing of the current</a>
<a name="ln1271">	 packet should then continue in this new state by falling</a>
<a name="ln1272">	 through to case ExStart below.  */</a>
<a name="ln1273">      if (nbr-&gt;state != NSM_ExStart)</a>
<a name="ln1274">	break;</a>
<a name="ln1275">    case NSM_ExStart:</a>
<a name="ln1276">      /* Initial DBD */</a>
<a name="ln1277">      if ((IS_SET_DD_ALL (dd-&gt;flags) == OSPF_DD_FLAG_ALL) &amp;&amp;</a>
<a name="ln1278">	  (size == OSPF_DB_DESC_MIN_SIZE))</a>
<a name="ln1279">	{</a>
<a name="ln1280">	  if (IPV4_ADDR_CMP (&amp;nbr-&gt;router_id, &amp;oi-&gt;ospf-&gt;router_id) &gt; 0)</a>
<a name="ln1281">	    {</a>
<a name="ln1282">	      /* We're Slave---obey */</a>
<a name="ln1283">	      zlog_info (&quot;Packet[DD]: Neighbor %s Negotiation done (Slave).&quot;,</a>
<a name="ln1284">	      		 inet_ntoa(nbr-&gt;router_id));</a>
<a name="ln1285">	      nbr-&gt;dd_seqnum = ntohl (dd-&gt;dd_seqnum);</a>
<a name="ln1286">	      </a>
<a name="ln1287">	      /* Reset I/MS */</a>
<a name="ln1288">	      UNSET_FLAG (nbr-&gt;dd_flags, (OSPF_DD_FLAG_MS|OSPF_DD_FLAG_I));</a>
<a name="ln1289">	    }</a>
<a name="ln1290">	  else</a>
<a name="ln1291">	    {</a>
<a name="ln1292">	      /* We're Master, ignore the initial DBD from Slave */</a>
<a name="ln1293">	      zlog_info (&quot;Packet[DD]: Neighbor %s: Initial DBD from Slave, &quot;</a>
<a name="ln1294">	      		 &quot;ignoring.&quot;, inet_ntoa(nbr-&gt;router_id));</a>
<a name="ln1295">	      break;</a>
<a name="ln1296">	    }</a>
<a name="ln1297">	}</a>
<a name="ln1298">      /* Ack from the Slave */</a>
<a name="ln1299">      else if (!IS_SET_DD_MS (dd-&gt;flags) &amp;&amp; !IS_SET_DD_I (dd-&gt;flags) &amp;&amp;</a>
<a name="ln1300">	       ntohl (dd-&gt;dd_seqnum) == nbr-&gt;dd_seqnum &amp;&amp;</a>
<a name="ln1301">	       IPV4_ADDR_CMP (&amp;nbr-&gt;router_id, &amp;oi-&gt;ospf-&gt;router_id) &lt; 0)</a>
<a name="ln1302">	{</a>
<a name="ln1303">	  zlog_info (&quot;Packet[DD]: Neighbor %s Negotiation done (Master).&quot;,</a>
<a name="ln1304">		     inet_ntoa(nbr-&gt;router_id));</a>
<a name="ln1305">          /* Reset I, leaving MS */</a>
<a name="ln1306">          UNSET_FLAG (nbr-&gt;dd_flags, OSPF_DD_FLAG_I);</a>
<a name="ln1307">	}</a>
<a name="ln1308">      else</a>
<a name="ln1309">	{</a>
<a name="ln1310">	  zlog_warn (&quot;Packet[DD]: Neighbor %s Negotiation fails.&quot;,</a>
<a name="ln1311">		     inet_ntoa(nbr-&gt;router_id));</a>
<a name="ln1312">	  break;</a>
<a name="ln1313">	}</a>
<a name="ln1314">      </a>
<a name="ln1315">      /* This is where the real Options are saved */</a>
<a name="ln1316">      nbr-&gt;options = dd-&gt;options;</a>
<a name="ln1317"> </a>
<a name="ln1318">      if (CHECK_FLAG (oi-&gt;ospf-&gt;config, OSPF_OPAQUE_CAPABLE))</a>
<a name="ln1319">        {</a>
<a name="ln1320">          if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1321">            zlog_debug (&quot;Neighbor[%s] is %sOpaque-capable.&quot;,</a>
<a name="ln1322">		       inet_ntoa (nbr-&gt;router_id),</a>
<a name="ln1323">		       CHECK_FLAG (nbr-&gt;options, OSPF_OPTION_O) ? &quot;&quot; : &quot;NOT &quot;);</a>
<a name="ln1324"> </a>
<a name="ln1325">          if (! CHECK_FLAG (nbr-&gt;options, OSPF_OPTION_O)</a>
<a name="ln1326">          &amp;&amp;  IPV4_ADDR_SAME (&amp;DR (oi), &amp;nbr-&gt;address.u.prefix4))</a>
<a name="ln1327">            {</a>
<a name="ln1328">              zlog_warn (&quot;DR-neighbor[%s] is NOT opaque-capable; &quot;</a>
<a name="ln1329">                         &quot;Opaque-LSAs cannot be reliably advertised &quot;</a>
<a name="ln1330">                         &quot;in this network.&quot;,</a>
<a name="ln1331">                         inet_ntoa (nbr-&gt;router_id));</a>
<a name="ln1332">              /* This situation is undesirable, but not a real error. */</a>
<a name="ln1333">            }</a>
<a name="ln1334">        }</a>
<a name="ln1335"> </a>
<a name="ln1336">      OSPF_NSM_EVENT_EXECUTE (nbr, NSM_NegotiationDone);</a>
<a name="ln1337"> </a>
<a name="ln1338">      /* continue processing rest of packet. */</a>
<a name="ln1339">      ospf_db_desc_proc (s, oi, nbr, dd, size);</a>
<a name="ln1340">      break;</a>
<a name="ln1341">    case NSM_Exchange:</a>
<a name="ln1342">      if (ospf_db_desc_is_dup (dd, nbr))</a>
<a name="ln1343">	{</a>
<a name="ln1344">	  if (IS_SET_DD_MS (nbr-&gt;dd_flags))</a>
<a name="ln1345">	    /* Master: discard duplicated DD packet. */</a>
<a name="ln1346">	    zlog_info (&quot;Packet[DD] (Master): Neighbor %s packet duplicated.&quot;,</a>
<a name="ln1347">		       inet_ntoa (nbr-&gt;router_id));</a>
<a name="ln1348">	  else</a>
<a name="ln1349">	    /* Slave: cause to retransmit the last Database Description. */</a>
<a name="ln1350">	    {</a>
<a name="ln1351">	      zlog_info (&quot;Packet[DD] [Slave]: Neighbor %s packet duplicated.&quot;,</a>
<a name="ln1352">			 inet_ntoa (nbr-&gt;router_id));</a>
<a name="ln1353">	      ospf_db_desc_resend (nbr);</a>
<a name="ln1354">	    }</a>
<a name="ln1355">	  break;</a>
<a name="ln1356">	}</a>
<a name="ln1357"> </a>
<a name="ln1358">      /* Otherwise DD packet should be checked. */</a>
<a name="ln1359">      /* Check Master/Slave bit mismatch */</a>
<a name="ln1360">      if (IS_SET_DD_MS (dd-&gt;flags) != IS_SET_DD_MS (nbr-&gt;last_recv.flags))</a>
<a name="ln1361">	{</a>
<a name="ln1362">	  zlog_warn (&quot;Packet[DD]: Neighbor %s MS-bit mismatch.&quot;,</a>
<a name="ln1363">		     inet_ntoa(nbr-&gt;router_id));</a>
<a name="ln1364">	  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_SeqNumberMismatch);</a>
<a name="ln1365">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1366">	    zlog_debug (&quot;Packet[DD]: dd-&gt;flags=%d, nbr-&gt;dd_flags=%d&quot;,</a>
<a name="ln1367">		        dd-&gt;flags, nbr-&gt;dd_flags);</a>
<a name="ln1368">	  break;</a>
<a name="ln1369">	}</a>
<a name="ln1370"> </a>
<a name="ln1371">      /* Check initialize bit is set. */</a>
<a name="ln1372">      if (IS_SET_DD_I (dd-&gt;flags))</a>
<a name="ln1373">	{</a>
<a name="ln1374">	  zlog_info (&quot;Packet[DD]: Neighbor %s I-bit set.&quot;,</a>
<a name="ln1375">		     inet_ntoa(nbr-&gt;router_id));</a>
<a name="ln1376">	  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_SeqNumberMismatch);</a>
<a name="ln1377">	  break;</a>
<a name="ln1378">	}</a>
<a name="ln1379"> </a>
<a name="ln1380">      /* Check DD Options. */</a>
<a name="ln1381">      if (dd-&gt;options != nbr-&gt;options)</a>
<a name="ln1382">	{</a>
<a name="ln1383">#ifdef ORIGINAL_CODING</a>
<a name="ln1384">	  /* Save the new options for debugging */</a>
<a name="ln1385">	  nbr-&gt;options = dd-&gt;options;</a>
<a name="ln1386">#endif /* ORIGINAL_CODING */</a>
<a name="ln1387">	  zlog_warn (&quot;Packet[DD]: Neighbor %s options mismatch.&quot;,</a>
<a name="ln1388">		     inet_ntoa(nbr-&gt;router_id));</a>
<a name="ln1389">	  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_SeqNumberMismatch);</a>
<a name="ln1390">	  break;</a>
<a name="ln1391">	}</a>
<a name="ln1392"> </a>
<a name="ln1393">      /* Check DD sequence number. */</a>
<a name="ln1394">      if ((IS_SET_DD_MS (nbr-&gt;dd_flags) &amp;&amp;</a>
<a name="ln1395">	   ntohl (dd-&gt;dd_seqnum) != nbr-&gt;dd_seqnum) ||</a>
<a name="ln1396">	  (!IS_SET_DD_MS (nbr-&gt;dd_flags) &amp;&amp;</a>
<a name="ln1397">	   ntohl (dd-&gt;dd_seqnum) != nbr-&gt;dd_seqnum + 1))</a>
<a name="ln1398">	{</a>
<a name="ln1399">	  zlog_warn (&quot;Packet[DD]: Neighbor %s sequence number mismatch.&quot;,</a>
<a name="ln1400">		     inet_ntoa(nbr-&gt;router_id));</a>
<a name="ln1401">	  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_SeqNumberMismatch);</a>
<a name="ln1402">	  break;</a>
<a name="ln1403">	}</a>
<a name="ln1404"> </a>
<a name="ln1405">      /* Continue processing rest of packet. */</a>
<a name="ln1406">      ospf_db_desc_proc (s, oi, nbr, dd, size);</a>
<a name="ln1407">      break;</a>
<a name="ln1408">    case NSM_Loading:</a>
<a name="ln1409">    case NSM_Full:</a>
<a name="ln1410">      if (ospf_db_desc_is_dup (dd, nbr))</a>
<a name="ln1411">	{</a>
<a name="ln1412">	  if (IS_SET_DD_MS (nbr-&gt;dd_flags))</a>
<a name="ln1413">	    {</a>
<a name="ln1414">	      /* Master should discard duplicate DD packet. */</a>
<a name="ln1415">	      zlog_info (&quot;Packet[DD]: Neighbor %s duplicated, &quot;</a>
<a name="ln1416">	                 &quot;packet discarded.&quot;,</a>
<a name="ln1417">			inet_ntoa(nbr-&gt;router_id));</a>
<a name="ln1418">	      break;</a>
<a name="ln1419">	    }</a>
<a name="ln1420">	  else</a>
<a name="ln1421">	    {</a>
<a name="ln1422">	      struct timeval t, now;</a>
<a name="ln1423">	      quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now);</a>
<a name="ln1424">	      t = tv_sub (now, nbr-&gt;last_send_ts);</a>
<a name="ln1425">	      if (tv_cmp (t, int2tv (nbr-&gt;v_inactivity)) &lt; 0)</a>
<a name="ln1426">		{</a>
<a name="ln1427">		  /* In states Loading and Full the slave must resend</a>
<a name="ln1428">		     its last Database Description packet in response to</a>
<a name="ln1429">		     duplicate Database Description packets received</a>
<a name="ln1430">		     from the master.  For this reason the slave must</a>
<a name="ln1431">		     wait RouterDeadInterval seconds before freeing the</a>
<a name="ln1432">		     last Database Description packet.  Reception of a</a>
<a name="ln1433">		     Database Description packet from the master after</a>
<a name="ln1434">		     this interval will generate a SeqNumberMismatch</a>
<a name="ln1435">		     neighbor event. RFC2328 Section 10.8 */</a>
<a name="ln1436">		  ospf_db_desc_resend (nbr);</a>
<a name="ln1437">		  break;</a>
<a name="ln1438">		}</a>
<a name="ln1439">	    }</a>
<a name="ln1440">	}</a>
<a name="ln1441"> </a>
<a name="ln1442">      OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_SeqNumberMismatch);</a>
<a name="ln1443">      break;</a>
<a name="ln1444">    default:</a>
<a name="ln1445">      zlog_warn (&quot;Packet[DD]: Neighbor %s NSM illegal status %u.&quot;,</a>
<a name="ln1446">		 inet_ntoa(nbr-&gt;router_id), nbr-&gt;state);</a>
<a name="ln1447">      break;</a>
<a name="ln1448">    }</a>
<a name="ln1449">}</a>
<a name="ln1450"> </a>
<a name="ln1451">#define OSPF_LSA_KEY_SIZE       12 /* type(4) + id(4) + ar(4) */</a>
<a name="ln1452"> </a>
<a name="ln1453">/* OSPF Link State Request Read -- RFC2328 Section 10.7. */</a>
<a name="ln1454">static void</a>
<a name="ln1455">ospf_ls_req (struct ip *iph, struct ospf_header *ospfh,</a>
<a name="ln1456">	     struct stream *s, struct ospf_interface *oi, u_int16_t size)</a>
<a name="ln1457">{</a>
<a name="ln1458">  struct ospf_neighbor *nbr;</a>
<a name="ln1459">  u_int32_t ls_type;</a>
<a name="ln1460">  struct in_addr ls_id;</a>
<a name="ln1461">  struct in_addr adv_router;</a>
<a name="ln1462">  struct ospf_lsa *find;</a>
<a name="ln1463">  struct list *ls_upd;</a>
<a name="ln1464">  unsigned int length;</a>
<a name="ln1465"> </a>
<a name="ln1466">  /* Increment statistics. */</a>
<a name="ln1467">  oi-&gt;ls_req_in++;</a>
<a name="ln1468"> </a>
<a name="ln1469">  nbr = ospf_nbr_lookup (oi, iph, ospfh);</a>
<a name="ln1470">  if (nbr == NULL)</a>
<a name="ln1471">    {</a>
<a name="ln1472">      zlog_warn (&quot;Link State Request: Unknown Neighbor %s.&quot;,</a>
<a name="ln1473">		 inet_ntoa (ospfh-&gt;router_id));</a>
<a name="ln1474">      return;</a>
<a name="ln1475">    }</a>
<a name="ln1476"> </a>
<a name="ln1477">  /* Add event to thread. */</a>
<a name="ln1478">  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);</a>
<a name="ln1479"> </a>
<a name="ln1480">  /* Neighbor State should be Exchange or later. */</a>
<a name="ln1481">  if (nbr-&gt;state != NSM_Exchange &amp;&amp;</a>
<a name="ln1482">      nbr-&gt;state != NSM_Loading &amp;&amp;</a>
<a name="ln1483">      nbr-&gt;state != NSM_Full)</a>
<a name="ln1484">    {</a>
<a name="ln1485">      zlog_warn (&quot;Link State Request received from %s: &quot;</a>
<a name="ln1486">      		 &quot;Neighbor state is %s, packet discarded.&quot;,</a>
<a name="ln1487">		 inet_ntoa (ospfh-&gt;router_id),</a>
<a name="ln1488">		 LOOKUP (ospf_nsm_state_msg, nbr-&gt;state));</a>
<a name="ln1489">      return;</a>
<a name="ln1490">    }</a>
<a name="ln1491"> </a>
<a name="ln1492">  /* Send Link State Update for ALL requested LSAs. */</a>
<a name="ln1493">  ls_upd = list_new ();</a>
<a name="ln1494">  length = OSPF_HEADER_SIZE + OSPF_LS_UPD_MIN_SIZE;</a>
<a name="ln1495"> </a>
<a name="ln1496">  while (size &gt;= OSPF_LSA_KEY_SIZE)</a>
<a name="ln1497">    {</a>
<a name="ln1498">      /* Get one slice of Link State Request. */</a>
<a name="ln1499">      ls_type = stream_getl (s);</a>
<a name="ln1500">      ls_id.s_addr = stream_get_ipv4 (s);</a>
<a name="ln1501">      adv_router.s_addr = stream_get_ipv4 (s);</a>
<a name="ln1502"> </a>
<a name="ln1503">      /* Verify LSA type. */</a>
<a name="ln1504">      if (ls_type &lt; OSPF_MIN_LSA || ls_type &gt;= OSPF_MAX_LSA)</a>
<a name="ln1505">	{</a>
<a name="ln1506">	  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_BadLSReq);</a>
<a name="ln1507">	  list_delete (ls_upd);</a>
<a name="ln1508">	  return;</a>
<a name="ln1509">	}</a>
<a name="ln1510"> </a>
<a name="ln1511">      /* Search proper LSA in LSDB. */</a>
<a name="ln1512">      find = ospf_lsa_lookup (oi-&gt;area, ls_type, ls_id, adv_router);</a>
<a name="ln1513">      if (find == NULL)</a>
<a name="ln1514">	{</a>
<a name="ln1515">	  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_BadLSReq);</a>
<a name="ln1516">	  list_delete (ls_upd);</a>
<a name="ln1517">	  return;</a>
<a name="ln1518">	}</a>
<a name="ln1519"> </a>
<a name="ln1520">      /* Packet overflows MTU size, send immediately. */</a>
<a name="ln1521">      if (length + ntohs (find-&gt;data-&gt;length) &gt; ospf_packet_max (oi))</a>
<a name="ln1522">	{</a>
<a name="ln1523">	  if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln1524">	    ospf_ls_upd_send (nbr, ls_upd, OSPF_SEND_PACKET_DIRECT);</a>
<a name="ln1525">	  else</a>
<a name="ln1526">	    ospf_ls_upd_send (nbr, ls_upd, OSPF_SEND_PACKET_INDIRECT);</a>
<a name="ln1527"> </a>
<a name="ln1528">	  /* Only remove list contents.  Keep ls_upd. */</a>
<a name="ln1529">	  list_delete_all_node (ls_upd);</a>
<a name="ln1530"> </a>
<a name="ln1531">	  length = OSPF_HEADER_SIZE + OSPF_LS_UPD_MIN_SIZE;</a>
<a name="ln1532">	}</a>
<a name="ln1533"> </a>
<a name="ln1534">      /* Append LSA to update list. */</a>
<a name="ln1535">      listnode_add (ls_upd, find);</a>
<a name="ln1536">      length += ntohs (find-&gt;data-&gt;length);</a>
<a name="ln1537"> </a>
<a name="ln1538">      size -= OSPF_LSA_KEY_SIZE;</a>
<a name="ln1539">    }</a>
<a name="ln1540"> </a>
<a name="ln1541">  /* Send rest of Link State Update. */</a>
<a name="ln1542">  if (listcount (ls_upd) &gt; 0)</a>
<a name="ln1543">    {</a>
<a name="ln1544">      if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln1545">	ospf_ls_upd_send (nbr, ls_upd, OSPF_SEND_PACKET_DIRECT);</a>
<a name="ln1546">      else</a>
<a name="ln1547">	ospf_ls_upd_send (nbr, ls_upd, OSPF_SEND_PACKET_INDIRECT);</a>
<a name="ln1548"> </a>
<a name="ln1549">      list_delete (ls_upd);</a>
<a name="ln1550">    }</a>
<a name="ln1551">  else</a>
<a name="ln1552">    list_free (ls_upd);</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555">/* Get the list of LSAs from Link State Update packet.</a>
<a name="ln1556">   And process some validation -- RFC2328 Section 13. (1)-(2). */</a>
<a name="ln1557">static struct list *</a>
<a name="ln1558">ospf_ls_upd_list_lsa (struct ospf_neighbor *nbr, struct stream *s,</a>
<a name="ln1559">                      struct ospf_interface *oi, size_t size)</a>
<a name="ln1560">{</a>
<a name="ln1561">  u_int16_t count, sum;</a>
<a name="ln1562">  u_int32_t length;</a>
<a name="ln1563">  struct lsa_header *lsah;</a>
<a name="ln1564">  struct ospf_lsa *lsa;</a>
<a name="ln1565">  struct list *lsas;</a>
<a name="ln1566"> </a>
<a name="ln1567">  lsas = list_new ();</a>
<a name="ln1568"> </a>
<a name="ln1569">  count = stream_getl (s);</a>
<a name="ln1570">  size -= OSPF_LS_UPD_MIN_SIZE; /* # LSAs */</a>
<a name="ln1571"> </a>
<a name="ln1572">  for (; size &gt;= OSPF_LSA_HEADER_SIZE &amp;&amp; count &gt; 0;</a>
<a name="ln1573">       size -= length, stream_forward_getp (s, length), count--)</a>
<a name="ln1574">    {</a>
<a name="ln1575">      lsah = (struct lsa_header *) STREAM_PNT (s);</a>
<a name="ln1576">      length = ntohs (lsah-&gt;length);</a>
<a name="ln1577"> </a>
<a name="ln1578">      if (length &gt; size)</a>
<a name="ln1579">	{</a>
<a name="ln1580">	  zlog_warn (&quot;Link State Update: LSA length exceeds packet size.&quot;);</a>
<a name="ln1581">	  break;</a>
<a name="ln1582">	}</a>
<a name="ln1583"> </a>
<a name="ln1584">      /* Validate the LSA's LS checksum. */</a>
<a name="ln1585">      sum = lsah-&gt;checksum;</a>
<a name="ln1586">      if (! ospf_lsa_checksum_valid (lsah))</a>
<a name="ln1587">	{</a>
<a name="ln1588">	  /* (bug #685) more details in a one-line message make it possible</a>
<a name="ln1589">	   * to identify problem source on the one hand and to have a better</a>
<a name="ln1590">	   * chance to compress repeated messages in syslog on the other */</a>
<a name="ln1591">	  zlog_warn (&quot;Link State Update: LSA checksum error %x/%x, ID=%s from: nbr %s, router ID %s, adv router %s&quot;,</a>
<a name="ln1592">		     sum, lsah-&gt;checksum, inet_ntoa (lsah-&gt;id),</a>
<a name="ln1593">		     inet_ntoa (nbr-&gt;src), inet_ntoa (nbr-&gt;router_id),</a>
<a name="ln1594">		     inet_ntoa (lsah-&gt;adv_router));</a>
<a name="ln1595">	  continue;</a>
<a name="ln1596">	}</a>
<a name="ln1597"> </a>
<a name="ln1598">      /* Examine the LSA's LS type. */</a>
<a name="ln1599">      if (lsah-&gt;type &lt; OSPF_MIN_LSA || lsah-&gt;type &gt;= OSPF_MAX_LSA)</a>
<a name="ln1600">	{</a>
<a name="ln1601">	  zlog_warn (&quot;Link State Update: Unknown LS type %d&quot;, lsah-&gt;type);</a>
<a name="ln1602">	  continue;</a>
<a name="ln1603">	}</a>
<a name="ln1604"> </a>
<a name="ln1605">      /*</a>
<a name="ln1606">       * What if the received LSA's age is greater than MaxAge?</a>
<a name="ln1607">       * Treat it as a MaxAge case -- endo.</a>
<a name="ln1608">       */</a>
<a name="ln1609">      if (ntohs (lsah-&gt;ls_age) &gt; OSPF_LSA_MAXAGE)</a>
<a name="ln1610">        lsah-&gt;ls_age = htons (OSPF_LSA_MAXAGE);</a>
<a name="ln1611"> </a>
<a name="ln1612">      if (CHECK_FLAG (nbr-&gt;options, OSPF_OPTION_O))</a>
<a name="ln1613">        {</a>
<a name="ln1614">#ifdef STRICT_OBIT_USAGE_CHECK</a>
<a name="ln1615">	  if ((IS_OPAQUE_LSA(lsah-&gt;type) &amp;&amp;</a>
<a name="ln1616">               ! CHECK_FLAG (lsah-&gt;options, OSPF_OPTION_O))</a>
<a name="ln1617">	  ||  (! IS_OPAQUE_LSA(lsah-&gt;type) &amp;&amp;</a>
<a name="ln1618">               CHECK_FLAG (lsah-&gt;options, OSPF_OPTION_O)))</a>
<a name="ln1619">            {</a>
<a name="ln1620">              /*</a>
<a name="ln1621">               * This neighbor must know the exact usage of O-bit;</a>
<a name="ln1622">               * the bit will be set in Type-9,10,11 LSAs only.</a>
<a name="ln1623">               */</a>
<a name="ln1624">              zlog_warn (&quot;LSA[Type%d:%s]: O-bit abuse?&quot;, lsah-&gt;type, inet_ntoa (lsah-&gt;id));</a>
<a name="ln1625">              continue;</a>
<a name="ln1626">            }</a>
<a name="ln1627">#endif /* STRICT_OBIT_USAGE_CHECK */</a>
<a name="ln1628"> </a>
<a name="ln1629">          /* Do not take in AS External Opaque-LSAs if we are a stub. */</a>
<a name="ln1630">          if (lsah-&gt;type == OSPF_OPAQUE_AS_LSA</a>
<a name="ln1631">	      &amp;&amp; nbr-&gt;oi-&gt;area-&gt;external_routing != OSPF_AREA_DEFAULT) </a>
<a name="ln1632">            {</a>
<a name="ln1633">              if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1634">                zlog_debug (&quot;LSA[Type%d:%s]: We are a stub, don't take this LSA.&quot;, lsah-&gt;type, inet_ntoa (lsah-&gt;id));</a>
<a name="ln1635">              continue;</a>
<a name="ln1636">            }</a>
<a name="ln1637">        }</a>
<a name="ln1638">      else if (IS_OPAQUE_LSA(lsah-&gt;type))</a>
<a name="ln1639">        {</a>
<a name="ln1640">          zlog_warn (&quot;LSA[Type%d:%s]: Opaque capability mismatch?&quot;, lsah-&gt;type, inet_ntoa (lsah-&gt;id));</a>
<a name="ln1641">          continue;</a>
<a name="ln1642">        }</a>
<a name="ln1643"> </a>
<a name="ln1644">      /* Create OSPF LSA instance. */</a>
<a name="ln1645">      lsa = ospf_lsa_new ();</a>
<a name="ln1646"> </a>
<a name="ln1647">      /* We may wish to put some error checking if type NSSA comes in</a>
<a name="ln1648">         and area not in NSSA mode */</a>
<a name="ln1649">      switch (lsah-&gt;type)</a>
<a name="ln1650">        {</a>
<a name="ln1651">        case OSPF_AS_EXTERNAL_LSA:</a>
<a name="ln1652">        case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln1653">          lsa-&gt;area = NULL;</a>
<a name="ln1654">          break;</a>
<a name="ln1655">        case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln1656">          lsa-&gt;oi = oi; /* Remember incoming interface for flooding control. */</a>
<a name="ln1657">          /* Fallthrough */</a>
<a name="ln1658">        default:</a>
<a name="ln1659">          lsa-&gt;area = oi-&gt;area;</a>
<a name="ln1660">          break;</a>
<a name="ln1661">        }</a>
<a name="ln1662"> </a>
<a name="ln1663">      lsa-&gt;data = ospf_lsa_data_new (length);</a>
<a name="ln1664">      memcpy (lsa-&gt;data, lsah, length);</a>
<a name="ln1665"> </a>
<a name="ln1666">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1667">	zlog_debug(&quot;LSA[Type%d:%s]: %p new LSA created with Link State Update&quot;,</a>
<a name="ln1668">		  lsa-&gt;data-&gt;type, inet_ntoa (lsa-&gt;data-&gt;id), (void *)lsa);</a>
<a name="ln1669">      listnode_add (lsas, lsa);</a>
<a name="ln1670">    }</a>
<a name="ln1671"> </a>
<a name="ln1672">  return lsas;</a>
<a name="ln1673">}</a>
<a name="ln1674"> </a>
<a name="ln1675">/* Cleanup Update list. */</a>
<a name="ln1676">static void</a>
<a name="ln1677">ospf_upd_list_clean (struct list *lsas)</a>
<a name="ln1678">{</a>
<a name="ln1679">  struct listnode *node, *nnode;</a>
<a name="ln1680">  struct ospf_lsa *lsa;</a>
<a name="ln1681"> </a>
<a name="ln1682">  for (ALL_LIST_ELEMENTS (lsas, node, nnode, lsa))</a>
<a name="ln1683">    ospf_lsa_discard (lsa);</a>
<a name="ln1684"> </a>
<a name="ln1685">  list_delete (lsas);</a>
<a name="ln1686">}</a>
<a name="ln1687"> </a>
<a name="ln1688">/* OSPF Link State Update message read -- RFC2328 Section 13. */</a>
<a name="ln1689">static void</a>
<a name="ln1690">ospf_ls_upd (struct ospf *ospf, struct ip *iph, struct ospf_header *ospfh,</a>
<a name="ln1691">	     struct stream *s, struct ospf_interface *oi, u_int16_t size)</a>
<a name="ln1692">{</a>
<a name="ln1693">  struct ospf_neighbor *nbr;</a>
<a name="ln1694">  struct list *lsas;</a>
<a name="ln1695">  struct listnode *node, *nnode;</a>
<a name="ln1696">  struct ospf_lsa *lsa = NULL;</a>
<a name="ln1697">  /* unsigned long ls_req_found = 0; */</a>
<a name="ln1698"> </a>
<a name="ln1699">  /* Dis-assemble the stream, update each entry, re-encapsulate for flooding */</a>
<a name="ln1700"> </a>
<a name="ln1701">  /* Increment statistics. */</a>
<a name="ln1702">  oi-&gt;ls_upd_in++;</a>
<a name="ln1703"> </a>
<a name="ln1704">  /* Check neighbor. */</a>
<a name="ln1705">  nbr = ospf_nbr_lookup (oi, iph, ospfh);</a>
<a name="ln1706">  if (nbr == NULL)</a>
<a name="ln1707">    {</a>
<a name="ln1708">      zlog_warn (&quot;Link State Update: Unknown Neighbor %s on int: %s&quot;,</a>
<a name="ln1709">		 inet_ntoa (ospfh-&gt;router_id), IF_NAME (oi));</a>
<a name="ln1710">      return;</a>
<a name="ln1711">    }</a>
<a name="ln1712"> </a>
<a name="ln1713">  /* Add event to thread. */</a>
<a name="ln1714">  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);</a>
<a name="ln1715"> </a>
<a name="ln1716">  /* Check neighbor state. */</a>
<a name="ln1717">  if (nbr-&gt;state &lt; NSM_Exchange)</a>
<a name="ln1718">    {</a>
<a name="ln1719">      zlog_warn (&quot;Link State Update: &quot;</a>
<a name="ln1720">      		 &quot;Neighbor[%s] state %s is less than Exchange&quot;,</a>
<a name="ln1721">		 inet_ntoa (ospfh-&gt;router_id),</a>
<a name="ln1722">		 LOOKUP(ospf_nsm_state_msg, nbr-&gt;state));</a>
<a name="ln1723">      return;</a>
<a name="ln1724">    }</a>
<a name="ln1725"> </a>
<a name="ln1726">  /* Get list of LSAs from Link State Update packet. - Also perorms Stages </a>
<a name="ln1727">   * 1 (validate LSA checksum) and 2 (check for LSA consistent type) </a>
<a name="ln1728">   * of section 13. </a>
<a name="ln1729">   */</a>
<a name="ln1730">  lsas = ospf_ls_upd_list_lsa (nbr, s, oi, size);</a>
<a name="ln1731"> </a>
<a name="ln1732">#define DISCARD_LSA(L,N) {\</a>
<a name="ln1733">        if (IS_DEBUG_OSPF_EVENT) \</a>
<a name="ln1734">          zlog_debug (&quot;ospf_lsa_discard() in ospf_ls_upd() point %d: lsa %p&quot; \</a>
<a name="ln1735">                      &quot; Type-%d&quot;, N, (void *)lsa, (int) lsa-&gt;data-&gt;type); \</a>
<a name="ln1736">        ospf_lsa_discard (L); \</a>
<a name="ln1737">	continue; }</a>
<a name="ln1738"> </a>
<a name="ln1739">  /* Process each LSA received in the one packet.</a>
<a name="ln1740">   *</a>
<a name="ln1741">   * Numbers in parentheses, e.g. (1), (2), etc., and the corresponding</a>
<a name="ln1742">   * text below are from the steps in RFC 2328, Section 13.</a>
<a name="ln1743">   */</a>
<a name="ln1744">  for (ALL_LIST_ELEMENTS (lsas, node, nnode, lsa))</a>
<a name="ln1745">    {</a>
<a name="ln1746">      struct ospf_lsa *ls_ret, *current;</a>
<a name="ln1747">      int ret = 1;</a>
<a name="ln1748"> </a>
<a name="ln1749">      if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln1750">	{</a>
<a name="ln1751">	  char buf1[INET_ADDRSTRLEN];</a>
<a name="ln1752">	  char buf2[INET_ADDRSTRLEN];</a>
<a name="ln1753">	  char buf3[INET_ADDRSTRLEN];</a>
<a name="ln1754"> </a>
<a name="ln1755">	  zlog_debug(&quot;LSA Type-%d from %s, ID: %s, ADV: %s&quot;,</a>
<a name="ln1756">		  lsa-&gt;data-&gt;type,</a>
<a name="ln1757">		  inet_ntop (AF_INET, &amp;ospfh-&gt;router_id,</a>
<a name="ln1758">			     buf1, INET_ADDRSTRLEN),</a>
<a name="ln1759">		  inet_ntop (AF_INET, &amp;lsa-&gt;data-&gt;id,</a>
<a name="ln1760">			     buf2, INET_ADDRSTRLEN),</a>
<a name="ln1761">		  inet_ntop (AF_INET, &amp;lsa-&gt;data-&gt;adv_router,</a>
<a name="ln1762">			     buf3, INET_ADDRSTRLEN));</a>
<a name="ln1763">	}</a>
<a name="ln1764"> </a>
<a name="ln1765">      listnode_delete (lsas, lsa); /* We don't need it in list anymore */</a>
<a name="ln1766"> </a>
<a name="ln1767">      /* (1) Validate Checksum - Done above by ospf_ls_upd_list_lsa() */</a>
<a name="ln1768"> </a>
<a name="ln1769">      /* (2) LSA Type  - Done above by ospf_ls_upd_list_lsa() */</a>
<a name="ln1770">   </a>
<a name="ln1771">      /* (3) Do not take in AS External LSAs if we are a stub or NSSA. */</a>
<a name="ln1772"> </a>
<a name="ln1773">      /* Do not take in AS NSSA if this neighbor and we are not NSSA */</a>
<a name="ln1774"> </a>
<a name="ln1775">      /* Do take in Type-7's if we are an NSSA  */ </a>
<a name="ln1776"> </a>
<a name="ln1777">      /* If we are also an ABR, later translate them to a Type-5 packet */</a>
<a name="ln1778"> </a>
<a name="ln1779">      /* Later, an NSSA Re-fresh can Re-fresh Type-7's and an ABR will</a>
<a name="ln1780">	 translate them to a separate Type-5 packet.  */</a>
<a name="ln1781"> </a>
<a name="ln1782">      if (lsa-&gt;data-&gt;type == OSPF_AS_EXTERNAL_LSA)</a>
<a name="ln1783">        /* Reject from STUB or NSSA */</a>
<a name="ln1784">        if (nbr-&gt;oi-&gt;area-&gt;external_routing != OSPF_AREA_DEFAULT) </a>
<a name="ln1785">	  {</a>
<a name="ln1786">	    if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln1787">	      zlog_debug(&quot;Incoming External LSA Discarded: We are NSSA/STUB Area&quot;);</a>
<a name="ln1788">	    DISCARD_LSA (lsa, 1);</a>
<a name="ln1789">	  }</a>
<a name="ln1790"> </a>
<a name="ln1791">      if (lsa-&gt;data-&gt;type == OSPF_AS_NSSA_LSA)</a>
<a name="ln1792">	if (nbr-&gt;oi-&gt;area-&gt;external_routing != OSPF_AREA_NSSA)</a>
<a name="ln1793">	  {</a>
<a name="ln1794">	    if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln1795">	      zlog_debug(&quot;Incoming NSSA LSA Discarded:  Not NSSA Area&quot;);</a>
<a name="ln1796">	    DISCARD_LSA (lsa,2);</a>
<a name="ln1797">	  }</a>
<a name="ln1798"> </a>
<a name="ln1799">      /* VU229804: Router-LSA Adv-ID must be equal to LS-ID */</a>
<a name="ln1800">      if (lsa-&gt;data-&gt;type == OSPF_ROUTER_LSA)</a>
<a name="ln1801">	if (!IPV4_ADDR_SAME(&amp;lsa-&gt;data-&gt;id, &amp;lsa-&gt;data-&gt;adv_router))</a>
<a name="ln1802">	  {</a>
<a name="ln1803">	    char buf1[INET_ADDRSTRLEN];</a>
<a name="ln1804">	    char buf2[INET_ADDRSTRLEN];</a>
<a name="ln1805">	    char buf3[INET_ADDRSTRLEN];</a>
<a name="ln1806"> </a>
<a name="ln1807">	    zlog_err(&quot;Incoming Router-LSA from %s with &quot;</a>
<a name="ln1808">		      &quot;Adv-ID[%s] != LS-ID[%s]&quot;,</a>
<a name="ln1809">		      inet_ntop (AF_INET, &amp;ospfh-&gt;router_id,</a>
<a name="ln1810">				 buf1, INET_ADDRSTRLEN),</a>
<a name="ln1811">		      inet_ntop (AF_INET, &amp;lsa-&gt;data-&gt;id,</a>
<a name="ln1812">				 buf2, INET_ADDRSTRLEN),</a>
<a name="ln1813">		      inet_ntop (AF_INET, &amp;lsa-&gt;data-&gt;adv_router,</a>
<a name="ln1814">				 buf3, INET_ADDRSTRLEN));</a>
<a name="ln1815">	    zlog_err(&quot;OSPF domain compromised by attack or corruption. &quot;</a>
<a name="ln1816">		     &quot;Verify correct operation of -ALL- OSPF routers.&quot;);</a>
<a name="ln1817">	    DISCARD_LSA (lsa, 0);</a>
<a name="ln1818">	  }</a>
<a name="ln1819"> </a>
<a name="ln1820">      /* Find the LSA in the current database. */</a>
<a name="ln1821"> </a>
<a name="ln1822">      current = ospf_lsa_lookup_by_header (oi-&gt;area, lsa-&gt;data);</a>
<a name="ln1823"> </a>
<a name="ln1824">      /* (4) If the LSA's LS age is equal to MaxAge, and there is currently</a>
<a name="ln1825">	 no instance of the LSA in the router's link state database,</a>
<a name="ln1826">	 and none of router's neighbors are in states Exchange or Loading,</a>
<a name="ln1827">	 then take the following actions: */</a>
<a name="ln1828"> </a>
<a name="ln1829">      if (IS_LSA_MAXAGE (lsa) &amp;&amp; !current &amp;&amp;</a>
<a name="ln1830">	  ospf_check_nbr_status(oi-&gt;ospf))</a>
<a name="ln1831">	{</a>
<a name="ln1832">	  /* (4a) Response Link State Acknowledgment. */</a>
<a name="ln1833">	  ospf_ls_ack_send (nbr, lsa);</a>
<a name="ln1834"> </a>
<a name="ln1835">	  /* (4b) Discard LSA. */</a>
<a name="ln1836">          if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln1837">            {</a>
<a name="ln1838">	       zlog_debug (&quot;Link State Update[%s]: LS age is equal to MaxAge.&quot;,</a>
<a name="ln1839">                           dump_lsa_key(lsa));</a>
<a name="ln1840">            }</a>
<a name="ln1841">          DISCARD_LSA (lsa, 3);</a>
<a name="ln1842">	}</a>
<a name="ln1843"> </a>
<a name="ln1844">      if (IS_OPAQUE_LSA (lsa-&gt;data-&gt;type)</a>
<a name="ln1845">      &amp;&amp;  IPV4_ADDR_SAME (&amp;lsa-&gt;data-&gt;adv_router, &amp;oi-&gt;ospf-&gt;router_id))</a>
<a name="ln1846">        {</a>
<a name="ln1847">          /*</a>
<a name="ln1848">           * Even if initial flushing seems to be completed, there might</a>
<a name="ln1849">           * be a case that self-originated LSA with MaxAge still remain</a>
<a name="ln1850">           * in the routing domain.</a>
<a name="ln1851">           * Just send an LSAck message to cease retransmission.</a>
<a name="ln1852">           */</a>
<a name="ln1853">          if (IS_LSA_MAXAGE (lsa))</a>
<a name="ln1854">            {</a>
<a name="ln1855">              zlog_warn (&quot;LSA[%s]: Boomerang effect?&quot;, dump_lsa_key (lsa));</a>
<a name="ln1856">              ospf_ls_ack_send (nbr, lsa);</a>
<a name="ln1857">              ospf_lsa_discard (lsa);</a>
<a name="ln1858"> </a>
<a name="ln1859">              if (current != NULL &amp;&amp; ! IS_LSA_MAXAGE (current))</a>
<a name="ln1860">                ospf_opaque_lsa_refresh_schedule (current);</a>
<a name="ln1861">              continue;</a>
<a name="ln1862">            }</a>
<a name="ln1863"> </a>
<a name="ln1864">          /*</a>
<a name="ln1865">           * If an instance of self-originated Opaque-LSA is not found</a>
<a name="ln1866">           * in the LSDB, there are some possible cases here.</a>
<a name="ln1867">           *</a>
<a name="ln1868">           * 1) This node lost opaque-capability after restart.</a>
<a name="ln1869">           * 2) Else, a part of opaque-type is no more supported.</a>
<a name="ln1870">           * 3) Else, a part of opaque-id is no more supported.</a>
<a name="ln1871">           *</a>
<a name="ln1872">           * Anyway, it is still this node's responsibility to flush it.</a>
<a name="ln1873">           * Otherwise, the LSA instance remains in the routing domain</a>
<a name="ln1874">           * until its age reaches to MaxAge.</a>
<a name="ln1875">           */</a>
<a name="ln1876">          /* XXX: We should deal with this for *ALL* LSAs, not just opaque */</a>
<a name="ln1877">          if (current == NULL)</a>
<a name="ln1878">            {</a>
<a name="ln1879">              if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1880">                zlog_debug (&quot;LSA[%s]: Previously originated Opaque-LSA,&quot;</a>
<a name="ln1881">                            &quot;not found in the LSDB.&quot;, dump_lsa_key (lsa));</a>
<a name="ln1882"> </a>
<a name="ln1883">              SET_FLAG (lsa-&gt;flags, OSPF_LSA_SELF);</a>
<a name="ln1884">              </a>
<a name="ln1885">              ospf_opaque_self_originated_lsa_received (nbr, lsa);</a>
<a name="ln1886">              ospf_ls_ack_send (nbr, lsa);</a>
<a name="ln1887">              </a>
<a name="ln1888">              continue;</a>
<a name="ln1889">            }</a>
<a name="ln1890">        }</a>
<a name="ln1891"> </a>
<a name="ln1892">      /* It might be happen that received LSA is self-originated network LSA, but</a>
<a name="ln1893">       * router ID is changed. So, we should check if LSA is a network-LSA whose</a>
<a name="ln1894">       * Link State ID is one of the router's own IP interface addresses but whose</a>
<a name="ln1895">       * Advertising Router is not equal to the router's own Router ID</a>
<a name="ln1896">       * According to RFC 2328 12.4.2 and 13.4 this LSA should be flushed.</a>
<a name="ln1897">       */</a>
<a name="ln1898"> </a>
<a name="ln1899">      if(lsa-&gt;data-&gt;type == OSPF_NETWORK_LSA)</a>
<a name="ln1900">      {</a>
<a name="ln1901">        struct listnode *oinode, *oinnode;</a>
<a name="ln1902">        struct ospf_interface *out_if;</a>
<a name="ln1903">        int Flag = 0;</a>
<a name="ln1904"> </a>
<a name="ln1905">        for (ALL_LIST_ELEMENTS (oi-&gt;ospf-&gt;oiflist, oinode, oinnode, out_if))</a>
<a name="ln1906">        {</a>
<a name="ln1907">          if(out_if == NULL)</a>
<a name="ln1908">            break;</a>
<a name="ln1909"> </a>
<a name="ln1910">          if((IPV4_ADDR_SAME(&amp;out_if-&gt;address-&gt;u.prefix4, &amp;lsa-&gt;data-&gt;id)) &amp;&amp;</a>
<a name="ln1911">              (!(IPV4_ADDR_SAME(&amp;oi-&gt;ospf-&gt;router_id, &amp;lsa-&gt;data-&gt;adv_router))))</a>
<a name="ln1912">          {</a>
<a name="ln1913">            if(out_if-&gt;network_lsa_self)</a>
<a name="ln1914">            {</a>
<a name="ln1915">              ospf_lsa_flush_area(lsa,out_if-&gt;area);</a>
<a name="ln1916">              if(IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1917">                zlog_debug (&quot;ospf_lsa_discard() in ospf_ls_upd() point 9: lsa %p Type-%d&quot;,</a>
<a name="ln1918">                            (void *)lsa, (int) lsa-&gt;data-&gt;type);</a>
<a name="ln1919">              ospf_lsa_discard (lsa);</a>
<a name="ln1920">              Flag = 1;</a>
<a name="ln1921">            }</a>
<a name="ln1922">            break;</a>
<a name="ln1923">          }</a>
<a name="ln1924">        }</a>
<a name="ln1925">        if(Flag)</a>
<a name="ln1926">          continue;</a>
<a name="ln1927">      }</a>
<a name="ln1928"> </a>
<a name="ln1929">      /* (5) Find the instance of this LSA that is currently contained</a>
<a name="ln1930">	 in the router's link state database.  If there is no</a>
<a name="ln1931">	 database copy, or the received LSA is more recent than</a>
<a name="ln1932">	 the database copy the following steps must be performed.</a>
<a name="ln1933">         (The sub steps from RFC 2328 section 13 step (5) will be performed in</a>
<a name="ln1934">         ospf_flood() ) */</a>
<a name="ln1935"> </a>
<a name="ln1936">      if (current == NULL ||</a>
<a name="ln1937">	  (ret = ospf_lsa_more_recent (current, lsa)) &lt; 0)</a>
<a name="ln1938">	{</a>
<a name="ln1939">	  /* Actual flooding procedure. */</a>
<a name="ln1940">	  if (ospf_flood (oi-&gt;ospf, nbr, current, lsa) &lt; 0)  /* Trap NSSA later. */</a>
<a name="ln1941">	    DISCARD_LSA (lsa, 4);</a>
<a name="ln1942">	  continue;</a>
<a name="ln1943">	}</a>
<a name="ln1944"> </a>
<a name="ln1945">      /* (6) Else, If there is an instance of the LSA on the sending</a>
<a name="ln1946">	 neighbor's Link state request list, an error has occurred in</a>
<a name="ln1947">	 the Database Exchange process.  In this case, restart the</a>
<a name="ln1948">	 Database Exchange process by generating the neighbor event</a>
<a name="ln1949">	 BadLSReq for the sending neighbor and stop processing the</a>
<a name="ln1950">	 Link State Update packet. */</a>
<a name="ln1951"> </a>
<a name="ln1952">      if (ospf_ls_request_lookup (nbr, lsa))</a>
<a name="ln1953">	{</a>
<a name="ln1954">	  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_BadLSReq);</a>
<a name="ln1955">	  zlog_warn(&quot;LSA[%s] instance exists on Link state request list&quot;,</a>
<a name="ln1956">	  	    dump_lsa_key(lsa));</a>
<a name="ln1957"> </a>
<a name="ln1958">	  /* Clean list of LSAs. */</a>
<a name="ln1959">          ospf_upd_list_clean (lsas);</a>
<a name="ln1960">	  /* this lsa is not on lsas list already. */</a>
<a name="ln1961">	  ospf_lsa_discard (lsa);</a>
<a name="ln1962">	  return;</a>
<a name="ln1963">	}</a>
<a name="ln1964"> </a>
<a name="ln1965">      /* If the received LSA is the same instance as the database copy</a>
<a name="ln1966">	 (i.e., neither one is more recent) the following two steps</a>
<a name="ln1967">	 should be performed: */</a>
<a name="ln1968"> </a>
<a name="ln1969">      if (ret == 0)</a>
<a name="ln1970">	{</a>
<a name="ln1971">	  /* If the LSA is listed in the Link state retransmission list</a>
<a name="ln1972">	     for the receiving adjacency, the router itself is expecting</a>
<a name="ln1973">	     an acknowledgment for this LSA.  The router should treat the</a>
<a name="ln1974">	     received LSA as an acknowledgment by removing the LSA from</a>
<a name="ln1975">	     the Link state retransmission list.  This is termed an</a>
<a name="ln1976">	     &quot;implied acknowledgment&quot;. */</a>
<a name="ln1977"> </a>
<a name="ln1978">	  ls_ret = ospf_ls_retransmit_lookup (nbr, lsa);</a>
<a name="ln1979"> </a>
<a name="ln1980">	  if (ls_ret != NULL)</a>
<a name="ln1981">	    {</a>
<a name="ln1982">	      ospf_ls_retransmit_delete (nbr, ls_ret);</a>
<a name="ln1983"> </a>
<a name="ln1984">	      /* Delayed acknowledgment sent if advertisement received</a>
<a name="ln1985">		 from Designated Router, otherwise do nothing. */</a>
<a name="ln1986">	      if (oi-&gt;state == ISM_Backup)</a>
<a name="ln1987">		if (NBR_IS_DR (nbr))</a>
<a name="ln1988">		  listnode_add (oi-&gt;ls_ack, ospf_lsa_lock (lsa));</a>
<a name="ln1989"> </a>
<a name="ln1990">              DISCARD_LSA (lsa, 5);</a>
<a name="ln1991">	    }</a>
<a name="ln1992">	  else</a>
<a name="ln1993">	    /* Acknowledge the receipt of the LSA by sending a</a>
<a name="ln1994">	       Link State Acknowledgment packet back out the receiving</a>
<a name="ln1995">	       interface. */</a>
<a name="ln1996">	    {</a>
<a name="ln1997">	      ospf_ls_ack_send (nbr, lsa);</a>
<a name="ln1998">	      DISCARD_LSA (lsa, 6);</a>
<a name="ln1999">	    }</a>
<a name="ln2000">	}</a>
<a name="ln2001"> </a>
<a name="ln2002">      /* The database copy is more recent.  If the database copy</a>
<a name="ln2003">	 has LS age equal to MaxAge and LS sequence number equal to</a>
<a name="ln2004">	 MaxSequenceNumber, simply discard the received LSA without</a>
<a name="ln2005">	 acknowledging it. (In this case, the LSA's LS sequence number is</a>
<a name="ln2006">	 wrapping, and the MaxSequenceNumber LSA must be completely</a>
<a name="ln2007">	 flushed before any new LSA instance can be introduced). */</a>
<a name="ln2008"> </a>
<a name="ln2009">      else if (ret &gt; 0)  /* Database copy is more recent */</a>
<a name="ln2010">	{ </a>
<a name="ln2011">	  if (IS_LSA_MAXAGE (current) &amp;&amp;</a>
<a name="ln2012">	      current-&gt;data-&gt;ls_seqnum == htonl (OSPF_MAX_SEQUENCE_NUMBER))</a>
<a name="ln2013">	    {</a>
<a name="ln2014">	      DISCARD_LSA (lsa, 7);</a>
<a name="ln2015">	    }</a>
<a name="ln2016">	  /* Otherwise, as long as the database copy has not been sent in a</a>
<a name="ln2017">	     Link State Update within the last MinLSArrival seconds, send the</a>
<a name="ln2018">	     database copy back to the sending neighbor, encapsulated within</a>
<a name="ln2019">	     a Link State Update Packet. The Link State Update Packet should</a>
<a name="ln2020">	     be sent directly to the neighbor. In so doing, do not put the</a>
<a name="ln2021">	     database copy of the LSA on the neighbor's link state</a>
<a name="ln2022">	     retransmission list, and do not acknowledge the received (less</a>
<a name="ln2023">	     recent) LSA instance. */</a>
<a name="ln2024">	  else</a>
<a name="ln2025">	    {</a>
<a name="ln2026">	      struct timeval now;</a>
<a name="ln2027">	      </a>
<a name="ln2028">	      quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now);</a>
<a name="ln2029">	      </a>
<a name="ln2030">	      if (tv_cmp (tv_sub (now, current-&gt;tv_orig), </a>
<a name="ln2031">			  msec2tv (ospf-&gt;min_ls_arrival)) &gt;= 0)</a>
<a name="ln2032">		/* Trap NSSA type later.*/</a>
<a name="ln2033">		ospf_ls_upd_send_lsa (nbr, current, OSPF_SEND_PACKET_DIRECT);</a>
<a name="ln2034">	      DISCARD_LSA (lsa, 8);</a>
<a name="ln2035">	    }</a>
<a name="ln2036">	}</a>
<a name="ln2037">    }</a>
<a name="ln2038">#undef DISCARD_LSA</a>
<a name="ln2039"> </a>
<a name="ln2040">  assert (listcount (lsas) == 0);</a>
<a name="ln2041">  list_delete (lsas);</a>
<a name="ln2042">}</a>
<a name="ln2043"> </a>
<a name="ln2044">/* OSPF Link State Acknowledgment message read -- RFC2328 Section 13.7. */</a>
<a name="ln2045">static void</a>
<a name="ln2046">ospf_ls_ack (struct ip *iph, struct ospf_header *ospfh,</a>
<a name="ln2047">	     struct stream *s, struct ospf_interface *oi, u_int16_t size)</a>
<a name="ln2048">{</a>
<a name="ln2049">  struct ospf_neighbor *nbr;</a>
<a name="ln2050">  </a>
<a name="ln2051">  /* increment statistics. */</a>
<a name="ln2052">  oi-&gt;ls_ack_in++;</a>
<a name="ln2053"> </a>
<a name="ln2054">  nbr = ospf_nbr_lookup (oi, iph, ospfh);</a>
<a name="ln2055">  if (nbr == NULL)</a>
<a name="ln2056">    {</a>
<a name="ln2057">      zlog_warn (&quot;Link State Acknowledgment: Unknown Neighbor %s.&quot;,</a>
<a name="ln2058">		 inet_ntoa (ospfh-&gt;router_id));</a>
<a name="ln2059">      return;</a>
<a name="ln2060">    }</a>
<a name="ln2061"> </a>
<a name="ln2062">  /* Add event to thread. */</a>
<a name="ln2063">  OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_PacketReceived);</a>
<a name="ln2064"> </a>
<a name="ln2065">  if (nbr-&gt;state &lt; NSM_Exchange)</a>
<a name="ln2066">    {</a>
<a name="ln2067">      zlog_warn (&quot;Link State Acknowledgment: &quot;</a>
<a name="ln2068">      		 &quot;Neighbor[%s] state %s is less than Exchange&quot;,</a>
<a name="ln2069">		 inet_ntoa (ospfh-&gt;router_id),</a>
<a name="ln2070">		 LOOKUP(ospf_nsm_state_msg, nbr-&gt;state));</a>
<a name="ln2071">      return;</a>
<a name="ln2072">    }</a>
<a name="ln2073">  </a>
<a name="ln2074">  while (size &gt;= OSPF_LSA_HEADER_SIZE)</a>
<a name="ln2075">    {</a>
<a name="ln2076">      struct ospf_lsa *lsa, *lsr;</a>
<a name="ln2077"> </a>
<a name="ln2078">      lsa = ospf_lsa_new ();</a>
<a name="ln2079">      lsa-&gt;data = (struct lsa_header *) STREAM_PNT (s);</a>
<a name="ln2080"> </a>
<a name="ln2081">      /* lsah = (struct lsa_header *) STREAM_PNT (s); */</a>
<a name="ln2082">      size -= OSPF_LSA_HEADER_SIZE;</a>
<a name="ln2083">      stream_forward_getp (s, OSPF_LSA_HEADER_SIZE);</a>
<a name="ln2084"> </a>
<a name="ln2085">      if (lsa-&gt;data-&gt;type &lt; OSPF_MIN_LSA || lsa-&gt;data-&gt;type &gt;= OSPF_MAX_LSA)</a>
<a name="ln2086">	{</a>
<a name="ln2087">	  lsa-&gt;data = NULL;</a>
<a name="ln2088">	  ospf_lsa_discard (lsa);</a>
<a name="ln2089">	  continue;</a>
<a name="ln2090">	}</a>
<a name="ln2091"> </a>
<a name="ln2092">      lsr = ospf_ls_retransmit_lookup (nbr, lsa);</a>
<a name="ln2093"> </a>
<a name="ln2094">      if (lsr != NULL &amp;&amp; ospf_lsa_more_recent (lsr, lsa) == 0)</a>
<a name="ln2095">        ospf_ls_retransmit_delete (nbr, lsr);</a>
<a name="ln2096"> </a>
<a name="ln2097">      lsa-&gt;data = NULL;</a>
<a name="ln2098">      ospf_lsa_discard (lsa);</a>
<a name="ln2099">    }</a>
<a name="ln2100"> </a>
<a name="ln2101">  return;</a>
<a name="ln2102">}</a>
<a name="ln2103"> </a>
<a name="ln2104">static struct stream *</a>
<a name="ln2105">ospf_recv_packet (int fd, struct interface **ifp, struct stream *ibuf)</a>
<a name="ln2106">{</a>
<a name="ln2107">  int ret;</a>
<a name="ln2108">  struct ip *iph;</a>
<a name="ln2109">  u_int16_t ip_len;</a>
<a name="ln2110">  ifindex_t ifindex = 0;</a>
<a name="ln2111">  struct iovec iov;</a>
<a name="ln2112">  /* Header and data both require alignment. */</a>
<a name="ln2113">  char buff [CMSG_SPACE(SOPT_SIZE_CMSG_IFINDEX_IPV4())];</a>
<a name="ln2114">  struct msghdr msgh;</a>
<a name="ln2115"> </a>
<a name="ln2116">  memset (&amp;msgh, 0, sizeof (struct msghdr));</a>
<a name="ln2117">  msgh.msg_iov = &amp;iov;</a>
<a name="ln2118">  msgh.msg_iovlen = 1;</a>
<a name="ln2119">  msgh.msg_control = (caddr_t) buff;</a>
<a name="ln2120">  msgh.msg_controllen = sizeof (buff);</a>
<a name="ln2121">  </a>
<a name="ln2122">  ret = stream_recvmsg (ibuf, fd, &amp;msgh, 0, OSPF_MAX_PACKET_SIZE+1);</a>
<a name="ln2123">  if (ret &lt; 0)</a>
<a name="ln2124">    {</a>
<a name="ln2125">      zlog_warn(&quot;stream_recvmsg failed: %s&quot;, safe_strerror(errno));</a>
<a name="ln2126">      return NULL;</a>
<a name="ln2127">    }</a>
<a name="ln2128">  if ((unsigned int)ret &lt; sizeof(iph)) /* ret must be &gt; 0 now */</a>
<a name="ln2129">    {</a>
<a name="ln2130">      zlog_warn(&quot;ospf_recv_packet: discarding runt packet of length %d &quot;</a>
<a name="ln2131">		&quot;(ip header size is %u)&quot;,</a>
<a name="ln2132">		ret, (u_int)sizeof(iph));</a>
<a name="ln2133">      return NULL;</a>
<a name="ln2134">    }</a>
<a name="ln2135">  </a>
<a name="ln2136">  /* Note that there should not be alignment problems with this assignment</a>
<a name="ln2137">     because this is at the beginning of the stream data buffer. */</a>
<a name="ln2138">  iph = (struct ip *) STREAM_DATA(ibuf);</a>
<a name="ln2139">  sockopt_iphdrincl_swab_systoh (iph);</a>
<a name="ln2140">  </a>
<a name="ln2141">  ip_len = iph-&gt;ip_len;</a>
<a name="ln2142">  </a>
<a name="ln2143">#if !defined(GNU_LINUX) &amp;&amp; (OpenBSD &lt; 200311) &amp;&amp; (__FreeBSD_version &lt; 1000000)</a>
<a name="ln2144">  /*</a>
<a name="ln2145">   * Kernel network code touches incoming IP header parameters,</a>
<a name="ln2146">   * before protocol specific processing.</a>
<a name="ln2147">   *</a>
<a name="ln2148">   *   1) Convert byteorder to host representation.</a>
<a name="ln2149">   *      --&gt; ip_len, ip_id, ip_off</a>
<a name="ln2150">   *</a>
<a name="ln2151">   *   2) Adjust ip_len to strip IP header size!</a>
<a name="ln2152">   *      --&gt; If user process receives entire IP packet via RAW</a>
<a name="ln2153">   *          socket, it must consider adding IP header size to</a>
<a name="ln2154">   *          the &quot;ip_len&quot; field of &quot;ip&quot; structure.</a>
<a name="ln2155">   *</a>
<a name="ln2156">   * For more details, see &lt;netinet/ip_input.c&gt;.</a>
<a name="ln2157">   */</a>
<a name="ln2158">  ip_len = ip_len + (iph-&gt;ip_hl &lt;&lt; 2);</a>
<a name="ln2159">#endif</a>
<a name="ln2160">  </a>
<a name="ln2161">#if defined(__DragonFly__)</a>
<a name="ln2162">  /*</a>
<a name="ln2163">   * in DragonFly's raw socket, ip_len/ip_off are read </a>
<a name="ln2164">   * in network byte order.</a>
<a name="ln2165">   * As OpenBSD &lt; 200311 adjust ip_len to strip IP header size!</a>
<a name="ln2166">   */</a>
<a name="ln2167">  ip_len = ntohs(iph-&gt;ip_len) + (iph-&gt;ip_hl &lt;&lt; 2);</a>
<a name="ln2168">#endif</a>
<a name="ln2169"> </a>
<a name="ln2170">  ifindex = getsockopt_ifindex (AF_INET, &amp;msgh);</a>
<a name="ln2171">  </a>
<a name="ln2172">  *ifp = if_lookup_by_index (ifindex);</a>
<a name="ln2173"> </a>
<a name="ln2174">  if (ret != ip_len)</a>
<a name="ln2175">    {</a>
<a name="ln2176">      zlog_warn (&quot;ospf_recv_packet read length mismatch: ip_len is %d, &quot;</a>
<a name="ln2177">       		 &quot;but recvmsg returned %d&quot;, ip_len, ret);</a>
<a name="ln2178">      return NULL;</a>
<a name="ln2179">    }</a>
<a name="ln2180">  </a>
<a name="ln2181">  return ibuf;</a>
<a name="ln2182">}</a>
<a name="ln2183"> </a>
<a name="ln2184">static struct ospf_interface *</a>
<a name="ln2185">ospf_associate_packet_vl (struct ospf *ospf, struct interface *ifp, </a>
<a name="ln2186">			  struct ip *iph, struct ospf_header *ospfh)</a>
<a name="ln2187">{</a>
<a name="ln2188">  struct ospf_interface *rcv_oi;</a>
<a name="ln2189">  struct ospf_vl_data *vl_data;</a>
<a name="ln2190">  struct ospf_area *vl_area;</a>
<a name="ln2191">  struct listnode *node;</a>
<a name="ln2192"> </a>
<a name="ln2193">  if (IN_MULTICAST (ntohl (iph-&gt;ip_dst.s_addr)) ||</a>
<a name="ln2194">      !OSPF_IS_AREA_BACKBONE (ospfh))</a>
<a name="ln2195">    return NULL;</a>
<a name="ln2196"> </a>
<a name="ln2197">  /* look for local OSPF interface matching the destination</a>
<a name="ln2198">   * to determine Area ID. We presume therefore the destination address</a>
<a name="ln2199">   * is unique, or at least (for &quot;unnumbered&quot; links), not used in other </a>
<a name="ln2200">   * areas</a>
<a name="ln2201">   */</a>
<a name="ln2202">  if ((rcv_oi = ospf_if_lookup_by_local_addr (ospf, NULL, </a>
<a name="ln2203">                                              iph-&gt;ip_dst)) == NULL)</a>
<a name="ln2204">    return NULL;</a>
<a name="ln2205"> </a>
<a name="ln2206">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;vlinks, node, vl_data))</a>
<a name="ln2207">    {</a>
<a name="ln2208">      vl_area = ospf_area_lookup_by_area_id (ospf, vl_data-&gt;vl_area_id);</a>
<a name="ln2209">      if (!vl_area)</a>
<a name="ln2210">	continue;</a>
<a name="ln2211">      </a>
<a name="ln2212">      if (OSPF_AREA_SAME (&amp;vl_area, &amp;rcv_oi-&gt;area) &amp;&amp;</a>
<a name="ln2213">	  IPV4_ADDR_SAME (&amp;vl_data-&gt;vl_peer, &amp;ospfh-&gt;router_id))</a>
<a name="ln2214">	{</a>
<a name="ln2215">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2216">	    zlog_debug (&quot;associating packet with %s&quot;,</a>
<a name="ln2217">		       IF_NAME (vl_data-&gt;vl_oi));</a>
<a name="ln2218">	  if (! CHECK_FLAG (vl_data-&gt;vl_oi-&gt;ifp-&gt;flags, IFF_UP))</a>
<a name="ln2219">	    {</a>
<a name="ln2220">	      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2221">		zlog_debug (&quot;This VL is not up yet, sorry&quot;);</a>
<a name="ln2222">	      return NULL;</a>
<a name="ln2223">	    }</a>
<a name="ln2224">	  </a>
<a name="ln2225">	  return vl_data-&gt;vl_oi;</a>
<a name="ln2226">	}</a>
<a name="ln2227">    }</a>
<a name="ln2228"> </a>
<a name="ln2229">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2230">    zlog_debug (&quot;couldn't find any VL to associate the packet with&quot;);</a>
<a name="ln2231">  </a>
<a name="ln2232">  return NULL;</a>
<a name="ln2233">}</a>
<a name="ln2234"> </a>
<a name="ln2235">static int</a>
<a name="ln2236">ospf_check_area_id (struct ospf_interface *oi, struct ospf_header *ospfh)</a>
<a name="ln2237">{</a>
<a name="ln2238">  /* Check match the Area ID of the receiving interface. */</a>
<a name="ln2239">  if (OSPF_AREA_SAME (&amp;oi-&gt;area, &amp;ospfh))</a>
<a name="ln2240">    return 1;</a>
<a name="ln2241"> </a>
<a name="ln2242">  return 0;</a>
<a name="ln2243">}</a>
<a name="ln2244"> </a>
<a name="ln2245">/* Unbound socket will accept any Raw IP packets if proto is matched.</a>
<a name="ln2246">   To prevent it, compare src IP address and i/f address with masking</a>
<a name="ln2247">   i/f network mask. */</a>
<a name="ln2248">static int</a>
<a name="ln2249">ospf_check_network_mask (struct ospf_interface *oi, struct in_addr ip_src)</a>
<a name="ln2250">{</a>
<a name="ln2251">  struct in_addr mask, me, him;</a>
<a name="ln2252"> </a>
<a name="ln2253">  if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT ||</a>
<a name="ln2254">      oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln2255">    return 1;</a>
<a name="ln2256"> </a>
<a name="ln2257">  masklen2ip (oi-&gt;address-&gt;prefixlen, &amp;mask);</a>
<a name="ln2258"> </a>
<a name="ln2259">  me.s_addr = oi-&gt;address-&gt;u.prefix4.s_addr &amp; mask.s_addr;</a>
<a name="ln2260">  him.s_addr = ip_src.s_addr &amp; mask.s_addr;</a>
<a name="ln2261"> </a>
<a name="ln2262"> if (IPV4_ADDR_SAME (&amp;me, &amp;him))</a>
<a name="ln2263">   return 1;</a>
<a name="ln2264"> </a>
<a name="ln2265"> return 0;</a>
<a name="ln2266">}</a>
<a name="ln2267"> </a>
<a name="ln2268">/* Return 1, if the packet is properly authenticated and checksummed,</a>
<a name="ln2269">   0 otherwise. In particular, check that AuType header field is valid and</a>
<a name="ln2270">   matches the locally configured AuType, and that D.5 requirements are met. */</a>
<a name="ln2271">static int</a>
<a name="ln2272">ospf_check_auth (struct ospf_interface *oi, struct ospf_header *ospfh)</a>
<a name="ln2273">{</a>
<a name="ln2274">  struct crypt_key *ck;</a>
<a name="ln2275">  u_int16_t iface_auth_type;</a>
<a name="ln2276">  u_int16_t pkt_auth_type = ntohs (ospfh-&gt;auth_type);</a>
<a name="ln2277"> </a>
<a name="ln2278">  switch (pkt_auth_type)</a>
<a name="ln2279">  {</a>
<a name="ln2280">  case OSPF_AUTH_NULL: /* RFC2328 D.5.1 */</a>
<a name="ln2281">    if (OSPF_AUTH_NULL != (iface_auth_type = ospf_auth_type (oi)))</a>
<a name="ln2282">    {</a>
<a name="ln2283">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2284">        zlog_warn (&quot;interface %s: auth-type mismatch, local %s, rcvd Null&quot;,</a>
<a name="ln2285">                   IF_NAME (oi), LOOKUP (ospf_auth_type_str, iface_auth_type));</a>
<a name="ln2286">      return 0;</a>
<a name="ln2287">    }</a>
<a name="ln2288">    if (! ospf_check_sum (ospfh))</a>
<a name="ln2289">    {</a>
<a name="ln2290">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2291">        zlog_warn (&quot;interface %s: Null auth OK, but checksum error, Router-ID %s&quot;,</a>
<a name="ln2292">                   IF_NAME (oi), inet_ntoa (ospfh-&gt;router_id));</a>
<a name="ln2293">      return 0;</a>
<a name="ln2294">    }</a>
<a name="ln2295">    return 1;</a>
<a name="ln2296">  case OSPF_AUTH_SIMPLE: /* RFC2328 D.5.2 */</a>
<a name="ln2297">    if (OSPF_AUTH_SIMPLE != (iface_auth_type = ospf_auth_type (oi)))</a>
<a name="ln2298">    {</a>
<a name="ln2299">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2300">        zlog_warn (&quot;interface %s: auth-type mismatch, local %s, rcvd Simple&quot;,</a>
<a name="ln2301">                   IF_NAME (oi), LOOKUP (ospf_auth_type_str, iface_auth_type));</a>
<a name="ln2302">      return 0;</a>
<a name="ln2303">    }</a>
<a name="ln2304">    if (memcmp (OSPF_IF_PARAM (oi, auth_simple), ospfh-&gt;u.auth_data, OSPF_AUTH_SIMPLE_SIZE))</a>
<a name="ln2305">    {</a>
<a name="ln2306">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2307">        zlog_warn (&quot;interface %s: Simple auth failed&quot;, IF_NAME (oi));</a>
<a name="ln2308">      return 0;</a>
<a name="ln2309">    }</a>
<a name="ln2310">    if (! ospf_check_sum (ospfh))</a>
<a name="ln2311">    {</a>
<a name="ln2312">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2313">        zlog_warn (&quot;interface %s: Simple auth OK, checksum error, Router-ID %s&quot;,</a>
<a name="ln2314">                   IF_NAME (oi), inet_ntoa (ospfh-&gt;router_id));</a>
<a name="ln2315">      return 0;</a>
<a name="ln2316">    }</a>
<a name="ln2317">    return 1;</a>
<a name="ln2318">  case OSPF_AUTH_CRYPTOGRAPHIC: /* RFC2328 D.5.3 */</a>
<a name="ln2319">    if (OSPF_AUTH_CRYPTOGRAPHIC != (iface_auth_type = ospf_auth_type (oi)))</a>
<a name="ln2320">    {</a>
<a name="ln2321">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2322">        zlog_warn (&quot;interface %s: auth-type mismatch, local %s, rcvd Cryptographic&quot;,</a>
<a name="ln2323">                   IF_NAME (oi), LOOKUP (ospf_auth_type_str, iface_auth_type));</a>
<a name="ln2324">      return 0;</a>
<a name="ln2325">    }</a>
<a name="ln2326">    if (ospfh-&gt;checksum)</a>
<a name="ln2327">    {</a>
<a name="ln2328">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2329">        zlog_warn (&quot;interface %s: OSPF header checksum is not 0&quot;, IF_NAME (oi));</a>
<a name="ln2330">      return 0;</a>
<a name="ln2331">    }</a>
<a name="ln2332">    /* only MD5 crypto method can pass ospf_packet_examin() */</a>
<a name="ln2333">    if</a>
<a name="ln2334">    (</a>
<a name="ln2335">      NULL == (ck = listgetdata (listtail(OSPF_IF_PARAM (oi,auth_crypt)))) ||</a>
<a name="ln2336">      ospfh-&gt;u.crypt.key_id != ck-&gt;key_id ||</a>
<a name="ln2337">      /* Condition above uses the last key ID on the list, which is</a>
<a name="ln2338">         different from what ospf_crypt_key_lookup() does. A bug? */</a>
<a name="ln2339">      ! ospf_check_md5_digest (oi, ospfh)</a>
<a name="ln2340">    )</a>
<a name="ln2341">    {</a>
<a name="ln2342">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2343">        zlog_warn (&quot;interface %s: MD5 auth failed&quot;, IF_NAME (oi));</a>
<a name="ln2344">      return 0;</a>
<a name="ln2345">    }</a>
<a name="ln2346">    return 1;</a>
<a name="ln2347">  default:</a>
<a name="ln2348">    if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2349">      zlog_warn (&quot;interface %s: invalid packet auth-type (%02x)&quot;,</a>
<a name="ln2350">                 IF_NAME (oi), pkt_auth_type);</a>
<a name="ln2351">    return 0;</a>
<a name="ln2352">  }</a>
<a name="ln2353">}</a>
<a name="ln2354"> </a>
<a name="ln2355">static int</a>
<a name="ln2356">ospf_check_sum (struct ospf_header *ospfh)</a>
<a name="ln2357">{</a>
<a name="ln2358">  u_int32_t ret;</a>
<a name="ln2359">  u_int16_t sum;</a>
<a name="ln2360"> </a>
<a name="ln2361">  /* clear auth_data for checksum. */</a>
<a name="ln2362">  memset (ospfh-&gt;u.auth_data, 0, OSPF_AUTH_SIMPLE_SIZE);</a>
<a name="ln2363"> </a>
<a name="ln2364">  /* keep checksum and clear. */</a>
<a name="ln2365">  sum = ospfh-&gt;checksum;</a>
<a name="ln2366">  memset (&amp;ospfh-&gt;checksum, 0, sizeof (u_int16_t));</a>
<a name="ln2367"> </a>
<a name="ln2368">  /* calculate checksum. */</a>
<a name="ln2369">  ret = in_cksum (ospfh, ntohs (ospfh-&gt;length));</a>
<a name="ln2370"> </a>
<a name="ln2371">  if (ret != sum)</a>
<a name="ln2372">    {</a>
<a name="ln2373">      zlog_info (&quot;ospf_check_sum(): checksum mismatch, my %X, his %X&quot;,</a>
<a name="ln2374">		 ret, sum);</a>
<a name="ln2375">      return 0;</a>
<a name="ln2376">    }</a>
<a name="ln2377"> </a>
<a name="ln2378">  return 1;</a>
<a name="ln2379">}</a>
<a name="ln2380"> </a>
<a name="ln2381">/* Verify, that given link/TOS records are properly sized/aligned and match</a>
<a name="ln2382">   Router-LSA &quot;# links&quot; and &quot;# TOS&quot; fields as specified in RFC2328 A.4.2. */</a>
<a name="ln2383">static unsigned</a>
<a name="ln2384">ospf_router_lsa_links_examin</a>
<a name="ln2385">(</a>
<a name="ln2386">  struct router_lsa_link * link,</a>
<a name="ln2387">  u_int16_t linkbytes,</a>
<a name="ln2388">  const u_int16_t num_links</a>
<a name="ln2389">)</a>
<a name="ln2390">{</a>
<a name="ln2391">  unsigned counted_links = 0, thislinklen;</a>
<a name="ln2392"> </a>
<a name="ln2393">  while (linkbytes)</a>
<a name="ln2394">  {</a>
<a name="ln2395">    thislinklen = OSPF_ROUTER_LSA_LINK_SIZE + 4 * link-&gt;m[0].tos_count;</a>
<a name="ln2396">    if (thislinklen &gt; linkbytes)</a>
<a name="ln2397">    {</a>
<a name="ln2398">      if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2399">        zlog_debug (&quot;%s: length error in link block #%u&quot;, __func__, counted_links);</a>
<a name="ln2400">      return MSG_NG;</a>
<a name="ln2401">    }</a>
<a name="ln2402">    link = (struct router_lsa_link *)((caddr_t) link + thislinklen);</a>
<a name="ln2403">    linkbytes -= thislinklen;</a>
<a name="ln2404">    counted_links++;</a>
<a name="ln2405">  }</a>
<a name="ln2406">  if (counted_links != num_links)</a>
<a name="ln2407">  {</a>
<a name="ln2408">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2409">      zlog_debug (&quot;%s: %u link blocks declared, %u present&quot;,</a>
<a name="ln2410">                  __func__, num_links, counted_links);</a>
<a name="ln2411">    return MSG_NG;</a>
<a name="ln2412">  }</a>
<a name="ln2413">  return MSG_OK;</a>
<a name="ln2414">}</a>
<a name="ln2415"> </a>
<a name="ln2416">/* Verify, that the given LSA is properly sized/aligned (including type-specific</a>
<a name="ln2417">   minimum length constraint). */</a>
<a name="ln2418">static unsigned</a>
<a name="ln2419">ospf_lsa_examin (struct lsa_header * lsah, const u_int16_t lsalen, const u_char headeronly)</a>
<a name="ln2420">{</a>
<a name="ln2421">  unsigned ret;</a>
<a name="ln2422">  struct router_lsa * rlsa;</a>
<a name="ln2423">  if</a>
<a name="ln2424">  (</a>
<a name="ln2425">    lsah-&gt;type &lt; OSPF_MAX_LSA &amp;&amp;</a>
<a name="ln2426">    ospf_lsa_minlen[lsah-&gt;type] &amp;&amp;</a>
<a name="ln2427">    lsalen &lt; OSPF_LSA_HEADER_SIZE + ospf_lsa_minlen[lsah-&gt;type]</a>
<a name="ln2428">  )</a>
<a name="ln2429">  {</a>
<a name="ln2430">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2431">      zlog_debug (&quot;%s: undersized (%u B) %s&quot;,</a>
<a name="ln2432">                  __func__, lsalen, LOOKUP (ospf_lsa_type_msg, lsah-&gt;type));</a>
<a name="ln2433">    return MSG_NG;</a>
<a name="ln2434">  }</a>
<a name="ln2435">  switch (lsah-&gt;type)</a>
<a name="ln2436">  {</a>
<a name="ln2437">  case OSPF_ROUTER_LSA:</a>
<a name="ln2438">    /* RFC2328 A.4.2, LSA header + 4 bytes followed by N&gt;=1 (12+)-byte link blocks */</a>
<a name="ln2439">    if (headeronly)</a>
<a name="ln2440">    {</a>
<a name="ln2441">      ret = (lsalen - OSPF_LSA_HEADER_SIZE - OSPF_ROUTER_LSA_MIN_SIZE) % 4 ? MSG_NG : MSG_OK;</a>
<a name="ln2442">      break;</a>
<a name="ln2443">    }</a>
<a name="ln2444">    rlsa = (struct router_lsa *) lsah;</a>
<a name="ln2445">    ret = ospf_router_lsa_links_examin</a>
<a name="ln2446">    (</a>
<a name="ln2447">      (struct router_lsa_link *) rlsa-&gt;link,</a>
<a name="ln2448">      lsalen - OSPF_LSA_HEADER_SIZE - 4, /* skip: basic header, &quot;flags&quot;, 0, &quot;# links&quot; */</a>
<a name="ln2449">      ntohs (rlsa-&gt;links) /* 16 bits */</a>
<a name="ln2450">    );</a>
<a name="ln2451">    break;</a>
<a name="ln2452">  case OSPF_AS_EXTERNAL_LSA:</a>
<a name="ln2453">    /* RFC2328 A.4.5, LSA header + 4 bytes followed by N&gt;=1 12-bytes long blocks */</a>
<a name="ln2454">  case OSPF_AS_NSSA_LSA:</a>
<a name="ln2455">    /* RFC3101 C, idem */</a>
<a name="ln2456">    ret = (lsalen - OSPF_LSA_HEADER_SIZE - OSPF_AS_EXTERNAL_LSA_MIN_SIZE) % 12 ? MSG_NG : MSG_OK;</a>
<a name="ln2457">    break;</a>
<a name="ln2458">  /* Following LSA types are considered OK length-wise as soon as their minimum</a>
<a name="ln2459">   * length constraint is met and length of the whole LSA is a multiple of 4</a>
<a name="ln2460">   * (basic LSA header size is already a multiple of 4). */</a>
<a name="ln2461">  case OSPF_NETWORK_LSA:</a>
<a name="ln2462">    /* RFC2328 A.4.3, LSA header + 4 bytes followed by N&gt;=1 router-IDs */</a>
<a name="ln2463">  case OSPF_SUMMARY_LSA:</a>
<a name="ln2464">  case OSPF_ASBR_SUMMARY_LSA:</a>
<a name="ln2465">    /* RFC2328 A.4.4, LSA header + 4 bytes followed by N&gt;=1 4-bytes TOS blocks */</a>
<a name="ln2466">  case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln2467">  case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln2468">  case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln2469">    /* RFC5250 A.2, &quot;some number of octets (of application-specific</a>
<a name="ln2470">     * data) padded to 32-bit alignment.&quot; This is considered equivalent</a>
<a name="ln2471">     * to 4-byte alignment of all other LSA types, see OSPF-ALIGNMENT.txt</a>
<a name="ln2472">     * file for the detailed analysis of this passage. */</a>
<a name="ln2473">    ret = lsalen % 4 ? MSG_NG : MSG_OK;</a>
<a name="ln2474">    break;</a>
<a name="ln2475">  default:</a>
<a name="ln2476">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2477">      zlog_debug (&quot;%s: unsupported LSA type 0x%02x&quot;, __func__, lsah-&gt;type);</a>
<a name="ln2478">    return MSG_NG;</a>
<a name="ln2479">  }</a>
<a name="ln2480">  if (ret != MSG_OK &amp;&amp; IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2481">    zlog_debug (&quot;%s: alignment error in %s&quot;,</a>
<a name="ln2482">                __func__, LOOKUP (ospf_lsa_type_msg, lsah-&gt;type));</a>
<a name="ln2483">  return ret;</a>
<a name="ln2484">}</a>
<a name="ln2485"> </a>
<a name="ln2486">/* Verify if the provided input buffer is a valid sequence of LSAs. This</a>
<a name="ln2487">   includes verification of LSA blocks length/alignment and dispatching</a>
<a name="ln2488">   of deeper-level checks. */</a>
<a name="ln2489">static unsigned</a>
<a name="ln2490">ospf_lsaseq_examin</a>
<a name="ln2491">(</a>
<a name="ln2492">  struct lsa_header *lsah, /* start of buffered data */</a>
<a name="ln2493">  size_t length,</a>
<a name="ln2494">  const u_char headeronly,</a>
<a name="ln2495">  /* When declared_num_lsas is not 0, compare it to the real number of LSAs</a>
<a name="ln2496">     and treat the difference as an error. */</a>
<a name="ln2497">  const u_int32_t declared_num_lsas</a>
<a name="ln2498">)</a>
<a name="ln2499">{</a>
<a name="ln2500">  u_int32_t counted_lsas = 0;</a>
<a name="ln2501"> </a>
<a name="ln2502">  while (length)</a>
<a name="ln2503">  {</a>
<a name="ln2504">    u_int16_t lsalen;</a>
<a name="ln2505">    if (length &lt; OSPF_LSA_HEADER_SIZE)</a>
<a name="ln2506">    {</a>
<a name="ln2507">      if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2508">        zlog_debug (&quot;%s: undersized (%zu B) trailing (#%u) LSA header&quot;,</a>
<a name="ln2509">                    __func__, length, counted_lsas);</a>
<a name="ln2510">      return MSG_NG;</a>
<a name="ln2511">    }</a>
<a name="ln2512">    /* save on ntohs() calls here and in the LSA validator */</a>
<a name="ln2513">    lsalen = ntohs (lsah-&gt;length);</a>
<a name="ln2514">    if (lsalen &lt; OSPF_LSA_HEADER_SIZE)</a>
<a name="ln2515">    {</a>
<a name="ln2516">      if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2517">        zlog_debug (&quot;%s: malformed LSA header #%u, declared length is %u B&quot;,</a>
<a name="ln2518">                    __func__, counted_lsas, lsalen);</a>
<a name="ln2519">      return MSG_NG;</a>
<a name="ln2520">    }</a>
<a name="ln2521">    if (headeronly)</a>
<a name="ln2522">    {</a>
<a name="ln2523">      /* less checks here and in ospf_lsa_examin() */</a>
<a name="ln2524">      if (MSG_OK != ospf_lsa_examin (lsah, lsalen, 1))</a>
<a name="ln2525">      {</a>
<a name="ln2526">        if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2527">          zlog_debug (&quot;%s: malformed header-only LSA #%u&quot;, __func__, counted_lsas);</a>
<a name="ln2528">        return MSG_NG;</a>
<a name="ln2529">      }</a>
<a name="ln2530">      lsah = (struct lsa_header *) ((caddr_t) lsah + OSPF_LSA_HEADER_SIZE);</a>
<a name="ln2531">      length -= OSPF_LSA_HEADER_SIZE;</a>
<a name="ln2532">    }</a>
<a name="ln2533">    else</a>
<a name="ln2534">    {</a>
<a name="ln2535">      /* make sure the input buffer is deep enough before further checks */</a>
<a name="ln2536">      if (lsalen &gt; length)</a>
<a name="ln2537">      {</a>
<a name="ln2538">        if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2539">          zlog_debug (&quot;%s: anomaly in LSA #%u: declared length is %u B, buffered length is %zu B&quot;,</a>
<a name="ln2540">                      __func__, counted_lsas, lsalen, length);</a>
<a name="ln2541">        return MSG_NG;</a>
<a name="ln2542">      }</a>
<a name="ln2543">      if (MSG_OK != ospf_lsa_examin (lsah, lsalen, 0))</a>
<a name="ln2544">      {</a>
<a name="ln2545">        if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2546">          zlog_debug (&quot;%s: malformed LSA #%u&quot;, __func__, counted_lsas);</a>
<a name="ln2547">        return MSG_NG;</a>
<a name="ln2548">      }</a>
<a name="ln2549">      lsah = (struct lsa_header *) ((caddr_t) lsah + lsalen);</a>
<a name="ln2550">      length -= lsalen;</a>
<a name="ln2551">    }</a>
<a name="ln2552">    counted_lsas++;</a>
<a name="ln2553">  }</a>
<a name="ln2554"> </a>
<a name="ln2555">  if (declared_num_lsas &amp;&amp; counted_lsas != declared_num_lsas)</a>
<a name="ln2556">  {</a>
<a name="ln2557">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2558">      zlog_debug (&quot;%s: #LSAs declared (%u) does not match actual (%u)&quot;,</a>
<a name="ln2559">                  __func__, declared_num_lsas, counted_lsas);</a>
<a name="ln2560">    return MSG_NG;</a>
<a name="ln2561">  }</a>
<a name="ln2562">  return MSG_OK;</a>
<a name="ln2563">}</a>
<a name="ln2564"> </a>
<a name="ln2565">/* Verify a complete OSPF packet for proper sizing/alignment. */</a>
<a name="ln2566">static unsigned</a>
<a name="ln2567">ospf_packet_examin (struct ospf_header * oh, const unsigned bytesonwire)</a>
<a name="ln2568">{</a>
<a name="ln2569">  u_int16_t bytesdeclared, bytesauth;</a>
<a name="ln2570">  unsigned ret;</a>
<a name="ln2571">  struct ospf_ls_update * lsupd;</a>
<a name="ln2572"> </a>
<a name="ln2573">  /* Length, 1st approximation. */</a>
<a name="ln2574">  if (bytesonwire &lt; OSPF_HEADER_SIZE)</a>
<a name="ln2575">  {</a>
<a name="ln2576">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2577">      zlog_debug (&quot;%s: undersized (%u B) packet&quot;, __func__, bytesonwire);</a>
<a name="ln2578">    return MSG_NG;</a>
<a name="ln2579">  }</a>
<a name="ln2580">  /* Now it is safe to access header fields. Performing length check, allow</a>
<a name="ln2581">   * for possible extra bytes of crypto auth/padding, which are not counted</a>
<a name="ln2582">   * in the OSPF header &quot;length&quot; field. */</a>
<a name="ln2583">  if (oh-&gt;version != OSPF_VERSION)</a>
<a name="ln2584">  {</a>
<a name="ln2585">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2586">      zlog_debug (&quot;%s: invalid (%u) protocol version&quot;, __func__, oh-&gt;version);</a>
<a name="ln2587">    return MSG_NG;</a>
<a name="ln2588">  }</a>
<a name="ln2589">  bytesdeclared = ntohs (oh-&gt;length);</a>
<a name="ln2590">  if (ntohs (oh-&gt;auth_type) != OSPF_AUTH_CRYPTOGRAPHIC)</a>
<a name="ln2591">    bytesauth = 0;</a>
<a name="ln2592">  else</a>
<a name="ln2593">  {</a>
<a name="ln2594">    if (oh-&gt;u.crypt.auth_data_len != OSPF_AUTH_MD5_SIZE)</a>
<a name="ln2595">    {</a>
<a name="ln2596">      if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2597">        zlog_debug (&quot;%s: unsupported crypto auth length (%u B)&quot;,</a>
<a name="ln2598">                    __func__, oh-&gt;u.crypt.auth_data_len);</a>
<a name="ln2599">      return MSG_NG;</a>
<a name="ln2600">    }</a>
<a name="ln2601">    bytesauth = OSPF_AUTH_MD5_SIZE;</a>
<a name="ln2602">  }</a>
<a name="ln2603">  if (bytesdeclared + bytesauth &gt; bytesonwire)</a>
<a name="ln2604">  {</a>
<a name="ln2605">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2606">      zlog_debug (&quot;%s: packet length error (%u real, %u+%u declared)&quot;,</a>
<a name="ln2607">                  __func__, bytesonwire, bytesdeclared, bytesauth);</a>
<a name="ln2608">    return MSG_NG;</a>
<a name="ln2609">  }</a>
<a name="ln2610">  /* Length, 2nd approximation. The type-specific constraint is checked</a>
<a name="ln2611">     against declared length, not amount of bytes on wire. */</a>
<a name="ln2612">  if</a>
<a name="ln2613">  (</a>
<a name="ln2614">    oh-&gt;type &gt;= OSPF_MSG_HELLO &amp;&amp;</a>
<a name="ln2615">    oh-&gt;type &lt;= OSPF_MSG_LS_ACK &amp;&amp;</a>
<a name="ln2616">    bytesdeclared &lt; OSPF_HEADER_SIZE + ospf_packet_minlen[oh-&gt;type]</a>
<a name="ln2617">  )</a>
<a name="ln2618">  {</a>
<a name="ln2619">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2620">      zlog_debug (&quot;%s: undersized (%u B) %s packet&quot;, __func__,</a>
<a name="ln2621">                  bytesdeclared, LOOKUP (ospf_packet_type_str, oh-&gt;type));</a>
<a name="ln2622">    return MSG_NG;</a>
<a name="ln2623">  }</a>
<a name="ln2624">  switch (oh-&gt;type)</a>
<a name="ln2625">  {</a>
<a name="ln2626">  case OSPF_MSG_HELLO:</a>
<a name="ln2627">    /* RFC2328 A.3.2, packet header + OSPF_HELLO_MIN_SIZE bytes followed</a>
<a name="ln2628">       by N&gt;=0 router-IDs. */</a>
<a name="ln2629">    ret = (bytesdeclared - OSPF_HEADER_SIZE - OSPF_HELLO_MIN_SIZE) % 4 ? MSG_NG : MSG_OK;</a>
<a name="ln2630">    break;</a>
<a name="ln2631">  case OSPF_MSG_DB_DESC:</a>
<a name="ln2632">    /* RFC2328 A.3.3, packet header + OSPF_DB_DESC_MIN_SIZE bytes followed</a>
<a name="ln2633">       by N&gt;=0 header-only LSAs. */</a>
<a name="ln2634">    ret = ospf_lsaseq_examin</a>
<a name="ln2635">    (</a>
<a name="ln2636">      (struct lsa_header *) ((caddr_t) oh + OSPF_HEADER_SIZE + OSPF_DB_DESC_MIN_SIZE),</a>
<a name="ln2637">      bytesdeclared - OSPF_HEADER_SIZE - OSPF_DB_DESC_MIN_SIZE,</a>
<a name="ln2638">      1, /* header-only LSAs */</a>
<a name="ln2639">      0</a>
<a name="ln2640">    );</a>
<a name="ln2641">    break;</a>
<a name="ln2642">  case OSPF_MSG_LS_REQ:</a>
<a name="ln2643">    /* RFC2328 A.3.4, packet header followed by N&gt;=0 12-bytes request blocks. */</a>
<a name="ln2644">    ret = (bytesdeclared - OSPF_HEADER_SIZE - OSPF_LS_REQ_MIN_SIZE) %</a>
<a name="ln2645">      OSPF_LSA_KEY_SIZE ? MSG_NG : MSG_OK;</a>
<a name="ln2646">    break;</a>
<a name="ln2647">  case OSPF_MSG_LS_UPD:</a>
<a name="ln2648">    /* RFC2328 A.3.5, packet header + OSPF_LS_UPD_MIN_SIZE bytes followed</a>
<a name="ln2649">       by N&gt;=0 full LSAs (with N declared beforehand). */</a>
<a name="ln2650">    lsupd = (struct ospf_ls_update *) ((caddr_t) oh + OSPF_HEADER_SIZE);</a>
<a name="ln2651">    ret = ospf_lsaseq_examin</a>
<a name="ln2652">    (</a>
<a name="ln2653">      (struct lsa_header *) ((caddr_t) lsupd + OSPF_LS_UPD_MIN_SIZE),</a>
<a name="ln2654">      bytesdeclared - OSPF_HEADER_SIZE - OSPF_LS_UPD_MIN_SIZE,</a>
<a name="ln2655">      0, /* full LSAs */</a>
<a name="ln2656">      ntohl (lsupd-&gt;num_lsas) /* 32 bits */</a>
<a name="ln2657">    );</a>
<a name="ln2658">    break;</a>
<a name="ln2659">  case OSPF_MSG_LS_ACK:</a>
<a name="ln2660">    /* RFC2328 A.3.6, packet header followed by N&gt;=0 header-only LSAs. */</a>
<a name="ln2661">    ret = ospf_lsaseq_examin</a>
<a name="ln2662">    (</a>
<a name="ln2663">      (struct lsa_header *) ((caddr_t) oh + OSPF_HEADER_SIZE + OSPF_LS_ACK_MIN_SIZE),</a>
<a name="ln2664">      bytesdeclared - OSPF_HEADER_SIZE - OSPF_LS_ACK_MIN_SIZE,</a>
<a name="ln2665">      1, /* header-only LSAs */</a>
<a name="ln2666">      0</a>
<a name="ln2667">    );</a>
<a name="ln2668">    break;</a>
<a name="ln2669">  default:</a>
<a name="ln2670">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2671">      zlog_debug (&quot;%s: invalid packet type 0x%02x&quot;, __func__, oh-&gt;type);</a>
<a name="ln2672">    return MSG_NG;</a>
<a name="ln2673">  }</a>
<a name="ln2674">  if (ret != MSG_OK &amp;&amp; IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2675">    zlog_debug (&quot;%s: malformed %s packet&quot;, __func__, LOOKUP (ospf_packet_type_str, oh-&gt;type));</a>
<a name="ln2676">  return ret;</a>
<a name="ln2677">}</a>
<a name="ln2678"> </a>
<a name="ln2679">/* OSPF Header verification. */</a>
<a name="ln2680">static int</a>
<a name="ln2681">ospf_verify_header (struct stream *ibuf, struct ospf_interface *oi,</a>
<a name="ln2682">		    struct ip *iph, struct ospf_header *ospfh)</a>
<a name="ln2683">{</a>
<a name="ln2684">  /* Check Area ID. */</a>
<a name="ln2685">  if (!ospf_check_area_id (oi, ospfh))</a>
<a name="ln2686">    {</a>
<a name="ln2687">      zlog_warn (&quot;interface %s: ospf_read invalid Area ID %s.&quot;,</a>
<a name="ln2688">		 IF_NAME (oi), inet_ntoa (ospfh-&gt;area_id));</a>
<a name="ln2689">      return -1;</a>
<a name="ln2690">    }</a>
<a name="ln2691"> </a>
<a name="ln2692">  /* Check network mask, Silently discarded. */</a>
<a name="ln2693">  if (! ospf_check_network_mask (oi, iph-&gt;ip_src))</a>
<a name="ln2694">    {</a>
<a name="ln2695">      zlog_warn (&quot;interface %s: ospf_read network address is not same [%s]&quot;,</a>
<a name="ln2696">		 IF_NAME (oi), inet_ntoa (iph-&gt;ip_src));</a>
<a name="ln2697">      return -1;</a>
<a name="ln2698">    }</a>
<a name="ln2699"> </a>
<a name="ln2700">  /* Check authentication. The function handles logging actions, where required. */</a>
<a name="ln2701">  if (! ospf_check_auth (oi, ospfh))</a>
<a name="ln2702">    return -1;</a>
<a name="ln2703"> </a>
<a name="ln2704">  return 0;</a>
<a name="ln2705">}</a>
<a name="ln2706"> </a>
<a name="ln2707">/* Starting point of packet process function. */</a>
<a name="ln2708">int</a>
<a name="ln2709">ospf_read (struct thread *thread)</a>
<a name="ln2710">{</a>
<a name="ln2711">  int ret;</a>
<a name="ln2712">  struct stream *ibuf;</a>
<a name="ln2713">  struct ospf *ospf;</a>
<a name="ln2714">  struct ospf_interface *oi;</a>
<a name="ln2715">  struct ip *iph;</a>
<a name="ln2716">  struct ospf_header *ospfh;</a>
<a name="ln2717">  u_int16_t length;</a>
<a name="ln2718">  struct interface *ifp;</a>
<a name="ln2719"> </a>
<a name="ln2720">  /* first of all get interface pointer. */</a>
<a name="ln2721">  ospf = THREAD_ARG (thread);</a>
<a name="ln2722"> </a>
<a name="ln2723">  /* prepare for next packet. */</a>
<a name="ln2724">  ospf-&gt;t_read = thread_add_read (master, ospf_read, ospf, ospf-&gt;fd);</a>
<a name="ln2725"> </a>
<a name="ln2726">  stream_reset(ospf-&gt;ibuf);</a>
<a name="ln2727">  if (!(ibuf = ospf_recv_packet (ospf-&gt;fd, &amp;ifp, ospf-&gt;ibuf)))</a>
<a name="ln2728">    return -1;</a>
<a name="ln2729">  /* This raw packet is known to be at least as big as its IP header. */</a>
<a name="ln2730">  </a>
<a name="ln2731">  /* Note that there should not be alignment problems with this assignment</a>
<a name="ln2732">     because this is at the beginning of the stream data buffer. */</a>
<a name="ln2733">  iph = (struct ip *) STREAM_DATA (ibuf);</a>
<a name="ln2734">  /* Note that sockopt_iphdrincl_swab_systoh was called in ospf_recv_packet. */</a>
<a name="ln2735"> </a>
<a name="ln2736">  if (ifp == NULL)</a>
<a name="ln2737">    /* Handle cases where the platform does not support retrieving the ifindex,</a>
<a name="ln2738">       and also platforms (such as Solaris 8) that claim to support ifindex</a>
<a name="ln2739">       retrieval but do not. */</a>
<a name="ln2740">    ifp = if_lookup_address (iph-&gt;ip_src);</a>
<a name="ln2741">  </a>
<a name="ln2742">  if (ifp == NULL)</a>
<a name="ln2743">    return 0;</a>
<a name="ln2744"> </a>
<a name="ln2745">  /* IP Header dump. */</a>
<a name="ln2746">    if (IS_DEBUG_OSPF_PACKET(0, RECV))</a>
<a name="ln2747">	    ospf_ip_header_dump (iph);</a>
<a name="ln2748"> </a>
<a name="ln2749">  /* Self-originated packet should be discarded silently. */</a>
<a name="ln2750">  if (ospf_if_lookup_by_local_addr (ospf, NULL, iph-&gt;ip_src))</a>
<a name="ln2751">    {</a>
<a name="ln2752">      if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2753">        {</a>
<a name="ln2754">          zlog_debug (&quot;ospf_read[%s]: Dropping self-originated packet&quot;,</a>
<a name="ln2755">                     inet_ntoa (iph-&gt;ip_src));</a>
<a name="ln2756">        }</a>
<a name="ln2757">      return 0;</a>
<a name="ln2758">    }</a>
<a name="ln2759"> </a>
<a name="ln2760">  /* Advance from IP header to OSPF header (iph-&gt;ip_hl has been verified</a>
<a name="ln2761">     by ospf_recv_packet() to be correct). */</a>
<a name="ln2762">  stream_forward_getp (ibuf, iph-&gt;ip_hl * 4);</a>
<a name="ln2763"> </a>
<a name="ln2764">  ospfh = (struct ospf_header *) STREAM_PNT (ibuf);</a>
<a name="ln2765">  if (MSG_OK != ospf_packet_examin (ospfh, stream_get_endp (ibuf) - stream_get_getp (ibuf)))</a>
<a name="ln2766">    return -1;</a>
<a name="ln2767">  /* Now it is safe to access all fields of OSPF packet header. */</a>
<a name="ln2768"> </a>
<a name="ln2769">  /* associate packet with ospf interface */</a>
<a name="ln2770">  oi = ospf_if_lookup_recv_if (ospf, iph-&gt;ip_src, ifp);</a>
<a name="ln2771"> </a>
<a name="ln2772">  /* ospf_verify_header() relies on a valid &quot;oi&quot; and thus can be called only</a>
<a name="ln2773">     after the passive/backbone/other checks below are passed. These checks</a>
<a name="ln2774">     in turn access the fields of unverified &quot;ospfh&quot; structure for their own</a>
<a name="ln2775">     purposes and must remain very accurate in doing this. */</a>
<a name="ln2776"> </a>
<a name="ln2777">  /* If incoming interface is passive one, ignore it. */</a>
<a name="ln2778">  if (oi &amp;&amp; OSPF_IF_PASSIVE_STATUS (oi) == OSPF_IF_PASSIVE)</a>
<a name="ln2779">    {</a>
<a name="ln2780">      char buf[3][INET_ADDRSTRLEN];</a>
<a name="ln2781"> </a>
<a name="ln2782">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2783">	zlog_debug (&quot;ignoring packet from router %s sent to %s, &quot;</a>
<a name="ln2784">		    &quot;received on a passive interface, %s&quot;,</a>
<a name="ln2785">		    inet_ntop(AF_INET, &amp;ospfh-&gt;router_id, buf[0], sizeof(buf[0])),</a>
<a name="ln2786">		    inet_ntop(AF_INET, &amp;iph-&gt;ip_dst, buf[1], sizeof(buf[1])),</a>
<a name="ln2787">		    inet_ntop(AF_INET, &amp;oi-&gt;address-&gt;u.prefix4,</a>
<a name="ln2788">			      buf[2], sizeof(buf[2])));</a>
<a name="ln2789"> </a>
<a name="ln2790">      if (iph-&gt;ip_dst.s_addr == htonl(OSPF_ALLSPFROUTERS))</a>
<a name="ln2791">	{</a>
<a name="ln2792">	  /* Try to fix multicast membership.</a>
<a name="ln2793">	   * Some OS:es may have problems in this area,</a>
<a name="ln2794">	   * make sure it is removed.</a>
<a name="ln2795">	   */</a>
<a name="ln2796">	  OI_MEMBER_JOINED(oi, MEMBER_ALLROUTERS);</a>
<a name="ln2797">	  ospf_if_set_multicast(oi);</a>
<a name="ln2798">	}</a>
<a name="ln2799">      return 0;</a>
<a name="ln2800">  }</a>
<a name="ln2801"> </a>
<a name="ln2802"> </a>
<a name="ln2803">  /* if no local ospf_interface, </a>
<a name="ln2804">   * or header area is backbone but ospf_interface is not</a>
<a name="ln2805">   * check for VLINK interface</a>
<a name="ln2806">   */</a>
<a name="ln2807">  if ( (oi == NULL) ||</a>
<a name="ln2808">      (OSPF_IS_AREA_ID_BACKBONE(ospfh-&gt;area_id)</a>
<a name="ln2809">      &amp;&amp; !OSPF_IS_AREA_ID_BACKBONE(oi-&gt;area-&gt;area_id))</a>
<a name="ln2810">     )</a>
<a name="ln2811">    {</a>
<a name="ln2812">      if ((oi = ospf_associate_packet_vl (ospf, ifp, iph, ospfh)) == NULL)</a>
<a name="ln2813">        {</a>
<a name="ln2814">          if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2815">            zlog_debug (&quot;Packet from [%s] received on link %s&quot;</a>
<a name="ln2816">                        &quot; but no ospf_interface&quot;,</a>
<a name="ln2817">                        inet_ntoa (iph-&gt;ip_src), ifp-&gt;name);</a>
<a name="ln2818">          return 0;</a>
<a name="ln2819">        }</a>
<a name="ln2820">    }</a>
<a name="ln2821"> </a>
<a name="ln2822">  /* else it must be a local ospf interface, check it was received on </a>
<a name="ln2823">   * correct link </a>
<a name="ln2824">   */</a>
<a name="ln2825">  else if (oi-&gt;ifp != ifp)</a>
<a name="ln2826">    {</a>
<a name="ln2827">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2828">        zlog_warn (&quot;Packet from [%s] received on wrong link %s&quot;,</a>
<a name="ln2829">                   inet_ntoa (iph-&gt;ip_src), ifp-&gt;name); </a>
<a name="ln2830">      return 0;</a>
<a name="ln2831">    }</a>
<a name="ln2832">  else if (oi-&gt;state == ISM_Down)</a>
<a name="ln2833">    {</a>
<a name="ln2834">      char buf[2][INET_ADDRSTRLEN];</a>
<a name="ln2835">      zlog_warn (&quot;Ignoring packet from %s to %s received on interface that is &quot;</a>
<a name="ln2836">      		 &quot;down [%s]; interface flags are %s&quot;,</a>
<a name="ln2837">		 inet_ntop(AF_INET, &amp;iph-&gt;ip_src, buf[0], sizeof(buf[0])),</a>
<a name="ln2838">		 inet_ntop(AF_INET, &amp;iph-&gt;ip_dst, buf[1], sizeof(buf[1])),</a>
<a name="ln2839">	         ifp-&gt;name, if_flag_dump(ifp-&gt;flags));</a>
<a name="ln2840">      /* Fix multicast memberships? */</a>
<a name="ln2841">      if (iph-&gt;ip_dst.s_addr == htonl(OSPF_ALLSPFROUTERS))</a>
<a name="ln2842">        OI_MEMBER_JOINED(oi, MEMBER_ALLROUTERS);</a>
<a name="ln2843">      else if (iph-&gt;ip_dst.s_addr == htonl(OSPF_ALLDROUTERS))</a>
<a name="ln2844">	OI_MEMBER_JOINED(oi, MEMBER_DROUTERS);</a>
<a name="ln2845">      if (oi-&gt;multicast_memberships)</a>
<a name="ln2846">	ospf_if_set_multicast(oi);</a>
<a name="ln2847">      return 0;</a>
<a name="ln2848">    }</a>
<a name="ln2849"> </a>
<a name="ln2850">  /*</a>
<a name="ln2851">   * If the received packet is destined for AllDRouters, the packet</a>
<a name="ln2852">   * should be accepted only if the received ospf interface state is</a>
<a name="ln2853">   * either DR or Backup -- endo.</a>
<a name="ln2854">   */</a>
<a name="ln2855">  if (iph-&gt;ip_dst.s_addr == htonl (OSPF_ALLDROUTERS)</a>
<a name="ln2856">  &amp;&amp; (oi-&gt;state != ISM_DR &amp;&amp; oi-&gt;state != ISM_Backup))</a>
<a name="ln2857">    {</a>
<a name="ln2858">      zlog_warn (&quot;Dropping packet for AllDRouters from [%s] via [%s] (ISM: %s)&quot;,</a>
<a name="ln2859">                 inet_ntoa (iph-&gt;ip_src), IF_NAME (oi),</a>
<a name="ln2860">                 LOOKUP (ospf_ism_state_msg, oi-&gt;state));</a>
<a name="ln2861">      /* Try to fix multicast membership. */</a>
<a name="ln2862">      SET_FLAG(oi-&gt;multicast_memberships, MEMBER_DROUTERS);</a>
<a name="ln2863">      ospf_if_set_multicast(oi);</a>
<a name="ln2864">      return 0;</a>
<a name="ln2865">    }</a>
<a name="ln2866"> </a>
<a name="ln2867">  /* Verify more OSPF header fields. */</a>
<a name="ln2868">  ret = ospf_verify_header (ibuf, oi, iph, ospfh);</a>
<a name="ln2869">  if (ret &lt; 0)</a>
<a name="ln2870">  {</a>
<a name="ln2871">    if (IS_DEBUG_OSPF_PACKET (0, RECV))</a>
<a name="ln2872">      zlog_debug (&quot;ospf_read[%s]: Header check failed, &quot;</a>
<a name="ln2873">                  &quot;dropping.&quot;,</a>
<a name="ln2874">                  inet_ntoa (iph-&gt;ip_src));</a>
<a name="ln2875">    return ret;</a>
<a name="ln2876">  }</a>
<a name="ln2877"> </a>
<a name="ln2878">  /* Show debug receiving packet. */</a>
<a name="ln2879">  if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, RECV))</a>
<a name="ln2880">    {</a>
<a name="ln2881">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, DETAIL))</a>
<a name="ln2882">        {</a>
<a name="ln2883">          zlog_debug (&quot;-----------------------------------------------------&quot;);</a>
<a name="ln2884">          ospf_packet_dump (ibuf);</a>
<a name="ln2885">        }</a>
<a name="ln2886"> </a>
<a name="ln2887">      zlog_debug (&quot;%s received from [%s] via [%s]&quot;,</a>
<a name="ln2888">                 LOOKUP (ospf_packet_type_str, ospfh-&gt;type),</a>
<a name="ln2889">                 inet_ntoa (ospfh-&gt;router_id), IF_NAME (oi));</a>
<a name="ln2890">      zlog_debug (&quot; src [%s],&quot;, inet_ntoa (iph-&gt;ip_src));</a>
<a name="ln2891">      zlog_debug (&quot; dst [%s]&quot;, inet_ntoa (iph-&gt;ip_dst));</a>
<a name="ln2892"> </a>
<a name="ln2893">      if (IS_DEBUG_OSPF_PACKET (ospfh-&gt;type - 1, DETAIL))</a>
<a name="ln2894">	zlog_debug (&quot;-----------------------------------------------------&quot;);</a>
<a name="ln2895">  }</a>
<a name="ln2896"> </a>
<a name="ln2897">  stream_forward_getp (ibuf, OSPF_HEADER_SIZE);</a>
<a name="ln2898"> </a>
<a name="ln2899">  /* Adjust size to message length. */</a>
<a name="ln2900">  length = ntohs (ospfh-&gt;length) - OSPF_HEADER_SIZE;</a>
<a name="ln2901"> </a>
<a name="ln2902">  /* Read rest of the packet and call each sort of packet routine. */</a>
<a name="ln2903">  switch (ospfh-&gt;type)</a>
<a name="ln2904">    {</a>
<a name="ln2905">    case OSPF_MSG_HELLO:</a>
<a name="ln2906">      ospf_hello (iph, ospfh, ibuf, oi, length);</a>
<a name="ln2907">      break;</a>
<a name="ln2908">    case OSPF_MSG_DB_DESC:</a>
<a name="ln2909">      ospf_db_desc (iph, ospfh, ibuf, oi, length);</a>
<a name="ln2910">      break;</a>
<a name="ln2911">    case OSPF_MSG_LS_REQ:</a>
<a name="ln2912">      ospf_ls_req (iph, ospfh, ibuf, oi, length);</a>
<a name="ln2913">      break;</a>
<a name="ln2914">    case OSPF_MSG_LS_UPD:</a>
<a name="ln2915">      ospf_ls_upd (ospf, iph, ospfh, ibuf, oi, length);</a>
<a name="ln2916">      break;</a>
<a name="ln2917">    case OSPF_MSG_LS_ACK:</a>
<a name="ln2918">      ospf_ls_ack (iph, ospfh, ibuf, oi, length);</a>
<a name="ln2919">      break;</a>
<a name="ln2920">    default:</a>
<a name="ln2921">      zlog (NULL, LOG_WARNING,</a>
<a name="ln2922">	    &quot;interface %s: OSPF packet header type %d is illegal&quot;,</a>
<a name="ln2923">	    IF_NAME (oi), ospfh-&gt;type);</a>
<a name="ln2924">      break;</a>
<a name="ln2925">    }</a>
<a name="ln2926"> </a>
<a name="ln2927">  return 0;</a>
<a name="ln2928">}</a>
<a name="ln2929"> </a>
<a name="ln2930">/* Make OSPF header. */</a>
<a name="ln2931">static void</a>
<a name="ln2932">ospf_make_header (int type, struct ospf_interface *oi, struct stream *s)</a>
<a name="ln2933">{</a>
<a name="ln2934">  struct ospf_header *ospfh;</a>
<a name="ln2935"> </a>
<a name="ln2936">  ospfh = (struct ospf_header *) STREAM_DATA (s);</a>
<a name="ln2937"> </a>
<a name="ln2938">  ospfh-&gt;version = (u_char) OSPF_VERSION;</a>
<a name="ln2939">  ospfh-&gt;type = (u_char) type;</a>
<a name="ln2940"> </a>
<a name="ln2941">  ospfh-&gt;router_id = oi-&gt;ospf-&gt;router_id;</a>
<a name="ln2942"> </a>
<a name="ln2943">  ospfh-&gt;checksum = 0;</a>
<a name="ln2944">  ospfh-&gt;area_id = oi-&gt;area-&gt;area_id;</a>
<a name="ln2945">  ospfh-&gt;auth_type = htons (ospf_auth_type (oi));</a>
<a name="ln2946"> </a>
<a name="ln2947">  memset (ospfh-&gt;u.auth_data, 0, OSPF_AUTH_SIMPLE_SIZE);</a>
<a name="ln2948"> </a>
<a name="ln2949">  stream_forward_endp (s, OSPF_HEADER_SIZE);</a>
<a name="ln2950">}</a>
<a name="ln2951"> </a>
<a name="ln2952">/* Make Authentication Data. */</a>
<a name="ln2953">static int</a>
<a name="ln2954">ospf_make_auth (struct ospf_interface *oi, struct ospf_header *ospfh)</a>
<a name="ln2955">{</a>
<a name="ln2956">  struct crypt_key *ck;</a>
<a name="ln2957"> </a>
<a name="ln2958">  switch (ospf_auth_type (oi))</a>
<a name="ln2959">    {</a>
<a name="ln2960">    case OSPF_AUTH_NULL:</a>
<a name="ln2961">      /* memset (ospfh-&gt;u.auth_data, 0, sizeof (ospfh-&gt;u.auth_data)); */</a>
<a name="ln2962">      break;</a>
<a name="ln2963">    case OSPF_AUTH_SIMPLE:</a>
<a name="ln2964">      memcpy (ospfh-&gt;u.auth_data, OSPF_IF_PARAM (oi, auth_simple),</a>
<a name="ln2965">	      OSPF_AUTH_SIMPLE_SIZE);</a>
<a name="ln2966">      break;</a>
<a name="ln2967">    case OSPF_AUTH_CRYPTOGRAPHIC:</a>
<a name="ln2968">      /* If key is not set, then set 0. */</a>
<a name="ln2969">      if (list_isempty (OSPF_IF_PARAM (oi, auth_crypt)))</a>
<a name="ln2970">	{</a>
<a name="ln2971">	  ospfh-&gt;u.crypt.zero = 0;</a>
<a name="ln2972">	  ospfh-&gt;u.crypt.key_id = 0;</a>
<a name="ln2973">	  ospfh-&gt;u.crypt.auth_data_len = OSPF_AUTH_MD5_SIZE;</a>
<a name="ln2974">	}</a>
<a name="ln2975">      else</a>
<a name="ln2976">	{</a>
<a name="ln2977">	  ck = listgetdata (listtail(OSPF_IF_PARAM (oi, auth_crypt)));</a>
<a name="ln2978">	  ospfh-&gt;u.crypt.zero = 0;</a>
<a name="ln2979">	  ospfh-&gt;u.crypt.key_id = ck-&gt;key_id;</a>
<a name="ln2980">	  ospfh-&gt;u.crypt.auth_data_len = OSPF_AUTH_MD5_SIZE;</a>
<a name="ln2981">	}</a>
<a name="ln2982">      /* note: the seq is done in ospf_make_md5_digest() */</a>
<a name="ln2983">      break;</a>
<a name="ln2984">    default:</a>
<a name="ln2985">      /* memset (ospfh-&gt;u.auth_data, 0, sizeof (ospfh-&gt;u.auth_data)); */</a>
<a name="ln2986">      break;</a>
<a name="ln2987">    }</a>
<a name="ln2988"> </a>
<a name="ln2989">  return 0;</a>
<a name="ln2990">}</a>
<a name="ln2991"> </a>
<a name="ln2992">/* Fill rest of OSPF header. */</a>
<a name="ln2993">static void</a>
<a name="ln2994">ospf_fill_header (struct ospf_interface *oi,</a>
<a name="ln2995">		  struct stream *s, u_int16_t length)</a>
<a name="ln2996">{</a>
<a name="ln2997">  struct ospf_header *ospfh;</a>
<a name="ln2998"> </a>
<a name="ln2999">  ospfh = (struct ospf_header *) STREAM_DATA (s);</a>
<a name="ln3000"> </a>
<a name="ln3001">  /* Fill length. */</a>
<a name="ln3002">  ospfh-&gt;length = htons (length);</a>
<a name="ln3003"> </a>
<a name="ln3004">  /* Calculate checksum. */</a>
<a name="ln3005">  if (ntohs (ospfh-&gt;auth_type) != OSPF_AUTH_CRYPTOGRAPHIC)</a>
<a name="ln3006">    ospfh-&gt;checksum = in_cksum (ospfh, length);</a>
<a name="ln3007">  else</a>
<a name="ln3008">    ospfh-&gt;checksum = 0;</a>
<a name="ln3009"> </a>
<a name="ln3010">  /* Add Authentication Data. */</a>
<a name="ln3011">  ospf_make_auth (oi, ospfh);</a>
<a name="ln3012">}</a>
<a name="ln3013"> </a>
<a name="ln3014">static int</a>
<a name="ln3015">ospf_make_hello (struct ospf_interface *oi, struct stream *s)</a>
<a name="ln3016">{</a>
<a name="ln3017">  struct ospf_neighbor *nbr;</a>
<a name="ln3018">  struct route_node *rn;</a>
<a name="ln3019">  u_int16_t length = OSPF_HELLO_MIN_SIZE;</a>
<a name="ln3020">  struct in_addr mask;</a>
<a name="ln3021">  unsigned long p;</a>
<a name="ln3022">  int flag = 0;</a>
<a name="ln3023"> </a>
<a name="ln3024">  /* Set netmask of interface. */</a>
<a name="ln3025">  if (!(CHECK_FLAG(oi-&gt;connected-&gt;flags, ZEBRA_IFA_UNNUMBERED) &amp;&amp;</a>
<a name="ln3026">        oi-&gt;type == OSPF_IFTYPE_POINTOPOINT) &amp;&amp;</a>
<a name="ln3027">      oi-&gt;type != OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln3028">    masklen2ip (oi-&gt;address-&gt;prefixlen, &amp;mask);</a>
<a name="ln3029">  else</a>
<a name="ln3030">    memset ((char *) &amp;mask, 0, sizeof (struct in_addr));</a>
<a name="ln3031">  stream_put_ipv4 (s, mask.s_addr);</a>
<a name="ln3032"> </a>
<a name="ln3033">  /* Set Hello Interval. */</a>
<a name="ln3034">  if (OSPF_IF_PARAM (oi, fast_hello) == 0)</a>
<a name="ln3035">    stream_putw (s, OSPF_IF_PARAM (oi, v_hello));</a>
<a name="ln3036">  else</a>
<a name="ln3037">    stream_putw (s, 0); /* hello-interval of 0 for fast-hellos */</a>
<a name="ln3038"> </a>
<a name="ln3039">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln3040">    zlog_debug (&quot;make_hello: options: %x, int: %s&quot;,</a>
<a name="ln3041">	       OPTIONS(oi), IF_NAME (oi));</a>
<a name="ln3042"> </a>
<a name="ln3043">  /* Set Options. */</a>
<a name="ln3044">  stream_putc (s, OPTIONS (oi));</a>
<a name="ln3045"> </a>
<a name="ln3046">  /* Set Router Priority. */</a>
<a name="ln3047">  stream_putc (s, PRIORITY (oi));</a>
<a name="ln3048"> </a>
<a name="ln3049">  /* Set Router Dead Interval. */</a>
<a name="ln3050">  stream_putl (s, OSPF_IF_PARAM (oi, v_wait));</a>
<a name="ln3051"> </a>
<a name="ln3052">  /* Set Designated Router. */</a>
<a name="ln3053">  stream_put_ipv4 (s, DR (oi).s_addr);</a>
<a name="ln3054"> </a>
<a name="ln3055">  p = stream_get_endp (s);</a>
<a name="ln3056"> </a>
<a name="ln3057">  /* Set Backup Designated Router. */</a>
<a name="ln3058">  stream_put_ipv4 (s, BDR (oi).s_addr);</a>
<a name="ln3059"> </a>
<a name="ln3060">  /* Add neighbor seen. */</a>
<a name="ln3061">  for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln3062">    if ((nbr = rn-&gt;info))</a>
<a name="ln3063">      if (nbr-&gt;router_id.s_addr != 0)	/* Ignore 0.0.0.0 node. */</a>
<a name="ln3064">	if (nbr-&gt;state != NSM_Attempt)  /* Ignore Down neighbor. */</a>
<a name="ln3065">	if (nbr-&gt;state != NSM_Down)     /* This is myself for DR election. */</a>
<a name="ln3066">	  if (!IPV4_ADDR_SAME (&amp;nbr-&gt;router_id, &amp;oi-&gt;ospf-&gt;router_id))</a>
<a name="ln3067">	    {</a>
<a name="ln3068">	      /* Check neighbor is sane? */</a>
<a name="ln3069">	      if (nbr-&gt;d_router.s_addr != 0</a>
<a name="ln3070">		  &amp;&amp; IPV4_ADDR_SAME (&amp;nbr-&gt;d_router, &amp;oi-&gt;address-&gt;u.prefix4)</a>
<a name="ln3071">		  &amp;&amp; IPV4_ADDR_SAME (&amp;nbr-&gt;bd_router, &amp;oi-&gt;address-&gt;u.prefix4))</a>
<a name="ln3072">		flag = 1;</a>
<a name="ln3073"> </a>
<a name="ln3074">	      stream_put_ipv4 (s, nbr-&gt;router_id.s_addr);</a>
<a name="ln3075">	      length += 4;</a>
<a name="ln3076">	    }</a>
<a name="ln3077"> </a>
<a name="ln3078">  /* Let neighbor generate BackupSeen. */</a>
<a name="ln3079">  if (flag == 1)</a>
<a name="ln3080">    stream_putl_at (s, p, 0); /* ipv4 address, normally */</a>
<a name="ln3081"> </a>
<a name="ln3082">  return length;</a>
<a name="ln3083">}</a>
<a name="ln3084"> </a>
<a name="ln3085">static int</a>
<a name="ln3086">ospf_make_db_desc (struct ospf_interface *oi, struct ospf_neighbor *nbr,</a>
<a name="ln3087">		   struct stream *s)</a>
<a name="ln3088">{</a>
<a name="ln3089">  struct ospf_lsa *lsa;</a>
<a name="ln3090">  u_int16_t length = OSPF_DB_DESC_MIN_SIZE;</a>
<a name="ln3091">  u_char options;</a>
<a name="ln3092">  unsigned long pp;</a>
<a name="ln3093">  int i;</a>
<a name="ln3094">  struct ospf_lsdb *lsdb;</a>
<a name="ln3095">  </a>
<a name="ln3096">  /* Set Interface MTU. */</a>
<a name="ln3097">  if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln3098">    stream_putw (s, 0);</a>
<a name="ln3099">  else</a>
<a name="ln3100">    stream_putw (s, oi-&gt;ifp-&gt;mtu);</a>
<a name="ln3101"> </a>
<a name="ln3102">  /* Set Options. */</a>
<a name="ln3103">  options = OPTIONS (oi);</a>
<a name="ln3104">  if (CHECK_FLAG (oi-&gt;ospf-&gt;config, OSPF_OPAQUE_CAPABLE))</a>
<a name="ln3105">    SET_FLAG (options, OSPF_OPTION_O);</a>
<a name="ln3106">  stream_putc (s, options);</a>
<a name="ln3107"> </a>
<a name="ln3108">  /* DD flags */</a>
<a name="ln3109">  pp = stream_get_endp (s);</a>
<a name="ln3110">  stream_putc (s, nbr-&gt;dd_flags);</a>
<a name="ln3111"> </a>
<a name="ln3112">  /* Set DD Sequence Number. */</a>
<a name="ln3113">  stream_putl (s, nbr-&gt;dd_seqnum);</a>
<a name="ln3114"> </a>
<a name="ln3115">  /* shortcut unneeded walk of (empty) summary LSDBs */</a>
<a name="ln3116">  if (ospf_db_summary_isempty (nbr))</a>
<a name="ln3117">    goto empty;</a>
<a name="ln3118"> </a>
<a name="ln3119">  /* Describe LSA Header from Database Summary List. */</a>
<a name="ln3120">  lsdb = &amp;nbr-&gt;db_sum;</a>
<a name="ln3121"> </a>
<a name="ln3122">  for (i = OSPF_MIN_LSA; i &lt; OSPF_MAX_LSA; i++)</a>
<a name="ln3123">    {</a>
<a name="ln3124">      struct route_table *table = lsdb-&gt;type[i].db;</a>
<a name="ln3125">      struct route_node *rn;</a>
<a name="ln3126"> </a>
<a name="ln3127">      for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln3128">	if ((lsa = rn-&gt;info) != NULL)</a>
<a name="ln3129">	  {</a>
<a name="ln3130">            if (IS_OPAQUE_LSA (lsa-&gt;data-&gt;type)</a>
<a name="ln3131">            &amp;&amp; (! CHECK_FLAG (options, OSPF_OPTION_O)))</a>
<a name="ln3132">              {</a>
<a name="ln3133">                /* Suppress advertising opaque-informations. */</a>
<a name="ln3134">                /* Remove LSA from DB summary list. */</a>
<a name="ln3135">                ospf_lsdb_delete (lsdb, lsa);</a>
<a name="ln3136">                continue;</a>
<a name="ln3137">              }</a>
<a name="ln3138"> </a>
<a name="ln3139">	    if (!CHECK_FLAG (lsa-&gt;flags, OSPF_LSA_DISCARD))</a>
<a name="ln3140">	      {</a>
<a name="ln3141">		struct lsa_header *lsah;</a>
<a name="ln3142">		u_int16_t ls_age;</a>
<a name="ln3143">		</a>
<a name="ln3144">		/* DD packet overflows interface MTU. */</a>
<a name="ln3145">		if (length + OSPF_LSA_HEADER_SIZE &gt; ospf_packet_max (oi))</a>
<a name="ln3146">		  break;</a>
<a name="ln3147">		</a>
<a name="ln3148">		/* Keep pointer to LS age. */</a>
<a name="ln3149">		lsah = (struct lsa_header *) (STREAM_DATA (s) +</a>
<a name="ln3150">					      stream_get_endp (s));</a>
<a name="ln3151">		</a>
<a name="ln3152">		/* Proceed stream pointer. */</a>
<a name="ln3153">		stream_put (s, lsa-&gt;data, OSPF_LSA_HEADER_SIZE);</a>
<a name="ln3154">		length += OSPF_LSA_HEADER_SIZE;</a>
<a name="ln3155">		</a>
<a name="ln3156">		/* Set LS age. */</a>
<a name="ln3157">		ls_age = LS_AGE (lsa);</a>
<a name="ln3158">		lsah-&gt;ls_age = htons (ls_age);</a>
<a name="ln3159">		</a>
<a name="ln3160">	      }</a>
<a name="ln3161">	    </a>
<a name="ln3162">	    /* Remove LSA from DB summary list. */</a>
<a name="ln3163">	    ospf_lsdb_delete (lsdb, lsa);</a>
<a name="ln3164">	  }</a>
<a name="ln3165">    }</a>
<a name="ln3166"> </a>
<a name="ln3167">  /* Update 'More' bit */</a>
<a name="ln3168">  if (ospf_db_summary_isempty (nbr))</a>
<a name="ln3169">    {</a>
<a name="ln3170">empty:</a>
<a name="ln3171">      if (nbr-&gt;state &gt;= NSM_Exchange)</a>
<a name="ln3172">        {</a>
<a name="ln3173">          UNSET_FLAG (nbr-&gt;dd_flags, OSPF_DD_FLAG_M);</a>
<a name="ln3174">          /* Rewrite DD flags */</a>
<a name="ln3175">          stream_putc_at (s, pp, nbr-&gt;dd_flags);</a>
<a name="ln3176">        }</a>
<a name="ln3177">      else</a>
<a name="ln3178">        {</a>
<a name="ln3179">          assert (IS_SET_DD_M(nbr-&gt;dd_flags));</a>
<a name="ln3180">        }</a>
<a name="ln3181">    }</a>
<a name="ln3182">  return length;</a>
<a name="ln3183">}</a>
<a name="ln3184"> </a>
<a name="ln3185">static int</a>
<a name="ln3186">ospf_make_ls_req_func (struct stream *s, u_int16_t *length,</a>
<a name="ln3187">		       unsigned long delta, struct ospf_neighbor *nbr,</a>
<a name="ln3188">		       struct ospf_lsa *lsa)</a>
<a name="ln3189">{</a>
<a name="ln3190">  struct ospf_interface *oi;</a>
<a name="ln3191"> </a>
<a name="ln3192">  oi = nbr-&gt;oi;</a>
<a name="ln3193"> </a>
<a name="ln3194">  /* LS Request packet overflows interface MTU. */</a>
<a name="ln3195">  if (*length + delta &gt; ospf_packet_max(oi))</a>
<a name="ln3196">    return 0;</a>
<a name="ln3197"> </a>
<a name="ln3198">  stream_putl (s, lsa-&gt;data-&gt;type);</a>
<a name="ln3199">  stream_put_ipv4 (s, lsa-&gt;data-&gt;id.s_addr);</a>
<a name="ln3200">  stream_put_ipv4 (s, lsa-&gt;data-&gt;adv_router.s_addr);</a>
<a name="ln3201">  </a>
<a name="ln3202">  ospf_lsa_unlock (&amp;nbr-&gt;ls_req_last);</a>
<a name="ln3203">  nbr-&gt;ls_req_last = ospf_lsa_lock (lsa);</a>
<a name="ln3204">  </a>
<a name="ln3205">  *length += 12;</a>
<a name="ln3206">  return 1;</a>
<a name="ln3207">}</a>
<a name="ln3208"> </a>
<a name="ln3209">static int</a>
<a name="ln3210">ospf_make_ls_req (struct ospf_neighbor *nbr, struct stream *s)</a>
<a name="ln3211">{</a>
<a name="ln3212">  struct ospf_lsa *lsa;</a>
<a name="ln3213">  u_int16_t length = OSPF_LS_REQ_MIN_SIZE;</a>
<a name="ln3214">  unsigned long delta = stream_get_endp(s)+12;</a>
<a name="ln3215">  struct route_table *table;</a>
<a name="ln3216">  struct route_node *rn;</a>
<a name="ln3217">  int i;</a>
<a name="ln3218">  struct ospf_lsdb *lsdb;</a>
<a name="ln3219"> </a>
<a name="ln3220">  lsdb = &amp;nbr-&gt;ls_req;</a>
<a name="ln3221"> </a>
<a name="ln3222">  for (i = OSPF_MIN_LSA; i &lt; OSPF_MAX_LSA; i++)</a>
<a name="ln3223">    {</a>
<a name="ln3224">      table = lsdb-&gt;type[i].db;</a>
<a name="ln3225">      for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln3226">	if ((lsa = (rn-&gt;info)) != NULL)</a>
<a name="ln3227">	  if (ospf_make_ls_req_func (s, &amp;length, delta, nbr, lsa) == 0)</a>
<a name="ln3228">	    {</a>
<a name="ln3229">	      route_unlock_node (rn);</a>
<a name="ln3230">	      break;</a>
<a name="ln3231">	    }</a>
<a name="ln3232">    }</a>
<a name="ln3233">  return length;</a>
<a name="ln3234">}</a>
<a name="ln3235"> </a>
<a name="ln3236">static int</a>
<a name="ln3237">ls_age_increment (struct ospf_lsa *lsa, int delay)</a>
<a name="ln3238">{</a>
<a name="ln3239">  int age;</a>
<a name="ln3240"> </a>
<a name="ln3241">  age = IS_LSA_MAXAGE (lsa) ? OSPF_LSA_MAXAGE : LS_AGE (lsa) + delay;</a>
<a name="ln3242"> </a>
<a name="ln3243">  return (age &gt; OSPF_LSA_MAXAGE ? OSPF_LSA_MAXAGE : age);</a>
<a name="ln3244">}</a>
<a name="ln3245"> </a>
<a name="ln3246">static int</a>
<a name="ln3247">ospf_make_ls_upd (struct ospf_interface *oi, struct list *update, struct stream *s)</a>
<a name="ln3248">{</a>
<a name="ln3249">  struct ospf_lsa *lsa;</a>
<a name="ln3250">  struct listnode *node;</a>
<a name="ln3251">  u_int16_t length = 0;</a>
<a name="ln3252">  unsigned int size_noauth;</a>
<a name="ln3253">  unsigned long delta = stream_get_endp (s);</a>
<a name="ln3254">  unsigned long pp;</a>
<a name="ln3255">  int count = 0;</a>
<a name="ln3256"> </a>
<a name="ln3257">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln3258">    zlog_debug (&quot;ospf_make_ls_upd: Start&quot;);</a>
<a name="ln3259"> </a>
<a name="ln3260">  pp = stream_get_endp (s);</a>
<a name="ln3261">  stream_forward_endp (s, OSPF_LS_UPD_MIN_SIZE);</a>
<a name="ln3262">  length += OSPF_LS_UPD_MIN_SIZE;</a>
<a name="ln3263"> </a>
<a name="ln3264">  /* Calculate amount of packet usable for data. */</a>
<a name="ln3265">  size_noauth = stream_get_size(s) - ospf_packet_authspace(oi);</a>
<a name="ln3266"> </a>
<a name="ln3267">  while ((node = listhead (update)) != NULL)</a>
<a name="ln3268">    {</a>
<a name="ln3269">      struct lsa_header *lsah;</a>
<a name="ln3270">      u_int16_t ls_age;</a>
<a name="ln3271"> </a>
<a name="ln3272">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln3273">        zlog_debug (&quot;ospf_make_ls_upd: List Iteration %d&quot;, count);</a>
<a name="ln3274"> </a>
<a name="ln3275">      lsa = listgetdata (node);</a>
<a name="ln3276"> </a>
<a name="ln3277">      assert (lsa-&gt;data);</a>
<a name="ln3278"> </a>
<a name="ln3279">      /* Will it fit? */</a>
<a name="ln3280">      if (length + delta + ntohs (lsa-&gt;data-&gt;length) &gt; size_noauth)</a>
<a name="ln3281">        break;</a>
<a name="ln3282"> </a>
<a name="ln3283">      /* Keep pointer to LS age. */</a>
<a name="ln3284">      lsah = (struct lsa_header *) (STREAM_DATA (s) + stream_get_endp (s));</a>
<a name="ln3285"> </a>
<a name="ln3286">      /* Put LSA to Link State Request. */</a>
<a name="ln3287">      stream_put (s, lsa-&gt;data, ntohs (lsa-&gt;data-&gt;length));</a>
<a name="ln3288"> </a>
<a name="ln3289">      /* Set LS age. */</a>
<a name="ln3290">      /* each hop must increment an lsa_age by transmit_delay </a>
<a name="ln3291">         of OSPF interface */</a>
<a name="ln3292">      ls_age = ls_age_increment (lsa, OSPF_IF_PARAM (oi, transmit_delay));</a>
<a name="ln3293">      lsah-&gt;ls_age = htons (ls_age);</a>
<a name="ln3294"> </a>
<a name="ln3295">      length += ntohs (lsa-&gt;data-&gt;length);</a>
<a name="ln3296">      count++;</a>
<a name="ln3297"> </a>
<a name="ln3298">      list_delete_node (update, node);</a>
<a name="ln3299">      ospf_lsa_unlock (&amp;lsa); /* oi-&gt;ls_upd_queue */</a>
<a name="ln3300">    }</a>
<a name="ln3301"> </a>
<a name="ln3302">  /* Now set #LSAs. */</a>
<a name="ln3303">  stream_putl_at (s, pp, count);</a>
<a name="ln3304"> </a>
<a name="ln3305">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln3306">    zlog_debug (&quot;ospf_make_ls_upd: Stop&quot;);</a>
<a name="ln3307">  return length;</a>
<a name="ln3308">}</a>
<a name="ln3309"> </a>
<a name="ln3310">static int</a>
<a name="ln3311">ospf_make_ls_ack (struct ospf_interface *oi, struct list *ack, struct stream *s)</a>
<a name="ln3312">{</a>
<a name="ln3313">  struct listnode *node, *nnode;</a>
<a name="ln3314">  u_int16_t length = OSPF_LS_ACK_MIN_SIZE;</a>
<a name="ln3315">  unsigned long delta = stream_get_endp(s) + 24;</a>
<a name="ln3316">  struct ospf_lsa *lsa;</a>
<a name="ln3317"> </a>
<a name="ln3318">  for (ALL_LIST_ELEMENTS (ack, node, nnode, lsa))</a>
<a name="ln3319">    {</a>
<a name="ln3320">      assert (lsa);</a>
<a name="ln3321">      </a>
<a name="ln3322">      if (length + delta &gt; ospf_packet_max (oi))</a>
<a name="ln3323">	break;</a>
<a name="ln3324">      </a>
<a name="ln3325">      stream_put (s, lsa-&gt;data, OSPF_LSA_HEADER_SIZE);</a>
<a name="ln3326">      length += OSPF_LSA_HEADER_SIZE;</a>
<a name="ln3327">      </a>
<a name="ln3328">      listnode_delete (ack, lsa);</a>
<a name="ln3329">      ospf_lsa_unlock (&amp;lsa); /* oi-&gt;ls_ack_direct.ls_ack */</a>
<a name="ln3330">    }</a>
<a name="ln3331">  </a>
<a name="ln3332">  return length;</a>
<a name="ln3333">}</a>
<a name="ln3334"> </a>
<a name="ln3335">static void</a>
<a name="ln3336">ospf_hello_send_sub (struct ospf_interface *oi, in_addr_t addr)</a>
<a name="ln3337">{</a>
<a name="ln3338">  struct ospf_packet *op;</a>
<a name="ln3339">  u_int16_t length = OSPF_HEADER_SIZE;</a>
<a name="ln3340"> </a>
<a name="ln3341">  op = ospf_packet_new (oi-&gt;ifp-&gt;mtu);</a>
<a name="ln3342"> </a>
<a name="ln3343">  /* Prepare OSPF common header. */</a>
<a name="ln3344">  ospf_make_header (OSPF_MSG_HELLO, oi, op-&gt;s);</a>
<a name="ln3345"> </a>
<a name="ln3346">  /* Prepare OSPF Hello body. */</a>
<a name="ln3347">  length += ospf_make_hello (oi, op-&gt;s);</a>
<a name="ln3348"> </a>
<a name="ln3349">  /* Fill OSPF header. */</a>
<a name="ln3350">  ospf_fill_header (oi, op-&gt;s, length);</a>
<a name="ln3351"> </a>
<a name="ln3352">  /* Set packet length. */</a>
<a name="ln3353">  op-&gt;length = length;</a>
<a name="ln3354"> </a>
<a name="ln3355">  op-&gt;dst.s_addr = addr;</a>
<a name="ln3356"> </a>
<a name="ln3357">  /* Add packet to the top of the interface output queue, so that they</a>
<a name="ln3358">   * can't get delayed by things like long queues of LS Update packets</a>
<a name="ln3359">   */</a>
<a name="ln3360">  ospf_packet_add_top (oi, op);</a>
<a name="ln3361"> </a>
<a name="ln3362">  /* Hook thread to write packet. */</a>
<a name="ln3363">  OSPF_ISM_WRITE_ON (oi-&gt;ospf);</a>
<a name="ln3364">}</a>
<a name="ln3365"> </a>
<a name="ln3366">static void</a>
<a name="ln3367">ospf_poll_send (struct ospf_nbr_nbma *nbr_nbma)</a>
<a name="ln3368">{</a>
<a name="ln3369">  struct ospf_interface *oi;</a>
<a name="ln3370"> </a>
<a name="ln3371">  oi = nbr_nbma-&gt;oi;</a>
<a name="ln3372">  assert(oi);</a>
<a name="ln3373"> </a>
<a name="ln3374">  /* If this is passive interface, do not send OSPF Hello. */</a>
<a name="ln3375">  if (OSPF_IF_PASSIVE_STATUS (oi) == OSPF_IF_PASSIVE)</a>
<a name="ln3376">    return;</a>
<a name="ln3377"> </a>
<a name="ln3378">  if (oi-&gt;type != OSPF_IFTYPE_NBMA)</a>
<a name="ln3379">    return;</a>
<a name="ln3380"> </a>
<a name="ln3381">  if (nbr_nbma-&gt;nbr != NULL &amp;&amp; nbr_nbma-&gt;nbr-&gt;state != NSM_Down)</a>
<a name="ln3382">    return;</a>
<a name="ln3383"> </a>
<a name="ln3384">  if (PRIORITY(oi) == 0)</a>
<a name="ln3385">    return;</a>
<a name="ln3386"> </a>
<a name="ln3387">  if (nbr_nbma-&gt;priority == 0</a>
<a name="ln3388">      &amp;&amp; oi-&gt;state != ISM_DR &amp;&amp; oi-&gt;state != ISM_Backup)</a>
<a name="ln3389">    return;</a>
<a name="ln3390"> </a>
<a name="ln3391">  ospf_hello_send_sub (oi, nbr_nbma-&gt;addr.s_addr);</a>
<a name="ln3392">}</a>
<a name="ln3393"> </a>
<a name="ln3394">int</a>
<a name="ln3395">ospf_poll_timer (struct thread *thread)</a>
<a name="ln3396">{</a>
<a name="ln3397">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln3398"> </a>
<a name="ln3399">  nbr_nbma = THREAD_ARG (thread);</a>
<a name="ln3400">  nbr_nbma-&gt;t_poll = NULL;</a>
<a name="ln3401"> </a>
<a name="ln3402">  if (IS_DEBUG_OSPF (nsm, NSM_TIMERS))</a>
<a name="ln3403">    zlog (NULL, LOG_DEBUG, &quot;NSM[%s:%s]: Timer (Poll timer expire)&quot;,</a>
<a name="ln3404">    IF_NAME (nbr_nbma-&gt;oi), inet_ntoa (nbr_nbma-&gt;addr));</a>
<a name="ln3405"> </a>
<a name="ln3406">  ospf_poll_send (nbr_nbma);</a>
<a name="ln3407"> </a>
<a name="ln3408">  if (nbr_nbma-&gt;v_poll &gt; 0)</a>
<a name="ln3409">    OSPF_POLL_TIMER_ON (nbr_nbma-&gt;t_poll, ospf_poll_timer,</a>
<a name="ln3410">			nbr_nbma-&gt;v_poll);</a>
<a name="ln3411"> </a>
<a name="ln3412">  return 0;</a>
<a name="ln3413">}</a>
<a name="ln3414"> </a>
<a name="ln3415"> </a>
<a name="ln3416">int</a>
<a name="ln3417">ospf_hello_reply_timer (struct thread *thread)</a>
<a name="ln3418">{</a>
<a name="ln3419">  struct ospf_neighbor *nbr;</a>
<a name="ln3420"> </a>
<a name="ln3421">  nbr = THREAD_ARG (thread);</a>
<a name="ln3422">  nbr-&gt;t_hello_reply = NULL;</a>
<a name="ln3423"> </a>
<a name="ln3424">  assert (nbr-&gt;oi);</a>
<a name="ln3425"> </a>
<a name="ln3426">  if (IS_DEBUG_OSPF (nsm, NSM_TIMERS))</a>
<a name="ln3427">    zlog (NULL, LOG_DEBUG, &quot;NSM[%s:%s]: Timer (hello-reply timer expire)&quot;,</a>
<a name="ln3428">	  IF_NAME (nbr-&gt;oi), inet_ntoa (nbr-&gt;router_id));</a>
<a name="ln3429"> </a>
<a name="ln3430">  ospf_hello_send_sub (nbr-&gt;oi, nbr-&gt;address.u.prefix4.s_addr);</a>
<a name="ln3431"> </a>
<a name="ln3432">  return 0;</a>
<a name="ln3433">}</a>
<a name="ln3434"> </a>
<a name="ln3435">/* Send OSPF Hello. */</a>
<a name="ln3436">void</a>
<a name="ln3437">ospf_hello_send (struct ospf_interface *oi)</a>
<a name="ln3438">{</a>
<a name="ln3439">  /* If this is passive interface, do not send OSPF Hello. */</a>
<a name="ln3440">  if (OSPF_IF_PASSIVE_STATUS (oi) == OSPF_IF_PASSIVE)</a>
<a name="ln3441">    return;</a>
<a name="ln3442"> </a>
<a name="ln3443">  if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln3444">    {</a>
<a name="ln3445">      struct ospf_neighbor *nbr;</a>
<a name="ln3446">      struct route_node *rn;</a>
<a name="ln3447"> </a>
<a name="ln3448">      for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln3449">	if ((nbr = rn-&gt;info))</a>
<a name="ln3450">	  if (nbr != oi-&gt;nbr_self)</a>
<a name="ln3451">	    if (nbr-&gt;state != NSM_Down)</a>
<a name="ln3452">	      {</a>
<a name="ln3453">		/*  RFC 2328  Section 9.5.1</a>
<a name="ln3454">		    If the router is not eligible to become Designated Router,</a>
<a name="ln3455">		    it must periodically send Hello Packets to both the</a>
<a name="ln3456">		    Designated Router and the Backup Designated Router (if they</a>
<a name="ln3457">		    exist).  */</a>
<a name="ln3458">		if (PRIORITY(oi) == 0 &amp;&amp;</a>
<a name="ln3459">		    IPV4_ADDR_CMP(&amp;DR(oi),  &amp;nbr-&gt;address.u.prefix4) &amp;&amp;</a>
<a name="ln3460">		    IPV4_ADDR_CMP(&amp;BDR(oi), &amp;nbr-&gt;address.u.prefix4))</a>
<a name="ln3461">		  continue;</a>
<a name="ln3462"> </a>
<a name="ln3463">		/*  If the router is eligible to become Designated Router, it</a>
<a name="ln3464">		    must periodically send Hello Packets to all neighbors that</a>
<a name="ln3465">		    are also eligible. In addition, if the router is itself the</a>
<a name="ln3466">		    Designated Router or Backup Designated Router, it must also</a>
<a name="ln3467">		    send periodic Hello Packets to all other neighbors. */</a>
<a name="ln3468"> </a>
<a name="ln3469">		if (nbr-&gt;priority == 0 &amp;&amp; oi-&gt;state == ISM_DROther)</a>
<a name="ln3470">		  continue;</a>
<a name="ln3471">		/* if oi-&gt;state == Waiting, send hello to all neighbors */</a>
<a name="ln3472">		ospf_hello_send_sub (oi, nbr-&gt;address.u.prefix4.s_addr);</a>
<a name="ln3473">	      }</a>
<a name="ln3474">    }</a>
<a name="ln3475">  else</a>
<a name="ln3476">    {</a>
<a name="ln3477">      /* Decide destination address. */</a>
<a name="ln3478">      if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln3479">        ospf_hello_send_sub (oi, oi-&gt;vl_data-&gt;peer_addr.s_addr);</a>
<a name="ln3480">      else</a>
<a name="ln3481">        ospf_hello_send_sub (oi, htonl (OSPF_ALLSPFROUTERS));</a>
<a name="ln3482">    }</a>
<a name="ln3483">}</a>
<a name="ln3484"> </a>
<a name="ln3485">/* Send OSPF Database Description. */</a>
<a name="ln3486">void</a>
<a name="ln3487">ospf_db_desc_send (struct ospf_neighbor *nbr)</a>
<a name="ln3488">{</a>
<a name="ln3489">  struct ospf_interface *oi;</a>
<a name="ln3490">  struct ospf_packet *op;</a>
<a name="ln3491">  u_int16_t length = OSPF_HEADER_SIZE;</a>
<a name="ln3492"> </a>
<a name="ln3493">  oi = nbr-&gt;oi;</a>
<a name="ln3494">  op = ospf_packet_new (oi-&gt;ifp-&gt;mtu);</a>
<a name="ln3495"> </a>
<a name="ln3496">  /* Prepare OSPF common header. */</a>
<a name="ln3497">  ospf_make_header (OSPF_MSG_DB_DESC, oi, op-&gt;s);</a>
<a name="ln3498"> </a>
<a name="ln3499">  /* Prepare OSPF Database Description body. */</a>
<a name="ln3500">  length += ospf_make_db_desc (oi, nbr, op-&gt;s);</a>
<a name="ln3501"> </a>
<a name="ln3502">  /* Fill OSPF header. */</a>
<a name="ln3503">  ospf_fill_header (oi, op-&gt;s, length);</a>
<a name="ln3504"> </a>
<a name="ln3505">  /* Set packet length. */</a>
<a name="ln3506">  op-&gt;length = length;</a>
<a name="ln3507"> </a>
<a name="ln3508">  /* Decide destination address. */</a>
<a name="ln3509">  if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT) </a>
<a name="ln3510">    op-&gt;dst.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3511">  else</a>
<a name="ln3512">    op-&gt;dst = nbr-&gt;address.u.prefix4;</a>
<a name="ln3513"> </a>
<a name="ln3514">  /* Add packet to the interface output queue. */</a>
<a name="ln3515">  ospf_packet_add (oi, op);</a>
<a name="ln3516"> </a>
<a name="ln3517">  /* Hook thread to write packet. */</a>
<a name="ln3518">  OSPF_ISM_WRITE_ON (oi-&gt;ospf);</a>
<a name="ln3519"> </a>
<a name="ln3520">  /* Remove old DD packet, then copy new one and keep in neighbor structure. */</a>
<a name="ln3521">  if (nbr-&gt;last_send)</a>
<a name="ln3522">    ospf_packet_free (nbr-&gt;last_send);</a>
<a name="ln3523">  nbr-&gt;last_send = ospf_packet_dup (op);</a>
<a name="ln3524">  quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;nbr-&gt;last_send_ts);</a>
<a name="ln3525">}</a>
<a name="ln3526"> </a>
<a name="ln3527">/* Re-send Database Description. */</a>
<a name="ln3528">void</a>
<a name="ln3529">ospf_db_desc_resend (struct ospf_neighbor *nbr)</a>
<a name="ln3530">{</a>
<a name="ln3531">  struct ospf_interface *oi;</a>
<a name="ln3532"> </a>
<a name="ln3533">  oi = nbr-&gt;oi;</a>
<a name="ln3534"> </a>
<a name="ln3535">  /* Add packet to the interface output queue. */</a>
<a name="ln3536">  ospf_packet_add (oi, ospf_packet_dup (nbr-&gt;last_send));</a>
<a name="ln3537"> </a>
<a name="ln3538">  /* Hook thread to write packet. */</a>
<a name="ln3539">  OSPF_ISM_WRITE_ON (oi-&gt;ospf);</a>
<a name="ln3540">}</a>
<a name="ln3541"> </a>
<a name="ln3542">/* Send Link State Request. */</a>
<a name="ln3543">void</a>
<a name="ln3544">ospf_ls_req_send (struct ospf_neighbor *nbr)</a>
<a name="ln3545">{</a>
<a name="ln3546">  struct ospf_interface *oi;</a>
<a name="ln3547">  struct ospf_packet *op;</a>
<a name="ln3548">  u_int16_t length = OSPF_HEADER_SIZE;</a>
<a name="ln3549"> </a>
<a name="ln3550">  oi = nbr-&gt;oi;</a>
<a name="ln3551">  op = ospf_packet_new (oi-&gt;ifp-&gt;mtu);</a>
<a name="ln3552"> </a>
<a name="ln3553">  /* Prepare OSPF common header. */</a>
<a name="ln3554">  ospf_make_header (OSPF_MSG_LS_REQ, oi, op-&gt;s);</a>
<a name="ln3555"> </a>
<a name="ln3556">  /* Prepare OSPF Link State Request body. */</a>
<a name="ln3557">  length += ospf_make_ls_req (nbr, op-&gt;s);</a>
<a name="ln3558">  if (length == OSPF_HEADER_SIZE)</a>
<a name="ln3559">    {</a>
<a name="ln3560">      ospf_packet_free (op);</a>
<a name="ln3561">      return;</a>
<a name="ln3562">    }</a>
<a name="ln3563"> </a>
<a name="ln3564">  /* Fill OSPF header. */</a>
<a name="ln3565">  ospf_fill_header (oi, op-&gt;s, length);</a>
<a name="ln3566"> </a>
<a name="ln3567">  /* Set packet length. */</a>
<a name="ln3568">  op-&gt;length = length;</a>
<a name="ln3569"> </a>
<a name="ln3570">  /* Decide destination address. */</a>
<a name="ln3571">  if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT) </a>
<a name="ln3572">    op-&gt;dst.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3573">  else</a>
<a name="ln3574">    op-&gt;dst = nbr-&gt;address.u.prefix4;</a>
<a name="ln3575"> </a>
<a name="ln3576">  /* Add packet to the interface output queue. */</a>
<a name="ln3577">  ospf_packet_add (oi, op);</a>
<a name="ln3578"> </a>
<a name="ln3579">  /* Hook thread to write packet. */</a>
<a name="ln3580">  OSPF_ISM_WRITE_ON (oi-&gt;ospf);</a>
<a name="ln3581"> </a>
<a name="ln3582">  /* Add Link State Request Retransmission Timer. */</a>
<a name="ln3583">  OSPF_NSM_TIMER_ON (nbr-&gt;t_ls_req, ospf_ls_req_timer, nbr-&gt;v_ls_req);</a>
<a name="ln3584">}</a>
<a name="ln3585"> </a>
<a name="ln3586">/* Send Link State Update with an LSA. */</a>
<a name="ln3587">void</a>
<a name="ln3588">ospf_ls_upd_send_lsa (struct ospf_neighbor *nbr, struct ospf_lsa *lsa,</a>
<a name="ln3589">		      int flag)</a>
<a name="ln3590">{</a>
<a name="ln3591">  struct list *update;</a>
<a name="ln3592"> </a>
<a name="ln3593">  update = list_new ();</a>
<a name="ln3594"> </a>
<a name="ln3595">  listnode_add (update, lsa);</a>
<a name="ln3596">  ospf_ls_upd_send (nbr, update, flag);</a>
<a name="ln3597"> </a>
<a name="ln3598">  list_delete (update);</a>
<a name="ln3599">}</a>
<a name="ln3600"> </a>
<a name="ln3601">/* Determine size for packet. Must be at least big enough to accomodate next</a>
<a name="ln3602"> * LSA on list, which may be bigger than MTU size.</a>
<a name="ln3603"> *</a>
<a name="ln3604"> * Return pointer to new ospf_packet</a>
<a name="ln3605"> * NULL if we can not allocate, eg because LSA is bigger than imposed limit</a>
<a name="ln3606"> * on packet sizes (in which case offending LSA is deleted from update list)</a>
<a name="ln3607"> */</a>
<a name="ln3608">static struct ospf_packet *</a>
<a name="ln3609">ospf_ls_upd_packet_new (struct list *update, struct ospf_interface *oi)</a>
<a name="ln3610">{</a>
<a name="ln3611">  struct ospf_lsa *lsa;</a>
<a name="ln3612">  struct listnode *ln;</a>
<a name="ln3613">  size_t size;</a>
<a name="ln3614">  static char warned = 0;</a>
<a name="ln3615"> </a>
<a name="ln3616">  lsa = listgetdata((ln = listhead (update)));</a>
<a name="ln3617">  assert (lsa-&gt;data);</a>
<a name="ln3618"> </a>
<a name="ln3619">  if ((OSPF_LS_UPD_MIN_SIZE + ntohs (lsa-&gt;data-&gt;length))</a>
<a name="ln3620">      &gt; ospf_packet_max (oi))</a>
<a name="ln3621">    {</a>
<a name="ln3622">      if (!warned)</a>
<a name="ln3623">        {</a>
<a name="ln3624">          zlog_warn (&quot;ospf_ls_upd_packet_new: oversized LSA encountered!&quot;</a>
<a name="ln3625">                     &quot;will need to fragment. Not optimal. Try divide up&quot;</a>
<a name="ln3626">                     &quot; your network with areas. Use 'debug ospf packet send'&quot;</a>
<a name="ln3627">                     &quot; to see details, or look at 'show ip ospf database ..'&quot;);</a>
<a name="ln3628">          warned = 1;</a>
<a name="ln3629">        }</a>
<a name="ln3630"> </a>
<a name="ln3631">      if (IS_DEBUG_OSPF_PACKET (0, SEND))</a>
<a name="ln3632">        zlog_debug (&quot;ospf_ls_upd_packet_new: oversized LSA id:%s,&quot;</a>
<a name="ln3633">                   &quot; %d bytes originated by %s, will be fragmented!&quot;,</a>
<a name="ln3634">                   inet_ntoa (lsa-&gt;data-&gt;id),</a>
<a name="ln3635">                   ntohs (lsa-&gt;data-&gt;length),</a>
<a name="ln3636">                   inet_ntoa (lsa-&gt;data-&gt;adv_router));</a>
<a name="ln3637"> </a>
<a name="ln3638">      /* </a>
<a name="ln3639">       * Allocate just enough to fit this LSA only, to avoid including other</a>
<a name="ln3640">       * LSAs in fragmented LSA Updates.</a>
<a name="ln3641">       */</a>
<a name="ln3642">      size = ntohs (lsa-&gt;data-&gt;length) + (oi-&gt;ifp-&gt;mtu - ospf_packet_max (oi))</a>
<a name="ln3643">             + OSPF_LS_UPD_MIN_SIZE;</a>
<a name="ln3644">    }</a>
<a name="ln3645">  else</a>
<a name="ln3646">    size = oi-&gt;ifp-&gt;mtu;</a>
<a name="ln3647"> </a>
<a name="ln3648">  if (size &gt; OSPF_MAX_PACKET_SIZE)</a>
<a name="ln3649">    {</a>
<a name="ln3650">      zlog_warn (&quot;ospf_ls_upd_packet_new: oversized LSA id:%s too big,&quot;</a>
<a name="ln3651">                 &quot; %d bytes, packet size %ld, dropping it completely.&quot;</a>
<a name="ln3652">                 &quot; OSPF routing is broken!&quot;,</a>
<a name="ln3653">                 inet_ntoa (lsa-&gt;data-&gt;id), ntohs (lsa-&gt;data-&gt;length),</a>
<a name="ln3654">                 (long int) size);</a>
<a name="ln3655">      list_delete_node (update, ln);</a>
<a name="ln3656">      return NULL;</a>
<a name="ln3657">    }</a>
<a name="ln3658"> </a>
<a name="ln3659">  /* IP header is built up separately by ospf_write(). This means, that we must</a>
<a name="ln3660">   * reduce the &quot;affordable&quot; size just calculated by length of an IP header.</a>
<a name="ln3661">   * This makes sure, that even if we manage to fill the payload with LSA data</a>
<a name="ln3662">   * completely, the final packet (our data plus IP header) still fits into</a>
<a name="ln3663">   * outgoing interface MTU. This correction isn't really meaningful for an</a>
<a name="ln3664">   * oversized LSA, but for consistency the correction is done for both cases.</a>
<a name="ln3665">   *</a>
<a name="ln3666">   * P.S. OSPF_MAX_PACKET_SIZE above already includes IP header size</a>
<a name="ln3667">   */</a>
<a name="ln3668">  return ospf_packet_new (size - sizeof (struct ip));</a>
<a name="ln3669">}</a>
<a name="ln3670"> </a>
<a name="ln3671">static void</a>
<a name="ln3672">ospf_ls_upd_queue_send (struct ospf_interface *oi, struct list *update,</a>
<a name="ln3673">			struct in_addr addr)</a>
<a name="ln3674">{</a>
<a name="ln3675">  struct ospf_packet *op;</a>
<a name="ln3676">  u_int16_t length = OSPF_HEADER_SIZE;</a>
<a name="ln3677"> </a>
<a name="ln3678">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln3679">    zlog_debug (&quot;listcount = %d, [%s]dst %s&quot;, listcount (update), IF_NAME(oi),</a>
<a name="ln3680">			    inet_ntoa(addr));</a>
<a name="ln3681">  </a>
<a name="ln3682">  op = ospf_ls_upd_packet_new (update, oi);</a>
<a name="ln3683"> </a>
<a name="ln3684">  /* Prepare OSPF common header. */</a>
<a name="ln3685">  ospf_make_header (OSPF_MSG_LS_UPD, oi, op-&gt;s);</a>
<a name="ln3686"> </a>
<a name="ln3687">  /* Prepare OSPF Link State Update body.</a>
<a name="ln3688">   * Includes Type-7 translation. </a>
<a name="ln3689">   */</a>
<a name="ln3690">  length += ospf_make_ls_upd (oi, update, op-&gt;s);</a>
<a name="ln3691"> </a>
<a name="ln3692">  /* Fill OSPF header. */</a>
<a name="ln3693">  ospf_fill_header (oi, op-&gt;s, length);</a>
<a name="ln3694"> </a>
<a name="ln3695">  /* Set packet length. */</a>
<a name="ln3696">  op-&gt;length = length;</a>
<a name="ln3697"> </a>
<a name="ln3698">  /* Decide destination address. */</a>
<a name="ln3699">  if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT) </a>
<a name="ln3700">    op-&gt;dst.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3701">  else</a>
<a name="ln3702">    op-&gt;dst.s_addr = addr.s_addr;</a>
<a name="ln3703"> </a>
<a name="ln3704">  /* Add packet to the interface output queue. */</a>
<a name="ln3705">  ospf_packet_add (oi, op);</a>
<a name="ln3706"> </a>
<a name="ln3707">  /* Hook thread to write packet. */</a>
<a name="ln3708">  OSPF_ISM_WRITE_ON (oi-&gt;ospf);</a>
<a name="ln3709">}</a>
<a name="ln3710"> </a>
<a name="ln3711">static int</a>
<a name="ln3712">ospf_ls_upd_send_queue_event (struct thread *thread)</a>
<a name="ln3713">{</a>
<a name="ln3714">  struct ospf_interface *oi = THREAD_ARG(thread);</a>
<a name="ln3715">  struct route_node *rn;</a>
<a name="ln3716">  struct route_node *rnext;</a>
<a name="ln3717">  struct list *update;</a>
<a name="ln3718">  char again = 0;</a>
<a name="ln3719">  </a>
<a name="ln3720">  oi-&gt;t_ls_upd_event = NULL;</a>
<a name="ln3721"> </a>
<a name="ln3722">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln3723">    zlog_debug (&quot;ospf_ls_upd_send_queue start&quot;);</a>
<a name="ln3724"> </a>
<a name="ln3725">  for (rn = route_top (oi-&gt;ls_upd_queue); rn; rn = rnext)</a>
<a name="ln3726">    {</a>
<a name="ln3727">      rnext = route_next (rn);</a>
<a name="ln3728">      </a>
<a name="ln3729">      if (rn-&gt;info == NULL)</a>
<a name="ln3730">        continue;</a>
<a name="ln3731">      </a>
<a name="ln3732">      update = (struct list *)rn-&gt;info;</a>
<a name="ln3733"> </a>
<a name="ln3734">      ospf_ls_upd_queue_send (oi, update, rn-&gt;p.u.prefix4);</a>
<a name="ln3735">      </a>
<a name="ln3736">      /* list might not be empty. */</a>
<a name="ln3737">      if (listcount(update) == 0)</a>
<a name="ln3738">        {</a>
<a name="ln3739">          list_delete (rn-&gt;info);</a>
<a name="ln3740">          rn-&gt;info = NULL;</a>
<a name="ln3741">          route_unlock_node (rn);</a>
<a name="ln3742">        }</a>
<a name="ln3743">      else</a>
<a name="ln3744">        again = 1;</a>
<a name="ln3745">    }</a>
<a name="ln3746"> </a>
<a name="ln3747">  if (again != 0)</a>
<a name="ln3748">    {</a>
<a name="ln3749">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln3750">        zlog_debug (&quot;ospf_ls_upd_send_queue: update lists not cleared,&quot;</a>
<a name="ln3751">                   &quot; %d nodes to try again, raising new event&quot;, again);</a>
<a name="ln3752">      oi-&gt;t_ls_upd_event = </a>
<a name="ln3753">        thread_add_event (master, ospf_ls_upd_send_queue_event, oi, 0);</a>
<a name="ln3754">    }</a>
<a name="ln3755"> </a>
<a name="ln3756">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln3757">    zlog_debug (&quot;ospf_ls_upd_send_queue stop&quot;);</a>
<a name="ln3758">  </a>
<a name="ln3759">  return 0;</a>
<a name="ln3760">}</a>
<a name="ln3761"> </a>
<a name="ln3762">void</a>
<a name="ln3763">ospf_ls_upd_send (struct ospf_neighbor *nbr, struct list *update, int flag)</a>
<a name="ln3764">{</a>
<a name="ln3765">  struct ospf_interface *oi;</a>
<a name="ln3766">  struct ospf_lsa *lsa;</a>
<a name="ln3767">  struct prefix_ipv4 p;</a>
<a name="ln3768">  struct route_node *rn;</a>
<a name="ln3769">  struct listnode *node;</a>
<a name="ln3770">  </a>
<a name="ln3771">  oi = nbr-&gt;oi;</a>
<a name="ln3772"> </a>
<a name="ln3773">  p.family = AF_INET;</a>
<a name="ln3774">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln3775">  </a>
<a name="ln3776">  /* Decide destination address. */</a>
<a name="ln3777">  if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln3778">    p.prefix = oi-&gt;vl_data-&gt;peer_addr;</a>
<a name="ln3779">  else if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT) </a>
<a name="ln3780">     p.prefix.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3781">  else if (flag == OSPF_SEND_PACKET_DIRECT)</a>
<a name="ln3782">     p.prefix = nbr-&gt;address.u.prefix4;</a>
<a name="ln3783">  else if (oi-&gt;state == ISM_DR || oi-&gt;state == ISM_Backup)</a>
<a name="ln3784">     p.prefix.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3785">  else if (oi-&gt;type == OSPF_IFTYPE_POINTOMULTIPOINT)</a>
<a name="ln3786">     p.prefix.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3787">  else</a>
<a name="ln3788">     p.prefix.s_addr = htonl (OSPF_ALLDROUTERS);</a>
<a name="ln3789"> </a>
<a name="ln3790">  if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln3791">    {</a>
<a name="ln3792">      if (flag == OSPF_SEND_PACKET_INDIRECT)</a>
<a name="ln3793">	zlog_warn (&quot;* LS-Update is directly sent on NBMA network.&quot;);</a>
<a name="ln3794">      if (IPV4_ADDR_SAME(&amp;oi-&gt;address-&gt;u.prefix4, &amp;p.prefix.s_addr))</a>
<a name="ln3795">	zlog_warn (&quot;* LS-Update is sent to myself.&quot;);</a>
<a name="ln3796">    }</a>
<a name="ln3797"> </a>
<a name="ln3798">  rn = route_node_get (oi-&gt;ls_upd_queue, (struct prefix *) &amp;p);</a>
<a name="ln3799"> </a>
<a name="ln3800">  if (rn-&gt;info == NULL)</a>
<a name="ln3801">    rn-&gt;info = list_new ();</a>
<a name="ln3802">  else</a>
<a name="ln3803">    route_unlock_node (rn);</a>
<a name="ln3804"> </a>
<a name="ln3805">  for (ALL_LIST_ELEMENTS_RO (update, node, lsa))</a>
<a name="ln3806">    listnode_add (rn-&gt;info, ospf_lsa_lock (lsa)); /* oi-&gt;ls_upd_queue */</a>
<a name="ln3807"> </a>
<a name="ln3808">  if (oi-&gt;t_ls_upd_event == NULL)</a>
<a name="ln3809">    oi-&gt;t_ls_upd_event =</a>
<a name="ln3810">      thread_add_event (master, ospf_ls_upd_send_queue_event, oi, 0);</a>
<a name="ln3811">}</a>
<a name="ln3812"> </a>
<a name="ln3813">static void</a>
<a name="ln3814">ospf_ls_ack_send_list (struct ospf_interface *oi, struct list *ack,</a>
<a name="ln3815">		       struct in_addr dst)</a>
<a name="ln3816">{</a>
<a name="ln3817">  struct ospf_packet *op;</a>
<a name="ln3818">  u_int16_t length = OSPF_HEADER_SIZE;</a>
<a name="ln3819"> </a>
<a name="ln3820">  op = ospf_packet_new (oi-&gt;ifp-&gt;mtu);</a>
<a name="ln3821"> </a>
<a name="ln3822">  /* Prepare OSPF common header. */</a>
<a name="ln3823">  ospf_make_header (OSPF_MSG_LS_ACK, oi, op-&gt;s);</a>
<a name="ln3824"> </a>
<a name="ln3825">  /* Prepare OSPF Link State Acknowledgment body. */</a>
<a name="ln3826">  length += ospf_make_ls_ack (oi, ack, op-&gt;s);</a>
<a name="ln3827"> </a>
<a name="ln3828">  /* Fill OSPF header. */</a>
<a name="ln3829">  ospf_fill_header (oi, op-&gt;s, length);</a>
<a name="ln3830"> </a>
<a name="ln3831">  /* Set packet length. */</a>
<a name="ln3832">  op-&gt;length = length;</a>
<a name="ln3833"> </a>
<a name="ln3834">  /* Decide destination address. */</a>
<a name="ln3835">  if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)</a>
<a name="ln3836">    op-&gt;dst.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3837">  else</a>
<a name="ln3838">    op-&gt;dst.s_addr = dst.s_addr;</a>
<a name="ln3839"> </a>
<a name="ln3840">  /* Add packet to the interface output queue. */</a>
<a name="ln3841">  ospf_packet_add (oi, op);</a>
<a name="ln3842"> </a>
<a name="ln3843">  /* Hook thread to write packet. */</a>
<a name="ln3844">  OSPF_ISM_WRITE_ON (oi-&gt;ospf);</a>
<a name="ln3845">}</a>
<a name="ln3846"> </a>
<a name="ln3847">static int</a>
<a name="ln3848">ospf_ls_ack_send_event (struct thread *thread)</a>
<a name="ln3849">{</a>
<a name="ln3850">  struct ospf_interface *oi = THREAD_ARG (thread);</a>
<a name="ln3851"> </a>
<a name="ln3852">  oi-&gt;t_ls_ack_direct = NULL;</a>
<a name="ln3853">  </a>
<a name="ln3854">  while (listcount (oi-&gt;ls_ack_direct.ls_ack))</a>
<a name="ln3855">    ospf_ls_ack_send_list (oi, oi-&gt;ls_ack_direct.ls_ack,</a>
<a name="ln3856">			   oi-&gt;ls_ack_direct.dst);</a>
<a name="ln3857"> </a>
<a name="ln3858">  return 0;</a>
<a name="ln3859">}</a>
<a name="ln3860"> </a>
<a name="ln3861">void</a>
<a name="ln3862">ospf_ls_ack_send (struct ospf_neighbor *nbr, struct ospf_lsa *lsa)</a>
<a name="ln3863">{</a>
<a name="ln3864">  struct ospf_interface *oi = nbr-&gt;oi;</a>
<a name="ln3865"> </a>
<a name="ln3866">  if (listcount (oi-&gt;ls_ack_direct.ls_ack) == 0)</a>
<a name="ln3867">    oi-&gt;ls_ack_direct.dst = nbr-&gt;address.u.prefix4;</a>
<a name="ln3868">  </a>
<a name="ln3869">  listnode_add (oi-&gt;ls_ack_direct.ls_ack, ospf_lsa_lock (lsa));</a>
<a name="ln3870">  </a>
<a name="ln3871">  if (oi-&gt;t_ls_ack_direct == NULL)</a>
<a name="ln3872">    oi-&gt;t_ls_ack_direct =</a>
<a name="ln3873">      thread_add_event (master, ospf_ls_ack_send_event, oi, 0);</a>
<a name="ln3874">}</a>
<a name="ln3875"> </a>
<a name="ln3876">/* Send Link State Acknowledgment delayed. */</a>
<a name="ln3877">void</a>
<a name="ln3878">ospf_ls_ack_send_delayed (struct ospf_interface *oi)</a>
<a name="ln3879">{</a>
<a name="ln3880">  struct in_addr dst;</a>
<a name="ln3881">  </a>
<a name="ln3882">  /* Decide destination address. */</a>
<a name="ln3883">  /* RFC2328 Section 13.5                           On non-broadcast</a>
<a name="ln3884">	networks, delayed Link State Acknowledgment packets must be</a>
<a name="ln3885">	unicast	separately over	each adjacency (i.e., neighbor whose</a>
<a name="ln3886">	state is &gt;= Exchange).  */</a>
<a name="ln3887">  if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln3888">    {</a>
<a name="ln3889">      struct ospf_neighbor *nbr;</a>
<a name="ln3890">      struct route_node *rn;</a>
<a name="ln3891"> </a>
<a name="ln3892">      for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln3893">	if ((nbr = rn-&gt;info) != NULL)</a>
<a name="ln3894">	  if (nbr != oi-&gt;nbr_self &amp;&amp; nbr-&gt;state &gt;= NSM_Exchange)</a>
<a name="ln3895">	    while (listcount (oi-&gt;ls_ack))</a>
<a name="ln3896">	      ospf_ls_ack_send_list (oi, oi-&gt;ls_ack, nbr-&gt;address.u.prefix4);</a>
<a name="ln3897">      return;</a>
<a name="ln3898">    }</a>
<a name="ln3899">  if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln3900">    dst.s_addr = oi-&gt;vl_data-&gt;peer_addr.s_addr;</a>
<a name="ln3901">  else if (oi-&gt;state == ISM_DR || oi-&gt;state == ISM_Backup)</a>
<a name="ln3902">    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3903">  else if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)</a>
<a name="ln3904">    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3905">  else if (oi-&gt;type == OSPF_IFTYPE_POINTOMULTIPOINT)</a>
<a name="ln3906">    dst.s_addr = htonl (OSPF_ALLSPFROUTERS);</a>
<a name="ln3907">  else</a>
<a name="ln3908">    dst.s_addr = htonl (OSPF_ALLDROUTERS);</a>
<a name="ln3909"> </a>
<a name="ln3910">  while (listcount (oi-&gt;ls_ack))</a>
<a name="ln3911">    ospf_ls_ack_send_list (oi, oi-&gt;ls_ack, dst);</a>
<a name="ln3912">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="707"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression is always false.</p></div>
<div class="balloon" rel="1081"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'oi->area->external_routing == 1' is always true.</p></div>
<div class="balloon" rel="2128"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'iph' class object.</p></div>
<div class="balloon" rel="2132"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v568/" target="_blank">V568</a> It's odd that 'sizeof()' operator evaluates the size of a pointer to a class, but not the size of the 'iph' class object.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
