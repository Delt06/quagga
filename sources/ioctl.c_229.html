
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ioctl.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Common ioctl functions.</a>
<a name="ln3"> * Copyright (C) 1997, 98 Kunihiro Ishiguro</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.  </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;linklist.h&quot;</a>
<a name="ln26">#include &quot;if.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;ioctl.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;privs.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;zebra/rib.h&quot;</a>
<a name="ln33">#include &quot;zebra/rt.h&quot;</a>
<a name="ln34">#include &quot;zebra/interface.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#ifdef HAVE_BSD_LINK_DETECT</a>
<a name="ln37">#include &lt;net/if_media.h&gt;</a>
<a name="ln38">#endif /* HAVE_BSD_LINK_DETECT*/</a>
<a name="ln39"> </a>
<a name="ln40">extern struct zebra_privs_t zserv_privs;</a>
<a name="ln41"> </a>
<a name="ln42">/* clear and set interface name string */</a>
<a name="ln43">void</a>
<a name="ln44">ifreq_set_name (struct ifreq *ifreq, struct interface *ifp)</a>
<a name="ln45">{</a>
<a name="ln46">  strncpy (ifreq-&gt;ifr_name, ifp-&gt;name, IFNAMSIZ);</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49">/* call ioctl system call */</a>
<a name="ln50">int</a>
<a name="ln51">if_ioctl (u_long request, caddr_t buffer)</a>
<a name="ln52">{</a>
<a name="ln53">  int sock;</a>
<a name="ln54">  int ret;</a>
<a name="ln55">  int err = 0;</a>
<a name="ln56"> </a>
<a name="ln57">  if (zserv_privs.change(ZPRIVS_RAISE))</a>
<a name="ln58">    zlog (NULL, LOG_ERR, &quot;Can't raise privileges&quot;);</a>
<a name="ln59">  sock = socket (AF_INET, SOCK_DGRAM, 0);</a>
<a name="ln60">  if (sock &lt; 0)</a>
<a name="ln61">    {</a>
<a name="ln62">      int save_errno = errno;</a>
<a name="ln63">      if (zserv_privs.change(ZPRIVS_LOWER))</a>
<a name="ln64">        zlog (NULL, LOG_ERR, &quot;Can't lower privileges&quot;);</a>
<a name="ln65">      zlog_err(&quot;Cannot create UDP socket: %s&quot;, safe_strerror(save_errno));</a>
<a name="ln66">      exit (1);</a>
<a name="ln67">    }</a>
<a name="ln68">  if ((ret = ioctl (sock, request, buffer)) &lt; 0)</a>
<a name="ln69">    err = errno;</a>
<a name="ln70">  if (zserv_privs.change(ZPRIVS_LOWER))</a>
<a name="ln71">    zlog (NULL, LOG_ERR, &quot;Can't lower privileges&quot;);</a>
<a name="ln72">  close (sock);</a>
<a name="ln73">  </a>
<a name="ln74">  if (ret &lt; 0) </a>
<a name="ln75">    {</a>
<a name="ln76">      errno = err;</a>
<a name="ln77">      return ret;</a>
<a name="ln78">    }</a>
<a name="ln79">  return 0;</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">#ifdef HAVE_IPV6</a>
<a name="ln83">static int</a>
<a name="ln84">if_ioctl_ipv6 (u_long request, caddr_t buffer)</a>
<a name="ln85">{</a>
<a name="ln86">  int sock;</a>
<a name="ln87">  int ret;</a>
<a name="ln88">  int err = 0;</a>
<a name="ln89"> </a>
<a name="ln90">  if (zserv_privs.change(ZPRIVS_RAISE))</a>
<a name="ln91">    zlog (NULL, LOG_ERR, &quot;Can't raise privileges&quot;);</a>
<a name="ln92">  sock = socket (AF_INET6, SOCK_DGRAM, 0);</a>
<a name="ln93">  if (sock &lt; 0)</a>
<a name="ln94">    {</a>
<a name="ln95">      int save_errno = errno;</a>
<a name="ln96">      if (zserv_privs.change(ZPRIVS_LOWER))</a>
<a name="ln97">        zlog (NULL, LOG_ERR, &quot;Can't lower privileges&quot;);</a>
<a name="ln98">      zlog_err(&quot;Cannot create IPv6 datagram socket: %s&quot;,</a>
<a name="ln99">	       safe_strerror(save_errno));</a>
<a name="ln100">      exit (1);</a>
<a name="ln101">    }</a>
<a name="ln102"> </a>
<a name="ln103">  if ((ret = ioctl (sock, request, buffer)) &lt; 0)</a>
<a name="ln104">    err = errno;</a>
<a name="ln105">  if (zserv_privs.change(ZPRIVS_LOWER))</a>
<a name="ln106">    zlog (NULL, LOG_ERR, &quot;Can't lower privileges&quot;);</a>
<a name="ln107">  close (sock);</a>
<a name="ln108">  </a>
<a name="ln109">  if (ret &lt; 0) </a>
<a name="ln110">    {</a>
<a name="ln111">      errno = err;</a>
<a name="ln112">      return ret;</a>
<a name="ln113">    }</a>
<a name="ln114">  return 0;</a>
<a name="ln115">}</a>
<a name="ln116">#endif /* HAVE_IPV6 */</a>
<a name="ln117"> </a>
<a name="ln118">/*</a>
<a name="ln119"> * get interface metric</a>
<a name="ln120"> *   -- if value is not avaliable set -1</a>
<a name="ln121"> */</a>
<a name="ln122">void</a>
<a name="ln123">if_get_metric (struct interface *ifp)</a>
<a name="ln124">{</a>
<a name="ln125">#ifdef SIOCGIFMETRIC</a>
<a name="ln126">  struct ifreq ifreq;</a>
<a name="ln127"> </a>
<a name="ln128">  ifreq_set_name (&amp;ifreq, ifp);</a>
<a name="ln129"> </a>
<a name="ln130">  if (if_ioctl (SIOCGIFMETRIC, (caddr_t) &amp;ifreq) &lt; 0) </a>
<a name="ln131">    return;</a>
<a name="ln132">  ifp-&gt;metric = ifreq.ifr_metric;</a>
<a name="ln133">  if (ifp-&gt;metric == 0)</a>
<a name="ln134">    ifp-&gt;metric = 1;</a>
<a name="ln135">#else /* SIOCGIFMETRIC */</a>
<a name="ln136">  ifp-&gt;metric = -1;</a>
<a name="ln137">#endif /* SIOCGIFMETRIC */</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">/* get interface MTU */</a>
<a name="ln141">void</a>
<a name="ln142">if_get_mtu (struct interface *ifp)</a>
<a name="ln143">{</a>
<a name="ln144">  struct ifreq ifreq;</a>
<a name="ln145"> </a>
<a name="ln146">  ifreq_set_name (&amp;ifreq, ifp);</a>
<a name="ln147"> </a>
<a name="ln148">#if defined(SIOCGIFMTU)</a>
<a name="ln149">  if (if_ioctl (SIOCGIFMTU, (caddr_t) &amp; ifreq) &lt; 0) </a>
<a name="ln150">    {</a>
<a name="ln151">      zlog_info (&quot;Can't lookup mtu by ioctl(SIOCGIFMTU)&quot;);</a>
<a name="ln152">      ifp-&gt;mtu6 = ifp-&gt;mtu = -1;</a>
<a name="ln153">      return;</a>
<a name="ln154">    }</a>
<a name="ln155"> </a>
<a name="ln156">#ifdef SUNOS_5</a>
<a name="ln157">  ifp-&gt;mtu6 = ifp-&gt;mtu = ifreq.ifr_metric;</a>
<a name="ln158">#else</a>
<a name="ln159">  ifp-&gt;mtu6 = ifp-&gt;mtu = ifreq.ifr_mtu;</a>
<a name="ln160">#endif /* SUNOS_5 */</a>
<a name="ln161"> </a>
<a name="ln162">  /* propogate */</a>
<a name="ln163">  zebra_interface_up_update(ifp);</a>
<a name="ln164"> </a>
<a name="ln165">#else</a>
<a name="ln166">  zlog (NULL, LOG_INFO, &quot;Can't lookup mtu on this system&quot;);</a>
<a name="ln167">  ifp-&gt;mtu6 = ifp-&gt;mtu = -1;</a>
<a name="ln168">#endif</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">#ifdef HAVE_NETLINK</a>
<a name="ln172">/* Interface address setting via netlink interface. */</a>
<a name="ln173">int</a>
<a name="ln174">if_set_prefix (struct interface *ifp, struct connected *ifc)</a>
<a name="ln175">{</a>
<a name="ln176">  return kernel_address_add_ipv4 (ifp, ifc);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">/* Interface address is removed using netlink interface. */</a>
<a name="ln180">int</a>
<a name="ln181">if_unset_prefix (struct interface *ifp, struct connected *ifc)</a>
<a name="ln182">{</a>
<a name="ln183">  return kernel_address_delete_ipv4 (ifp, ifc);</a>
<a name="ln184">}</a>
<a name="ln185">#else /* ! HAVE_NETLINK */</a>
<a name="ln186">#ifdef HAVE_STRUCT_IFALIASREQ</a>
<a name="ln187">/* Set up interface's IP address, netmask (and broadcas? ).  *BSD may</a>
<a name="ln188">   has ifaliasreq structure.  */</a>
<a name="ln189">int</a>
<a name="ln190">if_set_prefix (struct interface *ifp, struct connected *ifc)</a>
<a name="ln191">{</a>
<a name="ln192">  int ret;</a>
<a name="ln193">  struct ifaliasreq addreq;</a>
<a name="ln194">  struct sockaddr_in addr;</a>
<a name="ln195">  struct sockaddr_in mask;</a>
<a name="ln196">  struct prefix_ipv4 *p;</a>
<a name="ln197"> </a>
<a name="ln198">  p = (struct prefix_ipv4 *) ifc-&gt;address;</a>
<a name="ln199"> </a>
<a name="ln200">  memset (&amp;addreq, 0, sizeof addreq);</a>
<a name="ln201">  strncpy ((char *)&amp;addreq.ifra_name, ifp-&gt;name, sizeof addreq.ifra_name);</a>
<a name="ln202"> </a>
<a name="ln203">  memset (&amp;addr, 0, sizeof (struct sockaddr_in));</a>
<a name="ln204">  addr.sin_addr = p-&gt;prefix;</a>
<a name="ln205">  addr.sin_family = p-&gt;family;</a>
<a name="ln206">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln207">  addr.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln208">#endif</a>
<a name="ln209">  memcpy (&amp;addreq.ifra_addr, &amp;addr, sizeof (struct sockaddr_in));</a>
<a name="ln210"> </a>
<a name="ln211">  memset (&amp;mask, 0, sizeof (struct sockaddr_in));</a>
<a name="ln212">  masklen2ip (p-&gt;prefixlen, &amp;mask.sin_addr);</a>
<a name="ln213">  mask.sin_family = p-&gt;family;</a>
<a name="ln214">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln215">  mask.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln216">#endif</a>
<a name="ln217">  memcpy (&amp;addreq.ifra_mask, &amp;mask, sizeof (struct sockaddr_in));</a>
<a name="ln218">  </a>
<a name="ln219">  ret = if_ioctl (SIOCAIFADDR, (caddr_t) &amp;addreq);</a>
<a name="ln220">  if (ret &lt; 0)</a>
<a name="ln221">    return ret;</a>
<a name="ln222">  return 0;</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">/* Set up interface's IP address, netmask (and broadcas? ).  *BSD may</a>
<a name="ln226">   has ifaliasreq structure.  */</a>
<a name="ln227">int</a>
<a name="ln228">if_unset_prefix (struct interface *ifp, struct connected *ifc)</a>
<a name="ln229">{</a>
<a name="ln230">  int ret;</a>
<a name="ln231">  struct ifaliasreq addreq;</a>
<a name="ln232">  struct sockaddr_in addr;</a>
<a name="ln233">  struct sockaddr_in mask;</a>
<a name="ln234">  struct prefix_ipv4 *p;</a>
<a name="ln235"> </a>
<a name="ln236">  p = (struct prefix_ipv4 *)ifc-&gt;address;</a>
<a name="ln237"> </a>
<a name="ln238">  memset (&amp;addreq, 0, sizeof addreq);</a>
<a name="ln239">  strncpy ((char *)&amp;addreq.ifra_name, ifp-&gt;name, sizeof addreq.ifra_name);</a>
<a name="ln240"> </a>
<a name="ln241">  memset (&amp;addr, 0, sizeof (struct sockaddr_in));</a>
<a name="ln242">  addr.sin_addr = p-&gt;prefix;</a>
<a name="ln243">  addr.sin_family = p-&gt;family;</a>
<a name="ln244">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln245">  addr.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln246">#endif</a>
<a name="ln247">  memcpy (&amp;addreq.ifra_addr, &amp;addr, sizeof (struct sockaddr_in));</a>
<a name="ln248"> </a>
<a name="ln249">  memset (&amp;mask, 0, sizeof (struct sockaddr_in));</a>
<a name="ln250">  masklen2ip (p-&gt;prefixlen, &amp;mask.sin_addr);</a>
<a name="ln251">  mask.sin_family = p-&gt;family;</a>
<a name="ln252">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln253">  mask.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln254">#endif</a>
<a name="ln255">  memcpy (&amp;addreq.ifra_mask, &amp;mask, sizeof (struct sockaddr_in));</a>
<a name="ln256">  </a>
<a name="ln257">  ret = if_ioctl (SIOCDIFADDR, (caddr_t) &amp;addreq);</a>
<a name="ln258">  if (ret &lt; 0)</a>
<a name="ln259">    return ret;</a>
<a name="ln260">  return 0;</a>
<a name="ln261">}</a>
<a name="ln262">#else</a>
<a name="ln263">/* Set up interface's address, netmask (and broadcas? ).  Linux or</a>
<a name="ln264">   Solaris uses ifname:number semantics to set IP address aliases. */</a>
<a name="ln265">int</a>
<a name="ln266">if_set_prefix (struct interface *ifp, struct connected *ifc)</a>
<a name="ln267">{</a>
<a name="ln268">  int ret;</a>
<a name="ln269">  struct ifreq ifreq;</a>
<a name="ln270">  struct sockaddr_in addr;</a>
<a name="ln271">  struct sockaddr_in broad;</a>
<a name="ln272">  struct sockaddr_in mask;</a>
<a name="ln273">  struct prefix_ipv4 ifaddr;</a>
<a name="ln274">  struct prefix_ipv4 *p;</a>
<a name="ln275"> </a>
<a name="ln276">  p = (struct prefix_ipv4 *) ifc-&gt;address;</a>
<a name="ln277"> </a>
<a name="ln278">  ifaddr = *p;</a>
<a name="ln279"> </a>
<a name="ln280">  ifreq_set_name (&amp;ifreq, ifp);</a>
<a name="ln281"> </a>
<a name="ln282">  addr.sin_addr = p-&gt;prefix;</a>
<a name="ln283">  addr.sin_family = p-&gt;family;</a>
<a name="ln284">  memcpy (&amp;ifreq.ifr_addr, &amp;addr, sizeof (struct sockaddr_in));</a>
<a name="ln285">  ret = if_ioctl (SIOCSIFADDR, (caddr_t) &amp;ifreq);</a>
<a name="ln286">  if (ret &lt; 0)</a>
<a name="ln287">    return ret;</a>
<a name="ln288">  </a>
<a name="ln289">  /* We need mask for make broadcast addr. */</a>
<a name="ln290">  masklen2ip (p-&gt;prefixlen, &amp;mask.sin_addr);</a>
<a name="ln291"> </a>
<a name="ln292">  if (if_is_broadcast (ifp))</a>
<a name="ln293">    {</a>
<a name="ln294">      apply_mask_ipv4 (&amp;ifaddr);</a>
<a name="ln295">      addr.sin_addr = ifaddr.prefix;</a>
<a name="ln296"> </a>
<a name="ln297">      broad.sin_addr.s_addr = (addr.sin_addr.s_addr | ~mask.sin_addr.s_addr);</a>
<a name="ln298">      broad.sin_family = p-&gt;family;</a>
<a name="ln299"> </a>
<a name="ln300">      memcpy (&amp;ifreq.ifr_broadaddr, &amp;broad, sizeof (struct sockaddr_in));</a>
<a name="ln301">      ret = if_ioctl (SIOCSIFBRDADDR, (caddr_t) &amp;ifreq);</a>
<a name="ln302">      if (ret &lt; 0)</a>
<a name="ln303">	return ret;</a>
<a name="ln304">    }</a>
<a name="ln305"> </a>
<a name="ln306">  mask.sin_family = p-&gt;family;</a>
<a name="ln307">#ifdef SUNOS_5</a>
<a name="ln308">  memcpy (&amp;mask, &amp;ifreq.ifr_addr, sizeof (mask));</a>
<a name="ln309">#else</a>
<a name="ln310">  memcpy (&amp;ifreq.ifr_netmask, &amp;mask, sizeof (struct sockaddr_in));</a>
<a name="ln311">#endif /* SUNOS5 */</a>
<a name="ln312">  ret = if_ioctl (SIOCSIFNETMASK, (caddr_t) &amp;ifreq);</a>
<a name="ln313">  if (ret &lt; 0)</a>
<a name="ln314">    return ret;</a>
<a name="ln315"> </a>
<a name="ln316">  return 0;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">/* Set up interface's address, netmask (and broadcas? ).  Linux or</a>
<a name="ln320">   Solaris uses ifname:number semantics to set IP address aliases. */</a>
<a name="ln321">int</a>
<a name="ln322">if_unset_prefix (struct interface *ifp, struct connected *ifc)</a>
<a name="ln323">{</a>
<a name="ln324">  int ret;</a>
<a name="ln325">  struct ifreq ifreq;</a>
<a name="ln326">  struct sockaddr_in addr;</a>
<a name="ln327">  struct prefix_ipv4 *p;</a>
<a name="ln328"> </a>
<a name="ln329">  p = (struct prefix_ipv4 *) ifc-&gt;address;</a>
<a name="ln330"> </a>
<a name="ln331">  ifreq_set_name (&amp;ifreq, ifp);</a>
<a name="ln332"> </a>
<a name="ln333">  memset (&amp;addr, 0, sizeof (struct sockaddr_in));</a>
<a name="ln334">  addr.sin_family = p-&gt;family;</a>
<a name="ln335">  memcpy (&amp;ifreq.ifr_addr, &amp;addr, sizeof (struct sockaddr_in));</a>
<a name="ln336">  ret = if_ioctl (SIOCSIFADDR, (caddr_t) &amp;ifreq);</a>
<a name="ln337">  if (ret &lt; 0)</a>
<a name="ln338">    return ret;</a>
<a name="ln339"> </a>
<a name="ln340">  return 0;</a>
<a name="ln341">}</a>
<a name="ln342">#endif /* HAVE_STRUCT_IFALIASREQ */</a>
<a name="ln343">#endif /* HAVE_NETLINK */</a>
<a name="ln344"> </a>
<a name="ln345">/* get interface flags */</a>
<a name="ln346">void</a>
<a name="ln347">if_get_flags (struct interface *ifp)</a>
<a name="ln348">{</a>
<a name="ln349">  int ret;</a>
<a name="ln350">  struct ifreq ifreq;</a>
<a name="ln351">#ifdef HAVE_BSD_LINK_DETECT</a>
<a name="ln352">  struct ifmediareq ifmr;</a>
<a name="ln353">#endif /* HAVE_BSD_LINK_DETECT */</a>
<a name="ln354"> </a>
<a name="ln355">  ifreq_set_name (&amp;ifreq, ifp);</a>
<a name="ln356"> </a>
<a name="ln357">  ret = if_ioctl (SIOCGIFFLAGS, (caddr_t) &amp;ifreq);</a>
<a name="ln358">  if (ret &lt; 0) </a>
<a name="ln359">    {</a>
<a name="ln360">      zlog_err(&quot;if_ioctl(SIOCGIFFLAGS) failed: %s&quot;, safe_strerror(errno));</a>
<a name="ln361">      return;</a>
<a name="ln362">    }</a>
<a name="ln363">#ifdef HAVE_BSD_LINK_DETECT /* Detect BSD link-state at start-up */</a>
<a name="ln364"> </a>
<a name="ln365">  /* Per-default, IFF_RUNNING is held high, unless link-detect says</a>
<a name="ln366">   * otherwise - we abuse IFF_RUNNING inside zebra as a link-state flag,</a>
<a name="ln367">   * following practice on Linux and Solaris kernels</a>
<a name="ln368">   */</a>
<a name="ln369">  SET_FLAG(ifreq.ifr_flags, IFF_RUNNING);</a>
<a name="ln370">  </a>
<a name="ln371">  if (CHECK_FLAG (ifp-&gt;status, ZEBRA_INTERFACE_LINKDETECTION))</a>
<a name="ln372">    {</a>
<a name="ln373">      (void) memset(&amp;ifmr, 0, sizeof(ifmr));</a>
<a name="ln374">      strncpy (ifmr.ifm_name, ifp-&gt;name, IFNAMSIZ);</a>
<a name="ln375">      </a>
<a name="ln376">      /* Seems not all interfaces implement this ioctl */</a>
<a name="ln377">      if (if_ioctl(SIOCGIFMEDIA, (caddr_t) &amp;ifmr) &lt; 0)</a>
<a name="ln378">        zlog_err(&quot;if_ioctl(SIOCGIFMEDIA) failed: %s&quot;, safe_strerror(errno));</a>
<a name="ln379">      else if (ifmr.ifm_status &amp; IFM_AVALID) /* Link state is valid */</a>
<a name="ln380">        {</a>
<a name="ln381">          if (ifmr.ifm_status &amp; IFM_ACTIVE)</a>
<a name="ln382">            SET_FLAG(ifreq.ifr_flags, IFF_RUNNING);</a>
<a name="ln383">          else</a>
<a name="ln384">            UNSET_FLAG(ifreq.ifr_flags, IFF_RUNNING);</a>
<a name="ln385">        }</a>
<a name="ln386">  }</a>
<a name="ln387">#endif /* HAVE_BSD_LINK_DETECT */</a>
<a name="ln388"> </a>
<a name="ln389">  if_flags_update (ifp, (ifreq.ifr_flags &amp; 0x0000ffff));</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">/* Set interface flags */</a>
<a name="ln393">int</a>
<a name="ln394">if_set_flags (struct interface *ifp, uint64_t flags)</a>
<a name="ln395">{</a>
<a name="ln396">  int ret;</a>
<a name="ln397">  struct ifreq ifreq;</a>
<a name="ln398"> </a>
<a name="ln399">  memset (&amp;ifreq, 0, sizeof(struct ifreq));</a>
<a name="ln400">  ifreq_set_name (&amp;ifreq, ifp);</a>
<a name="ln401"> </a>
<a name="ln402">  ifreq.ifr_flags = ifp-&gt;flags;</a>
<a name="ln403">  ifreq.ifr_flags |= flags;</a>
<a name="ln404"> </a>
<a name="ln405">  ret = if_ioctl (SIOCSIFFLAGS, (caddr_t) &amp;ifreq);</a>
<a name="ln406"> </a>
<a name="ln407">  if (ret &lt; 0)</a>
<a name="ln408">    {</a>
<a name="ln409">      zlog_info (&quot;can't set interface flags&quot;);</a>
<a name="ln410">      return ret;</a>
<a name="ln411">    }</a>
<a name="ln412">  return 0;</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">/* Unset interface's flag. */</a>
<a name="ln416">int</a>
<a name="ln417">if_unset_flags (struct interface *ifp, uint64_t flags)</a>
<a name="ln418">{</a>
<a name="ln419">  int ret;</a>
<a name="ln420">  struct ifreq ifreq;</a>
<a name="ln421"> </a>
<a name="ln422">  memset (&amp;ifreq, 0, sizeof(struct ifreq));</a>
<a name="ln423">  ifreq_set_name (&amp;ifreq, ifp);</a>
<a name="ln424"> </a>
<a name="ln425">  ifreq.ifr_flags = ifp-&gt;flags;</a>
<a name="ln426">  ifreq.ifr_flags &amp;= ~flags;</a>
<a name="ln427"> </a>
<a name="ln428">  ret = if_ioctl (SIOCSIFFLAGS, (caddr_t) &amp;ifreq);</a>
<a name="ln429"> </a>
<a name="ln430">  if (ret &lt; 0)</a>
<a name="ln431">    {</a>
<a name="ln432">      zlog_info (&quot;can't unset interface flags&quot;);</a>
<a name="ln433">      return ret;</a>
<a name="ln434">    }</a>
<a name="ln435">  return 0;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">#ifdef HAVE_IPV6</a>
<a name="ln439"> </a>
<a name="ln440">#ifdef LINUX_IPV6</a>
<a name="ln441">#ifndef _LINUX_IN6_H</a>
<a name="ln442">/* linux/include/net/ipv6.h */</a>
<a name="ln443">struct in6_ifreq </a>
<a name="ln444">{</a>
<a name="ln445">  struct in6_addr ifr6_addr;</a>
<a name="ln446">  u_int32_t ifr6_prefixlen;</a>
<a name="ln447">  int ifr6_ifindex;</a>
<a name="ln448">};</a>
<a name="ln449">#endif /* _LINUX_IN6_H */</a>
<a name="ln450"> </a>
<a name="ln451">/* Interface's address add/delete functions. */</a>
<a name="ln452">int</a>
<a name="ln453">if_prefix_add_ipv6 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln454">{</a>
<a name="ln455">  int ret;</a>
<a name="ln456">  struct prefix_ipv6 *p;</a>
<a name="ln457">  struct in6_ifreq ifreq;</a>
<a name="ln458"> </a>
<a name="ln459">  p = (struct prefix_ipv6 *) ifc-&gt;address;</a>
<a name="ln460"> </a>
<a name="ln461">  memset (&amp;ifreq, 0, sizeof (struct in6_ifreq));</a>
<a name="ln462"> </a>
<a name="ln463">  memcpy (&amp;ifreq.ifr6_addr, &amp;p-&gt;prefix, sizeof (struct in6_addr));</a>
<a name="ln464">  ifreq.ifr6_ifindex = ifp-&gt;ifindex;</a>
<a name="ln465">  ifreq.ifr6_prefixlen = p-&gt;prefixlen;</a>
<a name="ln466"> </a>
<a name="ln467">  ret = if_ioctl_ipv6 (SIOCSIFADDR, (caddr_t) &amp;ifreq);</a>
<a name="ln468"> </a>
<a name="ln469">  return ret;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">int</a>
<a name="ln473">if_prefix_delete_ipv6 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln474">{</a>
<a name="ln475">  int ret;</a>
<a name="ln476">  struct prefix_ipv6 *p;</a>
<a name="ln477">  struct in6_ifreq ifreq;</a>
<a name="ln478"> </a>
<a name="ln479">  p = (struct prefix_ipv6 *) ifc-&gt;address;</a>
<a name="ln480"> </a>
<a name="ln481">  memset (&amp;ifreq, 0, sizeof (struct in6_ifreq));</a>
<a name="ln482"> </a>
<a name="ln483">  memcpy (&amp;ifreq.ifr6_addr, &amp;p-&gt;prefix, sizeof (struct in6_addr));</a>
<a name="ln484">  ifreq.ifr6_ifindex = ifp-&gt;ifindex;</a>
<a name="ln485">  ifreq.ifr6_prefixlen = p-&gt;prefixlen;</a>
<a name="ln486"> </a>
<a name="ln487">  ret = if_ioctl_ipv6 (SIOCDIFADDR, (caddr_t) &amp;ifreq);</a>
<a name="ln488"> </a>
<a name="ln489">  return ret;</a>
<a name="ln490">}</a>
<a name="ln491">#else /* LINUX_IPV6 */</a>
<a name="ln492">#ifdef HAVE_STRUCT_IN6_ALIASREQ</a>
<a name="ln493">#ifndef ND6_INFINITE_LIFETIME</a>
<a name="ln494">#define ND6_INFINITE_LIFETIME 0xffffffffL</a>
<a name="ln495">#endif /* ND6_INFINITE_LIFETIME */</a>
<a name="ln496">int</a>
<a name="ln497">if_prefix_add_ipv6 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln498">{</a>
<a name="ln499">  int ret;</a>
<a name="ln500">  struct in6_aliasreq addreq;</a>
<a name="ln501">  struct sockaddr_in6 addr;</a>
<a name="ln502">  struct sockaddr_in6 mask;</a>
<a name="ln503">  struct prefix_ipv6 *p;</a>
<a name="ln504"> </a>
<a name="ln505">  p = (struct prefix_ipv6 * ) ifc-&gt;address;</a>
<a name="ln506"> </a>
<a name="ln507">  memset (&amp;addreq, 0, sizeof addreq);</a>
<a name="ln508">  strncpy ((char *)&amp;addreq.ifra_name, ifp-&gt;name, sizeof addreq.ifra_name);</a>
<a name="ln509"> </a>
<a name="ln510">  memset (&amp;addr, 0, sizeof (struct sockaddr_in6));</a>
<a name="ln511">  addr.sin6_addr = p-&gt;prefix;</a>
<a name="ln512">  addr.sin6_family = p-&gt;family;</a>
<a name="ln513">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln514">  addr.sin6_len = sizeof (struct sockaddr_in6);</a>
<a name="ln515">#endif</a>
<a name="ln516">  memcpy (&amp;addreq.ifra_addr, &amp;addr, sizeof (struct sockaddr_in6));</a>
<a name="ln517"> </a>
<a name="ln518">  memset (&amp;mask, 0, sizeof (struct sockaddr_in6));</a>
<a name="ln519">  masklen2ip6 (p-&gt;prefixlen, &amp;mask.sin6_addr);</a>
<a name="ln520">  mask.sin6_family = p-&gt;family;</a>
<a name="ln521">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln522">  mask.sin6_len = sizeof (struct sockaddr_in6);</a>
<a name="ln523">#endif</a>
<a name="ln524">  memcpy (&amp;addreq.ifra_prefixmask, &amp;mask, sizeof (struct sockaddr_in6));</a>
<a name="ln525"> </a>
<a name="ln526">  addreq.ifra_lifetime.ia6t_vltime = 0xffffffff;</a>
<a name="ln527">  addreq.ifra_lifetime.ia6t_pltime = 0xffffffff;</a>
<a name="ln528">  </a>
<a name="ln529">#ifdef HAVE_STRUCT_IF6_ALIASREQ_IFRA_LIFETIME </a>
<a name="ln530">  addreq.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME; </a>
<a name="ln531">  addreq.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME; </a>
<a name="ln532">#endif</a>
<a name="ln533"> </a>
<a name="ln534">  ret = if_ioctl_ipv6 (SIOCAIFADDR_IN6, (caddr_t) &amp;addreq);</a>
<a name="ln535">  if (ret &lt; 0)</a>
<a name="ln536">    return ret;</a>
<a name="ln537">  return 0;</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">int</a>
<a name="ln541">if_prefix_delete_ipv6 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln542">{</a>
<a name="ln543">  int ret;</a>
<a name="ln544">  struct in6_aliasreq addreq;</a>
<a name="ln545">  struct sockaddr_in6 addr;</a>
<a name="ln546">  struct sockaddr_in6 mask;</a>
<a name="ln547">  struct prefix_ipv6 *p;</a>
<a name="ln548"> </a>
<a name="ln549">  p = (struct prefix_ipv6 *) ifc-&gt;address;</a>
<a name="ln550"> </a>
<a name="ln551">  memset (&amp;addreq, 0, sizeof addreq);</a>
<a name="ln552">  strncpy ((char *)&amp;addreq.ifra_name, ifp-&gt;name, sizeof addreq.ifra_name);</a>
<a name="ln553"> </a>
<a name="ln554">  memset (&amp;addr, 0, sizeof (struct sockaddr_in6));</a>
<a name="ln555">  addr.sin6_addr = p-&gt;prefix;</a>
<a name="ln556">  addr.sin6_family = p-&gt;family;</a>
<a name="ln557">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln558">  addr.sin6_len = sizeof (struct sockaddr_in6);</a>
<a name="ln559">#endif</a>
<a name="ln560">  memcpy (&amp;addreq.ifra_addr, &amp;addr, sizeof (struct sockaddr_in6));</a>
<a name="ln561"> </a>
<a name="ln562">  memset (&amp;mask, 0, sizeof (struct sockaddr_in6));</a>
<a name="ln563">  masklen2ip6 (p-&gt;prefixlen, &amp;mask.sin6_addr);</a>
<a name="ln564">  mask.sin6_family = p-&gt;family;</a>
<a name="ln565">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln566">  mask.sin6_len = sizeof (struct sockaddr_in6);</a>
<a name="ln567">#endif</a>
<a name="ln568">  memcpy (&amp;addreq.ifra_prefixmask, &amp;mask, sizeof (struct sockaddr_in6));</a>
<a name="ln569"> </a>
<a name="ln570">#ifdef HAVE_STRUCT_IF6_ALIASREQ_IFRA_LIFETIME</a>
<a name="ln571">  addreq.ifra_lifetime.ia6t_pltime = ND6_INFINITE_LIFETIME; </a>
<a name="ln572">  addreq.ifra_lifetime.ia6t_vltime = ND6_INFINITE_LIFETIME; </a>
<a name="ln573">#endif</a>
<a name="ln574"> </a>
<a name="ln575">  ret = if_ioctl_ipv6 (SIOCDIFADDR_IN6, (caddr_t) &amp;addreq);</a>
<a name="ln576">  if (ret &lt; 0)</a>
<a name="ln577">    return ret;</a>
<a name="ln578">  return 0;</a>
<a name="ln579">}</a>
<a name="ln580">#else</a>
<a name="ln581">int</a>
<a name="ln582">if_prefix_add_ipv6 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln583">{</a>
<a name="ln584">  return 0;</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">int</a>
<a name="ln588">if_prefix_delete_ipv6 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln589">{</a>
<a name="ln590">  return 0;</a>
<a name="ln591">}</a>
<a name="ln592">#endif /* HAVE_STRUCT_IN6_ALIASREQ */</a>
<a name="ln593"> </a>
<a name="ln594">#endif /* LINUX_IPV6 */</a>
<a name="ln595"> </a>
<a name="ln596">#endif /* HAVE_IPV6 */</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
