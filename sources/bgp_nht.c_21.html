
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_nht.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP Nexthop tracking</a>
<a name="ln2"> * Copyright (C) 2013 Cumulus Networks, Inc.</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.</a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;command.h&quot;</a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;zclient.h&quot;</a>
<a name="ln28">#include &quot;stream.h&quot;</a>
<a name="ln29">#include &quot;network.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31">#include &quot;memory.h&quot;</a>
<a name="ln32">#include &quot;nexthop.h&quot;</a>
<a name="ln33">#include &quot;filter.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln38">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln39">#include &quot;bgpd/bgp_nexthop.h&quot;</a>
<a name="ln40">#include &quot;bgpd/bgp_debug.h&quot;</a>
<a name="ln41">#include &quot;bgpd/bgp_nht.h&quot;</a>
<a name="ln42">#include &quot;bgpd/bgp_fsm.h&quot;</a>
<a name="ln43">#include &quot;bgpd/bgp_zebra.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">extern struct zclient *zclient;</a>
<a name="ln46">extern struct bgp_table *bgp_nexthop_cache_table[AFI_MAX];</a>
<a name="ln47"> </a>
<a name="ln48">static void register_nexthop(struct bgp_nexthop_cache *bnc);</a>
<a name="ln49">static void unregister_nexthop (struct bgp_nexthop_cache *bnc);</a>
<a name="ln50">static void evaluate_paths(struct bgp_nexthop_cache *bnc);</a>
<a name="ln51">static int make_prefix(int afi, struct bgp_info *ri, struct prefix *p);</a>
<a name="ln52">static void path_nh_map(struct bgp_info *path, struct bgp_nexthop_cache *bnc,</a>
<a name="ln53">			int keep);</a>
<a name="ln54"> </a>
<a name="ln55">int</a>
<a name="ln56">bgp_nexthop_check (struct bgp_info *path, int connected)</a>
<a name="ln57">{</a>
<a name="ln58">  struct bgp_nexthop_cache *bnc = path-&gt;nexthop;</a>
<a name="ln59"> </a>
<a name="ln60">  if (!bnc)</a>
<a name="ln61">    return 0;</a>
<a name="ln62"> </a>
<a name="ln63">  if (BGP_DEBUG(nht, NHT))</a>
<a name="ln64">    {</a>
<a name="ln65">      char buf[INET6_ADDRSTRLEN];</a>
<a name="ln66">      zlog_debug(&quot;%s: NHT checking %s&quot;, </a>
<a name="ln67">                 __FUNCTION__,</a>
<a name="ln68">                 bnc_str (bnc, buf, INET6_ADDRSTRLEN));</a>
<a name="ln69">    }</a>
<a name="ln70"> </a>
<a name="ln71">  if (connected &amp;&amp; !(CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_CONNECTED)))</a>
<a name="ln72">    return 0;</a>
<a name="ln73"> </a>
<a name="ln74">  return (bgp_zebra_num_connects() == 0 ||</a>
<a name="ln75">          CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_VALID));</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">/* Helper to get the rn for the appropriate nexthop for path or peer.</a>
<a name="ln79"> * returns the locked rn - caller must bump down the refcnt.</a>
<a name="ln80"> *</a>
<a name="ln81"> * may return NULL in error cases.</a>
<a name="ln82"> */</a>
<a name="ln83">static</a>
<a name="ln84">struct bgp_node *</a>
<a name="ln85">bgp_get_nexthop_rn (struct bgp_info *path, struct peer *peer)</a>
<a name="ln86">{</a>
<a name="ln87">  struct prefix p;</a>
<a name="ln88">  afi_t afi;</a>
<a name="ln89">  </a>
<a name="ln90">  assert (path || peer);</a>
<a name="ln91">  </a>
<a name="ln92">  if (!(path || peer))</a>
<a name="ln93">    return NULL;</a>
<a name="ln94">  </a>
<a name="ln95">  if (path)</a>
<a name="ln96">    {</a>
<a name="ln97">      afi = family2afi (path-&gt;net-&gt;p.family);</a>
<a name="ln98">      if (make_prefix(afi, path, &amp;p) &lt; 0)</a>
<a name="ln99">	return NULL;</a>
<a name="ln100">    }</a>
<a name="ln101">  else</a>
<a name="ln102">    {</a>
<a name="ln103">      afi = family2afi(peer-&gt;su.sa.sa_family);</a>
<a name="ln104">      if (afi == AFI_IP)</a>
<a name="ln105">	{</a>
<a name="ln106">	  p.family = AF_INET;</a>
<a name="ln107">	  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln108">	  p.u.prefix4 = peer-&gt;su.sin.sin_addr;</a>
<a name="ln109">	}</a>
<a name="ln110">      else if (afi == AFI_IP6)</a>
<a name="ln111">	{</a>
<a name="ln112">	  p.family = AF_INET6;</a>
<a name="ln113">	  p.prefixlen = IPV6_MAX_BITLEN;</a>
<a name="ln114">	  p.u.prefix6 = peer-&gt;su.sin6.sin6_addr;</a>
<a name="ln115">	}</a>
<a name="ln116">      else</a>
<a name="ln117">        return NULL;</a>
<a name="ln118">    }</a>
<a name="ln119">  </a>
<a name="ln120">  return bgp_node_get (bgp_nexthop_cache_table[afi], &amp;p);</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">static</a>
<a name="ln124">struct bgp_nexthop_cache *</a>
<a name="ln125">bgp_find_nexthop (struct bgp_info *path, struct peer *peer)</a>
<a name="ln126">{</a>
<a name="ln127">  struct bgp_nexthop_cache *bnc = NULL;</a>
<a name="ln128">  struct bgp_node *rn = bgp_get_nexthop_rn (path, peer);</a>
<a name="ln129">  </a>
<a name="ln130">  if (!rn)</a>
<a name="ln131">    return NULL;</a>
<a name="ln132">  </a>
<a name="ln133">  bnc = rn-&gt;info;</a>
<a name="ln134">  bgp_unlock_node (rn);</a>
<a name="ln135">  </a>
<a name="ln136">  return bnc;</a>
<a name="ln137">}</a>
<a name="ln138"> </a>
<a name="ln139">static void</a>
<a name="ln140">bgp_unlink_nexthop_check (struct bgp_nexthop_cache *bnc)</a>
<a name="ln141">{</a>
<a name="ln142">  if (LIST_EMPTY(&amp;(bnc-&gt;paths)) &amp;&amp; !bnc-&gt;nht_info)</a>
<a name="ln143">    {</a>
<a name="ln144">      if (BGP_DEBUG(nht, NHT))</a>
<a name="ln145">	{</a>
<a name="ln146">	  char buf[INET6_ADDRSTRLEN];</a>
<a name="ln147">	  zlog_debug(&quot;bgp_unlink_nexthop: freeing bnc %s&quot;,</a>
<a name="ln148">		     bnc_str (bnc, buf, INET6_ADDRSTRLEN));</a>
<a name="ln149"> 	}</a>
<a name="ln150">      unregister_nexthop(bnc);</a>
<a name="ln151">      bnc-&gt;node-&gt;info = NULL;</a>
<a name="ln152">      bgp_unlock_node (bnc-&gt;node);</a>
<a name="ln153">      bnc-&gt;node = NULL;</a>
<a name="ln154">      bnc_free (bnc);</a>
<a name="ln155">    }</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">void</a>
<a name="ln159">bgp_unlink_nexthop (struct bgp_info *path)</a>
<a name="ln160">{</a>
<a name="ln161">  struct bgp_nexthop_cache *bnc = path-&gt;nexthop;</a>
<a name="ln162"> </a>
<a name="ln163">  if (!bnc)</a>
<a name="ln164">    return;</a>
<a name="ln165"> </a>
<a name="ln166">  if (BGP_DEBUG(nht, NHT))</a>
<a name="ln167">    {</a>
<a name="ln168">      char buf[INET6_ADDRSTRLEN];</a>
<a name="ln169">      zlog_debug(&quot;%s: NHT unlinking %s&quot;, </a>
<a name="ln170">                 __FUNCTION__, bnc_str (bnc, buf, INET6_ADDRSTRLEN));</a>
<a name="ln171">    }</a>
<a name="ln172">  </a>
<a name="ln173">  path_nh_map(path, NULL, 0);</a>
<a name="ln174">  </a>
<a name="ln175">  bgp_unlink_nexthop_check (bnc);</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">void</a>
<a name="ln179">bgp_unlink_nexthop_by_peer (struct peer *peer)</a>
<a name="ln180">{</a>
<a name="ln181">  struct bgp_nexthop_cache *bnc = bgp_find_nexthop (NULL, peer);</a>
<a name="ln182">     </a>
<a name="ln183">  if (!bnc)</a>
<a name="ln184">    return;</a>
<a name="ln185"> </a>
<a name="ln186">  if (BGP_DEBUG(nht, NHT))</a>
<a name="ln187">    zlog_debug(&quot;%s: NHT unlinking %s&quot;, </a>
<a name="ln188">                __FUNCTION__, peer-&gt;host);</a>
<a name="ln189">  </a>
<a name="ln190">  bnc-&gt;nht_info = NULL;</a>
<a name="ln191">  </a>
<a name="ln192">  bgp_unlink_nexthop_check (bnc);</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">int</a>
<a name="ln196">bgp_ensure_nexthop (struct bgp_info *ri, struct peer *peer,</a>
<a name="ln197">                    int connected)</a>
<a name="ln198">{</a>
<a name="ln199">  struct bgp_node *rn;</a>
<a name="ln200">  struct bgp_nexthop_cache *bnc;</a>
<a name="ln201">  </a>
<a name="ln202">  rn = bgp_get_nexthop_rn (ri, peer);</a>
<a name="ln203">  </a>
<a name="ln204">  if (!rn)</a>
<a name="ln205">    {</a>
<a name="ln206">      zlog_debug(&quot;%s: NHT could not ensure, failed to get rn!&quot;, </a>
<a name="ln207">                 __FUNCTION__);</a>
<a name="ln208">      return 0;</a>
<a name="ln209">    }</a>
<a name="ln210">  </a>
<a name="ln211">  if (!rn-&gt;info)</a>
<a name="ln212">    {</a>
<a name="ln213">      bnc = bnc_new();</a>
<a name="ln214">      rn-&gt;info = bnc;</a>
<a name="ln215">      bnc-&gt;node = rn;</a>
<a name="ln216">      bgp_lock_node(rn);</a>
<a name="ln217">      if (connected)</a>
<a name="ln218">	SET_FLAG(bnc-&gt;flags, BGP_NEXTHOP_CONNECTED);</a>
<a name="ln219">    }</a>
<a name="ln220"> </a>
<a name="ln221">  bnc = rn-&gt;info;</a>
<a name="ln222">  bgp_unlock_node (rn);</a>
<a name="ln223"> </a>
<a name="ln224">  if (!CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_REGISTERED))</a>
<a name="ln225">    register_nexthop(bnc);</a>
<a name="ln226"> </a>
<a name="ln227">  if (ri)</a>
<a name="ln228">    {</a>
<a name="ln229">      path_nh_map(ri, bnc, 1); /* updates NHT ri list reference */</a>
<a name="ln230"> </a>
<a name="ln231">      if (CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_VALID) &amp;&amp; bnc-&gt;metric)</a>
<a name="ln232">	(bgp_info_extra_get(ri))-&gt;igpmetric = bnc-&gt;metric;</a>
<a name="ln233">      else if (ri-&gt;extra)</a>
<a name="ln234">	ri-&gt;extra-&gt;igpmetric = 0;</a>
<a name="ln235">    }</a>
<a name="ln236">  else if (peer)</a>
<a name="ln237">    bnc-&gt;nht_info = (void *)peer; /* NHT peer reference */</a>
<a name="ln238"> </a>
<a name="ln239">  if (BGP_DEBUG(nht, NHT))</a>
<a name="ln240">    {</a>
<a name="ln241">      char buf[INET6_ADDRSTRLEN];</a>
<a name="ln242">      zlog_debug(&quot;%s: NHT ensured %s&quot;, </a>
<a name="ln243">                 __FUNCTION__, bnc_str (bnc, buf, INET6_ADDRSTRLEN));</a>
<a name="ln244">    }</a>
<a name="ln245">  </a>
<a name="ln246">  return (bgp_zebra_num_connects() == 0 ||</a>
<a name="ln247">          CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_VALID));</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">void</a>
<a name="ln251">bgp_parse_nexthop_update (void)</a>
<a name="ln252">{</a>
<a name="ln253">  struct stream *s;</a>
<a name="ln254">  struct bgp_node *rn;</a>
<a name="ln255">  struct bgp_nexthop_cache *bnc;</a>
<a name="ln256">  struct nexthop *nexthop;</a>
<a name="ln257">  struct nexthop *oldnh;</a>
<a name="ln258">  struct nexthop *nhlist_head = NULL;</a>
<a name="ln259">  struct nexthop *nhlist_tail = NULL;</a>
<a name="ln260">  uint32_t metric;</a>
<a name="ln261">  u_char nexthop_num;</a>
<a name="ln262">  struct prefix p;</a>
<a name="ln263">  int i;</a>
<a name="ln264"> </a>
<a name="ln265">  s = zclient-&gt;ibuf;</a>
<a name="ln266"> </a>
<a name="ln267">  memset(&amp;p, 0, sizeof(struct prefix));</a>
<a name="ln268">  p.family = stream_getw(s);</a>
<a name="ln269">  p.prefixlen = stream_getc(s);</a>
<a name="ln270">  switch (p.family)</a>
<a name="ln271">    {</a>
<a name="ln272">    case AF_INET:</a>
<a name="ln273">      p.u.prefix4.s_addr = stream_get_ipv4 (s);</a>
<a name="ln274">      break;</a>
<a name="ln275">    case AF_INET6:</a>
<a name="ln276">      stream_get(&amp;p.u.prefix6, s, 16);</a>
<a name="ln277">      break;</a>
<a name="ln278">    default:</a>
<a name="ln279">      break;</a>
<a name="ln280">    }</a>
<a name="ln281"> </a>
<a name="ln282">  rn = bgp_node_lookup(bgp_nexthop_cache_table[family2afi(p.family)], &amp;p);</a>
<a name="ln283">  if (!rn || !rn-&gt;info)</a>
<a name="ln284">    {</a>
<a name="ln285">      if (BGP_DEBUG(nht, NHT))</a>
<a name="ln286">	{</a>
<a name="ln287">	  char buf[INET6_ADDRSTRLEN];</a>
<a name="ln288">	  prefix2str(&amp;p, buf, INET6_ADDRSTRLEN);</a>
<a name="ln289">	  zlog_debug(&quot;parse nexthop update(%s): rn not found&quot;, buf);</a>
<a name="ln290">	}</a>
<a name="ln291">      if (rn)</a>
<a name="ln292">        bgp_unlock_node (rn);</a>
<a name="ln293">      return;</a>
<a name="ln294">    }</a>
<a name="ln295"> </a>
<a name="ln296">  bnc = rn-&gt;info;</a>
<a name="ln297">  bgp_unlock_node (rn);</a>
<a name="ln298">  bnc-&gt;last_update = bgp_clock();</a>
<a name="ln299">  bnc-&gt;change_flags = 0;</a>
<a name="ln300">  metric = stream_getl (s);</a>
<a name="ln301">  nexthop_num = stream_getc (s);</a>
<a name="ln302"> </a>
<a name="ln303">  /* debug print the input */</a>
<a name="ln304">  if (BGP_DEBUG(nht, NHT))</a>
<a name="ln305">    {</a>
<a name="ln306">      char buf[INET6_ADDRSTRLEN];</a>
<a name="ln307">      prefix2str(&amp;p, buf, INET6_ADDRSTRLEN);</a>
<a name="ln308">      zlog_debug(&quot;parse nexthop update(%s): metric=%d, #nexthop=%d&quot;, buf,</a>
<a name="ln309">		 metric, nexthop_num);</a>
<a name="ln310">    }</a>
<a name="ln311"> </a>
<a name="ln312">  if (metric != bnc-&gt;metric)</a>
<a name="ln313">    bnc-&gt;change_flags |= BGP_NEXTHOP_METRIC_CHANGED;</a>
<a name="ln314"> </a>
<a name="ln315">  if(nexthop_num != bnc-&gt;nexthop_num)</a>
<a name="ln316">    bnc-&gt;change_flags |= BGP_NEXTHOP_CHANGED;</a>
<a name="ln317"> </a>
<a name="ln318">  if (nexthop_num)</a>
<a name="ln319">    {</a>
<a name="ln320">      bnc-&gt;flags |= BGP_NEXTHOP_VALID;</a>
<a name="ln321">      bnc-&gt;metric = metric;</a>
<a name="ln322">      bnc-&gt;nexthop_num = nexthop_num;</a>
<a name="ln323"> </a>
<a name="ln324">      for (i = 0; i &lt; nexthop_num; i++)</a>
<a name="ln325">	{</a>
<a name="ln326">	  nexthop = nexthop_new();</a>
<a name="ln327">	  nexthop-&gt;type = stream_getc (s);</a>
<a name="ln328">	  switch (nexthop-&gt;type)</a>
<a name="ln329">	    {</a>
<a name="ln330">	    case ZEBRA_NEXTHOP_IPV4:</a>
<a name="ln331">	      nexthop-&gt;gate.ipv4.s_addr = stream_get_ipv4 (s);</a>
<a name="ln332">	      break;</a>
<a name="ln333">	    case ZEBRA_NEXTHOP_IFINDEX:</a>
<a name="ln334">	    case ZEBRA_NEXTHOP_IFNAME:</a>
<a name="ln335">	      nexthop-&gt;ifindex = stream_getl (s);</a>
<a name="ln336">	      break;</a>
<a name="ln337">            case ZEBRA_NEXTHOP_IPV4_IFINDEX:</a>
<a name="ln338">	    case ZEBRA_NEXTHOP_IPV4_IFNAME:</a>
<a name="ln339">	      nexthop-&gt;gate.ipv4.s_addr = stream_get_ipv4 (s);</a>
<a name="ln340">	      nexthop-&gt;ifindex = stream_getl (s);</a>
<a name="ln341">	      break;</a>
<a name="ln342">#ifdef HAVE_IPV6</a>
<a name="ln343">            case ZEBRA_NEXTHOP_IPV6:</a>
<a name="ln344">	      stream_get (&amp;nexthop-&gt;gate.ipv6, s, 16);</a>
<a name="ln345">	      break;</a>
<a name="ln346">            case ZEBRA_NEXTHOP_IPV6_IFINDEX:</a>
<a name="ln347">	    case ZEBRA_NEXTHOP_IPV6_IFNAME:</a>
<a name="ln348">	      stream_get (&amp;nexthop-&gt;gate.ipv6, s, 16);</a>
<a name="ln349">	      nexthop-&gt;ifindex = stream_getl (s);</a>
<a name="ln350">	      break;</a>
<a name="ln351">#endif</a>
<a name="ln352">            default:</a>
<a name="ln353">              /* do nothing */</a>
<a name="ln354">              break;</a>
<a name="ln355">	    }</a>
<a name="ln356"> </a>
<a name="ln357">	  if (nhlist_tail)</a>
<a name="ln358">	    {</a>
<a name="ln359">	      nhlist_tail-&gt;next = nexthop;</a>
<a name="ln360">	      nhlist_tail = nexthop;</a>
<a name="ln361">	    }</a>
<a name="ln362">	  else</a>
<a name="ln363">	    {</a>
<a name="ln364">	      nhlist_tail = nexthop;</a>
<a name="ln365">	      nhlist_head = nexthop;</a>
<a name="ln366">	    }</a>
<a name="ln367"> </a>
<a name="ln368">	  /* No need to evaluate the nexthop if we have already determined</a>
<a name="ln369">	   * that there has been a change.</a>
<a name="ln370">	   */</a>
<a name="ln371">	  if (bnc-&gt;change_flags &amp; BGP_NEXTHOP_CHANGED)</a>
<a name="ln372">	    continue;</a>
<a name="ln373"> </a>
<a name="ln374">	  for (oldnh = bnc-&gt;nexthop; oldnh; oldnh = oldnh-&gt;next)</a>
<a name="ln375">	      if (nexthop_same_no_recurse(oldnh, nexthop))</a>
<a name="ln376">		  break;</a>
<a name="ln377"> </a>
<a name="ln378">	  if (!oldnh)</a>
<a name="ln379">	    bnc-&gt;change_flags |= BGP_NEXTHOP_CHANGED;</a>
<a name="ln380">	}</a>
<a name="ln381">      bnc_nexthop_free(bnc);</a>
<a name="ln382">      bnc-&gt;nexthop = nhlist_head;</a>
<a name="ln383">    }</a>
<a name="ln384">  else</a>
<a name="ln385">    {</a>
<a name="ln386">      bnc-&gt;flags &amp;= ~BGP_NEXTHOP_VALID;</a>
<a name="ln387">      UNSET_FLAG(bnc-&gt;flags, BGP_NEXTHOP_PEER_NOTIFIED);</a>
<a name="ln388">      bnc_nexthop_free(bnc);</a>
<a name="ln389">      bnc-&gt;nexthop = NULL;</a>
<a name="ln390">    }</a>
<a name="ln391"> </a>
<a name="ln392">  evaluate_paths(bnc);</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">/**</a>
<a name="ln396"> * make_prefix - make a prefix structure from the path (essentially</a>
<a name="ln397"> * path's node.</a>
<a name="ln398"> */</a>
<a name="ln399">static int</a>
<a name="ln400">make_prefix (int afi, struct bgp_info *ri, struct prefix *p)</a>
<a name="ln401">{</a>
<a name="ln402">  memset (p, 0, sizeof (struct prefix));</a>
<a name="ln403">  switch (afi)</a>
<a name="ln404">    {</a>
<a name="ln405">    case AFI_IP:</a>
<a name="ln406">      p-&gt;family = AF_INET;</a>
<a name="ln407">      p-&gt;prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln408">      p-&gt;u.prefix4 = ri-&gt;attr-&gt;nexthop;</a>
<a name="ln409">      break;</a>
<a name="ln410">#ifdef HAVE_IPV6</a>
<a name="ln411">    case AFI_IP6:</a>
<a name="ln412">      if (ri-&gt;attr-&gt;extra-&gt;mp_nexthop_len == 16</a>
<a name="ln413">	  &amp;&amp; IN6_IS_ADDR_LINKLOCAL (&amp;ri-&gt;attr-&gt;extra-&gt;mp_nexthop_global))</a>
<a name="ln414">	return -1;</a>
<a name="ln415"> </a>
<a name="ln416">      p-&gt;family = AF_INET6;</a>
<a name="ln417">      p-&gt;prefixlen = IPV6_MAX_BITLEN;</a>
<a name="ln418">      p-&gt;u.prefix6 = ri-&gt;attr-&gt;extra-&gt;mp_nexthop_global;</a>
<a name="ln419">      break;</a>
<a name="ln420">#endif</a>
<a name="ln421">    default:</a>
<a name="ln422">      break;</a>
<a name="ln423">    }</a>
<a name="ln424">  return 0;</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">/**</a>
<a name="ln428"> * sendmsg_nexthop -- Format and send a nexthop register/Unregister</a>
<a name="ln429"> *   command to Zebra.</a>
<a name="ln430"> * ARGUMENTS:</a>
<a name="ln431"> *   struct bgp_nexthop_cache *bnc -- the nexthop structure.</a>
<a name="ln432"> *   int command -- either ZEBRA_NEXTHOP_REGISTER or ZEBRA_NEXTHOP_UNREGISTER</a>
<a name="ln433"> * RETURNS:</a>
<a name="ln434"> *   void.</a>
<a name="ln435"> */</a>
<a name="ln436">static void</a>
<a name="ln437">sendmsg_nexthop (struct bgp_nexthop_cache *bnc, int command)</a>
<a name="ln438">{</a>
<a name="ln439">  struct stream *s;</a>
<a name="ln440">  struct prefix *p;</a>
<a name="ln441">  int ret;</a>
<a name="ln442"> </a>
<a name="ln443">  /* Check socket. */</a>
<a name="ln444">  if (!zclient || zclient-&gt;sock &lt; 0)</a>
<a name="ln445">    {</a>
<a name="ln446">      zlog_debug(&quot;%s: Can't send NH register, Zebra client not established&quot;,</a>
<a name="ln447">		 __FUNCTION__);</a>
<a name="ln448">      return;</a>
<a name="ln449">    }</a>
<a name="ln450"> </a>
<a name="ln451">  p = &amp;(bnc-&gt;node-&gt;p);</a>
<a name="ln452">  s = zclient-&gt;obuf;</a>
<a name="ln453">  stream_reset (s);</a>
<a name="ln454">  zclient_create_header (s, command, VRF_DEFAULT);</a>
<a name="ln455">  if (CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_CONNECTED))</a>
<a name="ln456">    stream_putc(s, 1);</a>
<a name="ln457">  else</a>
<a name="ln458">    stream_putc(s, 0);</a>
<a name="ln459"> </a>
<a name="ln460">  stream_putw(s, PREFIX_FAMILY(p));</a>
<a name="ln461">  stream_putc(s, p-&gt;prefixlen);</a>
<a name="ln462">  switch (PREFIX_FAMILY(p))</a>
<a name="ln463">    {</a>
<a name="ln464">    case AF_INET:</a>
<a name="ln465">      stream_put_in_addr (s, &amp;p-&gt;u.prefix4);</a>
<a name="ln466">      break;</a>
<a name="ln467">    case AF_INET6:</a>
<a name="ln468">      stream_put(s, &amp;(p-&gt;u.prefix6), 16);</a>
<a name="ln469">      break;</a>
<a name="ln470">    default:</a>
<a name="ln471">      break;</a>
<a name="ln472">    }</a>
<a name="ln473">  stream_putw_at (s, 0, stream_get_endp (s));</a>
<a name="ln474"> </a>
<a name="ln475">  ret = zclient_send_message(zclient);</a>
<a name="ln476">  /* TBD: handle the failure */</a>
<a name="ln477">  if (ret &lt; 0)</a>
<a name="ln478">    zlog_warn(&quot;sendmsg_nexthop: zclient_send_message() failed&quot;);</a>
<a name="ln479"> </a>
<a name="ln480">  if (command == ZEBRA_NEXTHOP_REGISTER)</a>
<a name="ln481">    SET_FLAG(bnc-&gt;flags, BGP_NEXTHOP_REGISTERED);</a>
<a name="ln482">  else if (command == ZEBRA_NEXTHOP_UNREGISTER)</a>
<a name="ln483">    UNSET_FLAG(bnc-&gt;flags, BGP_NEXTHOP_REGISTERED);</a>
<a name="ln484">  return;</a>
<a name="ln485">}</a>
<a name="ln486"> </a>
<a name="ln487">/**</a>
<a name="ln488"> * register_nexthop - register a nexthop with Zebra for notification</a>
<a name="ln489"> *    when the route to the nexthop changes.</a>
<a name="ln490"> * ARGUMENTS:</a>
<a name="ln491"> *   struct bgp_nexthop_cache *bnc -- the nexthop structure.</a>
<a name="ln492"> * RETURNS:</a>
<a name="ln493"> *   void.</a>
<a name="ln494"> */</a>
<a name="ln495">static void</a>
<a name="ln496">register_nexthop (struct bgp_nexthop_cache *bnc)</a>
<a name="ln497">{</a>
<a name="ln498">  /* Check if we have already registered */</a>
<a name="ln499">  if (bnc-&gt;flags &amp; BGP_NEXTHOP_REGISTERED)</a>
<a name="ln500">    return;</a>
<a name="ln501">  sendmsg_nexthop(bnc, ZEBRA_NEXTHOP_REGISTER);</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">/**</a>
<a name="ln505"> * unregister_nexthop -- Unregister the nexthop from Zebra.</a>
<a name="ln506"> * ARGUMENTS:</a>
<a name="ln507"> *   struct bgp_nexthop_cache *bnc -- the nexthop structure.</a>
<a name="ln508"> * RETURNS:</a>
<a name="ln509"> *   void.</a>
<a name="ln510"> */</a>
<a name="ln511">static void</a>
<a name="ln512">unregister_nexthop (struct bgp_nexthop_cache *bnc)</a>
<a name="ln513">{</a>
<a name="ln514">  /* Check if we have already registered */</a>
<a name="ln515">  if (!CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_REGISTERED))</a>
<a name="ln516">    return;</a>
<a name="ln517"> </a>
<a name="ln518">  sendmsg_nexthop(bnc, ZEBRA_NEXTHOP_UNREGISTER);</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">/**</a>
<a name="ln522"> * evaluate_paths - Evaluate the paths/nets associated with a nexthop.</a>
<a name="ln523"> * ARGUMENTS:</a>
<a name="ln524"> *   struct bgp_nexthop_cache *bnc -- the nexthop structure.</a>
<a name="ln525"> * RETURNS:</a>
<a name="ln526"> *   void.</a>
<a name="ln527"> */</a>
<a name="ln528">static void</a>
<a name="ln529">evaluate_paths (struct bgp_nexthop_cache *bnc)</a>
<a name="ln530">{</a>
<a name="ln531">  struct bgp_node *rn;</a>
<a name="ln532">  struct bgp_info *path;</a>
<a name="ln533">  struct bgp *bgp = bgp_get_default();</a>
<a name="ln534">  int afi;</a>
<a name="ln535">  struct peer *peer = (struct peer *)bnc-&gt;nht_info;</a>
<a name="ln536"> </a>
<a name="ln537">  LIST_FOREACH(path, &amp;(bnc-&gt;paths), nh_thread)</a>
<a name="ln538">    {</a>
<a name="ln539">      if (!(path-&gt;type == ZEBRA_ROUTE_BGP &amp;&amp;</a>
<a name="ln540">	    path-&gt;sub_type == BGP_ROUTE_NORMAL))</a>
<a name="ln541">	continue;</a>
<a name="ln542"> </a>
<a name="ln543">      rn = path-&gt;net;</a>
<a name="ln544">      afi = family2afi(rn-&gt;p.family);</a>
<a name="ln545"> </a>
<a name="ln546">      /* Path becomes valid/invalid depending on whether the nexthop</a>
<a name="ln547">       * reachable/unreachable.</a>
<a name="ln548">       */</a>
<a name="ln549">      if ((CHECK_FLAG(path-&gt;flags, BGP_INFO_VALID) ? 1 : 0) !=</a>
<a name="ln550">	  (CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_VALID) ? 1 : 0))</a>
<a name="ln551">	{</a>
<a name="ln552">	  if (CHECK_FLAG (path-&gt;flags, BGP_INFO_VALID))</a>
<a name="ln553">	    {</a>
<a name="ln554">	      bgp_aggregate_decrement (bgp, &amp;rn-&gt;p, path,</a>
<a name="ln555">				       afi, SAFI_UNICAST);</a>
<a name="ln556">	      bgp_info_unset_flag (rn, path, BGP_INFO_VALID);</a>
<a name="ln557">	    }</a>
<a name="ln558">	  else</a>
<a name="ln559">	    {</a>
<a name="ln560">	      bgp_info_set_flag (rn, path, BGP_INFO_VALID);</a>
<a name="ln561">	      bgp_aggregate_increment (bgp, &amp;rn-&gt;p, path,</a>
<a name="ln562">				       afi, SAFI_UNICAST);</a>
<a name="ln563">	    }</a>
<a name="ln564">	}</a>
<a name="ln565"> </a>
<a name="ln566">      /* Copy the metric to the path. Will be used for bestpath computation */</a>
<a name="ln567">      if (CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_VALID) &amp;&amp; bnc-&gt;metric)</a>
<a name="ln568">	(bgp_info_extra_get(path))-&gt;igpmetric = bnc-&gt;metric;</a>
<a name="ln569">      else if (path-&gt;extra)</a>
<a name="ln570">	path-&gt;extra-&gt;igpmetric = 0;</a>
<a name="ln571"> </a>
<a name="ln572">      if (CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_METRIC_CHANGED) ||</a>
<a name="ln573">	  CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_CHANGED))</a>
<a name="ln574">	SET_FLAG(path-&gt;flags, BGP_INFO_IGP_CHANGED);</a>
<a name="ln575"> </a>
<a name="ln576">      bgp_process(bgp, rn, afi, SAFI_UNICAST);</a>
<a name="ln577">    }</a>
<a name="ln578"> </a>
<a name="ln579">  if (peer &amp;&amp; !CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_PEER_NOTIFIED))</a>
<a name="ln580">    {</a>
<a name="ln581">      if (BGP_DEBUG(nht, NHT))</a>
<a name="ln582">	zlog_debug(&quot;%s: Updating peer (%s) status with NHT&quot;, __FUNCTION__, peer-&gt;host);</a>
<a name="ln583">      SET_FLAG(bnc-&gt;flags, BGP_NEXTHOP_PEER_NOTIFIED);</a>
<a name="ln584">    }</a>
<a name="ln585"> </a>
<a name="ln586">  RESET_FLAG(bnc-&gt;change_flags);</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">/**</a>
<a name="ln590"> * path_nh_map - make or break path-to-nexthop association.</a>
<a name="ln591"> * ARGUMENTS:</a>
<a name="ln592"> *   path - pointer to the path structure</a>
<a name="ln593"> *   bnc - pointer to the nexthop structure</a>
<a name="ln594"> *   make - if set, make the association. if unset, just break the existing</a>
<a name="ln595"> *          association.</a>
<a name="ln596"> */</a>
<a name="ln597">static void</a>
<a name="ln598">path_nh_map (struct bgp_info *path, struct bgp_nexthop_cache *bnc, int make)</a>
<a name="ln599">{</a>
<a name="ln600">  if (path-&gt;nexthop)</a>
<a name="ln601">    {</a>
<a name="ln602">      LIST_REMOVE(path, nh_thread);</a>
<a name="ln603">      path-&gt;nexthop-&gt;path_count--;</a>
<a name="ln604">      path-&gt;nexthop = NULL;</a>
<a name="ln605">    }</a>
<a name="ln606">  if (make)</a>
<a name="ln607">    {</a>
<a name="ln608">      LIST_INSERT_HEAD(&amp;(bnc-&gt;paths), path, nh_thread);</a>
<a name="ln609">      path-&gt;nexthop = bnc;</a>
<a name="ln610">      path-&gt;nexthop-&gt;path_count++;</a>
<a name="ln611">    }</a>
<a name="ln612">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
