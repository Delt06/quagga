
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_event.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP event manager</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;string.h&gt;</a>
<a name="ln11">#include &lt;sys/socket.h&gt;</a>
<a name="ln12">#include &lt;sys/un.h&gt;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;thread.h&quot;</a>
<a name="ln15">#include &quot;zbuf.h&quot;</a>
<a name="ln16">#include &quot;log.h&quot;</a>
<a name="ln17">#include &quot;nhrpd.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">const char *nhrp_event_socket_path;</a>
<a name="ln20">struct nhrp_reqid_pool nhrp_event_reqid;</a>
<a name="ln21"> </a>
<a name="ln22">struct event_manager {</a>
<a name="ln23">	struct thread *t_reconnect, *t_read, *t_write;</a>
<a name="ln24">	struct zbuf ibuf;</a>
<a name="ln25">	struct zbuf_queue obuf;</a>
<a name="ln26">	int fd;</a>
<a name="ln27">	uint8_t ibuf_data[4*1024];</a>
<a name="ln28">};</a>
<a name="ln29"> </a>
<a name="ln30">static int evmgr_reconnect(struct thread *t);</a>
<a name="ln31"> </a>
<a name="ln32">static void evmgr_connection_error(struct event_manager *evmgr)</a>
<a name="ln33">{</a>
<a name="ln34">	THREAD_OFF(evmgr-&gt;t_read);</a>
<a name="ln35">	THREAD_OFF(evmgr-&gt;t_write);</a>
<a name="ln36">	zbuf_reset(&amp;evmgr-&gt;ibuf);</a>
<a name="ln37">	zbufq_reset(&amp;evmgr-&gt;obuf);</a>
<a name="ln38"> </a>
<a name="ln39">	if (evmgr-&gt;fd &gt;= 0)</a>
<a name="ln40">		close(evmgr-&gt;fd);</a>
<a name="ln41">	evmgr-&gt;fd = -1;</a>
<a name="ln42">	if (nhrp_event_socket_path)</a>
<a name="ln43">		THREAD_TIMER_MSEC_ON(master, evmgr-&gt;t_reconnect, evmgr_reconnect,</a>
<a name="ln44">				     evmgr, 10);</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">static void evmgr_recv_message(struct event_manager *evmgr, struct zbuf *zb)</a>
<a name="ln48">{</a>
<a name="ln49">	struct zbuf zl;</a>
<a name="ln50">	uint32_t eventid = 0;</a>
<a name="ln51">	size_t len;</a>
<a name="ln52">	char buf[256], result[64] = &quot;&quot;;</a>
<a name="ln53"> </a>
<a name="ln54">	while (zbuf_may_pull_until(zb, &quot;\n&quot;, &amp;zl)) {</a>
<a name="ln55">		len = zbuf_used(&amp;zl) - 1;</a>
<a name="ln56">		if (len &gt;= sizeof(buf)-1)</a>
<a name="ln57">			continue;</a>
<a name="ln58">		memcpy(buf, zbuf_pulln(&amp;zl, len), len);</a>
<a name="ln59">		buf[len] = 0;</a>
<a name="ln60"> </a>
<a name="ln61">		debugf(NHRP_DEBUG_EVENT, &quot;evmgr: msg: %s&quot;, buf);</a>
<a name="ln62">		sscanf(buf, &quot;eventid=%d&quot;, &amp;eventid);</a>
<a name="ln63">		sscanf(buf, &quot;result=%63s&quot;, result);</a>
<a name="ln64">	}</a>
<a name="ln65">	debugf(NHRP_DEBUG_EVENT, &quot;evmgr: received: eventid=%d result=%s&quot;, eventid, result);</a>
<a name="ln66">	if (eventid &amp;&amp; result[0]) {</a>
<a name="ln67">		struct nhrp_reqid *r = nhrp_reqid_lookup(&amp;nhrp_event_reqid, eventid);</a>
<a name="ln68">		if (r) r-&gt;cb(r, result);</a>
<a name="ln69">	}</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">static int evmgr_read(struct thread *t)</a>
<a name="ln73">{</a>
<a name="ln74">	struct event_manager *evmgr = THREAD_ARG(t);</a>
<a name="ln75">	struct zbuf *ibuf = &amp;evmgr-&gt;ibuf;</a>
<a name="ln76">	struct zbuf msg;</a>
<a name="ln77"> </a>
<a name="ln78">	evmgr-&gt;t_read = NULL;</a>
<a name="ln79">	if (zbuf_read(ibuf, evmgr-&gt;fd, (size_t) -1) &lt; 0) {</a>
<a name="ln80">		evmgr_connection_error(evmgr);</a>
<a name="ln81">		return 0;</a>
<a name="ln82">	}</a>
<a name="ln83"> </a>
<a name="ln84">	/* Process all messages in buffer */</a>
<a name="ln85">	while (zbuf_may_pull_until(ibuf, &quot;\n\n&quot;, &amp;msg))</a>
<a name="ln86">		evmgr_recv_message(evmgr, &amp;msg);</a>
<a name="ln87"> </a>
<a name="ln88">	THREAD_READ_ON(master, evmgr-&gt;t_read, evmgr_read, evmgr, evmgr-&gt;fd);</a>
<a name="ln89">	return 0;</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">static int evmgr_write(struct thread *t)</a>
<a name="ln93">{</a>
<a name="ln94">	struct event_manager *evmgr = THREAD_ARG(t);</a>
<a name="ln95">	int r;</a>
<a name="ln96"> </a>
<a name="ln97">	evmgr-&gt;t_write = NULL;</a>
<a name="ln98">	r = zbufq_write(&amp;evmgr-&gt;obuf, evmgr-&gt;fd);</a>
<a name="ln99">	if (r &gt; 0) {</a>
<a name="ln100">		THREAD_WRITE_ON(master, evmgr-&gt;t_write, evmgr_write, evmgr, evmgr-&gt;fd);</a>
<a name="ln101">	} else if (r &lt; 0) {</a>
<a name="ln102">		evmgr_connection_error(evmgr);</a>
<a name="ln103">	}</a>
<a name="ln104"> </a>
<a name="ln105">	return 0;</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">static void evmgr_hexdump(struct zbuf *zb, const uint8_t *val, size_t vallen)</a>
<a name="ln109">{</a>
<a name="ln110">	static const char xd[] = &quot;0123456789abcdef&quot;;</a>
<a name="ln111">	size_t i;</a>
<a name="ln112">	char *ptr;</a>
<a name="ln113"> </a>
<a name="ln114">	ptr  = zbuf_pushn(zb, 2*vallen);</a>
<a name="ln115">	if (!ptr) return;</a>
<a name="ln116"> </a>
<a name="ln117">	for (i = 0; i &lt; vallen; i++) {</a>
<a name="ln118">		uint8_t b = val[i];</a>
<a name="ln119">		*(ptr++) = xd[b &gt;&gt; 4];</a>
<a name="ln120">		*(ptr++) = xd[b &amp; 0xf];</a>
<a name="ln121">	}</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">static void evmgr_put(struct zbuf *zb, const char *fmt, ...)</a>
<a name="ln125">{</a>
<a name="ln126">	const char *pos, *nxt, *str;</a>
<a name="ln127">	const uint8_t *bin;</a>
<a name="ln128">	const union sockunion *su;</a>
<a name="ln129">	int len;</a>
<a name="ln130">	va_list va;</a>
<a name="ln131"> </a>
<a name="ln132">	va_start(va, fmt);</a>
<a name="ln133">	for (pos = fmt; (nxt = strchr(pos, '%')) != NULL; pos = nxt + 2) {</a>
<a name="ln134">		zbuf_put(zb, pos, nxt-pos);</a>
<a name="ln135">		switch (nxt[1]) {</a>
<a name="ln136">		case '%':</a>
<a name="ln137">			zbuf_put8(zb, '%');</a>
<a name="ln138">			break;</a>
<a name="ln139">		case 'u':</a>
<a name="ln140">			zb-&gt;tail += snprintf((char *) zb-&gt;tail, zbuf_tailroom(zb), &quot;%u&quot;, va_arg(va, uint32_t));</a>
<a name="ln141">			break;</a>
<a name="ln142">		case 's':</a>
<a name="ln143">			str = va_arg(va, const char *);</a>
<a name="ln144">			zbuf_put(zb, str, strlen(str));</a>
<a name="ln145">			break;</a>
<a name="ln146">		case 'U':</a>
<a name="ln147">			su = va_arg(va, const union sockunion *);</a>
<a name="ln148">			if (sockunion2str(su, (char *) zb-&gt;tail, zbuf_tailroom(zb)))</a>
<a name="ln149">				zb-&gt;tail += strlen((char *) zb-&gt;tail);</a>
<a name="ln150">			else</a>
<a name="ln151">				zbuf_set_werror(zb);</a>
<a name="ln152">			break;</a>
<a name="ln153">		case 'H':</a>
<a name="ln154">			bin = va_arg(va, const uint8_t *);</a>
<a name="ln155">			len = va_arg(va, int);</a>
<a name="ln156">			evmgr_hexdump(zb, bin, len);</a>
<a name="ln157">			break;</a>
<a name="ln158">		}</a>
<a name="ln159">	}</a>
<a name="ln160">	va_end(va);</a>
<a name="ln161">	zbuf_put(zb, pos, strlen(pos));</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">static void evmgr_submit(struct event_manager *evmgr, struct zbuf *obuf)</a>
<a name="ln165">{</a>
<a name="ln166">	if (obuf-&gt;error) {</a>
<a name="ln167">		zbuf_free(obuf);</a>
<a name="ln168">		return;</a>
<a name="ln169">	}</a>
<a name="ln170">	zbuf_put(obuf, &quot;\n&quot;, 1);</a>
<a name="ln171">	zbufq_queue(&amp;evmgr-&gt;obuf, obuf);</a>
<a name="ln172">	if (evmgr-&gt;fd &gt;= 0)</a>
<a name="ln173">		THREAD_WRITE_ON(master, evmgr-&gt;t_write, evmgr_write, evmgr, evmgr-&gt;fd);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">static int evmgr_reconnect(struct thread *t)</a>
<a name="ln177">{</a>
<a name="ln178">	struct event_manager *evmgr = THREAD_ARG(t);</a>
<a name="ln179">	int fd;</a>
<a name="ln180"> </a>
<a name="ln181">	evmgr-&gt;t_reconnect = NULL;</a>
<a name="ln182">	if (evmgr-&gt;fd &gt;= 0 || !nhrp_event_socket_path) return 0;</a>
<a name="ln183"> </a>
<a name="ln184">	fd = sock_open_unix(nhrp_event_socket_path);</a>
<a name="ln185">	if (fd &lt; 0) {</a>
<a name="ln186">		zlog_warn(&quot;%s: failure connecting nhrp-event socket: %s&quot;,</a>
<a name="ln187">			__PRETTY_FUNCTION__, strerror(errno));</a>
<a name="ln188">		zbufq_reset(&amp;evmgr-&gt;obuf);</a>
<a name="ln189">		THREAD_TIMER_ON(master, evmgr-&gt;t_reconnect, evmgr_reconnect, evmgr, 10);</a>
<a name="ln190">		return 0;</a>
<a name="ln191">	}</a>
<a name="ln192"> </a>
<a name="ln193">	zlog_info(&quot;Connected to Event Manager&quot;);</a>
<a name="ln194">	evmgr-&gt;fd = fd;</a>
<a name="ln195">	THREAD_READ_ON(master, evmgr-&gt;t_read, evmgr_read, evmgr, evmgr-&gt;fd);</a>
<a name="ln196"> </a>
<a name="ln197">	return 0;</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">static struct event_manager evmgr_connection;</a>
<a name="ln201"> </a>
<a name="ln202">void evmgr_init(void)</a>
<a name="ln203">{</a>
<a name="ln204">	struct event_manager *evmgr = &amp;evmgr_connection;</a>
<a name="ln205"> </a>
<a name="ln206">	evmgr-&gt;fd = -1;</a>
<a name="ln207">	zbuf_init(&amp;evmgr-&gt;ibuf, evmgr-&gt;ibuf_data, sizeof(evmgr-&gt;ibuf_data), 0);</a>
<a name="ln208">	zbufq_init(&amp;evmgr-&gt;obuf);</a>
<a name="ln209">	THREAD_TIMER_MSEC_ON(master, evmgr-&gt;t_reconnect, evmgr_reconnect, evmgr, 10);</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">void evmgr_set_socket(const char *socket)</a>
<a name="ln213">{</a>
<a name="ln214">	if (nhrp_event_socket_path) {</a>
<a name="ln215">		free((char *) nhrp_event_socket_path);</a>
<a name="ln216">		nhrp_event_socket_path = NULL;</a>
<a name="ln217">	}</a>
<a name="ln218">	if (socket)</a>
<a name="ln219">		nhrp_event_socket_path = strdup(socket);</a>
<a name="ln220">	evmgr_connection_error(&amp;evmgr_connection);</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">void evmgr_terminate(void)</a>
<a name="ln224">{</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">void evmgr_notify(const char *name, struct nhrp_cache *c, void (*cb)(struct nhrp_reqid *, void *))</a>
<a name="ln228">{</a>
<a name="ln229">	struct event_manager *evmgr = &amp;evmgr_connection;</a>
<a name="ln230">	struct nhrp_vc *vc;</a>
<a name="ln231">	struct nhrp_interface *nifp = c-&gt;ifp-&gt;info;</a>
<a name="ln232">	struct zbuf *zb;</a>
<a name="ln233">	afi_t afi = family2afi(sockunion_family(&amp;c-&gt;remote_addr));</a>
<a name="ln234"> </a>
<a name="ln235">	if (!nhrp_event_socket_path) {</a>
<a name="ln236">		cb(&amp;c-&gt;eventid, (void*) &quot;accept&quot;);</a>
<a name="ln237">		return;</a>
<a name="ln238">	}</a>
<a name="ln239"> </a>
<a name="ln240">	debugf(NHRP_DEBUG_EVENT, &quot;evmgr: sending event %s&quot;, name);</a>
<a name="ln241"> </a>
<a name="ln242">	vc = c-&gt;new.peer ? c-&gt;new.peer-&gt;vc : NULL;</a>
<a name="ln243">	zb = zbuf_alloc(1024 + (vc ? (vc-&gt;local.certlen + vc-&gt;remote.certlen) * 2 : 0));</a>
<a name="ln244"> </a>
<a name="ln245">	if (cb) {</a>
<a name="ln246">		nhrp_reqid_free(&amp;nhrp_event_reqid, &amp;c-&gt;eventid);</a>
<a name="ln247">		evmgr_put(zb,</a>
<a name="ln248">			&quot;eventid=%u\n&quot;,</a>
<a name="ln249">			nhrp_reqid_alloc(&amp;nhrp_event_reqid, &amp;c-&gt;eventid, cb));</a>
<a name="ln250">	}</a>
<a name="ln251"> </a>
<a name="ln252">	evmgr_put(zb,</a>
<a name="ln253">		&quot;event=%s\n&quot;</a>
<a name="ln254">		&quot;type=%s\n&quot;</a>
<a name="ln255">		&quot;old_type=%s\n&quot;</a>
<a name="ln256">		&quot;num_nhs=%u\n&quot;</a>
<a name="ln257">		&quot;interface=%s\n&quot;</a>
<a name="ln258">		&quot;local_addr=%U\n&quot;,</a>
<a name="ln259">		name,</a>
<a name="ln260">		nhrp_cache_type_str[c-&gt;new.type],</a>
<a name="ln261">		nhrp_cache_type_str[c-&gt;cur.type],</a>
<a name="ln262">		(unsigned int) nhrp_cache_counts[NHRP_CACHE_NHS],</a>
<a name="ln263">		c-&gt;ifp-&gt;name,</a>
<a name="ln264">		&amp;nifp-&gt;afi[afi].addr);</a>
<a name="ln265"> </a>
<a name="ln266">	if (vc) {</a>
<a name="ln267">		evmgr_put(zb,</a>
<a name="ln268">			&quot;vc_initiated=%s\n&quot;</a>
<a name="ln269">			&quot;local_nbma=%U\n&quot;</a>
<a name="ln270">			&quot;local_cert=%H\n&quot;</a>
<a name="ln271">			&quot;remote_addr=%U\n&quot;</a>
<a name="ln272">			&quot;remote_nbma=%U\n&quot;</a>
<a name="ln273">			&quot;remote_cert=%H\n&quot;,</a>
<a name="ln274">			c-&gt;new.peer-&gt;requested ? &quot;yes&quot; : &quot;no&quot;,</a>
<a name="ln275">			&amp;vc-&gt;local.nbma,</a>
<a name="ln276">			vc-&gt;local.cert, vc-&gt;local.certlen,</a>
<a name="ln277">			&amp;c-&gt;remote_addr, &amp;vc-&gt;remote.nbma,</a>
<a name="ln278">			vc-&gt;remote.cert, vc-&gt;remote.certlen);</a>
<a name="ln279">	}</a>
<a name="ln280"> </a>
<a name="ln281">	evmgr_submit(evmgr, zb);</a>
<a name="ln282">}</a>
<a name="ln283"> </a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="62"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'sscanf' function. A pointer to the signed int type is expected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
