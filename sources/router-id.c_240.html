
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>router-id.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Router ID for zebra daemon.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2004 James R. Leu </a>
<a name="ln5"> *</a>
<a name="ln6"> * This file is part of Quagga routing suite.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Quagga is free software; you can redistribute it and/or modify it</a>
<a name="ln9"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln10"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln11"> * later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * Quagga is distributed in the hope that it will be useful, but</a>
<a name="ln14"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public License</a>
<a name="ln19"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln20"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln21"> * 02111-1307, USA.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;if.h&quot;</a>
<a name="ln27">#include &quot;vty.h&quot;</a>
<a name="ln28">#include &quot;sockunion.h&quot;</a>
<a name="ln29">#include &quot;prefix.h&quot;</a>
<a name="ln30">#include &quot;stream.h&quot;</a>
<a name="ln31">#include &quot;command.h&quot;</a>
<a name="ln32">#include &quot;memory.h&quot;</a>
<a name="ln33">#include &quot;ioctl.h&quot;</a>
<a name="ln34">#include &quot;connected.h&quot;</a>
<a name="ln35">#include &quot;network.h&quot;</a>
<a name="ln36">#include &quot;log.h&quot;</a>
<a name="ln37">#include &quot;table.h&quot;</a>
<a name="ln38">#include &quot;rib.h&quot;</a>
<a name="ln39">#include &quot;vrf.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln42">#include &quot;zebra/router-id.h&quot;</a>
<a name="ln43">#include &quot;zebra/redistribute.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">/* master zebra server structure */</a>
<a name="ln46">extern struct zebra_t zebrad;</a>
<a name="ln47"> </a>
<a name="ln48">static struct connected *</a>
<a name="ln49">router_id_find_node (struct list *l, struct connected *ifc)</a>
<a name="ln50">{</a>
<a name="ln51">  struct listnode *node;</a>
<a name="ln52">  struct connected *c;</a>
<a name="ln53"> </a>
<a name="ln54">  for (ALL_LIST_ELEMENTS_RO (l, node, c))</a>
<a name="ln55">    if (prefix_same (ifc-&gt;address, c-&gt;address))</a>
<a name="ln56">      return c;</a>
<a name="ln57"> </a>
<a name="ln58">  return NULL;</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">static int</a>
<a name="ln62">router_id_bad_address (struct connected *ifc)</a>
<a name="ln63">{</a>
<a name="ln64">  if (ifc-&gt;address-&gt;family != AF_INET)</a>
<a name="ln65">    return 1;</a>
<a name="ln66">  </a>
<a name="ln67">  /* non-redistributable addresses shouldn't be used for RIDs either */</a>
<a name="ln68">  if (!zebra_check_addr (ifc-&gt;address))</a>
<a name="ln69">    return 1;</a>
<a name="ln70">  </a>
<a name="ln71">  return 0;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">void</a>
<a name="ln75">router_id_get (struct prefix *p, vrf_id_t vrf_id)</a>
<a name="ln76">{</a>
<a name="ln77">  struct listnode *node;</a>
<a name="ln78">  struct connected *c;</a>
<a name="ln79">  struct zebra_vrf *zvrf = vrf_info_get (vrf_id);</a>
<a name="ln80"> </a>
<a name="ln81">  p-&gt;u.prefix4.s_addr = 0;</a>
<a name="ln82">  p-&gt;family = AF_INET;</a>
<a name="ln83">  p-&gt;prefixlen = 32;</a>
<a name="ln84"> </a>
<a name="ln85">  if (zvrf-&gt;rid_user_assigned.u.prefix4.s_addr)</a>
<a name="ln86">    p-&gt;u.prefix4.s_addr = zvrf-&gt;rid_user_assigned.u.prefix4.s_addr;</a>
<a name="ln87">  else if (!list_isempty (zvrf-&gt;rid_lo_sorted_list))</a>
<a name="ln88">    {</a>
<a name="ln89">      node = listtail (zvrf-&gt;rid_lo_sorted_list);</a>
<a name="ln90">      c = listgetdata (node);</a>
<a name="ln91">      p-&gt;u.prefix4.s_addr = c-&gt;address-&gt;u.prefix4.s_addr;</a>
<a name="ln92">    }</a>
<a name="ln93">  else if (!list_isempty (zvrf-&gt;rid_all_sorted_list))</a>
<a name="ln94">    {</a>
<a name="ln95">      node = listtail (zvrf-&gt;rid_all_sorted_list);</a>
<a name="ln96">      c = listgetdata (node);</a>
<a name="ln97">      p-&gt;u.prefix4.s_addr = c-&gt;address-&gt;u.prefix4.s_addr;</a>
<a name="ln98">    }</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">static void</a>
<a name="ln102">router_id_set (struct prefix *p, vrf_id_t vrf_id)</a>
<a name="ln103">{</a>
<a name="ln104">  struct prefix p2;</a>
<a name="ln105">  struct listnode *node;</a>
<a name="ln106">  struct zserv *client;</a>
<a name="ln107">  struct zebra_vrf *zvrf;</a>
<a name="ln108"> </a>
<a name="ln109">  if (p-&gt;u.prefix4.s_addr == 0) /* unset */</a>
<a name="ln110">    {</a>
<a name="ln111">      zvrf = vrf_info_lookup (vrf_id);</a>
<a name="ln112">      if (! zvrf)</a>
<a name="ln113">        return;</a>
<a name="ln114">    }</a>
<a name="ln115">  else /* set */</a>
<a name="ln116">    zvrf = vrf_info_get (vrf_id);</a>
<a name="ln117"> </a>
<a name="ln118">  zvrf-&gt;rid_user_assigned.u.prefix4.s_addr = p-&gt;u.prefix4.s_addr;</a>
<a name="ln119"> </a>
<a name="ln120">  router_id_get (&amp;p2, vrf_id);</a>
<a name="ln121"> </a>
<a name="ln122">  for (ALL_LIST_ELEMENTS_RO (zebrad.client_list, node, client))</a>
<a name="ln123">    zsend_router_id_update (client, &amp;p2, vrf_id);</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">void</a>
<a name="ln127">router_id_add_address (struct connected *ifc)</a>
<a name="ln128">{</a>
<a name="ln129">  struct list *l = NULL;</a>
<a name="ln130">  struct listnode *node;</a>
<a name="ln131">  struct prefix before;</a>
<a name="ln132">  struct prefix after;</a>
<a name="ln133">  struct zserv *client;</a>
<a name="ln134">  struct zebra_vrf *zvrf = vrf_info_get (ifc-&gt;ifp-&gt;vrf_id);</a>
<a name="ln135"> </a>
<a name="ln136">  if (router_id_bad_address (ifc))</a>
<a name="ln137">    return;</a>
<a name="ln138"> </a>
<a name="ln139">  router_id_get (&amp;before, zvrf-&gt;vrf_id);</a>
<a name="ln140"> </a>
<a name="ln141">  if (!strncmp (ifc-&gt;ifp-&gt;name, &quot;lo&quot;, 2)</a>
<a name="ln142">      || !strncmp (ifc-&gt;ifp-&gt;name, &quot;dummy&quot;, 5))</a>
<a name="ln143">    l = zvrf-&gt;rid_lo_sorted_list;</a>
<a name="ln144">  else</a>
<a name="ln145">    l = zvrf-&gt;rid_all_sorted_list;</a>
<a name="ln146">  </a>
<a name="ln147">  if (!router_id_find_node (l, ifc))</a>
<a name="ln148">    listnode_add_sort (l, ifc);</a>
<a name="ln149"> </a>
<a name="ln150">  router_id_get (&amp;after, zvrf-&gt;vrf_id);</a>
<a name="ln151"> </a>
<a name="ln152">  if (prefix_same (&amp;before, &amp;after))</a>
<a name="ln153">    return;</a>
<a name="ln154"> </a>
<a name="ln155">  for (ALL_LIST_ELEMENTS_RO (zebrad.client_list, node, client))</a>
<a name="ln156">    zsend_router_id_update (client, &amp;after, zvrf-&gt;vrf_id);</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">void</a>
<a name="ln160">router_id_del_address (struct connected *ifc)</a>
<a name="ln161">{</a>
<a name="ln162">  struct connected *c;</a>
<a name="ln163">  struct list *l;</a>
<a name="ln164">  struct prefix after;</a>
<a name="ln165">  struct prefix before;</a>
<a name="ln166">  struct listnode *node;</a>
<a name="ln167">  struct zserv *client;</a>
<a name="ln168">  struct zebra_vrf *zvrf = vrf_info_get (ifc-&gt;ifp-&gt;vrf_id);</a>
<a name="ln169"> </a>
<a name="ln170">  if (router_id_bad_address (ifc))</a>
<a name="ln171">    return;</a>
<a name="ln172"> </a>
<a name="ln173">  router_id_get (&amp;before, zvrf-&gt;vrf_id);</a>
<a name="ln174"> </a>
<a name="ln175">  if (!strncmp (ifc-&gt;ifp-&gt;name, &quot;lo&quot;, 2)</a>
<a name="ln176">      || !strncmp (ifc-&gt;ifp-&gt;name, &quot;dummy&quot;, 5))</a>
<a name="ln177">    l = zvrf-&gt;rid_lo_sorted_list;</a>
<a name="ln178">  else</a>
<a name="ln179">    l = zvrf-&gt;rid_all_sorted_list;</a>
<a name="ln180"> </a>
<a name="ln181">  if ((c = router_id_find_node (l, ifc)))</a>
<a name="ln182">    listnode_delete (l, c);</a>
<a name="ln183"> </a>
<a name="ln184">  router_id_get (&amp;after, zvrf-&gt;vrf_id);</a>
<a name="ln185"> </a>
<a name="ln186">  if (prefix_same (&amp;before, &amp;after))</a>
<a name="ln187">    return;</a>
<a name="ln188"> </a>
<a name="ln189">  for (ALL_LIST_ELEMENTS_RO (zebrad.client_list, node, client))</a>
<a name="ln190">    zsend_router_id_update (client, &amp;after, zvrf-&gt;vrf_id);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">void</a>
<a name="ln194">router_id_write (struct vty *vty)</a>
<a name="ln195">{</a>
<a name="ln196">  struct zebra_vrf *zvrf;</a>
<a name="ln197">  vrf_iter_t iter;</a>
<a name="ln198"> </a>
<a name="ln199">  for (iter = vrf_first (); iter != VRF_ITER_INVALID; iter = vrf_next (iter))</a>
<a name="ln200">    if ((zvrf = vrf_iter2info (iter)) != NULL)</a>
<a name="ln201">      if (zvrf-&gt;rid_user_assigned.u.prefix4.s_addr)</a>
<a name="ln202">        {</a>
<a name="ln203">          if (zvrf-&gt;vrf_id == VRF_DEFAULT)</a>
<a name="ln204">            vty_out (vty, &quot;router-id %s%s&quot;,</a>
<a name="ln205">                     inet_ntoa (zvrf-&gt;rid_user_assigned.u.prefix4),</a>
<a name="ln206">                     VTY_NEWLINE);</a>
<a name="ln207">          else</a>
<a name="ln208">            vty_out (vty, &quot;router-id %s vrf %u%s&quot;,</a>
<a name="ln209">                     inet_ntoa (zvrf-&gt;rid_user_assigned.u.prefix4),</a>
<a name="ln210">                     zvrf-&gt;vrf_id,</a>
<a name="ln211">                     VTY_NEWLINE);</a>
<a name="ln212">        }</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">DEFUN (router_id,</a>
<a name="ln216">       router_id_cmd,</a>
<a name="ln217">       &quot;router-id A.B.C.D&quot;,</a>
<a name="ln218">       &quot;Manually set the router-id\n&quot;</a>
<a name="ln219">       &quot;IP address to use for router-id\n&quot;)</a>
<a name="ln220">{</a>
<a name="ln221">  struct prefix rid;</a>
<a name="ln222">  vrf_id_t vrf_id = VRF_DEFAULT;</a>
<a name="ln223"> </a>
<a name="ln224">  rid.u.prefix4.s_addr = inet_addr (argv[0]);</a>
<a name="ln225">  if (!rid.u.prefix4.s_addr)</a>
<a name="ln226">    return CMD_WARNING;</a>
<a name="ln227"> </a>
<a name="ln228">  rid.prefixlen = 32;</a>
<a name="ln229">  rid.family = AF_INET;</a>
<a name="ln230"> </a>
<a name="ln231">  if (argc &gt; 1)</a>
<a name="ln232">    VTY_GET_INTEGER (&quot;VRF ID&quot;, vrf_id, argv[1]);</a>
<a name="ln233"> </a>
<a name="ln234">  router_id_set (&amp;rid, vrf_id);</a>
<a name="ln235"> </a>
<a name="ln236">  return CMD_SUCCESS;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">ALIAS (router_id,</a>
<a name="ln240">       router_id_vrf_cmd,</a>
<a name="ln241">       &quot;router-id A.B.C.D &quot; VRF_CMD_STR,</a>
<a name="ln242">       &quot;Manually set the router-id\n&quot;</a>
<a name="ln243">       &quot;IP address to use for router-id\n&quot;</a>
<a name="ln244">       VRF_CMD_HELP_STR)</a>
<a name="ln245"> </a>
<a name="ln246">DEFUN (no_router_id,</a>
<a name="ln247">       no_router_id_cmd,</a>
<a name="ln248">       &quot;no router-id&quot;,</a>
<a name="ln249">       NO_STR</a>
<a name="ln250">       &quot;Remove the manually configured router-id\n&quot;)</a>
<a name="ln251">{</a>
<a name="ln252">  struct prefix rid;</a>
<a name="ln253">  vrf_id_t vrf_id = VRF_DEFAULT;</a>
<a name="ln254"> </a>
<a name="ln255">  rid.u.prefix4.s_addr = 0;</a>
<a name="ln256">  rid.prefixlen = 0;</a>
<a name="ln257">  rid.family = AF_INET;</a>
<a name="ln258"> </a>
<a name="ln259">  if (argc &gt; 0)</a>
<a name="ln260">    VTY_GET_INTEGER (&quot;VRF ID&quot;, vrf_id, argv[0]);</a>
<a name="ln261"> </a>
<a name="ln262">  router_id_set (&amp;rid, vrf_id);</a>
<a name="ln263"> </a>
<a name="ln264">  return CMD_SUCCESS;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">ALIAS (no_router_id,</a>
<a name="ln268">       no_router_id_vrf_cmd,</a>
<a name="ln269">       &quot;no router-id &quot; VRF_CMD_STR,</a>
<a name="ln270">       NO_STR</a>
<a name="ln271">       &quot;Remove the manually configured router-id\n&quot;</a>
<a name="ln272">       VRF_CMD_HELP_STR)</a>
<a name="ln273"> </a>
<a name="ln274">static int</a>
<a name="ln275">router_id_cmp (void *a, void *b)</a>
<a name="ln276">{</a>
<a name="ln277">  const struct connected *ifa = (const struct connected *)a;</a>
<a name="ln278">  const struct connected *ifb = (const struct connected *)b;</a>
<a name="ln279"> </a>
<a name="ln280">  return IPV4_ADDR_CMP(&amp;ifa-&gt;address-&gt;u.prefix4.s_addr,&amp;ifb-&gt;address-&gt;u.prefix4.s_addr);</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">void</a>
<a name="ln284">router_id_cmd_init (void)</a>
<a name="ln285">{</a>
<a name="ln286">  install_element (CONFIG_NODE, &amp;router_id_cmd);</a>
<a name="ln287">  install_element (CONFIG_NODE, &amp;no_router_id_cmd);</a>
<a name="ln288">  install_element (CONFIG_NODE, &amp;router_id_vrf_cmd);</a>
<a name="ln289">  install_element (CONFIG_NODE, &amp;no_router_id_vrf_cmd);</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">void</a>
<a name="ln293">router_id_init (struct zebra_vrf *zvrf)</a>
<a name="ln294">{</a>
<a name="ln295">  zvrf-&gt;rid_all_sorted_list = &amp;zvrf-&gt;_rid_all_sorted_list;</a>
<a name="ln296">  zvrf-&gt;rid_lo_sorted_list = &amp;zvrf-&gt;_rid_lo_sorted_list;</a>
<a name="ln297"> </a>
<a name="ln298">  memset (zvrf-&gt;rid_all_sorted_list, 0, sizeof (zvrf-&gt;_rid_all_sorted_list));</a>
<a name="ln299">  memset (zvrf-&gt;rid_lo_sorted_list, 0, sizeof (zvrf-&gt;_rid_lo_sorted_list));</a>
<a name="ln300">  memset (&amp;zvrf-&gt;rid_user_assigned, 0, sizeof (zvrf-&gt;rid_user_assigned));</a>
<a name="ln301"> </a>
<a name="ln302">  zvrf-&gt;rid_all_sorted_list-&gt;cmp = router_id_cmp;</a>
<a name="ln303">  zvrf-&gt;rid_lo_sorted_list-&gt;cmp = router_id_cmp;</a>
<a name="ln304"> </a>
<a name="ln305">  zvrf-&gt;rid_user_assigned.family = AF_INET;</a>
<a name="ln306">  zvrf-&gt;rid_user_assigned.prefixlen = 32;</a>
<a name="ln307">}</a>

</code></pre>
<div class="balloon" rel="9"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
