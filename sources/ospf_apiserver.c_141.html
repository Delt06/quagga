
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_apiserver.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Server side of OSPF API.</a>
<a name="ln3"> * Copyright (C) 2001, 2002 Ralph Keller</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> * </a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln8"> * it under the terms of the GNU General Public License as published</a>
<a name="ln9"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln10"> * option) any later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln20"> * Boston, MA 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#ifdef SUPPORT_OSPF_API</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;table.h&quot;</a>
<a name="ln31">#include &quot;memory.h&quot;</a>
<a name="ln32">#include &quot;command.h&quot;</a>
<a name="ln33">#include &quot;vty.h&quot;</a>
<a name="ln34">#include &quot;stream.h&quot;</a>
<a name="ln35">#include &quot;log.h&quot;</a>
<a name="ln36">#include &quot;thread.h&quot;</a>
<a name="ln37">#include &quot;hash.h&quot;</a>
<a name="ln38">#include &quot;sockunion.h&quot;		/* for inet_aton() */</a>
<a name="ln39">#include &quot;buffer.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &lt;sys/types.h&gt;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;ospfd/ospfd.h&quot;        /* for &quot;struct thread_master&quot; */</a>
<a name="ln44">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln48">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln49">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln50">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln51">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln52">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln53">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln54">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln55">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln56">#include &quot;ospfd/ospf_ase.h&quot;</a>
<a name="ln57">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln58"> </a>
<a name="ln59">#include &quot;ospfd/ospf_api.h&quot;</a>
<a name="ln60">#include &quot;ospfd/ospf_apiserver.h&quot;</a>
<a name="ln61"> </a>
<a name="ln62">/* This is an implementation of an API to the OSPF daemon that allows</a>
<a name="ln63"> * external applications to access the OSPF daemon through socket</a>
<a name="ln64"> * connections. The application can use this API to inject its own</a>
<a name="ln65"> * opaque LSAs and flood them to other OSPF daemons. Other OSPF</a>
<a name="ln66"> * daemons then receive these LSAs and inform applications through the</a>
<a name="ln67"> * API by sending a corresponding message. The application can also</a>
<a name="ln68"> * register to receive all LSA types (in addition to opaque types) and</a>
<a name="ln69"> * use this information to reconstruct the OSPF's LSDB. The OSPF</a>
<a name="ln70"> * daemon supports multiple applications concurrently.  */</a>
<a name="ln71"> </a>
<a name="ln72">/* List of all active connections. */</a>
<a name="ln73">struct list *apiserver_list;</a>
<a name="ln74"> </a>
<a name="ln75">/* -----------------------------------------------------------</a>
<a name="ln76"> * Functions to lookup interfaces</a>
<a name="ln77"> * -----------------------------------------------------------</a>
<a name="ln78"> */</a>
<a name="ln79"> </a>
<a name="ln80">struct ospf_interface *</a>
<a name="ln81">ospf_apiserver_if_lookup_by_addr (struct in_addr address)</a>
<a name="ln82">{</a>
<a name="ln83">  struct listnode *node, *nnode;</a>
<a name="ln84">  struct ospf_interface *oi;</a>
<a name="ln85">  struct ospf *ospf;</a>
<a name="ln86"> </a>
<a name="ln87">  if (!(ospf = ospf_lookup ()))</a>
<a name="ln88">    return NULL;</a>
<a name="ln89"> </a>
<a name="ln90">  for (ALL_LIST_ELEMENTS (ospf-&gt;oiflist, node, nnode, oi))</a>
<a name="ln91">    if (oi-&gt;type != OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln92">      if (IPV4_ADDR_SAME (&amp;address, &amp;oi-&gt;address-&gt;u.prefix4))</a>
<a name="ln93">        return oi;</a>
<a name="ln94"> </a>
<a name="ln95">  return NULL;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">struct ospf_interface *</a>
<a name="ln99">ospf_apiserver_if_lookup_by_ifp (struct interface *ifp)</a>
<a name="ln100">{</a>
<a name="ln101">  struct listnode *node, *nnode;</a>
<a name="ln102">  struct ospf_interface *oi;</a>
<a name="ln103">  struct ospf *ospf;</a>
<a name="ln104"> </a>
<a name="ln105">  if (!(ospf = ospf_lookup ()))</a>
<a name="ln106">    return NULL;</a>
<a name="ln107"> </a>
<a name="ln108">  for (ALL_LIST_ELEMENTS (ospf-&gt;oiflist, node, nnode, oi))</a>
<a name="ln109">    if (oi-&gt;ifp == ifp)</a>
<a name="ln110">      return oi;</a>
<a name="ln111"> </a>
<a name="ln112">  return NULL;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">/* -----------------------------------------------------------</a>
<a name="ln116"> * Initialization</a>
<a name="ln117"> * -----------------------------------------------------------</a>
<a name="ln118"> */</a>
<a name="ln119"> </a>
<a name="ln120">unsigned short</a>
<a name="ln121">ospf_apiserver_getport (void)</a>
<a name="ln122">{</a>
<a name="ln123">  struct servent *sp = getservbyname (&quot;ospfapi&quot;, &quot;tcp&quot;);</a>
<a name="ln124"> </a>
<a name="ln125">  return sp ? ntohs (sp-&gt;s_port) : OSPF_API_SYNC_PORT;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">/* Initialize OSPF API module. Invoked from ospf_opaque_init() */</a>
<a name="ln129">int</a>
<a name="ln130">ospf_apiserver_init (void)</a>
<a name="ln131">{</a>
<a name="ln132">  int fd;</a>
<a name="ln133">  int rc = -1;</a>
<a name="ln134"> </a>
<a name="ln135">  /* Create new socket for synchronous messages. */</a>
<a name="ln136">  fd = ospf_apiserver_serv_sock_family (ospf_apiserver_getport (), AF_INET);</a>
<a name="ln137"> </a>
<a name="ln138">  if (fd &lt; 0)</a>
<a name="ln139">    goto out;</a>
<a name="ln140"> </a>
<a name="ln141">  /* Schedule new thread that handles accepted connections. */</a>
<a name="ln142">  ospf_apiserver_event (OSPF_APISERVER_ACCEPT, fd, NULL);</a>
<a name="ln143"> </a>
<a name="ln144">  /* Initialize list that keeps track of all connections. */</a>
<a name="ln145">  apiserver_list = list_new ();</a>
<a name="ln146"> </a>
<a name="ln147">  /* Register opaque-independent call back functions. These functions</a>
<a name="ln148">     are invoked on ISM, NSM changes and LSA update and LSA deletes */</a>
<a name="ln149">  rc =</a>
<a name="ln150">    ospf_register_opaque_functab (0 /* all LSAs */, </a>
<a name="ln151">				  0 /* all opaque types */,</a>
<a name="ln152">				  ospf_apiserver_new_if,</a>
<a name="ln153">				  ospf_apiserver_del_if,</a>
<a name="ln154">				  ospf_apiserver_ism_change,</a>
<a name="ln155">				  ospf_apiserver_nsm_change,</a>
<a name="ln156">				  NULL,</a>
<a name="ln157">				  NULL,</a>
<a name="ln158">				  NULL,</a>
<a name="ln159">				  NULL, /* ospf_apiserver_show_info */</a>
<a name="ln160">				  NULL, /* originator_func */</a>
<a name="ln161">				  NULL, /* ospf_apiserver_lsa_refresher */</a>
<a name="ln162">				  ospf_apiserver_lsa_update,</a>
<a name="ln163">				  ospf_apiserver_lsa_delete);</a>
<a name="ln164">  if (rc != 0)</a>
<a name="ln165">    {</a>
<a name="ln166">      zlog_warn (&quot;ospf_apiserver_init: Failed to register opaque type [0/0]&quot;);</a>
<a name="ln167">    }</a>
<a name="ln168"> </a>
<a name="ln169">  rc = 0;</a>
<a name="ln170"> </a>
<a name="ln171">out:</a>
<a name="ln172">  return rc;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">/* Terminate OSPF API module. */</a>
<a name="ln176">void</a>
<a name="ln177">ospf_apiserver_term (void)</a>
<a name="ln178">{</a>
<a name="ln179">  struct ospf_apiserver *apiserv;</a>
<a name="ln180"> </a>
<a name="ln181">  /* Unregister wildcard [0/0] type */</a>
<a name="ln182">  ospf_delete_opaque_functab (0 /* all LSAs */, </a>
<a name="ln183">			      0 /* all opaque types */);</a>
<a name="ln184"> </a>
<a name="ln185">  /*</a>
<a name="ln186">   * Free all client instances.  ospf_apiserver_free removes the node</a>
<a name="ln187">   * from the list, so we examine the head of the list anew each time.</a>
<a name="ln188">   */</a>
<a name="ln189">  while ( apiserver_list &amp;&amp;</a>
<a name="ln190">         (apiserv = listgetdata (listhead (apiserver_list))) != NULL)</a>
<a name="ln191">    ospf_apiserver_free (apiserv);</a>
<a name="ln192"> </a>
<a name="ln193">  /* Free client list itself */</a>
<a name="ln194">  if (apiserver_list)</a>
<a name="ln195">    list_delete (apiserver_list);</a>
<a name="ln196"> </a>
<a name="ln197">  /* Free wildcard list */</a>
<a name="ln198">  /* XXX  */</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">static struct ospf_apiserver *</a>
<a name="ln202">lookup_apiserver (u_char lsa_type, u_char opaque_type)</a>
<a name="ln203">{</a>
<a name="ln204">  struct listnode *n1, *n2;</a>
<a name="ln205">  struct registered_opaque_type *r;</a>
<a name="ln206">  struct ospf_apiserver *apiserv, *found = NULL;</a>
<a name="ln207"> </a>
<a name="ln208">  /* XXX: this approaches O(n**2) */</a>
<a name="ln209">  for (ALL_LIST_ELEMENTS_RO (apiserver_list, n1, apiserv))</a>
<a name="ln210">    {</a>
<a name="ln211">      for (ALL_LIST_ELEMENTS_RO (apiserv-&gt;opaque_types, n2, r))</a>
<a name="ln212">        if (r-&gt;lsa_type == lsa_type &amp;&amp; r-&gt;opaque_type == opaque_type)</a>
<a name="ln213">          {</a>
<a name="ln214">            found = apiserv;</a>
<a name="ln215">            goto out;</a>
<a name="ln216">          }</a>
<a name="ln217">    }</a>
<a name="ln218">out:</a>
<a name="ln219">  return found;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">static struct ospf_apiserver *</a>
<a name="ln223">lookup_apiserver_by_lsa (struct ospf_lsa *lsa)</a>
<a name="ln224">{</a>
<a name="ln225">  struct lsa_header *lsah = lsa-&gt;data;</a>
<a name="ln226">  struct ospf_apiserver *found = NULL;</a>
<a name="ln227"> </a>
<a name="ln228">  if (IS_OPAQUE_LSA (lsah-&gt;type))</a>
<a name="ln229">    {</a>
<a name="ln230">      found = lookup_apiserver (lsah-&gt;type,</a>
<a name="ln231">                                GET_OPAQUE_TYPE (ntohl (lsah-&gt;id.s_addr)));</a>
<a name="ln232">    }</a>
<a name="ln233">  return found;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">/* -----------------------------------------------------------</a>
<a name="ln237"> * Followings are functions to manage client connections.</a>
<a name="ln238"> * -----------------------------------------------------------</a>
<a name="ln239"> */</a>
<a name="ln240">static int</a>
<a name="ln241">ospf_apiserver_new_lsa_hook (struct ospf_lsa *lsa)</a>
<a name="ln242">{</a>
<a name="ln243">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln244">    zlog_debug (&quot;API: Put LSA(%p)[%s] into reserve, total=%ld&quot;, (void *)lsa,</a>
<a name="ln245">                dump_lsa_key (lsa), lsa-&gt;lsdb-&gt;total);</a>
<a name="ln246">  return 0;</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">static int</a>
<a name="ln250">ospf_apiserver_del_lsa_hook (struct ospf_lsa *lsa)</a>
<a name="ln251">{</a>
<a name="ln252">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln253">    zlog_debug (&quot;API: Get LSA(%p)[%s] from reserve, total=%ld&quot;, (void *)lsa,</a>
<a name="ln254">                dump_lsa_key (lsa), lsa-&gt;lsdb-&gt;total);</a>
<a name="ln255">  return 0;</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">/* Allocate new connection structure. */</a>
<a name="ln259">struct ospf_apiserver *</a>
<a name="ln260">ospf_apiserver_new (int fd_sync, int fd_async)</a>
<a name="ln261">{</a>
<a name="ln262">  struct ospf_apiserver *new =</a>
<a name="ln263">    XMALLOC (MTYPE_OSPF_APISERVER, sizeof (struct ospf_apiserver));</a>
<a name="ln264"> </a>
<a name="ln265">  new-&gt;filter =</a>
<a name="ln266">    XMALLOC (MTYPE_OSPF_APISERVER_MSGFILTER, sizeof (struct lsa_filter_type));</a>
<a name="ln267"> </a>
<a name="ln268">  new-&gt;fd_sync = fd_sync;</a>
<a name="ln269">  new-&gt;fd_async = fd_async;</a>
<a name="ln270"> </a>
<a name="ln271">  /* list of registered opaque types that application uses */</a>
<a name="ln272">  new-&gt;opaque_types = list_new ();</a>
<a name="ln273"> </a>
<a name="ln274">  /* Initialize temporary strage for LSA instances to be refreshed. */</a>
<a name="ln275">  memset (&amp;new-&gt;reserve, 0, sizeof (struct ospf_lsdb));</a>
<a name="ln276">  ospf_lsdb_init (&amp;new-&gt;reserve);</a>
<a name="ln277"> </a>
<a name="ln278">  new-&gt;reserve.new_lsa_hook = ospf_apiserver_new_lsa_hook; /* debug */</a>
<a name="ln279">  new-&gt;reserve.del_lsa_hook = ospf_apiserver_del_lsa_hook; /* debug */</a>
<a name="ln280"> </a>
<a name="ln281">  new-&gt;out_sync_fifo = msg_fifo_new ();</a>
<a name="ln282">  new-&gt;out_async_fifo = msg_fifo_new ();</a>
<a name="ln283">  new-&gt;t_sync_read = NULL;</a>
<a name="ln284">#ifdef USE_ASYNC_READ</a>
<a name="ln285">  new-&gt;t_async_read = NULL;</a>
<a name="ln286">#endif /* USE_ASYNC_READ */</a>
<a name="ln287">  new-&gt;t_sync_write = NULL;</a>
<a name="ln288">  new-&gt;t_async_write = NULL;</a>
<a name="ln289"> </a>
<a name="ln290">  new-&gt;filter-&gt;typemask = 0;	/* filter all LSAs */</a>
<a name="ln291">  new-&gt;filter-&gt;origin = ANY_ORIGIN;</a>
<a name="ln292">  new-&gt;filter-&gt;num_areas = 0;</a>
<a name="ln293"> </a>
<a name="ln294">  return new;</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">void</a>
<a name="ln298">ospf_apiserver_event (enum event event, int fd,</a>
<a name="ln299">		      struct ospf_apiserver *apiserv)</a>
<a name="ln300">{</a>
<a name="ln301">  switch (event)</a>
<a name="ln302">    {</a>
<a name="ln303">    case OSPF_APISERVER_ACCEPT:</a>
<a name="ln304">      (void)thread_add_read (master, ospf_apiserver_accept, apiserv, fd);</a>
<a name="ln305">      break;</a>
<a name="ln306">    case OSPF_APISERVER_SYNC_READ:</a>
<a name="ln307">      apiserv-&gt;t_sync_read =</a>
<a name="ln308">	thread_add_read (master, ospf_apiserver_read, apiserv, fd);</a>
<a name="ln309">      break;</a>
<a name="ln310">#ifdef USE_ASYNC_READ</a>
<a name="ln311">    case OSPF_APISERVER_ASYNC_READ:</a>
<a name="ln312">      apiserv-&gt;t_async_read =</a>
<a name="ln313">	thread_add_read (master, ospf_apiserver_read, apiserv, fd);</a>
<a name="ln314">      break;</a>
<a name="ln315">#endif /* USE_ASYNC_READ */</a>
<a name="ln316">    case OSPF_APISERVER_SYNC_WRITE:</a>
<a name="ln317">      if (!apiserv-&gt;t_sync_write)</a>
<a name="ln318">	{</a>
<a name="ln319">	  apiserv-&gt;t_sync_write =</a>
<a name="ln320">	    thread_add_write (master, ospf_apiserver_sync_write, apiserv, fd);</a>
<a name="ln321">	}</a>
<a name="ln322">      break;</a>
<a name="ln323">    case OSPF_APISERVER_ASYNC_WRITE:</a>
<a name="ln324">      if (!apiserv-&gt;t_async_write)</a>
<a name="ln325">	{</a>
<a name="ln326">	  apiserv-&gt;t_async_write =</a>
<a name="ln327">	    thread_add_write (master, ospf_apiserver_async_write, apiserv, fd);</a>
<a name="ln328">	}</a>
<a name="ln329">      break;</a>
<a name="ln330">    }</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">/* Free instance. First unregister all opaque types used by</a>
<a name="ln334">   application, flush opaque LSAs injected by application </a>
<a name="ln335">   from network and close connection. */</a>
<a name="ln336">void</a>
<a name="ln337">ospf_apiserver_free (struct ospf_apiserver *apiserv)</a>
<a name="ln338">{</a>
<a name="ln339">  struct listnode *node;</a>
<a name="ln340"> </a>
<a name="ln341">  /* Cancel read and write threads. */</a>
<a name="ln342">  if (apiserv-&gt;t_sync_read)</a>
<a name="ln343">    {</a>
<a name="ln344">      thread_cancel (apiserv-&gt;t_sync_read);</a>
<a name="ln345">    }</a>
<a name="ln346">#ifdef USE_ASYNC_READ</a>
<a name="ln347">  if (apiserv-&gt;t_async_read)</a>
<a name="ln348">    {</a>
<a name="ln349">      thread_cancel (apiserv-&gt;t_async_read);</a>
<a name="ln350">    }</a>
<a name="ln351">#endif /* USE_ASYNC_READ */</a>
<a name="ln352">  if (apiserv-&gt;t_sync_write)</a>
<a name="ln353">    {</a>
<a name="ln354">      thread_cancel (apiserv-&gt;t_sync_write);</a>
<a name="ln355">    }</a>
<a name="ln356"> </a>
<a name="ln357">  if (apiserv-&gt;t_async_write)</a>
<a name="ln358">    {</a>
<a name="ln359">      thread_cancel (apiserv-&gt;t_async_write);</a>
<a name="ln360">    }</a>
<a name="ln361"> </a>
<a name="ln362">  /* Unregister all opaque types that application registered </a>
<a name="ln363">     and flush opaque LSAs if still in LSDB. */</a>
<a name="ln364"> </a>
<a name="ln365">  while ((node = listhead (apiserv-&gt;opaque_types)) != NULL)</a>
<a name="ln366">    {</a>
<a name="ln367">      struct registered_opaque_type *regtype = listgetdata(node);</a>
<a name="ln368"> </a>
<a name="ln369">      ospf_apiserver_unregister_opaque_type (apiserv, regtype-&gt;lsa_type,</a>
<a name="ln370">					     regtype-&gt;opaque_type);</a>
<a name="ln371"> </a>
<a name="ln372">    }</a>
<a name="ln373"> </a>
<a name="ln374">  /* Close connections to OSPFd. */</a>
<a name="ln375">  if (apiserv-&gt;fd_sync &gt; 0)</a>
<a name="ln376">    {</a>
<a name="ln377">      close (apiserv-&gt;fd_sync);</a>
<a name="ln378">    }</a>
<a name="ln379"> </a>
<a name="ln380">  if (apiserv-&gt;fd_async &gt; 0)</a>
<a name="ln381">    {</a>
<a name="ln382">      close (apiserv-&gt;fd_async);</a>
<a name="ln383">    }</a>
<a name="ln384"> </a>
<a name="ln385">  /* Free fifos */</a>
<a name="ln386">  msg_fifo_free (apiserv-&gt;out_sync_fifo);</a>
<a name="ln387">  msg_fifo_free (apiserv-&gt;out_async_fifo);</a>
<a name="ln388"> </a>
<a name="ln389">  /* Clear temporary strage for LSA instances to be refreshed. */</a>
<a name="ln390">  ospf_lsdb_delete_all (&amp;apiserv-&gt;reserve);</a>
<a name="ln391">  ospf_lsdb_cleanup (&amp;apiserv-&gt;reserve);</a>
<a name="ln392"> </a>
<a name="ln393">  /* Remove from the list of active clients. */</a>
<a name="ln394">  listnode_delete (apiserver_list, apiserv);</a>
<a name="ln395"> </a>
<a name="ln396">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln397">    zlog_debug (&quot;API: Delete apiserv(%p), total#(%d)&quot;,</a>
<a name="ln398">                (void *)apiserv, apiserver_list-&gt;count);</a>
<a name="ln399"> </a>
<a name="ln400">  /* And free instance. */</a>
<a name="ln401">  XFREE (MTYPE_OSPF_APISERVER, apiserv);</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">int</a>
<a name="ln405">ospf_apiserver_read (struct thread *thread)</a>
<a name="ln406">{</a>
<a name="ln407">  struct ospf_apiserver *apiserv;</a>
<a name="ln408">  struct msg *msg;</a>
<a name="ln409">  int fd;</a>
<a name="ln410">  int rc = -1;</a>
<a name="ln411">  enum event event;</a>
<a name="ln412"> </a>
<a name="ln413">  apiserv = THREAD_ARG (thread);</a>
<a name="ln414">  fd = THREAD_FD (thread);</a>
<a name="ln415"> </a>
<a name="ln416">  if (fd == apiserv-&gt;fd_sync)</a>
<a name="ln417">    {</a>
<a name="ln418">      event = OSPF_APISERVER_SYNC_READ;</a>
<a name="ln419">      apiserv-&gt;t_sync_read = NULL;</a>
<a name="ln420"> </a>
<a name="ln421">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln422">        zlog_debug (&quot;API: ospf_apiserver_read: Peer: %s/%u&quot;,</a>
<a name="ln423">                    inet_ntoa (apiserv-&gt;peer_sync.sin_addr),</a>
<a name="ln424">                    ntohs (apiserv-&gt;peer_sync.sin_port));</a>
<a name="ln425">    }</a>
<a name="ln426">#ifdef USE_ASYNC_READ</a>
<a name="ln427">  else if (fd == apiserv-&gt;fd_async)</a>
<a name="ln428">    {</a>
<a name="ln429">      event = OSPF_APISERVER_ASYNC_READ;</a>
<a name="ln430">      apiserv-&gt;t_async_read = NULL;</a>
<a name="ln431"> </a>
<a name="ln432">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln433">        zlog_debug (&quot;API: ospf_apiserver_read: Peer: %s/%u&quot;,</a>
<a name="ln434">                    inet_ntoa (apiserv-&gt;peer_async.sin_addr),</a>
<a name="ln435">                    ntohs (apiserv-&gt;peer_async.sin_port));</a>
<a name="ln436">    }</a>
<a name="ln437">#endif /* USE_ASYNC_READ */</a>
<a name="ln438">  else</a>
<a name="ln439">    {</a>
<a name="ln440">      zlog_warn (&quot;ospf_apiserver_read: Unknown fd(%d)&quot;, fd);</a>
<a name="ln441">      ospf_apiserver_free (apiserv);</a>
<a name="ln442">      goto out;</a>
<a name="ln443">    }</a>
<a name="ln444"> </a>
<a name="ln445">  /* Read message from fd. */</a>
<a name="ln446">  msg = msg_read (fd);</a>
<a name="ln447">  if (msg == NULL)</a>
<a name="ln448">    {</a>
<a name="ln449">      zlog_warn</a>
<a name="ln450">	(&quot;ospf_apiserver_read: read failed on fd=%d, closing connection&quot;, fd);</a>
<a name="ln451"> </a>
<a name="ln452">      /* Perform cleanup. */</a>
<a name="ln453">      ospf_apiserver_free (apiserv);</a>
<a name="ln454">      goto out;</a>
<a name="ln455">    }</a>
<a name="ln456"> </a>
<a name="ln457">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln458">    msg_print (msg);</a>
<a name="ln459"> </a>
<a name="ln460">  /* Dispatch to corresponding message handler. */</a>
<a name="ln461">  rc = ospf_apiserver_handle_msg (apiserv, msg);</a>
<a name="ln462"> </a>
<a name="ln463">  /* Prepare for next message, add read thread. */</a>
<a name="ln464">  ospf_apiserver_event (event, fd, apiserv);</a>
<a name="ln465"> </a>
<a name="ln466">  msg_free (msg);</a>
<a name="ln467"> </a>
<a name="ln468">out:</a>
<a name="ln469">  return rc;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">int</a>
<a name="ln473">ospf_apiserver_sync_write (struct thread *thread)</a>
<a name="ln474">{</a>
<a name="ln475">  struct ospf_apiserver *apiserv;</a>
<a name="ln476">  struct msg *msg;</a>
<a name="ln477">  int fd;</a>
<a name="ln478">  int rc = -1;</a>
<a name="ln479"> </a>
<a name="ln480">  apiserv = THREAD_ARG (thread);</a>
<a name="ln481">  assert (apiserv);</a>
<a name="ln482">  fd = THREAD_FD (thread);</a>
<a name="ln483"> </a>
<a name="ln484">  apiserv-&gt;t_sync_write = NULL;</a>
<a name="ln485"> </a>
<a name="ln486">  /* Sanity check */</a>
<a name="ln487">  if (fd != apiserv-&gt;fd_sync)</a>
<a name="ln488">    {</a>
<a name="ln489">      zlog_warn (&quot;ospf_apiserver_sync_write: Unknown fd=%d&quot;, fd);</a>
<a name="ln490">      goto out;</a>
<a name="ln491">    }</a>
<a name="ln492"> </a>
<a name="ln493">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln494">    zlog_debug (&quot;API: ospf_apiserver_sync_write: Peer: %s/%u&quot;,</a>
<a name="ln495">                inet_ntoa (apiserv-&gt;peer_sync.sin_addr),</a>
<a name="ln496">                ntohs (apiserv-&gt;peer_sync.sin_port));</a>
<a name="ln497"> </a>
<a name="ln498">  /* Check whether there is really a message in the fifo. */</a>
<a name="ln499">  msg = msg_fifo_pop (apiserv-&gt;out_sync_fifo);</a>
<a name="ln500">  if (!msg)</a>
<a name="ln501">    {</a>
<a name="ln502">      zlog_warn (&quot;API: ospf_apiserver_sync_write: No message in Sync-FIFO?&quot;);</a>
<a name="ln503">      return 0;</a>
<a name="ln504">    }</a>
<a name="ln505"> </a>
<a name="ln506">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln507">    msg_print (msg);</a>
<a name="ln508"> </a>
<a name="ln509">  rc = msg_write (fd, msg);</a>
<a name="ln510"> </a>
<a name="ln511">  /* Once a message is dequeued, it should be freed anyway. */</a>
<a name="ln512">  msg_free (msg);</a>
<a name="ln513"> </a>
<a name="ln514">  if (rc &lt; 0)</a>
<a name="ln515">    {</a>
<a name="ln516">      zlog_warn</a>
<a name="ln517">        (&quot;ospf_apiserver_sync_write: write failed on fd=%d&quot;, fd);</a>
<a name="ln518">      goto out;</a>
<a name="ln519">    }</a>
<a name="ln520"> </a>
<a name="ln521"> </a>
<a name="ln522">  /* If more messages are in sync message fifo, schedule write thread. */</a>
<a name="ln523">  if (msg_fifo_head (apiserv-&gt;out_sync_fifo))</a>
<a name="ln524">    {</a>
<a name="ln525">      ospf_apiserver_event (OSPF_APISERVER_SYNC_WRITE, apiserv-&gt;fd_sync,</a>
<a name="ln526">                            apiserv);</a>
<a name="ln527">    }</a>
<a name="ln528">  </a>
<a name="ln529"> out:</a>
<a name="ln530"> </a>
<a name="ln531">  if (rc &lt; 0)</a>
<a name="ln532">  {</a>
<a name="ln533">      /* Perform cleanup and disconnect with peer */</a>
<a name="ln534">      ospf_apiserver_free (apiserv);</a>
<a name="ln535">    }</a>
<a name="ln536"> </a>
<a name="ln537">  return rc;</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540"> </a>
<a name="ln541">int</a>
<a name="ln542">ospf_apiserver_async_write (struct thread *thread)</a>
<a name="ln543">{</a>
<a name="ln544">  struct ospf_apiserver *apiserv;</a>
<a name="ln545">  struct msg *msg;</a>
<a name="ln546">  int fd;</a>
<a name="ln547">  int rc = -1;</a>
<a name="ln548"> </a>
<a name="ln549">  apiserv = THREAD_ARG (thread);</a>
<a name="ln550">  assert (apiserv);</a>
<a name="ln551">  fd = THREAD_FD (thread);</a>
<a name="ln552"> </a>
<a name="ln553">  apiserv-&gt;t_async_write = NULL;</a>
<a name="ln554"> </a>
<a name="ln555">  /* Sanity check */</a>
<a name="ln556">  if (fd != apiserv-&gt;fd_async)</a>
<a name="ln557">    {</a>
<a name="ln558">      zlog_warn (&quot;ospf_apiserver_async_write: Unknown fd=%d&quot;, fd);</a>
<a name="ln559">      goto out;</a>
<a name="ln560">    }</a>
<a name="ln561"> </a>
<a name="ln562">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln563">    zlog_debug (&quot;API: ospf_apiserver_async_write: Peer: %s/%u&quot;,</a>
<a name="ln564">                inet_ntoa (apiserv-&gt;peer_async.sin_addr),</a>
<a name="ln565">                ntohs (apiserv-&gt;peer_async.sin_port));</a>
<a name="ln566"> </a>
<a name="ln567">  /* Check whether there is really a message in the fifo. */</a>
<a name="ln568">  msg = msg_fifo_pop (apiserv-&gt;out_async_fifo);</a>
<a name="ln569">  if (!msg)</a>
<a name="ln570">    {</a>
<a name="ln571">      zlog_warn (&quot;API: ospf_apiserver_async_write: No message in Async-FIFO?&quot;);</a>
<a name="ln572">      return 0;</a>
<a name="ln573">    }</a>
<a name="ln574"> </a>
<a name="ln575">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln576">    msg_print (msg);</a>
<a name="ln577"> </a>
<a name="ln578">  rc = msg_write (fd, msg);</a>
<a name="ln579"> </a>
<a name="ln580">  /* Once a message is dequeued, it should be freed anyway. */</a>
<a name="ln581">  msg_free (msg);</a>
<a name="ln582"> </a>
<a name="ln583">  if (rc &lt; 0)</a>
<a name="ln584">    {</a>
<a name="ln585">      zlog_warn</a>
<a name="ln586">        (&quot;ospf_apiserver_async_write: write failed on fd=%d&quot;, fd);</a>
<a name="ln587">      goto out;</a>
<a name="ln588">    }</a>
<a name="ln589"> </a>
<a name="ln590"> </a>
<a name="ln591">  /* If more messages are in async message fifo, schedule write thread. */</a>
<a name="ln592">  if (msg_fifo_head (apiserv-&gt;out_async_fifo))</a>
<a name="ln593">    {</a>
<a name="ln594">      ospf_apiserver_event (OSPF_APISERVER_ASYNC_WRITE, apiserv-&gt;fd_async,</a>
<a name="ln595">                            apiserv);</a>
<a name="ln596">    }</a>
<a name="ln597"> </a>
<a name="ln598"> out:</a>
<a name="ln599"> </a>
<a name="ln600">  if (rc &lt; 0)</a>
<a name="ln601">    {</a>
<a name="ln602">      /* Perform cleanup and disconnect with peer */</a>
<a name="ln603">      ospf_apiserver_free (apiserv);</a>
<a name="ln604">    }</a>
<a name="ln605"> </a>
<a name="ln606">  return rc;</a>
<a name="ln607">}</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">int</a>
<a name="ln611">ospf_apiserver_serv_sock_family (unsigned short port, int family)</a>
<a name="ln612">{</a>
<a name="ln613">  union sockunion su;</a>
<a name="ln614">  int accept_sock;</a>
<a name="ln615">  int rc;</a>
<a name="ln616"> </a>
<a name="ln617">  memset (&amp;su, 0, sizeof (union sockunion));</a>
<a name="ln618">  su.sa.sa_family = family;</a>
<a name="ln619"> </a>
<a name="ln620">  /* Make new socket */</a>
<a name="ln621">  accept_sock = sockunion_stream_socket (&amp;su);</a>
<a name="ln622">  if (accept_sock &lt; 0)</a>
<a name="ln623">    return accept_sock;</a>
<a name="ln624"> </a>
<a name="ln625">  /* This is a server, so reuse address and port */</a>
<a name="ln626">  sockopt_reuseaddr (accept_sock);</a>
<a name="ln627">  sockopt_reuseport (accept_sock);</a>
<a name="ln628"> </a>
<a name="ln629">  /* Bind socket to address and given port. */</a>
<a name="ln630">  rc = sockunion_bind (accept_sock, &amp;su, port, NULL);</a>
<a name="ln631">  if (rc &lt; 0)</a>
<a name="ln632">    {</a>
<a name="ln633">      close (accept_sock);	/* Close socket */</a>
<a name="ln634">      return rc;</a>
<a name="ln635">    }</a>
<a name="ln636"> </a>
<a name="ln637">  /* Listen socket under queue length 3. */</a>
<a name="ln638">  rc = listen (accept_sock, 3);</a>
<a name="ln639">  if (rc &lt; 0)</a>
<a name="ln640">    {</a>
<a name="ln641">      zlog_warn (&quot;ospf_apiserver_serv_sock_family: listen: %s&quot;,</a>
<a name="ln642">                 safe_strerror (errno));</a>
<a name="ln643">      close (accept_sock);	/* Close socket */</a>
<a name="ln644">      return rc;</a>
<a name="ln645">    }</a>
<a name="ln646">  return accept_sock;</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649"> </a>
<a name="ln650">/* Accept connection request from external applications. For each</a>
<a name="ln651">   accepted connection allocate own connection instance. */</a>
<a name="ln652">int</a>
<a name="ln653">ospf_apiserver_accept (struct thread *thread)</a>
<a name="ln654">{</a>
<a name="ln655">  int accept_sock;</a>
<a name="ln656">  int new_sync_sock;</a>
<a name="ln657">  int new_async_sock;</a>
<a name="ln658">  union sockunion su;</a>
<a name="ln659">  struct ospf_apiserver *apiserv;</a>
<a name="ln660">  struct sockaddr_in peer_async;</a>
<a name="ln661">  struct sockaddr_in peer_sync;</a>
<a name="ln662">  unsigned int peerlen;</a>
<a name="ln663">  int ret;</a>
<a name="ln664"> </a>
<a name="ln665">  /* THREAD_ARG (thread) is NULL */</a>
<a name="ln666">  accept_sock = THREAD_FD (thread);</a>
<a name="ln667"> </a>
<a name="ln668">  /* Keep hearing on socket for further connections. */</a>
<a name="ln669">  ospf_apiserver_event (OSPF_APISERVER_ACCEPT, accept_sock, NULL);</a>
<a name="ln670"> </a>
<a name="ln671">  memset (&amp;su, 0, sizeof (union sockunion));</a>
<a name="ln672">  /* Accept connection for synchronous messages */</a>
<a name="ln673">  new_sync_sock = sockunion_accept (accept_sock, &amp;su);</a>
<a name="ln674">  if (new_sync_sock &lt; 0)</a>
<a name="ln675">    {</a>
<a name="ln676">      zlog_warn (&quot;ospf_apiserver_accept: accept: %s&quot;, safe_strerror (errno));</a>
<a name="ln677">      return -1;</a>
<a name="ln678">    }</a>
<a name="ln679"> </a>
<a name="ln680">  /* Get port address and port number of peer to make reverse connection.</a>
<a name="ln681">     The reverse channel uses the port number of the peer port+1. */</a>
<a name="ln682"> </a>
<a name="ln683">  memset(&amp;peer_sync, 0, sizeof(struct sockaddr_in));</a>
<a name="ln684">  peerlen = sizeof (struct sockaddr_in);</a>
<a name="ln685"> </a>
<a name="ln686">  ret = getpeername (new_sync_sock, (struct sockaddr *)&amp;peer_sync, &amp;peerlen);</a>
<a name="ln687">  if (ret &lt; 0)</a>
<a name="ln688">    {</a>
<a name="ln689">      zlog_warn (&quot;ospf_apiserver_accept: getpeername: %s&quot;, safe_strerror (errno));</a>
<a name="ln690">      close (new_sync_sock);</a>
<a name="ln691">      return -1;</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln695">    zlog_debug (&quot;API: ospf_apiserver_accept: New peer: %s/%u&quot;,</a>
<a name="ln696">               inet_ntoa (peer_sync.sin_addr), ntohs (peer_sync.sin_port));</a>
<a name="ln697"> </a>
<a name="ln698">  /* Create new socket for asynchronous messages. */</a>
<a name="ln699">  peer_async = peer_sync;</a>
<a name="ln700">  peer_async.sin_port = htons(ntohs(peer_sync.sin_port) + 1);</a>
<a name="ln701"> </a>
<a name="ln702">  /* Check if remote port number to make reverse connection is valid one. */</a>
<a name="ln703">  if (ntohs (peer_async.sin_port) == ospf_apiserver_getport ())</a>
<a name="ln704">    {</a>
<a name="ln705">      zlog_warn (&quot;API: ospf_apiserver_accept: Peer(%s/%u): Invalid async port number?&quot;,</a>
<a name="ln706">               inet_ntoa (peer_async.sin_addr), ntohs (peer_async.sin_port));</a>
<a name="ln707">      close (new_sync_sock);</a>
<a name="ln708">      return -1;</a>
<a name="ln709">    }</a>
<a name="ln710"> </a>
<a name="ln711">  new_async_sock = socket (AF_INET, SOCK_STREAM, 0);</a>
<a name="ln712">  if (new_async_sock &lt; 0)</a>
<a name="ln713">    {</a>
<a name="ln714">      zlog_warn (&quot;ospf_apiserver_accept: socket: %s&quot;, safe_strerror (errno));</a>
<a name="ln715">      close (new_sync_sock);</a>
<a name="ln716">      return -1;</a>
<a name="ln717">    }</a>
<a name="ln718"> </a>
<a name="ln719">  ret = connect (new_async_sock, (struct sockaddr *) &amp;peer_async,</a>
<a name="ln720">		 sizeof (struct sockaddr_in));</a>
<a name="ln721"> </a>
<a name="ln722">  if (ret &lt; 0)</a>
<a name="ln723">    {</a>
<a name="ln724">      zlog_warn (&quot;ospf_apiserver_accept: connect: %s&quot;, safe_strerror (errno));</a>
<a name="ln725">      close (new_sync_sock);</a>
<a name="ln726">      close (new_async_sock);</a>
<a name="ln727">      return -1;</a>
<a name="ln728">    }</a>
<a name="ln729"> </a>
<a name="ln730">#ifdef USE_ASYNC_READ</a>
<a name="ln731">#else /* USE_ASYNC_READ */</a>
<a name="ln732">  /* Make the asynchronous channel write-only. */</a>
<a name="ln733">  ret = shutdown (new_async_sock, SHUT_RD);</a>
<a name="ln734">  if (ret &lt; 0)</a>
<a name="ln735">    {</a>
<a name="ln736">      zlog_warn (&quot;ospf_apiserver_accept: shutdown: %s&quot;, safe_strerror (errno));</a>
<a name="ln737">      close (new_sync_sock);</a>
<a name="ln738">      close (new_async_sock);</a>
<a name="ln739">      return -1;</a>
<a name="ln740">    }</a>
<a name="ln741">#endif /* USE_ASYNC_READ */</a>
<a name="ln742"> </a>
<a name="ln743">  /* Allocate new server-side connection structure */</a>
<a name="ln744">  apiserv = ospf_apiserver_new (new_sync_sock, new_async_sock);</a>
<a name="ln745"> </a>
<a name="ln746">  /* Add to active connection list */</a>
<a name="ln747">  listnode_add (apiserver_list, apiserv);</a>
<a name="ln748">  apiserv-&gt;peer_sync = peer_sync;</a>
<a name="ln749">  apiserv-&gt;peer_async = peer_async;</a>
<a name="ln750"> </a>
<a name="ln751">  /* And add read threads for new connection */</a>
<a name="ln752">  ospf_apiserver_event (OSPF_APISERVER_SYNC_READ, new_sync_sock, apiserv);</a>
<a name="ln753">#ifdef USE_ASYNC_READ</a>
<a name="ln754">  ospf_apiserver_event (OSPF_APISERVER_ASYNC_READ, new_async_sock, apiserv);</a>
<a name="ln755">#endif /* USE_ASYNC_READ */</a>
<a name="ln756"> </a>
<a name="ln757">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln758">    zlog_debug (&quot;API: New apiserv(%p), total#(%d)&quot;,</a>
<a name="ln759">                (void *)apiserv, apiserver_list-&gt;count);</a>
<a name="ln760"> </a>
<a name="ln761">  return 0;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764"> </a>
<a name="ln765">/* -----------------------------------------------------------</a>
<a name="ln766"> * Send reply with return code to client application</a>
<a name="ln767"> * -----------------------------------------------------------</a>
<a name="ln768"> */</a>
<a name="ln769"> </a>
<a name="ln770">static int</a>
<a name="ln771">ospf_apiserver_send_msg (struct ospf_apiserver *apiserv, struct msg *msg)</a>
<a name="ln772">{</a>
<a name="ln773">  struct msg_fifo *fifo;</a>
<a name="ln774">  struct msg *msg2;</a>
<a name="ln775">  enum event event;</a>
<a name="ln776">  int fd;</a>
<a name="ln777"> </a>
<a name="ln778">  switch (msg-&gt;hdr.msgtype)</a>
<a name="ln779">    {</a>
<a name="ln780">    case MSG_REPLY:</a>
<a name="ln781">      fifo = apiserv-&gt;out_sync_fifo;</a>
<a name="ln782">      fd = apiserv-&gt;fd_sync;</a>
<a name="ln783">      event = OSPF_APISERVER_SYNC_WRITE;</a>
<a name="ln784">      break;</a>
<a name="ln785">    case MSG_READY_NOTIFY:</a>
<a name="ln786">    case MSG_LSA_UPDATE_NOTIFY:</a>
<a name="ln787">    case MSG_LSA_DELETE_NOTIFY:</a>
<a name="ln788">    case MSG_NEW_IF:</a>
<a name="ln789">    case MSG_DEL_IF:</a>
<a name="ln790">    case MSG_ISM_CHANGE:</a>
<a name="ln791">    case MSG_NSM_CHANGE:</a>
<a name="ln792">      fifo = apiserv-&gt;out_async_fifo;</a>
<a name="ln793">      fd = apiserv-&gt;fd_async;</a>
<a name="ln794">      event = OSPF_APISERVER_ASYNC_WRITE;</a>
<a name="ln795">      break;</a>
<a name="ln796">    default:</a>
<a name="ln797">      zlog_warn (&quot;ospf_apiserver_send_msg: Unknown message type %d&quot;,</a>
<a name="ln798">		 msg-&gt;hdr.msgtype);</a>
<a name="ln799">      return -1;</a>
<a name="ln800">    }</a>
<a name="ln801"> </a>
<a name="ln802">  /* Make a copy of the message and put in the fifo. Once the fifo</a>
<a name="ln803">     gets drained by the write thread, the message will be freed. */</a>
<a name="ln804">  /* NB: Given &quot;msg&quot; is untouched in this function. */</a>
<a name="ln805">  msg2 = msg_dup (msg);</a>
<a name="ln806"> </a>
<a name="ln807">  /* Enqueue message into corresponding fifo queue */</a>
<a name="ln808">  msg_fifo_push (fifo, msg2);</a>
<a name="ln809"> </a>
<a name="ln810">  /* Schedule write thread */</a>
<a name="ln811">  ospf_apiserver_event (event, fd, apiserv);</a>
<a name="ln812">  return 0;</a>
<a name="ln813">}</a>
<a name="ln814"> </a>
<a name="ln815">int</a>
<a name="ln816">ospf_apiserver_send_reply (struct ospf_apiserver *apiserv, u_int32_t seqnr,</a>
<a name="ln817">			   u_char rc)</a>
<a name="ln818">{</a>
<a name="ln819">  struct msg *msg = new_msg_reply (seqnr, rc);</a>
<a name="ln820">  int ret;</a>
<a name="ln821"> </a>
<a name="ln822">  if (!msg)</a>
<a name="ln823">    {</a>
<a name="ln824">      zlog_warn (&quot;ospf_apiserver_send_reply: msg_new failed&quot;);</a>
<a name="ln825">#ifdef NOTYET</a>
<a name="ln826">      /* Cannot allocate new message. What should we do? */</a>
<a name="ln827">      ospf_apiserver_free (apiserv);</a>
<a name="ln828">#endif</a>
<a name="ln829">      return -1;</a>
<a name="ln830">    }</a>
<a name="ln831"> </a>
<a name="ln832">  ret = ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln833">  msg_free (msg);</a>
<a name="ln834">  return ret;</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837"> </a>
<a name="ln838">/* -----------------------------------------------------------</a>
<a name="ln839"> * Generic message dispatching handler function</a>
<a name="ln840"> * -----------------------------------------------------------</a>
<a name="ln841"> */</a>
<a name="ln842"> </a>
<a name="ln843">int</a>
<a name="ln844">ospf_apiserver_handle_msg (struct ospf_apiserver *apiserv, struct msg *msg)</a>
<a name="ln845">{</a>
<a name="ln846">  int rc;</a>
<a name="ln847"> </a>
<a name="ln848">  /* Call corresponding message handler function. */</a>
<a name="ln849">  switch (msg-&gt;hdr.msgtype)</a>
<a name="ln850">    {</a>
<a name="ln851">    case MSG_REGISTER_OPAQUETYPE:</a>
<a name="ln852">      rc = ospf_apiserver_handle_register_opaque_type (apiserv, msg);</a>
<a name="ln853">      break;</a>
<a name="ln854">    case MSG_UNREGISTER_OPAQUETYPE:</a>
<a name="ln855">      rc = ospf_apiserver_handle_unregister_opaque_type (apiserv, msg);</a>
<a name="ln856">      break;</a>
<a name="ln857">    case MSG_REGISTER_EVENT:</a>
<a name="ln858">      rc = ospf_apiserver_handle_register_event (apiserv, msg);</a>
<a name="ln859">      break;</a>
<a name="ln860">    case MSG_SYNC_LSDB:</a>
<a name="ln861">      rc = ospf_apiserver_handle_sync_lsdb (apiserv, msg);</a>
<a name="ln862">      break;</a>
<a name="ln863">    case MSG_ORIGINATE_REQUEST:</a>
<a name="ln864">      rc = ospf_apiserver_handle_originate_request (apiserv, msg);</a>
<a name="ln865">      break;</a>
<a name="ln866">    case MSG_DELETE_REQUEST:</a>
<a name="ln867">      rc = ospf_apiserver_handle_delete_request (apiserv, msg);</a>
<a name="ln868">      break;</a>
<a name="ln869">    default:</a>
<a name="ln870">      zlog_warn (&quot;ospf_apiserver_handle_msg: Unknown message type: %d&quot;,</a>
<a name="ln871">		 msg-&gt;hdr.msgtype);</a>
<a name="ln872">      rc = -1;</a>
<a name="ln873">    }</a>
<a name="ln874">  return rc;</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877"> </a>
<a name="ln878">/* -----------------------------------------------------------</a>
<a name="ln879"> * Following are functions for opaque type registration</a>
<a name="ln880"> * -----------------------------------------------------------</a>
<a name="ln881"> */</a>
<a name="ln882"> </a>
<a name="ln883">int</a>
<a name="ln884">ospf_apiserver_register_opaque_type (struct ospf_apiserver *apiserv,</a>
<a name="ln885">				     u_char lsa_type, u_char opaque_type)</a>
<a name="ln886">{</a>
<a name="ln887">  struct registered_opaque_type *regtype;</a>
<a name="ln888">  int (*originator_func) (void *arg);</a>
<a name="ln889">  int rc;</a>
<a name="ln890"> </a>
<a name="ln891">  switch (lsa_type)</a>
<a name="ln892">    {</a>
<a name="ln893">    case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln894">      originator_func = ospf_apiserver_lsa9_originator;</a>
<a name="ln895">      break;</a>
<a name="ln896">    case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln897">      originator_func = ospf_apiserver_lsa10_originator;</a>
<a name="ln898">      break;</a>
<a name="ln899">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln900">      originator_func = ospf_apiserver_lsa11_originator;</a>
<a name="ln901">      break;</a>
<a name="ln902">    default:</a>
<a name="ln903">      zlog_warn (&quot;ospf_apiserver_register_opaque_type: lsa_type(%d)&quot;,</a>
<a name="ln904">		 lsa_type);</a>
<a name="ln905">      return OSPF_API_ILLEGALLSATYPE;</a>
<a name="ln906">    }</a>
<a name="ln907">  </a>
<a name="ln908"> </a>
<a name="ln909">  /* Register opaque function table */</a>
<a name="ln910">  /* NB: Duplicated registration will be detected inside the function. */</a>
<a name="ln911">  rc =</a>
<a name="ln912">    ospf_register_opaque_functab (lsa_type, opaque_type,</a>
<a name="ln913">				  NULL, /* ospf_apiserver_new_if */</a>
<a name="ln914">				  NULL, /* ospf_apiserver_del_if */</a>
<a name="ln915">				  NULL, /* ospf_apiserver_ism_change */</a>
<a name="ln916">				  NULL, /* ospf_apiserver_nsm_change */</a>
<a name="ln917">				  NULL,</a>
<a name="ln918">				  NULL,</a>
<a name="ln919">				  NULL,</a>
<a name="ln920">				  ospf_apiserver_show_info,</a>
<a name="ln921">				  originator_func,</a>
<a name="ln922">				  ospf_apiserver_lsa_refresher,</a>
<a name="ln923">				  NULL, /* ospf_apiserver_lsa_update */</a>
<a name="ln924">				  NULL /* ospf_apiserver_lsa_delete */);</a>
<a name="ln925"> </a>
<a name="ln926">  if (rc != 0)</a>
<a name="ln927">    {</a>
<a name="ln928">      zlog_warn (&quot;Failed to register opaque type [%d/%d]&quot;,</a>
<a name="ln929">		 lsa_type, opaque_type);</a>
<a name="ln930">      return OSPF_API_OPAQUETYPEINUSE;</a>
<a name="ln931">    }</a>
<a name="ln932"> </a>
<a name="ln933">  /* Remember the opaque type that application registers so when</a>
<a name="ln934">     connection shuts down, we can flush all LSAs of this opaque</a>
<a name="ln935">     type. */</a>
<a name="ln936"> </a>
<a name="ln937">  regtype =</a>
<a name="ln938">    XCALLOC (MTYPE_OSPF_APISERVER, sizeof (struct registered_opaque_type));</a>
<a name="ln939">  regtype-&gt;lsa_type = lsa_type;</a>
<a name="ln940">  regtype-&gt;opaque_type = opaque_type;</a>
<a name="ln941"> </a>
<a name="ln942">  /* Add to list of registered opaque types */</a>
<a name="ln943">  listnode_add (apiserv-&gt;opaque_types, regtype);</a>
<a name="ln944"> </a>
<a name="ln945">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln946">    zlog_debug (&quot;API: Add LSA-type(%d)/Opaque-type(%d) into&quot;</a>
<a name="ln947">               &quot; apiserv(%p), total#(%d)&quot;, </a>
<a name="ln948">               lsa_type, opaque_type, (void *)apiserv, </a>
<a name="ln949">               listcount (apiserv-&gt;opaque_types));</a>
<a name="ln950"> </a>
<a name="ln951">  return 0;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">int</a>
<a name="ln955">ospf_apiserver_unregister_opaque_type (struct ospf_apiserver *apiserv,</a>
<a name="ln956">				       u_char lsa_type, u_char opaque_type)</a>
<a name="ln957">{</a>
<a name="ln958">  struct listnode *node, *nnode;</a>
<a name="ln959">  struct registered_opaque_type *regtype;</a>
<a name="ln960"> </a>
<a name="ln961">  for (ALL_LIST_ELEMENTS (apiserv-&gt;opaque_types, node, nnode, regtype))</a>
<a name="ln962">    {</a>
<a name="ln963">      /* Check if we really registered this opaque type */</a>
<a name="ln964">      if (regtype-&gt;lsa_type == lsa_type &amp;&amp;</a>
<a name="ln965">	  regtype-&gt;opaque_type == opaque_type)</a>
<a name="ln966">	{</a>
<a name="ln967"> </a>
<a name="ln968">	  /* Yes, we registered this opaque type. Flush</a>
<a name="ln969">	     all existing opaque LSAs of this type */</a>
<a name="ln970"> </a>
<a name="ln971">	  ospf_apiserver_flush_opaque_lsa (apiserv, lsa_type, opaque_type);</a>
<a name="ln972">	  ospf_delete_opaque_functab (lsa_type, opaque_type);</a>
<a name="ln973"> </a>
<a name="ln974">	  /* Remove from list of registered opaque types */</a>
<a name="ln975">	  listnode_delete (apiserv-&gt;opaque_types, regtype);</a>
<a name="ln976"> </a>
<a name="ln977">          if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln978">            zlog_debug (&quot;API: Del LSA-type(%d)/Opaque-type(%d)&quot;</a>
<a name="ln979">                       &quot; from apiserv(%p), total#(%d)&quot;, </a>
<a name="ln980">                       lsa_type, opaque_type, (void *)apiserv,</a>
<a name="ln981">                       listcount (apiserv-&gt;opaque_types));</a>
<a name="ln982"> </a>
<a name="ln983">	  return 0;</a>
<a name="ln984">	}</a>
<a name="ln985">    }</a>
<a name="ln986"> </a>
<a name="ln987">  /* Opaque type is not registered */</a>
<a name="ln988">  zlog_warn (&quot;Failed to unregister opaque type [%d/%d]&quot;,</a>
<a name="ln989">	     lsa_type, opaque_type);</a>
<a name="ln990">  return OSPF_API_OPAQUETYPENOTREGISTERED;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">static int</a>
<a name="ln995">apiserver_is_opaque_type_registered (struct ospf_apiserver *apiserv,</a>
<a name="ln996">				     u_char lsa_type, u_char opaque_type)</a>
<a name="ln997">{</a>
<a name="ln998">  struct listnode *node, *nnode;</a>
<a name="ln999">  struct registered_opaque_type *regtype;</a>
<a name="ln1000"> </a>
<a name="ln1001">  /* XXX: how many types are there? if few, why not just a bitmap? */</a>
<a name="ln1002">  for (ALL_LIST_ELEMENTS (apiserv-&gt;opaque_types, node, nnode, regtype))</a>
<a name="ln1003">    {</a>
<a name="ln1004">      /* Check if we really registered this opaque type */</a>
<a name="ln1005">      if (regtype-&gt;lsa_type == lsa_type &amp;&amp;</a>
<a name="ln1006">	  regtype-&gt;opaque_type == opaque_type)</a>
<a name="ln1007">	{</a>
<a name="ln1008">	  /* Yes registered */</a>
<a name="ln1009">	  return 1;</a>
<a name="ln1010">	}</a>
<a name="ln1011">    }</a>
<a name="ln1012">  /* Not registered */</a>
<a name="ln1013">  return 0;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">int</a>
<a name="ln1017">ospf_apiserver_handle_register_opaque_type (struct ospf_apiserver *apiserv,</a>
<a name="ln1018">					    struct msg *msg)</a>
<a name="ln1019">{</a>
<a name="ln1020">  struct msg_register_opaque_type *rmsg;</a>
<a name="ln1021">  u_char lsa_type;</a>
<a name="ln1022">  u_char opaque_type;</a>
<a name="ln1023">  int rc = 0;</a>
<a name="ln1024"> </a>
<a name="ln1025">  /* Extract parameters from register opaque type message */</a>
<a name="ln1026">  rmsg = (struct msg_register_opaque_type *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln1027"> </a>
<a name="ln1028">  lsa_type = rmsg-&gt;lsatype;</a>
<a name="ln1029">  opaque_type = rmsg-&gt;opaquetype;</a>
<a name="ln1030"> </a>
<a name="ln1031">  rc = ospf_apiserver_register_opaque_type (apiserv, lsa_type, opaque_type);</a>
<a name="ln1032"> </a>
<a name="ln1033">  /* Send a reply back to client including return code */</a>
<a name="ln1034">  rc = ospf_apiserver_send_reply (apiserv, ntohl (msg-&gt;hdr.msgseq), rc);</a>
<a name="ln1035">  if (rc &lt; 0)</a>
<a name="ln1036">    goto out;</a>
<a name="ln1037"> </a>
<a name="ln1038">  /* Now inform application about opaque types that are ready */</a>
<a name="ln1039">  switch (lsa_type)</a>
<a name="ln1040">    {</a>
<a name="ln1041">    case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln1042">      ospf_apiserver_notify_ready_type9 (apiserv);</a>
<a name="ln1043">      break;</a>
<a name="ln1044">    case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln1045">      ospf_apiserver_notify_ready_type10 (apiserv);</a>
<a name="ln1046">      break;</a>
<a name="ln1047">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln1048">      ospf_apiserver_notify_ready_type11 (apiserv);</a>
<a name="ln1049">      break;</a>
<a name="ln1050">    }</a>
<a name="ln1051">out:</a>
<a name="ln1052">  return rc;</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055"> </a>
<a name="ln1056">/* Notify specific client about all opaque types 9 that are ready. */</a>
<a name="ln1057">void</a>
<a name="ln1058">ospf_apiserver_notify_ready_type9 (struct ospf_apiserver *apiserv)</a>
<a name="ln1059">{</a>
<a name="ln1060">  struct listnode *node, *nnode;</a>
<a name="ln1061">  struct listnode *node2, *nnode2;</a>
<a name="ln1062">  struct ospf *ospf;</a>
<a name="ln1063">  struct ospf_interface *oi;</a>
<a name="ln1064">  struct registered_opaque_type *r;</a>
<a name="ln1065"> </a>
<a name="ln1066">  ospf = ospf_lookup ();</a>
<a name="ln1067"> </a>
<a name="ln1068">  for (ALL_LIST_ELEMENTS (ospf-&gt;oiflist, node, nnode, oi))</a>
<a name="ln1069">    {</a>
<a name="ln1070">      /* Check if this interface is indeed ready for type 9 */</a>
<a name="ln1071">      if (!ospf_apiserver_is_ready_type9 (oi))</a>
<a name="ln1072">	continue;</a>
<a name="ln1073"> </a>
<a name="ln1074">      /* Check for registered opaque type 9 types */</a>
<a name="ln1075">      /* XXX: loop-de-loop - optimise me */</a>
<a name="ln1076">      for (ALL_LIST_ELEMENTS (apiserv-&gt;opaque_types, node2, nnode2, r))</a>
<a name="ln1077">	{</a>
<a name="ln1078">	  struct msg *msg;</a>
<a name="ln1079"> </a>
<a name="ln1080">	  if (r-&gt;lsa_type == OSPF_OPAQUE_LINK_LSA)</a>
<a name="ln1081">	    {</a>
<a name="ln1082"> </a>
<a name="ln1083">	      /* Yes, this opaque type is ready */</a>
<a name="ln1084">	      msg = new_msg_ready_notify (0, OSPF_OPAQUE_LINK_LSA,</a>
<a name="ln1085">					  r-&gt;opaque_type,</a>
<a name="ln1086">					  oi-&gt;address-&gt;u.prefix4);</a>
<a name="ln1087">	      if (!msg)</a>
<a name="ln1088">		{</a>
<a name="ln1089">		  zlog_warn (&quot;apiserver_notify_ready_type9: msg_new failed&quot;);</a>
<a name="ln1090">#ifdef NOTYET</a>
<a name="ln1091">		  /* Cannot allocate new message. What should we do? */</a>
<a name="ln1092">		  ospf_apiserver_free (apiserv);</a>
<a name="ln1093">#endif</a>
<a name="ln1094">		  goto out;</a>
<a name="ln1095">		}</a>
<a name="ln1096">	      ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln1097">	      msg_free (msg);</a>
<a name="ln1098">	    }</a>
<a name="ln1099">	}</a>
<a name="ln1100">    }</a>
<a name="ln1101"> </a>
<a name="ln1102">out:</a>
<a name="ln1103">  return;</a>
<a name="ln1104">}</a>
<a name="ln1105"> </a>
<a name="ln1106"> </a>
<a name="ln1107">/* Notify specific client about all opaque types 10 that are ready. */</a>
<a name="ln1108">void</a>
<a name="ln1109">ospf_apiserver_notify_ready_type10 (struct ospf_apiserver *apiserv)</a>
<a name="ln1110">{</a>
<a name="ln1111">  struct listnode *node, *nnode;</a>
<a name="ln1112">  struct listnode *node2, *nnode2;</a>
<a name="ln1113">  struct ospf *ospf;</a>
<a name="ln1114">  struct ospf_area *area;</a>
<a name="ln1115">  </a>
<a name="ln1116">  ospf = ospf_lookup ();</a>
<a name="ln1117"> </a>
<a name="ln1118">  for (ALL_LIST_ELEMENTS (ospf-&gt;areas, node, nnode, area))</a>
<a name="ln1119">    {</a>
<a name="ln1120">      struct registered_opaque_type *r;</a>
<a name="ln1121">      </a>
<a name="ln1122">      if (!ospf_apiserver_is_ready_type10 (area))</a>
<a name="ln1123">	{</a>
<a name="ln1124">	  continue;</a>
<a name="ln1125">	}</a>
<a name="ln1126"> </a>
<a name="ln1127">      /* Check for registered opaque type 10 types */</a>
<a name="ln1128">      /* XXX: loop in loop - optimise me */</a>
<a name="ln1129">      for (ALL_LIST_ELEMENTS (apiserv-&gt;opaque_types, node2, nnode2, r))</a>
<a name="ln1130">	{</a>
<a name="ln1131">	  struct msg *msg;</a>
<a name="ln1132">	  </a>
<a name="ln1133">	  if (r-&gt;lsa_type == OSPF_OPAQUE_AREA_LSA)</a>
<a name="ln1134">	    {</a>
<a name="ln1135">	      /* Yes, this opaque type is ready */</a>
<a name="ln1136">	      msg =</a>
<a name="ln1137">		new_msg_ready_notify (0, OSPF_OPAQUE_AREA_LSA,</a>
<a name="ln1138">				      r-&gt;opaque_type, area-&gt;area_id);</a>
<a name="ln1139">	      if (!msg)</a>
<a name="ln1140">		{</a>
<a name="ln1141">		  zlog_warn (&quot;apiserver_notify_ready_type10: msg_new failed&quot;);</a>
<a name="ln1142">#ifdef NOTYET</a>
<a name="ln1143">		  /* Cannot allocate new message. What should we do? */</a>
<a name="ln1144">		  ospf_apiserver_free (apiserv);</a>
<a name="ln1145">#endif</a>
<a name="ln1146">		  goto out;</a>
<a name="ln1147">		}</a>
<a name="ln1148">	      ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln1149">	      msg_free (msg);</a>
<a name="ln1150">	    }</a>
<a name="ln1151">	}</a>
<a name="ln1152">    }</a>
<a name="ln1153"> </a>
<a name="ln1154">out:</a>
<a name="ln1155">  return;</a>
<a name="ln1156">}</a>
<a name="ln1157"> </a>
<a name="ln1158">/* Notify specific client about all opaque types 11 that are ready */</a>
<a name="ln1159">void</a>
<a name="ln1160">ospf_apiserver_notify_ready_type11 (struct ospf_apiserver *apiserv)</a>
<a name="ln1161">{</a>
<a name="ln1162">  struct listnode *node, *nnode;</a>
<a name="ln1163">  struct ospf *ospf;</a>
<a name="ln1164">  struct registered_opaque_type *r;</a>
<a name="ln1165"> </a>
<a name="ln1166">  ospf = ospf_lookup ();</a>
<a name="ln1167"> </a>
<a name="ln1168">  /* Can type 11 be originated? */</a>
<a name="ln1169">  if (!ospf_apiserver_is_ready_type11 (ospf))</a>
<a name="ln1170">    goto out;</a>
<a name="ln1171"> </a>
<a name="ln1172">  /* Check for registered opaque type 11 types */</a>
<a name="ln1173">  for (ALL_LIST_ELEMENTS (apiserv-&gt;opaque_types, node, nnode, r))</a>
<a name="ln1174">    {</a>
<a name="ln1175">      struct msg *msg;</a>
<a name="ln1176">      struct in_addr noarea_id = { .s_addr = 0L };</a>
<a name="ln1177">      </a>
<a name="ln1178">      if (r-&gt;lsa_type == OSPF_OPAQUE_AS_LSA)</a>
<a name="ln1179">	{</a>
<a name="ln1180">	  /* Yes, this opaque type is ready */</a>
<a name="ln1181">	  msg = new_msg_ready_notify (0, OSPF_OPAQUE_AS_LSA,</a>
<a name="ln1182">				      r-&gt;opaque_type, noarea_id);</a>
<a name="ln1183"> </a>
<a name="ln1184">	  if (!msg)</a>
<a name="ln1185">	    {</a>
<a name="ln1186">	      zlog_warn (&quot;apiserver_notify_ready_type11: msg_new failed&quot;);</a>
<a name="ln1187">#ifdef NOTYET</a>
<a name="ln1188">	      /* Cannot allocate new message. What should we do? */</a>
<a name="ln1189">	      ospf_apiserver_free (apiserv);</a>
<a name="ln1190">#endif</a>
<a name="ln1191">	      goto out;</a>
<a name="ln1192">	    }</a>
<a name="ln1193">	  ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln1194">	  msg_free (msg);</a>
<a name="ln1195">	}</a>
<a name="ln1196">    }</a>
<a name="ln1197"> </a>
<a name="ln1198">out:</a>
<a name="ln1199">  return;</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202">int</a>
<a name="ln1203">ospf_apiserver_handle_unregister_opaque_type (struct ospf_apiserver *apiserv,</a>
<a name="ln1204">					      struct msg *msg)</a>
<a name="ln1205">{</a>
<a name="ln1206">  struct msg_unregister_opaque_type *umsg;</a>
<a name="ln1207">  u_char ltype;</a>
<a name="ln1208">  u_char otype;</a>
<a name="ln1209">  int rc = 0;</a>
<a name="ln1210"> </a>
<a name="ln1211">  /* Extract parameters from unregister opaque type message */</a>
<a name="ln1212">  umsg = (struct msg_unregister_opaque_type *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln1213"> </a>
<a name="ln1214">  ltype = umsg-&gt;lsatype;</a>
<a name="ln1215">  otype = umsg-&gt;opaquetype;</a>
<a name="ln1216"> </a>
<a name="ln1217">  rc = ospf_apiserver_unregister_opaque_type (apiserv, ltype, otype);</a>
<a name="ln1218"> </a>
<a name="ln1219">  /* Send a reply back to client including return code */</a>
<a name="ln1220">  rc = ospf_apiserver_send_reply (apiserv, ntohl (msg-&gt;hdr.msgseq), rc);</a>
<a name="ln1221"> </a>
<a name="ln1222">  return rc;</a>
<a name="ln1223">}</a>
<a name="ln1224"> </a>
<a name="ln1225"> </a>
<a name="ln1226">/* -----------------------------------------------------------</a>
<a name="ln1227"> * Following are functions for event (filter) registration.</a>
<a name="ln1228"> * -----------------------------------------------------------</a>
<a name="ln1229"> */</a>
<a name="ln1230">int</a>
<a name="ln1231">ospf_apiserver_handle_register_event (struct ospf_apiserver *apiserv,</a>
<a name="ln1232">				      struct msg *msg)</a>
<a name="ln1233">{</a>
<a name="ln1234">  struct msg_register_event *rmsg;</a>
<a name="ln1235">  int rc;</a>
<a name="ln1236">  u_int32_t seqnum;</a>
<a name="ln1237"> </a>
<a name="ln1238">  rmsg = (struct msg_register_event *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln1239"> </a>
<a name="ln1240">  /* Get request sequence number */</a>
<a name="ln1241">  seqnum = msg_get_seq (msg);</a>
<a name="ln1242"> </a>
<a name="ln1243">  /* Free existing filter in apiserv. */</a>
<a name="ln1244">  XFREE (MTYPE_OSPF_APISERVER_MSGFILTER, apiserv-&gt;filter);</a>
<a name="ln1245">  /* Alloc new space for filter. */</a>
<a name="ln1246"> </a>
<a name="ln1247">  apiserv-&gt;filter = XMALLOC (MTYPE_OSPF_APISERVER_MSGFILTER,</a>
<a name="ln1248">			     ntohs (msg-&gt;hdr.msglen));</a>
<a name="ln1249">  if (apiserv-&gt;filter)</a>
<a name="ln1250">    {</a>
<a name="ln1251">      /* copy it over. */</a>
<a name="ln1252">      memcpy (apiserv-&gt;filter, &amp;rmsg-&gt;filter, ntohs (msg-&gt;hdr.msglen));</a>
<a name="ln1253">      rc = OSPF_API_OK;</a>
<a name="ln1254">    }</a>
<a name="ln1255">  else</a>
<a name="ln1256">    {</a>
<a name="ln1257">      rc = OSPF_API_NOMEMORY;</a>
<a name="ln1258">    }</a>
<a name="ln1259">  /* Send a reply back to client with return code */</a>
<a name="ln1260">  rc = ospf_apiserver_send_reply (apiserv, seqnum, rc);</a>
<a name="ln1261">  return rc;</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264"> </a>
<a name="ln1265">/* -----------------------------------------------------------</a>
<a name="ln1266"> * Followings are functions for LSDB synchronization.</a>
<a name="ln1267"> * -----------------------------------------------------------</a>
<a name="ln1268"> */</a>
<a name="ln1269"> </a>
<a name="ln1270">static int</a>
<a name="ln1271">apiserver_sync_callback (struct ospf_lsa *lsa, void *p_arg, int int_arg)</a>
<a name="ln1272">{</a>
<a name="ln1273">  struct ospf_apiserver *apiserv;</a>
<a name="ln1274">  int seqnum;</a>
<a name="ln1275">  struct msg *msg;</a>
<a name="ln1276">  struct param_t</a>
<a name="ln1277">  {</a>
<a name="ln1278">    struct ospf_apiserver *apiserv;</a>
<a name="ln1279">    struct lsa_filter_type *filter;</a>
<a name="ln1280">  }</a>
<a name="ln1281">   *param;</a>
<a name="ln1282">  int rc = -1;</a>
<a name="ln1283"> </a>
<a name="ln1284">  /* Sanity check */</a>
<a name="ln1285">  assert (lsa-&gt;data);</a>
<a name="ln1286">  assert (p_arg);</a>
<a name="ln1287"> </a>
<a name="ln1288">  param = (struct param_t *) p_arg;</a>
<a name="ln1289">  apiserv = param-&gt;apiserv;</a>
<a name="ln1290">  seqnum = (u_int32_t) int_arg;</a>
<a name="ln1291"> </a>
<a name="ln1292">  /* Check origin in filter. */</a>
<a name="ln1293">  if ((param-&gt;filter-&gt;origin == ANY_ORIGIN) ||</a>
<a name="ln1294">      (param-&gt;filter-&gt;origin == (lsa-&gt;flags &amp; OSPF_LSA_SELF)))</a>
<a name="ln1295">    {</a>
<a name="ln1296"> </a>
<a name="ln1297">      /* Default area for AS-External and Opaque11 LSAs */</a>
<a name="ln1298">      struct in_addr area_id = { .s_addr = 0L };</a>
<a name="ln1299"> </a>
<a name="ln1300">      /* Default interface for non Opaque9 LSAs */</a>
<a name="ln1301">      struct in_addr ifaddr = { .s_addr = 0L };</a>
<a name="ln1302">      </a>
<a name="ln1303">      if (lsa-&gt;area)</a>
<a name="ln1304">	{</a>
<a name="ln1305">	  area_id = lsa-&gt;area-&gt;area_id;</a>
<a name="ln1306">	}</a>
<a name="ln1307">      if (lsa-&gt;data-&gt;type == OSPF_OPAQUE_LINK_LSA)</a>
<a name="ln1308">	{</a>
<a name="ln1309">	  ifaddr = lsa-&gt;oi-&gt;address-&gt;u.prefix4;</a>
<a name="ln1310">	}</a>
<a name="ln1311"> </a>
<a name="ln1312">      msg = new_msg_lsa_change_notify (MSG_LSA_UPDATE_NOTIFY,</a>
<a name="ln1313">				       seqnum,</a>
<a name="ln1314">				       ifaddr, area_id,</a>
<a name="ln1315">				       lsa-&gt;flags &amp; OSPF_LSA_SELF, lsa-&gt;data);</a>
<a name="ln1316">      if (!msg)</a>
<a name="ln1317">	{</a>
<a name="ln1318">	  zlog_warn (&quot;apiserver_sync_callback: new_msg_update failed&quot;);</a>
<a name="ln1319">#ifdef NOTYET</a>
<a name="ln1320">	  /* Cannot allocate new message. What should we do? */</a>
<a name="ln1321">/*        ospf_apiserver_free (apiserv);*//* Do nothing here XXX */</a>
<a name="ln1322">#endif</a>
<a name="ln1323">	  goto out;</a>
<a name="ln1324">	}</a>
<a name="ln1325"> </a>
<a name="ln1326">      /* Send LSA */</a>
<a name="ln1327">      ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln1328">      msg_free (msg);</a>
<a name="ln1329">    }</a>
<a name="ln1330">  rc = 0;</a>
<a name="ln1331"> </a>
<a name="ln1332">out:</a>
<a name="ln1333">  return rc;</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">int</a>
<a name="ln1337">ospf_apiserver_handle_sync_lsdb (struct ospf_apiserver *apiserv,</a>
<a name="ln1338">				 struct msg *msg)</a>
<a name="ln1339">{</a>
<a name="ln1340">  struct listnode *node, *nnode;</a>
<a name="ln1341">  u_int32_t seqnum;</a>
<a name="ln1342">  int rc = 0;</a>
<a name="ln1343">  struct msg_sync_lsdb *smsg;</a>
<a name="ln1344">  struct ospf_apiserver_param_t</a>
<a name="ln1345">  {</a>
<a name="ln1346">    struct ospf_apiserver *apiserv;</a>
<a name="ln1347">    struct lsa_filter_type *filter;</a>
<a name="ln1348">  } param;</a>
<a name="ln1349">  u_int16_t mask;</a>
<a name="ln1350">  struct route_node *rn;</a>
<a name="ln1351">  struct ospf_lsa *lsa;</a>
<a name="ln1352">  struct ospf *ospf;</a>
<a name="ln1353">  struct ospf_area *area;</a>
<a name="ln1354"> </a>
<a name="ln1355">  ospf = ospf_lookup ();</a>
<a name="ln1356"> </a>
<a name="ln1357">  /* Get request sequence number */</a>
<a name="ln1358">  seqnum = msg_get_seq (msg);</a>
<a name="ln1359">  /* Set sync msg. */</a>
<a name="ln1360">  smsg = (struct msg_sync_lsdb *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln1361"> </a>
<a name="ln1362">  /* Set parameter struct. */</a>
<a name="ln1363">  param.apiserv = apiserv;</a>
<a name="ln1364">  param.filter = &amp;smsg-&gt;filter;</a>
<a name="ln1365"> </a>
<a name="ln1366">  /* Remember mask. */</a>
<a name="ln1367">  mask = ntohs (smsg-&gt;filter.typemask);</a>
<a name="ln1368"> </a>
<a name="ln1369">  /* Iterate over all areas. */</a>
<a name="ln1370">  for (ALL_LIST_ELEMENTS (ospf-&gt;areas, node, nnode, area))</a>
<a name="ln1371">    {</a>
<a name="ln1372">      int i;</a>
<a name="ln1373">      u_int32_t *area_id = NULL;</a>
<a name="ln1374"> </a>
<a name="ln1375">      /* Compare area_id with area_ids in sync request. */</a>
<a name="ln1376">      if ((i = smsg-&gt;filter.num_areas) &gt; 0)</a>
<a name="ln1377">	{</a>
<a name="ln1378">	  /* Let area_id point to the list of area IDs,</a>
<a name="ln1379">	   * which is at the end of smsg-&gt;filter. */</a>
<a name="ln1380">	  area_id = (u_int32_t *) (&amp;smsg-&gt;filter + 1);</a>
<a name="ln1381">	  while (i)</a>
<a name="ln1382">	    {</a>
<a name="ln1383">	      if (*area_id == area-&gt;area_id.s_addr)</a>
<a name="ln1384">		{</a>
<a name="ln1385">		  break;</a>
<a name="ln1386">		}</a>
<a name="ln1387">	      i--;</a>
<a name="ln1388">	      area_id++;</a>
<a name="ln1389">	    }</a>
<a name="ln1390">	}</a>
<a name="ln1391">      else</a>
<a name="ln1392">	{</a>
<a name="ln1393">	  i = 1;</a>
<a name="ln1394">	}</a>
<a name="ln1395"> </a>
<a name="ln1396">      /* If area was found, then i&gt;0 here. */</a>
<a name="ln1397">      if (i)</a>
<a name="ln1398">	{</a>
<a name="ln1399">	  /* Check msg type. */</a>
<a name="ln1400">	  if (mask &amp; Power2[OSPF_ROUTER_LSA])</a>
<a name="ln1401">	    LSDB_LOOP (ROUTER_LSDB (area), rn, lsa)</a>
<a name="ln1402">	      apiserver_sync_callback(lsa, (void *) &amp;param, seqnum);</a>
<a name="ln1403">	  if (mask &amp; Power2[OSPF_NETWORK_LSA])</a>
<a name="ln1404">            LSDB_LOOP (NETWORK_LSDB (area), rn, lsa)</a>
<a name="ln1405">              apiserver_sync_callback(lsa, (void *) &amp;param, seqnum);</a>
<a name="ln1406">	  if (mask &amp; Power2[OSPF_SUMMARY_LSA])</a>
<a name="ln1407">            LSDB_LOOP (SUMMARY_LSDB (area), rn, lsa)</a>
<a name="ln1408">              apiserver_sync_callback(lsa, (void *) &amp;param, seqnum);</a>
<a name="ln1409">	  if (mask &amp; Power2[OSPF_ASBR_SUMMARY_LSA])</a>
<a name="ln1410">            LSDB_LOOP (ASBR_SUMMARY_LSDB (area), rn, lsa)</a>
<a name="ln1411">              apiserver_sync_callback(lsa, (void *) &amp;param, seqnum);</a>
<a name="ln1412">	  if (mask &amp; Power2[OSPF_OPAQUE_LINK_LSA])</a>
<a name="ln1413">            LSDB_LOOP (OPAQUE_LINK_LSDB (area), rn, lsa)</a>
<a name="ln1414">              apiserver_sync_callback(lsa, (void *) &amp;param, seqnum);</a>
<a name="ln1415">	  if (mask &amp; Power2[OSPF_OPAQUE_AREA_LSA])</a>
<a name="ln1416">            LSDB_LOOP (OPAQUE_AREA_LSDB (area), rn, lsa)</a>
<a name="ln1417">              apiserver_sync_callback(lsa, (void *) &amp;param, seqnum);</a>
<a name="ln1418">	}</a>
<a name="ln1419">    }</a>
<a name="ln1420"> </a>
<a name="ln1421">  /* For AS-external LSAs */</a>
<a name="ln1422">  if (ospf-&gt;lsdb)</a>
<a name="ln1423">    {</a>
<a name="ln1424">      if (mask &amp; Power2[OSPF_AS_EXTERNAL_LSA])</a>
<a name="ln1425">	LSDB_LOOP (EXTERNAL_LSDB (ospf), rn, lsa)</a>
<a name="ln1426">	  apiserver_sync_callback(lsa, (void *) &amp;param, seqnum);</a>
<a name="ln1427">    }</a>
<a name="ln1428"> </a>
<a name="ln1429">  /* For AS-external opaque LSAs */</a>
<a name="ln1430">  if (ospf-&gt;lsdb)</a>
<a name="ln1431">    {</a>
<a name="ln1432">      if (mask &amp; Power2[OSPF_OPAQUE_AS_LSA])</a>
<a name="ln1433">	LSDB_LOOP (OPAQUE_AS_LSDB (ospf), rn, lsa)</a>
<a name="ln1434">	  apiserver_sync_callback(lsa, (void *) &amp;param, seqnum);</a>
<a name="ln1435">    }</a>
<a name="ln1436"> </a>
<a name="ln1437">  /* Send a reply back to client with return code */</a>
<a name="ln1438">  rc = ospf_apiserver_send_reply (apiserv, seqnum, rc);</a>
<a name="ln1439">  return rc;</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442"> </a>
<a name="ln1443">/* -----------------------------------------------------------</a>
<a name="ln1444"> * Followings are functions to originate or update LSA</a>
<a name="ln1445"> * from an application.</a>
<a name="ln1446"> * -----------------------------------------------------------</a>
<a name="ln1447"> */</a>
<a name="ln1448"> </a>
<a name="ln1449">/* Create a new internal opaque LSA by taking prototype and filling in</a>
<a name="ln1450">   missing fields such as age, sequence number, advertising router,</a>
<a name="ln1451">   checksum and so on. The interface parameter is used for type 9</a>
<a name="ln1452">   LSAs, area parameter for type 10. Type 11 LSAs do neither need area</a>
<a name="ln1453">   nor interface. */</a>
<a name="ln1454"> </a>
<a name="ln1455">struct ospf_lsa *</a>
<a name="ln1456">ospf_apiserver_opaque_lsa_new (struct ospf_area *area,</a>
<a name="ln1457">			       struct ospf_interface *oi,</a>
<a name="ln1458">			       struct lsa_header *protolsa)</a>
<a name="ln1459">{</a>
<a name="ln1460">  struct stream *s;</a>
<a name="ln1461">  struct lsa_header *newlsa;</a>
<a name="ln1462">  struct ospf_lsa *new = NULL;</a>
<a name="ln1463">  u_char options = 0x0;</a>
<a name="ln1464">  u_int16_t length;</a>
<a name="ln1465"> </a>
<a name="ln1466">  struct ospf *ospf;</a>
<a name="ln1467"> </a>
<a name="ln1468">  ospf = ospf_lookup();</a>
<a name="ln1469">  assert(ospf);</a>
<a name="ln1470"> </a>
<a name="ln1471">  /* Create a stream for internal opaque LSA */</a>
<a name="ln1472">  if ((s = stream_new (OSPF_MAX_LSA_SIZE)) == NULL)</a>
<a name="ln1473">    {</a>
<a name="ln1474">      zlog_warn (&quot;ospf_apiserver_opaque_lsa_new: stream_new failed&quot;);</a>
<a name="ln1475">      return NULL;</a>
<a name="ln1476">    }</a>
<a name="ln1477"> </a>
<a name="ln1478">  newlsa = (struct lsa_header *) STREAM_DATA (s);</a>
<a name="ln1479"> </a>
<a name="ln1480">  /* XXX If this is a link-local LSA or an AS-external LSA, how do we</a>
<a name="ln1481">     have to set options? */</a>
<a name="ln1482"> </a>
<a name="ln1483">  if (area)</a>
<a name="ln1484">    {</a>
<a name="ln1485">      options = LSA_OPTIONS_GET (area);</a>
<a name="ln1486">      options |= LSA_OPTIONS_NSSA_GET (area);</a>
<a name="ln1487">    }</a>
<a name="ln1488"> </a>
<a name="ln1489">  options |= OSPF_OPTION_O;	/* Don't forget to set option bit */</a>
<a name="ln1490"> </a>
<a name="ln1491">  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))</a>
<a name="ln1492">    {</a>
<a name="ln1493">      zlog_debug (&quot;LSA[Type%d:%s]: Creating an Opaque-LSA instance&quot;,</a>
<a name="ln1494">		 protolsa-&gt;type, inet_ntoa (protolsa-&gt;id));</a>
<a name="ln1495">    }</a>
<a name="ln1496"> </a>
<a name="ln1497">  /* Set opaque-LSA header fields. */</a>
<a name="ln1498">  lsa_header_set (s, options, protolsa-&gt;type, protolsa-&gt;id, </a>
<a name="ln1499">                  ospf-&gt;router_id);</a>
<a name="ln1500"> </a>
<a name="ln1501">  /* Set opaque-LSA body fields. */</a>
<a name="ln1502">  stream_put (s, ((u_char *) protolsa) + sizeof (struct lsa_header),</a>
<a name="ln1503">	      ntohs (protolsa-&gt;length) - sizeof (struct lsa_header));</a>
<a name="ln1504"> </a>
<a name="ln1505">  /* Determine length of LSA. */</a>
<a name="ln1506">  length = stream_get_endp (s);</a>
<a name="ln1507">  newlsa-&gt;length = htons (length);</a>
<a name="ln1508"> </a>
<a name="ln1509">  /* Create OSPF LSA. */</a>
<a name="ln1510">  if ((new = ospf_lsa_new ()) == NULL)</a>
<a name="ln1511">    {</a>
<a name="ln1512">      zlog_warn (&quot;ospf_apiserver_opaque_lsa_new: ospf_lsa_new() ?&quot;);</a>
<a name="ln1513">      stream_free (s);</a>
<a name="ln1514">      return NULL;</a>
<a name="ln1515">    }</a>
<a name="ln1516"> </a>
<a name="ln1517">  if ((new-&gt;data = ospf_lsa_data_new (length)) == NULL)</a>
<a name="ln1518">    {</a>
<a name="ln1519">      zlog_warn (&quot;ospf_apiserver_opaque_lsa_new: ospf_lsa_data_new() ?&quot;);</a>
<a name="ln1520">      ospf_lsa_unlock (&amp;new);</a>
<a name="ln1521">      stream_free (s);</a>
<a name="ln1522">      return NULL;</a>
<a name="ln1523">    }</a>
<a name="ln1524"> </a>
<a name="ln1525">  new-&gt;area = area;</a>
<a name="ln1526">  new-&gt;oi = oi;</a>
<a name="ln1527"> </a>
<a name="ln1528">  SET_FLAG (new-&gt;flags, OSPF_LSA_SELF);</a>
<a name="ln1529">  memcpy (new-&gt;data, newlsa, length);</a>
<a name="ln1530">  stream_free (s);</a>
<a name="ln1531"> </a>
<a name="ln1532">  return new;</a>
<a name="ln1533">}</a>
<a name="ln1534"> </a>
<a name="ln1535"> </a>
<a name="ln1536">int</a>
<a name="ln1537">ospf_apiserver_is_ready_type9 (struct ospf_interface *oi)</a>
<a name="ln1538">{</a>
<a name="ln1539">  /* Type 9 opaque LSA can be originated if there is at least one</a>
<a name="ln1540">     active opaque-capable neighbor attached to the outgoing</a>
<a name="ln1541">     interface. */</a>
<a name="ln1542"> </a>
<a name="ln1543">  return (ospf_nbr_count_opaque_capable (oi) &gt; 0);</a>
<a name="ln1544">}</a>
<a name="ln1545"> </a>
<a name="ln1546">int</a>
<a name="ln1547">ospf_apiserver_is_ready_type10 (struct ospf_area *area)</a>
<a name="ln1548">{</a>
<a name="ln1549">  /* Type 10 opaque LSA can be originated if there is at least one</a>
<a name="ln1550">     interface belonging to the area that has an active opaque-capable</a>
<a name="ln1551">     neighbor. */</a>
<a name="ln1552">  struct listnode *node, *nnode;</a>
<a name="ln1553">  struct ospf_interface *oi;</a>
<a name="ln1554"> </a>
<a name="ln1555">  for (ALL_LIST_ELEMENTS (area-&gt;oiflist, node, nnode, oi))</a>
<a name="ln1556">    /* Is there an active neighbor attached to this interface? */</a>
<a name="ln1557">    if (ospf_apiserver_is_ready_type9 (oi))</a>
<a name="ln1558">      return 1;</a>
<a name="ln1559"> </a>
<a name="ln1560">  /* No active neighbor in area */</a>
<a name="ln1561">  return 0;</a>
<a name="ln1562">}</a>
<a name="ln1563"> </a>
<a name="ln1564">int</a>
<a name="ln1565">ospf_apiserver_is_ready_type11 (struct ospf *ospf)</a>
<a name="ln1566">{</a>
<a name="ln1567">  /* Type 11 opaque LSA can be originated if there is at least one interface</a>
<a name="ln1568">     that has an active opaque-capable neighbor. */</a>
<a name="ln1569">  struct listnode *node, *nnode;</a>
<a name="ln1570">  struct ospf_interface *oi;</a>
<a name="ln1571"> </a>
<a name="ln1572">  for (ALL_LIST_ELEMENTS (ospf-&gt;oiflist, node, nnode, oi))</a>
<a name="ln1573">    /* Is there an active neighbor attached to this interface? */</a>
<a name="ln1574">    if (ospf_apiserver_is_ready_type9 (oi))</a>
<a name="ln1575">      return 1;</a>
<a name="ln1576"> </a>
<a name="ln1577">  /* No active neighbor at all */</a>
<a name="ln1578">  return 0;</a>
<a name="ln1579">}</a>
<a name="ln1580"> </a>
<a name="ln1581"> </a>
<a name="ln1582">int</a>
<a name="ln1583">ospf_apiserver_handle_originate_request (struct ospf_apiserver *apiserv,</a>
<a name="ln1584">					 struct msg *msg)</a>
<a name="ln1585">{</a>
<a name="ln1586">  struct msg_originate_request *omsg;</a>
<a name="ln1587">  struct lsa_header *data;</a>
<a name="ln1588">  struct ospf_lsa *new;</a>
<a name="ln1589">  struct ospf_lsa *old;</a>
<a name="ln1590">  struct ospf_area *area = NULL;</a>
<a name="ln1591">  struct ospf_interface *oi = NULL;</a>
<a name="ln1592">  struct ospf_lsdb *lsdb = NULL;</a>
<a name="ln1593">  struct ospf *ospf;</a>
<a name="ln1594">  int lsa_type, opaque_type;</a>
<a name="ln1595">  int ready = 0;</a>
<a name="ln1596">  int rc = 0;</a>
<a name="ln1597">  </a>
<a name="ln1598">  ospf = ospf_lookup();</a>
<a name="ln1599"> </a>
<a name="ln1600">  /* Extract opaque LSA data from message */</a>
<a name="ln1601">  omsg = (struct msg_originate_request *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln1602">  data = &amp;omsg-&gt;data;</a>
<a name="ln1603"> </a>
<a name="ln1604">  /* Determine interface for type9 or area for type10 LSAs. */</a>
<a name="ln1605">  switch (data-&gt;type)</a>
<a name="ln1606">    {</a>
<a name="ln1607">    case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln1608">      oi = ospf_apiserver_if_lookup_by_addr (omsg-&gt;ifaddr);</a>
<a name="ln1609">      if (!oi)</a>
<a name="ln1610">	{</a>
<a name="ln1611">	  zlog_warn (&quot;apiserver_originate: unknown interface %s&quot;,</a>
<a name="ln1612">		     inet_ntoa (omsg-&gt;ifaddr));</a>
<a name="ln1613">	  rc = OSPF_API_NOSUCHINTERFACE;</a>
<a name="ln1614">	  goto out;</a>
<a name="ln1615">	}</a>
<a name="ln1616">      area = oi-&gt;area;</a>
<a name="ln1617">      lsdb = area-&gt;lsdb;</a>
<a name="ln1618">      break;</a>
<a name="ln1619">    case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln1620">      area = ospf_area_lookup_by_area_id (ospf, omsg-&gt;area_id);</a>
<a name="ln1621">      if (!area)</a>
<a name="ln1622">	{</a>
<a name="ln1623">	  zlog_warn (&quot;apiserver_originate: unknown area %s&quot;,</a>
<a name="ln1624">		     inet_ntoa (omsg-&gt;area_id));</a>
<a name="ln1625">	  rc = OSPF_API_NOSUCHAREA;</a>
<a name="ln1626">	  goto out;</a>
<a name="ln1627">	}</a>
<a name="ln1628">      lsdb = area-&gt;lsdb;</a>
<a name="ln1629">      break;</a>
<a name="ln1630">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln1631">      lsdb = ospf-&gt;lsdb;</a>
<a name="ln1632">      break;</a>
<a name="ln1633">    default:</a>
<a name="ln1634">      /* We can only handle opaque types here */</a>
<a name="ln1635">      zlog_warn (&quot;apiserver_originate: Cannot originate non-opaque LSA type %d&quot;,</a>
<a name="ln1636">		 data-&gt;type);</a>
<a name="ln1637">      rc = OSPF_API_ILLEGALLSATYPE;</a>
<a name="ln1638">      goto out;</a>
<a name="ln1639">    }</a>
<a name="ln1640"> </a>
<a name="ln1641">  /* Check if we registered this opaque type */</a>
<a name="ln1642">  lsa_type = data-&gt;type;</a>
<a name="ln1643">  opaque_type = GET_OPAQUE_TYPE (ntohl (data-&gt;id.s_addr));</a>
<a name="ln1644"> </a>
<a name="ln1645">  if (!apiserver_is_opaque_type_registered (apiserv, lsa_type, opaque_type))</a>
<a name="ln1646">    {</a>
<a name="ln1647">      zlog_warn (&quot;apiserver_originate: LSA-type(%d)/Opaque-type(%d): Not registered&quot;, lsa_type, opaque_type);</a>
<a name="ln1648">      rc = OSPF_API_OPAQUETYPENOTREGISTERED;</a>
<a name="ln1649">      goto out;</a>
<a name="ln1650">    }</a>
<a name="ln1651"> </a>
<a name="ln1652">  /* Make sure that the neighbors are ready before we can originate */</a>
<a name="ln1653">  switch (data-&gt;type)</a>
<a name="ln1654">    {</a>
<a name="ln1655">    case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln1656">      ready = ospf_apiserver_is_ready_type9 (oi);</a>
<a name="ln1657">      break;</a>
<a name="ln1658">    case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln1659">      ready = ospf_apiserver_is_ready_type10 (area);</a>
<a name="ln1660">      break;</a>
<a name="ln1661">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln1662">      ready = ospf_apiserver_is_ready_type11 (ospf);</a>
<a name="ln1663">      break;</a>
<a name="ln1664">    default:</a>
<a name="ln1665">      break;</a>
<a name="ln1666">    }</a>
<a name="ln1667"> </a>
<a name="ln1668">  if (!ready)</a>
<a name="ln1669">    {</a>
<a name="ln1670">      zlog_warn (&quot;Neighbors not ready to originate type %d&quot;, data-&gt;type);</a>
<a name="ln1671">      rc = OSPF_API_NOTREADY;</a>
<a name="ln1672">      goto out;</a>
<a name="ln1673">    }</a>
<a name="ln1674"> </a>
<a name="ln1675">  /* Create OSPF's internal opaque LSA representation */</a>
<a name="ln1676">  new = ospf_apiserver_opaque_lsa_new (area, oi, data);</a>
<a name="ln1677">  if (!new)</a>
<a name="ln1678">    {</a>
<a name="ln1679">      rc = OSPF_API_NOMEMORY;	/* XXX */</a>
<a name="ln1680">      goto out;</a>
<a name="ln1681">    }</a>
<a name="ln1682"> </a>
<a name="ln1683">  /* Determine if LSA is new or an update for an existing one. */</a>
<a name="ln1684">  old = ospf_lsdb_lookup (lsdb, new);</a>
<a name="ln1685"> </a>
<a name="ln1686">  if (!old)</a>
<a name="ln1687">    {</a>
<a name="ln1688">      /* New LSA install in LSDB. */</a>
<a name="ln1689">      rc = ospf_apiserver_originate1 (new);</a>
<a name="ln1690">    }</a>
<a name="ln1691">  else</a>
<a name="ln1692">    {</a>
<a name="ln1693">      /*</a>
<a name="ln1694">       * Keep the new LSA instance in the &quot;waiting place&quot; until the next</a>
<a name="ln1695">       * refresh timing. If several LSA update requests for the same LSID</a>
<a name="ln1696">       * have issued by peer, the last one takes effect.</a>
<a name="ln1697">       */</a>
<a name="ln1698">      new-&gt;lsdb = &amp;apiserv-&gt;reserve;</a>
<a name="ln1699">      ospf_lsdb_add (&amp;apiserv-&gt;reserve, new);</a>
<a name="ln1700"> </a>
<a name="ln1701">      /* Kick the scheduler function. */</a>
<a name="ln1702">      ospf_opaque_lsa_refresh_schedule (old);</a>
<a name="ln1703">    }</a>
<a name="ln1704"> </a>
<a name="ln1705">out:</a>
<a name="ln1706"> </a>
<a name="ln1707">  /* Send a reply back to client with return code */</a>
<a name="ln1708">  rc = ospf_apiserver_send_reply (apiserv, ntohl (msg-&gt;hdr.msgseq), rc);</a>
<a name="ln1709">  return rc;</a>
<a name="ln1710">}</a>
<a name="ln1711"> </a>
<a name="ln1712"> </a>
<a name="ln1713">/* -----------------------------------------------------------</a>
<a name="ln1714"> * Flood an LSA within its flooding scope. </a>
<a name="ln1715"> * -----------------------------------------------------------</a>
<a name="ln1716"> */</a>
<a name="ln1717"> </a>
<a name="ln1718">/* XXX We can probably use ospf_flood_through instead of this function</a>
<a name="ln1719">   but then we need the neighbor parameter. If we set nbr to </a>
<a name="ln1720">   NULL then ospf_flood_through crashes due to dereferencing NULL. */</a>
<a name="ln1721"> </a>
<a name="ln1722">void</a>
<a name="ln1723">ospf_apiserver_flood_opaque_lsa (struct ospf_lsa *lsa)</a>
<a name="ln1724">{</a>
<a name="ln1725">  assert (lsa);</a>
<a name="ln1726"> </a>
<a name="ln1727">  switch (lsa-&gt;data-&gt;type)</a>
<a name="ln1728">    {</a>
<a name="ln1729">    case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln1730">      /* Increment counters? XXX */</a>
<a name="ln1731"> </a>
<a name="ln1732">      /* Flood LSA through local network. */</a>
<a name="ln1733">      ospf_flood_through_area (lsa-&gt;area, NULL /*nbr */ , lsa);</a>
<a name="ln1734">      break;</a>
<a name="ln1735">    case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln1736">      /* Update LSA origination count. */</a>
<a name="ln1737">      assert (lsa-&gt;area);</a>
<a name="ln1738">      lsa-&gt;area-&gt;ospf-&gt;lsa_originate_count++;</a>
<a name="ln1739"> </a>
<a name="ln1740">      /* Flood LSA through area. */</a>
<a name="ln1741">      ospf_flood_through_area (lsa-&gt;area, NULL /*nbr */ , lsa);</a>
<a name="ln1742">      break;</a>
<a name="ln1743">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln1744">      {</a>
<a name="ln1745">	struct ospf *ospf;</a>
<a name="ln1746"> </a>
<a name="ln1747">	ospf = ospf_lookup();</a>
<a name="ln1748">	assert(ospf);</a>
<a name="ln1749"> </a>
<a name="ln1750">	/* Increment counters? XXX */</a>
<a name="ln1751"> </a>
<a name="ln1752">	/* Flood LSA through AS. */</a>
<a name="ln1753">	ospf_flood_through_as (ospf, NULL /*nbr */ , lsa);</a>
<a name="ln1754">	break;</a>
<a name="ln1755">      }</a>
<a name="ln1756">    }</a>
<a name="ln1757">}</a>
<a name="ln1758"> </a>
<a name="ln1759">int</a>
<a name="ln1760">ospf_apiserver_originate1 (struct ospf_lsa *lsa)</a>
<a name="ln1761">{</a>
<a name="ln1762">  struct ospf *ospf;</a>
<a name="ln1763"> </a>
<a name="ln1764">  ospf = ospf_lookup();</a>
<a name="ln1765">  assert(ospf);</a>
<a name="ln1766"> </a>
<a name="ln1767">  /* Install this LSA into LSDB. */</a>
<a name="ln1768">  if (ospf_lsa_install (ospf, lsa-&gt;oi, lsa) == NULL)</a>
<a name="ln1769">    {</a>
<a name="ln1770">      zlog_warn (&quot;ospf_apiserver_originate1: ospf_lsa_install failed&quot;);</a>
<a name="ln1771">      return -1;</a>
<a name="ln1772">    }</a>
<a name="ln1773"> </a>
<a name="ln1774">  /* Flood LSA within scope */</a>
<a name="ln1775"> </a>
<a name="ln1776">#ifdef NOTYET</a>
<a name="ln1777">  /*</a>
<a name="ln1778">   * NB: Modified version of &quot;ospf_flood_though ()&quot; accepts NULL &quot;inbr&quot;</a>
<a name="ln1779">   *     parameter, and thus it does not cause SIGSEGV error.</a>
<a name="ln1780">   */</a>
<a name="ln1781">  ospf_flood_through (NULL /*nbr */ , lsa);</a>
<a name="ln1782">#else /* NOTYET */</a>
<a name="ln1783"> </a>
<a name="ln1784">  ospf_apiserver_flood_opaque_lsa (lsa);</a>
<a name="ln1785">#endif /* NOTYET */</a>
<a name="ln1786"> </a>
<a name="ln1787">  return 0;</a>
<a name="ln1788">}</a>
<a name="ln1789"> </a>
<a name="ln1790"> </a>
<a name="ln1791">/* Opaque LSAs of type 9 on a specific interface can now be</a>
<a name="ln1792">   originated. Tell clients that registered type 9. */</a>
<a name="ln1793">int</a>
<a name="ln1794">ospf_apiserver_lsa9_originator (void *arg)</a>
<a name="ln1795">{</a>
<a name="ln1796">  struct ospf_interface *oi;</a>
<a name="ln1797"> </a>
<a name="ln1798">  oi = (struct ospf_interface *) arg;</a>
<a name="ln1799">  if (listcount (apiserver_list) &gt; 0) {</a>
<a name="ln1800">    ospf_apiserver_clients_notify_ready_type9 (oi);</a>
<a name="ln1801">  }</a>
<a name="ln1802">  return 0;</a>
<a name="ln1803">}</a>
<a name="ln1804"> </a>
<a name="ln1805">int</a>
<a name="ln1806">ospf_apiserver_lsa10_originator (void *arg)</a>
<a name="ln1807">{</a>
<a name="ln1808">  struct ospf_area *area;</a>
<a name="ln1809"> </a>
<a name="ln1810">  area = (struct ospf_area *) arg;</a>
<a name="ln1811">  if (listcount (apiserver_list) &gt; 0) {</a>
<a name="ln1812">    ospf_apiserver_clients_notify_ready_type10 (area);</a>
<a name="ln1813">  }</a>
<a name="ln1814">  return 0;</a>
<a name="ln1815">}</a>
<a name="ln1816"> </a>
<a name="ln1817">int</a>
<a name="ln1818">ospf_apiserver_lsa11_originator (void *arg)</a>
<a name="ln1819">{</a>
<a name="ln1820">  struct ospf *ospf;</a>
<a name="ln1821"> </a>
<a name="ln1822">  ospf = (struct ospf *) arg;</a>
<a name="ln1823">  if (listcount (apiserver_list) &gt; 0) {</a>
<a name="ln1824">    ospf_apiserver_clients_notify_ready_type11 (ospf);</a>
<a name="ln1825">  }</a>
<a name="ln1826">  return 0;</a>
<a name="ln1827">}</a>
<a name="ln1828"> </a>
<a name="ln1829"> </a>
<a name="ln1830">/* Periodically refresh opaque LSAs so that they do not expire in</a>
<a name="ln1831">   other routers. */</a>
<a name="ln1832">struct ospf_lsa *</a>
<a name="ln1833">ospf_apiserver_lsa_refresher (struct ospf_lsa *lsa)</a>
<a name="ln1834">{</a>
<a name="ln1835">  struct ospf_apiserver *apiserv;</a>
<a name="ln1836">  struct ospf_lsa *new = NULL;</a>
<a name="ln1837">  struct ospf * ospf;</a>
<a name="ln1838"> </a>
<a name="ln1839">  ospf = ospf_lookup();</a>
<a name="ln1840">  assert(ospf);</a>
<a name="ln1841"> </a>
<a name="ln1842">  apiserv = lookup_apiserver_by_lsa (lsa);</a>
<a name="ln1843">  if (!apiserv)</a>
<a name="ln1844">    {</a>
<a name="ln1845">      zlog_warn (&quot;ospf_apiserver_lsa_refresher: LSA[%s]: No apiserver?&quot;, dump_lsa_key (lsa));</a>
<a name="ln1846">      lsa-&gt;data-&gt;ls_age = htons (OSPF_LSA_MAXAGE); /* Flush it anyway. */</a>
<a name="ln1847">    }</a>
<a name="ln1848"> </a>
<a name="ln1849">  if (IS_LSA_MAXAGE (lsa))</a>
<a name="ln1850">    {</a>
<a name="ln1851">      ospf_opaque_lsa_flush_schedule (lsa);</a>
<a name="ln1852">      goto out;</a>
<a name="ln1853">    }</a>
<a name="ln1854"> </a>
<a name="ln1855">  /* Check if updated version of LSA instance has already prepared. */</a>
<a name="ln1856">  new = ospf_lsdb_lookup (&amp;apiserv-&gt;reserve, lsa);</a>
<a name="ln1857">  if (!new)</a>
<a name="ln1858">    {</a>
<a name="ln1859">      /* This is a periodic refresh, driven by core OSPF mechanism. */</a>
<a name="ln1860">      new = ospf_apiserver_opaque_lsa_new (lsa-&gt;area, lsa-&gt;oi, lsa-&gt;data);</a>
<a name="ln1861">      if (!new)</a>
<a name="ln1862">        {</a>
<a name="ln1863">          zlog_warn (&quot;ospf_apiserver_lsa_refresher: Cannot create a new LSA?&quot;);</a>
<a name="ln1864">          goto out;</a>
<a name="ln1865">        }</a>
<a name="ln1866">    }</a>
<a name="ln1867">  else</a>
<a name="ln1868">    {</a>
<a name="ln1869">      /* This is a forcible refresh, requested by OSPF-API client. */</a>
<a name="ln1870">      ospf_lsdb_delete (&amp;apiserv-&gt;reserve, new);</a>
<a name="ln1871">      new-&gt;lsdb = NULL;</a>
<a name="ln1872">    }</a>
<a name="ln1873"> </a>
<a name="ln1874">  /* Increment sequence number */</a>
<a name="ln1875">  new-&gt;data-&gt;ls_seqnum = lsa_seqnum_increment (lsa);</a>
<a name="ln1876"> </a>
<a name="ln1877">  /* New LSA is in same area. */</a>
<a name="ln1878">  new-&gt;area = lsa-&gt;area;</a>
<a name="ln1879">  SET_FLAG (new-&gt;flags, OSPF_LSA_SELF);</a>
<a name="ln1880"> </a>
<a name="ln1881">  /* Install LSA into LSDB. */</a>
<a name="ln1882">  if (ospf_lsa_install (ospf, new-&gt;oi, new) == NULL)</a>
<a name="ln1883">    {</a>
<a name="ln1884">      zlog_warn (&quot;ospf_apiserver_lsa_refresher: ospf_lsa_install failed&quot;);</a>
<a name="ln1885">      ospf_lsa_unlock (&amp;new);</a>
<a name="ln1886">      goto out;</a>
<a name="ln1887">    }</a>
<a name="ln1888"> </a>
<a name="ln1889">  /* Flood updated LSA through interface, area or AS */</a>
<a name="ln1890"> </a>
<a name="ln1891">#ifdef NOTYET</a>
<a name="ln1892">  ospf_flood_through (NULL /*nbr */ , new);</a>
<a name="ln1893">#endif /* NOTYET */</a>
<a name="ln1894">  ospf_apiserver_flood_opaque_lsa (new);</a>
<a name="ln1895"> </a>
<a name="ln1896">  /* Debug logging. */</a>
<a name="ln1897">  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))</a>
<a name="ln1898">    {</a>
<a name="ln1899">      zlog_debug (&quot;LSA[Type%d:%s]: Refresh Opaque LSA&quot;,</a>
<a name="ln1900">		 new-&gt;data-&gt;type, inet_ntoa (new-&gt;data-&gt;id));</a>
<a name="ln1901">      ospf_lsa_header_dump (new-&gt;data);</a>
<a name="ln1902">    }</a>
<a name="ln1903"> </a>
<a name="ln1904">out:</a>
<a name="ln1905">  return new;</a>
<a name="ln1906">}</a>
<a name="ln1907"> </a>
<a name="ln1908"> </a>
<a name="ln1909">/* -----------------------------------------------------------</a>
<a name="ln1910"> * Followings are functions to delete LSAs</a>
<a name="ln1911"> * -----------------------------------------------------------</a>
<a name="ln1912"> */</a>
<a name="ln1913"> </a>
<a name="ln1914">int</a>
<a name="ln1915">ospf_apiserver_handle_delete_request (struct ospf_apiserver *apiserv,</a>
<a name="ln1916">				      struct msg *msg)</a>
<a name="ln1917">{</a>
<a name="ln1918">  struct msg_delete_request *dmsg;</a>
<a name="ln1919">  struct ospf_lsa *old;</a>
<a name="ln1920">  struct ospf_area *area = NULL;</a>
<a name="ln1921">  struct in_addr id;</a>
<a name="ln1922">  int lsa_type, opaque_type;</a>
<a name="ln1923">  int rc = 0;</a>
<a name="ln1924">  struct ospf * ospf;</a>
<a name="ln1925"> </a>
<a name="ln1926">  ospf = ospf_lookup();</a>
<a name="ln1927">  assert(ospf);</a>
<a name="ln1928"> </a>
<a name="ln1929">  /* Extract opaque LSA from message */</a>
<a name="ln1930">  dmsg = (struct msg_delete_request *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln1931"> </a>
<a name="ln1932">  /* Lookup area for link-local and area-local opaque LSAs */</a>
<a name="ln1933">  switch (dmsg-&gt;lsa_type)</a>
<a name="ln1934">    {</a>
<a name="ln1935">    case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln1936">    case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln1937">      area = ospf_area_lookup_by_area_id (ospf, dmsg-&gt;area_id);</a>
<a name="ln1938">      if (!area)</a>
<a name="ln1939">	{</a>
<a name="ln1940">	  zlog_warn (&quot;ospf_apiserver_lsa_delete: unknown area %s&quot;,</a>
<a name="ln1941">		     inet_ntoa (dmsg-&gt;area_id));</a>
<a name="ln1942">	  rc = OSPF_API_NOSUCHAREA;</a>
<a name="ln1943">	  goto out;</a>
<a name="ln1944">	}</a>
<a name="ln1945">      break;</a>
<a name="ln1946">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln1947">      /* AS-external opaque LSAs have no designated area */</a>
<a name="ln1948">      area = NULL;</a>
<a name="ln1949">      break;</a>
<a name="ln1950">    default:</a>
<a name="ln1951">      zlog_warn</a>
<a name="ln1952">	(&quot;ospf_apiserver_lsa_delete: Cannot delete non-opaque LSA type %d&quot;,</a>
<a name="ln1953">	 dmsg-&gt;lsa_type);</a>
<a name="ln1954">      rc = OSPF_API_ILLEGALLSATYPE;</a>
<a name="ln1955">      goto out;</a>
<a name="ln1956">    }</a>
<a name="ln1957"> </a>
<a name="ln1958">  /* Check if we registered this opaque type */</a>
<a name="ln1959">  lsa_type = dmsg-&gt;lsa_type;</a>
<a name="ln1960">  opaque_type = dmsg-&gt;opaque_type;</a>
<a name="ln1961"> </a>
<a name="ln1962">  if (!apiserver_is_opaque_type_registered (apiserv, lsa_type, opaque_type))</a>
<a name="ln1963">    {</a>
<a name="ln1964">      zlog_warn (&quot;ospf_apiserver_lsa_delete: LSA-type(%d)/Opaque-type(%d): Not registered&quot;, lsa_type, opaque_type);</a>
<a name="ln1965">      rc = OSPF_API_OPAQUETYPENOTREGISTERED;</a>
<a name="ln1966">      goto out;</a>
<a name="ln1967">    }</a>
<a name="ln1968"> </a>
<a name="ln1969">  /* opaque_id is in network byte order */</a>
<a name="ln1970">  id.s_addr = htonl (SET_OPAQUE_LSID (dmsg-&gt;opaque_type,</a>
<a name="ln1971">				      ntohl (dmsg-&gt;opaque_id)));</a>
<a name="ln1972"> </a>
<a name="ln1973">  /*</a>
<a name="ln1974">   * Even if the target LSA has once scheduled to flush, it remains in</a>
<a name="ln1975">   * the LSDB until it is finally handled by the maxage remover thread.</a>
<a name="ln1976">   * Therefore, the lookup function below may return non-NULL result.</a>
<a name="ln1977">   */</a>
<a name="ln1978">  old = ospf_lsa_lookup (area, dmsg-&gt;lsa_type, id, ospf-&gt;router_id);</a>
<a name="ln1979">  if (!old)</a>
<a name="ln1980">    {</a>
<a name="ln1981">      zlog_warn (&quot;ospf_apiserver_lsa_delete: LSA[Type%d:%s] not in LSDB&quot;,</a>
<a name="ln1982">		 dmsg-&gt;lsa_type, inet_ntoa (id));</a>
<a name="ln1983">      rc = OSPF_API_NOSUCHLSA;</a>
<a name="ln1984">      goto out;</a>
<a name="ln1985">    }</a>
<a name="ln1986"> </a>
<a name="ln1987">  /* Schedule flushing of LSA from LSDB */</a>
<a name="ln1988">  /* NB: Multiple scheduling will produce a warning message, but harmless. */</a>
<a name="ln1989">  ospf_opaque_lsa_flush_schedule (old);</a>
<a name="ln1990"> </a>
<a name="ln1991">out:</a>
<a name="ln1992"> </a>
<a name="ln1993">  /* Send reply back to client including return code */</a>
<a name="ln1994">  rc = ospf_apiserver_send_reply (apiserv, ntohl (msg-&gt;hdr.msgseq), rc);</a>
<a name="ln1995">  return rc;</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998">/* Flush self-originated opaque LSA */</a>
<a name="ln1999">static int</a>
<a name="ln2000">apiserver_flush_opaque_type_callback (struct ospf_lsa *lsa,</a>
<a name="ln2001">				      void *p_arg, int int_arg)</a>
<a name="ln2002">{</a>
<a name="ln2003">  struct param_t</a>
<a name="ln2004">  {</a>
<a name="ln2005">    struct ospf_apiserver *apiserv;</a>
<a name="ln2006">    u_char lsa_type;</a>
<a name="ln2007">    u_char opaque_type;</a>
<a name="ln2008">  }</a>
<a name="ln2009">   *param;</a>
<a name="ln2010"> </a>
<a name="ln2011">  /* Sanity check */</a>
<a name="ln2012">  assert (lsa-&gt;data);</a>
<a name="ln2013">  assert (p_arg);</a>
<a name="ln2014">  param = (struct param_t *) p_arg;</a>
<a name="ln2015"> </a>
<a name="ln2016">  /* If LSA matches type and opaque type then delete it */</a>
<a name="ln2017">  if (IS_LSA_SELF (lsa) &amp;&amp; lsa-&gt;data-&gt;type == param-&gt;lsa_type</a>
<a name="ln2018">      &amp;&amp; GET_OPAQUE_TYPE (ntohl (lsa-&gt;data-&gt;id.s_addr)) == param-&gt;opaque_type)</a>
<a name="ln2019">    {</a>
<a name="ln2020">      ospf_opaque_lsa_flush_schedule (lsa);</a>
<a name="ln2021">    }</a>
<a name="ln2022">  return 0;</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025">/* Delete self-originated opaque LSAs of a given opaque type. This</a>
<a name="ln2026">   function is called when an application unregisters a given opaque</a>
<a name="ln2027">   type or a connection to an application closes and all those opaque</a>
<a name="ln2028">   LSAs need to be flushed the LSDB. */</a>
<a name="ln2029">void</a>
<a name="ln2030">ospf_apiserver_flush_opaque_lsa (struct ospf_apiserver *apiserv,</a>
<a name="ln2031">				 u_char lsa_type, u_char opaque_type)</a>
<a name="ln2032">{</a>
<a name="ln2033">  struct param_t</a>
<a name="ln2034">  {</a>
<a name="ln2035">    struct ospf_apiserver *apiserv;</a>
<a name="ln2036">    u_char lsa_type;</a>
<a name="ln2037">    u_char opaque_type;</a>
<a name="ln2038">  } param;</a>
<a name="ln2039">  struct listnode *node, *nnode;</a>
<a name="ln2040">  struct ospf * ospf;</a>
<a name="ln2041">  struct ospf_area *area;</a>
<a name="ln2042">  </a>
<a name="ln2043">  ospf = ospf_lookup();</a>
<a name="ln2044">  assert(ospf);</a>
<a name="ln2045"> </a>
<a name="ln2046">  /* Set parameter struct. */</a>
<a name="ln2047">  param.apiserv = apiserv;</a>
<a name="ln2048">  param.lsa_type = lsa_type;</a>
<a name="ln2049">  param.opaque_type = opaque_type;</a>
<a name="ln2050"> </a>
<a name="ln2051">  switch (lsa_type)</a>
<a name="ln2052">    {</a>
<a name="ln2053">      struct route_node *rn;</a>
<a name="ln2054">      struct ospf_lsa *lsa;</a>
<a name="ln2055"> </a>
<a name="ln2056">    case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln2057">      for (ALL_LIST_ELEMENTS (ospf-&gt;areas, node, nnode, area))</a>
<a name="ln2058">        LSDB_LOOP (OPAQUE_LINK_LSDB (area), rn, lsa)</a>
<a name="ln2059">          apiserver_flush_opaque_type_callback(lsa, (void *) &amp;param, 0);</a>
<a name="ln2060">      break;</a>
<a name="ln2061">    case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln2062">      for (ALL_LIST_ELEMENTS (ospf-&gt;areas, node, nnode, area))</a>
<a name="ln2063">        LSDB_LOOP (OPAQUE_AREA_LSDB (area), rn, lsa)</a>
<a name="ln2064">          apiserver_flush_opaque_type_callback(lsa, (void *) &amp;param, 0);</a>
<a name="ln2065">      break;</a>
<a name="ln2066">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln2067">      LSDB_LOOP (OPAQUE_LINK_LSDB (ospf), rn, lsa)</a>
<a name="ln2068">	apiserver_flush_opaque_type_callback(lsa, (void *) &amp;param, 0);</a>
<a name="ln2069">      break;</a>
<a name="ln2070">    default:</a>
<a name="ln2071">      break;</a>
<a name="ln2072">    }</a>
<a name="ln2073">  return;</a>
<a name="ln2074">}</a>
<a name="ln2075"> </a>
<a name="ln2076"> </a>
<a name="ln2077">/* -----------------------------------------------------------</a>
<a name="ln2078"> * Followings are callback functions to handle opaque types </a>
<a name="ln2079"> * -----------------------------------------------------------</a>
<a name="ln2080"> */</a>
<a name="ln2081"> </a>
<a name="ln2082">int</a>
<a name="ln2083">ospf_apiserver_new_if (struct interface *ifp)</a>
<a name="ln2084">{</a>
<a name="ln2085">  struct ospf_interface *oi;</a>
<a name="ln2086"> </a>
<a name="ln2087">  /* For some strange reason it seems possible that we are invoked</a>
<a name="ln2088">     with an interface that has no name. This seems to happen during</a>
<a name="ln2089">     initialization. Return if this happens */</a>
<a name="ln2090"> </a>
<a name="ln2091">  if (ifp-&gt;name[0] == '\0') {</a>
<a name="ln2092">    /* interface has empty name */</a>
<a name="ln2093">    zlog_warn (&quot;ospf_apiserver_new_if: interface has no name?&quot;);</a>
<a name="ln2094">    return 0;</a>
<a name="ln2095">  }</a>
<a name="ln2096"> </a>
<a name="ln2097">  /* zlog_warn for debugging */</a>
<a name="ln2098">  zlog_warn (&quot;ospf_apiserver_new_if&quot;);</a>
<a name="ln2099">  zlog_warn (&quot;ifp name=%s status=%d index=%d&quot;, ifp-&gt;name, ifp-&gt;status,</a>
<a name="ln2100">	     ifp-&gt;ifindex);</a>
<a name="ln2101"> </a>
<a name="ln2102">  if (ifp-&gt;name[0] == '\0') {</a>
<a name="ln2103">    /* interface has empty name */</a>
<a name="ln2104">    zlog_warn (&quot;ospf_apiserver_new_if: interface has no name?&quot;);</a>
<a name="ln2105">    return 0;</a>
<a name="ln2106">  }</a>
<a name="ln2107"> </a>
<a name="ln2108">  oi = ospf_apiserver_if_lookup_by_ifp (ifp);</a>
<a name="ln2109">  </a>
<a name="ln2110">  if (!oi) {</a>
<a name="ln2111">    /* This interface is known to Zebra but not to OSPF daemon yet. */</a>
<a name="ln2112">    zlog_warn (&quot;ospf_apiserver_new_if: interface %s not known to OSPFd?&quot;, </a>
<a name="ln2113">	       ifp-&gt;name);</a>
<a name="ln2114">    return 0;</a>
<a name="ln2115">  }</a>
<a name="ln2116"> </a>
<a name="ln2117">  assert (oi);</a>
<a name="ln2118"> </a>
<a name="ln2119">  /* New interface added to OSPF, tell clients about it */</a>
<a name="ln2120">  if (listcount (apiserver_list) &gt; 0) {</a>
<a name="ln2121">    ospf_apiserver_clients_notify_new_if (oi);</a>
<a name="ln2122">  }</a>
<a name="ln2123">  return 0;</a>
<a name="ln2124">}</a>
<a name="ln2125"> </a>
<a name="ln2126">int</a>
<a name="ln2127">ospf_apiserver_del_if (struct interface *ifp)</a>
<a name="ln2128">{</a>
<a name="ln2129">  struct ospf_interface *oi;</a>
<a name="ln2130"> </a>
<a name="ln2131">  /* zlog_warn for debugging */</a>
<a name="ln2132">  zlog_warn (&quot;ospf_apiserver_del_if&quot;);</a>
<a name="ln2133">  zlog_warn (&quot;ifp name=%s status=%d index=%d\n&quot;, ifp-&gt;name, ifp-&gt;status,</a>
<a name="ln2134">	     ifp-&gt;ifindex);</a>
<a name="ln2135"> </a>
<a name="ln2136">  oi = ospf_apiserver_if_lookup_by_ifp (ifp);</a>
<a name="ln2137"> </a>
<a name="ln2138">  if (!oi) {</a>
<a name="ln2139">    /* This interface is known to Zebra but not to OSPF daemon</a>
<a name="ln2140">       anymore. No need to tell clients about it */</a>
<a name="ln2141">    return 0;</a>
<a name="ln2142">  }</a>
<a name="ln2143"> </a>
<a name="ln2144">  /* Interface deleted, tell clients about it */</a>
<a name="ln2145">  if (listcount (apiserver_list) &gt; 0) {</a>
<a name="ln2146">    ospf_apiserver_clients_notify_del_if (oi);</a>
<a name="ln2147">  }</a>
<a name="ln2148">  return 0;</a>
<a name="ln2149">}</a>
<a name="ln2150"> </a>
<a name="ln2151">void</a>
<a name="ln2152">ospf_apiserver_ism_change (struct ospf_interface *oi, int old_state)</a>
<a name="ln2153">{</a>
<a name="ln2154">  /* Tell clients about interface change */</a>
<a name="ln2155"> </a>
<a name="ln2156">  /* zlog_warn for debugging */</a>
<a name="ln2157">  zlog_warn (&quot;ospf_apiserver_ism_change&quot;);</a>
<a name="ln2158">  if (listcount (apiserver_list) &gt; 0) {</a>
<a name="ln2159">    ospf_apiserver_clients_notify_ism_change (oi);</a>
<a name="ln2160">  }</a>
<a name="ln2161"> </a>
<a name="ln2162">  zlog_warn (&quot;oi-&gt;ifp-&gt;name=%s&quot;, oi-&gt;ifp-&gt;name);</a>
<a name="ln2163">  zlog_warn (&quot;old_state=%d&quot;, old_state);</a>
<a name="ln2164">  zlog_warn (&quot;oi-&gt;state=%d&quot;, oi-&gt;state);</a>
<a name="ln2165">}</a>
<a name="ln2166"> </a>
<a name="ln2167">void</a>
<a name="ln2168">ospf_apiserver_nsm_change (struct ospf_neighbor *nbr, int old_status)</a>
<a name="ln2169">{</a>
<a name="ln2170">  /* Neighbor status changed, tell clients about it */</a>
<a name="ln2171">  zlog_warn (&quot;ospf_apiserver_nsm_change&quot;);</a>
<a name="ln2172">  if (listcount (apiserver_list) &gt; 0) {</a>
<a name="ln2173">    ospf_apiserver_clients_notify_nsm_change (nbr);</a>
<a name="ln2174">  }</a>
<a name="ln2175">}</a>
<a name="ln2176"> </a>
<a name="ln2177">void</a>
<a name="ln2178">ospf_apiserver_show_info (struct vty *vty, struct ospf_lsa *lsa)</a>
<a name="ln2179">{</a>
<a name="ln2180">  struct opaque_lsa</a>
<a name="ln2181">  {</a>
<a name="ln2182">    struct lsa_header header;</a>
<a name="ln2183">    u_char data[1]; /* opaque data have variable length. This is start</a>
<a name="ln2184">                       address */</a>
<a name="ln2185">  };</a>
<a name="ln2186">  struct opaque_lsa *olsa;</a>
<a name="ln2187">  int opaquelen;</a>
<a name="ln2188"> </a>
<a name="ln2189">  olsa = (struct opaque_lsa *) lsa-&gt;data;</a>
<a name="ln2190"> </a>
<a name="ln2191">  if (VALID_OPAQUE_INFO_LEN (lsa-&gt;data))</a>
<a name="ln2192">    opaquelen = ntohs (lsa-&gt;data-&gt;length) - OSPF_LSA_HEADER_SIZE;</a>
<a name="ln2193">  else</a>
<a name="ln2194">    opaquelen = 0;</a>
<a name="ln2195"> </a>
<a name="ln2196">  /* Output information about opaque LSAs */</a>
<a name="ln2197">  if (vty != NULL)</a>
<a name="ln2198">    {</a>
<a name="ln2199">      int i;</a>
<a name="ln2200">      vty_out (vty, &quot;  Added using OSPF API: %u octets of opaque data %s%s&quot;,</a>
<a name="ln2201">	       opaquelen,</a>
<a name="ln2202">	       VALID_OPAQUE_INFO_LEN (lsa-&gt;data) ? &quot;&quot; : &quot;(Invalid length?)&quot;,</a>
<a name="ln2203">	       VTY_NEWLINE);</a>
<a name="ln2204">      vty_out (vty, &quot;  Opaque data: &quot;);</a>
<a name="ln2205"> </a>
<a name="ln2206">      for (i = 0; i &lt; opaquelen; i++)</a>
<a name="ln2207">	{</a>
<a name="ln2208">	  vty_out (vty, &quot;0x%x &quot;, olsa-&gt;data[i]);</a>
<a name="ln2209">	}</a>
<a name="ln2210">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln2211">    }</a>
<a name="ln2212">  else</a>
<a name="ln2213">    {</a>
<a name="ln2214">      int i;</a>
<a name="ln2215">      zlog_debug (&quot;    Added using OSPF API: %u octets of opaque data %s&quot;,</a>
<a name="ln2216">		 opaquelen,</a>
<a name="ln2217">		 VALID_OPAQUE_INFO_LEN (lsa-&gt;</a>
<a name="ln2218">					data) ? &quot;&quot; : &quot;(Invalid length?)&quot;);</a>
<a name="ln2219">      zlog_debug (&quot;    Opaque data: &quot;);</a>
<a name="ln2220"> </a>
<a name="ln2221">      for (i = 0; i &lt; opaquelen; i++)</a>
<a name="ln2222">	{</a>
<a name="ln2223">	  zlog_debug (&quot;0x%x &quot;, olsa-&gt;data[i]);</a>
<a name="ln2224">	}</a>
<a name="ln2225">      zlog_debug (&quot;\n&quot;);</a>
<a name="ln2226">    }</a>
<a name="ln2227">  return;</a>
<a name="ln2228">}</a>
<a name="ln2229"> </a>
<a name="ln2230">/* -----------------------------------------------------------</a>
<a name="ln2231"> * Followings are functions to notify clients about events</a>
<a name="ln2232"> * -----------------------------------------------------------</a>
<a name="ln2233"> */</a>
<a name="ln2234"> </a>
<a name="ln2235">/* Send a message to all clients. This is useful for messages</a>
<a name="ln2236">   that need to be notified to all clients (such as interface</a>
<a name="ln2237">   changes) */</a>
<a name="ln2238"> </a>
<a name="ln2239">void</a>
<a name="ln2240">ospf_apiserver_clients_notify_all (struct msg *msg)</a>
<a name="ln2241">{</a>
<a name="ln2242">  struct listnode *node, *nnode;</a>
<a name="ln2243">  struct ospf_apiserver *apiserv;</a>
<a name="ln2244"> </a>
<a name="ln2245">  /* Send message to all clients */</a>
<a name="ln2246">  for (ALL_LIST_ELEMENTS (apiserver_list, node, nnode, apiserv))</a>
<a name="ln2247">    ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln2248">}</a>
<a name="ln2249"> </a>
<a name="ln2250">/* An interface is now ready to accept opaque LSAs. Notify all</a>
<a name="ln2251">   clients that registered to use this opaque type */</a>
<a name="ln2252">void</a>
<a name="ln2253">ospf_apiserver_clients_notify_ready_type9 (struct ospf_interface *oi)</a>
<a name="ln2254">{</a>
<a name="ln2255">  struct listnode *node, *nnode;</a>
<a name="ln2256">  struct msg *msg;</a>
<a name="ln2257">  struct ospf_apiserver *apiserv;</a>
<a name="ln2258"> </a>
<a name="ln2259">  assert (oi);</a>
<a name="ln2260">  if (!oi-&gt;address)</a>
<a name="ln2261">    {</a>
<a name="ln2262">      zlog_warn (&quot;Interface has no address?&quot;);</a>
<a name="ln2263">      return;</a>
<a name="ln2264">    }</a>
<a name="ln2265"> </a>
<a name="ln2266">  if (!ospf_apiserver_is_ready_type9 (oi))</a>
<a name="ln2267">    {</a>
<a name="ln2268">      zlog_warn (&quot;Interface not ready for type 9?&quot;);</a>
<a name="ln2269">      return;</a>
<a name="ln2270">    }</a>
<a name="ln2271"> </a>
<a name="ln2272">  for (ALL_LIST_ELEMENTS (apiserver_list, node, nnode, apiserv))</a>
<a name="ln2273">    {</a>
<a name="ln2274">      struct listnode *node2, *nnode2;</a>
<a name="ln2275">      struct registered_opaque_type *r;</a>
<a name="ln2276"> </a>
<a name="ln2277">      for (ALL_LIST_ELEMENTS (apiserv-&gt;opaque_types, node2, nnode2, r))</a>
<a name="ln2278">	{</a>
<a name="ln2279">	  if (r-&gt;lsa_type == OSPF_OPAQUE_LINK_LSA)</a>
<a name="ln2280">	    {</a>
<a name="ln2281">	      msg = new_msg_ready_notify (0, OSPF_OPAQUE_LINK_LSA,</a>
<a name="ln2282">					  r-&gt;opaque_type,</a>
<a name="ln2283">					  oi-&gt;address-&gt;u.prefix4);</a>
<a name="ln2284">	      if (!msg)</a>
<a name="ln2285">		{</a>
<a name="ln2286">		  zlog_warn</a>
<a name="ln2287">		    (&quot;ospf_apiserver_clients_notify_ready_type9: new_msg_ready_notify failed&quot;);</a>
<a name="ln2288">#ifdef NOTYET</a>
<a name="ln2289">		  /* Cannot allocate new message. What should we do? */</a>
<a name="ln2290">		  ospf_apiserver_free (apiserv);</a>
<a name="ln2291">#endif</a>
<a name="ln2292">		  goto out;</a>
<a name="ln2293">		}</a>
<a name="ln2294"> </a>
<a name="ln2295">	      ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln2296">	      msg_free (msg);</a>
<a name="ln2297">	    }</a>
<a name="ln2298">	}</a>
<a name="ln2299">    }</a>
<a name="ln2300"> </a>
<a name="ln2301">out:</a>
<a name="ln2302">  return;</a>
<a name="ln2303">}</a>
<a name="ln2304"> </a>
<a name="ln2305">void</a>
<a name="ln2306">ospf_apiserver_clients_notify_ready_type10 (struct ospf_area *area)</a>
<a name="ln2307">{</a>
<a name="ln2308">  struct listnode *node, *nnode;</a>
<a name="ln2309">  struct msg *msg;</a>
<a name="ln2310">  struct ospf_apiserver *apiserv;</a>
<a name="ln2311"> </a>
<a name="ln2312">  assert (area);</a>
<a name="ln2313"> </a>
<a name="ln2314">  if (!ospf_apiserver_is_ready_type10 (area))</a>
<a name="ln2315">    {</a>
<a name="ln2316">      zlog_warn (&quot;Area not ready for type 10?&quot;);</a>
<a name="ln2317">      return;</a>
<a name="ln2318">    }</a>
<a name="ln2319"> </a>
<a name="ln2320">  for (ALL_LIST_ELEMENTS (apiserver_list, node, nnode, apiserv))</a>
<a name="ln2321">    {</a>
<a name="ln2322">      struct listnode *node2, *nnode2;</a>
<a name="ln2323">      struct registered_opaque_type *r;</a>
<a name="ln2324"> </a>
<a name="ln2325">      for (ALL_LIST_ELEMENTS (apiserv-&gt;opaque_types, node2, nnode2, r))</a>
<a name="ln2326">	{</a>
<a name="ln2327">	  if (r-&gt;lsa_type == OSPF_OPAQUE_AREA_LSA)</a>
<a name="ln2328">	    {</a>
<a name="ln2329">	      msg = new_msg_ready_notify (0, OSPF_OPAQUE_AREA_LSA,</a>
<a name="ln2330">					  r-&gt;opaque_type, area-&gt;area_id);</a>
<a name="ln2331">	      if (!msg)</a>
<a name="ln2332">		{</a>
<a name="ln2333">		  zlog_warn</a>
<a name="ln2334">		    (&quot;ospf_apiserver_clients_notify_ready_type10: new_msg_ready_nofity failed&quot;);</a>
<a name="ln2335">#ifdef NOTYET</a>
<a name="ln2336">		  /* Cannot allocate new message. What should we do? */</a>
<a name="ln2337">		  ospf_apiserver_free (apiserv);</a>
<a name="ln2338">#endif</a>
<a name="ln2339">                  goto out;</a>
<a name="ln2340">		}</a>
<a name="ln2341"> </a>
<a name="ln2342">	      ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln2343">	      msg_free (msg);</a>
<a name="ln2344">	    }</a>
<a name="ln2345">	}</a>
<a name="ln2346">    }</a>
<a name="ln2347"> </a>
<a name="ln2348">out:</a>
<a name="ln2349">  return;</a>
<a name="ln2350">}</a>
<a name="ln2351"> </a>
<a name="ln2352"> </a>
<a name="ln2353">void</a>
<a name="ln2354">ospf_apiserver_clients_notify_ready_type11 (struct ospf *top)</a>
<a name="ln2355">{</a>
<a name="ln2356">  struct listnode *node, *nnode;</a>
<a name="ln2357">  struct msg *msg;</a>
<a name="ln2358">  struct in_addr id_null = { .s_addr = 0L };</a>
<a name="ln2359">  struct ospf_apiserver *apiserv;</a>
<a name="ln2360">  </a>
<a name="ln2361">  assert (top);</a>
<a name="ln2362">  </a>
<a name="ln2363">  if (!ospf_apiserver_is_ready_type11 (top))</a>
<a name="ln2364">    {</a>
<a name="ln2365">      zlog_warn (&quot;AS not ready for type 11?&quot;);</a>
<a name="ln2366">      return;</a>
<a name="ln2367">    }</a>
<a name="ln2368"> </a>
<a name="ln2369">  for (ALL_LIST_ELEMENTS (apiserver_list, node, nnode, apiserv))</a>
<a name="ln2370">    {</a>
<a name="ln2371">      struct listnode *node2, *nnode2;</a>
<a name="ln2372">      struct registered_opaque_type *r;</a>
<a name="ln2373"> </a>
<a name="ln2374">      for (ALL_LIST_ELEMENTS (apiserv-&gt;opaque_types, node2, nnode2, r))</a>
<a name="ln2375">	{</a>
<a name="ln2376">	  if (r-&gt;lsa_type == OSPF_OPAQUE_AS_LSA)</a>
<a name="ln2377">	    {</a>
<a name="ln2378">	      msg = new_msg_ready_notify (0, OSPF_OPAQUE_AS_LSA,</a>
<a name="ln2379">					  r-&gt;opaque_type, id_null);</a>
<a name="ln2380">	      if (!msg)</a>
<a name="ln2381">		{</a>
<a name="ln2382">		  zlog_warn</a>
<a name="ln2383">		    (&quot;ospf_apiserver_clients_notify_ready_type11: new_msg_ready_notify failed&quot;);</a>
<a name="ln2384">#ifdef NOTYET</a>
<a name="ln2385">		  /* Cannot allocate new message. What should we do? */</a>
<a name="ln2386">		  ospf_apiserver_free (apiserv);</a>
<a name="ln2387">#endif</a>
<a name="ln2388">		  goto out;</a>
<a name="ln2389">		}</a>
<a name="ln2390"> </a>
<a name="ln2391">	      ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln2392">	      msg_free (msg);</a>
<a name="ln2393">	    }</a>
<a name="ln2394">	}</a>
<a name="ln2395">    }</a>
<a name="ln2396"> </a>
<a name="ln2397">out:</a>
<a name="ln2398">  return;</a>
<a name="ln2399">}</a>
<a name="ln2400"> </a>
<a name="ln2401">void</a>
<a name="ln2402">ospf_apiserver_clients_notify_new_if (struct ospf_interface *oi)</a>
<a name="ln2403">{</a>
<a name="ln2404">  struct msg *msg;</a>
<a name="ln2405"> </a>
<a name="ln2406">  msg = new_msg_new_if (0, oi-&gt;address-&gt;u.prefix4, oi-&gt;area-&gt;area_id);</a>
<a name="ln2407">  if (msg != NULL)</a>
<a name="ln2408">    {</a>
<a name="ln2409">      ospf_apiserver_clients_notify_all (msg);</a>
<a name="ln2410">      msg_free (msg);</a>
<a name="ln2411">    }</a>
<a name="ln2412">}</a>
<a name="ln2413"> </a>
<a name="ln2414">void</a>
<a name="ln2415">ospf_apiserver_clients_notify_del_if (struct ospf_interface *oi)</a>
<a name="ln2416">{</a>
<a name="ln2417">  struct msg *msg;</a>
<a name="ln2418"> </a>
<a name="ln2419">  msg = new_msg_del_if (0, oi-&gt;address-&gt;u.prefix4);</a>
<a name="ln2420">  if (msg != NULL)</a>
<a name="ln2421">    {</a>
<a name="ln2422">      ospf_apiserver_clients_notify_all (msg);</a>
<a name="ln2423">      msg_free (msg);</a>
<a name="ln2424">    }</a>
<a name="ln2425">}</a>
<a name="ln2426"> </a>
<a name="ln2427">void</a>
<a name="ln2428">ospf_apiserver_clients_notify_ism_change (struct ospf_interface *oi)</a>
<a name="ln2429">{</a>
<a name="ln2430">  struct msg *msg;</a>
<a name="ln2431">  struct in_addr ifaddr = { .s_addr = 0L };</a>
<a name="ln2432">  struct in_addr area_id = { .s_addr = 0L };</a>
<a name="ln2433">  </a>
<a name="ln2434">  assert (oi);</a>
<a name="ln2435">  assert (oi-&gt;ifp);</a>
<a name="ln2436">  </a>
<a name="ln2437">  if (oi-&gt;address)</a>
<a name="ln2438">    {</a>
<a name="ln2439">      ifaddr = oi-&gt;address-&gt;u.prefix4;</a>
<a name="ln2440">    }</a>
<a name="ln2441">  if (oi-&gt;area)</a>
<a name="ln2442">    {</a>
<a name="ln2443">      area_id = oi-&gt;area-&gt;area_id;</a>
<a name="ln2444">    }</a>
<a name="ln2445"> </a>
<a name="ln2446">  msg = new_msg_ism_change (0, ifaddr, area_id, oi-&gt;state);</a>
<a name="ln2447">  if (!msg)</a>
<a name="ln2448">    {</a>
<a name="ln2449">      zlog_warn (&quot;apiserver_clients_notify_ism_change: msg_new failed&quot;);</a>
<a name="ln2450">      return;</a>
<a name="ln2451">    }</a>
<a name="ln2452"> </a>
<a name="ln2453">  ospf_apiserver_clients_notify_all (msg);</a>
<a name="ln2454">  msg_free (msg);</a>
<a name="ln2455">}</a>
<a name="ln2456"> </a>
<a name="ln2457">void</a>
<a name="ln2458">ospf_apiserver_clients_notify_nsm_change (struct ospf_neighbor *nbr)</a>
<a name="ln2459">{</a>
<a name="ln2460">  struct msg *msg;</a>
<a name="ln2461">  struct in_addr ifaddr = { .s_addr = 0L };</a>
<a name="ln2462">  struct in_addr nbraddr = { .s_addr = 0L };</a>
<a name="ln2463"> </a>
<a name="ln2464">  assert (nbr);</a>
<a name="ln2465"> </a>
<a name="ln2466">  if (nbr-&gt;oi)</a>
<a name="ln2467">    {</a>
<a name="ln2468">      ifaddr = nbr-&gt;oi-&gt;address-&gt;u.prefix4;</a>
<a name="ln2469">    }</a>
<a name="ln2470"> </a>
<a name="ln2471">  nbraddr = nbr-&gt;address.u.prefix4;</a>
<a name="ln2472"> </a>
<a name="ln2473">  msg = new_msg_nsm_change (0, ifaddr, nbraddr, nbr-&gt;router_id, nbr-&gt;state);</a>
<a name="ln2474">  if (!msg)</a>
<a name="ln2475">    {</a>
<a name="ln2476">      zlog_warn (&quot;apiserver_clients_notify_nsm_change: msg_new failed&quot;);</a>
<a name="ln2477">      return;</a>
<a name="ln2478">    }</a>
<a name="ln2479"> </a>
<a name="ln2480">  ospf_apiserver_clients_notify_all (msg);</a>
<a name="ln2481">  msg_free (msg);</a>
<a name="ln2482">}</a>
<a name="ln2483"> </a>
<a name="ln2484">static void</a>
<a name="ln2485">apiserver_clients_lsa_change_notify (u_char msgtype, struct ospf_lsa *lsa)</a>
<a name="ln2486">{</a>
<a name="ln2487">  struct msg *msg;</a>
<a name="ln2488">  struct listnode *node, *nnode;</a>
<a name="ln2489">  struct ospf_apiserver *apiserv;</a>
<a name="ln2490"> </a>
<a name="ln2491">  /* Default area for AS-External and Opaque11 LSAs */</a>
<a name="ln2492">  struct in_addr area_id = { .s_addr = 0L };</a>
<a name="ln2493"> </a>
<a name="ln2494">  /* Default interface for non Opaque9 LSAs */</a>
<a name="ln2495">  struct in_addr ifaddr = { .s_addr = 0L };</a>
<a name="ln2496"> </a>
<a name="ln2497">  if (lsa-&gt;area)</a>
<a name="ln2498">    {</a>
<a name="ln2499">      area_id = lsa-&gt;area-&gt;area_id;</a>
<a name="ln2500">    }</a>
<a name="ln2501">  if (lsa-&gt;data-&gt;type == OSPF_OPAQUE_LINK_LSA)</a>
<a name="ln2502">    {</a>
<a name="ln2503">      assert (lsa-&gt;oi);</a>
<a name="ln2504">      ifaddr = lsa-&gt;oi-&gt;address-&gt;u.prefix4;</a>
<a name="ln2505">    }</a>
<a name="ln2506"> </a>
<a name="ln2507">  /* Prepare message that can be sent to clients that have a matching</a>
<a name="ln2508">     filter */</a>
<a name="ln2509">  msg = new_msg_lsa_change_notify (msgtype, 0L,	/* no sequence number */</a>
<a name="ln2510">				   ifaddr, area_id,</a>
<a name="ln2511">				   lsa-&gt;flags &amp; OSPF_LSA_SELF, lsa-&gt;data);</a>
<a name="ln2512">  if (!msg)</a>
<a name="ln2513">    {</a>
<a name="ln2514">      zlog_warn (&quot;apiserver_clients_lsa_change_notify: msg_new failed&quot;);</a>
<a name="ln2515">      return;</a>
<a name="ln2516">    }</a>
<a name="ln2517"> </a>
<a name="ln2518">  /* Now send message to all clients with a matching filter */</a>
<a name="ln2519">  for (ALL_LIST_ELEMENTS (apiserver_list, node, nnode, apiserv))</a>
<a name="ln2520">    {</a>
<a name="ln2521">      struct lsa_filter_type *filter;</a>
<a name="ln2522">      u_int16_t mask;</a>
<a name="ln2523">      u_int32_t *area;</a>
<a name="ln2524">      int i;</a>
<a name="ln2525"> </a>
<a name="ln2526">      /* Check filter for this client. */</a>
<a name="ln2527">      filter = apiserv-&gt;filter;</a>
<a name="ln2528"> </a>
<a name="ln2529">      /* Check area IDs in case of non AS-E LSAs.</a>
<a name="ln2530">       * If filter has areas (num_areas &gt; 0),</a>
<a name="ln2531">       * then one of the areas must match the area ID of this LSA. */</a>
<a name="ln2532"> </a>
<a name="ln2533">      i = filter-&gt;num_areas;</a>
<a name="ln2534">      if ((lsa-&gt;data-&gt;type == OSPF_AS_EXTERNAL_LSA) ||</a>
<a name="ln2535">	  (lsa-&gt;data-&gt;type == OSPF_OPAQUE_AS_LSA))</a>
<a name="ln2536">	{</a>
<a name="ln2537">	  i = 0;</a>
<a name="ln2538">	}</a>
<a name="ln2539"> </a>
<a name="ln2540">      if (i &gt; 0)</a>
<a name="ln2541">	{</a>
<a name="ln2542">	  area = (u_int32_t *) (filter + 1);</a>
<a name="ln2543">	  while (i)</a>
<a name="ln2544">	    {</a>
<a name="ln2545">	      if (*area == area_id.s_addr)</a>
<a name="ln2546">		{</a>
<a name="ln2547">		  break;</a>
<a name="ln2548">		}</a>
<a name="ln2549">	      i--;</a>
<a name="ln2550">	      area++;</a>
<a name="ln2551">	    }</a>
<a name="ln2552">	}</a>
<a name="ln2553">      else</a>
<a name="ln2554">	{</a>
<a name="ln2555">	  i = 1;</a>
<a name="ln2556">	}</a>
<a name="ln2557"> </a>
<a name="ln2558">      if (i &gt; 0)</a>
<a name="ln2559">	{</a>
<a name="ln2560">	  /* Area match. Check LSA type. */</a>
<a name="ln2561">	  mask = ntohs (filter-&gt;typemask);</a>
<a name="ln2562"> </a>
<a name="ln2563">	  if (mask &amp; Power2[lsa-&gt;data-&gt;type])</a>
<a name="ln2564">	    {</a>
<a name="ln2565">	      /* Type also matches. Check origin. */</a>
<a name="ln2566">	      if ((filter-&gt;origin == ANY_ORIGIN) ||</a>
<a name="ln2567">		  (filter-&gt;origin == IS_LSA_SELF (lsa)))</a>
<a name="ln2568">		{</a>
<a name="ln2569">		  ospf_apiserver_send_msg (apiserv, msg);</a>
<a name="ln2570">		}</a>
<a name="ln2571">	    }</a>
<a name="ln2572">	}</a>
<a name="ln2573">    }</a>
<a name="ln2574">  /* Free message since it is not used anymore */</a>
<a name="ln2575">  msg_free (msg);</a>
<a name="ln2576">}</a>
<a name="ln2577"> </a>
<a name="ln2578"> </a>
<a name="ln2579">/* -------------------------------------------------------------</a>
<a name="ln2580"> * Followings are hooks invoked when LSAs are updated or deleted</a>
<a name="ln2581"> * -------------------------------------------------------------</a>
<a name="ln2582"> */</a>
<a name="ln2583"> </a>
<a name="ln2584"> </a>
<a name="ln2585">static int</a>
<a name="ln2586">apiserver_notify_clients_lsa (u_char msgtype, struct ospf_lsa *lsa)</a>
<a name="ln2587">{</a>
<a name="ln2588">  struct msg *msg;</a>
<a name="ln2589">  /* default area for AS-External and Opaque11 LSAs */</a>
<a name="ln2590">  struct in_addr area_id = { .s_addr = 0L };</a>
<a name="ln2591"> </a>
<a name="ln2592">  /* default interface for non Opaque9 LSAs */</a>
<a name="ln2593">  struct in_addr ifaddr = { .s_addr = 0L };</a>
<a name="ln2594"> </a>
<a name="ln2595">  /* Only notify this update if the LSA's age is smaller than</a>
<a name="ln2596">     MAXAGE. Otherwise clients would see LSA updates with max age just</a>
<a name="ln2597">     before they are deleted from the LSDB. LSA delete messages have</a>
<a name="ln2598">     MAXAGE too but should not be filtered. */</a>
<a name="ln2599">  if (IS_LSA_MAXAGE(lsa) &amp;&amp; (msgtype == MSG_LSA_UPDATE_NOTIFY)) {</a>
<a name="ln2600">    return 0;</a>
<a name="ln2601">  }</a>
<a name="ln2602"> </a>
<a name="ln2603">  if (lsa-&gt;area)</a>
<a name="ln2604">    {</a>
<a name="ln2605">      area_id = lsa-&gt;area-&gt;area_id;</a>
<a name="ln2606">    }</a>
<a name="ln2607">  if (lsa-&gt;data-&gt;type == OSPF_OPAQUE_LINK_LSA)</a>
<a name="ln2608">    {</a>
<a name="ln2609">      ifaddr = lsa-&gt;oi-&gt;address-&gt;u.prefix4;</a>
<a name="ln2610">    }</a>
<a name="ln2611">  msg = new_msg_lsa_change_notify (msgtype, 0L,	/* no sequence number */</a>
<a name="ln2612">				   ifaddr, area_id,</a>
<a name="ln2613">				   lsa-&gt;flags &amp; OSPF_LSA_SELF, lsa-&gt;data);</a>
<a name="ln2614">  if (!msg)</a>
<a name="ln2615">    {</a>
<a name="ln2616">      zlog_warn (&quot;notify_clients_lsa: msg_new failed&quot;);</a>
<a name="ln2617">      return -1;</a>
<a name="ln2618">    }</a>
<a name="ln2619">  /* Notify all clients that new LSA is added/updated */</a>
<a name="ln2620">  apiserver_clients_lsa_change_notify (msgtype, lsa);</a>
<a name="ln2621"> </a>
<a name="ln2622">  /* Clients made their own copies of msg so we can free msg here */</a>
<a name="ln2623">  msg_free (msg);</a>
<a name="ln2624"> </a>
<a name="ln2625">  return 0;</a>
<a name="ln2626">}</a>
<a name="ln2627"> </a>
<a name="ln2628">int</a>
<a name="ln2629">ospf_apiserver_lsa_update (struct ospf_lsa *lsa)</a>
<a name="ln2630">{</a>
<a name="ln2631">  return apiserver_notify_clients_lsa (MSG_LSA_UPDATE_NOTIFY, lsa);</a>
<a name="ln2632">}</a>
<a name="ln2633"> </a>
<a name="ln2634">int</a>
<a name="ln2635">ospf_apiserver_lsa_delete (struct ospf_lsa *lsa)</a>
<a name="ln2636">{</a>
<a name="ln2637">  return apiserver_notify_clients_lsa (MSG_LSA_DELETE_NOTIFY, lsa);</a>
<a name="ln2638">}</a>
<a name="ln2639"> </a>
<a name="ln2640">#endif /* SUPPORT_OSPF_API */</a>
<a name="ln2641"> </a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="1856"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1004/" target="_blank">V1004</a> The 'apiserv' pointer was used unsafely after it was verified against nullptr. Check lines: 1843, 1856.</p></div>
<div class="balloon" rel="2542"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'filter' is cast to a more strictly aligned pointer type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
