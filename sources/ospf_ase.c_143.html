
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_ase.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF AS external route calculation.</a>
<a name="ln3"> * Copyright (C) 1999, 2000 Alex Zinin, Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;hash.h&quot;</a>
<a name="ln28">#include &quot;linklist.h&quot;</a>
<a name="ln29">#include &quot;prefix.h&quot;</a>
<a name="ln30">#include &quot;if.h&quot;</a>
<a name="ln31">#include &quot;table.h&quot;</a>
<a name="ln32">#include &quot;vty.h&quot;</a>
<a name="ln33">#include &quot;log.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln36">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_ase.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">struct ospf_route *</a>
<a name="ln50">ospf_find_asbr_route (struct ospf *ospf,</a>
<a name="ln51">		      struct route_table *rtrs, struct prefix_ipv4 *asbr)</a>
<a name="ln52">{</a>
<a name="ln53">  struct route_node *rn;</a>
<a name="ln54">  struct ospf_route *or, *best = NULL;</a>
<a name="ln55">  struct listnode *node;</a>
<a name="ln56">  struct list *chosen;</a>
<a name="ln57"> </a>
<a name="ln58">  /* Sanity check. */</a>
<a name="ln59">  if (rtrs == NULL)</a>
<a name="ln60">    return NULL;</a>
<a name="ln61"> </a>
<a name="ln62">  rn = route_node_lookup (rtrs, (struct prefix *) asbr);</a>
<a name="ln63">  if (! rn)</a>
<a name="ln64">    return NULL;</a>
<a name="ln65"> </a>
<a name="ln66">  route_unlock_node (rn);</a>
<a name="ln67"> </a>
<a name="ln68">  chosen = list_new ();</a>
<a name="ln69"> </a>
<a name="ln70">  /* First try to find intra-area non-bb paths. */</a>
<a name="ln71">  if (!CHECK_FLAG (ospf-&gt;config, OSPF_RFC1583_COMPATIBLE))</a>
<a name="ln72">    for (ALL_LIST_ELEMENTS_RO ((struct list *) rn-&gt;info, node, or))</a>
<a name="ln73">      if (or-&gt;cost &lt; OSPF_LS_INFINITY)</a>
<a name="ln74">        if (!OSPF_IS_AREA_ID_BACKBONE (or-&gt;u.std.area_id) &amp;&amp;</a>
<a name="ln75">            or-&gt;path_type == OSPF_PATH_INTRA_AREA)</a>
<a name="ln76">          listnode_add (chosen, or);</a>
<a name="ln77"> </a>
<a name="ln78">  /* If none is found -- look through all. */</a>
<a name="ln79">  if (listcount (chosen) == 0)</a>
<a name="ln80">    {</a>
<a name="ln81">      list_free (chosen);</a>
<a name="ln82">      chosen = rn-&gt;info;</a>
<a name="ln83">    }</a>
<a name="ln84"> </a>
<a name="ln85">  /* Now find the route with least cost. */</a>
<a name="ln86">  for (ALL_LIST_ELEMENTS_RO (chosen, node, or))</a>
<a name="ln87">    if (or-&gt;cost &lt; OSPF_LS_INFINITY)</a>
<a name="ln88">      {</a>
<a name="ln89">        if (best == NULL)</a>
<a name="ln90">          best = or;</a>
<a name="ln91">        else if (best-&gt;cost &gt; or-&gt;cost)</a>
<a name="ln92">          best = or;</a>
<a name="ln93">        else if (best-&gt;cost == or-&gt;cost &amp;&amp;</a>
<a name="ln94">                 IPV4_ADDR_CMP (&amp;best-&gt;u.std.area_id,</a>
<a name="ln95">                                &amp;or-&gt;u.std.area_id) &lt; 0)</a>
<a name="ln96">          best = or;</a>
<a name="ln97">      }</a>
<a name="ln98"> </a>
<a name="ln99">  if (chosen != rn-&gt;info)</a>
<a name="ln100">    list_delete (chosen);</a>
<a name="ln101"> </a>
<a name="ln102">  return best;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">struct ospf_route * </a>
<a name="ln106">ospf_find_asbr_route_through_area (struct route_table *rtrs, </a>
<a name="ln107">				   struct prefix_ipv4 *asbr, </a>
<a name="ln108">				   struct ospf_area *area)</a>
<a name="ln109">{</a>
<a name="ln110">  struct route_node *rn;</a>
<a name="ln111"> </a>
<a name="ln112">  /* Sanity check. */</a>
<a name="ln113">  if (rtrs == NULL)</a>
<a name="ln114">    return NULL;</a>
<a name="ln115"> </a>
<a name="ln116">  rn = route_node_lookup (rtrs, (struct prefix *) asbr);</a>
<a name="ln117"> </a>
<a name="ln118">  if (rn)</a>
<a name="ln119">    {</a>
<a name="ln120">      struct listnode *node;</a>
<a name="ln121">      struct ospf_route *or;</a>
<a name="ln122"> </a>
<a name="ln123">      route_unlock_node (rn);</a>
<a name="ln124"> </a>
<a name="ln125">      for (ALL_LIST_ELEMENTS_RO ((struct list *) rn-&gt;info, node, or))</a>
<a name="ln126">        if (IPV4_ADDR_SAME (&amp;or-&gt;u.std.area_id, &amp;area-&gt;area_id))</a>
<a name="ln127">          return or;</a>
<a name="ln128">    }</a>
<a name="ln129"> </a>
<a name="ln130">  return NULL;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">static void</a>
<a name="ln134">ospf_ase_complete_direct_routes (struct ospf_route *ro, struct in_addr nexthop)</a>
<a name="ln135">{</a>
<a name="ln136">  struct listnode *node;</a>
<a name="ln137">  struct ospf_path *op;</a>
<a name="ln138"> </a>
<a name="ln139">  for (ALL_LIST_ELEMENTS_RO (ro-&gt;paths, node, op))</a>
<a name="ln140">    if (op-&gt;nexthop.s_addr == 0)</a>
<a name="ln141">      op-&gt;nexthop.s_addr = nexthop.s_addr;</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">static int</a>
<a name="ln145">ospf_ase_forward_address_check (struct ospf *ospf, struct in_addr fwd_addr)</a>
<a name="ln146">{</a>
<a name="ln147">  struct listnode *ifn;</a>
<a name="ln148">  struct ospf_interface *oi;</a>
<a name="ln149"> </a>
<a name="ln150">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, ifn, oi))</a>
<a name="ln151">    if (if_is_operative (oi-&gt;ifp))</a>
<a name="ln152">      if (oi-&gt;type != OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln153">        if (IPV4_ADDR_SAME (&amp;oi-&gt;address-&gt;u.prefix4, &amp;fwd_addr))</a>
<a name="ln154">          return 0;</a>
<a name="ln155">  </a>
<a name="ln156">  return 1;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">#if 0</a>
<a name="ln160">/* Calculate ASBR route. */</a>
<a name="ln161">static struct ospf_route *</a>
<a name="ln162">ospf_ase_calculate_asbr_route (struct ospf *ospf,</a>
<a name="ln163">			       struct route_table *rt_network,</a>
<a name="ln164">			       struct route_table *rt_router,</a>
<a name="ln165">			       struct as_external_lsa *al)</a>
<a name="ln166">{</a>
<a name="ln167">  struct prefix_ipv4 asbr;</a>
<a name="ln168">  struct ospf_route *asbr_route;</a>
<a name="ln169">  struct route_node *rn;</a>
<a name="ln170"> </a>
<a name="ln171">  /* Find ASBR route from Router routing table. */</a>
<a name="ln172">  asbr.family = AF_INET;</a>
<a name="ln173">  asbr.prefix = al-&gt;header.adv_router;</a>
<a name="ln174">  asbr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln175">  apply_mask_ipv4 (&amp;asbr);</a>
<a name="ln176"> </a>
<a name="ln177">  asbr_route = ospf_find_asbr_route (ospf, rt_router, &amp;asbr);</a>
<a name="ln178"> </a>
<a name="ln179">  if (asbr_route == NULL)</a>
<a name="ln180">    {</a>
<a name="ln181">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln182">	zlog_debug (&quot;ospf_ase_calculate(): Route to ASBR %s not found&quot;,</a>
<a name="ln183">		    inet_ntoa (asbr.prefix));</a>
<a name="ln184">      return NULL;</a>
<a name="ln185">    }</a>
<a name="ln186"> </a>
<a name="ln187">  if (!(asbr_route-&gt;u.std.flags &amp; ROUTER_LSA_EXTERNAL))</a>
<a name="ln188">    {</a>
<a name="ln189">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln190">	zlog_debug (&quot;ospf_ase_calculate(): Originating router is not an ASBR&quot;);</a>
<a name="ln191">      return NULL;</a>
<a name="ln192">    }</a>
<a name="ln193">   </a>
<a name="ln194">  if (al-&gt;e[0].fwd_addr.s_addr != 0)</a>
<a name="ln195">    {</a>
<a name="ln196">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln197">	zlog_debug (&quot;ospf_ase_calculate(): &quot;</a>
<a name="ln198">		    &quot;Forwarding address is not 0.0.0.0.&quot;);</a>
<a name="ln199"> </a>
<a name="ln200">      if (! ospf_ase_forward_address_check (ospf, al-&gt;e[0].fwd_addr))</a>
<a name="ln201">	{</a>
<a name="ln202">	  if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln203">	    zlog_debug (&quot;ospf_ase_calculate(): &quot;</a>
<a name="ln204">			&quot;Forwarding address is one of our addresses, Ignore.&quot;);</a>
<a name="ln205">	  return NULL;</a>
<a name="ln206">        }</a>
<a name="ln207"> </a>
<a name="ln208">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln209">	zlog_debug (&quot;ospf_ase_calculate(): &quot;</a>
<a name="ln210">		    &quot;Looking up in the Network Routing Table.&quot;);</a>
<a name="ln211"> </a>
<a name="ln212">      /* Looking up the path to the fwd_addr from Network route. */</a>
<a name="ln213">      asbr.family = AF_INET;</a>
<a name="ln214">      asbr.prefix = al-&gt;e[0].fwd_addr;</a>
<a name="ln215">      asbr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln216"> </a>
<a name="ln217">      rn = route_node_match (rt_network, (struct prefix *) &amp;asbr);</a>
<a name="ln218">   </a>
<a name="ln219">      if (rn == NULL)</a>
<a name="ln220">	{</a>
<a name="ln221">	  if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln222">	    zlog_debug (&quot;ospf_ase_calculate(): &quot;</a>
<a name="ln223">			&quot;Couldn't find a route to the forwarding address.&quot;);</a>
<a name="ln224">	  return NULL;</a>
<a name="ln225">	}</a>
<a name="ln226"> </a>
<a name="ln227">      route_unlock_node (rn);</a>
<a name="ln228"> </a>
<a name="ln229">      if ((asbr_route = rn-&gt;info) == NULL)</a>
<a name="ln230">	{</a>
<a name="ln231">	  if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln232">	    zlog_debug (&quot;ospf_ase_calculate(): &quot;</a>
<a name="ln233">			&quot;Somehow OSPF route to ASBR is lost&quot;);</a>
<a name="ln234">	  return NULL;</a>
<a name="ln235">	}</a>
<a name="ln236">    }</a>
<a name="ln237"> </a>
<a name="ln238">  return asbr_route;</a>
<a name="ln239">}</a>
<a name="ln240">#endif</a>
<a name="ln241"> </a>
<a name="ln242">static struct ospf_route *</a>
<a name="ln243">ospf_ase_calculate_new_route (struct ospf_lsa *lsa,</a>
<a name="ln244">			      struct ospf_route *asbr_route, u_int32_t metric)</a>
<a name="ln245">{</a>
<a name="ln246">  struct as_external_lsa *al;</a>
<a name="ln247">  struct ospf_route *new;</a>
<a name="ln248"> </a>
<a name="ln249">  al = (struct as_external_lsa *) lsa-&gt;data;</a>
<a name="ln250"> </a>
<a name="ln251">  new = ospf_route_new ();</a>
<a name="ln252"> </a>
<a name="ln253">  /* Set redistributed type -- does make sense? */</a>
<a name="ln254">  /* new-&gt;type = type; */</a>
<a name="ln255">  new-&gt;id = al-&gt;header.id;</a>
<a name="ln256">  new-&gt;mask = al-&gt;mask;</a>
<a name="ln257"> </a>
<a name="ln258">  if (!IS_EXTERNAL_METRIC (al-&gt;e[0].tos))</a>
<a name="ln259">    {</a>
<a name="ln260">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln261">	zlog_debug (&quot;Route[External]: type-1 created.&quot;);</a>
<a name="ln262">      new-&gt;path_type = OSPF_PATH_TYPE1_EXTERNAL;</a>
<a name="ln263">      new-&gt;cost = asbr_route-&gt;cost + metric;		/* X + Y */</a>
<a name="ln264">    }</a>
<a name="ln265">  else</a>
<a name="ln266">    {</a>
<a name="ln267">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln268">	zlog_debug (&quot;Route[External]: type-2 created.&quot;);</a>
<a name="ln269">      new-&gt;path_type = OSPF_PATH_TYPE2_EXTERNAL;</a>
<a name="ln270">      new-&gt;cost = asbr_route-&gt;cost;			/* X */</a>
<a name="ln271">      new-&gt;u.ext.type2_cost = metric;			/* Y */</a>
<a name="ln272">    }</a>
<a name="ln273"> </a>
<a name="ln274">  new-&gt;type = OSPF_DESTINATION_NETWORK;</a>
<a name="ln275">  new-&gt;u.ext.origin = lsa;</a>
<a name="ln276">  new-&gt;u.ext.tag = ntohl (al-&gt;e[0].route_tag);</a>
<a name="ln277">  new-&gt;u.ext.asbr = asbr_route;</a>
<a name="ln278"> </a>
<a name="ln279">  assert (new != asbr_route);</a>
<a name="ln280"> </a>
<a name="ln281">  return new;</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">#define OSPF_ASE_CALC_INTERVAL 1</a>
<a name="ln285"> </a>
<a name="ln286">int</a>
<a name="ln287">ospf_ase_calculate_route (struct ospf *ospf, struct ospf_lsa * lsa)</a>
<a name="ln288">{</a>
<a name="ln289">  u_int32_t metric;</a>
<a name="ln290">  struct as_external_lsa *al;</a>
<a name="ln291">  struct ospf_route *asbr_route;</a>
<a name="ln292">  struct prefix_ipv4 asbr, p;</a>
<a name="ln293">  struct route_node *rn;</a>
<a name="ln294">  struct ospf_route *new, *or;</a>
<a name="ln295">  int ret;</a>
<a name="ln296">  </a>
<a name="ln297">  assert (lsa);</a>
<a name="ln298">  al = (struct as_external_lsa *) lsa-&gt;data;</a>
<a name="ln299"> </a>
<a name="ln300">  if (lsa-&gt;data-&gt;type == OSPF_AS_NSSA_LSA)</a>
<a name="ln301">    if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln302">      zlog_debug (&quot;ospf_ase_calc(): Processing Type-7&quot;);</a>
<a name="ln303"> </a>
<a name="ln304">  /* Stay away from any Local Translated Type-7 LSAs */</a>
<a name="ln305">  if (CHECK_FLAG (lsa-&gt;flags, OSPF_LSA_LOCAL_XLT))</a>
<a name="ln306">    {</a>
<a name="ln307">      if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln308">	zlog_debug (&quot;ospf_ase_calc(): Rejecting Local Xlt'd&quot;);</a>
<a name="ln309">      return 0;</a>
<a name="ln310">    }</a>
<a name="ln311"> </a>
<a name="ln312">  if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln313">    zlog_debug (&quot;Route[External]: Calculate AS-external-LSA to %s/%d&quot;,</a>
<a name="ln314">		inet_ntoa (al-&gt;header.id), ip_masklen (al-&gt;mask));</a>
<a name="ln315">  /* (1) If the cost specified by the LSA is LSInfinity, or if the</a>
<a name="ln316">         LSA's LS age is equal to MaxAge, then examine the next LSA. */</a>
<a name="ln317">  if ((metric = GET_METRIC (al-&gt;e[0].metric)) &gt;= OSPF_LS_INFINITY)</a>
<a name="ln318">    {</a>
<a name="ln319">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln320">	zlog_debug (&quot;Route[External]: Metric is OSPF_LS_INFINITY&quot;);</a>
<a name="ln321">      return 0;</a>
<a name="ln322">    }</a>
<a name="ln323">  if (IS_LSA_MAXAGE (lsa))</a>
<a name="ln324">    {</a>
<a name="ln325">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln326">	zlog_debug (&quot;Route[External]: AS-external-LSA is MAXAGE&quot;);</a>
<a name="ln327">      return 0;</a>
<a name="ln328">    }</a>
<a name="ln329">  </a>
<a name="ln330">  /* (2) If the LSA was originated by the calculating router itself,</a>
<a name="ln331">     examine the next LSA. */</a>
<a name="ln332">  if (IS_LSA_SELF (lsa))</a>
<a name="ln333">    {</a>
<a name="ln334">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln335">	zlog_debug (&quot;Route[External]: AS-external-LSA is self originated&quot;);</a>
<a name="ln336">      return 0;</a>
<a name="ln337">    }</a>
<a name="ln338"> </a>
<a name="ln339">  /* (3) Call the destination described by the LSA N.  N's address is</a>
<a name="ln340">         obtained by masking the LSA's Link State ID with the</a>
<a name="ln341">	 network/subnet mask contained in the body of the LSA.  Look</a>
<a name="ln342">	 up the routing table entries (potentially one per attached</a>
<a name="ln343">	 area) for the AS boundary router (ASBR) that originated the</a>
<a name="ln344">	 LSA. If no entries exist for router ASBR (i.e., ASBR is</a>
<a name="ln345">	 unreachable), do nothing with this LSA and consider the next</a>
<a name="ln346">	 in the list. */</a>
<a name="ln347">  </a>
<a name="ln348">  asbr.family = AF_INET;</a>
<a name="ln349">  asbr.prefix = al-&gt;header.adv_router;</a>
<a name="ln350">  asbr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln351">  apply_mask_ipv4 (&amp;asbr);</a>
<a name="ln352">  </a>
<a name="ln353">  asbr_route = ospf_find_asbr_route (ospf, ospf-&gt;new_rtrs, &amp;asbr);</a>
<a name="ln354">  if (asbr_route == NULL)</a>
<a name="ln355">    {</a>
<a name="ln356">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln357">	zlog_debug (&quot;Route[External]: Can't find originating ASBR route&quot;);</a>
<a name="ln358">      return 0;</a>
<a name="ln359">    }</a>
<a name="ln360">  if (!(asbr_route-&gt;u.std.flags &amp; ROUTER_LSA_EXTERNAL))</a>
<a name="ln361">    {</a>
<a name="ln362">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln363">	zlog_debug (&quot;Route[External]: Originating router is not an ASBR&quot;);</a>
<a name="ln364">      return 0;</a>
<a name="ln365">    }</a>
<a name="ln366">  </a>
<a name="ln367">  /*     Else, this LSA describes an AS external path to destination</a>
<a name="ln368">	 N.  Examine the forwarding address specified in the AS-</a>
<a name="ln369">	 external-LSA.  This indicates the IP address to which</a>
<a name="ln370">	 packets for the destination should be forwarded. */</a>
<a name="ln371">  </a>
<a name="ln372">  if (al-&gt;e[0].fwd_addr.s_addr == 0)</a>
<a name="ln373">    {</a>
<a name="ln374">      /* If the forwarding address is set to 0.0.0.0, packets should</a>
<a name="ln375">	 be sent to the ASBR itself. Among the multiple routing table</a>
<a name="ln376">	 entries for the ASBR, select the preferred entry as follows.</a>
<a name="ln377">	 If RFC1583Compatibility is set to &quot;disabled&quot;, prune the set</a>
<a name="ln378">	 of routing table entries for the ASBR as described in</a>
<a name="ln379">	 Section 16.4.1. In any case, among the remaining routing</a>
<a name="ln380">	 table entries, select the routing table entry with the least</a>
<a name="ln381">	 cost; when there are multiple least cost routing table</a>
<a name="ln382">	 entries the entry whose associated area has the largest OSPF</a>
<a name="ln383">	 Area ID (when considered as an unsigned 32-bit integer) is</a>
<a name="ln384">	 chosen. */</a>
<a name="ln385"> </a>
<a name="ln386">      /* asbr_route already contains the requested route */</a>
<a name="ln387">    }</a>
<a name="ln388">  else</a>
<a name="ln389">    {</a>
<a name="ln390">      /* If the forwarding address is non-zero, look up the</a>
<a name="ln391">	 forwarding address in the routing table.[24] The matching</a>
<a name="ln392">	 routing table entry must specify an intra-area or inter-area</a>
<a name="ln393">	 path; if no such path exists, do nothing with the LSA and</a>
<a name="ln394">	 consider the next in the list. */</a>
<a name="ln395">      if (! ospf_ase_forward_address_check (ospf, al-&gt;e[0].fwd_addr))</a>
<a name="ln396">	{</a>
<a name="ln397">	  if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln398">	    zlog_debug (&quot;Route[External]: Forwarding address is our router &quot;</a>
<a name="ln399">			&quot;address&quot;);</a>
<a name="ln400">	  return 0;</a>
<a name="ln401">	}</a>
<a name="ln402">      </a>
<a name="ln403">      asbr.family = AF_INET;</a>
<a name="ln404">      asbr.prefix = al-&gt;e[0].fwd_addr;</a>
<a name="ln405">      asbr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln406"> </a>
<a name="ln407">      rn = route_node_match (ospf-&gt;new_table, (struct prefix *) &amp;asbr);</a>
<a name="ln408">      </a>
<a name="ln409">      if (rn == NULL || (asbr_route = rn-&gt;info) == NULL)</a>
<a name="ln410">	{</a>
<a name="ln411">	  if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln412">	    zlog_debug (&quot;Route[External]: Can't find route to forwarding &quot;</a>
<a name="ln413">			&quot;address&quot;);</a>
<a name="ln414">	  if (rn)</a>
<a name="ln415">	    route_unlock_node (rn);</a>
<a name="ln416">	  return 0;</a>
<a name="ln417">	}</a>
<a name="ln418"> </a>
<a name="ln419">      route_unlock_node (rn);</a>
<a name="ln420">    }</a>
<a name="ln421"> </a>
<a name="ln422">  /* (4) Let X be the cost specified by the preferred routing table</a>
<a name="ln423">         entry for the ASBR/forwarding address, and Y the cost</a>
<a name="ln424">	 specified in the LSA.  X is in terms of the link state</a>
<a name="ln425">	 metric, and Y is a type 1 or 2 external metric. */</a>
<a name="ln426">			 </a>
<a name="ln427"> </a>
<a name="ln428">  /* (5) Look up the routing table entry for the destination N.  If</a>
<a name="ln429">         no entry exists for N, install the AS external path to N,</a>
<a name="ln430">	 with next hop equal to the list of next hops to the</a>
<a name="ln431">	 forwarding address, and advertising router equal to ASBR.</a>
<a name="ln432">	 If the external metric type is 1, then the path-type is set</a>
<a name="ln433">	 to type 1 external and the cost is equal to X+Y.  If the</a>
<a name="ln434">	 external metric type is 2, the path-type is set to type 2</a>
<a name="ln435">	 external, the link state component of the route's cost is X,</a>
<a name="ln436">	 and the type 2 cost is Y. */</a>
<a name="ln437">  new = ospf_ase_calculate_new_route (lsa, asbr_route, metric);</a>
<a name="ln438"> </a>
<a name="ln439">  /* (6) Compare the AS external path described by the LSA with the</a>
<a name="ln440">         existing paths in N's routing table entry, as follows. If</a>
<a name="ln441">	 the new path is preferred, it replaces the present paths in</a>
<a name="ln442">	 N's routing table entry.  If the new path is of equal</a>
<a name="ln443">	 preference, it is added to N's routing table entry's list of</a>
<a name="ln444">	 paths. */</a>
<a name="ln445"> </a>
<a name="ln446">  /* Set prefix. */</a>
<a name="ln447">  p.family = AF_INET;</a>
<a name="ln448">  p.prefix = al-&gt;header.id;</a>
<a name="ln449">  p.prefixlen = ip_masklen (al-&gt;mask);</a>
<a name="ln450"> </a>
<a name="ln451">  /* if there is a Intra/Inter area route to the N</a>
<a name="ln452">     do not install external route */</a>
<a name="ln453">  if ((rn = route_node_lookup (ospf-&gt;new_table,</a>
<a name="ln454">			      (struct prefix *) &amp;p)))</a>
<a name="ln455">    {</a>
<a name="ln456">      route_unlock_node(rn);</a>
<a name="ln457">      if (rn-&gt;info == NULL)</a>
<a name="ln458">	zlog_info (&quot;Route[External]: rn-&gt;info NULL&quot;);</a>
<a name="ln459">      if (new)</a>
<a name="ln460">	ospf_route_free (new);</a>
<a name="ln461">      return 0;</a>
<a name="ln462">    }</a>
<a name="ln463">  /* Find a route to the same dest */</a>
<a name="ln464">  /* If there is no route, create new one. */</a>
<a name="ln465">  if ((rn = route_node_lookup (ospf-&gt;new_external_route,</a>
<a name="ln466">			       (struct prefix *) &amp;p)))</a>
<a name="ln467">      route_unlock_node(rn);</a>
<a name="ln468"> </a>
<a name="ln469">  if (!rn || (or = rn-&gt;info) == NULL)</a>
<a name="ln470">    {</a>
<a name="ln471">      if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln472">	zlog_debug (&quot;Route[External]: Adding a new route %s/%d&quot;,</a>
<a name="ln473">		    inet_ntoa (p.prefix), p.prefixlen);</a>
<a name="ln474"> </a>
<a name="ln475">      ospf_route_add (ospf-&gt;new_external_route, &amp;p, new, asbr_route);</a>
<a name="ln476"> </a>
<a name="ln477">      if (al-&gt;e[0].fwd_addr.s_addr)</a>
<a name="ln478">	ospf_ase_complete_direct_routes (new, al-&gt;e[0].fwd_addr);</a>
<a name="ln479">      return 0;</a>
<a name="ln480">    }</a>
<a name="ln481">  else</a>
<a name="ln482">    {</a>
<a name="ln483">      /* (a) Intra-area and inter-area paths are always preferred</a>
<a name="ln484">             over AS external paths.</a>
<a name="ln485"> </a>
<a name="ln486">         (b) Type 1 external paths are always preferred over type 2</a>
<a name="ln487">             external paths. When all paths are type 2 external</a>
<a name="ln488">	     paths, the paths with the smallest advertised type 2</a>
<a name="ln489">	     metric are always preferred. */</a>
<a name="ln490">      ret = ospf_route_cmp (ospf, new, or);</a>
<a name="ln491">  </a>
<a name="ln492">  /*     (c) If the new AS external path is still indistinguishable</a>
<a name="ln493">             from the current paths in the N's routing table entry,</a>
<a name="ln494">	     and RFC1583Compatibility is set to &quot;disabled&quot;, select</a>
<a name="ln495">	     the preferred paths based on the intra-AS paths to the</a>
<a name="ln496">	     ASBR/forwarding addresses, as specified in Section</a>
<a name="ln497">	     16.4.1.</a>
<a name="ln498"> </a>
<a name="ln499">         (d) If the new AS external path is still indistinguishable</a>
<a name="ln500">             from the current paths in the N's routing table entry,</a>
<a name="ln501">	     select the preferred path based on a least cost</a>
<a name="ln502">	     comparison.  Type 1 external paths are compared by</a>
<a name="ln503">	     looking at the sum of the distance to the forwarding</a>
<a name="ln504">	     address and the advertised type 1 metric (X+Y).  Type 2</a>
<a name="ln505">	     external paths advertising equal type 2 metrics are</a>
<a name="ln506">	     compared by looking at the distance to the forwarding</a>
<a name="ln507">	     addresses.</a>
<a name="ln508">  */</a>
<a name="ln509">      /* New route is better */</a>
<a name="ln510">      if (ret &lt; 0)</a>
<a name="ln511">	{</a>
<a name="ln512">	  if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln513">	    zlog_debug (&quot;Route[External]: New route is better&quot;);</a>
<a name="ln514">	  ospf_route_subst (rn, new, asbr_route);</a>
<a name="ln515">	  if (al-&gt;e[0].fwd_addr.s_addr)</a>
<a name="ln516">	    ospf_ase_complete_direct_routes (new, al-&gt;e[0].fwd_addr);</a>
<a name="ln517">	  or = new;</a>
<a name="ln518">	  new = NULL;</a>
<a name="ln519">	}</a>
<a name="ln520">      /* Old route is better */</a>
<a name="ln521">      else if (ret &gt; 0)</a>
<a name="ln522">	{</a>
<a name="ln523">	  if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln524">	    zlog_debug (&quot;Route[External]: Old route is better&quot;);</a>
<a name="ln525">	  /* do nothing */</a>
<a name="ln526">	}</a>
<a name="ln527">      /* Routes are equal */</a>
<a name="ln528">      else</a>
<a name="ln529">	{</a>
<a name="ln530">	  if (IS_DEBUG_OSPF (lsa, LSA))</a>
<a name="ln531">	    zlog_debug (&quot;Route[External]: Routes are equal&quot;);</a>
<a name="ln532">	  ospf_route_copy_nexthops (or, asbr_route-&gt;paths);</a>
<a name="ln533">	  if (al-&gt;e[0].fwd_addr.s_addr)</a>
<a name="ln534">	    ospf_ase_complete_direct_routes (or, al-&gt;e[0].fwd_addr);</a>
<a name="ln535">	}</a>
<a name="ln536">    }</a>
<a name="ln537">  /* Make sure setting newly calculated ASBR route.*/</a>
<a name="ln538">  or-&gt;u.ext.asbr = asbr_route;</a>
<a name="ln539">  if (new)</a>
<a name="ln540">    ospf_route_free (new);</a>
<a name="ln541"> </a>
<a name="ln542">  lsa-&gt;route = or;</a>
<a name="ln543">  return 0;</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">static int</a>
<a name="ln547">ospf_ase_route_match_same (struct route_table *rt, struct prefix *prefix,</a>
<a name="ln548">			   struct ospf_route *newor)</a>
<a name="ln549">{</a>
<a name="ln550">  struct route_node *rn;</a>
<a name="ln551">  struct ospf_route *or;</a>
<a name="ln552">  struct ospf_path *op;</a>
<a name="ln553">  struct ospf_path *newop;</a>
<a name="ln554">  struct listnode *n1;</a>
<a name="ln555">  struct listnode *n2;</a>
<a name="ln556"> </a>
<a name="ln557">  if (! rt || ! prefix)</a>
<a name="ln558">    return 0;</a>
<a name="ln559"> </a>
<a name="ln560">   rn = route_node_lookup (rt, prefix);</a>
<a name="ln561">   if (! rn)</a>
<a name="ln562">     return 0;</a>
<a name="ln563"> </a>
<a name="ln564">   route_unlock_node (rn);</a>
<a name="ln565"> </a>
<a name="ln566">   or = rn-&gt;info;</a>
<a name="ln567">   if (or-&gt;path_type != newor-&gt;path_type)</a>
<a name="ln568">     return 0;</a>
<a name="ln569"> </a>
<a name="ln570">   switch (or-&gt;path_type)</a>
<a name="ln571">     {</a>
<a name="ln572">     case OSPF_PATH_TYPE1_EXTERNAL:</a>
<a name="ln573">       if (or-&gt;cost != newor-&gt;cost)</a>
<a name="ln574">	 return 0;</a>
<a name="ln575">       break;</a>
<a name="ln576">     case OSPF_PATH_TYPE2_EXTERNAL:</a>
<a name="ln577">       if ((or-&gt;cost != newor-&gt;cost) ||</a>
<a name="ln578">	   (or-&gt;u.ext.type2_cost != newor-&gt;u.ext.type2_cost))</a>
<a name="ln579">	 return 0;</a>
<a name="ln580">       break;</a>
<a name="ln581">     default:</a>
<a name="ln582">       assert (0);</a>
<a name="ln583">       return 0;</a>
<a name="ln584">     }</a>
<a name="ln585">   </a>
<a name="ln586">   if (or-&gt;paths-&gt;count != newor-&gt;paths-&gt;count)</a>
<a name="ln587">     return 0;</a>
<a name="ln588">       </a>
<a name="ln589">   /* Check each path. */</a>
<a name="ln590">   for (n1 = listhead (or-&gt;paths), n2 = listhead (newor-&gt;paths);</a>
<a name="ln591">	n1 &amp;&amp; n2; n1 = listnextnode (n1), n2 = listnextnode (n2))</a>
<a name="ln592">     { </a>
<a name="ln593">       op = listgetdata (n1);</a>
<a name="ln594">       newop = listgetdata (n2);</a>
<a name="ln595">       </a>
<a name="ln596">       if (! IPV4_ADDR_SAME (&amp;op-&gt;nexthop, &amp;newop-&gt;nexthop))</a>
<a name="ln597">	 return 0;</a>
<a name="ln598">       if (op-&gt;ifindex != newop-&gt;ifindex)</a>
<a name="ln599">	 return 0;</a>
<a name="ln600">     }</a>
<a name="ln601"> </a>
<a name="ln602">   if (or-&gt;u.ext.tag != newor-&gt;u.ext.tag)</a>
<a name="ln603">     return 0;</a>
<a name="ln604"> </a>
<a name="ln605">   return 1;</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">static int</a>
<a name="ln609">ospf_ase_compare_tables (struct route_table *new_external_route,</a>
<a name="ln610">			 struct route_table *old_external_route)</a>
<a name="ln611">{</a>
<a name="ln612">  struct route_node *rn, *new_rn;</a>
<a name="ln613">  struct ospf_route *or;</a>
<a name="ln614">  </a>
<a name="ln615">  /* Remove deleted routes */</a>
<a name="ln616">  for (rn = route_top (old_external_route); rn; rn = route_next (rn))</a>
<a name="ln617">    if ((or = rn-&gt;info))</a>
<a name="ln618">      {</a>
<a name="ln619">	if (! (new_rn = route_node_lookup (new_external_route, &amp;rn-&gt;p)))</a>
<a name="ln620">	  ospf_zebra_delete ((struct prefix_ipv4 *) &amp;rn-&gt;p, or);</a>
<a name="ln621">	else</a>
<a name="ln622">	  route_unlock_node (new_rn);</a>
<a name="ln623">      }</a>
<a name="ln624">  </a>
<a name="ln625">	</a>
<a name="ln626">  /* Install new routes */</a>
<a name="ln627">  for (rn = route_top (new_external_route); rn; rn = route_next (rn))</a>
<a name="ln628">    if ((or = rn-&gt;info) != NULL)</a>
<a name="ln629">      if (! ospf_ase_route_match_same (old_external_route, &amp;rn-&gt;p, or))</a>
<a name="ln630">	ospf_zebra_add ((struct prefix_ipv4 *) &amp;rn-&gt;p, or);</a>
<a name="ln631">				       </a>
<a name="ln632">  return 0;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">static int</a>
<a name="ln636">ospf_ase_calculate_timer (struct thread *t)</a>
<a name="ln637">{</a>
<a name="ln638">  struct ospf *ospf;</a>
<a name="ln639">  struct ospf_lsa *lsa;</a>
<a name="ln640">  struct route_node *rn;</a>
<a name="ln641">  struct listnode *node;</a>
<a name="ln642">  struct ospf_area *area;</a>
<a name="ln643">  struct timeval start_time, stop_time;</a>
<a name="ln644"> </a>
<a name="ln645">  ospf = THREAD_ARG (t);</a>
<a name="ln646">  ospf-&gt;t_ase_calc = NULL;</a>
<a name="ln647"> </a>
<a name="ln648">  if (ospf-&gt;ase_calc)</a>
<a name="ln649">    {</a>
<a name="ln650">      ospf-&gt;ase_calc = 0;</a>
<a name="ln651"> </a>
<a name="ln652">      quagga_gettime(QUAGGA_CLK_MONOTONIC, &amp;start_time);</a>
<a name="ln653"> </a>
<a name="ln654">      /* Calculate external route for each AS-external-LSA */</a>
<a name="ln655">      LSDB_LOOP (EXTERNAL_LSDB (ospf), rn, lsa)</a>
<a name="ln656">	ospf_ase_calculate_route (ospf, lsa);</a>
<a name="ln657"> </a>
<a name="ln658">      /*  This version simple adds to the table all NSSA areas  */</a>
<a name="ln659">      if (ospf-&gt;anyNSSA)</a>
<a name="ln660">	for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln661">	  {</a>
<a name="ln662">	    if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln663">	      zlog_debug (&quot;ospf_ase_calculate_timer(): looking at area %s&quot;,</a>
<a name="ln664">			 inet_ntoa (area-&gt;area_id));</a>
<a name="ln665"> </a>
<a name="ln666">	    if (area-&gt;external_routing == OSPF_AREA_NSSA)</a>
<a name="ln667">	      LSDB_LOOP (NSSA_LSDB (area), rn, lsa)</a>
<a name="ln668">		ospf_ase_calculate_route (ospf, lsa);</a>
<a name="ln669">	  }</a>
<a name="ln670">      /* kevinm: And add the NSSA routes in ospf_top */</a>
<a name="ln671">      LSDB_LOOP (NSSA_LSDB (ospf),rn,lsa)</a>
<a name="ln672">      		ospf_ase_calculate_route(ospf,lsa);</a>
<a name="ln673"> </a>
<a name="ln674">      /* Compare old and new external routing table and install the</a>
<a name="ln675">	 difference info zebra/kernel */</a>
<a name="ln676">      ospf_ase_compare_tables (ospf-&gt;new_external_route,</a>
<a name="ln677">			       ospf-&gt;old_external_route);</a>
<a name="ln678"> </a>
<a name="ln679">      /* Delete old external routing table */</a>
<a name="ln680">      ospf_route_table_free (ospf-&gt;old_external_route);</a>
<a name="ln681">      ospf-&gt;old_external_route = ospf-&gt;new_external_route;</a>
<a name="ln682">      ospf-&gt;new_external_route = route_table_init ();</a>
<a name="ln683"> </a>
<a name="ln684">      quagga_gettime(QUAGGA_CLK_MONOTONIC, &amp;stop_time);</a>
<a name="ln685"> </a>
<a name="ln686">      zlog_info (&quot;SPF Processing Time(usecs): External Routes: %lld\n&quot;,</a>
<a name="ln687">		 (stop_time.tv_sec - start_time.tv_sec)*1000000LL+</a>
<a name="ln688">		 (stop_time.tv_usec - start_time.tv_usec));</a>
<a name="ln689">    }</a>
<a name="ln690">  return 0;</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">void</a>
<a name="ln694">ospf_ase_calculate_schedule (struct ospf *ospf)</a>
<a name="ln695">{</a>
<a name="ln696">  if (ospf == NULL)</a>
<a name="ln697">    return;</a>
<a name="ln698"> </a>
<a name="ln699">  ospf-&gt;ase_calc = 1;</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">void</a>
<a name="ln703">ospf_ase_calculate_timer_add (struct ospf *ospf)</a>
<a name="ln704">{</a>
<a name="ln705">  if (ospf == NULL)</a>
<a name="ln706">    return;</a>
<a name="ln707"> </a>
<a name="ln708">  if (! ospf-&gt;t_ase_calc)</a>
<a name="ln709">    ospf-&gt;t_ase_calc = thread_add_timer (master, ospf_ase_calculate_timer,</a>
<a name="ln710">					 ospf, OSPF_ASE_CALC_INTERVAL);</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">void</a>
<a name="ln714">ospf_ase_register_external_lsa (struct ospf_lsa *lsa, struct ospf *top)</a>
<a name="ln715">{</a>
<a name="ln716">  struct route_node *rn;</a>
<a name="ln717">  struct prefix_ipv4 p;</a>
<a name="ln718">  struct list *lst;</a>
<a name="ln719">  struct as_external_lsa *al;</a>
<a name="ln720"> </a>
<a name="ln721">  al = (struct as_external_lsa *) lsa-&gt;data;</a>
<a name="ln722">  p.family = AF_INET;</a>
<a name="ln723">  p.prefix = lsa-&gt;data-&gt;id;</a>
<a name="ln724">  p.prefixlen = ip_masklen (al-&gt;mask);</a>
<a name="ln725">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln726"> </a>
<a name="ln727">  rn = route_node_get (top-&gt;external_lsas, (struct prefix *) &amp;p);</a>
<a name="ln728">  if ((lst = rn-&gt;info) == NULL)</a>
<a name="ln729">    rn-&gt;info = lst = list_new();</a>
<a name="ln730">  else</a>
<a name="ln731">    route_unlock_node (rn);</a>
<a name="ln732"> </a>
<a name="ln733">  /* We assume that if LSA is deleted from DB</a>
<a name="ln734">     is is also deleted from this RT */</a>
<a name="ln735">  listnode_add (lst, ospf_lsa_lock (lsa)); /* external_lsas lst */</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">void</a>
<a name="ln739">ospf_ase_unregister_external_lsa (struct ospf_lsa *lsa, struct ospf *top)</a>
<a name="ln740">{</a>
<a name="ln741">  struct route_node *rn;</a>
<a name="ln742">  struct prefix_ipv4 p;</a>
<a name="ln743">  struct list *lst;</a>
<a name="ln744">  struct as_external_lsa *al;</a>
<a name="ln745"> </a>
<a name="ln746">  al = (struct as_external_lsa *) lsa-&gt;data;</a>
<a name="ln747">  p.family = AF_INET;</a>
<a name="ln748">  p.prefix = lsa-&gt;data-&gt;id;</a>
<a name="ln749">  p.prefixlen = ip_masklen (al-&gt;mask);</a>
<a name="ln750">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln751"> </a>
<a name="ln752">  rn = route_node_lookup (top-&gt;external_lsas, (struct prefix *) &amp;p);</a>
<a name="ln753"> </a>
<a name="ln754">  if (rn) {</a>
<a name="ln755">    lst = rn-&gt;info;</a>
<a name="ln756">    listnode_delete (lst, lsa);</a>
<a name="ln757">    ospf_lsa_unlock (&amp;lsa); /* external_lsas list */</a>
<a name="ln758">    route_unlock_node (rn);</a>
<a name="ln759">  }</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">void</a>
<a name="ln763">ospf_ase_external_lsas_finish (struct route_table *rt)</a>
<a name="ln764">{</a>
<a name="ln765">  struct route_node *rn;</a>
<a name="ln766">  struct ospf_lsa *lsa;</a>
<a name="ln767">  struct list *lst;</a>
<a name="ln768">  struct listnode *node, *nnode;</a>
<a name="ln769">  </a>
<a name="ln770">  for (rn = route_top (rt); rn; rn = route_next (rn))</a>
<a name="ln771">    if ((lst = rn-&gt;info) != NULL)</a>
<a name="ln772">      {</a>
<a name="ln773">	for (ALL_LIST_ELEMENTS (lst, node, nnode, lsa))</a>
<a name="ln774">          ospf_lsa_unlock (&amp;lsa); /* external_lsas lst */</a>
<a name="ln775">	list_delete (lst);</a>
<a name="ln776">      }</a>
<a name="ln777">    </a>
<a name="ln778">  route_table_finish (rt);</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">void</a>
<a name="ln782">ospf_ase_incremental_update (struct ospf *ospf, struct ospf_lsa *lsa)</a>
<a name="ln783">{</a>
<a name="ln784">  struct list *lsas;</a>
<a name="ln785">  struct listnode *node;</a>
<a name="ln786">  struct route_node *rn, *rn2;</a>
<a name="ln787">  struct prefix_ipv4 p;</a>
<a name="ln788">  struct route_table *tmp_old;</a>
<a name="ln789">  struct as_external_lsa *al;</a>
<a name="ln790"> </a>
<a name="ln791">  al = (struct as_external_lsa *) lsa-&gt;data;</a>
<a name="ln792">  p.family = AF_INET;</a>
<a name="ln793">  p.prefix = lsa-&gt;data-&gt;id;</a>
<a name="ln794">  p.prefixlen = ip_masklen (al-&gt;mask);</a>
<a name="ln795">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln796"> </a>
<a name="ln797">  /* if new_table is NULL, there was no spf calculation, thus</a>
<a name="ln798">     incremental update is unneeded */</a>
<a name="ln799">  if (!ospf-&gt;new_table)</a>
<a name="ln800">    return;</a>
<a name="ln801">  </a>
<a name="ln802">  /* If there is already an intra-area or inter-area route</a>
<a name="ln803">     to the destination, no recalculation is necessary</a>
<a name="ln804">     (internal routes take precedence). */</a>
<a name="ln805">  </a>
<a name="ln806">  rn = route_node_lookup (ospf-&gt;new_table, (struct prefix *) &amp;p);</a>
<a name="ln807">  if (rn)</a>
<a name="ln808">    {</a>
<a name="ln809">      route_unlock_node (rn);</a>
<a name="ln810">      if (rn-&gt;info)</a>
<a name="ln811">	return;</a>
<a name="ln812">    }</a>
<a name="ln813"> </a>
<a name="ln814">  rn = route_node_lookup (ospf-&gt;external_lsas, (struct prefix *) &amp;p);</a>
<a name="ln815">  assert (rn); </a>
<a name="ln816">  assert (rn-&gt;info);</a>
<a name="ln817">  lsas = rn-&gt;info;</a>
<a name="ln818">  route_unlock_node (rn);</a>
<a name="ln819"> </a>
<a name="ln820">  for (ALL_LIST_ELEMENTS_RO (lsas, node, lsa))</a>
<a name="ln821">    ospf_ase_calculate_route (ospf, lsa);</a>
<a name="ln822"> </a>
<a name="ln823">  /* prepare temporary old routing table for compare */</a>
<a name="ln824">  tmp_old = route_table_init ();</a>
<a name="ln825">  rn = route_node_lookup (ospf-&gt;old_external_route, (struct prefix *) &amp;p);</a>
<a name="ln826">  if (rn &amp;&amp; rn-&gt;info)</a>
<a name="ln827">    {</a>
<a name="ln828">      rn2 = route_node_get (tmp_old, (struct prefix *) &amp;p);</a>
<a name="ln829">      rn2-&gt;info = rn-&gt;info;</a>
<a name="ln830">      route_unlock_node (rn);</a>
<a name="ln831">    }</a>
<a name="ln832"> </a>
<a name="ln833">  /* install changes to zebra */</a>
<a name="ln834">  ospf_ase_compare_tables (ospf-&gt;new_external_route, tmp_old);</a>
<a name="ln835"> </a>
<a name="ln836">  /* update ospf-&gt;old_external_route table */</a>
<a name="ln837">  if (rn &amp;&amp; rn-&gt;info)</a>
<a name="ln838">    ospf_route_free ((struct ospf_route *) rn-&gt;info);</a>
<a name="ln839"> </a>
<a name="ln840">  rn2 = route_node_lookup (ospf-&gt;new_external_route, (struct prefix *) &amp;p);</a>
<a name="ln841">  /* if new route exists, install it to ospf-&gt;old_external_route */</a>
<a name="ln842">  if (rn2 &amp;&amp; rn2-&gt;info)</a>
<a name="ln843">    {</a>
<a name="ln844">      if (!rn)</a>
<a name="ln845">	rn = route_node_get (ospf-&gt;old_external_route, (struct prefix *) &amp;p);</a>
<a name="ln846">      rn-&gt;info = rn2-&gt;info;</a>
<a name="ln847">    }</a>
<a name="ln848">  else</a>
<a name="ln849">    {</a>
<a name="ln850">      /* remove route node from ospf-&gt;old_external_route */</a>
<a name="ln851">      if (rn)</a>
<a name="ln852">	{</a>
<a name="ln853">	  rn-&gt;info = NULL;</a>
<a name="ln854">	  route_unlock_node (rn);</a>
<a name="ln855">	}</a>
<a name="ln856">    }</a>
<a name="ln857"> </a>
<a name="ln858">  if (rn2)</a>
<a name="ln859">    {</a>
<a name="ln860">      /* rn2-&gt;info is stored in route node of ospf-&gt;old_external_route */</a>
<a name="ln861">      rn2-&gt;info = NULL;</a>
<a name="ln862">      route_unlock_node (rn2);</a>
<a name="ln863">      route_unlock_node (rn2);</a>
<a name="ln864">    }</a>
<a name="ln865"> </a>
<a name="ln866">  route_table_finish (tmp_old);</a>
<a name="ln867">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="586"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'or->paths' pointer was utilized before it was verified against nullptr. Check lines: 586, 590.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
