
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_flood.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF Flooding -- RFC2328 Section 13.</a>
<a name="ln3"> * Copyright (C) 1999, 2000 Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> * </a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln8"> * it under the terms of the GNU General Public License as published</a>
<a name="ln9"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln10"> * option) any later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln20"> * Boston, MA 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;linklist.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;if.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29">#include &quot;table.h&quot;</a>
<a name="ln30">#include &quot;thread.h&quot;</a>
<a name="ln31">#include &quot;memory.h&quot;</a>
<a name="ln32">#include &quot;log.h&quot;</a>
<a name="ln33">#include &quot;zclient.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln36">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_abr.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln48">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln49">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">extern struct zclient *zclient;</a>
<a name="ln52"> </a>
<a name="ln53">/* Do the LSA acking specified in table 19, Section 13.5, row 2</a>
<a name="ln54"> * This get called from ospf_flood_out_interface. Declared inline </a>
<a name="ln55"> * for speed. */</a>
<a name="ln56">static void</a>
<a name="ln57">ospf_flood_delayed_lsa_ack (struct ospf_neighbor *inbr, struct ospf_lsa *lsa)</a>
<a name="ln58">{</a>
<a name="ln59">  /* LSA is more recent than database copy, but was not</a>
<a name="ln60">     flooded back out receiving interface.  Delayed</a>
<a name="ln61">     acknowledgment sent. If interface is in Backup state</a>
<a name="ln62">     delayed acknowledgment sent only if advertisement</a>
<a name="ln63">     received from Designated Router, otherwise do nothing See</a>
<a name="ln64">     RFC 2328 Section 13.5 */</a>
<a name="ln65"> </a>
<a name="ln66">  /* Whether LSA is more recent or not, and whether this is in</a>
<a name="ln67">     response to the LSA being sent out recieving interface has been </a>
<a name="ln68">     worked out previously */</a>
<a name="ln69"> </a>
<a name="ln70">  /* Deal with router as BDR */</a>
<a name="ln71">  if (inbr-&gt;oi-&gt;state == ISM_Backup &amp;&amp; ! NBR_IS_DR (inbr))</a>
<a name="ln72">    return;</a>
<a name="ln73"> </a>
<a name="ln74">  /* Schedule a delayed LSA Ack to be sent */ </a>
<a name="ln75">  listnode_add (inbr-&gt;oi-&gt;ls_ack, ospf_lsa_lock (lsa)); /* delayed LSA Ack */</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">/* Check LSA is related to external info. */</a>
<a name="ln79">struct external_info *</a>
<a name="ln80">ospf_external_info_check (struct ospf_lsa *lsa)</a>
<a name="ln81">{</a>
<a name="ln82">  struct as_external_lsa *al;</a>
<a name="ln83">  struct prefix_ipv4 p;</a>
<a name="ln84">  struct route_node *rn;</a>
<a name="ln85">  int type;</a>
<a name="ln86"> </a>
<a name="ln87">  al = (struct as_external_lsa *) lsa-&gt;data;</a>
<a name="ln88"> </a>
<a name="ln89">  p.family = AF_INET;</a>
<a name="ln90">  p.prefix = lsa-&gt;data-&gt;id;</a>
<a name="ln91">  p.prefixlen = ip_masklen (al-&gt;mask);</a>
<a name="ln92"> </a>
<a name="ln93">  for (type = 0; type &lt;= ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln94">    {</a>
<a name="ln95">      int redist_type = is_prefix_default (&amp;p) ? DEFAULT_ROUTE : type;</a>
<a name="ln96">      if (ospf_is_type_redistributed (redist_type))</a>
<a name="ln97">	if (EXTERNAL_INFO (type))</a>
<a name="ln98">	  {</a>
<a name="ln99">	    rn = route_node_lookup (EXTERNAL_INFO (type),</a>
<a name="ln100">				    (struct prefix *) &amp;p);</a>
<a name="ln101">	    if (rn)</a>
<a name="ln102">	      {</a>
<a name="ln103">		route_unlock_node (rn);</a>
<a name="ln104">		if (rn-&gt;info != NULL)</a>
<a name="ln105">		  return (struct external_info *) rn-&gt;info;</a>
<a name="ln106">	      }</a>
<a name="ln107">	  }</a>
<a name="ln108">    }</a>
<a name="ln109"> </a>
<a name="ln110">  return NULL;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">static void</a>
<a name="ln114">ospf_process_self_originated_lsa (struct ospf *ospf,</a>
<a name="ln115">				  struct ospf_lsa *new, struct ospf_area *area)</a>
<a name="ln116">{</a>
<a name="ln117">  struct ospf_interface *oi;</a>
<a name="ln118">  struct external_info *ei;</a>
<a name="ln119">  struct listnode *node;</a>
<a name="ln120">  </a>
<a name="ln121">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln122">    zlog_debug (&quot;LSA[Type%d:%s]: Process self-originated LSA seq 0x%x&quot;,</a>
<a name="ln123">	       new-&gt;data-&gt;type, inet_ntoa (new-&gt;data-&gt;id), </a>
<a name="ln124">	       ntohl(new-&gt;data-&gt;ls_seqnum));</a>
<a name="ln125"> </a>
<a name="ln126">  /* If we're here, we installed a self-originated LSA that we received</a>
<a name="ln127">     from a neighbor, i.e. it's more recent.  We must see whether we want</a>
<a name="ln128">     to originate it.</a>
<a name="ln129">     If yes, we should use this LSA's sequence number and reoriginate</a>
<a name="ln130">     a new instance.</a>
<a name="ln131">     if not --- we must flush this LSA from the domain. */</a>
<a name="ln132">  switch (new-&gt;data-&gt;type)</a>
<a name="ln133">    {</a>
<a name="ln134">    case OSPF_ROUTER_LSA:</a>
<a name="ln135">      /* Originate a new instance and schedule flooding */</a>
<a name="ln136">      if (area-&gt;router_lsa_self)</a>
<a name="ln137">	area-&gt;router_lsa_self-&gt;data-&gt;ls_seqnum = new-&gt;data-&gt;ls_seqnum;</a>
<a name="ln138">      ospf_router_lsa_update_area (area);</a>
<a name="ln139">      return;</a>
<a name="ln140">    case OSPF_NETWORK_LSA:</a>
<a name="ln141">    case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln142">      /* We must find the interface the LSA could belong to.</a>
<a name="ln143">	 If the interface is no more a broadcast type or we are no more</a>
<a name="ln144">	 the DR, we flush the LSA otherwise -- create the new instance and</a>
<a name="ln145">	 schedule flooding. */</a>
<a name="ln146"> </a>
<a name="ln147">      /* Look through all interfaces, not just area, since interface</a>
<a name="ln148">	 could be moved from one area to another. */</a>
<a name="ln149">      for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, node, oi))</a>
<a name="ln150">	/* These are sanity check. */</a>
<a name="ln151">        if (IPV4_ADDR_SAME (&amp;oi-&gt;address-&gt;u.prefix4, &amp;new-&gt;data-&gt;id))</a>
<a name="ln152">          {</a>
<a name="ln153">            if (oi-&gt;area != area ||</a>
<a name="ln154">                oi-&gt;type != OSPF_IFTYPE_BROADCAST ||</a>
<a name="ln155">                !IPV4_ADDR_SAME (&amp;oi-&gt;address-&gt;u.prefix4, &amp;DR (oi)))</a>
<a name="ln156">              {</a>
<a name="ln157">                ospf_schedule_lsa_flush_area (area, new);</a>
<a name="ln158">                return;</a>
<a name="ln159">              }</a>
<a name="ln160">            </a>
<a name="ln161">            if (new-&gt;data-&gt;type == OSPF_OPAQUE_LINK_LSA)</a>
<a name="ln162">              {</a>
<a name="ln163">                ospf_opaque_lsa_refresh (new);</a>
<a name="ln164">                return;</a>
<a name="ln165">              }</a>
<a name="ln166"> </a>
<a name="ln167">            if (oi-&gt;network_lsa_self)</a>
<a name="ln168">	      oi-&gt;network_lsa_self-&gt;data-&gt;ls_seqnum = new-&gt;data-&gt;ls_seqnum;</a>
<a name="ln169">            /* Schedule network-LSA origination. */</a>
<a name="ln170">            ospf_network_lsa_update (oi);</a>
<a name="ln171">            return;</a>
<a name="ln172">          }</a>
<a name="ln173">      break;</a>
<a name="ln174">    case OSPF_SUMMARY_LSA:</a>
<a name="ln175">    case OSPF_ASBR_SUMMARY_LSA:</a>
<a name="ln176">      ospf_schedule_abr_task (ospf);</a>
<a name="ln177">      break;</a>
<a name="ln178">    case OSPF_AS_EXTERNAL_LSA :</a>
<a name="ln179">    case OSPF_AS_NSSA_LSA:</a>
<a name="ln180">       if ( (new-&gt;data-&gt;type == OSPF_AS_EXTERNAL_LSA)</a>
<a name="ln181">             &amp;&amp; CHECK_FLAG (new-&gt;flags, OSPF_LSA_LOCAL_XLT))</a>
<a name="ln182">         {</a>
<a name="ln183">           ospf_translated_nssa_refresh (ospf, NULL, new);</a>
<a name="ln184">           return;</a>
<a name="ln185">         }</a>
<a name="ln186">      ei = ospf_external_info_check (new);</a>
<a name="ln187">      if (ei)</a>
<a name="ln188">        ospf_external_lsa_refresh (ospf, new, ei, LSA_REFRESH_FORCE);</a>
<a name="ln189">      else</a>
<a name="ln190">        ospf_lsa_flush_as (ospf, new);</a>
<a name="ln191">      break;</a>
<a name="ln192">    case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln193">      ospf_opaque_lsa_refresh (new);</a>
<a name="ln194">      break;</a>
<a name="ln195">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln196">      ospf_opaque_lsa_refresh (new); /* Reconsideration may needed. *//* XXX */</a>
<a name="ln197">      break;</a>
<a name="ln198">    default:</a>
<a name="ln199">      break;</a>
<a name="ln200">    }</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">/* OSPF LSA flooding -- RFC2328 Section 13.(5). */</a>
<a name="ln204"> </a>
<a name="ln205">/* Now Updated for NSSA operation, as follows:</a>
<a name="ln206"> </a>
<a name="ln207"> </a>
<a name="ln208">	Type-5's have no change.  Blocked to STUB or NSSA.</a>
<a name="ln209"> </a>
<a name="ln210">	Type-7's can be received, and if a DR</a>
<a name="ln211">	they will also flood the local NSSA Area as Type-7's</a>
<a name="ln212"> </a>
<a name="ln213">	If a Self-Originated LSA (now an ASBR), </a>
<a name="ln214">	The LSDB will be updated as Type-5's, (for continual re-fresh)</a>
<a name="ln215"> </a>
<a name="ln216">	    If an NSSA-IR it is installed/flooded as Type-7, P-bit on.</a>
<a name="ln217">	    if an NSSA-ABR it is installed/flooded as Type-7, P-bit off.</a>
<a name="ln218"> </a>
<a name="ln219">	Later, during the ABR TASK, if the ABR is the Elected NSSA</a>
<a name="ln220">	translator, then All Type-7s (with P-bit ON) are Translated to</a>
<a name="ln221">	Type-5's and flooded to all non-NSSA/STUB areas.</a>
<a name="ln222"> </a>
<a name="ln223">	During ASE Calculations, </a>
<a name="ln224">	    non-ABRs calculate external routes from Type-7's</a>
<a name="ln225">	    ABRs calculate external routes from Type-5's and non-self Type-7s</a>
<a name="ln226">*/</a>
<a name="ln227">int</a>
<a name="ln228">ospf_flood (struct ospf *ospf, struct ospf_neighbor *nbr,</a>
<a name="ln229">	    struct ospf_lsa *current, struct ospf_lsa *new)</a>
<a name="ln230">{</a>
<a name="ln231">  struct ospf_interface *oi;</a>
<a name="ln232">  int lsa_ack_flag;</a>
<a name="ln233"> </a>
<a name="ln234">  /* Type-7 LSA's will be flooded throughout their native NSSA area,</a>
<a name="ln235">     but will also be flooded as Type-5's into ABR capable links.  */</a>
<a name="ln236"> </a>
<a name="ln237">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln238">    zlog_debug (&quot;LSA[Flooding]: start, NBR %s (%s), cur(%p), New-LSA[%s]&quot;,</a>
<a name="ln239">               inet_ntoa (nbr-&gt;router_id),</a>
<a name="ln240">               LOOKUP (ospf_nsm_state_msg, nbr-&gt;state),</a>
<a name="ln241">               (void *)current,</a>
<a name="ln242">               dump_lsa_key (new));</a>
<a name="ln243"> </a>
<a name="ln244">  lsa_ack_flag = 0;</a>
<a name="ln245">  oi = nbr-&gt;oi;</a>
<a name="ln246"> </a>
<a name="ln247">  /* If there is already a database copy, and if the</a>
<a name="ln248">     database copy was received via flooding and installed less</a>
<a name="ln249">     than MinLSArrival seconds ago, discard the new LSA</a>
<a name="ln250">     (without acknowledging it). */</a>
<a name="ln251">  if (current != NULL)		/* -- endo. */</a>
<a name="ln252">    {</a>
<a name="ln253">      if (IS_LSA_SELF (current)</a>
<a name="ln254">      &amp;&amp; (ntohs (current-&gt;data-&gt;ls_age)    == 0</a>
<a name="ln255">      &amp;&amp;  ntohl (current-&gt;data-&gt;ls_seqnum) == OSPF_INITIAL_SEQUENCE_NUMBER))</a>
<a name="ln256">        {</a>
<a name="ln257">          if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln258">	    zlog_debug (&quot;LSA[Flooding]: Got a self-originated LSA, &quot;</a>
<a name="ln259">		       &quot;while local one is initial instance.&quot;);</a>
<a name="ln260">          ; /* Accept this LSA for quick LSDB resynchronization. */</a>
<a name="ln261">        }</a>
<a name="ln262">      else if (tv_cmp (tv_sub (recent_relative_time (), current-&gt;tv_recv),</a>
<a name="ln263">	               msec2tv (ospf-&gt;min_ls_arrival)) &lt; 0)</a>
<a name="ln264">        {</a>
<a name="ln265">          if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln266">	    zlog_debug (&quot;LSA[Flooding]: LSA is received recently.&quot;);</a>
<a name="ln267">          return -1;</a>
<a name="ln268">        }</a>
<a name="ln269">    }</a>
<a name="ln270"> </a>
<a name="ln271">  /* Flood the new LSA out some subset of the router's interfaces.</a>
<a name="ln272">     In some cases (e.g., the state of the receiving interface is</a>
<a name="ln273">     DR and the LSA was received from a router other than the</a>
<a name="ln274">     Backup DR) the LSA will be flooded back out the receiving</a>
<a name="ln275">     interface. */</a>
<a name="ln276">  lsa_ack_flag = ospf_flood_through (ospf, nbr, new);</a>
<a name="ln277"> </a>
<a name="ln278">  /* Remove the current database copy from all neighbors' Link state</a>
<a name="ln279">     retransmission lists.  AS_EXTERNAL and AS_EXTERNAL_OPAQUE does</a>
<a name="ln280">                                        ^^^^^^^^^^^^^^^^^^^^^^^</a>
<a name="ln281">     not have area ID.</a>
<a name="ln282">     All other (even NSSA's) do have area ID.  */</a>
<a name="ln283">  if (current)</a>
<a name="ln284">    {</a>
<a name="ln285">      switch (current-&gt;data-&gt;type)</a>
<a name="ln286">        {</a>
<a name="ln287">        case OSPF_AS_EXTERNAL_LSA:</a>
<a name="ln288">        case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln289">          ospf_ls_retransmit_delete_nbr_as (ospf, current);</a>
<a name="ln290">          break;</a>
<a name="ln291">        default:</a>
<a name="ln292">          ospf_ls_retransmit_delete_nbr_area (nbr-&gt;oi-&gt;area, current);</a>
<a name="ln293">          break;</a>
<a name="ln294">        }</a>
<a name="ln295">    }</a>
<a name="ln296"> </a>
<a name="ln297">  /* Do some internal house keeping that is needed here */</a>
<a name="ln298">  SET_FLAG (new-&gt;flags, OSPF_LSA_RECEIVED);</a>
<a name="ln299">  ospf_lsa_is_self_originated (ospf, new); /* Let it set the flag */</a>
<a name="ln300"> </a>
<a name="ln301">  /* Install the new LSA in the link state database</a>
<a name="ln302">     (replacing the current database copy).  This may cause the</a>
<a name="ln303">     routing table calculation to be scheduled.  In addition,</a>
<a name="ln304">     timestamp the new LSA with the current time.  The flooding</a>
<a name="ln305">     procedure cannot overwrite the newly installed LSA until</a>
<a name="ln306">     MinLSArrival seconds have elapsed. */  </a>
<a name="ln307"> </a>
<a name="ln308">  if (! (new = ospf_lsa_install (ospf, nbr-&gt;oi, new)))</a>
<a name="ln309">    return -1; /* unknown LSA type or any other error condition */</a>
<a name="ln310"> </a>
<a name="ln311">  /* Acknowledge the receipt of the LSA by sending a Link State</a>
<a name="ln312">     Acknowledgment packet back out the receiving interface. */</a>
<a name="ln313">  if (lsa_ack_flag)</a>
<a name="ln314">    ospf_flood_delayed_lsa_ack (nbr, new);     </a>
<a name="ln315"> </a>
<a name="ln316">  /* If this new LSA indicates that it was originated by the</a>
<a name="ln317">     receiving router itself, the router must take special action,</a>
<a name="ln318">     either updating the LSA or in some cases flushing it from</a>
<a name="ln319">     the routing domain. */</a>
<a name="ln320">  if (ospf_lsa_is_self_originated (ospf, new))</a>
<a name="ln321">    ospf_process_self_originated_lsa (ospf, new, oi-&gt;area);</a>
<a name="ln322">  else</a>
<a name="ln323">    /* Update statistics value for OSPF-MIB. */</a>
<a name="ln324">    ospf-&gt;rx_lsa_count++;</a>
<a name="ln325"> </a>
<a name="ln326">  return 0;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">/* OSPF LSA flooding -- RFC2328 Section 13.3. */</a>
<a name="ln330">static int</a>
<a name="ln331">ospf_flood_through_interface (struct ospf_interface *oi,</a>
<a name="ln332">			      struct ospf_neighbor *inbr,</a>
<a name="ln333">			      struct ospf_lsa *lsa)</a>
<a name="ln334">{</a>
<a name="ln335">  struct ospf_neighbor *onbr;</a>
<a name="ln336">  struct route_node *rn;</a>
<a name="ln337">  int retx_flag;</a>
<a name="ln338"> </a>
<a name="ln339">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln340">    zlog_debug (&quot;ospf_flood_through_interface(): &quot;</a>
<a name="ln341">	       &quot;considering int %s, INBR(%s), LSA[%s]&quot;,</a>
<a name="ln342">	       IF_NAME (oi), inbr ? inet_ntoa (inbr-&gt;router_id) : &quot;NULL&quot;,</a>
<a name="ln343">               dump_lsa_key (lsa));</a>
<a name="ln344"> </a>
<a name="ln345">  if (!ospf_if_is_enable (oi))</a>
<a name="ln346">    return 0;</a>
<a name="ln347"> </a>
<a name="ln348">  /* Remember if new LSA is aded to a retransmit list. */</a>
<a name="ln349">  retx_flag = 0;</a>
<a name="ln350"> </a>
<a name="ln351">  /* Each of the neighbors attached to this interface are examined,</a>
<a name="ln352">     to determine whether they must receive the new LSA.  The following</a>
<a name="ln353">     steps are executed for each neighbor: */</a>
<a name="ln354">  for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln355">    {</a>
<a name="ln356">      struct ospf_lsa *ls_req;</a>
<a name="ln357"> </a>
<a name="ln358">      if (rn-&gt;info == NULL)</a>
<a name="ln359">	continue;</a>
<a name="ln360"> </a>
<a name="ln361">      onbr = rn-&gt;info;</a>
<a name="ln362">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln363">	zlog_debug (&quot;ospf_flood_through_interface(): considering nbr %s (%s)&quot;,</a>
<a name="ln364">		   inet_ntoa (onbr-&gt;router_id),</a>
<a name="ln365">                   LOOKUP (ospf_nsm_state_msg, onbr-&gt;state));</a>
<a name="ln366"> </a>
<a name="ln367">      /* If the neighbor is in a lesser state than Exchange, it</a>
<a name="ln368">	 does not participate in flooding, and the next neighbor</a>
<a name="ln369">	 should be examined. */</a>
<a name="ln370">      if (onbr-&gt;state &lt; NSM_Exchange)</a>
<a name="ln371">	continue;</a>
<a name="ln372"> </a>
<a name="ln373">      /* If the adjacency is not yet full (neighbor state is</a>
<a name="ln374">	 Exchange or Loading), examine the Link state request</a>
<a name="ln375">	 list associated with this adjacency.  If there is an</a>
<a name="ln376">	 instance of the new LSA on the list, it indicates that</a>
<a name="ln377">	 the neighboring router has an instance of the LSA</a>
<a name="ln378">	 already.  Compare the new LSA to the neighbor's copy: */</a>
<a name="ln379">      if (onbr-&gt;state &lt; NSM_Full)</a>
<a name="ln380">	{</a>
<a name="ln381">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln382">	    zlog_debug (&quot;ospf_flood_through_interface(): nbr adj is not Full&quot;);</a>
<a name="ln383">	  ls_req = ospf_ls_request_lookup (onbr, lsa);</a>
<a name="ln384">	  if (ls_req != NULL)</a>
<a name="ln385">	    {</a>
<a name="ln386">	      int ret;</a>
<a name="ln387"> </a>
<a name="ln388">	      ret = ospf_lsa_more_recent (ls_req, lsa);</a>
<a name="ln389">	      /* The new LSA is less recent. */</a>
<a name="ln390">	      if (ret &gt; 0)</a>
<a name="ln391">		continue;</a>
<a name="ln392">	      /* The two copies are the same instance, then delete</a>
<a name="ln393">		 the LSA from the Link state request list. */</a>
<a name="ln394">	      else if (ret == 0)</a>
<a name="ln395">		{</a>
<a name="ln396">		  ospf_ls_request_delete (onbr, ls_req);</a>
<a name="ln397">		  ospf_check_nbr_loading (onbr);</a>
<a name="ln398">		  continue;</a>
<a name="ln399">		}</a>
<a name="ln400">	      /* The new LSA is more recent.  Delete the LSA</a>
<a name="ln401">		 from the Link state request list. */</a>
<a name="ln402">	      else</a>
<a name="ln403">		{</a>
<a name="ln404">		  ospf_ls_request_delete (onbr, ls_req);</a>
<a name="ln405">		  ospf_check_nbr_loading (onbr);</a>
<a name="ln406">		}</a>
<a name="ln407">	    }</a>
<a name="ln408">	}</a>
<a name="ln409"> </a>
<a name="ln410">      if (IS_OPAQUE_LSA (lsa-&gt;data-&gt;type))</a>
<a name="ln411">        {</a>
<a name="ln412">          if (! CHECK_FLAG (onbr-&gt;options, OSPF_OPTION_O))</a>
<a name="ln413">            {</a>
<a name="ln414">              if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))</a>
<a name="ln415">                zlog_debug (&quot;Skip this neighbor: Not Opaque-capable.&quot;);</a>
<a name="ln416">              continue;</a>
<a name="ln417">            }</a>
<a name="ln418">        }</a>
<a name="ln419"> </a>
<a name="ln420">      /* If the new LSA was received from this neighbor,</a>
<a name="ln421">	 examine the next neighbor. */</a>
<a name="ln422">#ifdef ORIGINAL_CODING</a>
<a name="ln423">      if (inbr)</a>
<a name="ln424">	if (IPV4_ADDR_SAME (&amp;inbr-&gt;router_id, &amp;onbr-&gt;router_id))</a>
<a name="ln425">	  continue;</a>
<a name="ln426">#else /* ORIGINAL_CODING */</a>
<a name="ln427">      if (inbr)</a>
<a name="ln428">        {</a>
<a name="ln429">          /*</a>
<a name="ln430">           * Triggered by LSUpd message parser &quot;ospf_ls_upd ()&quot;.</a>
<a name="ln431">           * E.g., all LSAs handling here is received via network.</a>
<a name="ln432">           */</a>
<a name="ln433">          if (IPV4_ADDR_SAME (&amp;inbr-&gt;router_id, &amp;onbr-&gt;router_id))</a>
<a name="ln434">            {</a>
<a name="ln435">              if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))</a>
<a name="ln436">                zlog_debug (&quot;Skip this neighbor: inbr == onbr&quot;);</a>
<a name="ln437">              continue;</a>
<a name="ln438">            }</a>
<a name="ln439">        }</a>
<a name="ln440">      else</a>
<a name="ln441">        {</a>
<a name="ln442">          /*</a>
<a name="ln443">           * Triggered by MaxAge remover, so far.</a>
<a name="ln444">           * NULL &quot;inbr&quot; means flooding starts from this node.</a>
<a name="ln445">           */</a>
<a name="ln446">          if (IPV4_ADDR_SAME (&amp;lsa-&gt;data-&gt;adv_router, &amp;onbr-&gt;router_id))</a>
<a name="ln447">            {</a>
<a name="ln448">              if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))</a>
<a name="ln449">                zlog_debug (&quot;Skip this neighbor: lsah-&gt;adv_router == onbr&quot;);</a>
<a name="ln450">              continue;</a>
<a name="ln451">            }</a>
<a name="ln452">        }</a>
<a name="ln453">#endif /* ORIGINAL_CODING */</a>
<a name="ln454"> </a>
<a name="ln455">      /* Add the new LSA to the Link state retransmission list</a>
<a name="ln456">	 for the adjacency. The LSA will be retransmitted</a>
<a name="ln457">	 at intervals until an acknowledgment is seen from</a>
<a name="ln458">	 the neighbor. */</a>
<a name="ln459">      ospf_ls_retransmit_add (onbr, lsa);</a>
<a name="ln460">      retx_flag = 1;</a>
<a name="ln461">    }</a>
<a name="ln462"> </a>
<a name="ln463">  /* If in the previous step, the LSA was NOT added to any of</a>
<a name="ln464">     the Link state retransmission lists, there is no need to</a>
<a name="ln465">     flood the LSA out the interface. */</a>
<a name="ln466">  if (retx_flag == 0) </a>
<a name="ln467">    {</a>
<a name="ln468">      return (inbr &amp;&amp; inbr-&gt;oi == oi);</a>
<a name="ln469">    }</a>
<a name="ln470"> </a>
<a name="ln471">  /* if we've received the lsa on this interface we need to perform</a>
<a name="ln472">     additional checking */</a>
<a name="ln473">  if (inbr &amp;&amp; (inbr-&gt;oi == oi))</a>
<a name="ln474">    {</a>
<a name="ln475">      /* If the new LSA was received on this interface, and it was</a>
<a name="ln476">	 received from either the Designated Router or the Backup</a>
<a name="ln477">	 Designated Router, chances are that all the neighbors have</a>
<a name="ln478">	 received the LSA already. */</a>
<a name="ln479">      if (NBR_IS_DR (inbr) || NBR_IS_BDR (inbr))</a>
<a name="ln480">	{</a>
<a name="ln481">	  if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln482">	    zlog_debug (&quot;ospf_flood_through_interface(): &quot;</a>
<a name="ln483">		       &quot;DR/BDR NOT SEND to int %s&quot;, IF_NAME (oi));</a>
<a name="ln484">	  return 1;</a>
<a name="ln485">	}</a>
<a name="ln486">	  </a>
<a name="ln487">      /* If the new LSA was received on this interface, and the</a>
<a name="ln488">	 interface state is Backup, examine the next interface.  The</a>
<a name="ln489">	 Designated Router will do the flooding on this interface.</a>
<a name="ln490">	 However, if the Designated Router fails the router will</a>
<a name="ln491">	 end up retransmitting the updates. */</a>
<a name="ln492"> </a>
<a name="ln493">      if (oi-&gt;state == ISM_Backup)</a>
<a name="ln494">	{</a>
<a name="ln495">	  if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln496">	    zlog_debug (&quot;ospf_flood_through_interface(): &quot;</a>
<a name="ln497">		       &quot;ISM_Backup NOT SEND to int %s&quot;, IF_NAME (oi));</a>
<a name="ln498">	  return 1;</a>
<a name="ln499">	}</a>
<a name="ln500">    }</a>
<a name="ln501"> </a>
<a name="ln502">  /* The LSA must be flooded out the interface. Send a Link State</a>
<a name="ln503">     Update packet (including the new LSA as contents) out the</a>
<a name="ln504">     interface.  The LSA's LS age must be incremented by InfTransDelay</a>
<a name="ln505">     (which	must be	&gt; 0) when it is copied into the outgoing Link</a>
<a name="ln506">     State Update packet (until the LS age field reaches the maximum</a>
<a name="ln507">     value of MaxAge). */</a>
<a name="ln508">  /* XXX HASSO: Is this IS_DEBUG_OSPF_NSSA really correct? */</a>
<a name="ln509">  if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln510">    zlog_debug (&quot;ospf_flood_through_interface(): &quot;</a>
<a name="ln511">	       &quot;DR/BDR sending upd to int %s&quot;, IF_NAME (oi));</a>
<a name="ln512"> </a>
<a name="ln513">  /*  RFC2328  Section 13.3</a>
<a name="ln514">      On non-broadcast networks, separate	Link State Update</a>
<a name="ln515">      packets must be sent, as unicasts, to each adjacent	neighbor</a>
<a name="ln516">      (i.e., those in state Exchange or greater).	 The destination</a>
<a name="ln517">      IP addresses for these packets are the neighbors' IP</a>
<a name="ln518">      addresses.   */</a>
<a name="ln519">  if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln520">    {</a>
<a name="ln521">      struct route_node *rn;</a>
<a name="ln522">      struct ospf_neighbor *nbr;</a>
<a name="ln523"> </a>
<a name="ln524">      for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln525">        if ((nbr = rn-&gt;info) != NULL)</a>
<a name="ln526">	  if (nbr != oi-&gt;nbr_self &amp;&amp; nbr-&gt;state &gt;= NSM_Exchange)</a>
<a name="ln527">	    ospf_ls_upd_send_lsa (nbr, lsa, OSPF_SEND_PACKET_DIRECT);</a>
<a name="ln528">    }</a>
<a name="ln529">  else</a>
<a name="ln530">    ospf_ls_upd_send_lsa (oi-&gt;nbr_self, lsa, OSPF_SEND_PACKET_INDIRECT);</a>
<a name="ln531"> </a>
<a name="ln532">  return 0;</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">int</a>
<a name="ln536">ospf_flood_through_area (struct ospf_area *area,</a>
<a name="ln537">			 struct ospf_neighbor *inbr, struct ospf_lsa *lsa)</a>
<a name="ln538">{</a>
<a name="ln539">  struct listnode *node, *nnode;</a>
<a name="ln540">  struct ospf_interface *oi;</a>
<a name="ln541">  int lsa_ack_flag = 0;</a>
<a name="ln542"> </a>
<a name="ln543">  /* All other types are specific to a single area (Area A).  The</a>
<a name="ln544">     eligible interfaces are all those interfaces attaching to the</a>
<a name="ln545">     Area A.  If Area A is the backbone, this includes all the virtual</a>
<a name="ln546">     links.  */</a>
<a name="ln547">  for (ALL_LIST_ELEMENTS (area-&gt;oiflist, node, nnode, oi))</a>
<a name="ln548">    {</a>
<a name="ln549">      if (area-&gt;area_id.s_addr != OSPF_AREA_BACKBONE &amp;&amp;</a>
<a name="ln550">	  oi-&gt;type ==  OSPF_IFTYPE_VIRTUALLINK) </a>
<a name="ln551">	continue;</a>
<a name="ln552"> </a>
<a name="ln553">      if ((lsa-&gt;data-&gt;type == OSPF_OPAQUE_LINK_LSA) &amp;&amp; (lsa-&gt;oi != oi))</a>
<a name="ln554">        {</a>
<a name="ln555">          /*</a>
<a name="ln556">           * Link local scoped Opaque-LSA should only be flooded</a>
<a name="ln557">           * for the link on which the LSA has received.</a>
<a name="ln558">           */</a>
<a name="ln559">          if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))</a>
<a name="ln560">            zlog_debug (&quot;Type-9 Opaque-LSA: lsa-&gt;oi(%p) != oi(%p)&quot;,</a>
<a name="ln561">                        (void *)lsa-&gt;oi, (void *)oi);</a>
<a name="ln562">          continue;</a>
<a name="ln563">        }</a>
<a name="ln564"> </a>
<a name="ln565">      if (ospf_flood_through_interface (oi, inbr, lsa))</a>
<a name="ln566">	lsa_ack_flag = 1;</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">  return (lsa_ack_flag);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">int</a>
<a name="ln573">ospf_flood_through_as (struct ospf *ospf, struct ospf_neighbor *inbr,</a>
<a name="ln574">		       struct ospf_lsa *lsa)</a>
<a name="ln575">{</a>
<a name="ln576">  struct listnode *node;</a>
<a name="ln577">  struct ospf_area *area;</a>
<a name="ln578">  int lsa_ack_flag;</a>
<a name="ln579"> </a>
<a name="ln580">  lsa_ack_flag = 0;</a>
<a name="ln581"> </a>
<a name="ln582">  /* The incoming LSA is type 5 or type 7  (AS-EXTERNAL or AS-NSSA )</a>
<a name="ln583"> </a>
<a name="ln584">    Divert the Type-5 LSA's to all non-NSSA/STUB areas</a>
<a name="ln585"> </a>
<a name="ln586">    Divert the Type-7 LSA's to all NSSA areas</a>
<a name="ln587"> </a>
<a name="ln588">     AS-external-LSAs are flooded throughout the entire AS, with the</a>
<a name="ln589">     exception of stub areas (see Section 3.6).  The eligible</a>
<a name="ln590">     interfaces are all the router's interfaces, excluding virtual</a>
<a name="ln591">     links and those interfaces attaching to stub areas.  */</a>
<a name="ln592"> </a>
<a name="ln593">  if (CHECK_FLAG (lsa-&gt;flags, OSPF_LSA_LOCAL_XLT)) /* Translated from 7  */</a>
<a name="ln594">    if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln595">      zlog_debug (&quot;Flood/AS: NSSA TRANSLATED LSA&quot;);</a>
<a name="ln596"> </a>
<a name="ln597">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln598">    {</a>
<a name="ln599">      int continue_flag = 0;</a>
<a name="ln600">      struct listnode *if_node;</a>
<a name="ln601">      struct ospf_interface *oi;</a>
<a name="ln602"> </a>
<a name="ln603">      switch (area-&gt;external_routing)</a>
<a name="ln604">	{</a>
<a name="ln605">	  /* Don't send AS externals into stub areas.  Various types</a>
<a name="ln606">             of support for partial stub areas can be implemented</a>
<a name="ln607">             here.  NSSA's will receive Type-7's that have areas</a>
<a name="ln608">             matching the originl LSA. */</a>
<a name="ln609">	case OSPF_AREA_NSSA:	/* Sending Type 5 or 7 into NSSA area */</a>
<a name="ln610">	  /* Type-7, flood NSSA area */</a>
<a name="ln611">          if (lsa-&gt;data-&gt;type == OSPF_AS_NSSA_LSA</a>
<a name="ln612">	      &amp;&amp; area == lsa-&gt;area)</a>
<a name="ln613">	    /* We will send it. */</a>
<a name="ln614">	    continue_flag = 0;</a>
<a name="ln615">          else</a>
<a name="ln616">	    continue_flag = 1;  /* Skip this NSSA area for Type-5's et al */</a>
<a name="ln617">          break;</a>
<a name="ln618"> </a>
<a name="ln619">	case OSPF_AREA_TYPE_MAX:</a>
<a name="ln620">	case OSPF_AREA_STUB:</a>
<a name="ln621">	  continue_flag = 1;	/* Skip this area. */</a>
<a name="ln622">	  break;</a>
<a name="ln623"> </a>
<a name="ln624">	case OSPF_AREA_DEFAULT:</a>
<a name="ln625">	default:</a>
<a name="ln626">	  /* No Type-7 into normal area */</a>
<a name="ln627">          if (lsa-&gt;data-&gt;type == OSPF_AS_NSSA_LSA) </a>
<a name="ln628">	    continue_flag = 1; /* skip Type-7 */</a>
<a name="ln629">          else</a>
<a name="ln630">	    continue_flag = 0;	/* Do this area. */</a>
<a name="ln631">	  break;</a>
<a name="ln632">	}</a>
<a name="ln633">      </a>
<a name="ln634">      /* Do continue for above switch.  Saves a big if then mess */</a>
<a name="ln635">      if (continue_flag) </a>
<a name="ln636">	continue; /* main for-loop */</a>
<a name="ln637">      </a>
<a name="ln638">      /* send to every interface in this area */</a>
<a name="ln639"> </a>
<a name="ln640">      for (ALL_LIST_ELEMENTS_RO (area-&gt;oiflist, if_node, oi))</a>
<a name="ln641">	{</a>
<a name="ln642">	  /* Skip virtual links */</a>
<a name="ln643">	  if (oi-&gt;type !=  OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln644">	    if (ospf_flood_through_interface (oi, inbr, lsa)) /* lsa */</a>
<a name="ln645">	      lsa_ack_flag = 1;</a>
<a name="ln646">	}</a>
<a name="ln647">    } /* main area for-loop */</a>
<a name="ln648">  </a>
<a name="ln649">  return (lsa_ack_flag);</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">int</a>
<a name="ln653">ospf_flood_through (struct ospf *ospf,</a>
<a name="ln654">		    struct ospf_neighbor *inbr, struct ospf_lsa *lsa)</a>
<a name="ln655">{</a>
<a name="ln656">  int lsa_ack_flag = 0;</a>
<a name="ln657">  </a>
<a name="ln658">  /* Type-7 LSA's for NSSA are flooded throughout the AS here, and</a>
<a name="ln659">     upon return are updated in the LSDB for Type-7's.  Later,</a>
<a name="ln660">     re-fresh will re-send them (and also, if ABR, packet code will</a>
<a name="ln661">     translate to Type-5's)</a>
<a name="ln662">  </a>
<a name="ln663">     As usual, Type-5 LSA's (if not DISCARDED because we are STUB or</a>
<a name="ln664">     NSSA) are flooded throughout the AS, and are updated in the</a>
<a name="ln665">     global table.  */</a>
<a name="ln666">#ifdef ORIGINAL_CODING</a>
<a name="ln667">  switch (lsa-&gt;data-&gt;type)</a>
<a name="ln668">    {</a>
<a name="ln669">    case OSPF_ROUTER_LSA:</a>
<a name="ln670">    case OSPF_NETWORK_LSA:</a>
<a name="ln671">    case OSPF_SUMMARY_LSA:</a>
<a name="ln672">    case OSPF_ASBR_SUMMARY_LSA:</a>
<a name="ln673">    case OSPF_OPAQUE_LINK_LSA: /* ospf_flood_through_interface ? */</a>
<a name="ln674">    case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln675">      lsa_ack_flag = ospf_flood_through_area (inbr-&gt;oi-&gt;area, inbr, lsa);</a>
<a name="ln676">      break;</a>
<a name="ln677">    case OSPF_AS_EXTERNAL_LSA: /* Type-5 */</a>
<a name="ln678">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln679">      lsa_ack_flag = ospf_flood_through_as (ospf, inbr, lsa);</a>
<a name="ln680">      break;</a>
<a name="ln681">      /* Type-7 Only received within NSSA, then flooded */</a>
<a name="ln682">    case OSPF_AS_NSSA_LSA:</a>
<a name="ln683">      /* Any P-bit was installed with the Type-7. */</a>
<a name="ln684">      lsa_ack_flag = ospf_flood_through_area (inbr-&gt;oi-&gt;area, inbr, lsa);</a>
<a name="ln685"> </a>
<a name="ln686">      if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln687">	zlog_debug (&quot;ospf_flood_through: LOCAL NSSA FLOOD of Type-7.&quot;);</a>
<a name="ln688">      break;</a>
<a name="ln689">    default:</a>
<a name="ln690">      break;</a>
<a name="ln691">    }</a>
<a name="ln692">#else /* ORIGINAL_CODING */</a>
<a name="ln693">  /*</a>
<a name="ln694">   * At the common sub-sub-function &quot;ospf_flood_through_interface()&quot;,</a>
<a name="ln695">   * a parameter &quot;inbr&quot; will be used to distinguish the called context</a>
<a name="ln696">   * whether the given LSA was received from the neighbor, or the</a>
<a name="ln697">   * flooding for the LSA starts from this node (e.g. the LSA was self-</a>
<a name="ln698">   * originated, or the LSA is going to be flushed from routing domain).</a>
<a name="ln699">   *</a>
<a name="ln700">   * So, for consistency reasons, this function &quot;ospf_flood_through()&quot;</a>
<a name="ln701">   * should also allow the usage that the given &quot;inbr&quot; parameter to be</a>
<a name="ln702">   * NULL. If we do so, corresponding AREA parameter should be referred</a>
<a name="ln703">   * by &quot;lsa-&gt;area&quot;, instead of &quot;inbr-&gt;oi-&gt;area&quot;.</a>
<a name="ln704">   */</a>
<a name="ln705">  switch (lsa-&gt;data-&gt;type)</a>
<a name="ln706">    {</a>
<a name="ln707">    case OSPF_AS_EXTERNAL_LSA: /* Type-5 */</a>
<a name="ln708">    case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln709">      lsa_ack_flag = ospf_flood_through_as (ospf, inbr, lsa);</a>
<a name="ln710">      break;</a>
<a name="ln711">      /* Type-7 Only received within NSSA, then flooded */</a>
<a name="ln712">    case OSPF_AS_NSSA_LSA:</a>
<a name="ln713">      /* Any P-bit was installed with the Type-7. */</a>
<a name="ln714"> </a>
<a name="ln715">      if (IS_DEBUG_OSPF_NSSA)</a>
<a name="ln716">	zlog_debug (&quot;ospf_flood_through: LOCAL NSSA FLOOD of Type-7.&quot;);</a>
<a name="ln717">      /* Fallthrough */</a>
<a name="ln718">    default:</a>
<a name="ln719">      lsa_ack_flag = ospf_flood_through_area (lsa-&gt;area, inbr, lsa);</a>
<a name="ln720">      break;</a>
<a name="ln721">    }</a>
<a name="ln722">#endif /* ORIGINAL_CODING */</a>
<a name="ln723">  </a>
<a name="ln724">  return (lsa_ack_flag);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727"> </a>
<a name="ln728"> </a>
<a name="ln729">/* Management functions for neighbor's Link State Request list. */</a>
<a name="ln730">void</a>
<a name="ln731">ospf_ls_request_add (struct ospf_neighbor *nbr, struct ospf_lsa *lsa)</a>
<a name="ln732">{</a>
<a name="ln733">  /*</a>
<a name="ln734">   * We cannot make use of the newly introduced callback function</a>
<a name="ln735">   * &quot;lsdb-&gt;new_lsa_hook&quot; to replace debug output below, just because</a>
<a name="ln736">   * it seems no simple and smart way to pass neighbor information to</a>
<a name="ln737">   * the common function &quot;ospf_lsdb_add()&quot; -- endo.</a>
<a name="ln738">   */</a>
<a name="ln739">  if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))</a>
<a name="ln740">      zlog_debug (&quot;RqstL(%lu)++, NBR(%s), LSA[%s]&quot;,</a>
<a name="ln741">                  ospf_ls_request_count (nbr),</a>
<a name="ln742">                  inet_ntoa (nbr-&gt;router_id), dump_lsa_key (lsa));</a>
<a name="ln743"> </a>
<a name="ln744">  ospf_lsdb_add (&amp;nbr-&gt;ls_req, lsa);</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">unsigned long</a>
<a name="ln748">ospf_ls_request_count (struct ospf_neighbor *nbr)</a>
<a name="ln749">{</a>
<a name="ln750">  return ospf_lsdb_count_all (&amp;nbr-&gt;ls_req);</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">int</a>
<a name="ln754">ospf_ls_request_isempty (struct ospf_neighbor *nbr)</a>
<a name="ln755">{</a>
<a name="ln756">  return ospf_lsdb_isempty (&amp;nbr-&gt;ls_req);</a>
<a name="ln757">}</a>
<a name="ln758"> </a>
<a name="ln759">/* Remove LSA from neighbor's ls-request list. */</a>
<a name="ln760">void</a>
<a name="ln761">ospf_ls_request_delete (struct ospf_neighbor *nbr, struct ospf_lsa *lsa)</a>
<a name="ln762">{</a>
<a name="ln763">  if (nbr-&gt;ls_req_last == lsa)</a>
<a name="ln764">    {</a>
<a name="ln765">      ospf_lsa_unlock (&amp;nbr-&gt;ls_req_last);</a>
<a name="ln766">      nbr-&gt;ls_req_last = NULL;</a>
<a name="ln767">    }</a>
<a name="ln768"> </a>
<a name="ln769">  if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))	/* -- endo. */</a>
<a name="ln770">      zlog_debug (&quot;RqstL(%lu)--, NBR(%s), LSA[%s]&quot;,</a>
<a name="ln771">                  ospf_ls_request_count (nbr),</a>
<a name="ln772">                  inet_ntoa (nbr-&gt;router_id), dump_lsa_key (lsa));</a>
<a name="ln773"> </a>
<a name="ln774">  ospf_lsdb_delete (&amp;nbr-&gt;ls_req, lsa);</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">/* Remove all LSA from neighbor's ls-requenst list. */</a>
<a name="ln778">void</a>
<a name="ln779">ospf_ls_request_delete_all (struct ospf_neighbor *nbr)</a>
<a name="ln780">{</a>
<a name="ln781">  ospf_lsa_unlock (&amp;nbr-&gt;ls_req_last);</a>
<a name="ln782">  nbr-&gt;ls_req_last = NULL;</a>
<a name="ln783">  ospf_lsdb_delete_all (&amp;nbr-&gt;ls_req);</a>
<a name="ln784">}</a>
<a name="ln785"> </a>
<a name="ln786">/* Lookup LSA from neighbor's ls-request list. */</a>
<a name="ln787">struct ospf_lsa *</a>
<a name="ln788">ospf_ls_request_lookup (struct ospf_neighbor *nbr, struct ospf_lsa *lsa)</a>
<a name="ln789">{</a>
<a name="ln790">  return ospf_lsdb_lookup (&amp;nbr-&gt;ls_req, lsa);</a>
<a name="ln791">}</a>
<a name="ln792"> </a>
<a name="ln793">struct ospf_lsa *</a>
<a name="ln794">ospf_ls_request_new (struct lsa_header *lsah)</a>
<a name="ln795">{</a>
<a name="ln796">  struct ospf_lsa *new;</a>
<a name="ln797"> </a>
<a name="ln798">  new = ospf_lsa_new ();</a>
<a name="ln799">  new-&gt;data = ospf_lsa_data_new (OSPF_LSA_HEADER_SIZE);</a>
<a name="ln800">  memcpy (new-&gt;data, lsah, OSPF_LSA_HEADER_SIZE);</a>
<a name="ln801"> </a>
<a name="ln802">  return new;</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805"> </a>
<a name="ln806">/* Management functions for neighbor's ls-retransmit list. */</a>
<a name="ln807">unsigned long</a>
<a name="ln808">ospf_ls_retransmit_count (struct ospf_neighbor *nbr)</a>
<a name="ln809">{</a>
<a name="ln810">  return ospf_lsdb_count_all (&amp;nbr-&gt;ls_rxmt);</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">unsigned long</a>
<a name="ln814">ospf_ls_retransmit_count_self (struct ospf_neighbor *nbr, int lsa_type)</a>
<a name="ln815">{</a>
<a name="ln816">  return ospf_lsdb_count_self (&amp;nbr-&gt;ls_rxmt, lsa_type);</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">int</a>
<a name="ln820">ospf_ls_retransmit_isempty (struct ospf_neighbor *nbr)</a>
<a name="ln821">{</a>
<a name="ln822">  return ospf_lsdb_isempty (&amp;nbr-&gt;ls_rxmt);</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">/* Add LSA to be retransmitted to neighbor's ls-retransmit list. */</a>
<a name="ln826">void</a>
<a name="ln827">ospf_ls_retransmit_add (struct ospf_neighbor *nbr, struct ospf_lsa *lsa)</a>
<a name="ln828">{</a>
<a name="ln829">  struct ospf_lsa *old;</a>
<a name="ln830"> </a>
<a name="ln831">  old = ospf_ls_retransmit_lookup (nbr, lsa);</a>
<a name="ln832"> </a>
<a name="ln833">  if (ospf_lsa_more_recent (old, lsa) &lt; 0)</a>
<a name="ln834">    {</a>
<a name="ln835">      if (old)</a>
<a name="ln836">	{</a>
<a name="ln837">	  old-&gt;retransmit_counter--;</a>
<a name="ln838">	  ospf_lsdb_delete (&amp;nbr-&gt;ls_rxmt, old);</a>
<a name="ln839">	}</a>
<a name="ln840">      lsa-&gt;retransmit_counter++;</a>
<a name="ln841">      /*</a>
<a name="ln842">       * We cannot make use of the newly introduced callback function</a>
<a name="ln843">       * &quot;lsdb-&gt;new_lsa_hook&quot; to replace debug output below, just because</a>
<a name="ln844">       * it seems no simple and smart way to pass neighbor information to</a>
<a name="ln845">       * the common function &quot;ospf_lsdb_add()&quot; -- endo.</a>
<a name="ln846">       */</a>
<a name="ln847">      if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))</a>
<a name="ln848">	  zlog_debug (&quot;RXmtL(%lu)++, NBR(%s), LSA[%s]&quot;,</a>
<a name="ln849">                     ospf_ls_retransmit_count (nbr),</a>
<a name="ln850">		     inet_ntoa (nbr-&gt;router_id), dump_lsa_key (lsa));</a>
<a name="ln851">      ospf_lsdb_add (&amp;nbr-&gt;ls_rxmt, lsa);</a>
<a name="ln852">    }</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">/* Remove LSA from neibghbor's ls-retransmit list. */</a>
<a name="ln856">void</a>
<a name="ln857">ospf_ls_retransmit_delete (struct ospf_neighbor *nbr, struct ospf_lsa *lsa)</a>
<a name="ln858">{</a>
<a name="ln859">  if (ospf_ls_retransmit_lookup (nbr, lsa))</a>
<a name="ln860">    {</a>
<a name="ln861">      lsa-&gt;retransmit_counter--;  </a>
<a name="ln862">      if (IS_DEBUG_OSPF (lsa, LSA_FLOODING))		/* -- endo. */</a>
<a name="ln863">	  zlog_debug (&quot;RXmtL(%lu)--, NBR(%s), LSA[%s]&quot;,</a>
<a name="ln864">                     ospf_ls_retransmit_count (nbr),</a>
<a name="ln865">		     inet_ntoa (nbr-&gt;router_id), dump_lsa_key (lsa));</a>
<a name="ln866">      ospf_lsdb_delete (&amp;nbr-&gt;ls_rxmt, lsa);</a>
<a name="ln867">    }</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">/* Clear neighbor's ls-retransmit list. */</a>
<a name="ln871">void</a>
<a name="ln872">ospf_ls_retransmit_clear (struct ospf_neighbor *nbr)</a>
<a name="ln873">{</a>
<a name="ln874">  struct ospf_lsdb *lsdb;</a>
<a name="ln875">  int i;</a>
<a name="ln876"> </a>
<a name="ln877">  lsdb = &amp;nbr-&gt;ls_rxmt;</a>
<a name="ln878"> </a>
<a name="ln879">  for (i = OSPF_MIN_LSA; i &lt; OSPF_MAX_LSA; i++)</a>
<a name="ln880">    {</a>
<a name="ln881">      struct route_table *table = lsdb-&gt;type[i].db;</a>
<a name="ln882">      struct route_node *rn;</a>
<a name="ln883">      struct ospf_lsa *lsa;</a>
<a name="ln884"> </a>
<a name="ln885">      for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln886">	if ((lsa = rn-&gt;info) != NULL)</a>
<a name="ln887">	  ospf_ls_retransmit_delete (nbr, lsa);</a>
<a name="ln888">    }</a>
<a name="ln889"> </a>
<a name="ln890">  ospf_lsa_unlock (&amp;nbr-&gt;ls_req_last);</a>
<a name="ln891">  nbr-&gt;ls_req_last = NULL;</a>
<a name="ln892">}</a>
<a name="ln893"> </a>
<a name="ln894">/* Lookup LSA from neighbor's ls-retransmit list. */</a>
<a name="ln895">struct ospf_lsa *</a>
<a name="ln896">ospf_ls_retransmit_lookup (struct ospf_neighbor *nbr, struct ospf_lsa *lsa)</a>
<a name="ln897">{</a>
<a name="ln898">  return ospf_lsdb_lookup (&amp;nbr-&gt;ls_rxmt, lsa);</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">static void</a>
<a name="ln902">ospf_ls_retransmit_delete_nbr_if (struct ospf_interface *oi,</a>
<a name="ln903">				  struct ospf_lsa *lsa)</a>
<a name="ln904">{</a>
<a name="ln905">  struct route_node *rn;</a>
<a name="ln906">  struct ospf_neighbor *nbr;</a>
<a name="ln907">  struct ospf_lsa *lsr;</a>
<a name="ln908"> </a>
<a name="ln909">  if (ospf_if_is_enable (oi))</a>
<a name="ln910">    for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln911">      /* If LSA find in LS-retransmit list, then remove it. */</a>
<a name="ln912">      if ((nbr = rn-&gt;info) != NULL)</a>
<a name="ln913">	{</a>
<a name="ln914">	  lsr = ospf_ls_retransmit_lookup (nbr, lsa);</a>
<a name="ln915">	     </a>
<a name="ln916">	  /* If LSA find in ls-retransmit list, remove it. */</a>
<a name="ln917">	  if (lsr != NULL &amp;&amp; lsr-&gt;data-&gt;ls_seqnum == lsa-&gt;data-&gt;ls_seqnum)</a>
<a name="ln918">	    ospf_ls_retransmit_delete (nbr, lsr);</a>
<a name="ln919">	}</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">void</a>
<a name="ln923">ospf_ls_retransmit_delete_nbr_area (struct ospf_area *area,</a>
<a name="ln924">				    struct ospf_lsa *lsa)</a>
<a name="ln925">{</a>
<a name="ln926">  struct listnode *node, *nnode;</a>
<a name="ln927">  struct ospf_interface *oi;</a>
<a name="ln928"> </a>
<a name="ln929">  for (ALL_LIST_ELEMENTS (area-&gt;oiflist, node, nnode, oi))</a>
<a name="ln930">    ospf_ls_retransmit_delete_nbr_if (oi, lsa);</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">void</a>
<a name="ln934">ospf_ls_retransmit_delete_nbr_as (struct ospf *ospf, struct ospf_lsa *lsa)</a>
<a name="ln935">{</a>
<a name="ln936">  struct listnode *node, *nnode;</a>
<a name="ln937">  struct ospf_interface *oi;</a>
<a name="ln938"> </a>
<a name="ln939">  for (ALL_LIST_ELEMENTS (ospf-&gt;oiflist, node, nnode, oi))</a>
<a name="ln940">    ospf_ls_retransmit_delete_nbr_if (oi, lsa);</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943"> </a>
<a name="ln944">/* Sets ls_age to MaxAge and floods throu the area. </a>
<a name="ln945">   When we implement ASE routing, there will be anothe function</a>
<a name="ln946">   flushing an LSA from the whole domain. */</a>
<a name="ln947">void</a>
<a name="ln948">ospf_lsa_flush_area (struct ospf_lsa *lsa, struct ospf_area *area)</a>
<a name="ln949">{</a>
<a name="ln950">  /* Reset the lsa origination time such that it gives</a>
<a name="ln951">     more time for the ACK to be received and avoid</a>
<a name="ln952">     retransmissions */</a>
<a name="ln953">  lsa-&gt;data-&gt;ls_age = htons (OSPF_LSA_MAXAGE);</a>
<a name="ln954">  lsa-&gt;tv_recv = recent_relative_time ();</a>
<a name="ln955">  lsa-&gt;tv_orig = lsa-&gt;tv_recv;</a>
<a name="ln956">  ospf_flood_through_area (area, NULL, lsa);</a>
<a name="ln957">  ospf_lsa_maxage (area-&gt;ospf, lsa);</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960">void</a>
<a name="ln961">ospf_lsa_flush_as (struct ospf *ospf, struct ospf_lsa *lsa)</a>
<a name="ln962">{</a>
<a name="ln963">  /* Reset the lsa origination time such that it gives</a>
<a name="ln964">     more time for the ACK to be received and avoid</a>
<a name="ln965">     retransmissions */</a>
<a name="ln966">  lsa-&gt;data-&gt;ls_age = htons (OSPF_LSA_MAXAGE);</a>
<a name="ln967">  lsa-&gt;tv_recv = recent_relative_time ();</a>
<a name="ln968">  lsa-&gt;tv_orig = lsa-&gt;tv_recv;</a>
<a name="ln969">  ospf_flood_through_as (ospf, NULL, lsa);</a>
<a name="ln970">  ospf_lsa_maxage (ospf, lsa);</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">void</a>
<a name="ln974">ospf_lsa_flush (struct ospf *ospf, struct ospf_lsa *lsa)</a>
<a name="ln975">{</a>
<a name="ln976">  lsa-&gt;data-&gt;ls_age = htons (OSPF_LSA_MAXAGE);</a>
<a name="ln977">  </a>
<a name="ln978">  switch (lsa-&gt;data-&gt;type)</a>
<a name="ln979">    {</a>
<a name="ln980">      case OSPF_ROUTER_LSA:</a>
<a name="ln981">      case OSPF_NETWORK_LSA:</a>
<a name="ln982">      case OSPF_SUMMARY_LSA:</a>
<a name="ln983">      case OSPF_ASBR_SUMMARY_LSA:</a>
<a name="ln984">      case OSPF_AS_NSSA_LSA:</a>
<a name="ln985">      case OSPF_OPAQUE_LINK_LSA:</a>
<a name="ln986">      case OSPF_OPAQUE_AREA_LSA:</a>
<a name="ln987">        ospf_lsa_flush_area (lsa, lsa-&gt;area);</a>
<a name="ln988">        break;</a>
<a name="ln989">      case OSPF_AS_EXTERNAL_LSA:</a>
<a name="ln990">      case OSPF_OPAQUE_AS_LSA:</a>
<a name="ln991">        ospf_lsa_flush_as (ospf, lsa);</a>
<a name="ln992">        break;</a>
<a name="ln993">      default:</a>
<a name="ln994">        zlog_info (&quot;%s: Unknown LSA type %u&quot;, __func__, lsa-&gt;data-&gt;type);</a>
<a name="ln995">        break;</a>
<a name="ln996">    }</a>
<a name="ln997">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="193"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 193, 196</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
