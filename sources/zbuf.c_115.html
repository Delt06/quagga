
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>zbuf.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Stream/packet buffer API implementation</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#define _GNU_SOURCE</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;unistd.h&gt;</a>
<a name="ln13">#include &lt;errno.h&gt;</a>
<a name="ln14">#include &quot;zassert.h&quot;</a>
<a name="ln15">#include &quot;zbuf.h&quot;</a>
<a name="ln16">#include &quot;memory.h&quot;</a>
<a name="ln17">#include &quot;memtypes.h&quot;</a>
<a name="ln18">#include &quot;nhrpd.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">#define ERRNO_IO_RETRY(EN) (((EN) == EAGAIN) || ((EN) == EWOULDBLOCK) || ((EN) == EINTR))</a>
<a name="ln21"> </a>
<a name="ln22">struct zbuf *zbuf_alloc(size_t size)</a>
<a name="ln23">{</a>
<a name="ln24">	struct zbuf *zb;</a>
<a name="ln25"> </a>
<a name="ln26">	zb = XMALLOC(MTYPE_STREAM_DATA, sizeof(*zb) + size);</a>
<a name="ln27">	if (!zb)</a>
<a name="ln28">		return NULL;</a>
<a name="ln29"> </a>
<a name="ln30">	zbuf_init(zb, zb+1, size, 0);</a>
<a name="ln31">	zb-&gt;allocated = 1;</a>
<a name="ln32"> </a>
<a name="ln33">	return zb;</a>
<a name="ln34">}</a>
<a name="ln35"> </a>
<a name="ln36">void zbuf_init(struct zbuf *zb, void *buf, size_t len, size_t datalen)</a>
<a name="ln37">{</a>
<a name="ln38">	*zb = (struct zbuf) {</a>
<a name="ln39">		.buf = buf,</a>
<a name="ln40">		.end = (uint8_t *)buf + len,</a>
<a name="ln41">		.head = buf,</a>
<a name="ln42">		.tail = (uint8_t *)buf + datalen,</a>
<a name="ln43">	};</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">void zbuf_free(struct zbuf *zb)</a>
<a name="ln47">{</a>
<a name="ln48">	if (zb-&gt;allocated)</a>
<a name="ln49">		XFREE(MTYPE_STREAM_DATA, zb);</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52">void zbuf_reset(struct zbuf *zb)</a>
<a name="ln53">{</a>
<a name="ln54">	zb-&gt;head = zb-&gt;tail = zb-&gt;buf;</a>
<a name="ln55">	zb-&gt;error = 0;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">void zbuf_reset_head(struct zbuf *zb, void *ptr)</a>
<a name="ln59">{</a>
<a name="ln60">	zassert((void*)zb-&gt;buf &lt;= ptr &amp;&amp; ptr &lt;= (void*)zb-&gt;tail);</a>
<a name="ln61">	zb-&gt;head = ptr;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">static void zbuf_remove_headroom(struct zbuf *zb)</a>
<a name="ln65">{</a>
<a name="ln66">	ssize_t headroom = zbuf_headroom(zb);</a>
<a name="ln67">	if (!headroom)</a>
<a name="ln68">		return;</a>
<a name="ln69">	memmove(zb-&gt;buf, zb-&gt;head, zbuf_used(zb));</a>
<a name="ln70">	zb-&gt;head -= headroom;</a>
<a name="ln71">	zb-&gt;tail -= headroom;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">ssize_t zbuf_read(struct zbuf *zb, int fd, size_t maxlen)</a>
<a name="ln75">{</a>
<a name="ln76">	ssize_t r;</a>
<a name="ln77"> </a>
<a name="ln78">	if (zb-&gt;error)</a>
<a name="ln79">		return -3;</a>
<a name="ln80"> </a>
<a name="ln81">	zbuf_remove_headroom(zb);</a>
<a name="ln82">	if (maxlen &gt; zbuf_tailroom(zb))</a>
<a name="ln83">		maxlen = zbuf_tailroom(zb);</a>
<a name="ln84"> </a>
<a name="ln85">	r = read(fd, zb-&gt;tail, maxlen);</a>
<a name="ln86">	if (r &gt; 0) zb-&gt;tail += r;</a>
<a name="ln87">	else if (r == 0) r = -2;</a>
<a name="ln88">	else if (r &lt; 0 &amp;&amp; ERRNO_IO_RETRY(errno)) r = 0;</a>
<a name="ln89"> </a>
<a name="ln90">	return r;</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">ssize_t zbuf_write(struct zbuf *zb, int fd)</a>
<a name="ln94">{</a>
<a name="ln95">	ssize_t r;</a>
<a name="ln96"> </a>
<a name="ln97">	if (zb-&gt;error)</a>
<a name="ln98">		return -3;</a>
<a name="ln99"> </a>
<a name="ln100">	r = write(fd, zb-&gt;head, zbuf_used(zb));</a>
<a name="ln101">	if (r &gt; 0) {</a>
<a name="ln102">		zb-&gt;head += r;</a>
<a name="ln103">		if (zb-&gt;head == zb-&gt;tail)</a>
<a name="ln104">			zbuf_reset(zb);</a>
<a name="ln105">	}</a>
<a name="ln106">	else if (r == 0) r = -2;</a>
<a name="ln107">	else if (r &lt; 0 &amp;&amp; ERRNO_IO_RETRY(errno)) r = 0;</a>
<a name="ln108"> </a>
<a name="ln109">	return r;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">ssize_t zbuf_recv(struct zbuf *zb, int fd)</a>
<a name="ln113">{</a>
<a name="ln114">	ssize_t r;</a>
<a name="ln115"> </a>
<a name="ln116">	if (zb-&gt;error)</a>
<a name="ln117">		return -3;</a>
<a name="ln118"> </a>
<a name="ln119">	zbuf_remove_headroom(zb);</a>
<a name="ln120">	r = recv(fd, zb-&gt;tail, zbuf_tailroom(zb), 0);</a>
<a name="ln121">	if (r &gt; 0) zb-&gt;tail += r;</a>
<a name="ln122">	else if (r == 0) r = -2;</a>
<a name="ln123">	else if (r &lt; 0 &amp;&amp; ERRNO_IO_RETRY(errno)) r = 0;</a>
<a name="ln124">	return r;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">ssize_t zbuf_send(struct zbuf *zb, int fd)</a>
<a name="ln128">{</a>
<a name="ln129">	ssize_t r;</a>
<a name="ln130"> </a>
<a name="ln131">	if (zb-&gt;error)</a>
<a name="ln132">		return -3;</a>
<a name="ln133"> </a>
<a name="ln134">	r = send(fd, zb-&gt;head, zbuf_used(zb), 0);</a>
<a name="ln135">	if (r &gt;= 0)</a>
<a name="ln136">		zbuf_reset(zb);</a>
<a name="ln137"> </a>
<a name="ln138">	return r;</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">void *zbuf_may_pull_until(struct zbuf *zb, const char *sep, struct zbuf *msg)</a>
<a name="ln142">{</a>
<a name="ln143">	size_t seplen = strlen(sep), len;</a>
<a name="ln144">	uint8_t *ptr;</a>
<a name="ln145"> </a>
<a name="ln146">	ptr = memmem(zb-&gt;head, zbuf_used(zb), sep, seplen);</a>
<a name="ln147">	if (!ptr) return NULL;</a>
<a name="ln148"> </a>
<a name="ln149">	len = ptr - zb-&gt;head + seplen;</a>
<a name="ln150">	zbuf_init(msg, zbuf_pulln(zb, len), len, len);</a>
<a name="ln151">	return msg-&gt;head;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">void zbufq_init(struct zbuf_queue *zbq)</a>
<a name="ln155">{</a>
<a name="ln156">	*zbq = (struct zbuf_queue) {</a>
<a name="ln157">		.queue_head = LIST_INITIALIZER(zbq-&gt;queue_head),</a>
<a name="ln158">	};</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">void zbufq_reset(struct zbuf_queue *zbq)</a>
<a name="ln162">{</a>
<a name="ln163">	struct zbuf *buf, *bufn;</a>
<a name="ln164"> </a>
<a name="ln165">	list_for_each_entry_safe(buf, bufn, &amp;zbq-&gt;queue_head, queue_list) {</a>
<a name="ln166">		list_del(&amp;buf-&gt;queue_list);</a>
<a name="ln167">		zbuf_free(buf);</a>
<a name="ln168">	}</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">void zbufq_queue(struct zbuf_queue *zbq, struct zbuf *zb)</a>
<a name="ln172">{</a>
<a name="ln173">	list_add_tail(&amp;zb-&gt;queue_list, &amp;zbq-&gt;queue_head);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">int zbufq_write(struct zbuf_queue *zbq, int fd)</a>
<a name="ln177">{</a>
<a name="ln178">	struct iovec iov[16];</a>
<a name="ln179">	struct zbuf *zb, *zbn;</a>
<a name="ln180">	ssize_t r;</a>
<a name="ln181">	size_t iovcnt = 0;</a>
<a name="ln182"> </a>
<a name="ln183">	list_for_each_entry_safe(zb, zbn, &amp;zbq-&gt;queue_head, queue_list) {</a>
<a name="ln184">		iov[iovcnt++] = (struct iovec) {</a>
<a name="ln185">			.iov_base = zb-&gt;head,</a>
<a name="ln186">			.iov_len = zbuf_used(zb),</a>
<a name="ln187">		};</a>
<a name="ln188">		if (iovcnt &gt;= ZEBRA_NUM_OF(iov))</a>
<a name="ln189">			break;</a>
<a name="ln190">	}</a>
<a name="ln191"> </a>
<a name="ln192">	r = writev(fd, iov, iovcnt);</a>
<a name="ln193">	if (r &lt; 0)</a>
<a name="ln194">		return r;</a>
<a name="ln195"> </a>
<a name="ln196">	list_for_each_entry_safe(zb, zbn, &amp;zbq-&gt;queue_head, queue_list) {</a>
<a name="ln197">		if (r &lt; (ssize_t)zbuf_used(zb)) {</a>
<a name="ln198">			zb-&gt;head += r;</a>
<a name="ln199">			return 1;</a>
<a name="ln200">		}</a>
<a name="ln201"> </a>
<a name="ln202">		r -= zbuf_used(zb);</a>
<a name="ln203">		list_del(&amp;zb-&gt;queue_list);</a>
<a name="ln204">		zbuf_free(zb);</a>
<a name="ln205">	}</a>
<a name="ln206"> </a>
<a name="ln207">	return 0;</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">void zbuf_copy(struct zbuf *zdst, struct zbuf *zsrc, size_t len)</a>
<a name="ln211">{</a>
<a name="ln212">	const void *src;</a>
<a name="ln213">	void *dst;</a>
<a name="ln214"> </a>
<a name="ln215">	dst = zbuf_pushn(zdst, len);</a>
<a name="ln216">	src = zbuf_pulln(zsrc, len);</a>
<a name="ln217">	if (!dst || !src) return;</a>
<a name="ln218">	memcpy(dst, src, len);</a>
<a name="ln219">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="88"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: r < 0.</p></div>
<div class="balloon" rel="107"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: r < 0.</p></div>
<div class="balloon" rel="123"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: r < 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
