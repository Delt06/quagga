
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_apiclient.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Client side of OSPF API.</a>
<a name="ln3"> * Copyright (C) 2001, 2002, 2003 Ralph Keller</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> * </a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln8"> * it under the terms of the GNU General Public License as published</a>
<a name="ln9"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln10"> * option) any later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln20"> * Boston, MA 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;lib/version.h&gt;</a>
<a name="ln26">#include &quot;getopt.h&quot;</a>
<a name="ln27">#include &quot;thread.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;linklist.h&quot;</a>
<a name="ln30">#include &quot;if.h&quot;</a>
<a name="ln31">#include &quot;vector.h&quot;</a>
<a name="ln32">#include &quot;vty.h&quot;</a>
<a name="ln33">#include &quot;command.h&quot;</a>
<a name="ln34">#include &quot;filter.h&quot;</a>
<a name="ln35">#include &quot;stream.h&quot;</a>
<a name="ln36">#include &quot;log.h&quot;</a>
<a name="ln37">#include &quot;memory.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_opaque.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln48">#include &quot;ospfd/ospf_api.h&quot;</a>
<a name="ln49"> </a>
<a name="ln50">#include &quot;ospf_apiclient.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">/* Backlog for listen */</a>
<a name="ln53">#define BACKLOG 5</a>
<a name="ln54"> </a>
<a name="ln55">/* -----------------------------------------------------------</a>
<a name="ln56"> * Forward declarations</a>
<a name="ln57"> * -----------------------------------------------------------</a>
<a name="ln58"> */</a>
<a name="ln59"> </a>
<a name="ln60">void ospf_apiclient_handle_reply (struct ospf_apiclient *oclient,</a>
<a name="ln61">				  struct msg *msg);</a>
<a name="ln62">void ospf_apiclient_handle_update_notify (struct ospf_apiclient *oclient,</a>
<a name="ln63">					  struct msg *msg);</a>
<a name="ln64">void ospf_apiclient_handle_delete_notify (struct ospf_apiclient *oclient,</a>
<a name="ln65">					  struct msg *msg);</a>
<a name="ln66"> </a>
<a name="ln67">/* -----------------------------------------------------------</a>
<a name="ln68"> * Initialization</a>
<a name="ln69"> * -----------------------------------------------------------</a>
<a name="ln70"> */</a>
<a name="ln71"> </a>
<a name="ln72">static unsigned short</a>
<a name="ln73">ospf_apiclient_getport (void)</a>
<a name="ln74">{</a>
<a name="ln75">  struct servent *sp = getservbyname (&quot;ospfapi&quot;, &quot;tcp&quot;);</a>
<a name="ln76"> </a>
<a name="ln77">  return sp ? ntohs (sp-&gt;s_port) : OSPF_API_SYNC_PORT;</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">/* -----------------------------------------------------------</a>
<a name="ln81"> * Followings are functions for connection management</a>
<a name="ln82"> * -----------------------------------------------------------</a>
<a name="ln83"> */</a>
<a name="ln84"> </a>
<a name="ln85">struct ospf_apiclient *</a>
<a name="ln86">ospf_apiclient_connect (char *host, int syncport)</a>
<a name="ln87">{</a>
<a name="ln88">  struct sockaddr_in myaddr_sync;</a>
<a name="ln89">  struct sockaddr_in myaddr_async;</a>
<a name="ln90">  struct sockaddr_in peeraddr;</a>
<a name="ln91">  struct hostent *hp;</a>
<a name="ln92">  struct ospf_apiclient *new;</a>
<a name="ln93">  int size = 0;</a>
<a name="ln94">  unsigned int peeraddrlen;</a>
<a name="ln95">  int async_server_sock;</a>
<a name="ln96">  int fd1, fd2;</a>
<a name="ln97">  int ret;</a>
<a name="ln98">  int on = 1;</a>
<a name="ln99"> </a>
<a name="ln100">  /* There are two connections between the client and the server.</a>
<a name="ln101">     First the client opens a connection for synchronous requests/replies </a>
<a name="ln102">     to the server. The server will accept this connection and</a>
<a name="ln103">     as a reaction open a reverse connection channel for </a>
<a name="ln104">     asynchronous messages. */</a>
<a name="ln105"> </a>
<a name="ln106">  async_server_sock = socket (AF_INET, SOCK_STREAM, 0);</a>
<a name="ln107">  if (async_server_sock &lt; 0)</a>
<a name="ln108">    {</a>
<a name="ln109">      fprintf (stderr,</a>
<a name="ln110">	       &quot;ospf_apiclient_connect: creating async socket failed\n&quot;);</a>
<a name="ln111">      return NULL;</a>
<a name="ln112">    }</a>
<a name="ln113"> </a>
<a name="ln114">  /* Prepare socket for asynchronous messages */</a>
<a name="ln115">  /* Initialize async address structure */</a>
<a name="ln116">  memset (&amp;myaddr_async, 0, sizeof (struct sockaddr_in));</a>
<a name="ln117">  myaddr_async.sin_family = AF_INET;</a>
<a name="ln118">  myaddr_async.sin_addr.s_addr = htonl (INADDR_ANY);</a>
<a name="ln119">  myaddr_async.sin_port = htons (syncport+1);</a>
<a name="ln120">  size = sizeof (struct sockaddr_in);</a>
<a name="ln121">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln122">  myaddr_async.sin_len = size;</a>
<a name="ln123">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln124"> </a>
<a name="ln125">  /* This is a server socket, reuse addr and port */</a>
<a name="ln126">  ret = setsockopt (async_server_sock, SOL_SOCKET,</a>
<a name="ln127">		    SO_REUSEADDR, (void *) &amp;on, sizeof (on));</a>
<a name="ln128">  if (ret &lt; 0)</a>
<a name="ln129">    {</a>
<a name="ln130">      fprintf (stderr, &quot;ospf_apiclient_connect: SO_REUSEADDR failed\n&quot;);</a>
<a name="ln131">      close (async_server_sock);</a>
<a name="ln132">      return NULL;</a>
<a name="ln133">    }</a>
<a name="ln134"> </a>
<a name="ln135">#ifdef SO_REUSEPORT</a>
<a name="ln136">  ret = setsockopt (async_server_sock, SOL_SOCKET, SO_REUSEPORT,</a>
<a name="ln137">		    (void *) &amp;on, sizeof (on));</a>
<a name="ln138">  if (ret &lt; 0)</a>
<a name="ln139">    {</a>
<a name="ln140">      fprintf (stderr, &quot;ospf_apiclient_connect: SO_REUSEPORT failed\n&quot;);</a>
<a name="ln141">      close (async_server_sock);</a>
<a name="ln142">      return NULL;</a>
<a name="ln143">    }</a>
<a name="ln144">#endif /* SO_REUSEPORT */</a>
<a name="ln145"> </a>
<a name="ln146">  /* Bind socket to address structure */</a>
<a name="ln147">  ret = bind (async_server_sock, (struct sockaddr *) &amp;myaddr_async, size);</a>
<a name="ln148">  if (ret &lt; 0)</a>
<a name="ln149">    {</a>
<a name="ln150">      fprintf (stderr, &quot;ospf_apiclient_connect: bind async socket failed\n&quot;);</a>
<a name="ln151">      close (async_server_sock);</a>
<a name="ln152">      return NULL;</a>
<a name="ln153">    }</a>
<a name="ln154"> </a>
<a name="ln155">  /* Wait for reverse channel connection establishment from server */</a>
<a name="ln156">  ret = listen (async_server_sock, BACKLOG);</a>
<a name="ln157">  if (ret &lt; 0)</a>
<a name="ln158">    {</a>
<a name="ln159">      fprintf (stderr, &quot;ospf_apiclient_connect: listen: %s\n&quot;, safe_strerror (errno));</a>
<a name="ln160">      close (async_server_sock);</a>
<a name="ln161">      return NULL;</a>
<a name="ln162">    }</a>
<a name="ln163"> </a>
<a name="ln164">  /* Make connection for synchronous requests and connect to server */</a>
<a name="ln165">  /* Resolve address of server */</a>
<a name="ln166">  hp = gethostbyname (host);</a>
<a name="ln167">  if (!hp)</a>
<a name="ln168">    {</a>
<a name="ln169">      fprintf (stderr, &quot;ospf_apiclient_connect: no such host %s\n&quot;, host);</a>
<a name="ln170">      close (async_server_sock);</a>
<a name="ln171">      return NULL;</a>
<a name="ln172">    }</a>
<a name="ln173"> </a>
<a name="ln174">  fd1 = socket (AF_INET, SOCK_STREAM, 0);</a>
<a name="ln175">  if (fd1 &lt; 0)</a>
<a name="ln176">    {</a>
<a name="ln177">      fprintf (stderr,</a>
<a name="ln178">	       &quot;ospf_apiclient_connect: creating sync socket failed\n&quot;);</a>
<a name="ln179">      return NULL;</a>
<a name="ln180">    }</a>
<a name="ln181"> </a>
<a name="ln182"> </a>
<a name="ln183">  /* Reuse addr and port */</a>
<a name="ln184">  ret = setsockopt (fd1, SOL_SOCKET,</a>
<a name="ln185">                    SO_REUSEADDR, (void *) &amp;on, sizeof (on));</a>
<a name="ln186">  if (ret &lt; 0)</a>
<a name="ln187">    {</a>
<a name="ln188">      fprintf (stderr, &quot;ospf_apiclient_connect: SO_REUSEADDR failed\n&quot;);</a>
<a name="ln189">      close (fd1);</a>
<a name="ln190">      return NULL;</a>
<a name="ln191">    }</a>
<a name="ln192"> </a>
<a name="ln193">#ifdef SO_REUSEPORT</a>
<a name="ln194">  ret = setsockopt (fd1, SOL_SOCKET, SO_REUSEPORT,</a>
<a name="ln195">                    (void *) &amp;on, sizeof (on));</a>
<a name="ln196">  if (ret &lt; 0)</a>
<a name="ln197">    {</a>
<a name="ln198">      fprintf (stderr, &quot;ospf_apiclient_connect: SO_REUSEPORT failed\n&quot;);</a>
<a name="ln199">      close (fd1);</a>
<a name="ln200">      return NULL;</a>
<a name="ln201">    }</a>
<a name="ln202">#endif /* SO_REUSEPORT */</a>
<a name="ln203"> </a>
<a name="ln204"> </a>
<a name="ln205">  /* Bind sync socket to address structure. This is needed since we</a>
<a name="ln206">     want the sync port number on a fixed port number. The reverse</a>
<a name="ln207">     async channel will be at this port+1 */</a>
<a name="ln208"> </a>
<a name="ln209">  memset (&amp;myaddr_sync, 0, sizeof (struct sockaddr_in));</a>
<a name="ln210">  myaddr_sync.sin_family = AF_INET;</a>
<a name="ln211">  myaddr_sync.sin_port = htons (syncport);</a>
<a name="ln212">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln213">  myaddr_sync.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln214">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln215"> </a>
<a name="ln216">  ret = bind (fd1, (struct sockaddr *) &amp;myaddr_sync, size);</a>
<a name="ln217">  if (ret &lt; 0)</a>
<a name="ln218">    {</a>
<a name="ln219">      fprintf (stderr, &quot;ospf_apiclient_connect: bind sync socket failed\n&quot;);</a>
<a name="ln220">      close (fd1);</a>
<a name="ln221">      return NULL;</a>
<a name="ln222">    }</a>
<a name="ln223"> </a>
<a name="ln224">  /* Prepare address structure for connect */</a>
<a name="ln225">  memcpy (&amp;myaddr_sync.sin_addr, hp-&gt;h_addr, hp-&gt;h_length);</a>
<a name="ln226">  myaddr_sync.sin_family = AF_INET;</a>
<a name="ln227">  myaddr_sync.sin_port = htons(ospf_apiclient_getport ());</a>
<a name="ln228">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln229">  myaddr_sync.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln230">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln231"> </a>
<a name="ln232">  /* Now establish synchronous channel with OSPF daemon */</a>
<a name="ln233">  ret = connect (fd1, (struct sockaddr *) &amp;myaddr_sync,</a>
<a name="ln234">		 sizeof (struct sockaddr_in));</a>
<a name="ln235">  if (ret &lt; 0)</a>
<a name="ln236">    {</a>
<a name="ln237">      fprintf (stderr, &quot;ospf_apiclient_connect: sync connect failed\n&quot;);</a>
<a name="ln238">      close (async_server_sock);</a>
<a name="ln239">      close (fd1);</a>
<a name="ln240">      return NULL;</a>
<a name="ln241">    }</a>
<a name="ln242"> </a>
<a name="ln243">  /* Accept reverse connection */</a>
<a name="ln244">  peeraddrlen = sizeof (struct sockaddr_in);</a>
<a name="ln245">  memset (&amp;peeraddr, 0, peeraddrlen);</a>
<a name="ln246"> </a>
<a name="ln247">  fd2 =</a>
<a name="ln248">    accept (async_server_sock, (struct sockaddr *) &amp;peeraddr, &amp;peeraddrlen);</a>
<a name="ln249">  if (fd2 &lt; 0)</a>
<a name="ln250">    {</a>
<a name="ln251">      fprintf (stderr, &quot;ospf_apiclient_connect: accept async failed\n&quot;);</a>
<a name="ln252">      close (async_server_sock);</a>
<a name="ln253">      close (fd1);</a>
<a name="ln254">      return NULL;</a>
<a name="ln255">    }</a>
<a name="ln256"> </a>
<a name="ln257">  /* Server socket is not needed anymore since we are not accepting more </a>
<a name="ln258">     connections */</a>
<a name="ln259">  close (async_server_sock);</a>
<a name="ln260"> </a>
<a name="ln261">  /* Create new client-side instance */</a>
<a name="ln262">  new = XCALLOC (MTYPE_OSPF_APICLIENT, sizeof (struct ospf_apiclient));</a>
<a name="ln263"> </a>
<a name="ln264">  /* Initialize socket descriptors for sync and async channels */</a>
<a name="ln265">  new-&gt;fd_sync = fd1;</a>
<a name="ln266">  new-&gt;fd_async = fd2;</a>
<a name="ln267"> </a>
<a name="ln268">  return new;</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">int</a>
<a name="ln272">ospf_apiclient_close (struct ospf_apiclient *oclient)</a>
<a name="ln273">{</a>
<a name="ln274"> </a>
<a name="ln275">  if (oclient-&gt;fd_sync &gt;= 0)</a>
<a name="ln276">    {</a>
<a name="ln277">      close (oclient-&gt;fd_sync);</a>
<a name="ln278">    }</a>
<a name="ln279"> </a>
<a name="ln280">  if (oclient-&gt;fd_async &gt;= 0)</a>
<a name="ln281">    {</a>
<a name="ln282">      close (oclient-&gt;fd_async);</a>
<a name="ln283">    }</a>
<a name="ln284"> </a>
<a name="ln285">  /* Free client structure */</a>
<a name="ln286">  XFREE (MTYPE_OSPF_APICLIENT, oclient);</a>
<a name="ln287">  return 0;</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">/* -----------------------------------------------------------</a>
<a name="ln291"> * Followings are functions to send a request to OSPFd</a>
<a name="ln292"> * -----------------------------------------------------------</a>
<a name="ln293"> */</a>
<a name="ln294"> </a>
<a name="ln295">/* Send synchronous request, wait for reply */</a>
<a name="ln296">static int</a>
<a name="ln297">ospf_apiclient_send_request (struct ospf_apiclient *oclient, struct msg *msg)</a>
<a name="ln298">{</a>
<a name="ln299">  u_int32_t reqseq;</a>
<a name="ln300">  struct msg_reply *msgreply;</a>
<a name="ln301">  int rc;</a>
<a name="ln302"> </a>
<a name="ln303">  /* NB: Given &quot;msg&quot; is freed inside this function. */</a>
<a name="ln304"> </a>
<a name="ln305">  /* Remember the sequence number of the request */</a>
<a name="ln306">  reqseq = ntohl (msg-&gt;hdr.msgseq);</a>
<a name="ln307"> </a>
<a name="ln308">  /* Write message to OSPFd */</a>
<a name="ln309">  rc = msg_write (oclient-&gt;fd_sync, msg);</a>
<a name="ln310">  msg_free (msg);</a>
<a name="ln311"> </a>
<a name="ln312">  if (rc &lt; 0)</a>
<a name="ln313">    {</a>
<a name="ln314">      return -1;</a>
<a name="ln315">    }</a>
<a name="ln316"> </a>
<a name="ln317">  /* Wait for reply *//* NB: New &quot;msg&quot; is allocated by &quot;msg_read()&quot;. */</a>
<a name="ln318">  msg = msg_read (oclient-&gt;fd_sync);</a>
<a name="ln319">  if (!msg)</a>
<a name="ln320">    return -1;</a>
<a name="ln321"> </a>
<a name="ln322">  assert (msg-&gt;hdr.msgtype == MSG_REPLY);</a>
<a name="ln323">  assert (ntohl (msg-&gt;hdr.msgseq) == reqseq);</a>
<a name="ln324"> </a>
<a name="ln325">  msgreply = (struct msg_reply *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln326">  rc = msgreply-&gt;errcode;</a>
<a name="ln327">  msg_free (msg);</a>
<a name="ln328"> </a>
<a name="ln329">  return rc;</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332"> </a>
<a name="ln333">/* -----------------------------------------------------------</a>
<a name="ln334"> * Helper functions</a>
<a name="ln335"> * -----------------------------------------------------------</a>
<a name="ln336"> */</a>
<a name="ln337"> </a>
<a name="ln338">static u_int32_t</a>
<a name="ln339">ospf_apiclient_get_seqnr (void)</a>
<a name="ln340">{</a>
<a name="ln341">  static u_int32_t seqnr = MIN_SEQ;</a>
<a name="ln342">  u_int32_t tmp;</a>
<a name="ln343"> </a>
<a name="ln344">  tmp = seqnr;</a>
<a name="ln345">  /* Increment sequence number */</a>
<a name="ln346">  if (seqnr &lt; MAX_SEQ)</a>
<a name="ln347">    {</a>
<a name="ln348">      seqnr++;</a>
<a name="ln349">    }</a>
<a name="ln350">  else</a>
<a name="ln351">    {</a>
<a name="ln352">      seqnr = MIN_SEQ;</a>
<a name="ln353">    }</a>
<a name="ln354">  return tmp;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">/* -----------------------------------------------------------</a>
<a name="ln358"> * API to access OSPF daemon by client applications.</a>
<a name="ln359"> * -----------------------------------------------------------</a>
<a name="ln360"> */</a>
<a name="ln361"> </a>
<a name="ln362">/*</a>
<a name="ln363"> * Synchronous request to register opaque type.</a>
<a name="ln364"> */</a>
<a name="ln365">int</a>
<a name="ln366">ospf_apiclient_register_opaque_type (struct ospf_apiclient *cl,</a>
<a name="ln367">				     u_char ltype, u_char otype)</a>
<a name="ln368">{</a>
<a name="ln369">  struct msg *msg;</a>
<a name="ln370">  int rc;</a>
<a name="ln371"> </a>
<a name="ln372">  /* just put 1 as a sequence number. */</a>
<a name="ln373">  msg = new_msg_register_opaque_type (ospf_apiclient_get_seqnr (),</a>
<a name="ln374">				      ltype, otype);</a>
<a name="ln375">  if (!msg)</a>
<a name="ln376">    {</a>
<a name="ln377">      fprintf (stderr, &quot;new_msg_register_opaque_type failed\n&quot;);</a>
<a name="ln378">      return -1;</a>
<a name="ln379">    }</a>
<a name="ln380"> </a>
<a name="ln381">  rc = ospf_apiclient_send_request (cl, msg);</a>
<a name="ln382">  return rc;</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">/* </a>
<a name="ln386"> * Synchronous request to synchronize with OSPF's LSDB.</a>
<a name="ln387"> * Two steps required: register_event in order to get</a>
<a name="ln388"> * dynamic updates and LSDB_Sync.</a>
<a name="ln389"> */</a>
<a name="ln390">int</a>
<a name="ln391">ospf_apiclient_sync_lsdb (struct ospf_apiclient *oclient)</a>
<a name="ln392">{</a>
<a name="ln393">  struct msg *msg;</a>
<a name="ln394">  int rc;</a>
<a name="ln395">  struct lsa_filter_type filter;</a>
<a name="ln396"> </a>
<a name="ln397">  filter.typemask = 0xFFFF;	/* all LSAs */</a>
<a name="ln398">  filter.origin = ANY_ORIGIN;</a>
<a name="ln399">  filter.num_areas = 0;		/* all Areas. */</a>
<a name="ln400"> </a>
<a name="ln401">  msg = new_msg_register_event (ospf_apiclient_get_seqnr (), &amp;filter);</a>
<a name="ln402">  if (!msg)</a>
<a name="ln403">    {</a>
<a name="ln404">      fprintf (stderr, &quot;new_msg_register_event failed\n&quot;);</a>
<a name="ln405">      return -1;</a>
<a name="ln406">    }</a>
<a name="ln407">  rc = ospf_apiclient_send_request (oclient, msg);</a>
<a name="ln408"> </a>
<a name="ln409">  if (rc != 0)</a>
<a name="ln410">    goto out;</a>
<a name="ln411"> </a>
<a name="ln412">  msg = new_msg_sync_lsdb (ospf_apiclient_get_seqnr (), &amp;filter);</a>
<a name="ln413">  if (!msg)</a>
<a name="ln414">    {</a>
<a name="ln415">      fprintf (stderr, &quot;new_msg_sync_lsdb failed\n&quot;);</a>
<a name="ln416">      return -1;</a>
<a name="ln417">    }</a>
<a name="ln418">  rc = ospf_apiclient_send_request (oclient, msg);</a>
<a name="ln419"> </a>
<a name="ln420">out:</a>
<a name="ln421">  return rc;</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">/* </a>
<a name="ln425"> * Synchronous request to originate or update an LSA.</a>
<a name="ln426"> */</a>
<a name="ln427"> </a>
<a name="ln428">int</a>
<a name="ln429">ospf_apiclient_lsa_originate (struct ospf_apiclient *oclient,</a>
<a name="ln430">			      struct in_addr ifaddr,</a>
<a name="ln431">			      struct in_addr area_id,</a>
<a name="ln432">			      u_char lsa_type,</a>
<a name="ln433">			      u_char opaque_type, u_int32_t opaque_id,</a>
<a name="ln434">			      void *opaquedata, int opaquelen)</a>
<a name="ln435">{</a>
<a name="ln436">  struct msg *msg;</a>
<a name="ln437">  int rc;</a>
<a name="ln438">  u_char buf[OSPF_MAX_LSA_SIZE];</a>
<a name="ln439">  struct lsa_header *lsah;</a>
<a name="ln440">  u_int32_t tmp;</a>
<a name="ln441"> </a>
<a name="ln442"> </a>
<a name="ln443">  /* We can only originate opaque LSAs */</a>
<a name="ln444">  if (!IS_OPAQUE_LSA (lsa_type))</a>
<a name="ln445">    {</a>
<a name="ln446">      fprintf (stderr, &quot;Cannot originate non-opaque LSA type %d\n&quot;, lsa_type);</a>
<a name="ln447">      return OSPF_API_ILLEGALLSATYPE;</a>
<a name="ln448">    }</a>
<a name="ln449"> </a>
<a name="ln450">  /* Make a new LSA from parameters */</a>
<a name="ln451">  lsah = (struct lsa_header *) buf;</a>
<a name="ln452">  lsah-&gt;ls_age = 0;</a>
<a name="ln453">  lsah-&gt;options = 0;</a>
<a name="ln454">  lsah-&gt;type = lsa_type;</a>
<a name="ln455"> </a>
<a name="ln456">  tmp = SET_OPAQUE_LSID (opaque_type, opaque_id);</a>
<a name="ln457">  lsah-&gt;id.s_addr = htonl (tmp);</a>
<a name="ln458">  lsah-&gt;adv_router.s_addr = 0;</a>
<a name="ln459">  lsah-&gt;ls_seqnum = 0;</a>
<a name="ln460">  lsah-&gt;checksum = 0;</a>
<a name="ln461">  lsah-&gt;length = htons (sizeof (struct lsa_header) + opaquelen);</a>
<a name="ln462"> </a>
<a name="ln463">  memcpy (((u_char *) lsah) + sizeof (struct lsa_header), opaquedata,</a>
<a name="ln464">	  opaquelen);</a>
<a name="ln465"> </a>
<a name="ln466">  msg = new_msg_originate_request (ospf_apiclient_get_seqnr (),</a>
<a name="ln467">				   ifaddr, area_id, lsah);</a>
<a name="ln468">  if (!msg)</a>
<a name="ln469">    {</a>
<a name="ln470">      fprintf (stderr, &quot;new_msg_originate_request failed\n&quot;);</a>
<a name="ln471">      return OSPF_API_NOMEMORY;</a>
<a name="ln472">    }</a>
<a name="ln473"> </a>
<a name="ln474">  rc = ospf_apiclient_send_request (oclient, msg);</a>
<a name="ln475">  return rc;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">int</a>
<a name="ln479">ospf_apiclient_lsa_delete (struct ospf_apiclient *oclient,</a>
<a name="ln480">			   struct in_addr area_id, u_char lsa_type,</a>
<a name="ln481">			   u_char opaque_type, u_int32_t opaque_id)</a>
<a name="ln482">{</a>
<a name="ln483">  struct msg *msg;</a>
<a name="ln484">  int rc;</a>
<a name="ln485"> </a>
<a name="ln486">  /* Only opaque LSA can be deleted */</a>
<a name="ln487">  if (!IS_OPAQUE_LSA (lsa_type))</a>
<a name="ln488">    {</a>
<a name="ln489">      fprintf (stderr, &quot;Cannot delete non-opaque LSA type %d\n&quot;, lsa_type);</a>
<a name="ln490">      return OSPF_API_ILLEGALLSATYPE;</a>
<a name="ln491">    }</a>
<a name="ln492"> </a>
<a name="ln493">  /* opaque_id is in host byte order and will be converted</a>
<a name="ln494">   * to network byte order by new_msg_delete_request */</a>
<a name="ln495">  msg = new_msg_delete_request (ospf_apiclient_get_seqnr (),</a>
<a name="ln496">				area_id, lsa_type, opaque_type, opaque_id);</a>
<a name="ln497"> </a>
<a name="ln498">  rc = ospf_apiclient_send_request (oclient, msg);</a>
<a name="ln499">  return rc;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">/* -----------------------------------------------------------</a>
<a name="ln503"> * Followings are handlers for messages from OSPF daemon</a>
<a name="ln504"> * -----------------------------------------------------------</a>
<a name="ln505"> */</a>
<a name="ln506"> </a>
<a name="ln507">static void</a>
<a name="ln508">ospf_apiclient_handle_ready (struct ospf_apiclient *oclient, struct msg *msg)</a>
<a name="ln509">{</a>
<a name="ln510">  struct msg_ready_notify *r;</a>
<a name="ln511">  r = (struct msg_ready_notify *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln512"> </a>
<a name="ln513">  /* Invoke registered callback function. */</a>
<a name="ln514">  if (oclient-&gt;ready_notify)</a>
<a name="ln515">    {</a>
<a name="ln516">      (oclient-&gt;ready_notify) (r-&gt;lsa_type, r-&gt;opaque_type, r-&gt;addr);</a>
<a name="ln517">    }</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">static void</a>
<a name="ln521">ospf_apiclient_handle_new_if (struct ospf_apiclient *oclient, struct msg *msg)</a>
<a name="ln522">{</a>
<a name="ln523">  struct msg_new_if *n;</a>
<a name="ln524">  n = (struct msg_new_if *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln525"> </a>
<a name="ln526">  /* Invoke registered callback function. */</a>
<a name="ln527">  if (oclient-&gt;new_if)</a>
<a name="ln528">    {</a>
<a name="ln529">      (oclient-&gt;new_if) (n-&gt;ifaddr, n-&gt;area_id);</a>
<a name="ln530">    }</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533">static void</a>
<a name="ln534">ospf_apiclient_handle_del_if (struct ospf_apiclient *oclient, struct msg *msg)</a>
<a name="ln535">{</a>
<a name="ln536">  struct msg_del_if *d;</a>
<a name="ln537">  d = (struct msg_del_if *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln538"> </a>
<a name="ln539">  /* Invoke registered callback function. */</a>
<a name="ln540">  if (oclient-&gt;del_if)</a>
<a name="ln541">    {</a>
<a name="ln542">      (oclient-&gt;del_if) (d-&gt;ifaddr);</a>
<a name="ln543">    }</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">static void</a>
<a name="ln547">ospf_apiclient_handle_ism_change (struct ospf_apiclient *oclient,</a>
<a name="ln548">				  struct msg *msg)</a>
<a name="ln549">{</a>
<a name="ln550">  struct msg_ism_change *m;</a>
<a name="ln551">  m = (struct msg_ism_change *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln552"> </a>
<a name="ln553">  /* Invoke registered callback function. */</a>
<a name="ln554">  if (oclient-&gt;ism_change)</a>
<a name="ln555">    {</a>
<a name="ln556">      (oclient-&gt;ism_change) (m-&gt;ifaddr, m-&gt;area_id, m-&gt;status);</a>
<a name="ln557">    }</a>
<a name="ln558"> </a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">static void</a>
<a name="ln562">ospf_apiclient_handle_nsm_change (struct ospf_apiclient *oclient,</a>
<a name="ln563">				  struct msg *msg)</a>
<a name="ln564">{</a>
<a name="ln565">  struct msg_nsm_change *m;</a>
<a name="ln566">  m = (struct msg_nsm_change *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln567"> </a>
<a name="ln568">  /* Invoke registered callback function. */</a>
<a name="ln569">  if (oclient-&gt;nsm_change)</a>
<a name="ln570">    {</a>
<a name="ln571">      (oclient-&gt;nsm_change) (m-&gt;ifaddr, m-&gt;nbraddr, m-&gt;router_id, m-&gt;status);</a>
<a name="ln572">    }</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">static void</a>
<a name="ln576">ospf_apiclient_handle_lsa_update (struct ospf_apiclient *oclient,</a>
<a name="ln577">				  struct msg *msg)</a>
<a name="ln578">{</a>
<a name="ln579">  struct msg_lsa_change_notify *cn;</a>
<a name="ln580">  struct lsa_header *lsa;</a>
<a name="ln581">  int lsalen;</a>
<a name="ln582"> </a>
<a name="ln583">  cn = (struct msg_lsa_change_notify *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln584"> </a>
<a name="ln585">  /* Extract LSA from message */</a>
<a name="ln586">  lsalen = ntohs (cn-&gt;data.length);</a>
<a name="ln587">  lsa = XMALLOC (MTYPE_OSPF_APICLIENT, lsalen);</a>
<a name="ln588">  if (!lsa)</a>
<a name="ln589">    {</a>
<a name="ln590">      fprintf (stderr, &quot;LSA update: Cannot allocate memory for LSA\n&quot;);</a>
<a name="ln591">      return;</a>
<a name="ln592">    }</a>
<a name="ln593">  memcpy (lsa, &amp;(cn-&gt;data), lsalen);</a>
<a name="ln594"> </a>
<a name="ln595">  /* Invoke registered update callback function */</a>
<a name="ln596">  if (oclient-&gt;update_notify)</a>
<a name="ln597">    {</a>
<a name="ln598">      (oclient-&gt;update_notify) (cn-&gt;ifaddr, cn-&gt;area_id, </a>
<a name="ln599">				cn-&gt;is_self_originated, lsa);</a>
<a name="ln600">    }</a>
<a name="ln601"> </a>
<a name="ln602">  /* free memory allocated by ospf apiclient library */</a>
<a name="ln603">  XFREE (MTYPE_OSPF_APICLIENT, lsa);</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">static void</a>
<a name="ln607">ospf_apiclient_handle_lsa_delete (struct ospf_apiclient *oclient,</a>
<a name="ln608">				  struct msg *msg)</a>
<a name="ln609">{</a>
<a name="ln610">  struct msg_lsa_change_notify *cn;</a>
<a name="ln611">  struct lsa_header *lsa;</a>
<a name="ln612">  int lsalen;</a>
<a name="ln613"> </a>
<a name="ln614">  cn = (struct msg_lsa_change_notify *) STREAM_DATA (msg-&gt;s);</a>
<a name="ln615"> </a>
<a name="ln616">  /* Extract LSA from message */</a>
<a name="ln617">  lsalen = ntohs (cn-&gt;data.length);</a>
<a name="ln618">  lsa = XMALLOC (MTYPE_OSPF_APICLIENT, lsalen);</a>
<a name="ln619">  if (!lsa)</a>
<a name="ln620">    {</a>
<a name="ln621">      fprintf (stderr, &quot;LSA delete: Cannot allocate memory for LSA\n&quot;);</a>
<a name="ln622">      return;</a>
<a name="ln623">    }</a>
<a name="ln624">  memcpy (lsa, &amp;(cn-&gt;data), lsalen);</a>
<a name="ln625"> </a>
<a name="ln626">  /* Invoke registered update callback function */</a>
<a name="ln627">  if (oclient-&gt;delete_notify)</a>
<a name="ln628">    {</a>
<a name="ln629">      (oclient-&gt;delete_notify) (cn-&gt;ifaddr, cn-&gt;area_id, </a>
<a name="ln630">				cn-&gt;is_self_originated, lsa);</a>
<a name="ln631">    }</a>
<a name="ln632"> </a>
<a name="ln633">  /* free memory allocated by ospf apiclient library */</a>
<a name="ln634">  XFREE (MTYPE_OSPF_APICLIENT, lsa);</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">static void</a>
<a name="ln638">ospf_apiclient_msghandle (struct ospf_apiclient *oclient, struct msg *msg)</a>
<a name="ln639">{</a>
<a name="ln640">  /* Call message handler function. */</a>
<a name="ln641">  switch (msg-&gt;hdr.msgtype)</a>
<a name="ln642">    {</a>
<a name="ln643">    case MSG_READY_NOTIFY:</a>
<a name="ln644">      ospf_apiclient_handle_ready (oclient, msg);</a>
<a name="ln645">      break;</a>
<a name="ln646">    case MSG_NEW_IF:</a>
<a name="ln647">      ospf_apiclient_handle_new_if (oclient, msg);</a>
<a name="ln648">      break;</a>
<a name="ln649">    case MSG_DEL_IF:</a>
<a name="ln650">      ospf_apiclient_handle_del_if (oclient, msg);</a>
<a name="ln651">      break;</a>
<a name="ln652">    case MSG_ISM_CHANGE:</a>
<a name="ln653">      ospf_apiclient_handle_ism_change (oclient, msg);</a>
<a name="ln654">      break;</a>
<a name="ln655">    case MSG_NSM_CHANGE:</a>
<a name="ln656">      ospf_apiclient_handle_nsm_change (oclient, msg);</a>
<a name="ln657">      break;</a>
<a name="ln658">    case MSG_LSA_UPDATE_NOTIFY:</a>
<a name="ln659">      ospf_apiclient_handle_lsa_update (oclient, msg);</a>
<a name="ln660">      break;</a>
<a name="ln661">    case MSG_LSA_DELETE_NOTIFY:</a>
<a name="ln662">      ospf_apiclient_handle_lsa_delete (oclient, msg);</a>
<a name="ln663">      break;</a>
<a name="ln664">    default:</a>
<a name="ln665">      fprintf (stderr, &quot;ospf_apiclient_read: Unknown message type: %d\n&quot;,</a>
<a name="ln666">	       msg-&gt;hdr.msgtype);</a>
<a name="ln667">      break;</a>
<a name="ln668">    }</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">/* -----------------------------------------------------------</a>
<a name="ln672"> * Callback handler registration</a>
<a name="ln673"> * -----------------------------------------------------------</a>
<a name="ln674"> */</a>
<a name="ln675"> </a>
<a name="ln676">void</a>
<a name="ln677">ospf_apiclient_register_callback (struct ospf_apiclient *oclient,</a>
<a name="ln678">				  void (*ready_notify) (u_char lsa_type,</a>
<a name="ln679">							u_char opaque_type,</a>
<a name="ln680">							struct in_addr addr),</a>
<a name="ln681">				  void (*new_if) (struct in_addr ifaddr,</a>
<a name="ln682">						  struct in_addr area_id),</a>
<a name="ln683">				  void (*del_if) (struct in_addr ifaddr),</a>
<a name="ln684">				  void (*ism_change) (struct in_addr ifaddr,</a>
<a name="ln685">						      struct in_addr area_id,</a>
<a name="ln686">						      u_char status),</a>
<a name="ln687">				  void (*nsm_change) (struct in_addr ifaddr,</a>
<a name="ln688">						      struct in_addr nbraddr,</a>
<a name="ln689">						      struct in_addr</a>
<a name="ln690">						      router_id,</a>
<a name="ln691">						      u_char status),</a>
<a name="ln692">				  void (*update_notify) (struct in_addr</a>
<a name="ln693">							 ifaddr,</a>
<a name="ln694">							 struct in_addr</a>
<a name="ln695">							 area_id,</a>
<a name="ln696">							 u_char self_origin,</a>
<a name="ln697">							 struct lsa_header *</a>
<a name="ln698">							 lsa),</a>
<a name="ln699">				  void (*delete_notify) (struct in_addr</a>
<a name="ln700">							 ifaddr,</a>
<a name="ln701">							 struct in_addr</a>
<a name="ln702">							 area_id,</a>
<a name="ln703">							 u_char self_origin,</a>
<a name="ln704">							 struct lsa_header *</a>
<a name="ln705">							 lsa))</a>
<a name="ln706">{</a>
<a name="ln707">  assert (oclient);</a>
<a name="ln708">  assert (update_notify);</a>
<a name="ln709"> </a>
<a name="ln710">  /* Register callback function */</a>
<a name="ln711">  oclient-&gt;ready_notify = ready_notify;</a>
<a name="ln712">  oclient-&gt;new_if = new_if;</a>
<a name="ln713">  oclient-&gt;del_if = del_if;</a>
<a name="ln714">  oclient-&gt;ism_change = ism_change;</a>
<a name="ln715">  oclient-&gt;nsm_change = nsm_change;</a>
<a name="ln716">  oclient-&gt;update_notify = update_notify;</a>
<a name="ln717">  oclient-&gt;delete_notify = delete_notify;</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">/* -----------------------------------------------------------</a>
<a name="ln721"> * Asynchronous message handling</a>
<a name="ln722"> * -----------------------------------------------------------</a>
<a name="ln723"> */</a>
<a name="ln724"> </a>
<a name="ln725">int</a>
<a name="ln726">ospf_apiclient_handle_async (struct ospf_apiclient *oclient)</a>
<a name="ln727">{</a>
<a name="ln728">  struct msg *msg;</a>
<a name="ln729"> </a>
<a name="ln730">  /* Get a message */</a>
<a name="ln731">  msg = msg_read (oclient-&gt;fd_async);</a>
<a name="ln732"> </a>
<a name="ln733">  if (!msg)</a>
<a name="ln734">    {</a>
<a name="ln735">      /* Connection broke down */</a>
<a name="ln736">      return -1;</a>
<a name="ln737">    }</a>
<a name="ln738"> </a>
<a name="ln739">  /* Handle message */</a>
<a name="ln740">  ospf_apiclient_msghandle (oclient, msg);</a>
<a name="ln741"> </a>
<a name="ln742">  /* Don't forget to free this message */</a>
<a name="ln743">  msg_free (msg);</a>
<a name="ln744"> </a>
<a name="ln745">  return 0;</a>
<a name="ln746">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="451"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'buf' is cast to a more strictly aligned pointer type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
