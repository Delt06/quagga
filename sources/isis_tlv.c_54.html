
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
  <title>isis_tlv.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol - isis_tlv.c</a>
<a name="ln3"> *                             IS-IS TLV related routines</a>
<a name="ln4"> *</a>
<a name="ln5"> * Copyright (C) 2001,2002   Sampo Saaristo</a>
<a name="ln6"> *                           Tampere University of Technology      </a>
<a name="ln7"> *                           Institute of Communications Engineering</a>
<a name="ln8"> *</a>
<a name="ln9"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln10"> * under the terms of the GNU General Public Licenseas published by the Free </a>
<a name="ln11"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln12"> * any later version.</a>
<a name="ln13"> *</a>
<a name="ln14"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln15"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln16"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln17"> * more details.</a>
<a name="ln18"> </a>
<a name="ln19"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln20"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln21"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;log.h&quot;</a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;stream.h&quot;</a>
<a name="ln29">#include &quot;memory.h&quot;</a>
<a name="ln30">#include &quot;prefix.h&quot;</a>
<a name="ln31">#include &quot;vty.h&quot;</a>
<a name="ln32">#include &quot;if.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;isisd/dict.h&quot;</a>
<a name="ln35">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln36">#include &quot;isisd/isis_common.h&quot;</a>
<a name="ln37">#include &quot;isisd/isis_flags.h&quot;</a>
<a name="ln38">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln39">#include &quot;isisd/isis_tlv.h&quot;</a>
<a name="ln40">#include &quot;isisd/isisd.h&quot;</a>
<a name="ln41">#include &quot;isisd/isis_dynhn.h&quot;</a>
<a name="ln42">#include &quot;isisd/isis_misc.h&quot;</a>
<a name="ln43">#include &quot;isisd/isis_pdu.h&quot;</a>
<a name="ln44">#include &quot;isisd/isis_lsp.h&quot;</a>
<a name="ln45">#include &quot;isisd/isis_te.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">void</a>
<a name="ln48">free_tlv (void *val)</a>
<a name="ln49">{</a>
<a name="ln50">  XFREE (MTYPE_ISIS_TLV, val);</a>
<a name="ln51"> </a>
<a name="ln52">  return;</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">/*</a>
<a name="ln56"> * Called after parsing of a PDU. There shouldn't be any tlv's left, so this</a>
<a name="ln57"> * is only a caution to avoid memory leaks</a>
<a name="ln58"> */</a>
<a name="ln59">void</a>
<a name="ln60">free_tlvs (struct tlvs *tlvs)</a>
<a name="ln61">{</a>
<a name="ln62">  if (tlvs-&gt;area_addrs)</a>
<a name="ln63">    list_delete (tlvs-&gt;area_addrs);</a>
<a name="ln64">  if (tlvs-&gt;is_neighs)</a>
<a name="ln65">    list_delete (tlvs-&gt;is_neighs);</a>
<a name="ln66">  if (tlvs-&gt;te_is_neighs)</a>
<a name="ln67">    list_delete (tlvs-&gt;te_is_neighs);</a>
<a name="ln68">  if (tlvs-&gt;es_neighs)</a>
<a name="ln69">    list_delete (tlvs-&gt;es_neighs);</a>
<a name="ln70">  if (tlvs-&gt;lsp_entries)</a>
<a name="ln71">    list_delete (tlvs-&gt;lsp_entries);</a>
<a name="ln72">  if (tlvs-&gt;prefix_neighs)</a>
<a name="ln73">    list_delete (tlvs-&gt;prefix_neighs);</a>
<a name="ln74">  if (tlvs-&gt;lan_neighs)</a>
<a name="ln75">    list_delete (tlvs-&gt;lan_neighs);</a>
<a name="ln76">  if (tlvs-&gt;ipv4_addrs)</a>
<a name="ln77">    list_delete (tlvs-&gt;ipv4_addrs);</a>
<a name="ln78">  if (tlvs-&gt;ipv4_int_reachs)</a>
<a name="ln79">    list_delete (tlvs-&gt;ipv4_int_reachs);</a>
<a name="ln80">  if (tlvs-&gt;ipv4_ext_reachs)</a>
<a name="ln81">    list_delete (tlvs-&gt;ipv4_ext_reachs);</a>
<a name="ln82">  if (tlvs-&gt;te_ipv4_reachs)</a>
<a name="ln83">    list_delete (tlvs-&gt;te_ipv4_reachs);</a>
<a name="ln84">#ifdef HAVE_IPV6</a>
<a name="ln85">  if (tlvs-&gt;ipv6_addrs)</a>
<a name="ln86">    list_delete (tlvs-&gt;ipv6_addrs);</a>
<a name="ln87">  if (tlvs-&gt;ipv6_reachs)</a>
<a name="ln88">    list_delete (tlvs-&gt;ipv6_reachs);</a>
<a name="ln89">#endif /* HAVE_IPV6 */</a>
<a name="ln90"> </a>
<a name="ln91">  memset (tlvs, 0, sizeof (struct tlvs));</a>
<a name="ln92"> </a>
<a name="ln93">  return;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">/*</a>
<a name="ln97"> * Parses the tlvs found in the variant length part of the PDU.</a>
<a name="ln98"> * Caller tells with flags in &quot;expected&quot; which TLV's it is interested in.</a>
<a name="ln99"> */</a>
<a name="ln100">int</a>
<a name="ln101">parse_tlvs (char *areatag, u_char * stream, int size, u_int32_t * expected,</a>
<a name="ln102">	    u_int32_t * found, struct tlvs *tlvs, u_int32_t *auth_tlv_offset)</a>
<a name="ln103">{</a>
<a name="ln104">  u_char type, length;</a>
<a name="ln105">  struct lan_neigh *lan_nei;</a>
<a name="ln106">  struct area_addr *area_addr;</a>
<a name="ln107">  struct is_neigh *is_nei;</a>
<a name="ln108">  struct te_is_neigh *te_is_nei;</a>
<a name="ln109">  struct es_neigh *es_nei;</a>
<a name="ln110">  struct lsp_entry *lsp_entry;</a>
<a name="ln111">  struct in_addr *ipv4_addr;</a>
<a name="ln112">  struct ipv4_reachability *ipv4_reach;</a>
<a name="ln113">  struct te_ipv4_reachability *te_ipv4_reach;</a>
<a name="ln114">#ifdef HAVE_IPV6</a>
<a name="ln115">  struct in6_addr *ipv6_addr;</a>
<a name="ln116">  struct ipv6_reachability *ipv6_reach;</a>
<a name="ln117">  int prefix_octets;</a>
<a name="ln118">#endif /* HAVE_IPV6 */</a>
<a name="ln119">  int value_len, retval = ISIS_OK;</a>
<a name="ln120">  u_char *start = stream, *pnt = stream, *endpnt;</a>
<a name="ln121"> </a>
<a name="ln122">  *found = 0;</a>
<a name="ln123">  memset (tlvs, 0, sizeof (struct tlvs));</a>
<a name="ln124"> </a>
<a name="ln125">  while (pnt &lt; stream + size - 2)</a>
<a name="ln126">    {</a>
<a name="ln127">      type = *pnt;</a>
<a name="ln128">      length = *(pnt + 1);</a>
<a name="ln129">      pnt += 2;</a>
<a name="ln130">      value_len = 0;</a>
<a name="ln131">      if (pnt + length &gt; stream + size)</a>
<a name="ln132">	{</a>
<a name="ln133">	  zlog_warn (&quot;ISIS-TLV (%s): TLV (type %d, length %d) exceeds packet &quot;</a>
<a name="ln134">		     &quot;boundaries&quot;, areatag, type, length);</a>
<a name="ln135">	  retval = ISIS_WARNING;</a>
<a name="ln136">	  break;</a>
<a name="ln137">	}</a>
<a name="ln138">      switch (type)</a>
<a name="ln139">	{</a>
<a name="ln140">	case AREA_ADDRESSES:</a>
<a name="ln141">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln142">	   * |                        Address Length                         | </a>
<a name="ln143">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln144">	   * |                         Area Address                          | </a>
<a name="ln145">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln146">	   * :                                                               :</a>
<a name="ln147">	   */</a>
<a name="ln148">	  *found |= TLVFLAG_AREA_ADDRS;</a>
<a name="ln149">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln150">	  zlog_debug (&quot;TLV Area Adresses len %d&quot;, length);</a>
<a name="ln151">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln152">	  if (*expected &amp; TLVFLAG_AREA_ADDRS)</a>
<a name="ln153">	    {</a>
<a name="ln154">	      while (length &gt; value_len)</a>
<a name="ln155">		{</a>
<a name="ln156">		  area_addr = (struct area_addr *) pnt;</a>
<a name="ln157">		  value_len += area_addr-&gt;addr_len + 1;</a>
<a name="ln158">		  pnt += area_addr-&gt;addr_len + 1;</a>
<a name="ln159">		  if (!tlvs-&gt;area_addrs)</a>
<a name="ln160">		    tlvs-&gt;area_addrs = list_new ();</a>
<a name="ln161">		  listnode_add (tlvs-&gt;area_addrs, area_addr);</a>
<a name="ln162">		}</a>
<a name="ln163">	    }</a>
<a name="ln164">	  else</a>
<a name="ln165">	    {</a>
<a name="ln166">	      pnt += length;</a>
<a name="ln167">	    }</a>
<a name="ln168">	  break;</a>
<a name="ln169"> </a>
<a name="ln170">	case IS_NEIGHBOURS:</a>
<a name="ln171">	  *found |= TLVFLAG_IS_NEIGHS;</a>
<a name="ln172">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln173">	  zlog_debug (&quot;ISIS-TLV (%s): IS Neighbours length %d&quot;,</a>
<a name="ln174">		      areatag, length);</a>
<a name="ln175">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln176">	  if (TLVFLAG_IS_NEIGHS &amp; *expected)</a>
<a name="ln177">	    {</a>
<a name="ln178">	      /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln179">	       * |                        Virtual Flag                           | </a>
<a name="ln180">	       * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln181">	       */</a>
<a name="ln182">	      pnt++;</a>
<a name="ln183">	      value_len++;</a>
<a name="ln184">	      /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln185">	       * |   0   |  I/E  |               Default Metric                  | </a>
<a name="ln186">	       * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln187">	       * |   S   |  I/E  |               Delay Metric                    |</a>
<a name="ln188">	       * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln189">	       * |   S   |  I/E  |               Expense Metric                  |</a>
<a name="ln190">	       * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln191">	       * |   S   |  I/E  |               Error Metric                    |</a>
<a name="ln192">	       * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln193">	       * |                        Neighbour ID                           |</a>
<a name="ln194">	       * +---------------------------------------------------------------+</a>
<a name="ln195">	       * :                                                               :</a>
<a name="ln196">	       */</a>
<a name="ln197">	      while (length &gt; value_len)</a>
<a name="ln198">		{</a>
<a name="ln199">		  is_nei = (struct is_neigh *) pnt;</a>
<a name="ln200">		  value_len += 4 + ISIS_SYS_ID_LEN + 1;</a>
<a name="ln201">		  pnt += 4 + ISIS_SYS_ID_LEN + 1;</a>
<a name="ln202">		  if (!tlvs-&gt;is_neighs)</a>
<a name="ln203">		    tlvs-&gt;is_neighs = list_new ();</a>
<a name="ln204">		  listnode_add (tlvs-&gt;is_neighs, is_nei);</a>
<a name="ln205">		}</a>
<a name="ln206">	    }</a>
<a name="ln207">	  else</a>
<a name="ln208">	    {</a>
<a name="ln209">	      pnt += length;</a>
<a name="ln210">	    }</a>
<a name="ln211">	  break;</a>
<a name="ln212"> </a>
<a name="ln213">	case TE_IS_NEIGHBOURS:</a>
<a name="ln214">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln215">	   * |                        Neighbour ID                           | 7</a>
<a name="ln216">	   * +---------------------------------------------------------------+</a>
<a name="ln217">	   * |                        TE Metric                              | 3</a>
<a name="ln218">	   * +---------------------------------------------------------------+</a>
<a name="ln219">	   * |                        SubTLVs Length                         | 1</a>
<a name="ln220">	   * +---------------------------------------------------------------+</a>
<a name="ln221">	   * :                                                               :</a>
<a name="ln222">	   */</a>
<a name="ln223">	  *found |= TLVFLAG_TE_IS_NEIGHS;</a>
<a name="ln224">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln225">	  zlog_debug (&quot;ISIS-TLV (%s): Extended IS Neighbours length %d&quot;,</a>
<a name="ln226">		     areatag, length);</a>
<a name="ln227">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln228">	  if (TLVFLAG_TE_IS_NEIGHS &amp; *expected)</a>
<a name="ln229">	    {</a>
<a name="ln230">	      while (length &gt; value_len)</a>
<a name="ln231">		{</a>
<a name="ln232">		  te_is_nei = (struct te_is_neigh *) pnt;</a>
<a name="ln233">		  value_len += IS_NEIGHBOURS_LEN;</a>
<a name="ln234">		  pnt += IS_NEIGHBOURS_LEN;</a>
<a name="ln235">                  /* FIXME - subtlvs are handled here, for now we skip */</a>
<a name="ln236">		  /* FIXME: All TE SubTLVs are not necessary present in LSP PDU. */</a>
<a name="ln237">		  /* So, it must be copied in a new te_is_neigh structure        */</a>
<a name="ln238">		  /* rather than just initialize pointer to the original LSP PDU */</a>
<a name="ln239">		  /* to avoid consider the rest of lspdu as subTLVs or buffer overflow */</a>
<a name="ln240">		  if (IS_MPLS_TE(isisMplsTE))</a>
<a name="ln241">		    {</a>
<a name="ln242">		      struct te_is_neigh *new = XCALLOC(MTYPE_ISIS_TLV, sizeof(struct te_is_neigh));</a>
<a name="ln243">		      memcpy(new-&gt;neigh_id, te_is_nei-&gt;neigh_id, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln244">		      memcpy(new-&gt;te_metric, te_is_nei-&gt;te_metric, 3);</a>
<a name="ln245">		      new-&gt;sub_tlvs_length = te_is_nei-&gt;sub_tlvs_length;</a>
<a name="ln246">		      memcpy(new-&gt;sub_tlvs, pnt, te_is_nei-&gt;sub_tlvs_length);</a>
<a name="ln247">                      te_is_nei = new;</a>
<a name="ln248">                    }</a>
<a name="ln249">		  /* Skip SUB TLVs payload */</a>
<a name="ln250">		  value_len += te_is_nei-&gt;sub_tlvs_length;</a>
<a name="ln251">		  pnt += te_is_nei-&gt;sub_tlvs_length;</a>
<a name="ln252"> </a>
<a name="ln253">		  if (!tlvs-&gt;te_is_neighs)</a>
<a name="ln254">		    tlvs-&gt;te_is_neighs = list_new ();</a>
<a name="ln255">		  listnode_add (tlvs-&gt;te_is_neighs, te_is_nei);</a>
<a name="ln256">		}</a>
<a name="ln257">	    }</a>
<a name="ln258">	  else</a>
<a name="ln259">	    {</a>
<a name="ln260">	      pnt += length;</a>
<a name="ln261">	    }</a>
<a name="ln262">	  break;</a>
<a name="ln263"> </a>
<a name="ln264">	case ES_NEIGHBOURS:</a>
<a name="ln265">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln266">	   * |   0   |  I/E  |               Default Metric                  | </a>
<a name="ln267">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln268">	   * |   S   |  I/E  |               Delay Metric                    |</a>
<a name="ln269">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln270">	   * |   S   |  I/E  |               Expense Metric                  |</a>
<a name="ln271">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln272">	   * |   S   |  I/E  |               Error Metric                    |</a>
<a name="ln273">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln274">	   * |                        Neighbour ID                           |</a>
<a name="ln275">	   * +---------------------------------------------------------------+</a>
<a name="ln276">	   * |                        Neighbour ID                           |</a>
<a name="ln277">	   * +---------------------------------------------------------------+</a>
<a name="ln278">	   * :                                                               :</a>
<a name="ln279">	   */</a>
<a name="ln280">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln281">	  zlog_debug (&quot;ISIS-TLV (%s): ES Neighbours length %d&quot;,</a>
<a name="ln282">		     areatag, length);</a>
<a name="ln283">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln284">	  *found |= TLVFLAG_ES_NEIGHS;</a>
<a name="ln285">	  if (*expected &amp; TLVFLAG_ES_NEIGHS)</a>
<a name="ln286">	    {</a>
<a name="ln287">	      es_nei = (struct es_neigh *) pnt;</a>
<a name="ln288">	      value_len += 4;</a>
<a name="ln289">	      pnt += 4;</a>
<a name="ln290">	      while (length &gt; value_len)</a>
<a name="ln291">		{</a>
<a name="ln292">		  /* FIXME FIXME FIXME - add to the list */</a>
<a name="ln293">		  /*          sys_id-&gt;id = pnt; */</a>
<a name="ln294">		  value_len += ISIS_SYS_ID_LEN;</a>
<a name="ln295">		  pnt += ISIS_SYS_ID_LEN;</a>
<a name="ln296">		  /*  if (!es_nei-&gt;neigh_ids) es_nei-&gt;neigh_ids = sysid; */</a>
<a name="ln297">		}</a>
<a name="ln298">	      if (!tlvs-&gt;es_neighs)</a>
<a name="ln299">		tlvs-&gt;es_neighs = list_new ();</a>
<a name="ln300">	      listnode_add (tlvs-&gt;es_neighs, es_nei);</a>
<a name="ln301">	    }</a>
<a name="ln302">	  else</a>
<a name="ln303">	    {</a>
<a name="ln304">	      pnt += length;</a>
<a name="ln305">	    }</a>
<a name="ln306">	  break;</a>
<a name="ln307"> </a>
<a name="ln308">	case LAN_NEIGHBOURS:</a>
<a name="ln309">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln310">	   * |                        LAN Address                            | </a>
<a name="ln311">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln312">	   * :                                                               :</a>
<a name="ln313">	   */</a>
<a name="ln314">	  *found |= TLVFLAG_LAN_NEIGHS;</a>
<a name="ln315">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln316">	  zlog_debug (&quot;ISIS-TLV (%s): LAN Neigbours length %d&quot;,</a>
<a name="ln317">		      areatag, length);</a>
<a name="ln318">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln319">	  if (TLVFLAG_LAN_NEIGHS &amp; *expected)</a>
<a name="ln320">	    {</a>
<a name="ln321">	      while (length &gt; value_len)</a>
<a name="ln322">		{</a>
<a name="ln323">		  lan_nei = (struct lan_neigh *) pnt;</a>
<a name="ln324">		  if (!tlvs-&gt;lan_neighs)</a>
<a name="ln325">		    tlvs-&gt;lan_neighs = list_new ();</a>
<a name="ln326">		  listnode_add (tlvs-&gt;lan_neighs, lan_nei);</a>
<a name="ln327">		  value_len += ETH_ALEN;</a>
<a name="ln328">		  pnt += ETH_ALEN;</a>
<a name="ln329">		}</a>
<a name="ln330">	    }</a>
<a name="ln331">	  else</a>
<a name="ln332">	    {</a>
<a name="ln333">	      pnt += length;</a>
<a name="ln334">	    }</a>
<a name="ln335">	  break;</a>
<a name="ln336"> </a>
<a name="ln337">	case PADDING:</a>
<a name="ln338">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln339">	  zlog_debug (&quot;TLV padding %d&quot;, length);</a>
<a name="ln340">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln341">	  pnt += length;</a>
<a name="ln342">	  break;</a>
<a name="ln343"> </a>
<a name="ln344">	case LSP_ENTRIES:</a>
<a name="ln345">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln346">	   * |                     Remaining Lifetime                        | 2</a>
<a name="ln347">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln348">	   * |                         LSP ID                                | id+2</a>
<a name="ln349">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln350">	   * |                   LSP Sequence Number                         | 4</a>
<a name="ln351">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln352">	   * |                        Checksum                               | 2</a>
<a name="ln353">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln354">	   */</a>
<a name="ln355">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln356">	  zlog_debug (&quot;ISIS-TLV (%s): LSP Entries length %d&quot;, areatag, length);</a>
<a name="ln357">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln358">	  *found |= TLVFLAG_LSP_ENTRIES;</a>
<a name="ln359">	  if (TLVFLAG_LSP_ENTRIES &amp; *expected)</a>
<a name="ln360">	    {</a>
<a name="ln361">	      while (length &gt; value_len)</a>
<a name="ln362">		{</a>
<a name="ln363">		  lsp_entry = (struct lsp_entry *) pnt;</a>
<a name="ln364">		  value_len += 10 + ISIS_SYS_ID_LEN;</a>
<a name="ln365">		  pnt += 10 + ISIS_SYS_ID_LEN;</a>
<a name="ln366">		  if (!tlvs-&gt;lsp_entries)</a>
<a name="ln367">		    tlvs-&gt;lsp_entries = list_new ();</a>
<a name="ln368">		  listnode_add (tlvs-&gt;lsp_entries, lsp_entry);</a>
<a name="ln369">		}</a>
<a name="ln370">	    }</a>
<a name="ln371">	  else</a>
<a name="ln372">	    {</a>
<a name="ln373">	      pnt += length;</a>
<a name="ln374">	    }</a>
<a name="ln375">	  break;</a>
<a name="ln376"> </a>
<a name="ln377">	case CHECKSUM:</a>
<a name="ln378">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln379">	   * |                   16 bit fletcher CHECKSUM                    |</a>
<a name="ln380">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln381">	   * :                                                               :</a>
<a name="ln382">	   */</a>
<a name="ln383">	  *found |= TLVFLAG_CHECKSUM;</a>
<a name="ln384">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln385">	  zlog_debug (&quot;ISIS-TLV (%s): Checksum length %d&quot;, areatag, length);</a>
<a name="ln386">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln387">	  if (*expected &amp; TLVFLAG_CHECKSUM)</a>
<a name="ln388">	    {</a>
<a name="ln389">	      tlvs-&gt;checksum = (struct checksum *) pnt;</a>
<a name="ln390">	    }</a>
<a name="ln391">	  pnt += length;</a>
<a name="ln392">	  break;</a>
<a name="ln393"> </a>
<a name="ln394">	case PROTOCOLS_SUPPORTED:</a>
<a name="ln395">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln396">	   * |                       NLPID                                   |</a>
<a name="ln397">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln398">	   * :                                                               :</a>
<a name="ln399">	   */</a>
<a name="ln400">	  *found |= TLVFLAG_NLPID;</a>
<a name="ln401">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln402">	  zlog_debug (&quot;ISIS-TLV (%s): Protocols Supported length %d&quot;,</a>
<a name="ln403">		      areatag, length);</a>
<a name="ln404">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln405">	  if (*expected &amp; TLVFLAG_NLPID)</a>
<a name="ln406">	    {</a>
<a name="ln407">	      tlvs-&gt;nlpids = (struct nlpids *) (pnt - 1);</a>
<a name="ln408">	    }</a>
<a name="ln409">	  pnt += length;</a>
<a name="ln410">	  break;</a>
<a name="ln411"> </a>
<a name="ln412">	case IPV4_ADDR:</a>
<a name="ln413">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln414">	   * +                 IP version 4 address                          + 4</a>
<a name="ln415">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln416">	   * :                                                               :</a>
<a name="ln417">	   */</a>
<a name="ln418">	  *found |= TLVFLAG_IPV4_ADDR;</a>
<a name="ln419">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln420">	  zlog_debug (&quot;ISIS-TLV (%s): IPv4 Address length %d&quot;,</a>
<a name="ln421">		      areatag, length);</a>
<a name="ln422">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln423">	  if (*expected &amp; TLVFLAG_IPV4_ADDR)</a>
<a name="ln424">	    {</a>
<a name="ln425">	      while (length &gt; value_len)</a>
<a name="ln426">		{</a>
<a name="ln427">		  ipv4_addr = (struct in_addr *) pnt;</a>
<a name="ln428">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln429">		  zlog_debug (&quot;ISIS-TLV (%s) : IP ADDR %s, pnt %p&quot;, areatag,</a>
<a name="ln430">			      inet_ntoa (*ipv4_addr), pnt);</a>
<a name="ln431">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln432">		  if (!tlvs-&gt;ipv4_addrs)</a>
<a name="ln433">		    tlvs-&gt;ipv4_addrs = list_new ();</a>
<a name="ln434">		  listnode_add (tlvs-&gt;ipv4_addrs, ipv4_addr);</a>
<a name="ln435">		  value_len += 4;</a>
<a name="ln436">		  pnt += 4;</a>
<a name="ln437">		}</a>
<a name="ln438">	    }</a>
<a name="ln439">	  else</a>
<a name="ln440">	    {</a>
<a name="ln441">	      pnt += length;</a>
<a name="ln442">	    }</a>
<a name="ln443">	  break;</a>
<a name="ln444"> </a>
<a name="ln445">	case AUTH_INFO:</a>
<a name="ln446">	  *found |= TLVFLAG_AUTH_INFO;</a>
<a name="ln447">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln448">	  zlog_debug (&quot;ISIS-TLV (%s): IS-IS Authentication Information&quot;,</a>
<a name="ln449">		      areatag);</a>
<a name="ln450">#endif</a>
<a name="ln451">	  if (*expected &amp; TLVFLAG_AUTH_INFO)</a>
<a name="ln452">	    {</a>
<a name="ln453">	      tlvs-&gt;auth_info.type = *pnt;</a>
<a name="ln454">              if (length == 0)</a>
<a name="ln455">                {</a>
<a name="ln456">                  zlog_warn (&quot;ISIS-TLV (%s): TLV (type %d, length %d) &quot;</a>
<a name="ln457">                             &quot;incorrect.&quot;, areatag, type, length);</a>
<a name="ln458">                  return ISIS_WARNING;</a>
<a name="ln459">                }</a>
<a name="ln460">              --length;</a>
<a name="ln461">	      tlvs-&gt;auth_info.len = length;</a>
<a name="ln462">	      pnt++;</a>
<a name="ln463">	      memcpy (tlvs-&gt;auth_info.passwd, pnt, length);</a>
<a name="ln464">              /* Return the authentication tlv pos for later computation</a>
<a name="ln465">               * of MD5 (RFC 5304, 2)</a>
<a name="ln466">               */</a>
<a name="ln467">              if (auth_tlv_offset)</a>
<a name="ln468">                *auth_tlv_offset += (pnt - start - 3);</a>
<a name="ln469">              pnt += length;</a>
<a name="ln470">	    }</a>
<a name="ln471">	  else</a>
<a name="ln472">	    {</a>
<a name="ln473">	      pnt += length;</a>
<a name="ln474">	    }</a>
<a name="ln475">	  break;</a>
<a name="ln476"> </a>
<a name="ln477">	case DYNAMIC_HOSTNAME:</a>
<a name="ln478">	  *found |= TLVFLAG_DYN_HOSTNAME;</a>
<a name="ln479">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln480">	  zlog_debug (&quot;ISIS-TLV (%s): Dynamic Hostname length %d&quot;,</a>
<a name="ln481">		      areatag, length);</a>
<a name="ln482">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln483">	  if (*expected &amp; TLVFLAG_DYN_HOSTNAME)</a>
<a name="ln484">	    {</a>
<a name="ln485">	      /* the length is also included in the pointed struct */</a>
<a name="ln486">	      tlvs-&gt;hostname = (struct hostname *) (pnt - 1);</a>
<a name="ln487">	    }</a>
<a name="ln488">	  pnt += length;</a>
<a name="ln489">	  break;</a>
<a name="ln490"> </a>
<a name="ln491">	case TE_ROUTER_ID:</a>
<a name="ln492">	  /* +---------------------------------------------------------------+</a>
<a name="ln493">	   * +                         Router ID                             + 4</a>
<a name="ln494">	   * +---------------------------------------------------------------+</a>
<a name="ln495">	   */</a>
<a name="ln496">	  *found |= TLVFLAG_TE_ROUTER_ID;</a>
<a name="ln497">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln498">	  zlog_debug (&quot;ISIS-TLV (%s): TE Router ID %d&quot;, areatag, length);</a>
<a name="ln499">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln500">	  if (*expected &amp; TLVFLAG_TE_ROUTER_ID)</a>
<a name="ln501">	    tlvs-&gt;router_id = (struct te_router_id *) (pnt);</a>
<a name="ln502">	  pnt += length;</a>
<a name="ln503">	  break;</a>
<a name="ln504"> </a>
<a name="ln505">	case IPV4_INT_REACHABILITY:</a>
<a name="ln506">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln507">	   * |   0   |  I/E  |               Default Metric                  | 1</a>
<a name="ln508">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln509">	   * |   S   |  I/E  |               Delay Metric                    | 1</a>
<a name="ln510">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln511">	   * |   S   |  I/E  |               Expense Metric                  | 1</a>
<a name="ln512">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln513">	   * |   S   |  I/E  |               Error Metric                    | 1</a>
<a name="ln514">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln515">	   * |                        ip address                             | 4</a>
<a name="ln516">	   * +---------------------------------------------------------------+</a>
<a name="ln517">	   * |                        address mask                           | 4</a>
<a name="ln518">	   * +---------------------------------------------------------------+</a>
<a name="ln519">	   * :                                                               :</a>
<a name="ln520">	   */</a>
<a name="ln521">	  *found |= TLVFLAG_IPV4_INT_REACHABILITY;</a>
<a name="ln522">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln523">	  zlog_debug (&quot;ISIS-TLV (%s): IPv4 internal Reachability length %d&quot;,</a>
<a name="ln524">		      areatag, length);</a>
<a name="ln525">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln526">	  if (*expected &amp; TLVFLAG_IPV4_INT_REACHABILITY)</a>
<a name="ln527">	    {</a>
<a name="ln528">	      while (length &gt; value_len)</a>
<a name="ln529">		{</a>
<a name="ln530">		  ipv4_reach = (struct ipv4_reachability *) pnt;</a>
<a name="ln531">		  if (!tlvs-&gt;ipv4_int_reachs)</a>
<a name="ln532">		    tlvs-&gt;ipv4_int_reachs = list_new ();</a>
<a name="ln533">		  listnode_add (tlvs-&gt;ipv4_int_reachs, ipv4_reach);</a>
<a name="ln534">		  value_len += 12;</a>
<a name="ln535">		  pnt += 12;</a>
<a name="ln536">		}</a>
<a name="ln537">	    }</a>
<a name="ln538">	  else</a>
<a name="ln539">	    {</a>
<a name="ln540">	      pnt += length;</a>
<a name="ln541">	    }</a>
<a name="ln542">	  break;</a>
<a name="ln543"> </a>
<a name="ln544">	case IPV4_EXT_REACHABILITY:</a>
<a name="ln545">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln546">	   * |   0   |  I/E  |               Default Metric                  | 1</a>
<a name="ln547">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln548">	   * |   S   |  I/E  |               Delay Metric                    | 1</a>
<a name="ln549">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln550">	   * |   S   |  I/E  |               Expense Metric                  | 1</a>
<a name="ln551">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln552">	   * |   S   |  I/E  |               Error Metric                    | 1</a>
<a name="ln553">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln554">	   * |                        ip address                             | 4</a>
<a name="ln555">	   * +---------------------------------------------------------------+</a>
<a name="ln556">	   * |                        address mask                           | 4</a>
<a name="ln557">	   * +---------------------------------------------------------------+</a>
<a name="ln558">	   * :                                                               :</a>
<a name="ln559">	   */</a>
<a name="ln560">	  *found |= TLVFLAG_IPV4_EXT_REACHABILITY;</a>
<a name="ln561">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln562">	  zlog_debug (&quot;ISIS-TLV (%s): IPv4 external Reachability length %d&quot;,</a>
<a name="ln563">		      areatag, length);</a>
<a name="ln564">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln565">	  if (*expected &amp; TLVFLAG_IPV4_EXT_REACHABILITY)</a>
<a name="ln566">	    {</a>
<a name="ln567">	      while (length &gt; value_len)</a>
<a name="ln568">		{</a>
<a name="ln569">		  ipv4_reach = (struct ipv4_reachability *) pnt;</a>
<a name="ln570">		  if (!tlvs-&gt;ipv4_ext_reachs)</a>
<a name="ln571">		    tlvs-&gt;ipv4_ext_reachs = list_new ();</a>
<a name="ln572">		  listnode_add (tlvs-&gt;ipv4_ext_reachs, ipv4_reach);</a>
<a name="ln573">		  value_len += 12;</a>
<a name="ln574">		  pnt += 12;</a>
<a name="ln575">		}</a>
<a name="ln576">	    }</a>
<a name="ln577">	  else</a>
<a name="ln578">	    {</a>
<a name="ln579">	      pnt += length;</a>
<a name="ln580">	    }</a>
<a name="ln581">	  break;</a>
<a name="ln582"> </a>
<a name="ln583">	case TE_IPV4_REACHABILITY:</a>
<a name="ln584">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln585">	   * |                        TE Metric                              | 4</a>
<a name="ln586">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln587">	   * |  U/D  | sTLV? |               Prefix Mask Len                 | 1</a>
<a name="ln588">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln589">	   * |                           Prefix                              | 0-4</a>
<a name="ln590">	   * +---------------------------------------------------------------+</a>
<a name="ln591">	   * |                         sub tlvs                              |</a>
<a name="ln592">	   * +---------------------------------------------------------------+</a>
<a name="ln593">	   * :                                                               :</a>
<a name="ln594">	   */</a>
<a name="ln595">	  *found |= TLVFLAG_TE_IPV4_REACHABILITY;</a>
<a name="ln596">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln597">	  zlog_debug (&quot;ISIS-TLV (%s): IPv4 extended Reachability length %d&quot;,</a>
<a name="ln598">		      areatag, length);</a>
<a name="ln599">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln600">	  endpnt = pnt + length;</a>
<a name="ln601">	  if (*expected &amp; TLVFLAG_TE_IPV4_REACHABILITY)</a>
<a name="ln602">	    {</a>
<a name="ln603">	      while (length &gt; value_len)</a>
<a name="ln604">		{</a>
<a name="ln605">		  te_ipv4_reach = (struct te_ipv4_reachability *) pnt;</a>
<a name="ln606">		  if ((te_ipv4_reach-&gt;control &amp; 0x3F) &gt; IPV4_MAX_BITLEN)</a>
<a name="ln607">		    {</a>
<a name="ln608">		      zlog_warn (&quot;ISIS-TLV (%s): invalid IPv4 extended reach&quot;</a>
<a name="ln609">				 &quot;ability prefix length %d&quot;, areatag,</a>
<a name="ln610">				 te_ipv4_reach-&gt;control &amp; 0x3F);</a>
<a name="ln611">		      retval = ISIS_WARNING;</a>
<a name="ln612">		      break;</a>
<a name="ln613">		    }</a>
<a name="ln614">		  if (!tlvs-&gt;te_ipv4_reachs)</a>
<a name="ln615">		    tlvs-&gt;te_ipv4_reachs = list_new ();</a>
<a name="ln616">		  listnode_add (tlvs-&gt;te_ipv4_reachs, te_ipv4_reach);</a>
<a name="ln617">		  /* this trickery is permitable since no subtlvs are defined */</a>
<a name="ln618">		  value_len += 5 + ((te_ipv4_reach-&gt;control &amp; 0x3F) ?</a>
<a name="ln619">				    ((((te_ipv4_reach-&gt;control &amp; 0x3F) -</a>
<a name="ln620">				       1) &gt;&gt; 3) + 1) : 0);</a>
<a name="ln621">		  pnt += 5 + ((te_ipv4_reach-&gt;control &amp; 0x3F) ?</a>
<a name="ln622">		              ((((te_ipv4_reach-&gt;control &amp; 0x3F) - 1) &gt;&gt; 3) + 1) : 0);</a>
<a name="ln623">		}</a>
<a name="ln624">	    }</a>
<a name="ln625"> </a>
<a name="ln626">	  pnt = endpnt;</a>
<a name="ln627">	  break;</a>
<a name="ln628"> </a>
<a name="ln629">#ifdef  HAVE_IPV6</a>
<a name="ln630">	case IPV6_ADDR:</a>
<a name="ln631">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln632">	   * +                 IP version 6 address                          + 16</a>
<a name="ln633">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln634">	   * :                                                               :</a>
<a name="ln635">	   */</a>
<a name="ln636">	  *found |= TLVFLAG_IPV6_ADDR;</a>
<a name="ln637">#ifdef EXTREME_TLV_DEBUG</a>
<a name="ln638">	  zlog_debug (&quot;ISIS-TLV (%s): IPv6 Address length %d&quot;,</a>
<a name="ln639">		      areatag, length);</a>
<a name="ln640">#endif /* EXTREME_TLV_DEBUG */</a>
<a name="ln641">	  if (*expected &amp; TLVFLAG_IPV6_ADDR)</a>
<a name="ln642">	    {</a>
<a name="ln643">	      while (length &gt; value_len)</a>
<a name="ln644">		{</a>
<a name="ln645">		  ipv6_addr = (struct in6_addr *) pnt;</a>
<a name="ln646">		  if (!tlvs-&gt;ipv6_addrs)</a>
<a name="ln647">		    tlvs-&gt;ipv6_addrs = list_new ();</a>
<a name="ln648">		  listnode_add (tlvs-&gt;ipv6_addrs, ipv6_addr);</a>
<a name="ln649">		  value_len += 16;</a>
<a name="ln650">		  pnt += 16;</a>
<a name="ln651">		}</a>
<a name="ln652">	    }</a>
<a name="ln653">	  else</a>
<a name="ln654">	    {</a>
<a name="ln655">	      pnt += length;</a>
<a name="ln656">	    }</a>
<a name="ln657">	  break;</a>
<a name="ln658"> </a>
<a name="ln659">	case IPV6_REACHABILITY:</a>
<a name="ln660">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln661">	   * |                 Default Metric                                | 4 </a>
<a name="ln662">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln663">	   * |                        Control Informantion                   |</a>
<a name="ln664">	   * +---------------------------------------------------------------+</a>
<a name="ln665">	   * |                        IPv6 Prefix Length                     |--+</a>
<a name="ln666">	   * +---------------------------------------------------------------+  |</a>
<a name="ln667">	   * |                        IPv6 Prefix                            |&lt;-+</a>
<a name="ln668">	   * +---------------------------------------------------------------+</a>
<a name="ln669">	   */</a>
<a name="ln670">	  *found |= TLVFLAG_IPV6_REACHABILITY;</a>
<a name="ln671">	  endpnt = pnt + length;</a>
<a name="ln672"> </a>
<a name="ln673">	  if (*expected &amp; TLVFLAG_IPV6_REACHABILITY)</a>
<a name="ln674">	    {</a>
<a name="ln675">	      while (length &gt; value_len)</a>
<a name="ln676">		{</a>
<a name="ln677">		  ipv6_reach = (struct ipv6_reachability *) pnt;</a>
<a name="ln678">		  if (ipv6_reach-&gt;prefix_len &gt; IPV6_MAX_BITLEN)</a>
<a name="ln679">		    {</a>
<a name="ln680">		      zlog_warn (&quot;ISIS-TLV (%s): invalid IPv6 extended reach&quot;</a>
<a name="ln681">				 &quot;ability prefix length %d&quot;, areatag,</a>
<a name="ln682">				 ipv6_reach-&gt;prefix_len);</a>
<a name="ln683">		      retval = ISIS_WARNING;</a>
<a name="ln684">		      break;</a>
<a name="ln685">		    }</a>
<a name="ln686"> </a>
<a name="ln687">		  prefix_octets = ((ipv6_reach-&gt;prefix_len + 7) / 8);</a>
<a name="ln688">		  value_len += prefix_octets + 6;</a>
<a name="ln689">		  pnt += prefix_octets + 6;</a>
<a name="ln690">		  /* FIXME: sub-tlvs */</a>
<a name="ln691">		  if (!tlvs-&gt;ipv6_reachs)</a>
<a name="ln692">		    tlvs-&gt;ipv6_reachs = list_new ();</a>
<a name="ln693">		  listnode_add (tlvs-&gt;ipv6_reachs, ipv6_reach);</a>
<a name="ln694">		}</a>
<a name="ln695">	    }</a>
<a name="ln696"> </a>
<a name="ln697">	  pnt = endpnt;</a>
<a name="ln698">	  break;</a>
<a name="ln699">#endif /* HAVE_IPV6 */</a>
<a name="ln700"> </a>
<a name="ln701">	case WAY3_HELLO:</a>
<a name="ln702">	  /* +---------------------------------------------------------------+</a>
<a name="ln703">	   * |                  Adjacency state                              | 1</a>
<a name="ln704">	   * +---------------------------------------------------------------+</a>
<a name="ln705">	   * |                  Extended Local Circuit ID                    | 4</a>
<a name="ln706">	   * +---------------------------------------------------------------+</a>
<a name="ln707">	   * |                  Neighbor System ID (If known)                | 0-8</a>
<a name="ln708">	   *                                      (probably 6)</a>
<a name="ln709">	   * +---------------------------------------------------------------+</a>
<a name="ln710">	   * |                  Neighbor Local Circuit ID (If known)         | 4</a>
<a name="ln711">	   * +---------------------------------------------------------------+</a>
<a name="ln712">	   */</a>
<a name="ln713">	  *found |= TLVFLAG_3WAY_HELLO;</a>
<a name="ln714">	  if (*expected &amp; TLVFLAG_3WAY_HELLO)</a>
<a name="ln715">	    {</a>
<a name="ln716">	      while (length &gt; value_len)</a>
<a name="ln717">		{</a>
<a name="ln718">		  /* FIXME: make this work */</a>
<a name="ln719">/*           Adjacency State (one octet):</a>
<a name="ln720">              0 = Up</a>
<a name="ln721">              1 = Initializing</a>
<a name="ln722">              2 = Down</a>
<a name="ln723">            Extended Local Circuit ID (four octets)</a>
<a name="ln724">            Neighbor System ID if known (zero to eight octets)</a>
<a name="ln725">            Neighbor Extended Local Circuit ID (four octets, if Neighbor</a>
<a name="ln726">              System ID is present) */</a>
<a name="ln727">		  pnt += length;</a>
<a name="ln728">		  value_len += length;</a>
<a name="ln729">		}</a>
<a name="ln730">	    }</a>
<a name="ln731">	  else</a>
<a name="ln732">	    {</a>
<a name="ln733">	      pnt += length;</a>
<a name="ln734">	    }</a>
<a name="ln735"> </a>
<a name="ln736">	  break;</a>
<a name="ln737">	case GRACEFUL_RESTART:</a>
<a name="ln738">	  /* +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln739">	   * |         Reserved                      |  SA   |  RA   |  RR   | 1</a>
<a name="ln740">	   * +-------+-------+-------+-------+-------+-------+-------+-------+</a>
<a name="ln741">	   * |                          Remaining Time                       | 2</a>
<a name="ln742">	   * +---------------------------------------------------------------+</a>
<a name="ln743">	   * |                Restarting Neighbor ID (If known)              | 0-8</a>
<a name="ln744">	   * +---------------------------------------------------------------+</a>
<a name="ln745">	   */</a>
<a name="ln746">	  *found |= TLVFLAG_GRACEFUL_RESTART;</a>
<a name="ln747">	  if (*expected &amp; TLVFLAG_GRACEFUL_RESTART)</a>
<a name="ln748">	    {</a>
<a name="ln749">	      /* FIXME: make this work */</a>
<a name="ln750">	    }</a>
<a name="ln751">	  pnt += length;</a>
<a name="ln752">	  break;</a>
<a name="ln753"> </a>
<a name="ln754">	default:</a>
<a name="ln755">	  zlog_warn (&quot;ISIS-TLV (%s): unsupported TLV type %d, length %d&quot;,</a>
<a name="ln756">		     areatag, type, length);</a>
<a name="ln757"> </a>
<a name="ln758">	  pnt += length;</a>
<a name="ln759">	  break;</a>
<a name="ln760">	}</a>
<a name="ln761">    }</a>
<a name="ln762"> </a>
<a name="ln763">  return retval;</a>
<a name="ln764">}</a>
<a name="ln765"> </a>
<a name="ln766">int</a>
<a name="ln767">add_tlv (u_char tag, u_char len, u_char * value, struct stream *stream)</a>
<a name="ln768">{</a>
<a name="ln769">  if ((stream_get_size (stream) - stream_get_endp (stream)) &lt;</a>
<a name="ln770">      (((unsigned)len) + 2))</a>
<a name="ln771">    {</a>
<a name="ln772">      zlog_warn (&quot;No room for TLV of type %d &quot;</a>
<a name="ln773">                 &quot;(total size %d available %d required %d)&quot;,</a>
<a name="ln774">                 tag, (int)stream_get_size (stream),</a>
<a name="ln775">                 (int)(stream_get_size (stream) - stream_get_endp (stream)),</a>
<a name="ln776">                 len+2);</a>
<a name="ln777">      return ISIS_WARNING;</a>
<a name="ln778">    }</a>
<a name="ln779"> </a>
<a name="ln780">  stream_putc (stream, tag);	/* TAG */</a>
<a name="ln781">  stream_putc (stream, len);	/* LENGTH */</a>
<a name="ln782">  stream_put (stream, value, (int) len);	/* VALUE */</a>
<a name="ln783"> </a>
<a name="ln784">#ifdef EXTREME_DEBUG</a>
<a name="ln785">  zlog_debug (&quot;Added TLV %d len %d&quot;, tag, len);</a>
<a name="ln786">#endif /* EXTREME DEBUG */</a>
<a name="ln787">  return ISIS_OK;</a>
<a name="ln788">}</a>
<a name="ln789"> </a>
<a name="ln790">int</a>
<a name="ln791">tlv_add_area_addrs (struct list *area_addrs, struct stream *stream)</a>
<a name="ln792">{</a>
<a name="ln793">  struct listnode *node;</a>
<a name="ln794">  struct area_addr *area_addr;</a>
<a name="ln795"> </a>
<a name="ln796">  u_char value[255];</a>
<a name="ln797">  u_char *pos = value;</a>
<a name="ln798"> </a>
<a name="ln799">  for (ALL_LIST_ELEMENTS_RO (area_addrs, node, area_addr))</a>
<a name="ln800">    {</a>
<a name="ln801">      if (pos - value + area_addr-&gt;addr_len &gt; 255)</a>
<a name="ln802">	goto err;</a>
<a name="ln803">      *pos = area_addr-&gt;addr_len;</a>
<a name="ln804">      pos++;</a>
<a name="ln805">      memcpy (pos, area_addr-&gt;area_addr, (int) area_addr-&gt;addr_len);</a>
<a name="ln806">      pos += area_addr-&gt;addr_len;</a>
<a name="ln807">    }</a>
<a name="ln808"> </a>
<a name="ln809">  return add_tlv (AREA_ADDRESSES, pos - value, value, stream);</a>
<a name="ln810"> </a>
<a name="ln811">err:</a>
<a name="ln812">  zlog_warn (&quot;tlv_add_area_addrs(): TLV longer than 255&quot;);</a>
<a name="ln813">  return ISIS_WARNING;</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">int</a>
<a name="ln817">tlv_add_is_neighs (struct list *is_neighs, struct stream *stream)</a>
<a name="ln818">{</a>
<a name="ln819">  struct listnode *node;</a>
<a name="ln820">  struct is_neigh *is_neigh;</a>
<a name="ln821">  u_char value[255];</a>
<a name="ln822">  u_char *pos = value;</a>
<a name="ln823">  int retval;</a>
<a name="ln824"> </a>
<a name="ln825">  *pos = 0;			/*is_neigh-&gt;virtual; */</a>
<a name="ln826">  pos++;</a>
<a name="ln827"> </a>
<a name="ln828">  for (ALL_LIST_ELEMENTS_RO (is_neighs, node, is_neigh))</a>
<a name="ln829">    {</a>
<a name="ln830">      if (pos - value + IS_NEIGHBOURS_LEN &gt; 255)</a>
<a name="ln831">	{</a>
<a name="ln832">	  retval = add_tlv (IS_NEIGHBOURS, pos - value, value, stream);</a>
<a name="ln833">	  if (retval != ISIS_OK)</a>
<a name="ln834">	    return retval;</a>
<a name="ln835">	  pos = value;</a>
<a name="ln836">	}</a>
<a name="ln837">      *pos = is_neigh-&gt;metrics.metric_default;</a>
<a name="ln838">      pos++;</a>
<a name="ln839">      *pos = is_neigh-&gt;metrics.metric_delay;</a>
<a name="ln840">      pos++;</a>
<a name="ln841">      *pos = is_neigh-&gt;metrics.metric_expense;</a>
<a name="ln842">      pos++;</a>
<a name="ln843">      *pos = is_neigh-&gt;metrics.metric_error;</a>
<a name="ln844">      pos++;</a>
<a name="ln845">      memcpy (pos, is_neigh-&gt;neigh_id, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln846">      pos += ISIS_SYS_ID_LEN + 1;</a>
<a name="ln847">    }</a>
<a name="ln848"> </a>
<a name="ln849">  return add_tlv (IS_NEIGHBOURS, pos - value, value, stream);</a>
<a name="ln850">}</a>
<a name="ln851"> </a>
<a name="ln852">int</a>
<a name="ln853">tlv_add_te_is_neighs (struct list *te_is_neighs, struct stream *stream)</a>
<a name="ln854">{</a>
<a name="ln855">  struct listnode *node;</a>
<a name="ln856">  struct te_is_neigh *te_is_neigh;</a>
<a name="ln857">  u_char value[255];</a>
<a name="ln858">  u_char *pos = value;</a>
<a name="ln859">  int retval;</a>
<a name="ln860"> </a>
<a name="ln861">  for (ALL_LIST_ELEMENTS_RO (te_is_neighs, node, te_is_neigh))</a>
<a name="ln862">    {</a>
<a name="ln863">      /* FIXME: Check if Total SubTLVs size doesn't exceed 255 */</a>
<a name="ln864">      if (pos - value + IS_NEIGHBOURS_LEN + te_is_neigh-&gt;sub_tlvs_length &gt; 255)</a>
<a name="ln865">        {</a>
<a name="ln866">          retval = add_tlv (TE_IS_NEIGHBOURS, pos - value, value, stream);</a>
<a name="ln867">          if (retval != ISIS_OK)</a>
<a name="ln868">            return retval;</a>
<a name="ln869">          pos = value;</a>
<a name="ln870">        }</a>
<a name="ln871">      </a>
<a name="ln872">      memcpy (pos, te_is_neigh-&gt;neigh_id, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln873">      pos += ISIS_SYS_ID_LEN + 1;</a>
<a name="ln874">      memcpy (pos, te_is_neigh-&gt;te_metric, 3);</a>
<a name="ln875">      pos += 3;</a>
<a name="ln876">      /* Set the total size of Sub TLVs */</a>
<a name="ln877">      *pos = te_is_neigh-&gt;sub_tlvs_length;</a>
<a name="ln878">      pos++;</a>
<a name="ln879">      /* Copy Sub TLVs if any */</a>
<a name="ln880">      if (te_is_neigh-&gt;sub_tlvs_length &gt; 0)</a>
<a name="ln881">        {</a>
<a name="ln882">          memcpy (pos, te_is_neigh-&gt;sub_tlvs, te_is_neigh-&gt;sub_tlvs_length);</a>
<a name="ln883">          pos += te_is_neigh-&gt;sub_tlvs_length;</a>
<a name="ln884">        }</a>
<a name="ln885">    }</a>
<a name="ln886"> </a>
<a name="ln887">  return add_tlv (TE_IS_NEIGHBOURS, pos - value, value, stream);</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">int</a>
<a name="ln891">tlv_add_lan_neighs (struct list *lan_neighs, struct stream *stream)</a>
<a name="ln892">{</a>
<a name="ln893">  struct listnode *node;</a>
<a name="ln894">  u_char *snpa;</a>
<a name="ln895">  u_char value[255];</a>
<a name="ln896">  u_char *pos = value;</a>
<a name="ln897">  int retval;</a>
<a name="ln898"> </a>
<a name="ln899">  for (ALL_LIST_ELEMENTS_RO (lan_neighs, node, snpa))</a>
<a name="ln900">    {</a>
<a name="ln901">      if (pos - value + ETH_ALEN &gt; 255)</a>
<a name="ln902">	{</a>
<a name="ln903">	  retval = add_tlv (LAN_NEIGHBOURS, pos - value, value, stream);</a>
<a name="ln904">	  if (retval != ISIS_OK)</a>
<a name="ln905">	    return retval;</a>
<a name="ln906">	  pos = value;</a>
<a name="ln907">	}</a>
<a name="ln908">      memcpy (pos, snpa, ETH_ALEN);</a>
<a name="ln909">      pos += ETH_ALEN;</a>
<a name="ln910">    }</a>
<a name="ln911"> </a>
<a name="ln912">  return add_tlv (LAN_NEIGHBOURS, pos - value, value, stream);</a>
<a name="ln913">}</a>
<a name="ln914"> </a>
<a name="ln915">int</a>
<a name="ln916">tlv_add_nlpid (struct nlpids *nlpids, struct stream *stream)</a>
<a name="ln917">{</a>
<a name="ln918">  return add_tlv (PROTOCOLS_SUPPORTED, nlpids-&gt;count, nlpids-&gt;nlpids, stream);</a>
<a name="ln919">}</a>
<a name="ln920"> </a>
<a name="ln921">int</a>
<a name="ln922">tlv_add_authinfo (u_char auth_type, u_char auth_len, u_char *auth_value,</a>
<a name="ln923">		  struct stream *stream)</a>
<a name="ln924">{</a>
<a name="ln925">  u_char value[255];</a>
<a name="ln926">  u_char *pos = value;</a>
<a name="ln927">  *pos++ = auth_type;</a>
<a name="ln928">  memcpy (pos, auth_value, auth_len);</a>
<a name="ln929"> </a>
<a name="ln930">  return add_tlv (AUTH_INFO, auth_len + 1, value, stream);</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">int</a>
<a name="ln934">tlv_add_checksum (struct checksum *checksum, struct stream *stream)</a>
<a name="ln935">{</a>
<a name="ln936">  u_char value[255];</a>
<a name="ln937">  u_char *pos = value;</a>
<a name="ln938">  return add_tlv (CHECKSUM, pos - value, value, stream);</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">int</a>
<a name="ln942">tlv_add_ip_addrs (struct list *ip_addrs, struct stream *stream)</a>
<a name="ln943">{</a>
<a name="ln944">  struct listnode *node;</a>
<a name="ln945">  struct prefix_ipv4 *ipv4;</a>
<a name="ln946">  u_char value[255];</a>
<a name="ln947">  u_char *pos = value;</a>
<a name="ln948"> </a>
<a name="ln949">  for (ALL_LIST_ELEMENTS_RO (ip_addrs, node, ipv4))</a>
<a name="ln950">    {</a>
<a name="ln951">      if (pos - value + IPV4_MAX_BYTELEN &gt; 255)</a>
<a name="ln952">	{</a>
<a name="ln953">	  /* RFC 1195 s4.2: only one tuple of 63 allowed. */</a>
<a name="ln954">	  zlog_warn (&quot;tlv_add_ip_addrs(): cutting off at 63 IP addresses&quot;);</a>
<a name="ln955">	  break;</a>
<a name="ln956">	}</a>
<a name="ln957">      *(u_int32_t *) pos = ipv4-&gt;prefix.s_addr;</a>
<a name="ln958">      pos += IPV4_MAX_BYTELEN;</a>
<a name="ln959">    }</a>
<a name="ln960"> </a>
<a name="ln961">  return add_tlv (IPV4_ADDR, pos - value, value, stream);</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">/* Used to add TLV containing just one IPv4 address - either IPv4 address TLV</a>
<a name="ln965"> * (in case of LSP) or TE router ID TLV. */</a>
<a name="ln966">int</a>
<a name="ln967">tlv_add_in_addr (struct in_addr *addr, struct stream *stream, u_char tag)</a>
<a name="ln968">{</a>
<a name="ln969">  u_char value[255];</a>
<a name="ln970">  u_char *pos = value;</a>
<a name="ln971">  </a>
<a name="ln972">  memcpy (pos, addr, IPV4_MAX_BYTELEN);</a>
<a name="ln973">  pos += IPV4_MAX_BYTELEN;</a>
<a name="ln974"> </a>
<a name="ln975">  return add_tlv (tag, pos - value, value, stream);</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">int</a>
<a name="ln979">tlv_add_dynamic_hostname (struct hostname *hostname, struct stream *stream)</a>
<a name="ln980">{</a>
<a name="ln981">  return add_tlv (DYNAMIC_HOSTNAME, hostname-&gt;namelen, hostname-&gt;name,</a>
<a name="ln982">		  stream);</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">int</a>
<a name="ln986">tlv_add_lsp_entries (struct list *lsps, struct stream *stream)</a>
<a name="ln987">{</a>
<a name="ln988">  struct listnode *node;</a>
<a name="ln989">  struct isis_lsp *lsp;</a>
<a name="ln990">  u_char value[255];</a>
<a name="ln991">  u_char *pos = value;</a>
<a name="ln992">  int retval;</a>
<a name="ln993"> </a>
<a name="ln994">  for (ALL_LIST_ELEMENTS_RO (lsps, node, lsp))</a>
<a name="ln995">    {</a>
<a name="ln996">      if (pos - value + LSP_ENTRIES_LEN &gt; 255)</a>
<a name="ln997">	{</a>
<a name="ln998">	  retval = add_tlv (LSP_ENTRIES, pos - value, value, stream);</a>
<a name="ln999">	  if (retval != ISIS_OK)</a>
<a name="ln1000">	    return retval;</a>
<a name="ln1001">	  pos = value;</a>
<a name="ln1002">	}</a>
<a name="ln1003">      *((u_int16_t *) pos) = lsp-&gt;lsp_header-&gt;rem_lifetime;</a>
<a name="ln1004">      pos += 2;</a>
<a name="ln1005">      memcpy (pos, lsp-&gt;lsp_header-&gt;lsp_id, ISIS_SYS_ID_LEN + 2);</a>
<a name="ln1006">      pos += ISIS_SYS_ID_LEN + 2;</a>
<a name="ln1007">      *((u_int32_t *) pos) = lsp-&gt;lsp_header-&gt;seq_num;</a>
<a name="ln1008">      pos += 4;</a>
<a name="ln1009">      *((u_int16_t *) pos) = lsp-&gt;lsp_header-&gt;checksum;</a>
<a name="ln1010">      pos += 2;</a>
<a name="ln1011">    }</a>
<a name="ln1012"> </a>
<a name="ln1013">  return add_tlv (LSP_ENTRIES, pos - value, value, stream);</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">static int</a>
<a name="ln1017">tlv_add_ipv4_reachs (u_char tag, struct list *ipv4_reachs, struct stream *stream)</a>
<a name="ln1018">{</a>
<a name="ln1019">  struct listnode *node;</a>
<a name="ln1020">  struct ipv4_reachability *reach;</a>
<a name="ln1021">  u_char value[255];</a>
<a name="ln1022">  u_char *pos = value;</a>
<a name="ln1023">  int retval;</a>
<a name="ln1024"> </a>
<a name="ln1025">  for (ALL_LIST_ELEMENTS_RO (ipv4_reachs, node, reach))</a>
<a name="ln1026">    {</a>
<a name="ln1027">      if (pos - value + IPV4_REACH_LEN &gt; 255)</a>
<a name="ln1028">	{</a>
<a name="ln1029">	  retval =</a>
<a name="ln1030">	    add_tlv (tag, pos - value, value, stream);</a>
<a name="ln1031">	  if (retval != ISIS_OK)</a>
<a name="ln1032">	    return retval;</a>
<a name="ln1033">	  pos = value;</a>
<a name="ln1034">	}</a>
<a name="ln1035">      *pos = reach-&gt;metrics.metric_default;</a>
<a name="ln1036">      pos++;</a>
<a name="ln1037">      *pos = reach-&gt;metrics.metric_delay;</a>
<a name="ln1038">      pos++;</a>
<a name="ln1039">      *pos = reach-&gt;metrics.metric_expense;</a>
<a name="ln1040">      pos++;</a>
<a name="ln1041">      *pos = reach-&gt;metrics.metric_error;</a>
<a name="ln1042">      pos++;</a>
<a name="ln1043">      *(u_int32_t *) pos = reach-&gt;prefix.s_addr;</a>
<a name="ln1044">      pos += IPV4_MAX_BYTELEN;</a>
<a name="ln1045">      *(u_int32_t *) pos = reach-&gt;mask.s_addr;</a>
<a name="ln1046">      pos += IPV4_MAX_BYTELEN;</a>
<a name="ln1047">    }</a>
<a name="ln1048"> </a>
<a name="ln1049">  return add_tlv (tag, pos - value, value, stream);</a>
<a name="ln1050">}</a>
<a name="ln1051"> </a>
<a name="ln1052">int</a>
<a name="ln1053">tlv_add_ipv4_int_reachs (struct list *ipv4_reachs, struct stream *stream)</a>
<a name="ln1054">{</a>
<a name="ln1055">  return tlv_add_ipv4_reachs(IPV4_INT_REACHABILITY, ipv4_reachs, stream);</a>
<a name="ln1056">}</a>
<a name="ln1057"> </a>
<a name="ln1058">int</a>
<a name="ln1059">tlv_add_ipv4_ext_reachs (struct list *ipv4_reachs, struct stream *stream)</a>
<a name="ln1060">{</a>
<a name="ln1061">  return tlv_add_ipv4_reachs(IPV4_EXT_REACHABILITY, ipv4_reachs, stream);</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064"> </a>
<a name="ln1065">int</a>
<a name="ln1066">tlv_add_te_ipv4_reachs (struct list *te_ipv4_reachs, struct stream *stream)</a>
<a name="ln1067">{</a>
<a name="ln1068">  struct listnode *node;</a>
<a name="ln1069">  struct te_ipv4_reachability *te_reach;</a>
<a name="ln1070">  u_char value[255];</a>
<a name="ln1071">  u_char *pos = value;</a>
<a name="ln1072">  u_char prefix_size;</a>
<a name="ln1073">  int retval;</a>
<a name="ln1074"> </a>
<a name="ln1075">  for (ALL_LIST_ELEMENTS_RO (te_ipv4_reachs, node, te_reach))</a>
<a name="ln1076">    {</a>
<a name="ln1077">      prefix_size = ((((te_reach-&gt;control &amp; 0x3F) - 1) &gt;&gt; 3) + 1);</a>
<a name="ln1078"> </a>
<a name="ln1079">      if (pos - value + (5 + prefix_size) &gt; 255)</a>
<a name="ln1080">	{</a>
<a name="ln1081">	  retval =</a>
<a name="ln1082">	    add_tlv (TE_IPV4_REACHABILITY, pos - value, value, stream);</a>
<a name="ln1083">	  if (retval != ISIS_OK)</a>
<a name="ln1084">	    return retval;</a>
<a name="ln1085">	  pos = value;</a>
<a name="ln1086">	}</a>
<a name="ln1087">      *(u_int32_t *) pos = te_reach-&gt;te_metric;</a>
<a name="ln1088">      pos += 4;</a>
<a name="ln1089">      *pos = te_reach-&gt;control;</a>
<a name="ln1090">      pos++;</a>
<a name="ln1091">      memcpy (pos, &amp;te_reach-&gt;prefix_start, prefix_size);</a>
<a name="ln1092">      pos += prefix_size;</a>
<a name="ln1093">    }</a>
<a name="ln1094"> </a>
<a name="ln1095">  return add_tlv (TE_IPV4_REACHABILITY, pos - value, value, stream);</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">#ifdef HAVE_IPV6</a>
<a name="ln1099">int</a>
<a name="ln1100">tlv_add_ipv6_addrs (struct list *ipv6_addrs, struct stream *stream)</a>
<a name="ln1101">{</a>
<a name="ln1102">  struct listnode *node;</a>
<a name="ln1103">  struct prefix_ipv6 *ipv6;</a>
<a name="ln1104">  u_char value[255];</a>
<a name="ln1105">  u_char *pos = value;</a>
<a name="ln1106">  int retval;</a>
<a name="ln1107"> </a>
<a name="ln1108">  for (ALL_LIST_ELEMENTS_RO (ipv6_addrs, node, ipv6))</a>
<a name="ln1109">    {</a>
<a name="ln1110">      if (pos - value + IPV6_MAX_BYTELEN &gt; 255)</a>
<a name="ln1111">	{</a>
<a name="ln1112">	  retval = add_tlv (IPV6_ADDR, pos - value, value, stream);</a>
<a name="ln1113">	  if (retval != ISIS_OK)</a>
<a name="ln1114">	    return retval;</a>
<a name="ln1115">	  pos = value;</a>
<a name="ln1116">	}</a>
<a name="ln1117">      memcpy (pos, ipv6-&gt;prefix.s6_addr, IPV6_MAX_BYTELEN);</a>
<a name="ln1118">      pos += IPV6_MAX_BYTELEN;</a>
<a name="ln1119">    }</a>
<a name="ln1120"> </a>
<a name="ln1121">  return add_tlv (IPV6_ADDR, pos - value, value, stream);</a>
<a name="ln1122">}</a>
<a name="ln1123"> </a>
<a name="ln1124">int</a>
<a name="ln1125">tlv_add_ipv6_reachs (struct list *ipv6_reachs, struct stream *stream)</a>
<a name="ln1126">{</a>
<a name="ln1127">  struct listnode *node;</a>
<a name="ln1128">  struct ipv6_reachability *ip6reach;</a>
<a name="ln1129">  u_char value[255];</a>
<a name="ln1130">  u_char *pos = value;</a>
<a name="ln1131">  int retval, prefix_octets;</a>
<a name="ln1132"> </a>
<a name="ln1133">  for (ALL_LIST_ELEMENTS_RO (ipv6_reachs, node, ip6reach))</a>
<a name="ln1134">    {</a>
<a name="ln1135">      if (pos - value + IPV6_MAX_BYTELEN + 6 &gt; 255)</a>
<a name="ln1136">	{</a>
<a name="ln1137">	  retval = add_tlv (IPV6_REACHABILITY, pos - value, value, stream);</a>
<a name="ln1138">	  if (retval != ISIS_OK)</a>
<a name="ln1139">	    return retval;</a>
<a name="ln1140">	  pos = value;</a>
<a name="ln1141">	}</a>
<a name="ln1142">      *(uint32_t *) pos = ip6reach-&gt;metric;</a>
<a name="ln1143">      pos += 4;</a>
<a name="ln1144">      *pos = ip6reach-&gt;control_info;</a>
<a name="ln1145">      pos++;</a>
<a name="ln1146">      prefix_octets = ((ip6reach-&gt;prefix_len + 7) / 8);</a>
<a name="ln1147">      *pos = ip6reach-&gt;prefix_len;</a>
<a name="ln1148">      pos++;</a>
<a name="ln1149">      memcpy (pos, ip6reach-&gt;prefix, prefix_octets);</a>
<a name="ln1150">      pos += prefix_octets;</a>
<a name="ln1151">    }</a>
<a name="ln1152"> </a>
<a name="ln1153">  return add_tlv (IPV6_REACHABILITY, pos - value, value, stream);</a>
<a name="ln1154">}</a>
<a name="ln1155">#endif /* HAVE_IPV6 */</a>
<a name="ln1156"> </a>
<a name="ln1157">int</a>
<a name="ln1158">tlv_add_padding (struct stream *stream)</a>
<a name="ln1159">{</a>
<a name="ln1160">  int fullpads, i, left;</a>
<a name="ln1161"> </a>
<a name="ln1162">  /*</a>
<a name="ln1163">   * How many times can we add full padding ?</a>
<a name="ln1164">   */</a>
<a name="ln1165">  fullpads = (stream_get_size (stream) - stream_get_endp (stream)) / 257;</a>
<a name="ln1166">  for (i = 0; i &lt; fullpads; i++)</a>
<a name="ln1167">    {</a>
<a name="ln1168">      if (!stream_putc (stream, (u_char) PADDING))	/* TAG */</a>
<a name="ln1169">	goto err;</a>
<a name="ln1170">      if (!stream_putc (stream, (u_char) 255))	/* LENGHT */</a>
<a name="ln1171">	goto err;</a>
<a name="ln1172">      stream_put (stream, NULL, 255);		/* zero padding */</a>
<a name="ln1173">    }</a>
<a name="ln1174"> </a>
<a name="ln1175">  left = stream_get_size (stream) - stream_get_endp (stream);</a>
<a name="ln1176"> </a>
<a name="ln1177">  if (left &lt; 2)</a>
<a name="ln1178">    return ISIS_OK;</a>
<a name="ln1179"> </a>
<a name="ln1180">  if (left == 2)</a>
<a name="ln1181">    {</a>
<a name="ln1182">      stream_putc (stream, PADDING);</a>
<a name="ln1183">      stream_putc (stream, 0);</a>
<a name="ln1184">      return ISIS_OK;</a>
<a name="ln1185">    }</a>
<a name="ln1186"> </a>
<a name="ln1187">  stream_putc (stream, PADDING);</a>
<a name="ln1188">  stream_putc (stream, left - 2);</a>
<a name="ln1189">  stream_put (stream, NULL, left-2);</a>
<a name="ln1190"> </a>
<a name="ln1191">  return ISIS_OK;</a>
<a name="ln1192"> </a>
<a name="ln1193">err:</a>
<a name="ln1194">  zlog_warn (&quot;tlv_add_padding(): no room for tlv&quot;);</a>
<a name="ln1195">  return ISIS_WARNING;</a>
<a name="ln1196">}</a>

</code></pre>
<div class="balloon" rel="16"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
