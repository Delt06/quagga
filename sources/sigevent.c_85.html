
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>sigevent.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Quagga signal handling functions.</a>
<a name="ln2"> * Copyright (C) 2004 Paul Jakma,</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of Quagga.</a>
<a name="ln5"> *</a>
<a name="ln6"> * Quagga is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * Quagga is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with Quagga; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23">#include &lt;sigevent.h&gt;</a>
<a name="ln24">#include &lt;log.h&gt;</a>
<a name="ln25">#include &lt;memory.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#ifdef SA_SIGINFO</a>
<a name="ln28">#ifdef HAVE_UCONTEXT_H</a>
<a name="ln29">#ifdef GNU_LINUX</a>
<a name="ln30">/* get REG_EIP from ucontext.h */</a>
<a name="ln31">#ifndef __USE_GNU</a>
<a name="ln32">#define __USE_GNU</a>
<a name="ln33">#endif /* __USE_GNU */</a>
<a name="ln34">#endif /* GNU_LINUX */</a>
<a name="ln35">#include &lt;ucontext.h&gt;</a>
<a name="ln36">#endif /* HAVE_UCONTEXT_H */</a>
<a name="ln37">#endif /* SA_SIGINFO */</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">/* master signals descriptor struct */</a>
<a name="ln41">struct quagga_sigevent_master_t</a>
<a name="ln42">{</a>
<a name="ln43">  struct thread *t;</a>
<a name="ln44"> </a>
<a name="ln45">  struct quagga_signal_t *signals; </a>
<a name="ln46">  int sigc;</a>
<a name="ln47">  </a>
<a name="ln48">  volatile sig_atomic_t caught;</a>
<a name="ln49">} sigmaster;</a>
<a name="ln50"> </a>
<a name="ln51">/* Generic signal handler </a>
<a name="ln52"> * Schedules signal event thread</a>
<a name="ln53"> */</a>
<a name="ln54">static void</a>
<a name="ln55">quagga_signal_handler (int signo)</a>
<a name="ln56">{</a>
<a name="ln57">  int i;</a>
<a name="ln58">  struct quagga_signal_t *sig;</a>
<a name="ln59">  </a>
<a name="ln60">  for (i = 0; i &lt; sigmaster.sigc; i++)</a>
<a name="ln61">    {</a>
<a name="ln62">      sig = &amp;(sigmaster.signals[i]);</a>
<a name="ln63">      </a>
<a name="ln64">      if (sig-&gt;signal == signo)</a>
<a name="ln65">        sig-&gt;caught = 1;</a>
<a name="ln66">    }</a>
<a name="ln67">  </a>
<a name="ln68">  sigmaster.caught = 1;</a>
<a name="ln69">} </a>
<a name="ln70"> </a>
<a name="ln71">/* check if signals have been caught and run appropriate handlers */</a>
<a name="ln72">int</a>
<a name="ln73">quagga_sigevent_process (void)</a>
<a name="ln74">{</a>
<a name="ln75">  struct quagga_signal_t *sig;</a>
<a name="ln76">  int i;</a>
<a name="ln77">#ifdef SIGEVENT_BLOCK_SIGNALS</a>
<a name="ln78">  /* shouldnt need to block signals, but potentially may be needed */</a>
<a name="ln79">  sigset_t newmask, oldmask;</a>
<a name="ln80"> </a>
<a name="ln81">  /*</a>
<a name="ln82">   * Block most signals, but be careful not to defer SIGTRAP because</a>
<a name="ln83">   * doing so breaks gdb, at least on NetBSD 2.0.  Avoid asking to</a>
<a name="ln84">   * block SIGKILL, just because we shouldn't be able to do so.</a>
<a name="ln85">   */</a>
<a name="ln86">  sigfillset (&amp;newmask);</a>
<a name="ln87">  sigdelset (&amp;newmask, SIGTRAP);</a>
<a name="ln88">  sigdelset (&amp;newmask, SIGKILL);</a>
<a name="ln89">   </a>
<a name="ln90">  if ( (sigprocmask (SIG_BLOCK, &amp;newmask, &amp;oldmask)) &lt; 0)</a>
<a name="ln91">    {</a>
<a name="ln92">      zlog_err (&quot;quagga_signal_timer: couldnt block signals!&quot;);</a>
<a name="ln93">      return -1;</a>
<a name="ln94">    }</a>
<a name="ln95">#endif /* SIGEVENT_BLOCK_SIGNALS */</a>
<a name="ln96"> </a>
<a name="ln97">  if (sigmaster.caught &gt; 0)</a>
<a name="ln98">    {</a>
<a name="ln99">      sigmaster.caught = 0;</a>
<a name="ln100">      /* must not read or set sigmaster.caught after here,</a>
<a name="ln101">       * race condition with per-sig caught flags if one does</a>
<a name="ln102">       */</a>
<a name="ln103">      </a>
<a name="ln104">      for (i = 0; i &lt; sigmaster.sigc; i++)</a>
<a name="ln105">        {</a>
<a name="ln106">          sig = &amp;(sigmaster.signals[i]);</a>
<a name="ln107"> </a>
<a name="ln108">          if (sig-&gt;caught &gt; 0)</a>
<a name="ln109">            {</a>
<a name="ln110">              sig-&gt;caught = 0;</a>
<a name="ln111">              sig-&gt;handler ();</a>
<a name="ln112">            }</a>
<a name="ln113">        }</a>
<a name="ln114">    }</a>
<a name="ln115"> </a>
<a name="ln116">#ifdef SIGEVENT_BLOCK_SIGNALS</a>
<a name="ln117">  if ( sigprocmask (SIG_UNBLOCK, &amp;oldmask, NULL) &lt; 0 );</a>
<a name="ln118">    return -1;</a>
<a name="ln119">#endif /* SIGEVENT_BLOCK_SIGNALS */</a>
<a name="ln120"> </a>
<a name="ln121">  return 0;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">#ifdef SIGEVENT_SCHEDULE_THREAD</a>
<a name="ln125">/* timer thread to check signals. Shouldnt be needed */</a>
<a name="ln126">int</a>
<a name="ln127">quagga_signal_timer (struct thread *t)</a>
<a name="ln128">{</a>
<a name="ln129">  struct quagga_sigevent_master_t *sigm;</a>
<a name="ln130">  struct quagga_signal_t *sig;</a>
<a name="ln131">  int i;</a>
<a name="ln132"> </a>
<a name="ln133">  sigm = THREAD_ARG (t);</a>
<a name="ln134">  sigm-&gt;t = thread_add_timer (sigm-&gt;t-&gt;master, quagga_signal_timer, &amp;sigmaster,</a>
<a name="ln135">                              QUAGGA_SIGNAL_TIMER_INTERVAL);</a>
<a name="ln136">  return quagga_sigevent_process ();</a>
<a name="ln137">}</a>
<a name="ln138">#endif /* SIGEVENT_SCHEDULE_THREAD */</a>
<a name="ln139"> </a>
<a name="ln140">/* Initialization of signal handles. */</a>
<a name="ln141">/* Signal wrapper. */</a>
<a name="ln142">static int</a>
<a name="ln143">signal_set (int signo)</a>
<a name="ln144">{</a>
<a name="ln145">  int ret;</a>
<a name="ln146">  struct sigaction sig;</a>
<a name="ln147">  struct sigaction osig;</a>
<a name="ln148"> </a>
<a name="ln149">  sig.sa_handler = &amp;quagga_signal_handler;</a>
<a name="ln150">  sigfillset (&amp;sig.sa_mask);</a>
<a name="ln151">  sig.sa_flags = 0;</a>
<a name="ln152">  if (signo == SIGALRM) {</a>
<a name="ln153">#ifdef SA_INTERRUPT</a>
<a name="ln154">      sig.sa_flags |= SA_INTERRUPT; /* SunOS */</a>
<a name="ln155">#endif</a>
<a name="ln156">  } else {</a>
<a name="ln157">#ifdef SA_RESTART</a>
<a name="ln158">      sig.sa_flags |= SA_RESTART;</a>
<a name="ln159">#endif /* SA_RESTART */</a>
<a name="ln160">  }</a>
<a name="ln161"> </a>
<a name="ln162">  ret = sigaction (signo, &amp;sig, &amp;osig);</a>
<a name="ln163">  if (ret &lt; 0) </a>
<a name="ln164">    return ret;</a>
<a name="ln165">  else</a>
<a name="ln166">    return 0;</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">#ifdef SA_SIGINFO</a>
<a name="ln170"> </a>
<a name="ln171">/* XXX This function should be enhanced to support more platforms</a>
<a name="ln172">       (it currently works only on Linux/x86). */</a>
<a name="ln173">static void *</a>
<a name="ln174">program_counter(void *context)</a>
<a name="ln175">{</a>
<a name="ln176">#ifdef HAVE_UCONTEXT_H</a>
<a name="ln177">#ifdef GNU_LINUX</a>
<a name="ln178">  /* these are from GNU libc, rather than Linux, strictly speaking */</a>
<a name="ln179"># if defined(REG_EIP)</a>
<a name="ln180">#  define REG_INDEX REG_EIP</a>
<a name="ln181"># elif defined(REG_RIP)</a>
<a name="ln182">#  define REG_INDEX REG_RIP</a>
<a name="ln183"># elif defined(__powerpc__)</a>
<a name="ln184">#  define REG_INDEX 32</a>
<a name="ln185"># endif</a>
<a name="ln186">#elif defined(SUNOS_5) /* !GNU_LINUX */</a>
<a name="ln187"># define REG_INDEX REG_PC</a>
<a name="ln188">#endif /* GNU_LINUX */</a>
<a name="ln189"> </a>
<a name="ln190">#ifdef REG_INDEX</a>
<a name="ln191"># ifdef HAVE_UCONTEXT_T_UC_MCONTEXT_GREGS</a>
<a name="ln192">#  define REGS gregs[REG_INDEX]</a>
<a name="ln193"># elif defined(HAVE_UCONTEXT_T_UC_MCONTEXT_UC_REGS)</a>
<a name="ln194">#  define REGS uc_regs-&gt;gregs[REG_INDEX]</a>
<a name="ln195"># endif /* HAVE_UCONTEXT_T_UC_MCONTEXT_GREGS */</a>
<a name="ln196">#endif /* REG_INDEX */</a>
<a name="ln197"> </a>
<a name="ln198">#ifdef REGS</a>
<a name="ln199">  if (context)</a>
<a name="ln200">    return (void *)(((ucontext_t *)context)-&gt;uc_mcontext.REGS);</a>
<a name="ln201">#elif defined(HAVE_UCONTEXT_T_UC_MCONTEXT_REGS__NIP) </a>
<a name="ln202">  /* older Linux / struct pt_regs ? */</a>
<a name="ln203">  if (context)</a>
<a name="ln204">    return (void *)(((ucontext_t *)context)-&gt;uc_mcontext.regs-&gt;nip);</a>
<a name="ln205">#endif /* REGS */</a>
<a name="ln206"> </a>
<a name="ln207">#endif /* HAVE_UCONTEXT_H */</a>
<a name="ln208">  return NULL;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">#endif /* SA_SIGINFO */</a>
<a name="ln212"> </a>
<a name="ln213">static void __attribute__ ((noreturn))</a>
<a name="ln214">exit_handler(int signo</a>
<a name="ln215">#ifdef SA_SIGINFO</a>
<a name="ln216">	     , siginfo_t *siginfo, void *context</a>
<a name="ln217">#endif</a>
<a name="ln218">	    )</a>
<a name="ln219">{</a>
<a name="ln220">  zlog_signal(signo, &quot;exiting...&quot;</a>
<a name="ln221">#ifdef SA_SIGINFO</a>
<a name="ln222">	      , siginfo, program_counter(context)</a>
<a name="ln223">#endif</a>
<a name="ln224">	     );</a>
<a name="ln225">  _exit(128+signo);</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">static void __attribute__ ((noreturn))</a>
<a name="ln229">core_handler(int signo</a>
<a name="ln230">#ifdef SA_SIGINFO</a>
<a name="ln231">	     , siginfo_t *siginfo, void *context</a>
<a name="ln232">#endif</a>
<a name="ln233">	    )</a>
<a name="ln234">{</a>
<a name="ln235">  zlog_signal(signo, &quot;aborting...&quot;</a>
<a name="ln236">#ifdef SA_SIGINFO</a>
<a name="ln237">	      , siginfo, program_counter(context)</a>
<a name="ln238">#endif</a>
<a name="ln239">	     );</a>
<a name="ln240">  /* dump memory stats on core */</a>
<a name="ln241">  log_memstats_stderr (&quot;core_handler&quot;);</a>
<a name="ln242">  abort();</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">static void</a>
<a name="ln246">trap_default_signals(void)</a>
<a name="ln247">{</a>
<a name="ln248">  static const int core_signals[] = {</a>
<a name="ln249">    SIGQUIT,</a>
<a name="ln250">    SIGILL,</a>
<a name="ln251">#ifdef SIGEMT</a>
<a name="ln252">    SIGEMT,</a>
<a name="ln253">#endif</a>
<a name="ln254">    SIGFPE,</a>
<a name="ln255">    SIGBUS,</a>
<a name="ln256">    SIGSEGV,</a>
<a name="ln257">#ifdef SIGSYS</a>
<a name="ln258">    SIGSYS,</a>
<a name="ln259">#endif</a>
<a name="ln260">#ifdef SIGXCPU</a>
<a name="ln261">    SIGXCPU,</a>
<a name="ln262">#endif</a>
<a name="ln263">#ifdef SIGXFSZ</a>
<a name="ln264">    SIGXFSZ,</a>
<a name="ln265">#endif</a>
<a name="ln266">  };</a>
<a name="ln267">  static const int exit_signals[] = {</a>
<a name="ln268">    SIGHUP,</a>
<a name="ln269">    SIGINT,</a>
<a name="ln270">    SIGALRM,</a>
<a name="ln271">    SIGTERM,</a>
<a name="ln272">    SIGUSR1,</a>
<a name="ln273">    SIGUSR2,</a>
<a name="ln274">#ifdef SIGPOLL</a>
<a name="ln275">    SIGPOLL, </a>
<a name="ln276">#endif</a>
<a name="ln277">#ifdef SIGVTALRM</a>
<a name="ln278">    SIGVTALRM,</a>
<a name="ln279">#endif</a>
<a name="ln280">#ifdef SIGSTKFLT</a>
<a name="ln281">    SIGSTKFLT, </a>
<a name="ln282">#endif</a>
<a name="ln283">  };</a>
<a name="ln284">  static const int ignore_signals[] = {</a>
<a name="ln285">    SIGPIPE,</a>
<a name="ln286">  };</a>
<a name="ln287">  static const struct {</a>
<a name="ln288">    const int *sigs;</a>
<a name="ln289">    u_int nsigs;</a>
<a name="ln290">    void (*handler)(int signo</a>
<a name="ln291">#ifdef SA_SIGINFO</a>
<a name="ln292">		    , siginfo_t *info, void *context</a>
<a name="ln293">#endif</a>
<a name="ln294">		   );</a>
<a name="ln295">  } sigmap[] = {</a>
<a name="ln296">    { core_signals, array_size(core_signals), core_handler},</a>
<a name="ln297">    { exit_signals, array_size(exit_signals), exit_handler},</a>
<a name="ln298">    { ignore_signals, array_size(ignore_signals), NULL},</a>
<a name="ln299">  };</a>
<a name="ln300">  u_int i;</a>
<a name="ln301"> </a>
<a name="ln302">  for (i = 0; i &lt; array_size(sigmap); i++)</a>
<a name="ln303">    {</a>
<a name="ln304">      u_int j;</a>
<a name="ln305"> </a>
<a name="ln306">      for (j = 0; j &lt; sigmap[i].nsigs; j++)</a>
<a name="ln307">        {</a>
<a name="ln308">	  struct sigaction oact;</a>
<a name="ln309">	  if ((sigaction(sigmap[i].sigs[j],NULL,&amp;oact) == 0) &amp;&amp;</a>
<a name="ln310">	      (oact.sa_handler == SIG_DFL))</a>
<a name="ln311">	    {</a>
<a name="ln312">	      struct sigaction act;</a>
<a name="ln313">	      sigfillset (&amp;act.sa_mask);</a>
<a name="ln314">	      if (sigmap[i].handler == NULL)</a>
<a name="ln315">	        {</a>
<a name="ln316">		  act.sa_handler = SIG_IGN;</a>
<a name="ln317">		  act.sa_flags = 0;</a>
<a name="ln318">	        }</a>
<a name="ln319">	      else</a>
<a name="ln320">	        {</a>
<a name="ln321">#ifdef SA_SIGINFO</a>
<a name="ln322">		  /* Request extra arguments to signal handler. */</a>
<a name="ln323">		  act.sa_sigaction = sigmap[i].handler;</a>
<a name="ln324">		  act.sa_flags = SA_SIGINFO;</a>
<a name="ln325">#else</a>
<a name="ln326">		  act.sa_handler = sigmap[i].handler;</a>
<a name="ln327">		  act.sa_flags = 0;</a>
<a name="ln328">#endif</a>
<a name="ln329">	        }</a>
<a name="ln330">	      if (sigaction(sigmap[i].sigs[j],&amp;act,NULL) &lt; 0)</a>
<a name="ln331">	        zlog_warn(&quot;Unable to set signal handler for signal %d: %s&quot;,</a>
<a name="ln332">			  sigmap[i].sigs[j],safe_strerror(errno));</a>
<a name="ln333"> </a>
<a name="ln334">	    }</a>
<a name="ln335">        }</a>
<a name="ln336">    }</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">void </a>
<a name="ln340">signal_init (struct thread_master *m, int sigc, </a>
<a name="ln341">             struct quagga_signal_t signals[])</a>
<a name="ln342">{</a>
<a name="ln343"> </a>
<a name="ln344">  int i = 0;</a>
<a name="ln345">  struct quagga_signal_t *sig;</a>
<a name="ln346"> </a>
<a name="ln347">  /* First establish some default handlers that can be overridden by</a>
<a name="ln348">     the application. */</a>
<a name="ln349">  trap_default_signals();</a>
<a name="ln350">  </a>
<a name="ln351">  while (i &lt; sigc)</a>
<a name="ln352">    {</a>
<a name="ln353">      sig = &amp;signals[i];</a>
<a name="ln354">      if ( signal_set (sig-&gt;signal) &lt; 0 )</a>
<a name="ln355">        exit (-1);</a>
<a name="ln356">      i++;</a>
<a name="ln357">    }</a>
<a name="ln358"> </a>
<a name="ln359">  sigmaster.sigc = sigc;</a>
<a name="ln360">  sigmaster.signals = signals;</a>
<a name="ln361"> </a>
<a name="ln362">#ifdef SIGEVENT_SCHEDULE_THREAD  </a>
<a name="ln363">  sigmaster.t = </a>
<a name="ln364">    thread_add_timer (m, quagga_signal_timer, &amp;sigmaster, </a>
<a name="ln365">                      QUAGGA_SIGNAL_TIMER_INTERVAL);</a>
<a name="ln366">#endif /* SIGEVENT_SCHEDULE_THREAD */</a>
<a name="ln367">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
