
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_mplsvpn.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* MPLS-VPN</a>
<a name="ln2">   Copyright (C) 2000 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;command.h&quot;</a>
<a name="ln24">#include &quot;prefix.h&quot;</a>
<a name="ln25">#include &quot;log.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;stream.h&quot;</a>
<a name="ln28">#include &quot;filter.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln31">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln32">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln33">#include &quot;bgpd/bgp_packet.h&quot;</a>
<a name="ln34">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln35">#include &quot;bgpd/bgp_mplsvpn.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_packet.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">static u_int16_t</a>
<a name="ln39">decode_rd_type (u_char *pnt)</a>
<a name="ln40">{</a>
<a name="ln41">  u_int16_t v;</a>
<a name="ln42">  </a>
<a name="ln43">  v = ((u_int16_t) *pnt++ &lt;&lt; 8);</a>
<a name="ln44">  v |= (u_int16_t) *pnt;</a>
<a name="ln45">  return v;</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">u_int32_t</a>
<a name="ln49">decode_label (u_char *pnt)</a>
<a name="ln50">{</a>
<a name="ln51">  u_int32_t l;</a>
<a name="ln52"> </a>
<a name="ln53">  l = ((u_int32_t) *pnt++ &lt;&lt; 12);</a>
<a name="ln54">  l |= (u_int32_t) *pnt++ &lt;&lt; 4;</a>
<a name="ln55">  l |= (u_int32_t) ((*pnt &amp; 0xf0) &gt;&gt; 4);</a>
<a name="ln56">  return l;</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">/* type == RD_TYPE_AS */</a>
<a name="ln60">static void</a>
<a name="ln61">decode_rd_as (u_char *pnt, struct rd_as *rd_as)</a>
<a name="ln62">{</a>
<a name="ln63">  rd_as-&gt;as = (u_int16_t) *pnt++ &lt;&lt; 8;</a>
<a name="ln64">  rd_as-&gt;as |= (u_int16_t) *pnt++;</a>
<a name="ln65">  </a>
<a name="ln66">  rd_as-&gt;val = ((u_int32_t) *pnt++ &lt;&lt; 24);</a>
<a name="ln67">  rd_as-&gt;val |= ((u_int32_t) *pnt++ &lt;&lt; 16);</a>
<a name="ln68">  rd_as-&gt;val |= ((u_int32_t) *pnt++ &lt;&lt; 8);</a>
<a name="ln69">  rd_as-&gt;val |= (u_int32_t) *pnt;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">/* type == RD_TYPE_AS4 */</a>
<a name="ln73">static void</a>
<a name="ln74">decode_rd_as4 (u_char *pnt, struct rd_as *rd_as)</a>
<a name="ln75">{</a>
<a name="ln76">  rd_as-&gt;as  = (u_int32_t) *pnt++ &lt;&lt; 24;</a>
<a name="ln77">  rd_as-&gt;as |= (u_int32_t) *pnt++ &lt;&lt; 16;</a>
<a name="ln78">  rd_as-&gt;as |= (u_int32_t) *pnt++ &lt;&lt; 8;</a>
<a name="ln79">  rd_as-&gt;as |= (u_int32_t) *pnt++;</a>
<a name="ln80"> </a>
<a name="ln81">  rd_as-&gt;val  = ((u_int16_t) *pnt++ &lt;&lt; 8);</a>
<a name="ln82">  rd_as-&gt;val |= (u_int16_t) *pnt;</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">/* type == RD_TYPE_IP */</a>
<a name="ln86">static void</a>
<a name="ln87">decode_rd_ip (u_char *pnt, struct rd_ip *rd_ip)</a>
<a name="ln88">{</a>
<a name="ln89">  memcpy (&amp;rd_ip-&gt;ip, pnt, 4);</a>
<a name="ln90">  pnt += 4;</a>
<a name="ln91">  </a>
<a name="ln92">  rd_ip-&gt;val = ((u_int16_t) *pnt++ &lt;&lt; 8);</a>
<a name="ln93">  rd_ip-&gt;val |= (u_int16_t) *pnt;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">int</a>
<a name="ln97">bgp_nlri_parse_vpn (struct peer *peer, struct attr *attr, </a>
<a name="ln98">                    struct bgp_nlri *packet)</a>
<a name="ln99">{</a>
<a name="ln100">  u_char *pnt;</a>
<a name="ln101">  u_char *lim;</a>
<a name="ln102">  struct prefix p;</a>
<a name="ln103">  int psize = 0;</a>
<a name="ln104">  int prefixlen;</a>
<a name="ln105">  u_int16_t type;</a>
<a name="ln106">  struct rd_as rd_as;</a>
<a name="ln107">  struct rd_ip rd_ip;</a>
<a name="ln108">  struct prefix_rd prd;</a>
<a name="ln109">  u_char *tagpnt;</a>
<a name="ln110"> </a>
<a name="ln111">  /* Check peer status. */</a>
<a name="ln112">  if (peer-&gt;status != Established)</a>
<a name="ln113">    return 0;</a>
<a name="ln114">  </a>
<a name="ln115">  /* Make prefix_rd */</a>
<a name="ln116">  prd.family = AF_UNSPEC;</a>
<a name="ln117">  prd.prefixlen = 64;</a>
<a name="ln118"> </a>
<a name="ln119">  pnt = packet-&gt;nlri;</a>
<a name="ln120">  lim = pnt + packet-&gt;length;</a>
<a name="ln121"> </a>
<a name="ln122">#define VPN_PREFIXLEN_MIN_BYTES (3 + 8) /* label + RD */</a>
<a name="ln123">  for (; pnt &lt; lim; pnt += psize)</a>
<a name="ln124">    {</a>
<a name="ln125">      /* Clear prefix structure. */</a>
<a name="ln126">      memset (&amp;p, 0, sizeof (struct prefix));</a>
<a name="ln127"> </a>
<a name="ln128">      /* Fetch prefix length. */</a>
<a name="ln129">      prefixlen = *pnt++;</a>
<a name="ln130">      p.family = afi2family (packet-&gt;afi);</a>
<a name="ln131">      psize = PSIZE (prefixlen);</a>
<a name="ln132">      </a>
<a name="ln133">      /* sanity check against packet data */</a>
<a name="ln134">      if (prefixlen &lt; VPN_PREFIXLEN_MIN_BYTES*8)</a>
<a name="ln135">        {</a>
<a name="ln136">          plog_err (peer-&gt;log, </a>
<a name="ln137">                    &quot;%s [Error] Update packet error / VPNv4&quot;</a>
<a name="ln138">                     &quot; (prefix length %d less than VPNv4 min length)&quot;,</a>
<a name="ln139">                    peer-&gt;host, prefixlen);</a>
<a name="ln140">          return -1;</a>
<a name="ln141">        }</a>
<a name="ln142">      if ((pnt + psize) &gt; lim)</a>
<a name="ln143">        {</a>
<a name="ln144">          plog_err (peer-&gt;log,</a>
<a name="ln145">                    &quot;%s [Error] Update packet error / VPNv4&quot;</a>
<a name="ln146">                    &quot; (psize %u exceeds packet size (%u)&quot;,</a>
<a name="ln147">                    peer-&gt;host, </a>
<a name="ln148">                    prefixlen, (uint)(lim-pnt));</a>
<a name="ln149">          return -1;</a>
<a name="ln150">        }</a>
<a name="ln151">      </a>
<a name="ln152">      /* sanity check against storage for the IP address portion */</a>
<a name="ln153">      if ((psize - VPN_PREFIXLEN_MIN_BYTES) &gt; (ssize_t) sizeof(p.u))</a>
<a name="ln154">        {</a>
<a name="ln155">          plog_err (peer-&gt;log,</a>
<a name="ln156">                    &quot;%s [Error] Update packet error / VPNv4&quot;</a>
<a name="ln157">                    &quot; (psize %u exceeds storage size (%zu)&quot;,</a>
<a name="ln158">                    peer-&gt;host,</a>
<a name="ln159">                    prefixlen - VPN_PREFIXLEN_MIN_BYTES*8, sizeof(p.u));</a>
<a name="ln160">          return -1;</a>
<a name="ln161">        }</a>
<a name="ln162">      </a>
<a name="ln163">      /* Sanity check against max bitlen of the address family */</a>
<a name="ln164">      if ((psize - VPN_PREFIXLEN_MIN_BYTES) &gt; prefix_blen (&amp;p))</a>
<a name="ln165">        {</a>
<a name="ln166">          plog_err (peer-&gt;log,</a>
<a name="ln167">                    &quot;%s [Error] Update packet error / VPNv4&quot;</a>
<a name="ln168">                    &quot; (psize %u exceeds family (%u) max byte len %u)&quot;,</a>
<a name="ln169">                    peer-&gt;host,</a>
<a name="ln170">                    prefixlen - VPN_PREFIXLEN_MIN_BYTES*8, </a>
<a name="ln171">                    p.family, prefix_blen (&amp;p));</a>
<a name="ln172">          return -1;</a>
<a name="ln173">        }</a>
<a name="ln174">      </a>
<a name="ln175">      /* Copyr label to prefix. */</a>
<a name="ln176">      tagpnt = pnt;</a>
<a name="ln177"> </a>
<a name="ln178">      /* Copy routing distinguisher to rd. */</a>
<a name="ln179">      memcpy (&amp;prd.val, pnt + 3, 8);</a>
<a name="ln180"> </a>
<a name="ln181">      /* Decode RD type. */</a>
<a name="ln182">      type = decode_rd_type (pnt + 3);</a>
<a name="ln183"> </a>
<a name="ln184">      switch (type)</a>
<a name="ln185">        {</a>
<a name="ln186">        case RD_TYPE_AS:</a>
<a name="ln187">          decode_rd_as (pnt + 5, &amp;rd_as);</a>
<a name="ln188">          break;</a>
<a name="ln189"> </a>
<a name="ln190">        case RD_TYPE_AS4:</a>
<a name="ln191">          decode_rd_as4 (pnt + 5, &amp;rd_as);</a>
<a name="ln192">          break;</a>
<a name="ln193"> </a>
<a name="ln194">        case RD_TYPE_IP:</a>
<a name="ln195">          decode_rd_ip (pnt + 5, &amp;rd_ip);</a>
<a name="ln196">          break;</a>
<a name="ln197"> </a>
<a name="ln198">	default:</a>
<a name="ln199">	  zlog_err (&quot;Unknown RD type %d&quot;, type);</a>
<a name="ln200">          break;  /* just report */</a>
<a name="ln201">      }</a>
<a name="ln202"> </a>
<a name="ln203">      p.prefixlen = prefixlen - VPN_PREFIXLEN_MIN_BYTES*8;</a>
<a name="ln204">      memcpy (&amp;p.u.prefix, pnt + VPN_PREFIXLEN_MIN_BYTES, </a>
<a name="ln205">              psize - VPN_PREFIXLEN_MIN_BYTES);</a>
<a name="ln206"> </a>
<a name="ln207">      if (attr)</a>
<a name="ln208">        bgp_update (peer, &amp;p, attr, packet-&gt;afi, SAFI_MPLS_VPN,</a>
<a name="ln209">                    ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &amp;prd, tagpnt, 0);</a>
<a name="ln210">      else</a>
<a name="ln211">        bgp_withdraw (peer, &amp;p, attr, packet-&gt;afi, SAFI_MPLS_VPN,</a>
<a name="ln212">                      ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &amp;prd, tagpnt);</a>
<a name="ln213">    }</a>
<a name="ln214">  /* Packet length consistency check. */</a>
<a name="ln215">  if (pnt != lim)</a>
<a name="ln216">    {</a>
<a name="ln217">      plog_err (peer-&gt;log,</a>
<a name="ln218">                &quot;%s [Error] Update packet error / VPNv4&quot;</a>
<a name="ln219">                &quot; (%zu data remaining after parsing)&quot;,</a>
<a name="ln220">                peer-&gt;host, lim - pnt);</a>
<a name="ln221">      return -1;</a>
<a name="ln222">    }</a>
<a name="ln223">  </a>
<a name="ln224">  return 0;</a>
<a name="ln225">#undef VPN_PREFIXLEN_MIN_BYTES</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">int</a>
<a name="ln229">str2prefix_rd (const char *str, struct prefix_rd *prd)</a>
<a name="ln230">{</a>
<a name="ln231">  int ret; /* ret of called functions */</a>
<a name="ln232">  int lret; /* local ret, of this func */</a>
<a name="ln233">  char *p;</a>
<a name="ln234">  char *p2;</a>
<a name="ln235">  struct stream *s = NULL;</a>
<a name="ln236">  char *half = NULL;</a>
<a name="ln237">  struct in_addr addr;</a>
<a name="ln238"> </a>
<a name="ln239">  s = stream_new (8);</a>
<a name="ln240"> </a>
<a name="ln241">  prd-&gt;family = AF_UNSPEC;</a>
<a name="ln242">  prd-&gt;prefixlen = 64;</a>
<a name="ln243"> </a>
<a name="ln244">  lret = 0;</a>
<a name="ln245">  p = strchr (str, ':');</a>
<a name="ln246">  if (! p)</a>
<a name="ln247">    goto out;</a>
<a name="ln248"> </a>
<a name="ln249">  if (! all_digit (p + 1))</a>
<a name="ln250">    goto out;</a>
<a name="ln251"> </a>
<a name="ln252">  half = XMALLOC (MTYPE_TMP, (p - str) + 1);</a>
<a name="ln253">  memcpy (half, str, (p - str));</a>
<a name="ln254">  half[p - str] = '\0';</a>
<a name="ln255"> </a>
<a name="ln256">  p2 = strchr (str, '.');</a>
<a name="ln257"> </a>
<a name="ln258">  if (! p2)</a>
<a name="ln259">    {</a>
<a name="ln260">      if (! all_digit (half))</a>
<a name="ln261">        goto out;</a>
<a name="ln262">      </a>
<a name="ln263">      stream_putw (s, RD_TYPE_AS);</a>
<a name="ln264">      stream_putw (s, atoi (half));</a>
<a name="ln265">      stream_putl (s, atol (p + 1));</a>
<a name="ln266">    }</a>
<a name="ln267">  else</a>
<a name="ln268">    {</a>
<a name="ln269">      ret = inet_aton (half, &amp;addr);</a>
<a name="ln270">      if (! ret)</a>
<a name="ln271">        goto out;</a>
<a name="ln272">      </a>
<a name="ln273">      stream_putw (s, RD_TYPE_IP);</a>
<a name="ln274">      stream_put_in_addr (s, &amp;addr);</a>
<a name="ln275">      stream_putw (s, atol (p + 1));</a>
<a name="ln276">    }</a>
<a name="ln277">  memcpy (prd-&gt;val, s-&gt;data, 8);</a>
<a name="ln278">  lret = 1;</a>
<a name="ln279"> </a>
<a name="ln280">out:</a>
<a name="ln281">  if (s)</a>
<a name="ln282">    stream_free (s);</a>
<a name="ln283">  if (half)</a>
<a name="ln284">    XFREE(MTYPE_TMP, half);</a>
<a name="ln285">  return lret;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">int</a>
<a name="ln289">str2tag (const char *str, u_char *tag)</a>
<a name="ln290">{</a>
<a name="ln291">  unsigned long l;</a>
<a name="ln292">  char *endptr;</a>
<a name="ln293">  u_int32_t t;</a>
<a name="ln294"> </a>
<a name="ln295">  if (*str == '-')</a>
<a name="ln296">    return 0;</a>
<a name="ln297">  </a>
<a name="ln298">  errno = 0;</a>
<a name="ln299">  l = strtoul (str, &amp;endptr, 10);</a>
<a name="ln300"> </a>
<a name="ln301">  if (*endptr != '\0' || errno || l &gt; UINT32_MAX)</a>
<a name="ln302">    return 0;</a>
<a name="ln303"> </a>
<a name="ln304">  t = (u_int32_t) l;</a>
<a name="ln305">  </a>
<a name="ln306">  tag[0] = (u_char)(t &gt;&gt; 12);</a>
<a name="ln307">  tag[1] = (u_char)(t &gt;&gt; 4);</a>
<a name="ln308">  tag[2] = (u_char)(t &lt;&lt; 4);</a>
<a name="ln309"> </a>
<a name="ln310">  return 1;</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">char *</a>
<a name="ln314">prefix_rd2str (struct prefix_rd *prd, char *buf, size_t size)</a>
<a name="ln315">{</a>
<a name="ln316">  u_char *pnt;</a>
<a name="ln317">  u_int16_t type;</a>
<a name="ln318">  struct rd_as rd_as;</a>
<a name="ln319">  struct rd_ip rd_ip;</a>
<a name="ln320"> </a>
<a name="ln321">  if (size &lt; RD_ADDRSTRLEN)</a>
<a name="ln322">    return NULL;</a>
<a name="ln323"> </a>
<a name="ln324">  pnt = prd-&gt;val;</a>
<a name="ln325"> </a>
<a name="ln326">  type = decode_rd_type (pnt);</a>
<a name="ln327"> </a>
<a name="ln328">  if (type == RD_TYPE_AS)</a>
<a name="ln329">    {</a>
<a name="ln330">      decode_rd_as (pnt + 2, &amp;rd_as);</a>
<a name="ln331">      snprintf (buf, size, &quot;%u:%d&quot;, rd_as.as, rd_as.val);</a>
<a name="ln332">      return buf;</a>
<a name="ln333">    }</a>
<a name="ln334">  else if (type == RD_TYPE_AS4)</a>
<a name="ln335">    {</a>
<a name="ln336">      decode_rd_as4 (pnt + 2, &amp;rd_as);</a>
<a name="ln337">      snprintf (buf, size, &quot;%u:%d&quot;, rd_as.as, rd_as.val);</a>
<a name="ln338">      return buf;</a>
<a name="ln339">    }</a>
<a name="ln340">  else if (type == RD_TYPE_IP)</a>
<a name="ln341">    {</a>
<a name="ln342">      decode_rd_ip (pnt + 2, &amp;rd_ip);</a>
<a name="ln343">      snprintf (buf, size, &quot;%s:%d&quot;, inet_ntoa (rd_ip.ip), rd_ip.val);</a>
<a name="ln344">      return buf;</a>
<a name="ln345">    }</a>
<a name="ln346">  return NULL;</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">/* For testing purpose, static route of MPLS-VPN. */</a>
<a name="ln350">DEFUN (vpnv4_network,</a>
<a name="ln351">       vpnv4_network_cmd,</a>
<a name="ln352">       &quot;network A.B.C.D/M rd ASN:nn_or_IP-address:nn tag WORD&quot;,</a>
<a name="ln353">       &quot;Specify a network to announce via BGP\n&quot;</a>
<a name="ln354">       &quot;IP prefix &lt;network&gt;/&lt;length&gt;, e.g., 35.0.0.0/8\n&quot;</a>
<a name="ln355">       &quot;Specify Route Distinguisher\n&quot;</a>
<a name="ln356">       &quot;VPN Route Distinguisher\n&quot;</a>
<a name="ln357">       &quot;BGP tag\n&quot;</a>
<a name="ln358">       &quot;tag value\n&quot;)</a>
<a name="ln359">{</a>
<a name="ln360">  return bgp_static_set_safi (SAFI_MPLS_VPN, vty, argv[0], argv[1], argv[2], NULL);</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">DEFUN (vpnv4_network_route_map,</a>
<a name="ln364">       vpnv4_network_route_map_cmd,</a>
<a name="ln365">       &quot;network A.B.C.D/M rd ASN:nn_or_IP-address:nn tag WORD route-map WORD&quot;,</a>
<a name="ln366">       &quot;Specify a network to announce via BGP\n&quot;</a>
<a name="ln367">       &quot;IP prefix &lt;network&gt;/&lt;length&gt;, e.g., 35.0.0.0/8\n&quot;</a>
<a name="ln368">       &quot;Specify Route Distinguisher\n&quot;</a>
<a name="ln369">       &quot;VPN Route Distinguisher\n&quot;</a>
<a name="ln370">       &quot;BGP tag\n&quot;</a>
<a name="ln371">       &quot;tag value\n&quot;</a>
<a name="ln372">       &quot;route map\n&quot;</a>
<a name="ln373">       &quot;route map name\n&quot;)</a>
<a name="ln374">{</a>
<a name="ln375">  return bgp_static_set_safi (SAFI_MPLS_VPN, vty, argv[0], argv[1], argv[2], argv[3]);</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">/* For testing purpose, static route of MPLS-VPN. */</a>
<a name="ln379">DEFUN (no_vpnv4_network,</a>
<a name="ln380">       no_vpnv4_network_cmd,</a>
<a name="ln381">       &quot;no network A.B.C.D/M rd ASN:nn_or_IP-address:nn tag WORD&quot;,</a>
<a name="ln382">       NO_STR</a>
<a name="ln383">       &quot;Specify a network to announce via BGP\n&quot;</a>
<a name="ln384">       &quot;IP prefix &lt;network&gt;/&lt;length&gt;, e.g., 35.0.0.0/8\n&quot;</a>
<a name="ln385">       &quot;Specify Route Distinguisher\n&quot;</a>
<a name="ln386">       &quot;VPN Route Distinguisher\n&quot;</a>
<a name="ln387">       &quot;BGP tag\n&quot;</a>
<a name="ln388">       &quot;tag value\n&quot;)</a>
<a name="ln389">{</a>
<a name="ln390">  return bgp_static_unset_safi (SAFI_MPLS_VPN, vty, argv[0], argv[1], argv[2]);</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">static int</a>
<a name="ln394">show_adj_route_vpn (struct vty *vty, struct peer *peer, struct prefix_rd *prd)</a>
<a name="ln395">{</a>
<a name="ln396">  struct bgp *bgp;</a>
<a name="ln397">  struct bgp_table *table;</a>
<a name="ln398">  struct bgp_node *rn;</a>
<a name="ln399">  struct bgp_node *rm;</a>
<a name="ln400">  struct attr *attr;</a>
<a name="ln401">  int rd_header;</a>
<a name="ln402">  int header = 1;</a>
<a name="ln403">  char v4_header[] = &quot;   Network          Next Hop            Metric LocPrf Weight Path%s&quot;;</a>
<a name="ln404"> </a>
<a name="ln405">  bgp = bgp_get_default ();</a>
<a name="ln406">  if (bgp == NULL)</a>
<a name="ln407">    {</a>
<a name="ln408">      vty_out (vty, &quot;No BGP process is configured%s&quot;, VTY_NEWLINE);</a>
<a name="ln409">      return CMD_WARNING;</a>
<a name="ln410">    }</a>
<a name="ln411"> </a>
<a name="ln412">  for (rn = bgp_table_top (bgp-&gt;rib[AFI_IP][SAFI_MPLS_VPN]); rn;</a>
<a name="ln413">       rn = bgp_route_next (rn))</a>
<a name="ln414">    {</a>
<a name="ln415">      if (prd &amp;&amp; memcmp (rn-&gt;p.u.val, prd-&gt;val, 8) != 0)</a>
<a name="ln416">        continue;</a>
<a name="ln417"> </a>
<a name="ln418">      if ((table = rn-&gt;info) != NULL)</a>
<a name="ln419">        {</a>
<a name="ln420">          rd_header = 1;</a>
<a name="ln421"> </a>
<a name="ln422">          for (rm = bgp_table_top (table); rm; rm = bgp_route_next (rm))</a>
<a name="ln423">            if ((attr = rm-&gt;info) != NULL)</a>
<a name="ln424">              {</a>
<a name="ln425">                if (header)</a>
<a name="ln426">                  {</a>
<a name="ln427">                    vty_out (vty, &quot;BGP table version is 0, local router ID is %s%s&quot;,</a>
<a name="ln428">                             inet_ntoa (bgp-&gt;router_id), VTY_NEWLINE);</a>
<a name="ln429">                    vty_out (vty, &quot;Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal%s&quot;,</a>
<a name="ln430">                             VTY_NEWLINE);</a>
<a name="ln431">                    vty_out (vty, &quot;Origin codes: i - IGP, e - EGP, ? - incomplete%s%s&quot;,</a>
<a name="ln432">                             VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln433">                    vty_out (vty, v4_header, VTY_NEWLINE);</a>
<a name="ln434">                    header = 0;</a>
<a name="ln435">                  }</a>
<a name="ln436"> </a>
<a name="ln437">                if (rd_header)</a>
<a name="ln438">                  {</a>
<a name="ln439">                    u_int16_t type;</a>
<a name="ln440">                    struct rd_as rd_as;</a>
<a name="ln441">                    struct rd_ip rd_ip;</a>
<a name="ln442">                    u_char *pnt;</a>
<a name="ln443"> </a>
<a name="ln444">                    pnt = rn-&gt;p.u.val;</a>
<a name="ln445"> </a>
<a name="ln446">                    /* Decode RD type. */</a>
<a name="ln447">                    type = decode_rd_type (pnt);</a>
<a name="ln448">                    /* Decode RD value. */</a>
<a name="ln449">                    if (type == RD_TYPE_AS)</a>
<a name="ln450">                      decode_rd_as (pnt + 2, &amp;rd_as);</a>
<a name="ln451">                    else if (type == RD_TYPE_AS4)</a>
<a name="ln452">                      decode_rd_as4 (pnt + 2, &amp;rd_as);</a>
<a name="ln453">                    else if (type == RD_TYPE_IP)</a>
<a name="ln454">                      decode_rd_ip (pnt + 2, &amp;rd_ip);</a>
<a name="ln455"> </a>
<a name="ln456">                    vty_out (vty, &quot;Route Distinguisher: &quot;);</a>
<a name="ln457"> </a>
<a name="ln458">                    if (type == RD_TYPE_AS)</a>
<a name="ln459">                      vty_out (vty, &quot;%u:%d&quot;, rd_as.as, rd_as.val);</a>
<a name="ln460">                    else if (type == RD_TYPE_AS4)</a>
<a name="ln461">                      vty_out (vty, &quot;%u:%d&quot;, rd_as.as, rd_as.val);</a>
<a name="ln462">                    else if (type == RD_TYPE_IP)</a>
<a name="ln463">                      vty_out (vty, &quot;%s:%d&quot;, inet_ntoa (rd_ip.ip), rd_ip.val);</a>
<a name="ln464"> </a>
<a name="ln465">                    vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln466">                    rd_header = 0;</a>
<a name="ln467">                  }</a>
<a name="ln468">                route_vty_out_tmp (vty, &amp;rm-&gt;p, attr, SAFI_MPLS_VPN);</a>
<a name="ln469">              }</a>
<a name="ln470">        }</a>
<a name="ln471">    }</a>
<a name="ln472">  return CMD_SUCCESS;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">enum bgp_show_type</a>
<a name="ln476">{</a>
<a name="ln477">  bgp_show_type_normal,</a>
<a name="ln478">  bgp_show_type_regexp,</a>
<a name="ln479">  bgp_show_type_prefix_list,</a>
<a name="ln480">  bgp_show_type_filter_list,</a>
<a name="ln481">  bgp_show_type_neighbor,</a>
<a name="ln482">  bgp_show_type_cidr_only,</a>
<a name="ln483">  bgp_show_type_prefix_longer,</a>
<a name="ln484">  bgp_show_type_community_all,</a>
<a name="ln485">  bgp_show_type_community,</a>
<a name="ln486">  bgp_show_type_community_exact,</a>
<a name="ln487">  bgp_show_type_community_list,</a>
<a name="ln488">  bgp_show_type_community_list_exact</a>
<a name="ln489">};</a>
<a name="ln490"> </a>
<a name="ln491">static int</a>
<a name="ln492">bgp_show_mpls_vpn(</a>
<a name="ln493">    struct vty *vty,</a>
<a name="ln494">    afi_t afi,</a>
<a name="ln495">    struct prefix_rd *prd,</a>
<a name="ln496">    enum bgp_show_type type,</a>
<a name="ln497">    void *output_arg,</a>
<a name="ln498">    int tags)</a>
<a name="ln499">{</a>
<a name="ln500">  struct bgp *bgp;</a>
<a name="ln501">  struct bgp_table *table;</a>
<a name="ln502">  struct bgp_node *rn;</a>
<a name="ln503">  struct bgp_node *rm;</a>
<a name="ln504">  struct bgp_info *ri;</a>
<a name="ln505">  int rd_header;</a>
<a name="ln506">  int header = 1;</a>
<a name="ln507">  char v4_header[] = &quot;   Network          Next Hop            Metric LocPrf Weight Path%s&quot;;</a>
<a name="ln508">  char v4_header_tag[] = &quot;   Network          Next Hop      In tag/Out tag%s&quot;;</a>
<a name="ln509"> </a>
<a name="ln510">  unsigned long output_count = 0;</a>
<a name="ln511">  unsigned long total_count  = 0;</a>
<a name="ln512"> </a>
<a name="ln513">  bgp = bgp_get_default ();</a>
<a name="ln514">  if (bgp == NULL)</a>
<a name="ln515">    {</a>
<a name="ln516">      vty_out (vty, &quot;No BGP process is configured%s&quot;, VTY_NEWLINE);</a>
<a name="ln517">      return CMD_WARNING;</a>
<a name="ln518">    }</a>
<a name="ln519">  </a>
<a name="ln520">  if ((afi != AFI_IP) &amp;&amp; (afi != AFI_IP6))</a>
<a name="ln521">    {</a>
<a name="ln522">      vty_out (vty, &quot;Afi %d not supported%s&quot;, afi, VTY_NEWLINE);</a>
<a name="ln523">      return CMD_WARNING;</a>
<a name="ln524">    }</a>
<a name="ln525"> </a>
<a name="ln526">  for (rn = bgp_table_top (bgp-&gt;rib[afi][SAFI_MPLS_VPN]); rn; rn = bgp_route_next (rn))</a>
<a name="ln527">    {</a>
<a name="ln528">      if (prd &amp;&amp; memcmp (rn-&gt;p.u.val, prd-&gt;val, 8) != 0)</a>
<a name="ln529">	continue;</a>
<a name="ln530"> </a>
<a name="ln531">      if ((table = rn-&gt;info) != NULL)</a>
<a name="ln532">	{</a>
<a name="ln533">	  rd_header = 1;</a>
<a name="ln534"> </a>
<a name="ln535">	  for (rm = bgp_table_top (table); rm; rm = bgp_route_next (rm))</a>
<a name="ln536">	    for (ri = rm-&gt;info; ri; ri = ri-&gt;next)</a>
<a name="ln537">	      {</a>
<a name="ln538">                total_count++;</a>
<a name="ln539">		if (type == bgp_show_type_neighbor)</a>
<a name="ln540">		  {</a>
<a name="ln541">		    union sockunion *su = output_arg;</a>
<a name="ln542"> </a>
<a name="ln543">		    if (ri-&gt;peer-&gt;su_remote == NULL || ! sockunion_same(ri-&gt;peer-&gt;su_remote, su))</a>
<a name="ln544">		      continue;</a>
<a name="ln545">		  }</a>
<a name="ln546">		if (header)</a>
<a name="ln547">		  {</a>
<a name="ln548">		    if (tags)</a>
<a name="ln549">		      vty_out (vty, v4_header_tag, VTY_NEWLINE);</a>
<a name="ln550">		    else</a>
<a name="ln551">		      {</a>
<a name="ln552">			vty_out (vty, &quot;BGP table version is 0, local router ID is %s%s&quot;,</a>
<a name="ln553">				 inet_ntoa (bgp-&gt;router_id), VTY_NEWLINE);</a>
<a name="ln554">			vty_out (vty, &quot;Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal%s&quot;,</a>
<a name="ln555">				 VTY_NEWLINE);</a>
<a name="ln556">			vty_out (vty, &quot;Origin codes: i - IGP, e - EGP, ? - incomplete%s%s&quot;,</a>
<a name="ln557">				 VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln558">			vty_out (vty, v4_header, VTY_NEWLINE);</a>
<a name="ln559">		      }</a>
<a name="ln560">		    header = 0;</a>
<a name="ln561">		  }</a>
<a name="ln562"> </a>
<a name="ln563">		if (rd_header)</a>
<a name="ln564">		  {</a>
<a name="ln565">		    u_int16_t type;</a>
<a name="ln566">		    struct rd_as rd_as;</a>
<a name="ln567">		    struct rd_ip rd_ip;</a>
<a name="ln568">		    u_char *pnt;</a>
<a name="ln569"> </a>
<a name="ln570">		    pnt = rn-&gt;p.u.val;</a>
<a name="ln571"> </a>
<a name="ln572">		    /* Decode RD type. */</a>
<a name="ln573">		    type = decode_rd_type (pnt);</a>
<a name="ln574">		    /* Decode RD value. */</a>
<a name="ln575">		    if (type == RD_TYPE_AS)</a>
<a name="ln576">		      decode_rd_as (pnt + 2, &amp;rd_as);</a>
<a name="ln577">		    else if (type == RD_TYPE_AS4)</a>
<a name="ln578">		      decode_rd_as4 (pnt + 2, &amp;rd_as);</a>
<a name="ln579">		    else if (type == RD_TYPE_IP)</a>
<a name="ln580">		      decode_rd_ip (pnt + 2, &amp;rd_ip);</a>
<a name="ln581"> </a>
<a name="ln582">		    vty_out (vty, &quot;Route Distinguisher: &quot;);</a>
<a name="ln583"> </a>
<a name="ln584">		    if (type == RD_TYPE_AS)</a>
<a name="ln585">		      vty_out (vty, &quot;as2 %u:%d&quot;, rd_as.as, rd_as.val);</a>
<a name="ln586">		    else if (type == RD_TYPE_AS4)</a>
<a name="ln587">		      vty_out (vty, &quot;as4 %u:%d&quot;, rd_as.as, rd_as.val);</a>
<a name="ln588">		    else if (type == RD_TYPE_IP)</a>
<a name="ln589">		      vty_out (vty, &quot;ip %s:%d&quot;, inet_ntoa (rd_ip.ip), rd_ip.val);</a>
<a name="ln590">		  </a>
<a name="ln591">		    vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);		  </a>
<a name="ln592">		    rd_header = 0;</a>
<a name="ln593">		  }</a>
<a name="ln594">	        if (tags)</a>
<a name="ln595">		  route_vty_out_tag (vty, &amp;rm-&gt;p, ri, 0, SAFI_MPLS_VPN);</a>
<a name="ln596">	        else</a>
<a name="ln597">		  route_vty_out (vty, &amp;rm-&gt;p, ri, 0, SAFI_MPLS_VPN);</a>
<a name="ln598">                output_count++;</a>
<a name="ln599">	      }</a>
<a name="ln600">        }</a>
<a name="ln601">    }</a>
<a name="ln602"> </a>
<a name="ln603">  if (output_count == 0)</a>
<a name="ln604">    {</a>
<a name="ln605">      vty_out (vty, &quot;No prefixes displayed, %ld exist%s&quot;, total_count, VTY_NEWLINE);</a>
<a name="ln606">    }</a>
<a name="ln607">  else</a>
<a name="ln608">    vty_out (vty, &quot;%sDisplayed %ld out of %ld total prefixes%s&quot;,</a>
<a name="ln609">	     VTY_NEWLINE, output_count, total_count, VTY_NEWLINE);</a>
<a name="ln610"> </a>
<a name="ln611">  return CMD_SUCCESS;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">DEFUN (show_bgp_ipv4_vpn,</a>
<a name="ln615">       show_bgp_ipv4_vpn_cmd,</a>
<a name="ln616">       &quot;show bgp ipv4 vpn&quot;,</a>
<a name="ln617">       SHOW_STR</a>
<a name="ln618">       BGP_STR</a>
<a name="ln619">       &quot;Address Family\n&quot;</a>
<a name="ln620">       &quot;Display VPN NLRI specific information\n&quot;)</a>
<a name="ln621">{</a>
<a name="ln622">  return bgp_show_mpls_vpn (vty, AFI_IP, NULL, bgp_show_type_normal, NULL, 0);</a>
<a name="ln623">}</a>
<a name="ln624"> </a>
<a name="ln625">DEFUN (show_bgp_ipv6_vpn,</a>
<a name="ln626">       show_bgp_ipv6_vpn_cmd,</a>
<a name="ln627">       &quot;show bgp ipv6 vpn&quot;,</a>
<a name="ln628">       SHOW_STR</a>
<a name="ln629">       BGP_STR</a>
<a name="ln630">       &quot;Address Family\n&quot;</a>
<a name="ln631">       &quot;Display VPN NLRI specific information\n&quot;)</a>
<a name="ln632">{</a>
<a name="ln633">  return bgp_show_mpls_vpn (vty, AFI_IP6, NULL, bgp_show_type_normal, NULL, 0);</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">DEFUN (show_bgp_ipv4_vpn_rd,</a>
<a name="ln637">       show_bgp_ipv4_vpn_rd_cmd,</a>
<a name="ln638">       &quot;show bgp ipv4 vpn rd ASN:nn_or_IP-address:nn&quot;,</a>
<a name="ln639">       SHOW_STR</a>
<a name="ln640">       BGP_STR</a>
<a name="ln641">       &quot;Address Family\n&quot;</a>
<a name="ln642">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln643">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln644">       &quot;VPN Route Distinguisher\n&quot;)</a>
<a name="ln645">{</a>
<a name="ln646">  int ret;</a>
<a name="ln647">  struct prefix_rd prd;</a>
<a name="ln648"> </a>
<a name="ln649">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln650">  if (! ret)</a>
<a name="ln651">    {</a>
<a name="ln652">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln653">      return CMD_WARNING;</a>
<a name="ln654">    }</a>
<a name="ln655">  return bgp_show_mpls_vpn (vty, AFI_IP, &amp;prd, bgp_show_type_normal, NULL, 0);</a>
<a name="ln656">}</a>
<a name="ln657"> </a>
<a name="ln658">DEFUN (show_bgp_ipv6_vpn_rd,</a>
<a name="ln659">       show_bgp_ipv6_vpn_rd_cmd,</a>
<a name="ln660">       &quot;show bgp ipv6 vpn rd ASN:nn_or_IP-address:nn&quot;,</a>
<a name="ln661">       SHOW_STR</a>
<a name="ln662">       BGP_STR</a>
<a name="ln663">       &quot;Address Family\n&quot;</a>
<a name="ln664">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln665">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln666">       &quot;VPN Route Distinguisher\n&quot;)</a>
<a name="ln667">{</a>
<a name="ln668">  int ret;</a>
<a name="ln669">  struct prefix_rd prd;</a>
<a name="ln670"> </a>
<a name="ln671">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln672">  if (! ret)</a>
<a name="ln673">    {</a>
<a name="ln674">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln675">      return CMD_WARNING;</a>
<a name="ln676">    }</a>
<a name="ln677">  return bgp_show_mpls_vpn (vty, AFI_IP6, &amp;prd, bgp_show_type_normal, NULL, 0);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680"> </a>
<a name="ln681">DEFUN (show_bgp_ipv4_vpn_tags,</a>
<a name="ln682">       show_bgp_ipv4_vpn_tags_cmd,</a>
<a name="ln683">       &quot;show bgp ipv4 vpn tags&quot;,</a>
<a name="ln684">       SHOW_STR</a>
<a name="ln685">       BGP_STR</a>
<a name="ln686">       &quot;Address Family\n&quot;</a>
<a name="ln687">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln688">       &quot;Display BGP tags for prefixes\n&quot;)</a>
<a name="ln689">{</a>
<a name="ln690">  return bgp_show_mpls_vpn (vty, AFI_IP, NULL, bgp_show_type_normal, NULL,  1);</a>
<a name="ln691">}</a>
<a name="ln692">DEFUN (show_bgp_ipv6_vpn_tags,</a>
<a name="ln693">       show_bgp_ipv6_vpn_tags_cmd,</a>
<a name="ln694">       &quot;show bgp ipv6 vpn tags&quot;,</a>
<a name="ln695">       SHOW_STR</a>
<a name="ln696">       BGP_STR</a>
<a name="ln697">       &quot;Address Family\n&quot;</a>
<a name="ln698">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln699">       &quot;Display BGP tags for prefixes\n&quot;)</a>
<a name="ln700">{</a>
<a name="ln701">  return bgp_show_mpls_vpn (vty, AFI_IP6, NULL, bgp_show_type_normal, NULL,  1);</a>
<a name="ln702">}</a>
<a name="ln703"> </a>
<a name="ln704">DEFUN (show_bgp_ipv4_vpn_rd_tags,</a>
<a name="ln705">       show_bgp_ipv4_vpn_rd_tags_cmd,</a>
<a name="ln706">       &quot;show bgp ipv4 vpn rd ASN:nn_or_IP-address:nn tags&quot;,</a>
<a name="ln707">       SHOW_STR</a>
<a name="ln708">       BGP_STR</a>
<a name="ln709">       &quot;Address Family\n&quot;</a>
<a name="ln710">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln711">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln712">       &quot;VPN Route Distinguisher\n&quot;</a>
<a name="ln713">       &quot;Display BGP tags for prefixes\n&quot;)</a>
<a name="ln714">{</a>
<a name="ln715">  int ret;</a>
<a name="ln716">  struct prefix_rd prd;</a>
<a name="ln717"> </a>
<a name="ln718">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln719">  if (! ret)</a>
<a name="ln720">    {</a>
<a name="ln721">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln722">      return CMD_WARNING;</a>
<a name="ln723">    }</a>
<a name="ln724">  return bgp_show_mpls_vpn (vty, AFI_IP, &amp;prd, bgp_show_type_normal, NULL, 1);</a>
<a name="ln725">}</a>
<a name="ln726">DEFUN (show_bgp_ipv6_vpn_rd_tags,</a>
<a name="ln727">       show_bgp_ipv6_vpn_rd_tags_cmd,</a>
<a name="ln728">       &quot;show bgp ipv6 vpn rd ASN:nn_or_IP-address:nn tags&quot;,</a>
<a name="ln729">       SHOW_STR</a>
<a name="ln730">       BGP_STR</a>
<a name="ln731">       &quot;Address Family\n&quot;</a>
<a name="ln732">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln733">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln734">       &quot;VPN Route Distinguisher\n&quot;</a>
<a name="ln735">       &quot;Display BGP tags for prefixes\n&quot;)</a>
<a name="ln736">{</a>
<a name="ln737">  int ret;</a>
<a name="ln738">  struct prefix_rd prd;</a>
<a name="ln739"> </a>
<a name="ln740">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln741">  if (! ret)</a>
<a name="ln742">    {</a>
<a name="ln743">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln744">      return CMD_WARNING;</a>
<a name="ln745">    }</a>
<a name="ln746">  return bgp_show_mpls_vpn (vty, AFI_IP6, &amp;prd, bgp_show_type_normal, NULL, 1);</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">DEFUN (show_bgp_ipv4_vpn_neighbor_routes,</a>
<a name="ln750">       show_bgp_ipv4_vpn_neighbor_routes_cmd,</a>
<a name="ln751">       &quot;show bgp ipv4 vpn neighbors (A.B.C.D|X:X::X:X) routes&quot;,</a>
<a name="ln752">       SHOW_STR</a>
<a name="ln753">       BGP_STR</a>
<a name="ln754">       &quot;Address Family\n&quot;</a>
<a name="ln755">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln756">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln757">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln758">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln759">       &quot;Display routes learned from neighbor\n&quot;)</a>
<a name="ln760">{</a>
<a name="ln761">  union sockunion su;</a>
<a name="ln762">  struct peer *peer;</a>
<a name="ln763">  int ret;</a>
<a name="ln764"> </a>
<a name="ln765">  ret = str2sockunion (argv[0], &amp;su);</a>
<a name="ln766">  if (ret &lt; 0)</a>
<a name="ln767">    {</a>
<a name="ln768">      vty_out (vty, &quot;Malformed address: %s%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln769">      return CMD_WARNING;</a>
<a name="ln770">    }</a>
<a name="ln771"> </a>
<a name="ln772">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln773">  if (! peer || ! peer-&gt;afc[AFI_IP][SAFI_MPLS_VPN])</a>
<a name="ln774">    {</a>
<a name="ln775">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln776">      return CMD_WARNING;</a>
<a name="ln777">    }</a>
<a name="ln778"> </a>
<a name="ln779">  return bgp_show_mpls_vpn (vty, AFI_IP, NULL, bgp_show_type_neighbor, &amp;su, 0);</a>
<a name="ln780">}</a>
<a name="ln781"> </a>
<a name="ln782">DEFUN (show_bgp_ipv6_vpn_neighbor_routes,</a>
<a name="ln783">       show_bgp_ipv6_vpn_neighbor_routes_cmd,</a>
<a name="ln784">       &quot;show bgp ipv6 vpn neighbors (A.B.C.D|X:X::X:X) routes&quot;,</a>
<a name="ln785">       SHOW_STR</a>
<a name="ln786">       BGP_STR</a>
<a name="ln787">       &quot;Address Family\n&quot;</a>
<a name="ln788">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln789">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln790">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln791">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln792">       &quot;Display routes learned from neighbor\n&quot;)</a>
<a name="ln793">{</a>
<a name="ln794">  union sockunion su;</a>
<a name="ln795">  struct peer *peer;</a>
<a name="ln796"> </a>
<a name="ln797">  int ret;</a>
<a name="ln798"> </a>
<a name="ln799">  ret = str2sockunion (argv[0], &amp;su);</a>
<a name="ln800">  if (ret &lt; 0)</a>
<a name="ln801">    {</a>
<a name="ln802">      vty_out (vty, &quot;Malformed address: %s%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln803">      return CMD_WARNING;</a>
<a name="ln804">    }</a>
<a name="ln805"> </a>
<a name="ln806">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln807">  if (! peer || ! peer-&gt;afc[AFI_IP6][SAFI_MPLS_VPN])</a>
<a name="ln808">    {</a>
<a name="ln809">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln810">      return CMD_WARNING;</a>
<a name="ln811">    }</a>
<a name="ln812"> </a>
<a name="ln813">  return bgp_show_mpls_vpn (vty, AFI_IP6, NULL, bgp_show_type_neighbor, &amp;su, 0);</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">DEFUN (show_bgp_ipv4_vpn_neighbor_advertised_routes,</a>
<a name="ln817">       show_bgp_ipv4_vpn_neighbor_advertised_routes_cmd,</a>
<a name="ln818">       &quot;show bgp ipv4 vpn neighbors (A.B.C.D|X:X::X:X) advertised-routes&quot;,</a>
<a name="ln819">       SHOW_STR</a>
<a name="ln820">       BGP_STR</a>
<a name="ln821">       &quot;Address Family\n&quot;</a>
<a name="ln822">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln823">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln824">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln825">       &quot;Display the routes advertised to a BGP neighbor\n&quot;)</a>
<a name="ln826">{</a>
<a name="ln827">  int ret;</a>
<a name="ln828">  struct peer *peer;</a>
<a name="ln829">  union sockunion su;</a>
<a name="ln830"> </a>
<a name="ln831">  ret = str2sockunion (argv[0], &amp;su);</a>
<a name="ln832">  if (ret &lt; 0)</a>
<a name="ln833">    {</a>
<a name="ln834">      vty_out (vty, &quot;%% Malformed address: %s%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln835">      return CMD_WARNING;</a>
<a name="ln836">    }</a>
<a name="ln837">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln838">  if (! peer || ! peer-&gt;afc[AFI_IP][SAFI_MPLS_VPN])</a>
<a name="ln839">    {</a>
<a name="ln840">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln841">      return CMD_WARNING;</a>
<a name="ln842">    }</a>
<a name="ln843"> </a>
<a name="ln844">  return show_adj_route_vpn (vty, peer, NULL);</a>
<a name="ln845">}</a>
<a name="ln846">DEFUN (show_bgp_ipv6_vpn_neighbor_advertised_routes,</a>
<a name="ln847">       show_bgp_ipv6_vpn_neighbor_advertised_routes_cmd,</a>
<a name="ln848">       &quot;show bgp ipv6 vpn neighbors (A.B.C.D|X:X::X:X) advertised-routes&quot;,</a>
<a name="ln849">       SHOW_STR</a>
<a name="ln850">       BGP_STR</a>
<a name="ln851">       &quot;Address Family\n&quot;</a>
<a name="ln852">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln853">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln854">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln855">       &quot;Display the routes advertised to a BGP neighbor\n&quot;)</a>
<a name="ln856">{</a>
<a name="ln857">  int ret;</a>
<a name="ln858">  struct peer *peer;</a>
<a name="ln859">  union sockunion su;</a>
<a name="ln860"> </a>
<a name="ln861">  ret = str2sockunion (argv[0], &amp;su);</a>
<a name="ln862">  if (ret &lt; 0)</a>
<a name="ln863">    {</a>
<a name="ln864">      vty_out (vty, &quot;%% Malformed address: %s%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln865">      return CMD_WARNING;</a>
<a name="ln866">    }</a>
<a name="ln867">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln868">  if (! peer || ! peer-&gt;afc[AFI_IP6][SAFI_MPLS_VPN])</a>
<a name="ln869">    {</a>
<a name="ln870">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln871">      return CMD_WARNING;</a>
<a name="ln872">    }</a>
<a name="ln873"> </a>
<a name="ln874">  return show_adj_route_vpn (vty, peer, NULL);</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">DEFUN (show_ip_bgp_vpnv4_rd_neighbor_advertised_routes,</a>
<a name="ln878">       show_bgp_ipv4_vpn_rd_neighbor_advertised_routes_cmd,</a>
<a name="ln879">       &quot;show bgp ipv4 vpn rd ASN:nn_or_IP-address:nn neighbors (A.B.C.D|X:X::X:X) advertised-routes&quot;,</a>
<a name="ln880">       SHOW_STR</a>
<a name="ln881">       BGP_STR</a>
<a name="ln882">       &quot;Address Family\n&quot;</a>
<a name="ln883">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln884">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln885">       &quot;VPN Route Distinguisher\n&quot;</a>
<a name="ln886">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln887">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln888">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln889">       &quot;Display the routes advertised to a BGP neighbor\n&quot;)</a>
<a name="ln890">{</a>
<a name="ln891">  int ret;</a>
<a name="ln892">  struct peer *peer;</a>
<a name="ln893">  struct prefix_rd prd;</a>
<a name="ln894">  union sockunion su;</a>
<a name="ln895">  ret = str2sockunion (argv[1], &amp;su);</a>
<a name="ln896">  if (ret &lt; 0)</a>
<a name="ln897">    {</a>
<a name="ln898">      vty_out (vty, &quot;%% Malformed address: %s%s&quot;, argv[1], VTY_NEWLINE);</a>
<a name="ln899">      return CMD_WARNING;</a>
<a name="ln900">    }</a>
<a name="ln901">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln902">  if (! peer || ! peer-&gt;afc[AFI_IP][SAFI_MPLS_VPN])</a>
<a name="ln903">    {</a>
<a name="ln904">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln905">      return CMD_WARNING;</a>
<a name="ln906">    }</a>
<a name="ln907"> </a>
<a name="ln908">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln909">  if (! ret)</a>
<a name="ln910">    {</a>
<a name="ln911">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln912">      return CMD_WARNING;</a>
<a name="ln913">    }</a>
<a name="ln914"> </a>
<a name="ln915">  return show_adj_route_vpn (vty, peer, &amp;prd);</a>
<a name="ln916">}</a>
<a name="ln917">DEFUN (show_ip_bgp_vpnv6_rd_neighbor_advertised_routes,</a>
<a name="ln918">       show_bgp_ipv6_vpn_rd_neighbor_advertised_routes_cmd,</a>
<a name="ln919">       &quot;show bgp ipv6 vpn rd ASN:nn_or_IP-address:nn neighbors (A.B.C.D|X:X::X:X) advertised-routes&quot;,</a>
<a name="ln920">       SHOW_STR</a>
<a name="ln921">       BGP_STR</a>
<a name="ln922">       &quot;Address Family\n&quot;</a>
<a name="ln923">       &quot;Display VPN NLRI specific information\n&quot;</a>
<a name="ln924">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln925">       &quot;VPN Route Distinguisher\n&quot;</a>
<a name="ln926">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln927">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln928">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln929">       &quot;Display the routes advertised to a BGP neighbor\n&quot;)</a>
<a name="ln930">{</a>
<a name="ln931">  int ret;</a>
<a name="ln932">  struct peer *peer;</a>
<a name="ln933">  struct prefix_rd prd;</a>
<a name="ln934">  union sockunion su;</a>
<a name="ln935">  ret = str2sockunion (argv[1], &amp;su);</a>
<a name="ln936">  if (ret &lt; 0)</a>
<a name="ln937">    {</a>
<a name="ln938">      vty_out (vty, &quot;%% Malformed address: %s%s&quot;, argv[1], VTY_NEWLINE);</a>
<a name="ln939">      return CMD_WARNING;</a>
<a name="ln940">    }</a>
<a name="ln941">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln942">  if (! peer || ! peer-&gt;afc[AFI_IP6][SAFI_MPLS_VPN])</a>
<a name="ln943">    {</a>
<a name="ln944">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln945">      return CMD_WARNING;</a>
<a name="ln946">    }</a>
<a name="ln947"> </a>
<a name="ln948">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln949">  if (! ret)</a>
<a name="ln950">    {</a>
<a name="ln951">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln952">      return CMD_WARNING;</a>
<a name="ln953">    }</a>
<a name="ln954"> </a>
<a name="ln955">  return show_adj_route_vpn (vty, peer, &amp;prd);</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">DEFUN (show_bgp_ipv4_vpn_rd_neighbor_routes,</a>
<a name="ln959">       show_bgp_ipv4_vpn_rd_neighbor_routes_cmd,</a>
<a name="ln960">       &quot;show bgp ipv4 vpn rd ASN:nn_or_IP-address:nn neighbors (A.B.C.D|X:X::X:X) routes&quot;,</a>
<a name="ln961">       SHOW_STR</a>
<a name="ln962">       BGP_STR</a>
<a name="ln963">       &quot;Address Family\n&quot;</a>
<a name="ln964">       &quot;Address Family modifier\n&quot;</a>
<a name="ln965">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln966">       &quot;VPN Route Distinguisher\n&quot;</a>
<a name="ln967">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln968">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln969">       &quot;Display routes learned from neighbor\n&quot;)</a>
<a name="ln970">{</a>
<a name="ln971">  int ret;</a>
<a name="ln972">  union sockunion su;</a>
<a name="ln973">  struct peer *peer;</a>
<a name="ln974">  struct prefix_rd prd;</a>
<a name="ln975"> </a>
<a name="ln976">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln977">  if (! ret)</a>
<a name="ln978">    {</a>
<a name="ln979">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln980">      return CMD_WARNING;</a>
<a name="ln981">    }</a>
<a name="ln982"> </a>
<a name="ln983">  if (str2sockunion(argv[1], &amp;su))</a>
<a name="ln984">    {</a>
<a name="ln985">      vty_out (vty, &quot;Malformed address: %s%s&quot;, argv[1], VTY_NEWLINE);</a>
<a name="ln986">               return CMD_WARNING;</a>
<a name="ln987">    }</a>
<a name="ln988"> </a>
<a name="ln989">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln990">  if (! peer || ! peer-&gt;afc[AFI_IP][SAFI_MPLS_VPN])</a>
<a name="ln991">    {</a>
<a name="ln992">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln993">      return CMD_WARNING;</a>
<a name="ln994">    }</a>
<a name="ln995"> </a>
<a name="ln996">  return bgp_show_mpls_vpn (vty, AFI_IP, &amp;prd, bgp_show_type_neighbor, &amp;su, 0);</a>
<a name="ln997">}</a>
<a name="ln998">DEFUN (show_bgp_ipv6_vpn_rd_neighbor_routes,</a>
<a name="ln999">       show_bgp_ipv6_vpn_rd_neighbor_routes_cmd,</a>
<a name="ln1000">       &quot;show bgp ipv6 vpn rd ASN:nn_or_IP-address:nn neighbors (A.B.C.D|X:X::X:X) routes&quot;,</a>
<a name="ln1001">       SHOW_STR</a>
<a name="ln1002">       BGP_STR</a>
<a name="ln1003">       &quot;Address Family\n&quot;</a>
<a name="ln1004">       &quot;Address Family modifier\n&quot;</a>
<a name="ln1005">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln1006">       &quot;VPN Route Distinguisher\n&quot;</a>
<a name="ln1007">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln1008">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln1009">       &quot;Display routes learned from neighbor\n&quot;)</a>
<a name="ln1010">{</a>
<a name="ln1011">  int ret;</a>
<a name="ln1012">  union sockunion su;</a>
<a name="ln1013">  struct peer *peer;</a>
<a name="ln1014">  struct prefix_rd prd;</a>
<a name="ln1015"> </a>
<a name="ln1016">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln1017">  if (! ret)</a>
<a name="ln1018">    {</a>
<a name="ln1019">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln1020">      return CMD_WARNING;</a>
<a name="ln1021">    }</a>
<a name="ln1022"> </a>
<a name="ln1023">  if (str2sockunion(argv[1], &amp;su))</a>
<a name="ln1024">    {</a>
<a name="ln1025">      vty_out (vty, &quot;Malformed address: %s%s&quot;, argv[1], VTY_NEWLINE);</a>
<a name="ln1026">               return CMD_WARNING;</a>
<a name="ln1027">    }</a>
<a name="ln1028"> </a>
<a name="ln1029">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln1030">  if (! peer || ! peer-&gt;afc[AFI_IP6][SAFI_MPLS_VPN])</a>
<a name="ln1031">    {</a>
<a name="ln1032">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln1033">      return CMD_WARNING;</a>
<a name="ln1034">    }</a>
<a name="ln1035"> </a>
<a name="ln1036">  return bgp_show_mpls_vpn (vty, AFI_IP6, &amp;prd, bgp_show_type_neighbor, &amp;su, 0);</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">void</a>
<a name="ln1040">bgp_mplsvpn_init (void)</a>
<a name="ln1041">{</a>
<a name="ln1042">  install_element (BGP_VPNV4_NODE, &amp;vpnv4_network_cmd);</a>
<a name="ln1043">  install_element (BGP_VPNV4_NODE, &amp;vpnv4_network_route_map_cmd);</a>
<a name="ln1044">  install_element (BGP_VPNV4_NODE, &amp;no_vpnv4_network_cmd);</a>
<a name="ln1045"> </a>
<a name="ln1046">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_vpn_cmd);</a>
<a name="ln1047">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_vpn_rd_cmd);</a>
<a name="ln1048">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_vpn_tags_cmd);</a>
<a name="ln1049">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_vpn_rd_tags_cmd);</a>
<a name="ln1050">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_vpn_neighbor_routes_cmd);</a>
<a name="ln1051">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_vpn_neighbor_advertised_routes_cmd);</a>
<a name="ln1052">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_vpn_rd_neighbor_advertised_routes_cmd);</a>
<a name="ln1053">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_vpn_rd_neighbor_routes_cmd);</a>
<a name="ln1054"> </a>
<a name="ln1055">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_vpn_cmd);</a>
<a name="ln1056">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_vpn_rd_cmd);</a>
<a name="ln1057">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_vpn_tags_cmd);</a>
<a name="ln1058">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_vpn_rd_tags_cmd);</a>
<a name="ln1059">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_vpn_neighbor_routes_cmd);</a>
<a name="ln1060">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_vpn_neighbor_advertised_routes_cmd);</a>
<a name="ln1061">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_vpn_rd_neighbor_advertised_routes_cmd);</a>
<a name="ln1062">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_vpn_rd_neighbor_routes_cmd);</a>
<a name="ln1063">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
