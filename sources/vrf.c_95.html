
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>vrf.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * VRF functions.</a>
<a name="ln3"> * Copyright (C) 2014 6WIND S.A.</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln8"> * it under the terms of the GNU General Public License as published</a>
<a name="ln9"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln10"> * option) any later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln20"> * Boston, MA 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#ifdef HAVE_NETNS</a>
<a name="ln26">#undef  _GNU_SOURCE</a>
<a name="ln27">#define _GNU_SOURCE</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;sched.h&gt;</a>
<a name="ln30">#endif</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;if.h&quot;</a>
<a name="ln33">#include &quot;vrf.h&quot;</a>
<a name="ln34">#include &quot;prefix.h&quot;</a>
<a name="ln35">#include &quot;table.h&quot;</a>
<a name="ln36">#include &quot;log.h&quot;</a>
<a name="ln37">#include &quot;memory.h&quot;</a>
<a name="ln38">#include &quot;command.h&quot;</a>
<a name="ln39">#include &quot;vty.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41"> </a>
<a name="ln42">#ifndef CLONE_NEWNET</a>
<a name="ln43">#define CLONE_NEWNET 0x40000000 /* New network namespace (lo, device, names sockets, etc) */</a>
<a name="ln44">#endif</a>
<a name="ln45"> </a>
<a name="ln46">#ifndef HAVE_SETNS</a>
<a name="ln47">static inline int setns(int fd, int nstype)</a>
<a name="ln48">{</a>
<a name="ln49">#ifdef __NR_setns</a>
<a name="ln50">  return syscall(__NR_setns, fd, nstype);</a>
<a name="ln51">#else</a>
<a name="ln52">  errno = ENOSYS;</a>
<a name="ln53">  return -1;</a>
<a name="ln54">#endif</a>
<a name="ln55">}</a>
<a name="ln56">#endif /* HAVE_SETNS */</a>
<a name="ln57"> </a>
<a name="ln58">#define VRF_RUN_DIR         &quot;/var/run/netns&quot;</a>
<a name="ln59"> </a>
<a name="ln60">#ifdef HAVE_NETNS</a>
<a name="ln61"> </a>
<a name="ln62">#define VRF_DEFAULT_NAME    &quot;/proc/self/ns/net&quot;</a>
<a name="ln63">static int have_netns_enabled = -1;</a>
<a name="ln64"> </a>
<a name="ln65">#else /* !HAVE_NETNS */</a>
<a name="ln66"> </a>
<a name="ln67">#define VRF_DEFAULT_NAME    &quot;Default-IP-Routing-Table&quot;</a>
<a name="ln68"> </a>
<a name="ln69">#endif /* HAVE_NETNS */</a>
<a name="ln70"> </a>
<a name="ln71">static int have_netns(void)</a>
<a name="ln72">{</a>
<a name="ln73">#ifdef HAVE_NETNS</a>
<a name="ln74">  if (have_netns_enabled &lt; 0)</a>
<a name="ln75">    {</a>
<a name="ln76">        int fd = open (VRF_DEFAULT_NAME, O_RDONLY);</a>
<a name="ln77"> </a>
<a name="ln78">        if (fd &lt; 0)</a>
<a name="ln79">          have_netns_enabled = 0;</a>
<a name="ln80">        else</a>
<a name="ln81">          {</a>
<a name="ln82">            have_netns_enabled = 1;</a>
<a name="ln83">            close(fd);</a>
<a name="ln84">          }</a>
<a name="ln85">    }</a>
<a name="ln86">  return have_netns_enabled;</a>
<a name="ln87">#else</a>
<a name="ln88">  return 0;</a>
<a name="ln89">#endif</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">struct vrf</a>
<a name="ln93">{</a>
<a name="ln94">  /* Identifier, same as the vector index */</a>
<a name="ln95">  vrf_id_t vrf_id;</a>
<a name="ln96">  /* Name */</a>
<a name="ln97">  char *name;</a>
<a name="ln98">  /* File descriptor */</a>
<a name="ln99">  int fd;</a>
<a name="ln100"> </a>
<a name="ln101">  /* Master list of interfaces belonging to this VRF */</a>
<a name="ln102">  struct list *iflist;</a>
<a name="ln103"> </a>
<a name="ln104">  /* User data */</a>
<a name="ln105">  void *info;</a>
<a name="ln106">};</a>
<a name="ln107"> </a>
<a name="ln108">/* Holding VRF hooks  */</a>
<a name="ln109">struct vrf_master</a>
<a name="ln110">{</a>
<a name="ln111">  int (*vrf_new_hook) (vrf_id_t, void **);</a>
<a name="ln112">  int (*vrf_delete_hook) (vrf_id_t, void **);</a>
<a name="ln113">  int (*vrf_enable_hook) (vrf_id_t, void **);</a>
<a name="ln114">  int (*vrf_disable_hook) (vrf_id_t, void **);</a>
<a name="ln115">} vrf_master = {0,};</a>
<a name="ln116"> </a>
<a name="ln117">/* VRF table */</a>
<a name="ln118">struct route_table *vrf_table = NULL;</a>
<a name="ln119"> </a>
<a name="ln120">static int vrf_is_enabled (struct vrf *vrf);</a>
<a name="ln121">static int vrf_enable (struct vrf *vrf);</a>
<a name="ln122">static void vrf_disable (struct vrf *vrf);</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">/* Build the table key */</a>
<a name="ln126">static void</a>
<a name="ln127">vrf_build_key (vrf_id_t vrf_id, struct prefix *p)</a>
<a name="ln128">{</a>
<a name="ln129">  p-&gt;family = AF_INET;</a>
<a name="ln130">  p-&gt;prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln131">  p-&gt;u.prefix4.s_addr = vrf_id;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">/* Get a VRF. If not found, create one. */</a>
<a name="ln135">static struct vrf *</a>
<a name="ln136">vrf_get (vrf_id_t vrf_id)</a>
<a name="ln137">{</a>
<a name="ln138">  struct prefix p;</a>
<a name="ln139">  struct route_node *rn;</a>
<a name="ln140">  struct vrf *vrf;</a>
<a name="ln141"> </a>
<a name="ln142">  vrf_build_key (vrf_id, &amp;p);</a>
<a name="ln143">  rn = route_node_get (vrf_table, &amp;p);</a>
<a name="ln144">  if (rn-&gt;info)</a>
<a name="ln145">    {</a>
<a name="ln146">      vrf = (struct vrf *)rn-&gt;info;</a>
<a name="ln147">      route_unlock_node (rn); /* get */</a>
<a name="ln148">      return vrf;</a>
<a name="ln149">    }</a>
<a name="ln150"> </a>
<a name="ln151">  vrf = XCALLOC (MTYPE_VRF, sizeof (struct vrf));</a>
<a name="ln152">  vrf-&gt;vrf_id = vrf_id;</a>
<a name="ln153">  vrf-&gt;fd = -1;</a>
<a name="ln154">  rn-&gt;info = vrf;</a>
<a name="ln155"> </a>
<a name="ln156">  /* Initialize interfaces. */</a>
<a name="ln157">  if_init (vrf_id, &amp;vrf-&gt;iflist);</a>
<a name="ln158"> </a>
<a name="ln159">  zlog_info (&quot;VRF %u is created.&quot;, vrf_id);</a>
<a name="ln160"> </a>
<a name="ln161">  if (vrf_master.vrf_new_hook)</a>
<a name="ln162">    (*vrf_master.vrf_new_hook) (vrf_id, &amp;vrf-&gt;info);</a>
<a name="ln163"> </a>
<a name="ln164">  return vrf;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">/* Delete a VRF. This is called in vrf_terminate(). */</a>
<a name="ln168">static void</a>
<a name="ln169">vrf_delete (struct vrf *vrf)</a>
<a name="ln170">{</a>
<a name="ln171">  zlog_info (&quot;VRF %u is to be deleted.&quot;, vrf-&gt;vrf_id);</a>
<a name="ln172"> </a>
<a name="ln173">  vrf_disable (vrf);</a>
<a name="ln174"> </a>
<a name="ln175">  if (vrf_master.vrf_delete_hook)</a>
<a name="ln176">    (*vrf_master.vrf_delete_hook) (vrf-&gt;vrf_id, &amp;vrf-&gt;info);</a>
<a name="ln177"> </a>
<a name="ln178">  if_terminate (vrf-&gt;vrf_id, &amp;vrf-&gt;iflist);</a>
<a name="ln179"> </a>
<a name="ln180">  if (vrf-&gt;name)</a>
<a name="ln181">    XFREE (MTYPE_VRF_NAME, vrf-&gt;name);</a>
<a name="ln182"> </a>
<a name="ln183">  XFREE (MTYPE_VRF, vrf);</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">/* Look up a VRF by identifier. */</a>
<a name="ln187">static struct vrf *</a>
<a name="ln188">vrf_lookup (vrf_id_t vrf_id)</a>
<a name="ln189">{</a>
<a name="ln190">  struct prefix p;</a>
<a name="ln191">  struct route_node *rn;</a>
<a name="ln192">  struct vrf *vrf = NULL;</a>
<a name="ln193"> </a>
<a name="ln194">  vrf_build_key (vrf_id, &amp;p);</a>
<a name="ln195">  rn = route_node_lookup (vrf_table, &amp;p);</a>
<a name="ln196">  if (rn)</a>
<a name="ln197">    {</a>
<a name="ln198">      vrf = (struct vrf *)rn-&gt;info;</a>
<a name="ln199">      route_unlock_node (rn); /* lookup */</a>
<a name="ln200">    }</a>
<a name="ln201">  return vrf;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">/*</a>
<a name="ln205"> * Check whether the VRF is enabled - that is, whether the VRF</a>
<a name="ln206"> * is ready to allocate resources. Currently there's only one</a>
<a name="ln207"> * type of resource: socket.</a>
<a name="ln208"> */</a>
<a name="ln209">static int</a>
<a name="ln210">vrf_is_enabled (struct vrf *vrf)</a>
<a name="ln211">{</a>
<a name="ln212">  if (have_netns())</a>
<a name="ln213">      return vrf &amp;&amp; vrf-&gt;fd &gt;= 0;</a>
<a name="ln214">  else</a>
<a name="ln215">      return vrf &amp;&amp; vrf-&gt;fd == -2 &amp;&amp; vrf-&gt;vrf_id == VRF_DEFAULT;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">/*</a>
<a name="ln219"> * Enable a VRF - that is, let the VRF be ready to use.</a>
<a name="ln220"> * The VRF_ENABLE_HOOK callback will be called to inform</a>
<a name="ln221"> * that they can allocate resources in this VRF.</a>
<a name="ln222"> *</a>
<a name="ln223"> * RETURN: 1 - enabled successfully; otherwise, 0.</a>
<a name="ln224"> */</a>
<a name="ln225">static int</a>
<a name="ln226">vrf_enable (struct vrf *vrf)</a>
<a name="ln227">{</a>
<a name="ln228"> </a>
<a name="ln229">  if (!vrf_is_enabled (vrf))</a>
<a name="ln230">    {</a>
<a name="ln231">      if (have_netns()) {</a>
<a name="ln232">        vrf-&gt;fd = open (vrf-&gt;name, O_RDONLY);</a>
<a name="ln233">      } else {</a>
<a name="ln234">        vrf-&gt;fd = -2; /* Remember that vrf_enable_hook has been called */</a>
<a name="ln235">        errno = -ENOTSUP;</a>
<a name="ln236">      }</a>
<a name="ln237"> </a>
<a name="ln238">      if (!vrf_is_enabled (vrf))</a>
<a name="ln239">        {</a>
<a name="ln240">          zlog_err (&quot;Can not enable VRF %u: %s!&quot;,</a>
<a name="ln241">                    vrf-&gt;vrf_id, safe_strerror (errno));</a>
<a name="ln242">          return 0;</a>
<a name="ln243">        }</a>
<a name="ln244"> </a>
<a name="ln245">      if (have_netns())</a>
<a name="ln246">        zlog_info (&quot;VRF %u is associated with NETNS %s.&quot;,</a>
<a name="ln247">                   vrf-&gt;vrf_id, vrf-&gt;name);</a>
<a name="ln248"> </a>
<a name="ln249">      zlog_info (&quot;VRF %u is enabled.&quot;, vrf-&gt;vrf_id);</a>
<a name="ln250">      if (vrf_master.vrf_enable_hook)</a>
<a name="ln251">        (*vrf_master.vrf_enable_hook) (vrf-&gt;vrf_id, &amp;vrf-&gt;info);</a>
<a name="ln252">    }</a>
<a name="ln253"> </a>
<a name="ln254">  return 1;</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">/*</a>
<a name="ln258"> * Disable a VRF - that is, let the VRF be unusable.</a>
<a name="ln259"> * The VRF_DELETE_HOOK callback will be called to inform</a>
<a name="ln260"> * that they must release the resources in the VRF.</a>
<a name="ln261"> */</a>
<a name="ln262">static void</a>
<a name="ln263">vrf_disable (struct vrf *vrf)</a>
<a name="ln264">{</a>
<a name="ln265">  if (vrf_is_enabled (vrf))</a>
<a name="ln266">    {</a>
<a name="ln267">      zlog_info (&quot;VRF %u is to be disabled.&quot;, vrf-&gt;vrf_id);</a>
<a name="ln268"> </a>
<a name="ln269">      if (vrf_master.vrf_disable_hook)</a>
<a name="ln270">        (*vrf_master.vrf_disable_hook) (vrf-&gt;vrf_id, &amp;vrf-&gt;info);</a>
<a name="ln271"> </a>
<a name="ln272">      if (have_netns())</a>
<a name="ln273">        close (vrf-&gt;fd);</a>
<a name="ln274"> </a>
<a name="ln275">      vrf-&gt;fd = -1;</a>
<a name="ln276">    }</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279"> </a>
<a name="ln280">/* Add a VRF hook. Please add hooks before calling vrf_init(). */</a>
<a name="ln281">void</a>
<a name="ln282">vrf_add_hook (int type, int (*func)(vrf_id_t, void **))</a>
<a name="ln283">{</a>
<a name="ln284">  switch (type) {</a>
<a name="ln285">  case VRF_NEW_HOOK:</a>
<a name="ln286">    vrf_master.vrf_new_hook = func;</a>
<a name="ln287">    break;</a>
<a name="ln288">  case VRF_DELETE_HOOK:</a>
<a name="ln289">    vrf_master.vrf_delete_hook = func;</a>
<a name="ln290">    break;</a>
<a name="ln291">  case VRF_ENABLE_HOOK:</a>
<a name="ln292">    vrf_master.vrf_enable_hook = func;</a>
<a name="ln293">    break;</a>
<a name="ln294">  case VRF_DISABLE_HOOK:</a>
<a name="ln295">    vrf_master.vrf_disable_hook = func;</a>
<a name="ln296">    break;</a>
<a name="ln297">  default:</a>
<a name="ln298">    break;</a>
<a name="ln299">  }</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">/* Return the iterator of the first VRF. */</a>
<a name="ln303">vrf_iter_t</a>
<a name="ln304">vrf_first (void)</a>
<a name="ln305">{</a>
<a name="ln306">  struct route_node *rn;</a>
<a name="ln307"> </a>
<a name="ln308">  for (rn = route_top (vrf_table); rn; rn = route_next (rn))</a>
<a name="ln309">    if (rn-&gt;info)</a>
<a name="ln310">      {</a>
<a name="ln311">        route_unlock_node (rn); /* top/next */</a>
<a name="ln312">        return (vrf_iter_t)rn;</a>
<a name="ln313">      }</a>
<a name="ln314">  return VRF_ITER_INVALID;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">/* Return the next VRF iterator to the given iterator. */</a>
<a name="ln318">vrf_iter_t</a>
<a name="ln319">vrf_next (vrf_iter_t iter)</a>
<a name="ln320">{</a>
<a name="ln321">  struct route_node *rn = NULL;</a>
<a name="ln322"> </a>
<a name="ln323">  /* Lock it first because route_next() will unlock it. */</a>
<a name="ln324">  if (iter != VRF_ITER_INVALID)</a>
<a name="ln325">    rn = route_next (route_lock_node ((struct route_node *)iter));</a>
<a name="ln326"> </a>
<a name="ln327">  for (; rn; rn = route_next (rn))</a>
<a name="ln328">    if (rn-&gt;info)</a>
<a name="ln329">      {</a>
<a name="ln330">        route_unlock_node (rn); /* next */</a>
<a name="ln331">        return (vrf_iter_t)rn;</a>
<a name="ln332">      }</a>
<a name="ln333">  return VRF_ITER_INVALID;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">/* Return the VRF iterator of the given VRF ID. If it does not exist,</a>
<a name="ln337"> * the iterator of the next existing VRF is returned. */</a>
<a name="ln338">vrf_iter_t</a>
<a name="ln339">vrf_iterator (vrf_id_t vrf_id)</a>
<a name="ln340">{</a>
<a name="ln341">  struct prefix p;</a>
<a name="ln342">  struct route_node *rn;</a>
<a name="ln343"> </a>
<a name="ln344">  vrf_build_key (vrf_id, &amp;p);</a>
<a name="ln345">  rn = route_node_get (vrf_table, &amp;p);</a>
<a name="ln346">  if (rn-&gt;info)</a>
<a name="ln347">    {</a>
<a name="ln348">      /* OK, the VRF exists. */</a>
<a name="ln349">      route_unlock_node (rn); /* get */</a>
<a name="ln350">      return (vrf_iter_t)rn;</a>
<a name="ln351">    }</a>
<a name="ln352"> </a>
<a name="ln353">  /* Find the next VRF. */</a>
<a name="ln354">  for (rn = route_next (rn); rn; rn = route_next (rn))</a>
<a name="ln355">    if (rn-&gt;info)</a>
<a name="ln356">      {</a>
<a name="ln357">        route_unlock_node (rn); /* next */</a>
<a name="ln358">        return (vrf_iter_t)rn;</a>
<a name="ln359">      }</a>
<a name="ln360"> </a>
<a name="ln361">  return VRF_ITER_INVALID;</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364">/* Obtain the VRF ID from the given VRF iterator. */</a>
<a name="ln365">vrf_id_t</a>
<a name="ln366">vrf_iter2id (vrf_iter_t iter)</a>
<a name="ln367">{</a>
<a name="ln368">  struct route_node *rn = (struct route_node *) iter;</a>
<a name="ln369">  return (rn &amp;&amp; rn-&gt;info) ? ((struct vrf *)rn-&gt;info)-&gt;vrf_id : VRF_DEFAULT;</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">/* Obtain the data pointer from the given VRF iterator. */</a>
<a name="ln373">void *</a>
<a name="ln374">vrf_iter2info (vrf_iter_t iter)</a>
<a name="ln375">{</a>
<a name="ln376">  struct route_node *rn = (struct route_node *) iter;</a>
<a name="ln377">  return (rn &amp;&amp; rn-&gt;info) ? ((struct vrf *)rn-&gt;info)-&gt;info : NULL;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">/* Obtain the interface list from the given VRF iterator. */</a>
<a name="ln381">struct list *</a>
<a name="ln382">vrf_iter2iflist (vrf_iter_t iter)</a>
<a name="ln383">{</a>
<a name="ln384">  struct route_node *rn = (struct route_node *) iter;</a>
<a name="ln385">  return (rn &amp;&amp; rn-&gt;info) ? ((struct vrf *)rn-&gt;info)-&gt;iflist : NULL;</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">/* Get the data pointer of the specified VRF. If not found, create one. */</a>
<a name="ln389">void *</a>
<a name="ln390">vrf_info_get (vrf_id_t vrf_id)</a>
<a name="ln391">{</a>
<a name="ln392">  struct vrf *vrf = vrf_get (vrf_id);</a>
<a name="ln393">  return vrf-&gt;info;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">/* Look up the data pointer of the specified VRF. */</a>
<a name="ln397">void *</a>
<a name="ln398">vrf_info_lookup (vrf_id_t vrf_id)</a>
<a name="ln399">{</a>
<a name="ln400">  struct vrf *vrf = vrf_lookup (vrf_id);</a>
<a name="ln401">  return vrf ? vrf-&gt;info : NULL;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">/* Look up the interface list in a VRF. */</a>
<a name="ln405">struct list *</a>
<a name="ln406">vrf_iflist (vrf_id_t vrf_id)</a>
<a name="ln407">{</a>
<a name="ln408">   struct vrf * vrf = vrf_lookup (vrf_id);</a>
<a name="ln409">   return vrf ? vrf-&gt;iflist : NULL;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">/* Get the interface list of the specified VRF. Create one if not find. */</a>
<a name="ln413">struct list *</a>
<a name="ln414">vrf_iflist_get (vrf_id_t vrf_id)</a>
<a name="ln415">{</a>
<a name="ln416">   struct vrf * vrf = vrf_get (vrf_id);</a>
<a name="ln417">   return vrf-&gt;iflist;</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">/*</a>
<a name="ln421"> * VRF bit-map</a>
<a name="ln422"> */</a>
<a name="ln423"> </a>
<a name="ln424">#define VRF_BITMAP_NUM_OF_GROUPS            8</a>
<a name="ln425">#define VRF_BITMAP_NUM_OF_BITS_IN_GROUP \</a>
<a name="ln426">    (UINT16_MAX / VRF_BITMAP_NUM_OF_GROUPS)</a>
<a name="ln427">#define VRF_BITMAP_NUM_OF_BYTES_IN_GROUP \</a>
<a name="ln428">    (VRF_BITMAP_NUM_OF_BITS_IN_GROUP / CHAR_BIT + 1) /* +1 for ensure */</a>
<a name="ln429"> </a>
<a name="ln430">#define VRF_BITMAP_GROUP(_id) \</a>
<a name="ln431">    ((_id) / VRF_BITMAP_NUM_OF_BITS_IN_GROUP)</a>
<a name="ln432">#define VRF_BITMAP_BIT_OFFSET(_id) \</a>
<a name="ln433">    ((_id) % VRF_BITMAP_NUM_OF_BITS_IN_GROUP)</a>
<a name="ln434"> </a>
<a name="ln435">#define VRF_BITMAP_INDEX_IN_GROUP(_bit_offset) \</a>
<a name="ln436">    ((_bit_offset) / CHAR_BIT)</a>
<a name="ln437">#define VRF_BITMAP_FLAG(_bit_offset) \</a>
<a name="ln438">    (((u_char)1) &lt;&lt; ((_bit_offset) % CHAR_BIT))</a>
<a name="ln439"> </a>
<a name="ln440">struct vrf_bitmap</a>
<a name="ln441">{</a>
<a name="ln442">  u_char *groups[VRF_BITMAP_NUM_OF_GROUPS];</a>
<a name="ln443">};</a>
<a name="ln444"> </a>
<a name="ln445">vrf_bitmap_t</a>
<a name="ln446">vrf_bitmap_init (void)</a>
<a name="ln447">{</a>
<a name="ln448">  return (vrf_bitmap_t) XCALLOC (MTYPE_VRF_BITMAP, sizeof (struct vrf_bitmap));</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">void</a>
<a name="ln452">vrf_bitmap_free (vrf_bitmap_t bmap)</a>
<a name="ln453">{</a>
<a name="ln454">  struct vrf_bitmap *bm = (struct vrf_bitmap *) bmap;</a>
<a name="ln455">  int i;</a>
<a name="ln456"> </a>
<a name="ln457">  if (bmap == VRF_BITMAP_NULL)</a>
<a name="ln458">    return;</a>
<a name="ln459"> </a>
<a name="ln460">  for (i = 0; i &lt; VRF_BITMAP_NUM_OF_GROUPS; i++)</a>
<a name="ln461">    if (bm-&gt;groups[i])</a>
<a name="ln462">      XFREE (MTYPE_VRF_BITMAP, bm-&gt;groups[i]);</a>
<a name="ln463"> </a>
<a name="ln464">  XFREE (MTYPE_VRF_BITMAP, bm);</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">void</a>
<a name="ln468">vrf_bitmap_set (vrf_bitmap_t bmap, vrf_id_t vrf_id)</a>
<a name="ln469">{</a>
<a name="ln470">  struct vrf_bitmap *bm = (struct vrf_bitmap *) bmap;</a>
<a name="ln471">  u_char group = VRF_BITMAP_GROUP (vrf_id);</a>
<a name="ln472">  u_char offset = VRF_BITMAP_BIT_OFFSET (vrf_id);</a>
<a name="ln473"> </a>
<a name="ln474">  if (bmap == VRF_BITMAP_NULL)</a>
<a name="ln475">    return;</a>
<a name="ln476"> </a>
<a name="ln477">  if (bm-&gt;groups[group] == NULL)</a>
<a name="ln478">    bm-&gt;groups[group] = XCALLOC (MTYPE_VRF_BITMAP,</a>
<a name="ln479">                                 VRF_BITMAP_NUM_OF_BYTES_IN_GROUP);</a>
<a name="ln480"> </a>
<a name="ln481">  SET_FLAG (bm-&gt;groups[group][VRF_BITMAP_INDEX_IN_GROUP (offset)],</a>
<a name="ln482">            VRF_BITMAP_FLAG (offset));</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">void</a>
<a name="ln486">vrf_bitmap_unset (vrf_bitmap_t bmap, vrf_id_t vrf_id)</a>
<a name="ln487">{</a>
<a name="ln488">  struct vrf_bitmap *bm = (struct vrf_bitmap *) bmap;</a>
<a name="ln489">  u_char group = VRF_BITMAP_GROUP (vrf_id);</a>
<a name="ln490">  u_char offset = VRF_BITMAP_BIT_OFFSET (vrf_id);</a>
<a name="ln491"> </a>
<a name="ln492">  if (bmap == VRF_BITMAP_NULL || bm-&gt;groups[group] == NULL)</a>
<a name="ln493">    return;</a>
<a name="ln494"> </a>
<a name="ln495">  UNSET_FLAG (bm-&gt;groups[group][VRF_BITMAP_INDEX_IN_GROUP (offset)],</a>
<a name="ln496">              VRF_BITMAP_FLAG (offset));</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">int</a>
<a name="ln500">vrf_bitmap_check (vrf_bitmap_t bmap, vrf_id_t vrf_id)</a>
<a name="ln501">{</a>
<a name="ln502">  struct vrf_bitmap *bm = (struct vrf_bitmap *) bmap;</a>
<a name="ln503">  u_char group = VRF_BITMAP_GROUP (vrf_id);</a>
<a name="ln504">  u_char offset = VRF_BITMAP_BIT_OFFSET (vrf_id);</a>
<a name="ln505"> </a>
<a name="ln506">  if (bmap == VRF_BITMAP_NULL || bm-&gt;groups[group] == NULL)</a>
<a name="ln507">    return 0;</a>
<a name="ln508"> </a>
<a name="ln509">  return CHECK_FLAG (bm-&gt;groups[group][VRF_BITMAP_INDEX_IN_GROUP (offset)],</a>
<a name="ln510">                     VRF_BITMAP_FLAG (offset)) ? 1 : 0;</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513">/*</a>
<a name="ln514"> * VRF realization with NETNS</a>
<a name="ln515"> */</a>
<a name="ln516"> </a>
<a name="ln517">static char *</a>
<a name="ln518">vrf_netns_pathname (struct vty *vty, const char *name)</a>
<a name="ln519">{</a>
<a name="ln520">  static char pathname[PATH_MAX];</a>
<a name="ln521">  char *result;</a>
<a name="ln522"> </a>
<a name="ln523">  if (name[0] == '/') /* absolute pathname */</a>
<a name="ln524">    result = realpath (name, pathname);</a>
<a name="ln525">  else /* relevant pathname */</a>
<a name="ln526">    {</a>
<a name="ln527">      char tmp_name[PATH_MAX];</a>
<a name="ln528">      snprintf (tmp_name, PATH_MAX, &quot;%s/%s&quot;, VRF_RUN_DIR, name);</a>
<a name="ln529">      result = realpath (tmp_name, pathname);</a>
<a name="ln530">    }</a>
<a name="ln531"> </a>
<a name="ln532">  if (! result)</a>
<a name="ln533">    {</a>
<a name="ln534">      vty_out (vty, &quot;Invalid pathname: %s%s&quot;, safe_strerror (errno),</a>
<a name="ln535">               VTY_NEWLINE);</a>
<a name="ln536">      return NULL;</a>
<a name="ln537">    }</a>
<a name="ln538">  return pathname;</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">DEFUN (vrf_netns,</a>
<a name="ln542">       vrf_netns_cmd,</a>
<a name="ln543">       &quot;vrf &lt;1-65535&gt; netns NAME&quot;,</a>
<a name="ln544">       &quot;Enable a VRF\n&quot;</a>
<a name="ln545">       &quot;Specify the VRF identifier\n&quot;</a>
<a name="ln546">       &quot;Associate with a NETNS\n&quot;</a>
<a name="ln547">       &quot;The file name in &quot; VRF_RUN_DIR &quot;, or a full pathname\n&quot;)</a>
<a name="ln548">{</a>
<a name="ln549">  vrf_id_t vrf_id = VRF_DEFAULT;</a>
<a name="ln550">  struct vrf *vrf = NULL;</a>
<a name="ln551">  char *pathname = vrf_netns_pathname (vty, argv[1]);</a>
<a name="ln552"> </a>
<a name="ln553">  if (!pathname)</a>
<a name="ln554">    return CMD_WARNING;</a>
<a name="ln555"> </a>
<a name="ln556">  VTY_GET_INTEGER (&quot;VRF ID&quot;, vrf_id, argv[0]);</a>
<a name="ln557">  vrf = vrf_get (vrf_id);</a>
<a name="ln558"> </a>
<a name="ln559">  if (vrf-&gt;name &amp;&amp; strcmp (vrf-&gt;name, pathname) != 0)</a>
<a name="ln560">    {</a>
<a name="ln561">      vty_out (vty, &quot;VRF %u is already configured with NETNS %s%s&quot;,</a>
<a name="ln562">               vrf-&gt;vrf_id, vrf-&gt;name, VTY_NEWLINE);</a>
<a name="ln563">      return CMD_WARNING;</a>
<a name="ln564">    }</a>
<a name="ln565"> </a>
<a name="ln566">  if (!vrf-&gt;name)</a>
<a name="ln567">    vrf-&gt;name = XSTRDUP (MTYPE_VRF_NAME, pathname);</a>
<a name="ln568"> </a>
<a name="ln569">  if (!vrf_enable (vrf))</a>
<a name="ln570">    {</a>
<a name="ln571">      vty_out (vty, &quot;Can not associate VRF %u with NETNS %s%s&quot;,</a>
<a name="ln572">               vrf-&gt;vrf_id, vrf-&gt;name, VTY_NEWLINE);</a>
<a name="ln573">      return CMD_WARNING;</a>
<a name="ln574">    }</a>
<a name="ln575"> </a>
<a name="ln576">  return CMD_SUCCESS;</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">DEFUN (no_vrf_netns,</a>
<a name="ln580">       no_vrf_netns_cmd,</a>
<a name="ln581">       &quot;no vrf &lt;1-65535&gt; netns NAME&quot;,</a>
<a name="ln582">       NO_STR</a>
<a name="ln583">       &quot;Enable a VRF\n&quot;</a>
<a name="ln584">       &quot;Specify the VRF identifier\n&quot;</a>
<a name="ln585">       &quot;Associate with a NETNS\n&quot;</a>
<a name="ln586">       &quot;The file name in &quot; VRF_RUN_DIR &quot;, or a full pathname\n&quot;)</a>
<a name="ln587">{</a>
<a name="ln588">  vrf_id_t vrf_id = VRF_DEFAULT;</a>
<a name="ln589">  struct vrf *vrf = NULL;</a>
<a name="ln590">  char *pathname = vrf_netns_pathname (vty, argv[1]);</a>
<a name="ln591"> </a>
<a name="ln592">  if (!pathname)</a>
<a name="ln593">    return CMD_WARNING;</a>
<a name="ln594"> </a>
<a name="ln595">  VTY_GET_INTEGER (&quot;VRF ID&quot;, vrf_id, argv[0]);</a>
<a name="ln596">  vrf = vrf_lookup (vrf_id);</a>
<a name="ln597"> </a>
<a name="ln598">  if (!vrf)</a>
<a name="ln599">    {</a>
<a name="ln600">      vty_out (vty, &quot;VRF %u is not found%s&quot;, vrf_id, VTY_NEWLINE);</a>
<a name="ln601">      return CMD_SUCCESS;</a>
<a name="ln602">    }</a>
<a name="ln603"> </a>
<a name="ln604">  if (vrf-&gt;name &amp;&amp; strcmp (vrf-&gt;name, pathname) != 0)</a>
<a name="ln605">    {</a>
<a name="ln606">      vty_out (vty, &quot;Incorrect NETNS file name%s&quot;, VTY_NEWLINE);</a>
<a name="ln607">      return CMD_WARNING;</a>
<a name="ln608">    }</a>
<a name="ln609"> </a>
<a name="ln610">  vrf_disable (vrf);</a>
<a name="ln611"> </a>
<a name="ln612">  if (vrf-&gt;name)</a>
<a name="ln613">    {</a>
<a name="ln614">      XFREE (MTYPE_VRF_NAME, vrf-&gt;name);</a>
<a name="ln615">      vrf-&gt;name = NULL;</a>
<a name="ln616">    }</a>
<a name="ln617"> </a>
<a name="ln618">  return CMD_SUCCESS;</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">/* VRF node. */</a>
<a name="ln622">static struct cmd_node vrf_node =</a>
<a name="ln623">{</a>
<a name="ln624">  VRF_NODE,</a>
<a name="ln625">  &quot;&quot;,       /* VRF node has no interface. */</a>
<a name="ln626">  1</a>
<a name="ln627">};</a>
<a name="ln628"> </a>
<a name="ln629">/* VRF configuration write function. */</a>
<a name="ln630">static int</a>
<a name="ln631">vrf_config_write (struct vty *vty)</a>
<a name="ln632">{</a>
<a name="ln633">  struct route_node *rn;</a>
<a name="ln634">  struct vrf *vrf;</a>
<a name="ln635">  int write = 0;</a>
<a name="ln636"> </a>
<a name="ln637">  for (rn = route_top (vrf_table); rn; rn = route_next (rn))</a>
<a name="ln638">    if ((vrf = rn-&gt;info) != NULL &amp;&amp;</a>
<a name="ln639">        vrf-&gt;vrf_id != VRF_DEFAULT &amp;&amp; vrf-&gt;name)</a>
<a name="ln640">      {</a>
<a name="ln641">        vty_out (vty, &quot;vrf %u netns %s%s&quot;, vrf-&gt;vrf_id, vrf-&gt;name, VTY_NEWLINE);</a>
<a name="ln642">        write++;</a>
<a name="ln643">      }</a>
<a name="ln644"> </a>
<a name="ln645">  return write;</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">/* Initialize VRF module. */</a>
<a name="ln649">void</a>
<a name="ln650">vrf_init (void)</a>
<a name="ln651">{</a>
<a name="ln652">  struct vrf *default_vrf;</a>
<a name="ln653"> </a>
<a name="ln654">  /* Allocate VRF table.  */</a>
<a name="ln655">  vrf_table = route_table_init ();</a>
<a name="ln656"> </a>
<a name="ln657">  /* The default VRF always exists. */</a>
<a name="ln658">  default_vrf = vrf_get (VRF_DEFAULT);</a>
<a name="ln659">  if (!default_vrf)</a>
<a name="ln660">    {</a>
<a name="ln661">      zlog_err (&quot;vrf_init: failed to create the default VRF!&quot;);</a>
<a name="ln662">      exit (1);</a>
<a name="ln663">    }</a>
<a name="ln664"> </a>
<a name="ln665">  /* Set the default VRF name. */</a>
<a name="ln666">  default_vrf-&gt;name = XSTRDUP (MTYPE_VRF_NAME, VRF_DEFAULT_NAME);</a>
<a name="ln667"> </a>
<a name="ln668">  /* Enable the default VRF. */</a>
<a name="ln669">  if (!vrf_enable (default_vrf))</a>
<a name="ln670">    {</a>
<a name="ln671">      zlog_err (&quot;vrf_init: failed to enable the default VRF!&quot;);</a>
<a name="ln672">      exit (1);</a>
<a name="ln673">    }</a>
<a name="ln674"> </a>
<a name="ln675">  if (have_netns())</a>
<a name="ln676">    {</a>
<a name="ln677">      /* Install VRF commands. */</a>
<a name="ln678">      install_node (&amp;vrf_node, vrf_config_write);</a>
<a name="ln679">      install_element (CONFIG_NODE, &amp;vrf_netns_cmd);</a>
<a name="ln680">      install_element (CONFIG_NODE, &amp;no_vrf_netns_cmd);</a>
<a name="ln681">    }</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">/* Terminate VRF module. */</a>
<a name="ln685">void</a>
<a name="ln686">vrf_terminate (void)</a>
<a name="ln687">{</a>
<a name="ln688">  struct route_node *rn;</a>
<a name="ln689">  struct vrf *vrf;</a>
<a name="ln690"> </a>
<a name="ln691">  for (rn = route_top (vrf_table); rn; rn = route_next (rn))</a>
<a name="ln692">    if ((vrf = rn-&gt;info) != NULL)</a>
<a name="ln693">      vrf_delete (vrf);</a>
<a name="ln694"> </a>
<a name="ln695">  route_table_finish (vrf_table);</a>
<a name="ln696">  vrf_table = NULL;</a>
<a name="ln697">}</a>
<a name="ln698"> </a>
<a name="ln699">/* Create a socket for the VRF. */</a>
<a name="ln700">int</a>
<a name="ln701">vrf_socket (int domain, int type, int protocol, vrf_id_t vrf_id)</a>
<a name="ln702">{</a>
<a name="ln703">  struct vrf *vrf = vrf_lookup (vrf_id);</a>
<a name="ln704">  int ret = -1;</a>
<a name="ln705"> </a>
<a name="ln706">  if (!vrf_is_enabled (vrf))</a>
<a name="ln707">    {</a>
<a name="ln708">      errno = ENOSYS;</a>
<a name="ln709">      return -1;</a>
<a name="ln710">    }</a>
<a name="ln711"> </a>
<a name="ln712">  if (have_netns())</a>
<a name="ln713">    {</a>
<a name="ln714">      ret = (vrf_id != VRF_DEFAULT) ? setns (vrf-&gt;fd, CLONE_NEWNET) : 0;</a>
<a name="ln715">      if (ret &gt;= 0)</a>
<a name="ln716">        {</a>
<a name="ln717">          ret = socket (domain, type, protocol);</a>
<a name="ln718">          if (vrf_id != VRF_DEFAULT)</a>
<a name="ln719">            setns (vrf_lookup (VRF_DEFAULT)-&gt;fd, CLONE_NEWNET);</a>
<a name="ln720">        }</a>
<a name="ln721">    }</a>
<a name="ln722">  else</a>
<a name="ln723">    ret = socket (domain, type, protocol);</a>
<a name="ln724"> </a>
<a name="ln725">  return ret;</a>
<a name="ln726">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
