
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf6_asbr.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (C) 2003 Yasuhiro Ohara</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the </a>
<a name="ln18"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330, </a>
<a name="ln19"> * Boston, MA 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;log.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;command.h&quot;</a>
<a name="ln28">#include &quot;vty.h&quot;</a>
<a name="ln29">#include &quot;routemap.h&quot;</a>
<a name="ln30">#include &quot;table.h&quot;</a>
<a name="ln31">#include &quot;plist.h&quot;</a>
<a name="ln32">#include &quot;thread.h&quot;</a>
<a name="ln33">#include &quot;linklist.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;ospf6_proto.h&quot;</a>
<a name="ln36">#include &quot;ospf6_lsa.h&quot;</a>
<a name="ln37">#include &quot;ospf6_lsdb.h&quot;</a>
<a name="ln38">#include &quot;ospf6_route.h&quot;</a>
<a name="ln39">#include &quot;ospf6_zebra.h&quot;</a>
<a name="ln40">#include &quot;ospf6_message.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;ospf6_top.h&quot;</a>
<a name="ln43">#include &quot;ospf6_area.h&quot;</a>
<a name="ln44">#include &quot;ospf6_interface.h&quot;</a>
<a name="ln45">#include &quot;ospf6_neighbor.h&quot;</a>
<a name="ln46">#include &quot;ospf6_asbr.h&quot;</a>
<a name="ln47">#include &quot;ospf6_intra.h&quot;</a>
<a name="ln48">#include &quot;ospf6_flood.h&quot;</a>
<a name="ln49">#include &quot;ospf6d.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">unsigned char conf_debug_ospf6_asbr = 0;</a>
<a name="ln52"> </a>
<a name="ln53">#define ZROUTE_NAME(x) zebra_route_string(x)</a>
<a name="ln54"> </a>
<a name="ln55">/* AS External LSA origination */</a>
<a name="ln56">static void</a>
<a name="ln57">ospf6_as_external_lsa_originate (struct ospf6_route *route)</a>
<a name="ln58">{</a>
<a name="ln59">  char buffer[OSPF6_MAX_LSASIZE];</a>
<a name="ln60">  struct ospf6_lsa_header *lsa_header;</a>
<a name="ln61">  struct ospf6_lsa *lsa;</a>
<a name="ln62">  struct ospf6_external_info *info = route-&gt;route_option;</a>
<a name="ln63"> </a>
<a name="ln64">  struct ospf6_as_external_lsa *as_external_lsa;</a>
<a name="ln65">  char buf[64];</a>
<a name="ln66">  caddr_t p;</a>
<a name="ln67"> </a>
<a name="ln68">  if (IS_OSPF6_DEBUG_ASBR || IS_OSPF6_DEBUG_ORIGINATE (AS_EXTERNAL))</a>
<a name="ln69">    {</a>
<a name="ln70">      prefix2str (&amp;route-&gt;prefix, buf, sizeof (buf));</a>
<a name="ln71">      zlog_debug (&quot;Originate AS-External-LSA for %s&quot;, buf);</a>
<a name="ln72">    }</a>
<a name="ln73"> </a>
<a name="ln74">  /* prepare buffer */</a>
<a name="ln75">  memset (buffer, 0, sizeof (buffer));</a>
<a name="ln76">  lsa_header = (struct ospf6_lsa_header *) buffer;</a>
<a name="ln77">  as_external_lsa = (struct ospf6_as_external_lsa *)</a>
<a name="ln78">    ((caddr_t) lsa_header + sizeof (struct ospf6_lsa_header));</a>
<a name="ln79">  p = (caddr_t)</a>
<a name="ln80">    ((caddr_t) as_external_lsa + sizeof (struct ospf6_as_external_lsa));</a>
<a name="ln81"> </a>
<a name="ln82">  /* Fill AS-External-LSA */</a>
<a name="ln83">  /* Metric type */</a>
<a name="ln84">  if (route-&gt;path.metric_type == 2)</a>
<a name="ln85">    SET_FLAG (as_external_lsa-&gt;bits_metric, OSPF6_ASBR_BIT_E);</a>
<a name="ln86">  else</a>
<a name="ln87">    UNSET_FLAG (as_external_lsa-&gt;bits_metric, OSPF6_ASBR_BIT_E);</a>
<a name="ln88"> </a>
<a name="ln89">  /* forwarding address */</a>
<a name="ln90">  if (! IN6_IS_ADDR_UNSPECIFIED (&amp;info-&gt;forwarding))</a>
<a name="ln91">    SET_FLAG (as_external_lsa-&gt;bits_metric, OSPF6_ASBR_BIT_F);</a>
<a name="ln92">  else</a>
<a name="ln93">    UNSET_FLAG (as_external_lsa-&gt;bits_metric, OSPF6_ASBR_BIT_F);</a>
<a name="ln94"> </a>
<a name="ln95">  /* external route tag */</a>
<a name="ln96">  if (info-&gt;tag)</a>
<a name="ln97">    SET_FLAG (as_external_lsa-&gt;bits_metric, OSPF6_ASBR_BIT_T);</a>
<a name="ln98">  else</a>
<a name="ln99">    UNSET_FLAG (as_external_lsa-&gt;bits_metric, OSPF6_ASBR_BIT_T);</a>
<a name="ln100"> </a>
<a name="ln101">  /* Set metric */</a>
<a name="ln102">  OSPF6_ASBR_METRIC_SET (as_external_lsa, route-&gt;path.cost);</a>
<a name="ln103"> </a>
<a name="ln104">  /* prefixlen */</a>
<a name="ln105">  as_external_lsa-&gt;prefix.prefix_length = route-&gt;prefix.prefixlen;</a>
<a name="ln106"> </a>
<a name="ln107">  /* PrefixOptions */</a>
<a name="ln108">  as_external_lsa-&gt;prefix.prefix_options = route-&gt;path.prefix_options;</a>
<a name="ln109"> </a>
<a name="ln110">  /* don't use refer LS-type */</a>
<a name="ln111">  as_external_lsa-&gt;prefix.prefix_refer_lstype = htons (0);</a>
<a name="ln112"> </a>
<a name="ln113">  /* set Prefix */</a>
<a name="ln114">  memcpy (p, &amp;route-&gt;prefix.u.prefix6,</a>
<a name="ln115">          OSPF6_PREFIX_SPACE (route-&gt;prefix.prefixlen));</a>
<a name="ln116">  ospf6_prefix_apply_mask (&amp;as_external_lsa-&gt;prefix);</a>
<a name="ln117">  p += OSPF6_PREFIX_SPACE (route-&gt;prefix.prefixlen);</a>
<a name="ln118"> </a>
<a name="ln119">  /* Forwarding address */</a>
<a name="ln120">  if (CHECK_FLAG (as_external_lsa-&gt;bits_metric, OSPF6_ASBR_BIT_F))</a>
<a name="ln121">    {</a>
<a name="ln122">      memcpy (p, &amp;info-&gt;forwarding, sizeof (struct in6_addr));</a>
<a name="ln123">      p += sizeof (struct in6_addr);</a>
<a name="ln124">    }</a>
<a name="ln125"> </a>
<a name="ln126">  /* External Route Tag */</a>
<a name="ln127">  if (CHECK_FLAG (as_external_lsa-&gt;bits_metric, OSPF6_ASBR_BIT_T))</a>
<a name="ln128">    {</a>
<a name="ln129">      route_tag_t network_order = htonl(info-&gt;tag);</a>
<a name="ln130"> </a>
<a name="ln131">      memcpy (p, &amp;network_order, sizeof(network_order));</a>
<a name="ln132">      p += sizeof(network_order);</a>
<a name="ln133">    }</a>
<a name="ln134"> </a>
<a name="ln135">  /* Fill LSA Header */</a>
<a name="ln136">  lsa_header-&gt;age = 0;</a>
<a name="ln137">  lsa_header-&gt;type = htons (OSPF6_LSTYPE_AS_EXTERNAL);</a>
<a name="ln138">  lsa_header-&gt;id = route-&gt;path.origin.id;</a>
<a name="ln139">  lsa_header-&gt;adv_router = ospf6-&gt;router_id;</a>
<a name="ln140">  lsa_header-&gt;seqnum =</a>
<a name="ln141">    ospf6_new_ls_seqnum (lsa_header-&gt;type, lsa_header-&gt;id,</a>
<a name="ln142">                         lsa_header-&gt;adv_router, ospf6-&gt;lsdb);</a>
<a name="ln143">  lsa_header-&gt;length = htons ((caddr_t) p - (caddr_t) lsa_header);</a>
<a name="ln144"> </a>
<a name="ln145">  /* LSA checksum */</a>
<a name="ln146">  ospf6_lsa_checksum (lsa_header);</a>
<a name="ln147"> </a>
<a name="ln148">  /* create LSA */</a>
<a name="ln149">  lsa = ospf6_lsa_create (lsa_header);</a>
<a name="ln150"> </a>
<a name="ln151">  /* Originate */</a>
<a name="ln152">  ospf6_lsa_originate_process (lsa, ospf6);</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">static route_tag_t</a>
<a name="ln156">ospf6_as_external_lsa_get_tag (struct ospf6_lsa *lsa)</a>
<a name="ln157">{</a>
<a name="ln158">  struct ospf6_as_external_lsa *external;</a>
<a name="ln159">  ptrdiff_t tag_offset;</a>
<a name="ln160">  route_tag_t network_order;</a>
<a name="ln161"> </a>
<a name="ln162">  if (!lsa)</a>
<a name="ln163">    return 0;</a>
<a name="ln164"> </a>
<a name="ln165">  external = (struct ospf6_as_external_lsa *)</a>
<a name="ln166">    OSPF6_LSA_HEADER_END (lsa-&gt;header);</a>
<a name="ln167"> </a>
<a name="ln168">  if (!CHECK_FLAG (external-&gt;bits_metric, OSPF6_ASBR_BIT_T))</a>
<a name="ln169">    return 0;</a>
<a name="ln170"> </a>
<a name="ln171">  tag_offset = sizeof(*external) + OSPF6_PREFIX_SPACE(external-&gt;prefix.prefix_length);</a>
<a name="ln172">  if (CHECK_FLAG (external-&gt;bits_metric, OSPF6_ASBR_BIT_F))</a>
<a name="ln173">    tag_offset += sizeof(struct in6_addr);</a>
<a name="ln174"> </a>
<a name="ln175">  memcpy(&amp;network_order, (caddr_t)external + tag_offset, sizeof(network_order));</a>
<a name="ln176">  return ntohl(network_order);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">void</a>
<a name="ln180">ospf6_asbr_lsa_add (struct ospf6_lsa *lsa)</a>
<a name="ln181">{</a>
<a name="ln182">  struct ospf6_as_external_lsa *external;</a>
<a name="ln183">  struct prefix asbr_id;</a>
<a name="ln184">  struct ospf6_route *asbr_entry, *route;</a>
<a name="ln185">  char buf[64];</a>
<a name="ln186">  int i;</a>
<a name="ln187"> </a>
<a name="ln188">  external = (struct ospf6_as_external_lsa *)</a>
<a name="ln189">    OSPF6_LSA_HEADER_END (lsa-&gt;header);</a>
<a name="ln190"> </a>
<a name="ln191">  if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln192">    zlog_debug (&quot;Calculate AS-External route for %s&quot;, lsa-&gt;name);</a>
<a name="ln193"> </a>
<a name="ln194">  if (lsa-&gt;header-&gt;adv_router == ospf6-&gt;router_id)</a>
<a name="ln195">    {</a>
<a name="ln196">      if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln197">        zlog_debug (&quot;Ignore self-originated AS-External-LSA&quot;);</a>
<a name="ln198">      return;</a>
<a name="ln199">    }</a>
<a name="ln200"> </a>
<a name="ln201">  if (OSPF6_ASBR_METRIC (external) == OSPF_LS_INFINITY)</a>
<a name="ln202">    {</a>
<a name="ln203">      if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln204">        zlog_debug (&quot;Ignore LSA with LSInfinity Metric&quot;);</a>
<a name="ln205">      return;</a>
<a name="ln206">    }</a>
<a name="ln207"> </a>
<a name="ln208">  if (CHECK_FLAG(external-&gt;prefix.prefix_options, OSPF6_PREFIX_OPTION_NU))</a>
<a name="ln209">    {</a>
<a name="ln210">      if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln211">        zlog_debug (&quot;Ignore LSA with NU bit set Metric&quot;);</a>
<a name="ln212">      return;</a>
<a name="ln213">    }</a>
<a name="ln214"> </a>
<a name="ln215">  ospf6_linkstate_prefix (lsa-&gt;header-&gt;adv_router, htonl (0), &amp;asbr_id);</a>
<a name="ln216">  asbr_entry = ospf6_route_lookup (&amp;asbr_id, ospf6-&gt;brouter_table);</a>
<a name="ln217">  if (asbr_entry == NULL ||</a>
<a name="ln218">      ! CHECK_FLAG (asbr_entry-&gt;path.router_bits, OSPF6_ROUTER_BIT_E))</a>
<a name="ln219">    {</a>
<a name="ln220">      if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln221">        {</a>
<a name="ln222">          prefix2str (&amp;asbr_id, buf, sizeof (buf));</a>
<a name="ln223">          zlog_debug (&quot;ASBR entry not found: %s&quot;, buf);</a>
<a name="ln224">        }</a>
<a name="ln225">      return;</a>
<a name="ln226">    }</a>
<a name="ln227"> </a>
<a name="ln228">  route = ospf6_route_create ();</a>
<a name="ln229">  route-&gt;type = OSPF6_DEST_TYPE_NETWORK;</a>
<a name="ln230">  route-&gt;prefix.family = AF_INET6;</a>
<a name="ln231">  route-&gt;prefix.prefixlen = external-&gt;prefix.prefix_length;</a>
<a name="ln232">  ospf6_prefix_in6_addr (&amp;route-&gt;prefix.u.prefix6, &amp;external-&gt;prefix);</a>
<a name="ln233"> </a>
<a name="ln234">  route-&gt;path.area_id = asbr_entry-&gt;path.area_id;</a>
<a name="ln235">  route-&gt;path.origin.type = lsa-&gt;header-&gt;type;</a>
<a name="ln236">  route-&gt;path.origin.id = lsa-&gt;header-&gt;id;</a>
<a name="ln237">  route-&gt;path.origin.adv_router = lsa-&gt;header-&gt;adv_router;</a>
<a name="ln238"> </a>
<a name="ln239">  route-&gt;path.prefix_options = external-&gt;prefix.prefix_options;</a>
<a name="ln240">  if (CHECK_FLAG (external-&gt;bits_metric, OSPF6_ASBR_BIT_E))</a>
<a name="ln241">    {</a>
<a name="ln242">      route-&gt;path.type = OSPF6_PATH_TYPE_EXTERNAL2;</a>
<a name="ln243">      route-&gt;path.metric_type = 2;</a>
<a name="ln244">      route-&gt;path.cost = asbr_entry-&gt;path.cost;</a>
<a name="ln245">      route-&gt;path.cost_e2 = OSPF6_ASBR_METRIC (external);</a>
<a name="ln246">    }</a>
<a name="ln247">  else</a>
<a name="ln248">    {</a>
<a name="ln249">      route-&gt;path.type = OSPF6_PATH_TYPE_EXTERNAL1;</a>
<a name="ln250">      route-&gt;path.metric_type = 1;</a>
<a name="ln251">      route-&gt;path.cost = asbr_entry-&gt;path.cost + OSPF6_ASBR_METRIC (external);</a>
<a name="ln252">      route-&gt;path.cost_e2 = 0;</a>
<a name="ln253">    }</a>
<a name="ln254"> </a>
<a name="ln255">  route-&gt;path.tag = ospf6_as_external_lsa_get_tag (lsa);</a>
<a name="ln256">  </a>
<a name="ln257">  for (i = 0; i &lt; OSPF6_MULTI_PATH_LIMIT; i++)</a>
<a name="ln258">    ospf6_nexthop_copy (&amp;route-&gt;nexthop[i], &amp;asbr_entry-&gt;nexthop[i]);</a>
<a name="ln259"> </a>
<a name="ln260">  if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln261">    {</a>
<a name="ln262">      prefix2str (&amp;route-&gt;prefix, buf, sizeof (buf));</a>
<a name="ln263">      zlog_debug (&quot;AS-External route add: %s&quot;, buf);</a>
<a name="ln264">    }</a>
<a name="ln265"> </a>
<a name="ln266">  ospf6_route_add (route, ospf6-&gt;route_table);</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">void</a>
<a name="ln270">ospf6_asbr_lsa_remove (struct ospf6_lsa *lsa)</a>
<a name="ln271">{</a>
<a name="ln272">  struct ospf6_as_external_lsa *external;</a>
<a name="ln273">  struct prefix prefix;</a>
<a name="ln274">  struct ospf6_route *route, *nroute;</a>
<a name="ln275">  char buf[64];</a>
<a name="ln276"> </a>
<a name="ln277">  external = (struct ospf6_as_external_lsa *)</a>
<a name="ln278">    OSPF6_LSA_HEADER_END (lsa-&gt;header);</a>
<a name="ln279"> </a>
<a name="ln280">  if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln281">    zlog_debug (&quot;Withdraw AS-External route for %s&quot;, lsa-&gt;name);</a>
<a name="ln282"> </a>
<a name="ln283">  if (lsa-&gt;header-&gt;adv_router == ospf6-&gt;router_id)</a>
<a name="ln284">    {</a>
<a name="ln285">      if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln286">        zlog_debug (&quot;Ignore self-originated AS-External-LSA&quot;);</a>
<a name="ln287">      return;</a>
<a name="ln288">    }</a>
<a name="ln289"> </a>
<a name="ln290">  memset (&amp;prefix, 0, sizeof (struct prefix));</a>
<a name="ln291">  prefix.family = AF_INET6;</a>
<a name="ln292">  prefix.prefixlen = external-&gt;prefix.prefix_length;</a>
<a name="ln293">  ospf6_prefix_in6_addr (&amp;prefix.u.prefix6, &amp;external-&gt;prefix);</a>
<a name="ln294"> </a>
<a name="ln295">  route = ospf6_route_lookup (&amp;prefix, ospf6-&gt;route_table);</a>
<a name="ln296">  if (route == NULL)</a>
<a name="ln297">    {</a>
<a name="ln298">      if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln299">        {</a>
<a name="ln300">          prefix2str (&amp;prefix, buf, sizeof (buf));</a>
<a name="ln301">          zlog_debug (&quot;AS-External route %s not found&quot;, buf);</a>
<a name="ln302">        }</a>
<a name="ln303">      return;</a>
<a name="ln304">    }</a>
<a name="ln305"> </a>
<a name="ln306">  for (ospf6_route_lock (route);</a>
<a name="ln307">       route &amp;&amp; ospf6_route_is_prefix (&amp;prefix, route);</a>
<a name="ln308">       route = nroute)</a>
<a name="ln309">    {</a>
<a name="ln310">      nroute = ospf6_route_next (route);</a>
<a name="ln311">      if (route-&gt;type != OSPF6_DEST_TYPE_NETWORK)</a>
<a name="ln312">        continue;</a>
<a name="ln313">      if (route-&gt;path.origin.type != lsa-&gt;header-&gt;type)</a>
<a name="ln314">        continue;</a>
<a name="ln315">      if (route-&gt;path.origin.id != lsa-&gt;header-&gt;id)</a>
<a name="ln316">        continue;</a>
<a name="ln317">      if (route-&gt;path.origin.adv_router != lsa-&gt;header-&gt;adv_router)</a>
<a name="ln318">        continue;</a>
<a name="ln319"> </a>
<a name="ln320">      if (IS_OSPF6_DEBUG_EXAMIN (AS_EXTERNAL))</a>
<a name="ln321">        {</a>
<a name="ln322">          prefix2str (&amp;route-&gt;prefix, buf, sizeof (buf));</a>
<a name="ln323">          zlog_debug (&quot;AS-External route remove: %s&quot;, buf);</a>
<a name="ln324">        }</a>
<a name="ln325">      ospf6_route_remove (route, ospf6-&gt;route_table);</a>
<a name="ln326">    }</a>
<a name="ln327">  if (route != NULL)</a>
<a name="ln328">    ospf6_route_unlock (route);</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">void</a>
<a name="ln332">ospf6_asbr_lsentry_add (struct ospf6_route *asbr_entry)</a>
<a name="ln333">{</a>
<a name="ln334">  struct ospf6_lsa *lsa;</a>
<a name="ln335">  u_int16_t type;</a>
<a name="ln336">  u_int32_t router;</a>
<a name="ln337"> </a>
<a name="ln338">  if (! CHECK_FLAG (asbr_entry-&gt;flag, OSPF6_ROUTE_BEST))</a>
<a name="ln339">    {</a>
<a name="ln340">      char buf[16];</a>
<a name="ln341">      inet_ntop (AF_INET, &amp;ADV_ROUTER_IN_PREFIX (&amp;asbr_entry-&gt;prefix),</a>
<a name="ln342">                 buf, sizeof (buf));</a>
<a name="ln343">       zlog_info (&quot;ignore non-best path: lsentry %s add&quot;, buf);</a>
<a name="ln344">      return;</a>
<a name="ln345">    }</a>
<a name="ln346"> </a>
<a name="ln347">  type = htons (OSPF6_LSTYPE_AS_EXTERNAL);</a>
<a name="ln348">  router = ospf6_linkstate_prefix_adv_router (&amp;asbr_entry-&gt;prefix);</a>
<a name="ln349">  for (lsa = ospf6_lsdb_type_router_head (type, router, ospf6-&gt;lsdb); lsa;</a>
<a name="ln350">       lsa = ospf6_lsdb_type_router_next (type, router, lsa))</a>
<a name="ln351">    {</a>
<a name="ln352">      if (! OSPF6_LSA_IS_MAXAGE (lsa))</a>
<a name="ln353">        ospf6_asbr_lsa_add (lsa);</a>
<a name="ln354">    }</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">void</a>
<a name="ln358">ospf6_asbr_lsentry_remove (struct ospf6_route *asbr_entry)</a>
<a name="ln359">{</a>
<a name="ln360">  struct ospf6_lsa *lsa;</a>
<a name="ln361">  u_int16_t type;</a>
<a name="ln362">  u_int32_t router;</a>
<a name="ln363"> </a>
<a name="ln364">  type = htons (OSPF6_LSTYPE_AS_EXTERNAL);</a>
<a name="ln365">  router = ospf6_linkstate_prefix_adv_router (&amp;asbr_entry-&gt;prefix);</a>
<a name="ln366">  for (lsa = ospf6_lsdb_type_router_head (type, router, ospf6-&gt;lsdb);</a>
<a name="ln367">       lsa; lsa = ospf6_lsdb_type_router_next (type, router, lsa))</a>
<a name="ln368">    ospf6_asbr_lsa_remove (lsa);</a>
<a name="ln369">}</a>
<a name="ln370"> </a>
<a name="ln371"> </a>
<a name="ln372"> </a>
<a name="ln373">/* redistribute function */</a>
<a name="ln374"> </a>
<a name="ln375">static void</a>
<a name="ln376">ospf6_asbr_routemap_set (int type, const char *mapname)</a>
<a name="ln377">{</a>
<a name="ln378">  if (ospf6-&gt;rmap[type].name)</a>
<a name="ln379">    free (ospf6-&gt;rmap[type].name);</a>
<a name="ln380">  ospf6-&gt;rmap[type].name = strdup (mapname);</a>
<a name="ln381">  ospf6-&gt;rmap[type].map = route_map_lookup_by_name (mapname);</a>
<a name="ln382">}</a>
<a name="ln383"> </a>
<a name="ln384">static void</a>
<a name="ln385">ospf6_asbr_routemap_unset (int type)</a>
<a name="ln386">{</a>
<a name="ln387">  if (ospf6-&gt;rmap[type].name)</a>
<a name="ln388">    free (ospf6-&gt;rmap[type].name);</a>
<a name="ln389">  ospf6-&gt;rmap[type].name = NULL;</a>
<a name="ln390">  ospf6-&gt;rmap[type].map = NULL;</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">static void</a>
<a name="ln394">ospf6_asbr_routemap_update (const char *mapname)</a>
<a name="ln395">{</a>
<a name="ln396">  int type;</a>
<a name="ln397"> </a>
<a name="ln398">  if (ospf6 == NULL)</a>
<a name="ln399">    return;</a>
<a name="ln400"> </a>
<a name="ln401">  for (type = 0; type &lt; ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln402">    {</a>
<a name="ln403">      if (ospf6-&gt;rmap[type].name)</a>
<a name="ln404">        ospf6-&gt;rmap[type].map =</a>
<a name="ln405">          route_map_lookup_by_name (ospf6-&gt;rmap[type].name);</a>
<a name="ln406">      else</a>
<a name="ln407">        ospf6-&gt;rmap[type].map = NULL;</a>
<a name="ln408">    }</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">int</a>
<a name="ln412">ospf6_asbr_is_asbr (struct ospf6 *o)</a>
<a name="ln413">{</a>
<a name="ln414">  return o-&gt;external_table-&gt;count;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">static void</a>
<a name="ln418">ospf6_asbr_redistribute_set (int type)</a>
<a name="ln419">{</a>
<a name="ln420">  ospf6_zebra_redistribute (type);</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423">static void</a>
<a name="ln424">ospf6_asbr_redistribute_unset (int type)</a>
<a name="ln425">{</a>
<a name="ln426">  struct ospf6_route *route;</a>
<a name="ln427">  struct ospf6_external_info *info;</a>
<a name="ln428"> </a>
<a name="ln429">  ospf6_zebra_no_redistribute (type);</a>
<a name="ln430"> </a>
<a name="ln431">  for (route = ospf6_route_head (ospf6-&gt;external_table); route;</a>
<a name="ln432">       route = ospf6_route_next (route))</a>
<a name="ln433">    {</a>
<a name="ln434">      info = route-&gt;route_option;</a>
<a name="ln435">      if (info-&gt;type != type)</a>
<a name="ln436">        continue;</a>
<a name="ln437"> </a>
<a name="ln438">      ospf6_asbr_redistribute_remove (info-&gt;type, route-&gt;nexthop[0].ifindex,</a>
<a name="ln439">                                      &amp;route-&gt;prefix);</a>
<a name="ln440">    }</a>
<a name="ln441"> </a>
<a name="ln442">  ospf6_asbr_routemap_unset (type);</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">void</a>
<a name="ln446">ospf6_asbr_redistribute_add (int type, ifindex_t ifindex, struct prefix *prefix,</a>
<a name="ln447">                             u_int nexthop_num, struct in6_addr *nexthop, route_tag_t tag)</a>
<a name="ln448">{</a>
<a name="ln449">  int ret;</a>
<a name="ln450">  struct ospf6_route troute;</a>
<a name="ln451">  struct ospf6_external_info tinfo;</a>
<a name="ln452">  struct ospf6_route *route, *match;</a>
<a name="ln453">  struct ospf6_external_info *info;</a>
<a name="ln454">  struct prefix prefix_id;</a>
<a name="ln455">  struct route_node *node;</a>
<a name="ln456">  char pbuf[64], ibuf[16];</a>
<a name="ln457">  struct listnode *lnode, *lnnode;</a>
<a name="ln458">  struct ospf6_area *oa;</a>
<a name="ln459"> </a>
<a name="ln460">  if (! ospf6_zebra_is_redistribute (type))</a>
<a name="ln461">    return;</a>
<a name="ln462"> </a>
<a name="ln463">  if (IS_OSPF6_DEBUG_ASBR)</a>
<a name="ln464">    {</a>
<a name="ln465">      prefix2str (prefix, pbuf, sizeof (pbuf));</a>
<a name="ln466">      zlog_debug (&quot;Redistribute %s (%s)&quot;, pbuf, ZROUTE_NAME (type));</a>
<a name="ln467">    }</a>
<a name="ln468"> </a>
<a name="ln469">  /* if route-map was specified but not found, do not advertise */</a>
<a name="ln470">  if (ospf6-&gt;rmap[type].name)</a>
<a name="ln471">    {</a>
<a name="ln472">      if (ospf6-&gt;rmap[type].map == NULL)</a>
<a name="ln473">        ospf6_asbr_routemap_update (NULL);</a>
<a name="ln474">      if (ospf6-&gt;rmap[type].map == NULL)</a>
<a name="ln475">        {</a>
<a name="ln476">          zlog_warn (&quot;route-map \&quot;%s\&quot; not found, suppress redistributing&quot;,</a>
<a name="ln477">                     ospf6-&gt;rmap[type].name);</a>
<a name="ln478">          return;</a>
<a name="ln479">        }</a>
<a name="ln480">    }</a>
<a name="ln481"> </a>
<a name="ln482">  /* apply route-map */</a>
<a name="ln483">  if (ospf6-&gt;rmap[type].map)</a>
<a name="ln484">    {</a>
<a name="ln485">      memset (&amp;troute, 0, sizeof (troute));</a>
<a name="ln486">      memset (&amp;tinfo, 0, sizeof (tinfo));</a>
<a name="ln487">      troute.route_option = &amp;tinfo;</a>
<a name="ln488">      tinfo.ifindex = ifindex;</a>
<a name="ln489">      tinfo.tag = tag;</a>
<a name="ln490"> </a>
<a name="ln491">      ret = route_map_apply (ospf6-&gt;rmap[type].map, prefix,</a>
<a name="ln492">                             RMAP_OSPF6, &amp;troute);</a>
<a name="ln493">      if (ret == RMAP_DENYMATCH)</a>
<a name="ln494">        {</a>
<a name="ln495">          if (IS_OSPF6_DEBUG_ASBR)</a>
<a name="ln496">            zlog_debug (&quot;Denied by route-map \&quot;%s\&quot;&quot;, ospf6-&gt;rmap[type].name);</a>
<a name="ln497">          return;</a>
<a name="ln498">        }</a>
<a name="ln499">    }</a>
<a name="ln500"> </a>
<a name="ln501">  match = ospf6_route_lookup (prefix, ospf6-&gt;external_table);</a>
<a name="ln502">  if (match)</a>
<a name="ln503">    {</a>
<a name="ln504">      info = match-&gt;route_option;</a>
<a name="ln505"> </a>
<a name="ln506">      /* copy result of route-map */</a>
<a name="ln507">      if (ospf6-&gt;rmap[type].map)</a>
<a name="ln508">        {</a>
<a name="ln509">          if (troute.path.metric_type)</a>
<a name="ln510">            match-&gt;path.metric_type = troute.path.metric_type;</a>
<a name="ln511">          if (troute.path.cost)</a>
<a name="ln512">            match-&gt;path.cost = troute.path.cost;</a>
<a name="ln513">          if (! IN6_IS_ADDR_UNSPECIFIED (&amp;tinfo.forwarding))</a>
<a name="ln514">            memcpy (&amp;info-&gt;forwarding, &amp;tinfo.forwarding,</a>
<a name="ln515">                    sizeof (struct in6_addr));</a>
<a name="ln516">          info-&gt;tag = tinfo.tag;</a>
<a name="ln517">        }</a>
<a name="ln518">      else</a>
<a name="ln519">        {</a>
<a name="ln520">          /* If there is no route-map, simply update the tag */</a>
<a name="ln521">          info-&gt;tag = tag;</a>
<a name="ln522">        }</a>
<a name="ln523"> </a>
<a name="ln524">      info-&gt;type = type;</a>
<a name="ln525">      match-&gt;nexthop[0].ifindex = ifindex;</a>
<a name="ln526">      if (nexthop_num &amp;&amp; nexthop)</a>
<a name="ln527">        memcpy (&amp;match-&gt;nexthop[0].address, nexthop, sizeof (struct in6_addr));</a>
<a name="ln528"> </a>
<a name="ln529">      /* create/update binding in external_id_table */</a>
<a name="ln530">      prefix_id.family = AF_INET;</a>
<a name="ln531">      prefix_id.prefixlen = 32;</a>
<a name="ln532">      prefix_id.u.prefix4.s_addr = htonl (info-&gt;id);</a>
<a name="ln533">      node = route_node_get (ospf6-&gt;external_id_table, &amp;prefix_id);</a>
<a name="ln534">      node-&gt;info = match;</a>
<a name="ln535"> </a>
<a name="ln536">      if (IS_OSPF6_DEBUG_ASBR)</a>
<a name="ln537">        {</a>
<a name="ln538">          inet_ntop (AF_INET, &amp;prefix_id.u.prefix4, ibuf, sizeof (ibuf));</a>
<a name="ln539">          zlog_debug (&quot;Advertise as AS-External Id:%s&quot;, ibuf);</a>
<a name="ln540">        }</a>
<a name="ln541"> </a>
<a name="ln542">      match-&gt;path.origin.id = htonl (info-&gt;id);</a>
<a name="ln543">      ospf6_as_external_lsa_originate (match);</a>
<a name="ln544">      return;</a>
<a name="ln545">    }</a>
<a name="ln546"> </a>
<a name="ln547">  /* create new entry */</a>
<a name="ln548">  route = ospf6_route_create ();</a>
<a name="ln549">  route-&gt;type = OSPF6_DEST_TYPE_NETWORK;</a>
<a name="ln550">  memcpy (&amp;route-&gt;prefix, prefix, sizeof (struct prefix));</a>
<a name="ln551"> </a>
<a name="ln552">  info = (struct ospf6_external_info *)</a>
<a name="ln553">    XCALLOC (MTYPE_OSPF6_EXTERNAL_INFO, sizeof (struct ospf6_external_info));</a>
<a name="ln554">  route-&gt;route_option = info;</a>
<a name="ln555">  info-&gt;id = ospf6-&gt;external_id++;</a>
<a name="ln556"> </a>
<a name="ln557">  /* copy result of route-map */</a>
<a name="ln558">  if (ospf6-&gt;rmap[type].map)</a>
<a name="ln559">    {</a>
<a name="ln560">      if (troute.path.metric_type)</a>
<a name="ln561">        route-&gt;path.metric_type = troute.path.metric_type;</a>
<a name="ln562">      if (troute.path.cost)</a>
<a name="ln563">        route-&gt;path.cost = troute.path.cost;</a>
<a name="ln564">      if (! IN6_IS_ADDR_UNSPECIFIED (&amp;tinfo.forwarding))</a>
<a name="ln565">        memcpy (&amp;info-&gt;forwarding, &amp;tinfo.forwarding,</a>
<a name="ln566">                sizeof (struct in6_addr));</a>
<a name="ln567">      info-&gt;tag = tinfo.tag;</a>
<a name="ln568">    }</a>
<a name="ln569">  else</a>
<a name="ln570">    {</a>
<a name="ln571">      /* If there is no route-map, simply set the tag */</a>
<a name="ln572">      info-&gt;tag = tag;</a>
<a name="ln573">    }</a>
<a name="ln574"> </a>
<a name="ln575">  info-&gt;type = type;</a>
<a name="ln576">  route-&gt;nexthop[0].ifindex = ifindex;</a>
<a name="ln577">  if (nexthop_num &amp;&amp; nexthop)</a>
<a name="ln578">    memcpy (&amp;route-&gt;nexthop[0].address, nexthop, sizeof (struct in6_addr));</a>
<a name="ln579"> </a>
<a name="ln580">  /* create/update binding in external_id_table */</a>
<a name="ln581">  prefix_id.family = AF_INET;</a>
<a name="ln582">  prefix_id.prefixlen = 32;</a>
<a name="ln583">  prefix_id.u.prefix4.s_addr = htonl (info-&gt;id);</a>
<a name="ln584">  node = route_node_get (ospf6-&gt;external_id_table, &amp;prefix_id);</a>
<a name="ln585">  node-&gt;info = route;</a>
<a name="ln586"> </a>
<a name="ln587">  route = ospf6_route_add (route, ospf6-&gt;external_table);</a>
<a name="ln588">  route-&gt;route_option = info;</a>
<a name="ln589"> </a>
<a name="ln590">  if (IS_OSPF6_DEBUG_ASBR)</a>
<a name="ln591">    {</a>
<a name="ln592">      inet_ntop (AF_INET, &amp;prefix_id.u.prefix4, ibuf, sizeof (ibuf));</a>
<a name="ln593">      zlog_debug (&quot;Advertise as AS-External Id:%s&quot;, ibuf);</a>
<a name="ln594">    }</a>
<a name="ln595"> </a>
<a name="ln596">  route-&gt;path.origin.id = htonl (info-&gt;id);</a>
<a name="ln597">  ospf6_as_external_lsa_originate (route);</a>
<a name="ln598"> </a>
<a name="ln599">  /* Router-Bit (ASBR Flag) may have to be updated */</a>
<a name="ln600">  for (ALL_LIST_ELEMENTS (ospf6-&gt;area_list, lnode, lnnode, oa))</a>
<a name="ln601">    OSPF6_ROUTER_LSA_SCHEDULE (oa);</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">void</a>
<a name="ln605">ospf6_asbr_redistribute_remove (int type, ifindex_t ifindex,</a>
<a name="ln606">                                struct prefix *prefix)</a>
<a name="ln607">{</a>
<a name="ln608">  struct ospf6_route *match;</a>
<a name="ln609">  struct ospf6_external_info *info = NULL;</a>
<a name="ln610">  struct route_node *node;</a>
<a name="ln611">  struct ospf6_lsa *lsa;</a>
<a name="ln612">  struct prefix prefix_id;</a>
<a name="ln613">  char pbuf[64], ibuf[16];</a>
<a name="ln614">  struct listnode *lnode, *lnnode;</a>
<a name="ln615">  struct ospf6_area *oa;</a>
<a name="ln616"> </a>
<a name="ln617">  match = ospf6_route_lookup (prefix, ospf6-&gt;external_table);</a>
<a name="ln618">  if (match == NULL)</a>
<a name="ln619">    {</a>
<a name="ln620">      if (IS_OSPF6_DEBUG_ASBR)</a>
<a name="ln621">        {</a>
<a name="ln622">          prefix2str (prefix, pbuf, sizeof (pbuf));</a>
<a name="ln623">          zlog_debug (&quot;No such route %s to withdraw&quot;, pbuf);</a>
<a name="ln624">        }</a>
<a name="ln625">      return;</a>
<a name="ln626">    }</a>
<a name="ln627"> </a>
<a name="ln628">  info = match-&gt;route_option;</a>
<a name="ln629">  assert (info);</a>
<a name="ln630"> </a>
<a name="ln631">  if (info-&gt;type != type)</a>
<a name="ln632">    {</a>
<a name="ln633">      if (IS_OSPF6_DEBUG_ASBR)</a>
<a name="ln634">        {</a>
<a name="ln635">          prefix2str (prefix, pbuf, sizeof (pbuf));</a>
<a name="ln636">          zlog_debug (&quot;Original protocol mismatch: %s&quot;, pbuf);</a>
<a name="ln637">        }</a>
<a name="ln638">      return;</a>
<a name="ln639">    }</a>
<a name="ln640"> </a>
<a name="ln641">  if (IS_OSPF6_DEBUG_ASBR)</a>
<a name="ln642">    {</a>
<a name="ln643">      prefix2str (prefix, pbuf, sizeof (pbuf));</a>
<a name="ln644">      inet_ntop (AF_INET, &amp;prefix_id.u.prefix4, ibuf, sizeof (ibuf));</a>
<a name="ln645">      zlog_debug (&quot;Withdraw %s (AS-External Id:%s)&quot;, pbuf, ibuf);</a>
<a name="ln646">    }</a>
<a name="ln647"> </a>
<a name="ln648">  lsa = ospf6_lsdb_lookup (htons (OSPF6_LSTYPE_AS_EXTERNAL),</a>
<a name="ln649">                           htonl (info-&gt;id), ospf6-&gt;router_id, ospf6-&gt;lsdb);</a>
<a name="ln650">  if (lsa)</a>
<a name="ln651">    ospf6_lsa_purge (lsa);</a>
<a name="ln652"> </a>
<a name="ln653">  /* remove binding in external_id_table */</a>
<a name="ln654">  prefix_id.family = AF_INET;</a>
<a name="ln655">  prefix_id.prefixlen = 32;</a>
<a name="ln656">  prefix_id.u.prefix4.s_addr = htonl (info-&gt;id);</a>
<a name="ln657">  node = route_node_lookup (ospf6-&gt;external_id_table, &amp;prefix_id);</a>
<a name="ln658">  assert (node);</a>
<a name="ln659">  node-&gt;info = NULL;</a>
<a name="ln660">  route_unlock_node (node);</a>
<a name="ln661"> </a>
<a name="ln662">  ospf6_route_remove (match, ospf6-&gt;external_table);</a>
<a name="ln663">  XFREE (MTYPE_OSPF6_EXTERNAL_INFO, info);</a>
<a name="ln664"> </a>
<a name="ln665">  /* Router-Bit (ASBR Flag) may have to be updated */</a>
<a name="ln666">  for (ALL_LIST_ELEMENTS (ospf6-&gt;area_list, lnode, lnnode, oa))</a>
<a name="ln667">    OSPF6_ROUTER_LSA_SCHEDULE (oa);</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">DEFUN (ospf6_redistribute,</a>
<a name="ln671">       ospf6_redistribute_cmd,</a>
<a name="ln672">       &quot;redistribute &quot; QUAGGA_REDIST_STR_OSPF6D,</a>
<a name="ln673">       &quot;Redistribute\n&quot;</a>
<a name="ln674">       QUAGGA_REDIST_HELP_STR_OSPF6D</a>
<a name="ln675">      )</a>
<a name="ln676">{</a>
<a name="ln677">  int type;</a>
<a name="ln678"> </a>
<a name="ln679">  type = proto_redistnum(AFI_IP6, argv[0]);</a>
<a name="ln680">  if (type &lt; 0 || type == ZEBRA_ROUTE_OSPF6)</a>
<a name="ln681">    return CMD_WARNING;</a>
<a name="ln682"> </a>
<a name="ln683">  ospf6_asbr_redistribute_unset (type);</a>
<a name="ln684">  ospf6_asbr_redistribute_set (type);</a>
<a name="ln685">  return CMD_SUCCESS;</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">DEFUN (ospf6_redistribute_routemap,</a>
<a name="ln689">       ospf6_redistribute_routemap_cmd,</a>
<a name="ln690">       &quot;redistribute &quot; QUAGGA_REDIST_STR_OSPF6D &quot; route-map WORD&quot;,</a>
<a name="ln691">       &quot;Redistribute\n&quot;</a>
<a name="ln692">       QUAGGA_REDIST_HELP_STR_OSPF6D</a>
<a name="ln693">       &quot;Route map reference\n&quot;</a>
<a name="ln694">       &quot;Route map name\n&quot;</a>
<a name="ln695">      )</a>
<a name="ln696">{</a>
<a name="ln697">  int type;</a>
<a name="ln698"> </a>
<a name="ln699">  type = proto_redistnum(AFI_IP6, argv[0]);</a>
<a name="ln700">  if (type &lt; 0 || type == ZEBRA_ROUTE_OSPF6)</a>
<a name="ln701">    return CMD_WARNING;</a>
<a name="ln702"> </a>
<a name="ln703">  ospf6_asbr_redistribute_unset (type);</a>
<a name="ln704">  ospf6_asbr_routemap_set (type, argv[1]);</a>
<a name="ln705">  ospf6_asbr_redistribute_set (type);</a>
<a name="ln706">  return CMD_SUCCESS;</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">DEFUN (no_ospf6_redistribute,</a>
<a name="ln710">       no_ospf6_redistribute_cmd,</a>
<a name="ln711">       &quot;no redistribute &quot; QUAGGA_REDIST_STR_OSPF6D,</a>
<a name="ln712">       NO_STR</a>
<a name="ln713">       &quot;Redistribute\n&quot;</a>
<a name="ln714">       QUAGGA_REDIST_HELP_STR_OSPF6D</a>
<a name="ln715">      )</a>
<a name="ln716">{</a>
<a name="ln717">  int type;</a>
<a name="ln718"> </a>
<a name="ln719">  type = proto_redistnum(AFI_IP6, argv[0]);</a>
<a name="ln720">  if (type &lt; 0 || type == ZEBRA_ROUTE_OSPF6)</a>
<a name="ln721">    return CMD_WARNING;</a>
<a name="ln722"> </a>
<a name="ln723">  ospf6_asbr_redistribute_unset (type);</a>
<a name="ln724"> </a>
<a name="ln725">  return CMD_SUCCESS;</a>
<a name="ln726">}</a>
<a name="ln727"> </a>
<a name="ln728">ALIAS (no_ospf6_redistribute,</a>
<a name="ln729">       no_ospf6_redistribute_route_map_cmd,</a>
<a name="ln730">       &quot;no redistribute &quot; QUAGGA_REDIST_STR_OSPF6D &quot; route-map WORD&quot;,</a>
<a name="ln731">       NO_STR</a>
<a name="ln732">       &quot;Redistribute\n&quot;</a>
<a name="ln733">       QUAGGA_REDIST_HELP_STR_OSPF6D</a>
<a name="ln734">       &quot;Route map reference\n&quot;</a>
<a name="ln735">       &quot;Route map name\n&quot;)</a>
<a name="ln736"> </a>
<a name="ln737">int</a>
<a name="ln738">ospf6_redistribute_config_write (struct vty *vty)</a>
<a name="ln739">{</a>
<a name="ln740">  int type;</a>
<a name="ln741"> </a>
<a name="ln742">  for (type = 0; type &lt; ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln743">    {</a>
<a name="ln744">      if (type == ZEBRA_ROUTE_OSPF6)</a>
<a name="ln745">        continue;</a>
<a name="ln746">      if (! ospf6_zebra_is_redistribute (type))</a>
<a name="ln747">        continue;</a>
<a name="ln748"> </a>
<a name="ln749">      if (ospf6-&gt;rmap[type].name)</a>
<a name="ln750">        vty_out (vty, &quot; redistribute %s route-map %s%s&quot;,</a>
<a name="ln751">                 ZROUTE_NAME (type), ospf6-&gt;rmap[type].name, VNL);</a>
<a name="ln752">      else</a>
<a name="ln753">        vty_out (vty, &quot; redistribute %s%s&quot;,</a>
<a name="ln754">                 ZROUTE_NAME (type), VNL);</a>
<a name="ln755">    }</a>
<a name="ln756"> </a>
<a name="ln757">  return 0;</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">static void</a>
<a name="ln761">ospf6_redistribute_show_config (struct vty *vty)</a>
<a name="ln762">{</a>
<a name="ln763">  int type;</a>
<a name="ln764">  int nroute[ZEBRA_ROUTE_MAX];</a>
<a name="ln765">  int total;</a>
<a name="ln766">  struct ospf6_route *route;</a>
<a name="ln767">  struct ospf6_external_info *info;</a>
<a name="ln768"> </a>
<a name="ln769">  total = 0;</a>
<a name="ln770">  for (type = 0; type &lt; ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln771">    nroute[type] = 0;</a>
<a name="ln772">  for (route = ospf6_route_head (ospf6-&gt;external_table); route;</a>
<a name="ln773">       route = ospf6_route_next (route))</a>
<a name="ln774">    {</a>
<a name="ln775">      info = route-&gt;route_option;</a>
<a name="ln776">      nroute[info-&gt;type]++;</a>
<a name="ln777">      total++;</a>
<a name="ln778">    }</a>
<a name="ln779"> </a>
<a name="ln780">  vty_out (vty, &quot;Redistributing External Routes from:%s&quot;, VNL);</a>
<a name="ln781">  for (type = 0; type &lt; ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln782">    {</a>
<a name="ln783">      if (type == ZEBRA_ROUTE_OSPF6)</a>
<a name="ln784">        continue;</a>
<a name="ln785">      if (! ospf6_zebra_is_redistribute (type))</a>
<a name="ln786">        continue;</a>
<a name="ln787"> </a>
<a name="ln788">      if (ospf6-&gt;rmap[type].name)</a>
<a name="ln789">        vty_out (vty, &quot;    %d: %s with route-map \&quot;%s\&quot;%s%s&quot;, nroute[type],</a>
<a name="ln790">                 ZROUTE_NAME (type), ospf6-&gt;rmap[type].name,</a>
<a name="ln791">                 (ospf6-&gt;rmap[type].map ? &quot;&quot; : &quot; (not found !)&quot;),</a>
<a name="ln792">                 VNL);</a>
<a name="ln793">      else</a>
<a name="ln794">        vty_out (vty, &quot;    %d: %s%s&quot;, nroute[type],</a>
<a name="ln795">                 ZROUTE_NAME (type), VNL);</a>
<a name="ln796">    }</a>
<a name="ln797">  vty_out (vty, &quot;Total %d routes%s&quot;, total, VNL);</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800"> </a>
<a name="ln801"> </a>
<a name="ln802">/* Routemap Functions */</a>
<a name="ln803">static route_map_result_t</a>
<a name="ln804">ospf6_routemap_rule_match_address_prefixlist (void *rule,</a>
<a name="ln805">                                              struct prefix *prefix,</a>
<a name="ln806">                                              route_map_object_t type,</a>
<a name="ln807">                                              void *object)</a>
<a name="ln808">{</a>
<a name="ln809">  struct prefix_list *plist;</a>
<a name="ln810"> </a>
<a name="ln811">  if (type != RMAP_OSPF6)</a>
<a name="ln812">    return RMAP_NOMATCH;</a>
<a name="ln813"> </a>
<a name="ln814">  plist = prefix_list_lookup (AFI_IP6, (char *) rule);</a>
<a name="ln815">  if (plist == NULL)</a>
<a name="ln816">    return RMAP_NOMATCH;</a>
<a name="ln817"> </a>
<a name="ln818">  return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?</a>
<a name="ln819">          RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">static void *</a>
<a name="ln823">ospf6_routemap_rule_match_address_prefixlist_compile (const char *arg)</a>
<a name="ln824">{</a>
<a name="ln825">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">static void</a>
<a name="ln829">ospf6_routemap_rule_match_address_prefixlist_free (void *rule)</a>
<a name="ln830">{</a>
<a name="ln831">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">struct route_map_rule_cmd</a>
<a name="ln835">ospf6_routemap_rule_match_address_prefixlist_cmd =</a>
<a name="ln836">{</a>
<a name="ln837">  &quot;ipv6 address prefix-list&quot;,</a>
<a name="ln838">  ospf6_routemap_rule_match_address_prefixlist,</a>
<a name="ln839">  ospf6_routemap_rule_match_address_prefixlist_compile,</a>
<a name="ln840">  ospf6_routemap_rule_match_address_prefixlist_free,</a>
<a name="ln841">};</a>
<a name="ln842"> </a>
<a name="ln843">/* `match interface IFNAME' */</a>
<a name="ln844">/* Match function should return 1 if match is success else return</a>
<a name="ln845">   zero. */</a>
<a name="ln846">static route_map_result_t</a>
<a name="ln847">ospf6_routemap_rule_match_interface (void *rule, struct prefix *prefix,</a>
<a name="ln848">		       route_map_object_t type, void *object)</a>
<a name="ln849">{</a>
<a name="ln850">  struct interface   *ifp;</a>
<a name="ln851">  struct ospf6_external_info *ei;</a>
<a name="ln852"> </a>
<a name="ln853">  if (type == RMAP_OSPF6)</a>
<a name="ln854">    {</a>
<a name="ln855">      ei = ((struct ospf6_route *) object)-&gt;route_option;</a>
<a name="ln856">      ifp = if_lookup_by_name ((char *)rule);</a>
<a name="ln857"> </a>
<a name="ln858">      if (ifp != NULL</a>
<a name="ln859">      &amp;&amp;  ei-&gt;ifindex == ifp-&gt;ifindex)</a>
<a name="ln860">          return RMAP_MATCH;</a>
<a name="ln861">    }</a>
<a name="ln862"> </a>
<a name="ln863">  return RMAP_NOMATCH;</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">/* Route map `interface' match statement.  `arg' should be</a>
<a name="ln867">   interface name. */</a>
<a name="ln868">static void *</a>
<a name="ln869">ospf6_routemap_rule_match_interface_compile (const char *arg)</a>
<a name="ln870">{</a>
<a name="ln871">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">/* Free route map's compiled `interface' value. */</a>
<a name="ln875">static void</a>
<a name="ln876">ospf6_routemap_rule_match_interface_free (void *rule)</a>
<a name="ln877">{</a>
<a name="ln878">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">/* Route map commands for interface matching. */</a>
<a name="ln882">struct route_map_rule_cmd</a>
<a name="ln883">ospf6_routemap_rule_match_interface_cmd =</a>
<a name="ln884">{</a>
<a name="ln885">  &quot;interface&quot;,</a>
<a name="ln886">  ospf6_routemap_rule_match_interface,</a>
<a name="ln887">  ospf6_routemap_rule_match_interface_compile,</a>
<a name="ln888">  ospf6_routemap_rule_match_interface_free</a>
<a name="ln889">};</a>
<a name="ln890"> </a>
<a name="ln891">/* Match function for matching route tags */</a>
<a name="ln892">static route_map_result_t</a>
<a name="ln893">ospf6_routemap_rule_match_tag (void *rule, struct prefix *prefix,</a>
<a name="ln894">                               route_map_object_t type, void *object)</a>
<a name="ln895">{</a>
<a name="ln896">  route_tag_t *tag = rule;</a>
<a name="ln897">  struct ospf6_route *route = object;</a>
<a name="ln898">  struct ospf6_external_info *info = route-&gt;route_option;</a>
<a name="ln899"> </a>
<a name="ln900">  if (type == RMAP_OSPF6 &amp;&amp; info-&gt;tag == *tag)</a>
<a name="ln901">    return RMAP_MATCH;</a>
<a name="ln902"> </a>
<a name="ln903">  return RMAP_NOMATCH;</a>
<a name="ln904">}</a>
<a name="ln905"> </a>
<a name="ln906">static struct route_map_rule_cmd</a>
<a name="ln907">ospf6_routemap_rule_match_tag_cmd =</a>
<a name="ln908">{</a>
<a name="ln909">  &quot;tag&quot;,</a>
<a name="ln910">  ospf6_routemap_rule_match_tag,</a>
<a name="ln911">  route_map_rule_tag_compile,</a>
<a name="ln912">  route_map_rule_tag_free,</a>
<a name="ln913">};</a>
<a name="ln914"> </a>
<a name="ln915">static route_map_result_t</a>
<a name="ln916">ospf6_routemap_rule_set_metric_type (void *rule, struct prefix *prefix,</a>
<a name="ln917">                                     route_map_object_t type, void *object)</a>
<a name="ln918">{</a>
<a name="ln919">  char *metric_type = rule;</a>
<a name="ln920">  struct ospf6_route *route = object;</a>
<a name="ln921"> </a>
<a name="ln922">  if (type != RMAP_OSPF6)</a>
<a name="ln923">    return RMAP_OKAY;</a>
<a name="ln924"> </a>
<a name="ln925">  if (strcmp (metric_type, &quot;type-2&quot;) == 0)</a>
<a name="ln926">    route-&gt;path.metric_type = 2;</a>
<a name="ln927">  else</a>
<a name="ln928">    route-&gt;path.metric_type = 1;</a>
<a name="ln929"> </a>
<a name="ln930">  return RMAP_OKAY;</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">static void *</a>
<a name="ln934">ospf6_routemap_rule_set_metric_type_compile (const char *arg)</a>
<a name="ln935">{</a>
<a name="ln936">  if (strcmp (arg, &quot;type-2&quot;) &amp;&amp; strcmp (arg, &quot;type-1&quot;))</a>
<a name="ln937">    return NULL;</a>
<a name="ln938">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">static void</a>
<a name="ln942">ospf6_routemap_rule_set_metric_type_free (void *rule)</a>
<a name="ln943">{</a>
<a name="ln944">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">struct route_map_rule_cmd</a>
<a name="ln948">ospf6_routemap_rule_set_metric_type_cmd =</a>
<a name="ln949">{</a>
<a name="ln950">  &quot;metric-type&quot;,</a>
<a name="ln951">  ospf6_routemap_rule_set_metric_type,</a>
<a name="ln952">  ospf6_routemap_rule_set_metric_type_compile,</a>
<a name="ln953">  ospf6_routemap_rule_set_metric_type_free,</a>
<a name="ln954">};</a>
<a name="ln955"> </a>
<a name="ln956">static route_map_result_t</a>
<a name="ln957">ospf6_routemap_rule_set_metric (void *rule, struct prefix *prefix,</a>
<a name="ln958">                                route_map_object_t type, void *object)</a>
<a name="ln959">{</a>
<a name="ln960">  char *metric = rule;</a>
<a name="ln961">  struct ospf6_route *route = object;</a>
<a name="ln962"> </a>
<a name="ln963">  if (type != RMAP_OSPF6)</a>
<a name="ln964">    return RMAP_OKAY;</a>
<a name="ln965"> </a>
<a name="ln966">  route-&gt;path.cost = atoi (metric);</a>
<a name="ln967">  return RMAP_OKAY;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">static void *</a>
<a name="ln971">ospf6_routemap_rule_set_metric_compile (const char *arg)</a>
<a name="ln972">{</a>
<a name="ln973">  u_int32_t metric;</a>
<a name="ln974">  char *endp;</a>
<a name="ln975">  metric = strtoul (arg, &amp;endp, 0);</a>
<a name="ln976">  if (metric &gt; OSPF_LS_INFINITY || *endp != '\0')</a>
<a name="ln977">    return NULL;</a>
<a name="ln978">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln979">}</a>
<a name="ln980"> </a>
<a name="ln981">static void</a>
<a name="ln982">ospf6_routemap_rule_set_metric_free (void *rule)</a>
<a name="ln983">{</a>
<a name="ln984">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln985">}</a>
<a name="ln986"> </a>
<a name="ln987">struct route_map_rule_cmd</a>
<a name="ln988">ospf6_routemap_rule_set_metric_cmd =</a>
<a name="ln989">{</a>
<a name="ln990">  &quot;metric&quot;,</a>
<a name="ln991">  ospf6_routemap_rule_set_metric,</a>
<a name="ln992">  ospf6_routemap_rule_set_metric_compile,</a>
<a name="ln993">  ospf6_routemap_rule_set_metric_free,</a>
<a name="ln994">};</a>
<a name="ln995"> </a>
<a name="ln996">static route_map_result_t</a>
<a name="ln997">ospf6_routemap_rule_set_forwarding (void *rule, struct prefix *prefix,</a>
<a name="ln998">                                    route_map_object_t type, void *object)</a>
<a name="ln999">{</a>
<a name="ln1000">  char *forwarding = rule;</a>
<a name="ln1001">  struct ospf6_route *route = object;</a>
<a name="ln1002">  struct ospf6_external_info *info = route-&gt;route_option;</a>
<a name="ln1003"> </a>
<a name="ln1004">  if (type != RMAP_OSPF6)</a>
<a name="ln1005">    return RMAP_OKAY;</a>
<a name="ln1006"> </a>
<a name="ln1007">  if (inet_pton (AF_INET6, forwarding, &amp;info-&gt;forwarding) != 1)</a>
<a name="ln1008">    {</a>
<a name="ln1009">      memset (&amp;info-&gt;forwarding, 0, sizeof (struct in6_addr));</a>
<a name="ln1010">      return RMAP_ERROR;</a>
<a name="ln1011">    }</a>
<a name="ln1012"> </a>
<a name="ln1013">  return RMAP_OKAY;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">static void *</a>
<a name="ln1017">ospf6_routemap_rule_set_forwarding_compile (const char *arg)</a>
<a name="ln1018">{</a>
<a name="ln1019">  struct in6_addr a;</a>
<a name="ln1020">  if (inet_pton (AF_INET6, arg, &amp;a) != 1)</a>
<a name="ln1021">    return NULL;</a>
<a name="ln1022">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln1023">}</a>
<a name="ln1024"> </a>
<a name="ln1025">static void</a>
<a name="ln1026">ospf6_routemap_rule_set_forwarding_free (void *rule)</a>
<a name="ln1027">{</a>
<a name="ln1028">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">struct route_map_rule_cmd</a>
<a name="ln1032">ospf6_routemap_rule_set_forwarding_cmd =</a>
<a name="ln1033">{</a>
<a name="ln1034">  &quot;forwarding-address&quot;,</a>
<a name="ln1035">  ospf6_routemap_rule_set_forwarding,</a>
<a name="ln1036">  ospf6_routemap_rule_set_forwarding_compile,</a>
<a name="ln1037">  ospf6_routemap_rule_set_forwarding_free,</a>
<a name="ln1038">};</a>
<a name="ln1039"> </a>
<a name="ln1040">static route_map_result_t</a>
<a name="ln1041">ospf6_routemap_rule_set_tag (void *rule, struct prefix *prefix,</a>
<a name="ln1042">                             route_map_object_t type, void *object)</a>
<a name="ln1043">{</a>
<a name="ln1044">  route_tag_t *tag = rule;</a>
<a name="ln1045">  struct ospf6_route *route = object;</a>
<a name="ln1046">  struct ospf6_external_info *info = route-&gt;route_option;</a>
<a name="ln1047"> </a>
<a name="ln1048">  if (type != RMAP_OSPF6)</a>
<a name="ln1049">    return RMAP_OKAY;</a>
<a name="ln1050"> </a>
<a name="ln1051">  info-&gt;tag = *tag;</a>
<a name="ln1052">  return RMAP_OKAY;</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">static struct route_map_rule_cmd</a>
<a name="ln1056">ospf6_routemap_rule_set_tag_cmd =</a>
<a name="ln1057">{</a>
<a name="ln1058">  &quot;tag&quot;,</a>
<a name="ln1059">  ospf6_routemap_rule_set_tag,</a>
<a name="ln1060">  route_map_rule_tag_compile,</a>
<a name="ln1061">  route_map_rule_tag_free,</a>
<a name="ln1062">};</a>
<a name="ln1063"> </a>
<a name="ln1064">static int</a>
<a name="ln1065">route_map_command_status (struct vty *vty, int ret)</a>
<a name="ln1066">{</a>
<a name="ln1067">  if (! ret)</a>
<a name="ln1068">    return CMD_SUCCESS;</a>
<a name="ln1069"> </a>
<a name="ln1070">  switch (ret)</a>
<a name="ln1071">    {</a>
<a name="ln1072">    case RMAP_RULE_MISSING:</a>
<a name="ln1073">      vty_out (vty, &quot;OSPF6 Can't find rule.%s&quot;, VNL);</a>
<a name="ln1074">      break;</a>
<a name="ln1075">    case RMAP_COMPILE_ERROR:</a>
<a name="ln1076">      vty_out (vty, &quot;OSPF6 Argument is malformed.%s&quot;, VNL);</a>
<a name="ln1077">      break;</a>
<a name="ln1078">    default:</a>
<a name="ln1079">      vty_out (vty, &quot;OSPF6 route-map add set failed.%s&quot;, VNL);</a>
<a name="ln1080">      break;</a>
<a name="ln1081">    }</a>
<a name="ln1082">  return CMD_WARNING;</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">/* add &quot;match address&quot; */</a>
<a name="ln1086">DEFUN (ospf6_routemap_match_address_prefixlist,</a>
<a name="ln1087">       ospf6_routemap_match_address_prefixlist_cmd,</a>
<a name="ln1088">       &quot;match ipv6 address prefix-list WORD&quot;,</a>
<a name="ln1089">       &quot;Match values\n&quot;</a>
<a name="ln1090">       IPV6_STR</a>
<a name="ln1091">       &quot;Match address of route\n&quot;</a>
<a name="ln1092">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln1093">       &quot;IPv6 prefix-list name\n&quot;)</a>
<a name="ln1094">{</a>
<a name="ln1095">  int ret = route_map_add_match ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1096">                                 &quot;ipv6 address prefix-list&quot;, argv[0]);</a>
<a name="ln1097">  return route_map_command_status (vty, ret);</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">/* delete &quot;match address&quot; */</a>
<a name="ln1101">DEFUN (ospf6_routemap_no_match_address_prefixlist,</a>
<a name="ln1102">       ospf6_routemap_no_match_address_prefixlist_cmd,</a>
<a name="ln1103">       &quot;no match ipv6 address prefix-list WORD&quot;,</a>
<a name="ln1104">       NO_STR</a>
<a name="ln1105">       &quot;Match values\n&quot;</a>
<a name="ln1106">       IPV6_STR</a>
<a name="ln1107">       &quot;Match address of route\n&quot;</a>
<a name="ln1108">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln1109">       &quot;IPv6 prefix-list name\n&quot;)</a>
<a name="ln1110">{</a>
<a name="ln1111">  int ret = route_map_delete_match ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1112">                                    &quot;ipv6 address prefix-list&quot;, argv[0]);</a>
<a name="ln1113">  return route_map_command_status (vty, ret);</a>
<a name="ln1114">}</a>
<a name="ln1115"> </a>
<a name="ln1116">/* &quot;match interface&quot; */</a>
<a name="ln1117">DEFUN (ospf6_routemap_match_interface,</a>
<a name="ln1118">       ospf6_routemap_match_interface_cmd,</a>
<a name="ln1119">       &quot;match interface WORD&quot;,</a>
<a name="ln1120">       MATCH_STR</a>
<a name="ln1121">       &quot;Match first hop interface of route\n&quot;</a>
<a name="ln1122">       &quot;Interface name\n&quot;)</a>
<a name="ln1123">{</a>
<a name="ln1124">  return route_map_add_match ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1125">                              &quot;interface&quot;, argv[0]);</a>
<a name="ln1126">}</a>
<a name="ln1127"> </a>
<a name="ln1128">/* &quot;no match interface WORD&quot; */</a>
<a name="ln1129">DEFUN (ospf6_routemap_no_match_interface,</a>
<a name="ln1130">       ospf6_routemap_no_match_interface_cmd,</a>
<a name="ln1131">       &quot;no match interface&quot;,</a>
<a name="ln1132">       NO_STR</a>
<a name="ln1133">       MATCH_STR</a>
<a name="ln1134">       &quot;Match first hop interface of route\n&quot;)</a>
<a name="ln1135">{</a>
<a name="ln1136">  int ret = route_map_delete_match ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1137">                                    &quot;interface&quot;, (argc == 0) ? NULL : argv[0]);</a>
<a name="ln1138">  return route_map_command_status (vty, ret);</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">ALIAS (ospf6_routemap_no_match_interface,</a>
<a name="ln1142">       ospf6_routemap_no_match_interface_val_cmd,</a>
<a name="ln1143">       &quot;no match interface WORD&quot;,</a>
<a name="ln1144">       NO_STR</a>
<a name="ln1145">       MATCH_STR</a>
<a name="ln1146">       &quot;Match first hop interface of route\n&quot;</a>
<a name="ln1147">       &quot;Interface name\n&quot;)</a>
<a name="ln1148"> </a>
<a name="ln1149">/* add &quot;match tag&quot; */</a>
<a name="ln1150">DEFUN (ospf6_routemap_match_tag,</a>
<a name="ln1151">       ospf6_routemap_match_tag_cmd,</a>
<a name="ln1152">       &quot;match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln1153">       MATCH_STR</a>
<a name="ln1154">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln1155">       &quot;Tag value\n&quot;)</a>
<a name="ln1156">{</a>
<a name="ln1157">  int ret = route_map_add_match ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1158">                               &quot;tag&quot;, argv[0]);</a>
<a name="ln1159">  return route_map_command_status (vty, ret);</a>
<a name="ln1160">}</a>
<a name="ln1161"> </a>
<a name="ln1162">/* delete &quot;match tag&quot; */</a>
<a name="ln1163">DEFUN (ospf6_routemap_no_match_tag,</a>
<a name="ln1164">       ospf6_routemap_no_match_tag_cmd,</a>
<a name="ln1165">       &quot;no match tag&quot;,</a>
<a name="ln1166">       NO_STR</a>
<a name="ln1167">       MATCH_STR</a>
<a name="ln1168">       &quot;Tag value for routing protocol\n&quot;)</a>
<a name="ln1169">{</a>
<a name="ln1170">  int ret = route_map_delete_match ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1171">                                  &quot;tag&quot;, argc ? argv[0] : NULL);</a>
<a name="ln1172">  return route_map_command_status (vty, ret);</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">ALIAS (ospf6_routemap_no_match_tag,</a>
<a name="ln1176">       ospf6_routemap_no_match_tag_val_cmd,</a>
<a name="ln1177">       &quot;no match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln1178">       NO_STR</a>
<a name="ln1179">       MATCH_STR</a>
<a name="ln1180">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln1181">       &quot;Tag value\n&quot;)</a>
<a name="ln1182"> </a>
<a name="ln1183">/* add &quot;set metric-type&quot; */</a>
<a name="ln1184">DEFUN (ospf6_routemap_set_metric_type,</a>
<a name="ln1185">       ospf6_routemap_set_metric_type_cmd,</a>
<a name="ln1186">       &quot;set metric-type (type-1|type-2)&quot;,</a>
<a name="ln1187">       &quot;Set value\n&quot;</a>
<a name="ln1188">       &quot;Type of metric\n&quot;</a>
<a name="ln1189">       &quot;OSPF6 external type 1 metric\n&quot;</a>
<a name="ln1190">       &quot;OSPF6 external type 2 metric\n&quot;)</a>
<a name="ln1191">{</a>
<a name="ln1192">  int ret = route_map_add_set ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1193">                               &quot;metric-type&quot;, argv[0]);</a>
<a name="ln1194">  return route_map_command_status (vty, ret);</a>
<a name="ln1195">}</a>
<a name="ln1196"> </a>
<a name="ln1197">/* delete &quot;set metric-type&quot; */</a>
<a name="ln1198">DEFUN (ospf6_routemap_no_set_metric_type,</a>
<a name="ln1199">       ospf6_routemap_no_set_metric_type_cmd,</a>
<a name="ln1200">       &quot;no set metric-type (type-1|type-2)&quot;,</a>
<a name="ln1201">       NO_STR</a>
<a name="ln1202">       &quot;Set value\n&quot;</a>
<a name="ln1203">       &quot;Type of metric\n&quot;</a>
<a name="ln1204">       &quot;OSPF6 external type 1 metric\n&quot;</a>
<a name="ln1205">       &quot;OSPF6 external type 2 metric\n&quot;)</a>
<a name="ln1206">{</a>
<a name="ln1207">  int ret = route_map_delete_set ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1208">                                  &quot;metric-type&quot;, argv[0]);</a>
<a name="ln1209">  return route_map_command_status (vty, ret);</a>
<a name="ln1210">}</a>
<a name="ln1211"> </a>
<a name="ln1212">/* add &quot;set metric&quot; */</a>
<a name="ln1213">DEFUN (set_metric,</a>
<a name="ln1214">       set_metric_cmd,</a>
<a name="ln1215">       &quot;set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln1216">       &quot;Set value\n&quot;</a>
<a name="ln1217">       &quot;Metric value\n&quot;</a>
<a name="ln1218">       &quot;Metric value\n&quot;)</a>
<a name="ln1219">{</a>
<a name="ln1220">  int ret = route_map_add_set ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1221">                               &quot;metric&quot;, argv[0]);</a>
<a name="ln1222">  return route_map_command_status (vty, ret);</a>
<a name="ln1223">}</a>
<a name="ln1224"> </a>
<a name="ln1225">/* delete &quot;set metric&quot; */</a>
<a name="ln1226">DEFUN (no_set_metric,</a>
<a name="ln1227">       no_set_metric_cmd,</a>
<a name="ln1228">       &quot;no set metric&quot;,</a>
<a name="ln1229">       NO_STR</a>
<a name="ln1230">       SET_STR</a>
<a name="ln1231">       &quot;Metric value for destination routing protocol\n&quot;)</a>
<a name="ln1232">{</a>
<a name="ln1233">  int ret = 0;</a>
<a name="ln1234"> </a>
<a name="ln1235">  if (argc == 0)</a>
<a name="ln1236">    ret = route_map_delete_set ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1237">                                &quot;metric&quot;, NULL);</a>
<a name="ln1238">  else</a>
<a name="ln1239">    ret = route_map_delete_set ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1240">                                &quot;metric&quot;, argv[0]);</a>
<a name="ln1241">  return route_map_command_status (vty, ret);</a>
<a name="ln1242">}</a>
<a name="ln1243"> </a>
<a name="ln1244">ALIAS (no_set_metric,</a>
<a name="ln1245">       no_set_metric_val_cmd,</a>
<a name="ln1246">       &quot;no set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln1247">       NO_STR</a>
<a name="ln1248">       SET_STR</a>
<a name="ln1249">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln1250">       &quot;Metric value\n&quot;)</a>
<a name="ln1251"> </a>
<a name="ln1252">/* add &quot;set forwarding-address&quot; */</a>
<a name="ln1253">DEFUN (ospf6_routemap_set_forwarding,</a>
<a name="ln1254">       ospf6_routemap_set_forwarding_cmd,</a>
<a name="ln1255">       &quot;set forwarding-address X:X::X:X&quot;,</a>
<a name="ln1256">       &quot;Set value\n&quot;</a>
<a name="ln1257">       &quot;Forwarding Address\n&quot;</a>
<a name="ln1258">       &quot;IPv6 Address\n&quot;)</a>
<a name="ln1259">{</a>
<a name="ln1260">  int ret = route_map_add_set ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1261">                               &quot;forwarding-address&quot;, argv[0]);</a>
<a name="ln1262">  return route_map_command_status (vty, ret);</a>
<a name="ln1263">}</a>
<a name="ln1264"> </a>
<a name="ln1265">/* delete &quot;set forwarding-address&quot; */</a>
<a name="ln1266">DEFUN (ospf6_routemap_no_set_forwarding,</a>
<a name="ln1267">       ospf6_routemap_no_set_forwarding_cmd,</a>
<a name="ln1268">       &quot;no set forwarding-address X:X::X:X&quot;,</a>
<a name="ln1269">       NO_STR</a>
<a name="ln1270">       &quot;Set value\n&quot;</a>
<a name="ln1271">       &quot;Forwarding Address\n&quot;</a>
<a name="ln1272">       &quot;IPv6 Address\n&quot;)</a>
<a name="ln1273">{</a>
<a name="ln1274">  int ret = route_map_delete_set ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1275">                                  &quot;forwarding-address&quot;, argv[0]);</a>
<a name="ln1276">  return route_map_command_status (vty, ret);</a>
<a name="ln1277">}</a>
<a name="ln1278"> </a>
<a name="ln1279">/* add &quot;set tag&quot; */</a>
<a name="ln1280">DEFUN (ospf6_routemap_set_tag,</a>
<a name="ln1281">       ospf6_routemap_set_tag_cmd,</a>
<a name="ln1282">       &quot;set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln1283">       &quot;Set value\n&quot;</a>
<a name="ln1284">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln1285">       &quot;Tag value\n&quot;)</a>
<a name="ln1286">{</a>
<a name="ln1287">  int ret = route_map_add_set ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1288">                               &quot;tag&quot;, argv[0]);</a>
<a name="ln1289">  return route_map_command_status (vty, ret);</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292">/* delete &quot;set tag&quot; */</a>
<a name="ln1293">DEFUN (ospf6_routemap_no_set_tag,</a>
<a name="ln1294">       ospf6_routemap_no_set_tag_cmd,</a>
<a name="ln1295">       &quot;no set tag&quot;,</a>
<a name="ln1296">       NO_STR</a>
<a name="ln1297">       &quot;Set value\n&quot;</a>
<a name="ln1298">       &quot;Tag value for routing protocol\n&quot;)</a>
<a name="ln1299">{</a>
<a name="ln1300">  int ret = route_map_delete_set ((struct route_map_index *) vty-&gt;index,</a>
<a name="ln1301">                                  &quot;tag&quot;, argc ? argv[0] : NULL);</a>
<a name="ln1302">  return route_map_command_status (vty, ret);</a>
<a name="ln1303">}</a>
<a name="ln1304"> </a>
<a name="ln1305">ALIAS (ospf6_routemap_no_set_tag,</a>
<a name="ln1306">       ospf6_routemap_no_set_tag_val_cmd,</a>
<a name="ln1307">       &quot;no set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln1308">       NO_STR</a>
<a name="ln1309">       &quot;Set value\n&quot;</a>
<a name="ln1310">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln1311">       &quot;Tag value\n&quot;)</a>
<a name="ln1312"> </a>
<a name="ln1313">static void</a>
<a name="ln1314">ospf6_routemap_init (void)</a>
<a name="ln1315">{</a>
<a name="ln1316">  route_map_init ();</a>
<a name="ln1317">  route_map_init_vty ();</a>
<a name="ln1318">  route_map_add_hook (ospf6_asbr_routemap_update);</a>
<a name="ln1319">  route_map_delete_hook (ospf6_asbr_routemap_update);</a>
<a name="ln1320"> </a>
<a name="ln1321">  route_map_install_match (&amp;ospf6_routemap_rule_match_address_prefixlist_cmd);</a>
<a name="ln1322">  route_map_install_match (&amp;ospf6_routemap_rule_match_interface_cmd);</a>
<a name="ln1323">  route_map_install_match (&amp;ospf6_routemap_rule_match_tag_cmd);</a>
<a name="ln1324"> </a>
<a name="ln1325">  route_map_install_set (&amp;ospf6_routemap_rule_set_metric_type_cmd);</a>
<a name="ln1326">  route_map_install_set (&amp;ospf6_routemap_rule_set_metric_cmd);</a>
<a name="ln1327">  route_map_install_set (&amp;ospf6_routemap_rule_set_forwarding_cmd);</a>
<a name="ln1328">  route_map_install_set (&amp;ospf6_routemap_rule_set_tag_cmd);</a>
<a name="ln1329"> </a>
<a name="ln1330">  /* Match address prefix-list */</a>
<a name="ln1331">  install_element (RMAP_NODE, &amp;ospf6_routemap_match_address_prefixlist_cmd);</a>
<a name="ln1332">  install_element (RMAP_NODE, &amp;ospf6_routemap_no_match_address_prefixlist_cmd);</a>
<a name="ln1333"> </a>
<a name="ln1334">  /* Match interface */</a>
<a name="ln1335">  install_element (RMAP_NODE, &amp;ospf6_routemap_match_interface_cmd);</a>
<a name="ln1336">  install_element (RMAP_NODE, &amp;ospf6_routemap_no_match_interface_cmd);</a>
<a name="ln1337">  install_element (RMAP_NODE, &amp;ospf6_routemap_no_match_interface_val_cmd);</a>
<a name="ln1338"> </a>
<a name="ln1339">  /* Match tag */</a>
<a name="ln1340">  install_element (RMAP_NODE, &amp;ospf6_routemap_match_tag_cmd);</a>
<a name="ln1341">  install_element (RMAP_NODE, &amp;ospf6_routemap_no_match_tag_cmd);</a>
<a name="ln1342">  install_element (RMAP_NODE, &amp;ospf6_routemap_no_match_tag_val_cmd);</a>
<a name="ln1343"> </a>
<a name="ln1344">  /* ASE Metric Type (e.g. Type-1/Type-2) */</a>
<a name="ln1345">  install_element (RMAP_NODE, &amp;ospf6_routemap_set_metric_type_cmd);</a>
<a name="ln1346">  install_element (RMAP_NODE, &amp;ospf6_routemap_no_set_metric_type_cmd);</a>
<a name="ln1347"> </a>
<a name="ln1348">  /* ASE Metric */</a>
<a name="ln1349">  install_element (RMAP_NODE, &amp;set_metric_cmd);</a>
<a name="ln1350">  install_element (RMAP_NODE, &amp;no_set_metric_cmd);</a>
<a name="ln1351">  install_element (RMAP_NODE, &amp;no_set_metric_val_cmd);</a>
<a name="ln1352"> </a>
<a name="ln1353">  /* Forwarding address */</a>
<a name="ln1354">  install_element (RMAP_NODE, &amp;ospf6_routemap_set_forwarding_cmd);</a>
<a name="ln1355">  install_element (RMAP_NODE, &amp;ospf6_routemap_no_set_forwarding_cmd);</a>
<a name="ln1356"> </a>
<a name="ln1357">  /* Tag */</a>
<a name="ln1358">  install_element (RMAP_NODE, &amp;ospf6_routemap_set_tag_cmd);</a>
<a name="ln1359">  install_element (RMAP_NODE, &amp;ospf6_routemap_no_set_tag_cmd);</a>
<a name="ln1360">  install_element (RMAP_NODE, &amp;ospf6_routemap_no_set_tag_val_cmd);</a>
<a name="ln1361">}</a>
<a name="ln1362"> </a>
<a name="ln1363"> </a>
<a name="ln1364">/* Display functions */</a>
<a name="ln1365">static char *</a>
<a name="ln1366">ospf6_as_external_lsa_get_prefix_str (struct ospf6_lsa *lsa, char *buf,</a>
<a name="ln1367">				      int buflen, int pos)</a>
<a name="ln1368">{</a>
<a name="ln1369">  struct ospf6_as_external_lsa *external;</a>
<a name="ln1370">  struct in6_addr in6;</a>
<a name="ln1371">  int prefix_length = 0;</a>
<a name="ln1372"> </a>
<a name="ln1373">  if (lsa)</a>
<a name="ln1374">    {</a>
<a name="ln1375">        external = (struct ospf6_as_external_lsa *)</a>
<a name="ln1376">	  OSPF6_LSA_HEADER_END (lsa-&gt;header);</a>
<a name="ln1377"> </a>
<a name="ln1378">	if (pos == 0)</a>
<a name="ln1379">	  {</a>
<a name="ln1380">	    ospf6_prefix_in6_addr (&amp;in6, &amp;external-&gt;prefix);</a>
<a name="ln1381">	    prefix_length = external-&gt;prefix.prefix_length;</a>
<a name="ln1382">	  }</a>
<a name="ln1383">	else {</a>
<a name="ln1384">	  in6 = *((struct in6_addr *)</a>
<a name="ln1385">		  ((caddr_t) external + sizeof (struct ospf6_as_external_lsa) +</a>
<a name="ln1386">		   OSPF6_PREFIX_SPACE (external-&gt;prefix.prefix_length)));</a>
<a name="ln1387">	}</a>
<a name="ln1388">	if (buf)</a>
<a name="ln1389">	  {</a>
<a name="ln1390">	    inet_ntop (AF_INET6, &amp;in6, buf, buflen);</a>
<a name="ln1391">	    if (prefix_length)</a>
<a name="ln1392">	      sprintf (&amp;buf[strlen(buf)], &quot;/%d&quot;, prefix_length);</a>
<a name="ln1393">	  }</a>
<a name="ln1394">    }</a>
<a name="ln1395">  return (buf);</a>
<a name="ln1396">}</a>
<a name="ln1397"> </a>
<a name="ln1398">static int</a>
<a name="ln1399">ospf6_as_external_lsa_show (struct vty *vty, struct ospf6_lsa *lsa)</a>
<a name="ln1400">{</a>
<a name="ln1401">  struct ospf6_as_external_lsa *external;</a>
<a name="ln1402">  char buf[64];</a>
<a name="ln1403"> </a>
<a name="ln1404">  assert (lsa-&gt;header);</a>
<a name="ln1405">  external = (struct ospf6_as_external_lsa *)</a>
<a name="ln1406">    OSPF6_LSA_HEADER_END (lsa-&gt;header);</a>
<a name="ln1407">  </a>
<a name="ln1408">  /* bits */</a>
<a name="ln1409">  snprintf (buf, sizeof (buf), &quot;%c%c%c&quot;,</a>
<a name="ln1410">    (CHECK_FLAG (external-&gt;bits_metric, OSPF6_ASBR_BIT_E) ? 'E' : '-'),</a>
<a name="ln1411">    (CHECK_FLAG (external-&gt;bits_metric, OSPF6_ASBR_BIT_F) ? 'F' : '-'),</a>
<a name="ln1412">    (CHECK_FLAG (external-&gt;bits_metric, OSPF6_ASBR_BIT_T) ? 'T' : '-'));</a>
<a name="ln1413"> </a>
<a name="ln1414">  vty_out (vty, &quot;     Bits: %s%s&quot;, buf, VNL);</a>
<a name="ln1415">  vty_out (vty, &quot;     Metric: %5lu%s&quot;, (u_long) OSPF6_ASBR_METRIC (external),</a>
<a name="ln1416">           VNL);</a>
<a name="ln1417"> </a>
<a name="ln1418">  ospf6_prefix_options_printbuf (external-&gt;prefix.prefix_options,</a>
<a name="ln1419">                                 buf, sizeof (buf));</a>
<a name="ln1420">  vty_out (vty, &quot;     Prefix Options: %s%s&quot;, buf,</a>
<a name="ln1421">           VNL);</a>
<a name="ln1422"> </a>
<a name="ln1423">  vty_out (vty, &quot;     Referenced LSType: %d%s&quot;,</a>
<a name="ln1424">           ntohs (external-&gt;prefix.prefix_refer_lstype),</a>
<a name="ln1425">           VNL);</a>
<a name="ln1426"> </a>
<a name="ln1427">  vty_out (vty, &quot;     Prefix: %s%s&quot;,</a>
<a name="ln1428">	   ospf6_as_external_lsa_get_prefix_str (lsa, buf, sizeof(buf), 0), VNL);</a>
<a name="ln1429"> </a>
<a name="ln1430">  /* Forwarding-Address */</a>
<a name="ln1431">  if (CHECK_FLAG (external-&gt;bits_metric, OSPF6_ASBR_BIT_F))</a>
<a name="ln1432">    {</a>
<a name="ln1433">      vty_out (vty, &quot;     Forwarding-Address: %s%s&quot;,</a>
<a name="ln1434">	       ospf6_as_external_lsa_get_prefix_str (lsa, buf, sizeof(buf), 1),</a>
<a name="ln1435">	       VNL);</a>
<a name="ln1436">    }</a>
<a name="ln1437"> </a>
<a name="ln1438">  /* Tag */</a>
<a name="ln1439">  if (CHECK_FLAG (external-&gt;bits_metric, OSPF6_ASBR_BIT_T))</a>
<a name="ln1440">    {</a>
<a name="ln1441">      vty_out (vty, &quot;     Tag: %u%s&quot;,</a>
<a name="ln1442">               ospf6_as_external_lsa_get_tag (lsa), VNL);</a>
<a name="ln1443">    }</a>
<a name="ln1444"> </a>
<a name="ln1445">  return 0;</a>
<a name="ln1446">}</a>
<a name="ln1447"> </a>
<a name="ln1448">static void</a>
<a name="ln1449">ospf6_asbr_external_route_show (struct vty *vty, struct ospf6_route *route)</a>
<a name="ln1450">{</a>
<a name="ln1451">  struct ospf6_external_info *info = route-&gt;route_option;</a>
<a name="ln1452">  char prefix[64], id[16], forwarding[64];</a>
<a name="ln1453">  u_int32_t tmp_id;</a>
<a name="ln1454"> </a>
<a name="ln1455">  prefix2str (&amp;route-&gt;prefix, prefix, sizeof (prefix));</a>
<a name="ln1456">  tmp_id = ntohl (info-&gt;id);</a>
<a name="ln1457">  inet_ntop (AF_INET, &amp;tmp_id, id, sizeof (id));</a>
<a name="ln1458">  if (! IN6_IS_ADDR_UNSPECIFIED (&amp;info-&gt;forwarding))</a>
<a name="ln1459">    inet_ntop (AF_INET6, &amp;info-&gt;forwarding, forwarding, sizeof (forwarding));</a>
<a name="ln1460">  else</a>
<a name="ln1461">    snprintf (forwarding, sizeof (forwarding), &quot;:: (ifindex %d)&quot;,</a>
<a name="ln1462">              route-&gt;nexthop[0].ifindex);</a>
<a name="ln1463"> </a>
<a name="ln1464">  vty_out (vty, &quot;%c %-32s %-15s type-%d %5lu %s%s&quot;,</a>
<a name="ln1465">           zebra_route_char(info-&gt;type),</a>
<a name="ln1466">           prefix, id, route-&gt;path.metric_type,</a>
<a name="ln1467">           (u_long) (route-&gt;path.metric_type == 2 ?</a>
<a name="ln1468">                     route-&gt;path.cost_e2 : route-&gt;path.cost),</a>
<a name="ln1469">           forwarding, VNL);</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472">DEFUN (show_ipv6_ospf6_redistribute,</a>
<a name="ln1473">       show_ipv6_ospf6_redistribute_cmd,</a>
<a name="ln1474">       &quot;show ipv6 ospf6 redistribute&quot;,</a>
<a name="ln1475">       SHOW_STR</a>
<a name="ln1476">       IP6_STR</a>
<a name="ln1477">       OSPF6_STR</a>
<a name="ln1478">       &quot;redistributing External information\n&quot;</a>
<a name="ln1479">       )</a>
<a name="ln1480">{</a>
<a name="ln1481">  struct ospf6_route *route;</a>
<a name="ln1482"> </a>
<a name="ln1483">  OSPF6_CMD_CHECK_RUNNING ();</a>
<a name="ln1484"> </a>
<a name="ln1485">  ospf6_redistribute_show_config (vty);</a>
<a name="ln1486"> </a>
<a name="ln1487">  for (route = ospf6_route_head (ospf6-&gt;external_table); route;</a>
<a name="ln1488">       route = ospf6_route_next (route))</a>
<a name="ln1489">    ospf6_asbr_external_route_show (vty, route);</a>
<a name="ln1490"> </a>
<a name="ln1491">  return CMD_SUCCESS;</a>
<a name="ln1492">}</a>
<a name="ln1493"> </a>
<a name="ln1494">struct ospf6_lsa_handler as_external_handler =</a>
<a name="ln1495">{</a>
<a name="ln1496">  OSPF6_LSTYPE_AS_EXTERNAL,</a>
<a name="ln1497">  &quot;AS-External&quot;,</a>
<a name="ln1498">  &quot;ASE&quot;,</a>
<a name="ln1499">  ospf6_as_external_lsa_show,</a>
<a name="ln1500">  ospf6_as_external_lsa_get_prefix_str</a>
<a name="ln1501">};</a>
<a name="ln1502"> </a>
<a name="ln1503">void</a>
<a name="ln1504">ospf6_asbr_init (void)</a>
<a name="ln1505">{</a>
<a name="ln1506">  ospf6_routemap_init ();</a>
<a name="ln1507"> </a>
<a name="ln1508">  ospf6_install_lsa_handler (&amp;as_external_handler);</a>
<a name="ln1509"> </a>
<a name="ln1510">  install_element (VIEW_NODE, &amp;show_ipv6_ospf6_redistribute_cmd);</a>
<a name="ln1511"> </a>
<a name="ln1512">  install_element (OSPF6_NODE, &amp;ospf6_redistribute_cmd);</a>
<a name="ln1513">  install_element (OSPF6_NODE, &amp;ospf6_redistribute_routemap_cmd);</a>
<a name="ln1514">  install_element (OSPF6_NODE, &amp;no_ospf6_redistribute_cmd);</a>
<a name="ln1515">  install_element (OSPF6_NODE, &amp;no_ospf6_redistribute_route_map_cmd);</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">void</a>
<a name="ln1519">ospf6_asbr_redistribute_reset (void)</a>
<a name="ln1520">{</a>
<a name="ln1521">  int type;</a>
<a name="ln1522"> </a>
<a name="ln1523">  for (type = 0; type &lt; ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln1524">    {</a>
<a name="ln1525">      if (type == ZEBRA_ROUTE_OSPF6)</a>
<a name="ln1526">        continue;</a>
<a name="ln1527">      if (ospf6_zebra_is_redistribute (type))</a>
<a name="ln1528">        ospf6_asbr_redistribute_unset(type);</a>
<a name="ln1529">    }</a>
<a name="ln1530">}</a>
<a name="ln1531"> </a>
<a name="ln1532">void</a>
<a name="ln1533">ospf6_asbr_terminate (void)</a>
<a name="ln1534">{</a>
<a name="ln1535">  route_map_finish ();</a>
<a name="ln1536">}</a>
<a name="ln1537"> </a>
<a name="ln1538">DEFUN (debug_ospf6_asbr,</a>
<a name="ln1539">       debug_ospf6_asbr_cmd,</a>
<a name="ln1540">       &quot;debug ospf6 asbr&quot;,</a>
<a name="ln1541">       DEBUG_STR</a>
<a name="ln1542">       OSPF6_STR</a>
<a name="ln1543">       &quot;Debug OSPFv3 ASBR function\n&quot;</a>
<a name="ln1544">      )</a>
<a name="ln1545">{</a>
<a name="ln1546">  OSPF6_DEBUG_ASBR_ON ();</a>
<a name="ln1547">  return CMD_SUCCESS;</a>
<a name="ln1548">}</a>
<a name="ln1549"> </a>
<a name="ln1550">DEFUN (no_debug_ospf6_asbr,</a>
<a name="ln1551">       no_debug_ospf6_asbr_cmd,</a>
<a name="ln1552">       &quot;no debug ospf6 asbr&quot;,</a>
<a name="ln1553">       NO_STR</a>
<a name="ln1554">       DEBUG_STR</a>
<a name="ln1555">       OSPF6_STR</a>
<a name="ln1556">       &quot;Debug OSPFv3 ASBR function\n&quot;</a>
<a name="ln1557">      )</a>
<a name="ln1558">{</a>
<a name="ln1559">  OSPF6_DEBUG_ASBR_OFF ();</a>
<a name="ln1560">  return CMD_SUCCESS;</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>
<a name="ln1563">int</a>
<a name="ln1564">config_write_ospf6_debug_asbr (struct vty *vty)</a>
<a name="ln1565">{</a>
<a name="ln1566">  if (IS_OSPF6_DEBUG_ASBR)</a>
<a name="ln1567">    vty_out (vty, &quot;debug ospf6 asbr%s&quot;, VNL);</a>
<a name="ln1568">  return 0;</a>
<a name="ln1569">}</a>
<a name="ln1570"> </a>
<a name="ln1571">void</a>
<a name="ln1572">install_element_ospf6_debug_asbr ()</a>
<a name="ln1573">{</a>
<a name="ln1574">  install_element (ENABLE_NODE, &amp;debug_ospf6_asbr_cmd);</a>
<a name="ln1575">  install_element (ENABLE_NODE, &amp;no_debug_ospf6_asbr_cmd);</a>
<a name="ln1576">  install_element (CONFIG_NODE, &amp;debug_ospf6_asbr_cmd);</a>
<a name="ln1577">  install_element (CONFIG_NODE, &amp;no_debug_ospf6_asbr_cmd);</a>
<a name="ln1578">}</a>
<a name="ln1579"> </a>
<a name="ln1580"> </a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="76"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'buffer' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="77"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'lsa_header' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="327"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'ospf6_route_unlock' function. Check lines: 327, 306.</p></div>
<div class="balloon" rel="1506"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'ospf6_routemap_init' function is not declared. Passing data to or from this function can be affected.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
