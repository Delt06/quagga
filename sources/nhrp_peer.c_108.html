
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_peer.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP peer functions</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln11"> </a>
<a name="ln12">#include &quot;zebra.h&quot;</a>
<a name="ln13">#include &quot;memory.h&quot;</a>
<a name="ln14">#include &quot;thread.h&quot;</a>
<a name="ln15">#include &quot;hash.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;nhrpd.h&quot;</a>
<a name="ln18">#include &quot;nhrp_protocol.h&quot;</a>
<a name="ln19">#include &quot;os.h&quot;</a>
<a name="ln20"> </a>
<a name="ln21">struct ipv6hdr {</a>
<a name="ln22">	uint8_t priority_version;</a>
<a name="ln23">	uint8_t flow_lbl[3];</a>
<a name="ln24">	uint16_t payload_len;</a>
<a name="ln25">	uint8_t nexthdr;</a>
<a name="ln26">	uint8_t hop_limit;</a>
<a name="ln27">	struct in6_addr saddr;</a>
<a name="ln28">	struct in6_addr daddr;</a>
<a name="ln29">};</a>
<a name="ln30"> </a>
<a name="ln31">static void nhrp_packet_debug(struct zbuf *zb, const char *dir);</a>
<a name="ln32"> </a>
<a name="ln33">static void nhrp_peer_check_delete(struct nhrp_peer *p)</a>
<a name="ln34">{</a>
<a name="ln35">	struct nhrp_interface *nifp = p-&gt;ifp-&gt;info;</a>
<a name="ln36"> </a>
<a name="ln37">	if (p-&gt;ref || notifier_active(&amp;p-&gt;notifier_list))</a>
<a name="ln38">		return;</a>
<a name="ln39"> </a>
<a name="ln40">	THREAD_OFF(p-&gt;t_fallback);</a>
<a name="ln41">	hash_release(nifp-&gt;peer_hash, p);</a>
<a name="ln42">	nhrp_interface_notify_del(p-&gt;ifp, &amp;p-&gt;ifp_notifier);</a>
<a name="ln43">	nhrp_vc_notify_del(p-&gt;vc, &amp;p-&gt;vc_notifier);</a>
<a name="ln44">	XFREE(MTYPE_NHRP_PEER, p);</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">static int nhrp_peer_notify_up(struct thread *t)</a>
<a name="ln48">{</a>
<a name="ln49">	struct nhrp_peer *p = THREAD_ARG(t);</a>
<a name="ln50">	struct nhrp_vc *vc = p-&gt;vc;</a>
<a name="ln51">	struct interface *ifp = p-&gt;ifp;</a>
<a name="ln52">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln53"> </a>
<a name="ln54">	p-&gt;t_fallback = NULL;</a>
<a name="ln55">	if (nifp-&gt;enabled &amp;&amp; (!nifp-&gt;ipsec_profile || vc-&gt;ipsec)) {</a>
<a name="ln56">		p-&gt;online = 1;</a>
<a name="ln57">		nhrp_peer_ref(p);</a>
<a name="ln58">		notifier_call(&amp;p-&gt;notifier_list, NOTIFY_PEER_UP);</a>
<a name="ln59">		nhrp_peer_unref(p);</a>
<a name="ln60">	}</a>
<a name="ln61"> </a>
<a name="ln62">	return 0;</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">static void __nhrp_peer_check(struct nhrp_peer *p)</a>
<a name="ln66">{</a>
<a name="ln67">	struct nhrp_vc *vc = p-&gt;vc;</a>
<a name="ln68">	struct interface *ifp = p-&gt;ifp;</a>
<a name="ln69">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln70">	unsigned online;</a>
<a name="ln71"> </a>
<a name="ln72">	online = nifp-&gt;enabled &amp;&amp; (!nifp-&gt;ipsec_profile || vc-&gt;ipsec);</a>
<a name="ln73">	if (p-&gt;online != online) {</a>
<a name="ln74">		THREAD_OFF(p-&gt;t_fallback);</a>
<a name="ln75">		if (online &amp;&amp; notifier_active(&amp;p-&gt;notifier_list)) {</a>
<a name="ln76">			/* If we requested the IPsec connection, delay</a>
<a name="ln77">			 * the up notification a bit to allow things</a>
<a name="ln78">			 * settle down. This allows IKE to install</a>
<a name="ln79">			 * SPDs and SAs. */</a>
<a name="ln80">			THREAD_TIMER_MSEC_ON(</a>
<a name="ln81">				master, p-&gt;t_fallback,</a>
<a name="ln82">				nhrp_peer_notify_up, p, 50);</a>
<a name="ln83">		} else {</a>
<a name="ln84">			nhrp_peer_ref(p);</a>
<a name="ln85">			p-&gt;online = online;</a>
<a name="ln86">			if (online) {</a>
<a name="ln87">				notifier_call(&amp;p-&gt;notifier_list, NOTIFY_PEER_UP);</a>
<a name="ln88">			} else {</a>
<a name="ln89">				p-&gt;requested = p-&gt;fallback_requested = 0;</a>
<a name="ln90">				notifier_call(&amp;p-&gt;notifier_list, NOTIFY_PEER_DOWN);</a>
<a name="ln91">			}</a>
<a name="ln92">			nhrp_peer_unref(p);</a>
<a name="ln93">		}</a>
<a name="ln94">	}</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">static void nhrp_peer_vc_notify(struct notifier_block *n, unsigned long cmd)</a>
<a name="ln98">{</a>
<a name="ln99">	struct nhrp_peer *p = container_of(n, struct nhrp_peer, vc_notifier);</a>
<a name="ln100"> </a>
<a name="ln101">	switch (cmd) {</a>
<a name="ln102">	case NOTIFY_VC_IPSEC_CHANGED:</a>
<a name="ln103">		__nhrp_peer_check(p);</a>
<a name="ln104">		break;</a>
<a name="ln105">	case NOTIFY_VC_IPSEC_UPDATE_NBMA:</a>
<a name="ln106">		nhrp_peer_ref(p);</a>
<a name="ln107">		notifier_call(&amp;p-&gt;notifier_list, NOTIFY_PEER_NBMA_CHANGING);</a>
<a name="ln108">		nhrp_peer_unref(p);</a>
<a name="ln109">		break;</a>
<a name="ln110">	}</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">static void nhrp_peer_ifp_notify(struct notifier_block *n, unsigned long cmd)</a>
<a name="ln114">{</a>
<a name="ln115">	struct nhrp_peer *p = container_of(n, struct nhrp_peer, ifp_notifier);</a>
<a name="ln116">	struct nhrp_interface *nifp;</a>
<a name="ln117">	struct nhrp_vc *vc;</a>
<a name="ln118"> </a>
<a name="ln119">	nhrp_peer_ref(p);</a>
<a name="ln120">	switch (cmd) {</a>
<a name="ln121">	case NOTIFY_INTERFACE_UP:</a>
<a name="ln122">	case NOTIFY_INTERFACE_DOWN:</a>
<a name="ln123">		__nhrp_peer_check(p);</a>
<a name="ln124">		break;</a>
<a name="ln125">	case NOTIFY_INTERFACE_NBMA_CHANGED:</a>
<a name="ln126">		/* Source NBMA changed, rebind to new VC */</a>
<a name="ln127">		nifp = p-&gt;ifp-&gt;info;</a>
<a name="ln128">		vc = nhrp_vc_get(&amp;nifp-&gt;nbma, &amp;p-&gt;vc-&gt;remote.nbma, 1);</a>
<a name="ln129">		if (vc &amp;&amp; p-&gt;vc != vc) {</a>
<a name="ln130">			nhrp_vc_notify_del(p-&gt;vc, &amp;p-&gt;vc_notifier);</a>
<a name="ln131">			p-&gt;vc = vc;</a>
<a name="ln132">			nhrp_vc_notify_add(p-&gt;vc, &amp;p-&gt;vc_notifier, nhrp_peer_vc_notify);</a>
<a name="ln133">			__nhrp_peer_check(p);</a>
<a name="ln134">		}</a>
<a name="ln135">		/* Fall-through to post config update */</a>
<a name="ln136">	case NOTIFY_INTERFACE_ADDRESS_CHANGED:</a>
<a name="ln137">		notifier_call(&amp;p-&gt;notifier_list, NOTIFY_PEER_IFCONFIG_CHANGED);</a>
<a name="ln138">		break;</a>
<a name="ln139">	case NOTIFY_INTERFACE_MTU_CHANGED:</a>
<a name="ln140">		notifier_call(&amp;p-&gt;notifier_list, NOTIFY_PEER_MTU_CHANGED);</a>
<a name="ln141">		break;</a>
<a name="ln142">	}</a>
<a name="ln143">	nhrp_peer_unref(p);</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">static unsigned int nhrp_peer_key(void *peer_data)</a>
<a name="ln147">{</a>
<a name="ln148">	struct nhrp_peer *p = peer_data;</a>
<a name="ln149">	return sockunion_hash(&amp;p-&gt;vc-&gt;remote.nbma);</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">static int nhrp_peer_cmp(const void *cache_data, const void *key_data)</a>
<a name="ln153">{</a>
<a name="ln154">	const struct nhrp_peer *a = cache_data;</a>
<a name="ln155">	const struct nhrp_peer *b = key_data;</a>
<a name="ln156">	return a-&gt;ifp == b-&gt;ifp &amp;&amp; a-&gt;vc == b-&gt;vc;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">static void *nhrp_peer_create(void *data)</a>
<a name="ln160">{</a>
<a name="ln161">	struct nhrp_peer *p, *key = data;</a>
<a name="ln162"> </a>
<a name="ln163">	p = XMALLOC(MTYPE_NHRP_PEER, sizeof(*p));</a>
<a name="ln164">	if (p) {</a>
<a name="ln165">		*p = (struct nhrp_peer) {</a>
<a name="ln166">			.ref = 0,</a>
<a name="ln167">			.ifp = key-&gt;ifp,</a>
<a name="ln168">			.vc = key-&gt;vc,</a>
<a name="ln169">			.notifier_list = NOTIFIER_LIST_INITIALIZER(&amp;p-&gt;notifier_list),</a>
<a name="ln170">		};</a>
<a name="ln171">		nhrp_vc_notify_add(p-&gt;vc, &amp;p-&gt;vc_notifier, nhrp_peer_vc_notify);</a>
<a name="ln172">		nhrp_interface_notify_add(p-&gt;ifp, &amp;p-&gt;ifp_notifier, nhrp_peer_ifp_notify);</a>
<a name="ln173">	}</a>
<a name="ln174">	return p;</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">struct nhrp_peer *nhrp_peer_get(struct interface *ifp, const union sockunion *remote_nbma)</a>
<a name="ln178">{</a>
<a name="ln179">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln180">	struct nhrp_peer key, *p;</a>
<a name="ln181">	struct nhrp_vc *vc;</a>
<a name="ln182"> </a>
<a name="ln183">	if (!nifp-&gt;peer_hash) {</a>
<a name="ln184">		nifp-&gt;peer_hash = hash_create(nhrp_peer_key, nhrp_peer_cmp);</a>
<a name="ln185">		if (!nifp-&gt;peer_hash) return NULL;</a>
<a name="ln186">	}</a>
<a name="ln187"> </a>
<a name="ln188">	vc = nhrp_vc_get(&amp;nifp-&gt;nbma, remote_nbma, 1);</a>
<a name="ln189">	if (!vc) return NULL;</a>
<a name="ln190"> </a>
<a name="ln191">	key.ifp = ifp;</a>
<a name="ln192">	key.vc = vc;</a>
<a name="ln193"> </a>
<a name="ln194">	p = hash_get(nifp-&gt;peer_hash, &amp;key, nhrp_peer_create);</a>
<a name="ln195">	nhrp_peer_ref(p);</a>
<a name="ln196">	if (p-&gt;ref == 1) __nhrp_peer_check(p);</a>
<a name="ln197"> </a>
<a name="ln198">	return p;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">struct nhrp_peer *nhrp_peer_ref(struct nhrp_peer *p)</a>
<a name="ln202">{</a>
<a name="ln203">	if (p) p-&gt;ref++;</a>
<a name="ln204">	return p;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">void nhrp_peer_unref(struct nhrp_peer *p)</a>
<a name="ln208">{</a>
<a name="ln209">	if (p) {</a>
<a name="ln210">		p-&gt;ref--;</a>
<a name="ln211">		nhrp_peer_check_delete(p);</a>
<a name="ln212">	}</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">static int nhrp_peer_request_timeout(struct thread *t)</a>
<a name="ln216">{</a>
<a name="ln217">	struct nhrp_peer *p = THREAD_ARG(t);</a>
<a name="ln218">	struct nhrp_vc *vc = p-&gt;vc;</a>
<a name="ln219">	struct interface *ifp = p-&gt;ifp;</a>
<a name="ln220">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln221"> </a>
<a name="ln222">	p-&gt;t_fallback = NULL;</a>
<a name="ln223"> </a>
<a name="ln224">	if (p-&gt;online)</a>
<a name="ln225">		return 0;</a>
<a name="ln226"> </a>
<a name="ln227">	if (nifp-&gt;ipsec_fallback_profile &amp;&amp; !p-&gt;prio &amp;&amp; !p-&gt;fallback_requested) {</a>
<a name="ln228">		p-&gt;fallback_requested = 1;</a>
<a name="ln229">		vici_request_vc(nifp-&gt;ipsec_fallback_profile,</a>
<a name="ln230">				&amp;vc-&gt;local.nbma, &amp;vc-&gt;remote.nbma, p-&gt;prio);</a>
<a name="ln231">		THREAD_TIMER_ON(master, p-&gt;t_fallback, nhrp_peer_request_timeout, p, 30);</a>
<a name="ln232">	} else {</a>
<a name="ln233">		p-&gt;requested = p-&gt;fallback_requested = 0;</a>
<a name="ln234">	}</a>
<a name="ln235"> </a>
<a name="ln236">	return 0;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">int nhrp_peer_check(struct nhrp_peer *p, int establish)</a>
<a name="ln240">{</a>
<a name="ln241">	struct nhrp_vc *vc = p-&gt;vc;</a>
<a name="ln242">	struct interface *ifp = p-&gt;ifp;</a>
<a name="ln243">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln244"> </a>
<a name="ln245">	if (p-&gt;online)</a>
<a name="ln246">		return 1;</a>
<a name="ln247">	if (!establish)</a>
<a name="ln248">		return 0;</a>
<a name="ln249">	if (p-&gt;requested)</a>
<a name="ln250">		return 0;</a>
<a name="ln251">	if (!nifp-&gt;ipsec_profile)</a>
<a name="ln252">		return 0;</a>
<a name="ln253">	if (sockunion_family(&amp;vc-&gt;local.nbma) == AF_UNSPEC)</a>
<a name="ln254">		return 0;</a>
<a name="ln255"> </a>
<a name="ln256">	p-&gt;prio = establish &gt; 1;</a>
<a name="ln257">	p-&gt;requested = 1;</a>
<a name="ln258">	vici_request_vc(nifp-&gt;ipsec_profile, &amp;vc-&gt;local.nbma, &amp;vc-&gt;remote.nbma, p-&gt;prio);</a>
<a name="ln259">	THREAD_TIMER_ON(master, p-&gt;t_fallback, nhrp_peer_request_timeout, p,</a>
<a name="ln260">			(nifp-&gt;ipsec_fallback_profile &amp;&amp; !p-&gt;prio) ? 15 : 30);</a>
<a name="ln261"> </a>
<a name="ln262">	return 0;</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">void nhrp_peer_notify_add(struct nhrp_peer *p, struct notifier_block *n, notifier_fn_t fn)</a>
<a name="ln266">{</a>
<a name="ln267">	notifier_add(n, &amp;p-&gt;notifier_list, fn);</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">void nhrp_peer_notify_del(struct nhrp_peer *p, struct notifier_block *n)</a>
<a name="ln271">{</a>
<a name="ln272">	notifier_del(n);</a>
<a name="ln273">	nhrp_peer_check_delete(p);</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">void nhrp_peer_send(struct nhrp_peer *p, struct zbuf *zb)</a>
<a name="ln277">{</a>
<a name="ln278">	char buf[2][256];</a>
<a name="ln279"> </a>
<a name="ln280">	nhrp_packet_debug(zb, &quot;Send&quot;);</a>
<a name="ln281"> </a>
<a name="ln282">	if (!p-&gt;online)</a>
<a name="ln283">		return;</a>
<a name="ln284"> </a>
<a name="ln285">	debugf(NHRP_DEBUG_KERNEL, &quot;PACKET: Send %s -&gt; %s&quot;,</a>
<a name="ln286">		sockunion2str(&amp;p-&gt;vc-&gt;local.nbma, buf[0], sizeof buf[0]),</a>
<a name="ln287">		sockunion2str(&amp;p-&gt;vc-&gt;remote.nbma, buf[1], sizeof buf[1]));</a>
<a name="ln288"> </a>
<a name="ln289">	os_sendmsg(zb-&gt;head, zbuf_used(zb),</a>
<a name="ln290">		p-&gt;ifp-&gt;ifindex,</a>
<a name="ln291">		sockunion_get_addr(&amp;p-&gt;vc-&gt;remote.nbma),</a>
<a name="ln292">		sockunion_get_addrlen(&amp;p-&gt;vc-&gt;remote.nbma));</a>
<a name="ln293">	zbuf_reset(zb);</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">static void nhrp_handle_resolution_req(struct nhrp_packet_parser *p)</a>
<a name="ln297">{</a>
<a name="ln298">	struct zbuf *zb, payload;</a>
<a name="ln299">	struct nhrp_packet_header *hdr;</a>
<a name="ln300">	struct nhrp_cie_header *cie;</a>
<a name="ln301">	struct nhrp_extension_header *ext;</a>
<a name="ln302">	struct nhrp_interface *nifp;</a>
<a name="ln303">	struct nhrp_peer *peer;</a>
<a name="ln304"> </a>
<a name="ln305">	if (!(p-&gt;if_ad-&gt;flags &amp; NHRP_IFF_SHORTCUT)) {</a>
<a name="ln306">		debugf(NHRP_DEBUG_COMMON, &quot;Shortcuts disabled&quot;);</a>
<a name="ln307">		/* FIXME: Send error indication? */</a>
<a name="ln308">		return;</a>
<a name="ln309">	}</a>
<a name="ln310"> </a>
<a name="ln311">	if (p-&gt;if_ad-&gt;network_id &amp;&amp;</a>
<a name="ln312">	    p-&gt;route_type == NHRP_ROUTE_OFF_NBMA &amp;&amp;</a>
<a name="ln313">	    p-&gt;route_prefix.prefixlen &lt; 8) {</a>
<a name="ln314">		debugf(NHRP_DEBUG_COMMON, &quot;Shortcut to more generic than /8 dropped&quot;);</a>
<a name="ln315">		return;</a>
<a name="ln316">	}</a>
<a name="ln317"> </a>
<a name="ln318">	debugf(NHRP_DEBUG_COMMON, &quot;Parsing and replying to Resolution Req&quot;);</a>
<a name="ln319"> </a>
<a name="ln320">	if (nhrp_route_address(p-&gt;ifp, &amp;p-&gt;src_proto, NULL, &amp;peer) != NHRP_ROUTE_NBMA_NEXTHOP)</a>
<a name="ln321">		return;</a>
<a name="ln322"> </a>
<a name="ln323">#if 0</a>
<a name="ln324">	/* FIXME: Update requestors binding if CIE specifies holding time */</a>
<a name="ln325">	nhrp_cache_update_binding(</a>
<a name="ln326">			NHRP_CACHE_CACHED, &amp;p-&gt;src_proto,</a>
<a name="ln327">			nhrp_peer_get(p-&gt;ifp, &amp;p-&gt;src_nbma),</a>
<a name="ln328">			htons(cie-&gt;holding_time));</a>
<a name="ln329">#endif</a>
<a name="ln330"> </a>
<a name="ln331">	nifp = peer-&gt;ifp-&gt;info;</a>
<a name="ln332"> </a>
<a name="ln333">	/* Create reply */</a>
<a name="ln334">	zb = zbuf_alloc(1500);</a>
<a name="ln335">	hdr = nhrp_packet_push(zb, NHRP_PACKET_RESOLUTION_REPLY, &amp;p-&gt;src_nbma, &amp;p-&gt;src_proto, &amp;p-&gt;dst_proto);</a>
<a name="ln336"> </a>
<a name="ln337">	/* Copied information from request */</a>
<a name="ln338">	hdr-&gt;flags = p-&gt;hdr-&gt;flags &amp; htons(NHRP_FLAG_RESOLUTION_SOURCE_IS_ROUTER|NHRP_FLAG_RESOLUTION_SOURCE_STABLE);</a>
<a name="ln339">	hdr-&gt;flags |= htons(NHRP_FLAG_RESOLUTION_DESTINATION_STABLE | NHRP_FLAG_RESOLUTION_AUTHORATIVE);</a>
<a name="ln340">	hdr-&gt;u.request_id = p-&gt;hdr-&gt;u.request_id;</a>
<a name="ln341"> </a>
<a name="ln342">	/* CIE payload */</a>
<a name="ln343">	cie = nhrp_cie_push(zb, NHRP_CODE_SUCCESS, &amp;nifp-&gt;nbma, &amp;p-&gt;if_ad-&gt;addr);</a>
<a name="ln344">	cie-&gt;holding_time = htons(p-&gt;if_ad-&gt;holdtime);</a>
<a name="ln345">	cie-&gt;mtu = htons(p-&gt;if_ad-&gt;mtu);</a>
<a name="ln346">	if (p-&gt;if_ad-&gt;network_id &amp;&amp; p-&gt;route_type == NHRP_ROUTE_OFF_NBMA)</a>
<a name="ln347">		cie-&gt;prefix_length = p-&gt;route_prefix.prefixlen;</a>
<a name="ln348">	else</a>
<a name="ln349">		cie-&gt;prefix_length = 8 * sockunion_get_addrlen(&amp;p-&gt;if_ad-&gt;addr);</a>
<a name="ln350"> </a>
<a name="ln351">	/* Handle extensions */</a>
<a name="ln352">	while ((ext = nhrp_ext_pull(&amp;p-&gt;extensions, &amp;payload)) != NULL) {</a>
<a name="ln353">		switch (htons(ext-&gt;type) &amp; ~NHRP_EXTENSION_FLAG_COMPULSORY) {</a>
<a name="ln354">		case NHRP_EXTENSION_NAT_ADDRESS:</a>
<a name="ln355">			if (sockunion_family(&amp;nifp-&gt;nat_nbma) == AF_UNSPEC)</a>
<a name="ln356">				break;</a>
<a name="ln357">			ext = nhrp_ext_push(zb, hdr, NHRP_EXTENSION_NAT_ADDRESS);</a>
<a name="ln358">			if (!ext) goto err;</a>
<a name="ln359">			cie = nhrp_cie_push(zb, NHRP_CODE_SUCCESS, &amp;nifp-&gt;nat_nbma, &amp;p-&gt;if_ad-&gt;addr);</a>
<a name="ln360">			if (!cie) goto err;</a>
<a name="ln361">			nhrp_ext_complete(zb, ext);</a>
<a name="ln362">			break;</a>
<a name="ln363">		default:</a>
<a name="ln364">			if (nhrp_ext_reply(zb, hdr, p-&gt;ifp, ext, &amp;payload) &lt; 0)</a>
<a name="ln365">				goto err;</a>
<a name="ln366">			break;</a>
<a name="ln367">		}</a>
<a name="ln368">	}</a>
<a name="ln369"> </a>
<a name="ln370">	nhrp_packet_complete(zb, hdr);</a>
<a name="ln371">	nhrp_peer_send(peer, zb);</a>
<a name="ln372">err:</a>
<a name="ln373">	nhrp_peer_unref(peer);</a>
<a name="ln374">	zbuf_free(zb);</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">static void nhrp_handle_registration_request(struct nhrp_packet_parser *p)</a>
<a name="ln378">{</a>
<a name="ln379">	struct interface *ifp = p-&gt;ifp;</a>
<a name="ln380">	struct zbuf *zb, payload;</a>
<a name="ln381">	struct nhrp_packet_header *hdr;</a>
<a name="ln382">	struct nhrp_cie_header *cie;</a>
<a name="ln383">	struct nhrp_extension_header *ext;</a>
<a name="ln384">	struct nhrp_cache *c;</a>
<a name="ln385">	union sockunion cie_nbma, cie_proto, *proto_addr, *nbma_addr, *nbma_natoa;</a>
<a name="ln386">	int holdtime, prefix_len, hostprefix_len, natted = 0;</a>
<a name="ln387">	size_t paylen;</a>
<a name="ln388">	void *pay;</a>
<a name="ln389"> </a>
<a name="ln390">	debugf(NHRP_DEBUG_COMMON, &quot;Parsing and replying to Registration Req&quot;);</a>
<a name="ln391">	hostprefix_len = 8 * sockunion_get_addrlen(&amp;p-&gt;if_ad-&gt;addr);</a>
<a name="ln392"> </a>
<a name="ln393">	if (!sockunion_same(&amp;p-&gt;src_nbma, &amp;p-&gt;peer-&gt;vc-&gt;remote.nbma))</a>
<a name="ln394">		natted = 1;</a>
<a name="ln395"> </a>
<a name="ln396">	/* Create reply */</a>
<a name="ln397">	zb = zbuf_alloc(1500);</a>
<a name="ln398">	hdr = nhrp_packet_push(zb, NHRP_PACKET_REGISTRATION_REPLY,</a>
<a name="ln399">		&amp;p-&gt;src_nbma, &amp;p-&gt;src_proto, &amp;p-&gt;if_ad-&gt;addr);</a>
<a name="ln400"> </a>
<a name="ln401">	/* Copied information from request */</a>
<a name="ln402">	hdr-&gt;flags = p-&gt;hdr-&gt;flags &amp; htons(NHRP_FLAG_REGISTRATION_UNIQUE | NHRP_FLAG_REGISTRATION_NAT);</a>
<a name="ln403">	hdr-&gt;u.request_id = p-&gt;hdr-&gt;u.request_id;</a>
<a name="ln404"> </a>
<a name="ln405">	/* Copy payload CIEs */</a>
<a name="ln406">	paylen = zbuf_used(&amp;p-&gt;payload);</a>
<a name="ln407">	pay = zbuf_pushn(zb, paylen);</a>
<a name="ln408">	if (!pay) goto err;</a>
<a name="ln409">	memcpy(pay, zbuf_pulln(&amp;p-&gt;payload, paylen), paylen);</a>
<a name="ln410">	zbuf_init(&amp;payload, pay, paylen, paylen);</a>
<a name="ln411"> </a>
<a name="ln412">	while ((cie = nhrp_cie_pull(&amp;payload, hdr, &amp;cie_nbma, &amp;cie_proto)) != NULL) {</a>
<a name="ln413">		prefix_len = cie-&gt;prefix_length;</a>
<a name="ln414">		if (prefix_len == 0 || prefix_len &gt;= hostprefix_len)</a>
<a name="ln415">			prefix_len = hostprefix_len;</a>
<a name="ln416"> </a>
<a name="ln417">		if (prefix_len != hostprefix_len &amp;&amp; !(p-&gt;hdr-&gt;flags &amp; htons(NHRP_FLAG_REGISTRATION_UNIQUE))) {</a>
<a name="ln418">			cie-&gt;code = NHRP_CODE_BINDING_NON_UNIQUE;</a>
<a name="ln419">			continue;</a>
<a name="ln420">		}</a>
<a name="ln421"> </a>
<a name="ln422">		/* We currently support only unique prefix registrations */</a>
<a name="ln423">		if (prefix_len != hostprefix_len) {</a>
<a name="ln424">			cie-&gt;code = NHRP_CODE_ADMINISTRATIVELY_PROHIBITED;</a>
<a name="ln425">			continue;</a>
<a name="ln426">		}</a>
<a name="ln427"> </a>
<a name="ln428">		proto_addr = (sockunion_family(&amp;cie_proto) == AF_UNSPEC) ? &amp;p-&gt;src_proto : &amp;cie_proto;</a>
<a name="ln429">		nbma_addr = (sockunion_family(&amp;cie_nbma) == AF_UNSPEC) ? &amp;p-&gt;src_nbma : &amp;cie_nbma;</a>
<a name="ln430">		nbma_natoa = NULL;</a>
<a name="ln431">		if (natted) {</a>
<a name="ln432">			nbma_natoa = nbma_addr;</a>
<a name="ln433">			nbma_addr = &amp;p-&gt;peer-&gt;vc-&gt;remote.nbma;</a>
<a name="ln434">		}</a>
<a name="ln435"> </a>
<a name="ln436">		holdtime = htons(cie-&gt;holding_time);</a>
<a name="ln437">		if (!holdtime) holdtime = p-&gt;if_ad-&gt;holdtime;</a>
<a name="ln438"> </a>
<a name="ln439">		c = nhrp_cache_get(ifp, proto_addr, 1);</a>
<a name="ln440">		if (!c) {</a>
<a name="ln441">			cie-&gt;code = NHRP_CODE_INSUFFICIENT_RESOURCES;</a>
<a name="ln442">			continue;</a>
<a name="ln443">		}</a>
<a name="ln444"> </a>
<a name="ln445">		if (!nhrp_cache_update_binding(c, NHRP_CACHE_DYNAMIC, holdtime, nhrp_peer_ref(p-&gt;peer), htons(cie-&gt;mtu), nbma_natoa)) {</a>
<a name="ln446">			cie-&gt;code = NHRP_CODE_ADMINISTRATIVELY_PROHIBITED;</a>
<a name="ln447">			continue;</a>
<a name="ln448">		}</a>
<a name="ln449"> </a>
<a name="ln450">		cie-&gt;code = NHRP_CODE_SUCCESS;</a>
<a name="ln451">	}</a>
<a name="ln452"> </a>
<a name="ln453">	/* Handle extensions */</a>
<a name="ln454">	while ((ext = nhrp_ext_pull(&amp;p-&gt;extensions, &amp;payload)) != NULL) {</a>
<a name="ln455">		switch (htons(ext-&gt;type) &amp; ~NHRP_EXTENSION_FLAG_COMPULSORY) {</a>
<a name="ln456">		case NHRP_EXTENSION_NAT_ADDRESS:</a>
<a name="ln457">			ext = nhrp_ext_push(zb, hdr, NHRP_EXTENSION_NAT_ADDRESS);</a>
<a name="ln458">			if (!ext) goto err;</a>
<a name="ln459">			zbuf_copy(zb, &amp;payload, zbuf_used(&amp;payload));</a>
<a name="ln460">			if (natted) {</a>
<a name="ln461">				nhrp_cie_push(zb, NHRP_CODE_SUCCESS,</a>
<a name="ln462">					&amp;p-&gt;peer-&gt;vc-&gt;remote.nbma,</a>
<a name="ln463">					&amp;p-&gt;src_proto);</a>
<a name="ln464">			}</a>
<a name="ln465">			nhrp_ext_complete(zb, ext);</a>
<a name="ln466">			break;</a>
<a name="ln467">		default:</a>
<a name="ln468">			if (nhrp_ext_reply(zb, hdr, ifp, ext, &amp;payload) &lt; 0)</a>
<a name="ln469">				goto err;</a>
<a name="ln470">			break;</a>
<a name="ln471">		}</a>
<a name="ln472">	}</a>
<a name="ln473"> </a>
<a name="ln474">	nhrp_packet_complete(zb, hdr);</a>
<a name="ln475">	nhrp_peer_send(p-&gt;peer, zb);</a>
<a name="ln476">err:</a>
<a name="ln477">	zbuf_free(zb);</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">static int parse_ether_packet(struct zbuf *zb, uint16_t protocol_type, union sockunion *src, union sockunion *dst)</a>
<a name="ln481">{</a>
<a name="ln482">	switch (protocol_type) {</a>
<a name="ln483">	case ETH_P_IP: {</a>
<a name="ln484">			struct iphdr *iph = zbuf_pull(zb, struct iphdr);</a>
<a name="ln485">			if (iph) {</a>
<a name="ln486">				if (src) sockunion_set(src, AF_INET, (uint8_t*) &amp;iph-&gt;saddr, sizeof(iph-&gt;saddr));</a>
<a name="ln487">				if (dst) sockunion_set(dst, AF_INET, (uint8_t*) &amp;iph-&gt;daddr, sizeof(iph-&gt;daddr));</a>
<a name="ln488">			}</a>
<a name="ln489">		}</a>
<a name="ln490">		break;</a>
<a name="ln491">	case ETH_P_IPV6: {</a>
<a name="ln492">			struct ipv6hdr *iph = zbuf_pull(zb, struct ipv6hdr);</a>
<a name="ln493">			if (iph) {</a>
<a name="ln494">				if (src) sockunion_set(src, AF_INET6, (uint8_t*) &amp;iph-&gt;saddr, sizeof(iph-&gt;saddr));</a>
<a name="ln495">				if (dst) sockunion_set(dst, AF_INET6, (uint8_t*) &amp;iph-&gt;daddr, sizeof(iph-&gt;daddr));</a>
<a name="ln496">			}</a>
<a name="ln497">		}</a>
<a name="ln498">		break;</a>
<a name="ln499">	default:</a>
<a name="ln500">		return 0;</a>
<a name="ln501">	}</a>
<a name="ln502">	return 1;</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">void nhrp_peer_send_indication(struct interface *ifp, uint16_t protocol_type, struct zbuf *pkt)</a>
<a name="ln506">{</a>
<a name="ln507">	union sockunion dst;</a>
<a name="ln508">	struct zbuf *zb, payload;</a>
<a name="ln509">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln510">	struct nhrp_afi_data *if_ad;</a>
<a name="ln511">	struct nhrp_packet_header *hdr;</a>
<a name="ln512">	struct nhrp_peer *p;</a>
<a name="ln513">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln514"> </a>
<a name="ln515">	if (!nifp-&gt;enabled) return;</a>
<a name="ln516"> </a>
<a name="ln517">	payload = *pkt;</a>
<a name="ln518">	if (!parse_ether_packet(&amp;payload, protocol_type, &amp;dst, NULL))</a>
<a name="ln519">		return;</a>
<a name="ln520"> </a>
<a name="ln521">	if (nhrp_route_address(ifp, &amp;dst, NULL, &amp;p) != NHRP_ROUTE_NBMA_NEXTHOP)</a>
<a name="ln522">		return;</a>
<a name="ln523"> </a>
<a name="ln524">	if_ad = &amp;nifp-&gt;afi[family2afi(sockunion_family(&amp;dst))];</a>
<a name="ln525">	if (!(if_ad-&gt;flags &amp; NHRP_IFF_REDIRECT)) {</a>
<a name="ln526">		debugf(NHRP_DEBUG_COMMON, &quot;Send Traffic Indication to %s about packet to %s ignored&quot;,</a>
<a name="ln527">			sockunion2str(&amp;p-&gt;vc-&gt;remote.nbma, buf[0], sizeof buf[0]),</a>
<a name="ln528">			sockunion2str(&amp;dst, buf[1], sizeof buf[1]));</a>
<a name="ln529">		return;</a>
<a name="ln530">	}</a>
<a name="ln531"> </a>
<a name="ln532">	debugf(NHRP_DEBUG_COMMON, &quot;Send Traffic Indication to %s (online=%d) about packet to %s&quot;,</a>
<a name="ln533">		sockunion2str(&amp;p-&gt;vc-&gt;remote.nbma, buf[0], sizeof buf[0]),</a>
<a name="ln534">		p-&gt;online,</a>
<a name="ln535">		sockunion2str(&amp;dst, buf[1], sizeof buf[1]));</a>
<a name="ln536"> </a>
<a name="ln537">	/* Create reply */</a>
<a name="ln538">	zb = zbuf_alloc(1500);</a>
<a name="ln539">	hdr = nhrp_packet_push(zb, NHRP_PACKET_TRAFFIC_INDICATION, &amp;nifp-&gt;nbma, &amp;if_ad-&gt;addr, &amp;dst);</a>
<a name="ln540">	hdr-&gt;hop_count = 0;</a>
<a name="ln541"> </a>
<a name="ln542">	/* Payload is the packet causing indication */</a>
<a name="ln543">	zbuf_copy(zb, pkt, zbuf_used(pkt));</a>
<a name="ln544">	nhrp_packet_complete(zb, hdr);</a>
<a name="ln545">	nhrp_peer_send(p, zb);</a>
<a name="ln546">	nhrp_peer_unref(p);</a>
<a name="ln547">	zbuf_free(zb);</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">static void nhrp_handle_error_ind(struct nhrp_packet_parser *pp)</a>
<a name="ln551">{</a>
<a name="ln552">	struct zbuf origmsg = pp-&gt;payload;</a>
<a name="ln553">	struct nhrp_packet_header *hdr;</a>
<a name="ln554">	struct nhrp_reqid *reqid;</a>
<a name="ln555">	union sockunion src_nbma, src_proto, dst_proto;</a>
<a name="ln556">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln557"> </a>
<a name="ln558">	hdr = nhrp_packet_pull(&amp;origmsg, &amp;src_nbma, &amp;src_proto, &amp;dst_proto);</a>
<a name="ln559">	if (!hdr) return;</a>
<a name="ln560"> </a>
<a name="ln561">	debugf(NHRP_DEBUG_COMMON, &quot;Error Indication from %s about packet to %s ignored&quot;,</a>
<a name="ln562">		sockunion2str(&amp;pp-&gt;src_proto, buf[0], sizeof buf[0]),</a>
<a name="ln563">		sockunion2str(&amp;dst_proto, buf[1], sizeof buf[1]));</a>
<a name="ln564"> </a>
<a name="ln565">	reqid = nhrp_reqid_lookup(&amp;nhrp_packet_reqid, htonl(hdr-&gt;u.request_id));</a>
<a name="ln566">	if (reqid)</a>
<a name="ln567">		reqid-&gt;cb(reqid, pp);</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">static void nhrp_handle_traffic_ind(struct nhrp_packet_parser *p)</a>
<a name="ln571">{</a>
<a name="ln572">	union sockunion dst;</a>
<a name="ln573">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln574"> </a>
<a name="ln575">	if (!parse_ether_packet(&amp;p-&gt;payload, htons(p-&gt;hdr-&gt;protocol_type), NULL, &amp;dst))</a>
<a name="ln576">		return;</a>
<a name="ln577"> </a>
<a name="ln578">	debugf(NHRP_DEBUG_COMMON, &quot;Traffic Indication from %s about packet to %s: %s&quot;,</a>
<a name="ln579">		sockunion2str(&amp;p-&gt;src_proto, buf[0], sizeof buf[0]),</a>
<a name="ln580">		sockunion2str(&amp;dst, buf[1], sizeof buf[1]),</a>
<a name="ln581">		(p-&gt;if_ad-&gt;flags &amp; NHRP_IFF_SHORTCUT) ? &quot;trying shortcut&quot; : &quot;ignored&quot;);</a>
<a name="ln582"> </a>
<a name="ln583">	if (p-&gt;if_ad-&gt;flags &amp; NHRP_IFF_SHORTCUT)</a>
<a name="ln584">		nhrp_shortcut_initiate(&amp;dst);</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">enum packet_type_t {</a>
<a name="ln588">	PACKET_UNKNOWN = 0,</a>
<a name="ln589">	PACKET_REQUEST,</a>
<a name="ln590">	PACKET_REPLY,</a>
<a name="ln591">	PACKET_INDICATION,</a>
<a name="ln592">};</a>
<a name="ln593"> </a>
<a name="ln594">static struct {</a>
<a name="ln595">	enum packet_type_t type;</a>
<a name="ln596">	const char *name;</a>
<a name="ln597">	void (*handler)(struct nhrp_packet_parser *);</a>
<a name="ln598">} packet_types[] = {</a>
<a name="ln599">	[NHRP_PACKET_RESOLUTION_REQUEST] = {</a>
<a name="ln600">		.type = PACKET_REQUEST,</a>
<a name="ln601">		.name = &quot;Resolution-Request&quot;,</a>
<a name="ln602">		.handler = nhrp_handle_resolution_req,</a>
<a name="ln603">	},</a>
<a name="ln604">	[NHRP_PACKET_RESOLUTION_REPLY] = {</a>
<a name="ln605">		.type = PACKET_REPLY,</a>
<a name="ln606">		.name = &quot;Resolution-Reply&quot;,</a>
<a name="ln607">	},</a>
<a name="ln608">	[NHRP_PACKET_REGISTRATION_REQUEST] = {</a>
<a name="ln609">		.type = PACKET_REQUEST,</a>
<a name="ln610">		.name = &quot;Registration-Request&quot;,</a>
<a name="ln611">		.handler = nhrp_handle_registration_request,</a>
<a name="ln612">	},</a>
<a name="ln613">	[NHRP_PACKET_REGISTRATION_REPLY] = {</a>
<a name="ln614">		.type = PACKET_REPLY,</a>
<a name="ln615">		.name = &quot;Registration-Reply&quot;,</a>
<a name="ln616">	},</a>
<a name="ln617">	[NHRP_PACKET_PURGE_REQUEST] = {</a>
<a name="ln618">		.type = PACKET_REQUEST,</a>
<a name="ln619">		.name = &quot;Purge-Request&quot;,</a>
<a name="ln620">	},</a>
<a name="ln621">	[NHRP_PACKET_PURGE_REPLY] = {</a>
<a name="ln622">		.type = PACKET_REPLY,</a>
<a name="ln623">		.name = &quot;Purge-Reply&quot;,</a>
<a name="ln624">	},</a>
<a name="ln625">	[NHRP_PACKET_ERROR_INDICATION] = {</a>
<a name="ln626">		.type = PACKET_INDICATION,</a>
<a name="ln627">		.name = &quot;Error-Indication&quot;,</a>
<a name="ln628">		.handler = nhrp_handle_error_ind,</a>
<a name="ln629">	},</a>
<a name="ln630">	[NHRP_PACKET_TRAFFIC_INDICATION] = {</a>
<a name="ln631">		.type = PACKET_INDICATION,</a>
<a name="ln632">		.name = &quot;Traffic-Indication&quot;,</a>
<a name="ln633">		.handler = nhrp_handle_traffic_ind,</a>
<a name="ln634">	}</a>
<a name="ln635">};</a>
<a name="ln636"> </a>
<a name="ln637">static void nhrp_peer_forward(struct nhrp_peer *p, struct nhrp_packet_parser *pp)</a>
<a name="ln638">{</a>
<a name="ln639">	struct zbuf *zb, extpl;</a>
<a name="ln640">	struct nhrp_packet_header *hdr;</a>
<a name="ln641">	struct nhrp_extension_header *ext, *dst;</a>
<a name="ln642">	struct nhrp_cie_header *cie;</a>
<a name="ln643">	struct nhrp_interface *nifp = pp-&gt;ifp-&gt;info;</a>
<a name="ln644">	struct nhrp_afi_data *if_ad = pp-&gt;if_ad;</a>
<a name="ln645">	union sockunion cie_nbma, cie_protocol;</a>
<a name="ln646">	uint16_t type, len;</a>
<a name="ln647"> </a>
<a name="ln648">	if (pp-&gt;hdr-&gt;hop_count == 0)</a>
<a name="ln649">		return;</a>
<a name="ln650"> </a>
<a name="ln651">	/* Create forward packet - copy header */</a>
<a name="ln652">	zb = zbuf_alloc(1500);</a>
<a name="ln653">	hdr = nhrp_packet_push(zb, pp-&gt;hdr-&gt;type, &amp;pp-&gt;src_nbma, &amp;pp-&gt;src_proto, &amp;pp-&gt;dst_proto);</a>
<a name="ln654">	hdr-&gt;flags = pp-&gt;hdr-&gt;flags;</a>
<a name="ln655">	hdr-&gt;hop_count = pp-&gt;hdr-&gt;hop_count - 1;</a>
<a name="ln656">	hdr-&gt;u.request_id = pp-&gt;hdr-&gt;u.request_id;</a>
<a name="ln657"> </a>
<a name="ln658">	/* Copy payload */</a>
<a name="ln659">	zbuf_copy(zb, &amp;pp-&gt;payload, zbuf_used(&amp;pp-&gt;payload));</a>
<a name="ln660"> </a>
<a name="ln661">	/* Copy extensions */</a>
<a name="ln662">	while ((ext = nhrp_ext_pull(&amp;pp-&gt;extensions, &amp;extpl)) != NULL) {</a>
<a name="ln663">		type = htons(ext-&gt;type) &amp; ~NHRP_EXTENSION_FLAG_COMPULSORY;</a>
<a name="ln664">		len = htons(ext-&gt;length);</a>
<a name="ln665"> </a>
<a name="ln666">		if (type == NHRP_EXTENSION_END)</a>
<a name="ln667">			break;</a>
<a name="ln668"> </a>
<a name="ln669">		dst = nhrp_ext_push(zb, hdr, htons(ext-&gt;type));</a>
<a name="ln670">		if (!dst) goto err;</a>
<a name="ln671"> </a>
<a name="ln672">		switch (type) {</a>
<a name="ln673">		case NHRP_EXTENSION_FORWARD_TRANSIT_NHS:</a>
<a name="ln674">		case NHRP_EXTENSION_REVERSE_TRANSIT_NHS:</a>
<a name="ln675">			zbuf_put(zb, extpl.head, len);</a>
<a name="ln676">			if ((type == NHRP_EXTENSION_REVERSE_TRANSIT_NHS) ==</a>
<a name="ln677">			    (packet_types[hdr-&gt;type].type == PACKET_REPLY)) {</a>
<a name="ln678">				/* Check NHS list for forwarding loop */</a>
<a name="ln679">				while ((cie = nhrp_cie_pull(&amp;extpl, pp-&gt;hdr, &amp;cie_nbma, &amp;cie_protocol)) != NULL) {</a>
<a name="ln680">					if (sockunion_same(&amp;p-&gt;vc-&gt;remote.nbma, &amp;cie_nbma))</a>
<a name="ln681">						goto err;</a>
<a name="ln682">				}</a>
<a name="ln683">				/* Append our selves to the list */</a>
<a name="ln684">				cie = nhrp_cie_push(zb, NHRP_CODE_SUCCESS, &amp;nifp-&gt;nbma, &amp;if_ad-&gt;addr);</a>
<a name="ln685">				if (!cie) goto err;</a>
<a name="ln686">				cie-&gt;holding_time = htons(if_ad-&gt;holdtime);</a>
<a name="ln687">			}</a>
<a name="ln688">			break;</a>
<a name="ln689">		default:</a>
<a name="ln690">			if (htons(ext-&gt;type) &amp; NHRP_EXTENSION_FLAG_COMPULSORY)</a>
<a name="ln691">				/* FIXME: RFC says to just copy, but not</a>
<a name="ln692">				 * append our selves to the transit NHS list */</a>
<a name="ln693">				goto err;</a>
<a name="ln694">		case NHRP_EXTENSION_RESPONDER_ADDRESS:</a>
<a name="ln695">			/* Supported compulsory extensions, and any</a>
<a name="ln696">			 * non-compulsory that is not explicitly handled,</a>
<a name="ln697">			 * should be just copied. */</a>
<a name="ln698">			zbuf_copy(zb, &amp;extpl, len);</a>
<a name="ln699">			break;</a>
<a name="ln700">		}</a>
<a name="ln701">		nhrp_ext_complete(zb, dst);</a>
<a name="ln702">	}</a>
<a name="ln703"> </a>
<a name="ln704">	nhrp_packet_complete(zb, hdr);</a>
<a name="ln705">	nhrp_peer_send(p, zb);</a>
<a name="ln706">	zbuf_free(zb);</a>
<a name="ln707">	return;</a>
<a name="ln708">err:</a>
<a name="ln709">	nhrp_packet_debug(pp-&gt;pkt, &quot;FWD-FAIL&quot;);</a>
<a name="ln710">	zbuf_free(zb);</a>
<a name="ln711">}</a>
<a name="ln712"> </a>
<a name="ln713">static void nhrp_packet_debug(struct zbuf *zb, const char *dir)</a>
<a name="ln714">{</a>
<a name="ln715">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln716">	union sockunion src_nbma, src_proto, dst_proto;</a>
<a name="ln717">	struct nhrp_packet_header *hdr;</a>
<a name="ln718">	struct zbuf zhdr;</a>
<a name="ln719">	int reply;</a>
<a name="ln720"> </a>
<a name="ln721">	if (likely(!(debug_flags &amp; NHRP_DEBUG_COMMON)))</a>
<a name="ln722">		return;</a>
<a name="ln723"> </a>
<a name="ln724">	zbuf_init(&amp;zhdr, zb-&gt;buf, zb-&gt;tail-zb-&gt;buf, zb-&gt;tail-zb-&gt;buf);</a>
<a name="ln725">	hdr = nhrp_packet_pull(&amp;zhdr, &amp;src_nbma, &amp;src_proto, &amp;dst_proto);</a>
<a name="ln726"> </a>
<a name="ln727">	sockunion2str(&amp;src_proto, buf[0], sizeof buf[0]);</a>
<a name="ln728">	sockunion2str(&amp;dst_proto, buf[1], sizeof buf[1]);</a>
<a name="ln729"> </a>
<a name="ln730">	reply = packet_types[hdr-&gt;type].type == PACKET_REPLY;</a>
<a name="ln731">	debugf(NHRP_DEBUG_COMMON, &quot;%s %s(%d) %s -&gt; %s&quot;,</a>
<a name="ln732">		dir,</a>
<a name="ln733">		packet_types[hdr-&gt;type].name ? : &quot;Unknown&quot;,</a>
<a name="ln734">		hdr-&gt;type,</a>
<a name="ln735">		reply ? buf[1] : buf[0],</a>
<a name="ln736">		reply ? buf[0] : buf[1]);</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">static int proto2afi(uint16_t proto)</a>
<a name="ln740">{</a>
<a name="ln741">	switch (proto) {</a>
<a name="ln742">	case ETH_P_IP: return AFI_IP;</a>
<a name="ln743">	case ETH_P_IPV6: return AFI_IP6;</a>
<a name="ln744">	}</a>
<a name="ln745">	return AF_UNSPEC;</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">struct nhrp_route_info {</a>
<a name="ln749">	int local;</a>
<a name="ln750">	struct interface *ifp;</a>
<a name="ln751">	struct nhrp_vc *vc;</a>
<a name="ln752">};</a>
<a name="ln753"> </a>
<a name="ln754">void nhrp_peer_recv(struct nhrp_peer *p, struct zbuf *zb)</a>
<a name="ln755">{</a>
<a name="ln756">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln757">	struct nhrp_packet_header *hdr;</a>
<a name="ln758">	struct nhrp_vc *vc = p-&gt;vc;</a>
<a name="ln759">	struct interface *ifp = p-&gt;ifp;</a>
<a name="ln760">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln761">	struct nhrp_packet_parser pp;</a>
<a name="ln762">	struct nhrp_peer *peer = NULL;</a>
<a name="ln763">	struct nhrp_reqid *reqid;</a>
<a name="ln764">	const char *info = NULL;</a>
<a name="ln765">	union sockunion *target_addr;</a>
<a name="ln766">	unsigned paylen, extoff, extlen, realsize;</a>
<a name="ln767">	afi_t nbma_afi, proto_afi;</a>
<a name="ln768"> </a>
<a name="ln769">	debugf(NHRP_DEBUG_KERNEL, &quot;PACKET: Recv %s -&gt; %s&quot;,</a>
<a name="ln770">		sockunion2str(&amp;vc-&gt;remote.nbma, buf[0], sizeof buf[0]),</a>
<a name="ln771">		sockunion2str(&amp;vc-&gt;local.nbma, buf[1], sizeof buf[1]));</a>
<a name="ln772"> </a>
<a name="ln773">	if (!p-&gt;online) {</a>
<a name="ln774">		info = &quot;peer not online&quot;;</a>
<a name="ln775">		goto drop;</a>
<a name="ln776">	}</a>
<a name="ln777"> </a>
<a name="ln778">	if (nhrp_packet_calculate_checksum(zb-&gt;head, zbuf_used(zb)) != 0) {</a>
<a name="ln779">		info = &quot;bad checksum&quot;;</a>
<a name="ln780">		goto drop;</a>
<a name="ln781">	}</a>
<a name="ln782"> </a>
<a name="ln783">	realsize = zbuf_used(zb);</a>
<a name="ln784">	hdr = nhrp_packet_pull(zb, &amp;pp.src_nbma, &amp;pp.src_proto, &amp;pp.dst_proto);</a>
<a name="ln785">	if (!hdr) {</a>
<a name="ln786">		info = &quot;corrupt header&quot;;</a>
<a name="ln787">		goto drop;</a>
<a name="ln788">	}</a>
<a name="ln789"> </a>
<a name="ln790">	pp.ifp = ifp;</a>
<a name="ln791">	pp.pkt = zb;</a>
<a name="ln792">	pp.hdr = hdr;</a>
<a name="ln793">	pp.peer = p;</a>
<a name="ln794"> </a>
<a name="ln795">	nbma_afi = htons(hdr-&gt;afnum);</a>
<a name="ln796">	proto_afi = proto2afi(htons(hdr-&gt;protocol_type));</a>
<a name="ln797">	if (hdr-&gt;type &gt; ZEBRA_NUM_OF(packet_types) ||</a>
<a name="ln798">	    hdr-&gt;version != NHRP_VERSION_RFC2332 ||</a>
<a name="ln799">	    nbma_afi &gt;= AFI_MAX || proto_afi == AF_UNSPEC ||</a>
<a name="ln800">	    packet_types[hdr-&gt;type].type == PACKET_UNKNOWN ||</a>
<a name="ln801">	    htons(hdr-&gt;packet_size) &gt; realsize) {</a>
<a name="ln802">		zlog_info(&quot;From %s: error: packet type %d, version %d, AFI %d, proto %x, size %d (real size %d)&quot;,</a>
<a name="ln803">			   sockunion2str(&amp;vc-&gt;remote.nbma, buf[0], sizeof buf[0]),</a>
<a name="ln804">			   (int) hdr-&gt;type, (int) hdr-&gt;version,</a>
<a name="ln805">			   (int) nbma_afi, (int) htons(hdr-&gt;protocol_type),</a>
<a name="ln806">			   (int) htons(hdr-&gt;packet_size), (int) realsize);</a>
<a name="ln807">		goto drop;</a>
<a name="ln808">	}</a>
<a name="ln809">	pp.if_ad = &amp;((struct nhrp_interface *)ifp-&gt;info)-&gt;afi[proto_afi];</a>
<a name="ln810"> </a>
<a name="ln811">	extoff = htons(hdr-&gt;extension_offset);</a>
<a name="ln812">	if (extoff) {</a>
<a name="ln813">		if (extoff &gt;= realsize) {</a>
<a name="ln814">			info = &quot;extoff larger than packet&quot;;</a>
<a name="ln815">			goto drop;</a>
<a name="ln816">		}</a>
<a name="ln817">		paylen = extoff - (zb-&gt;head - zb-&gt;buf);</a>
<a name="ln818">	} else {</a>
<a name="ln819">		paylen = zbuf_used(zb);</a>
<a name="ln820">	}</a>
<a name="ln821">	zbuf_init(&amp;pp.payload, zbuf_pulln(zb, paylen), paylen, paylen);</a>
<a name="ln822">	extlen = zbuf_used(zb);</a>
<a name="ln823">	zbuf_init(&amp;pp.extensions, zbuf_pulln(zb, extlen), extlen, extlen);</a>
<a name="ln824"> </a>
<a name="ln825">	if (!nifp-&gt;afi[proto_afi].network_id) {</a>
<a name="ln826">		info = &quot;nhrp not enabled&quot;;</a>
<a name="ln827">		goto drop;</a>
<a name="ln828">	}</a>
<a name="ln829"> </a>
<a name="ln830">	nhrp_packet_debug(zb, &quot;Recv&quot;);</a>
<a name="ln831"> </a>
<a name="ln832">	/* FIXME: Check authentication here. This extension needs to be</a>
<a name="ln833">	 * pre-handled. */</a>
<a name="ln834"> </a>
<a name="ln835">	/* Figure out if this is local */</a>
<a name="ln836">	target_addr = (packet_types[hdr-&gt;type].type == PACKET_REPLY) ? &amp;pp.src_proto : &amp;pp.dst_proto;</a>
<a name="ln837"> </a>
<a name="ln838">	if (sockunion_same(&amp;pp.src_proto, &amp;pp.dst_proto))</a>
<a name="ln839">		pp.route_type = NHRP_ROUTE_LOCAL;</a>
<a name="ln840">	else</a>
<a name="ln841">		pp.route_type = nhrp_route_address(pp.ifp, target_addr, &amp;pp.route_prefix, &amp;peer);</a>
<a name="ln842"> </a>
<a name="ln843">	switch (pp.route_type) {</a>
<a name="ln844">	case NHRP_ROUTE_LOCAL:</a>
<a name="ln845">		nhrp_packet_debug(zb, &quot;!LOCAL&quot;);</a>
<a name="ln846">		if (packet_types[hdr-&gt;type].type == PACKET_REPLY) {</a>
<a name="ln847">			reqid = nhrp_reqid_lookup(&amp;nhrp_packet_reqid, htonl(hdr-&gt;u.request_id));</a>
<a name="ln848">			if (reqid) {</a>
<a name="ln849">				reqid-&gt;cb(reqid, &amp;pp);</a>
<a name="ln850">				break;</a>
<a name="ln851">			} else {</a>
<a name="ln852">				nhrp_packet_debug(zb, &quot;!UNKNOWN-REQID&quot;);</a>
<a name="ln853">				/* FIXME: send error-indication */</a>
<a name="ln854">			}</a>
<a name="ln855">		}</a>
<a name="ln856">	case NHRP_ROUTE_OFF_NBMA:</a>
<a name="ln857">		if (packet_types[hdr-&gt;type].handler) {</a>
<a name="ln858">			packet_types[hdr-&gt;type].handler(&amp;pp);</a>
<a name="ln859">			break;</a>
<a name="ln860">		}</a>
<a name="ln861">		break;</a>
<a name="ln862">	case NHRP_ROUTE_NBMA_NEXTHOP:</a>
<a name="ln863">		nhrp_peer_forward(peer, &amp;pp);</a>
<a name="ln864">		break;</a>
<a name="ln865">	case NHRP_ROUTE_BLACKHOLE:</a>
<a name="ln866">		break;</a>
<a name="ln867">	}</a>
<a name="ln868"> </a>
<a name="ln869">drop:</a>
<a name="ln870">	if (info) {</a>
<a name="ln871">		zlog_info(&quot;From %s: error: %s&quot;,</a>
<a name="ln872">			  sockunion2str(&amp;vc-&gt;remote.nbma, buf[0], sizeof buf[0]),</a>
<a name="ln873">			  info);</a>
<a name="ln874">	}</a>
<a name="ln875">	if (peer) nhrp_peer_unref(peer);</a>
<a name="ln876">	zbuf_free(zb);</a>
<a name="ln877">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="800"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'hdr->type' index could reach 9.</p></div>
<div class="balloon" rel="836"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'hdr->type' index could reach 9.</p></div>
<div class="balloon" rel="846"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'hdr->type' index could reach 9.</p></div>
<div class="balloon" rel="857"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'hdr->type' index could reach 9.</p></div>
<div class="balloon" rel="858"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'hdr->type' index could reach 9.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
