
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_ecommunity.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP Extended Communities Attribute</a>
<a name="ln2">   Copyright (C) 2000 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;hash.h&quot;</a>
<a name="ln24">#include &quot;memory.h&quot;</a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;filter.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln30">#include &quot;bgpd/bgp_ecommunity.h&quot;</a>
<a name="ln31">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">/* Hash of community attribute. */</a>
<a name="ln34">static struct hash *ecomhash;</a>
<a name="ln35"> </a>
<a name="ln36">/* Allocate a new ecommunities.  */</a>
<a name="ln37">static struct ecommunity *</a>
<a name="ln38">ecommunity_new (void)</a>
<a name="ln39">{</a>
<a name="ln40">  return (struct ecommunity *) XCALLOC (MTYPE_ECOMMUNITY,</a>
<a name="ln41">					sizeof (struct ecommunity));</a>
<a name="ln42">}</a>
<a name="ln43"> </a>
<a name="ln44">/* Allocate ecommunities.  */</a>
<a name="ln45">void</a>
<a name="ln46">ecommunity_free (struct ecommunity **ecom)</a>
<a name="ln47">{</a>
<a name="ln48">  if ((*ecom)-&gt;val)</a>
<a name="ln49">    XFREE (MTYPE_ECOMMUNITY_VAL, (*ecom)-&gt;val);</a>
<a name="ln50">  if ((*ecom)-&gt;str)</a>
<a name="ln51">    XFREE (MTYPE_ECOMMUNITY_STR, (*ecom)-&gt;str);</a>
<a name="ln52">  XFREE (MTYPE_ECOMMUNITY, *ecom);</a>
<a name="ln53">  ecom = NULL;</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56">/* Add a new Extended Communities value to Extended Communities</a>
<a name="ln57">   Attribute structure.  When the value is already exists in the</a>
<a name="ln58">   structure, we don't add the value.  Newly added value is sorted by</a>
<a name="ln59">   numerical order.  When the value is added to the structure return 1</a>
<a name="ln60">   else return 0.  */</a>
<a name="ln61">static int</a>
<a name="ln62">ecommunity_add_val (struct ecommunity *ecom, struct ecommunity_val *eval)</a>
<a name="ln63">{</a>
<a name="ln64">  u_int8_t *p;</a>
<a name="ln65">  int ret;</a>
<a name="ln66">  int c;</a>
<a name="ln67"> </a>
<a name="ln68">  /* When this is fist value, just add it.  */</a>
<a name="ln69">  if (ecom-&gt;val == NULL)</a>
<a name="ln70">    {</a>
<a name="ln71">      ecom-&gt;size++;</a>
<a name="ln72">      ecom-&gt;val = XMALLOC (MTYPE_ECOMMUNITY_VAL, ecom_length (ecom));</a>
<a name="ln73">      memcpy (ecom-&gt;val, eval-&gt;val, ECOMMUNITY_SIZE);</a>
<a name="ln74">      return 1;</a>
<a name="ln75">    }</a>
<a name="ln76"> </a>
<a name="ln77">  /* If the value already exists in the structure return 0.  */</a>
<a name="ln78">  c = 0;</a>
<a name="ln79">  for (p = ecom-&gt;val; c &lt; ecom-&gt;size; p += ECOMMUNITY_SIZE, c++)</a>
<a name="ln80">    {</a>
<a name="ln81">      ret = memcmp (p, eval-&gt;val, ECOMMUNITY_SIZE);</a>
<a name="ln82">      if (ret == 0)</a>
<a name="ln83">        return 0;</a>
<a name="ln84">      if (ret &gt; 0)</a>
<a name="ln85">        break;</a>
<a name="ln86">    }</a>
<a name="ln87"> </a>
<a name="ln88">  /* Add the value to the structure with numerical sorting.  */</a>
<a name="ln89">  ecom-&gt;size++;</a>
<a name="ln90">  ecom-&gt;val = XREALLOC (MTYPE_ECOMMUNITY_VAL, ecom-&gt;val, ecom_length (ecom));</a>
<a name="ln91"> </a>
<a name="ln92">  memmove (ecom-&gt;val + (c + 1) * ECOMMUNITY_SIZE,</a>
<a name="ln93">	   ecom-&gt;val + c * ECOMMUNITY_SIZE,</a>
<a name="ln94">	   (ecom-&gt;size - 1 - c) * ECOMMUNITY_SIZE);</a>
<a name="ln95">  memcpy (ecom-&gt;val + c * ECOMMUNITY_SIZE, eval-&gt;val, ECOMMUNITY_SIZE);</a>
<a name="ln96"> </a>
<a name="ln97">  return 1;</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">/* This function takes pointer to Extended Communites strucutre then</a>
<a name="ln101">   create a new Extended Communities structure by uniq and sort each</a>
<a name="ln102">   Extended Communities value.  */</a>
<a name="ln103">struct ecommunity *</a>
<a name="ln104">ecommunity_uniq_sort (struct ecommunity *ecom)</a>
<a name="ln105">{</a>
<a name="ln106">  int i;</a>
<a name="ln107">  struct ecommunity *new;</a>
<a name="ln108">  struct ecommunity_val *eval;</a>
<a name="ln109">  </a>
<a name="ln110">  if (! ecom)</a>
<a name="ln111">    return NULL;</a>
<a name="ln112">  </a>
<a name="ln113">  new = ecommunity_new ();</a>
<a name="ln114">  </a>
<a name="ln115">  for (i = 0; i &lt; ecom-&gt;size; i++)</a>
<a name="ln116">    {</a>
<a name="ln117">      eval = (struct ecommunity_val *) (ecom-&gt;val + (i * ECOMMUNITY_SIZE));</a>
<a name="ln118">      ecommunity_add_val (new, eval);</a>
<a name="ln119">    }</a>
<a name="ln120">  return new;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">/* Parse Extended Communites Attribute in BGP packet.  */</a>
<a name="ln124">struct ecommunity *</a>
<a name="ln125">ecommunity_parse (u_int8_t *pnt, u_short length)</a>
<a name="ln126">{</a>
<a name="ln127">  struct ecommunity tmp;</a>
<a name="ln128">  struct ecommunity *new;</a>
<a name="ln129"> </a>
<a name="ln130">  /* Length check.  */</a>
<a name="ln131">  if (length % ECOMMUNITY_SIZE)</a>
<a name="ln132">    return NULL;</a>
<a name="ln133"> </a>
<a name="ln134">  /* Prepare tmporary structure for making a new Extended Communities</a>
<a name="ln135">     Attribute.  */</a>
<a name="ln136">  tmp.size = length / ECOMMUNITY_SIZE;</a>
<a name="ln137">  tmp.val = pnt;</a>
<a name="ln138"> </a>
<a name="ln139">  /* Create a new Extended Communities Attribute by uniq and sort each</a>
<a name="ln140">     Extended Communities value  */</a>
<a name="ln141">  new = ecommunity_uniq_sort (&amp;tmp);</a>
<a name="ln142"> </a>
<a name="ln143">  return ecommunity_intern (new);</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">/* Duplicate the Extended Communities Attribute structure.  */</a>
<a name="ln147">struct ecommunity *</a>
<a name="ln148">ecommunity_dup (struct ecommunity *ecom)</a>
<a name="ln149">{</a>
<a name="ln150">  struct ecommunity *new;</a>
<a name="ln151"> </a>
<a name="ln152">  new = XCALLOC (MTYPE_ECOMMUNITY, sizeof (struct ecommunity));</a>
<a name="ln153">  new-&gt;size = ecom-&gt;size;</a>
<a name="ln154">  if (new-&gt;size)</a>
<a name="ln155">    {</a>
<a name="ln156">      new-&gt;val = XMALLOC (MTYPE_ECOMMUNITY_VAL, ecom-&gt;size * ECOMMUNITY_SIZE);</a>
<a name="ln157">      memcpy (new-&gt;val, ecom-&gt;val, ecom-&gt;size * ECOMMUNITY_SIZE);</a>
<a name="ln158">    }</a>
<a name="ln159">  else</a>
<a name="ln160">    new-&gt;val = NULL;</a>
<a name="ln161">  return new;</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">/* Retrun string representation of communities attribute. */</a>
<a name="ln165">char *</a>
<a name="ln166">ecommunity_str (struct ecommunity *ecom)</a>
<a name="ln167">{</a>
<a name="ln168">  if (! ecom-&gt;str)</a>
<a name="ln169">    ecom-&gt;str = ecommunity_ecom2str (ecom, ECOMMUNITY_FORMAT_DISPLAY);</a>
<a name="ln170">  return ecom-&gt;str;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">/* Merge two Extended Communities Attribute structure.  */</a>
<a name="ln174">struct ecommunity *</a>
<a name="ln175">ecommunity_merge (struct ecommunity *ecom1, struct ecommunity *ecom2)</a>
<a name="ln176">{</a>
<a name="ln177">  if (ecom1-&gt;val)</a>
<a name="ln178">    ecom1-&gt;val = XREALLOC (MTYPE_ECOMMUNITY_VAL, ecom1-&gt;val, </a>
<a name="ln179">			   (ecom1-&gt;size + ecom2-&gt;size) * ECOMMUNITY_SIZE);</a>
<a name="ln180">  else</a>
<a name="ln181">    ecom1-&gt;val = XMALLOC (MTYPE_ECOMMUNITY_VAL,</a>
<a name="ln182">			  (ecom1-&gt;size + ecom2-&gt;size) * ECOMMUNITY_SIZE);</a>
<a name="ln183"> </a>
<a name="ln184">  memcpy (ecom1-&gt;val + (ecom1-&gt;size * ECOMMUNITY_SIZE),</a>
<a name="ln185">	  ecom2-&gt;val, ecom2-&gt;size * ECOMMUNITY_SIZE);</a>
<a name="ln186">  ecom1-&gt;size += ecom2-&gt;size;</a>
<a name="ln187"> </a>
<a name="ln188">  return ecom1;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">/* Intern Extended Communities Attribute.  */</a>
<a name="ln192">struct ecommunity *</a>
<a name="ln193">ecommunity_intern (struct ecommunity *ecom)</a>
<a name="ln194">{</a>
<a name="ln195">  struct ecommunity *find;</a>
<a name="ln196"> </a>
<a name="ln197">  assert (ecom-&gt;refcnt == 0);</a>
<a name="ln198"> </a>
<a name="ln199">  find = (struct ecommunity *) hash_get (ecomhash, ecom, hash_alloc_intern);</a>
<a name="ln200"> </a>
<a name="ln201">  if (find != ecom)</a>
<a name="ln202">    ecommunity_free (&amp;ecom);</a>
<a name="ln203"> </a>
<a name="ln204">  find-&gt;refcnt++;</a>
<a name="ln205"> </a>
<a name="ln206">  if (! find-&gt;str)</a>
<a name="ln207">    find-&gt;str = ecommunity_ecom2str (find, ECOMMUNITY_FORMAT_DISPLAY);</a>
<a name="ln208"> </a>
<a name="ln209">  return find;</a>
<a name="ln210">}</a>
<a name="ln211"> </a>
<a name="ln212">/* Unintern Extended Communities Attribute.  */</a>
<a name="ln213">void</a>
<a name="ln214">ecommunity_unintern (struct ecommunity **ecom)</a>
<a name="ln215">{</a>
<a name="ln216">  struct ecommunity *ret;</a>
<a name="ln217"> </a>
<a name="ln218">  if ((*ecom)-&gt;refcnt)</a>
<a name="ln219">    (*ecom)-&gt;refcnt--;</a>
<a name="ln220">    </a>
<a name="ln221">  /* Pull off from hash.  */</a>
<a name="ln222">  if ((*ecom)-&gt;refcnt == 0)</a>
<a name="ln223">    {</a>
<a name="ln224">      /* Extended community must be in the hash.  */</a>
<a name="ln225">      ret = (struct ecommunity *) hash_release (ecomhash, *ecom);</a>
<a name="ln226">      assert (ret != NULL);</a>
<a name="ln227"> </a>
<a name="ln228">      ecommunity_free (ecom);</a>
<a name="ln229">    }</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">/* Utinity function to make hash key.  */</a>
<a name="ln233">unsigned int</a>
<a name="ln234">ecommunity_hash_make (void *arg)</a>
<a name="ln235">{</a>
<a name="ln236">  const struct ecommunity *ecom = arg;</a>
<a name="ln237">  int size = ecom-&gt;size * ECOMMUNITY_SIZE;</a>
<a name="ln238">  u_int8_t *pnt = ecom-&gt;val;</a>
<a name="ln239">  unsigned int key = 0;</a>
<a name="ln240">  int c;</a>
<a name="ln241"> </a>
<a name="ln242">  for (c = 0; c &lt; size; c += ECOMMUNITY_SIZE)</a>
<a name="ln243">    {</a>
<a name="ln244">      key += pnt[c];</a>
<a name="ln245">      key += pnt[c + 1];</a>
<a name="ln246">      key += pnt[c + 2];</a>
<a name="ln247">      key += pnt[c + 3];</a>
<a name="ln248">      key += pnt[c + 4];</a>
<a name="ln249">      key += pnt[c + 5];</a>
<a name="ln250">      key += pnt[c + 6];</a>
<a name="ln251">      key += pnt[c + 7];</a>
<a name="ln252">    }</a>
<a name="ln253"> </a>
<a name="ln254">  return key;</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">/* Compare two Extended Communities Attribute structure.  */</a>
<a name="ln258">int</a>
<a name="ln259">ecommunity_cmp (const void *arg1, const void *arg2)</a>
<a name="ln260">{</a>
<a name="ln261">  const struct ecommunity *ecom1 = arg1;</a>
<a name="ln262">  const struct ecommunity *ecom2 = arg2;</a>
<a name="ln263">  </a>
<a name="ln264">  return (ecom1-&gt;size == ecom2-&gt;size</a>
<a name="ln265">	  &amp;&amp; memcmp (ecom1-&gt;val, ecom2-&gt;val, ecom1-&gt;size * ECOMMUNITY_SIZE) == 0);</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">/* Initialize Extended Comminities related hash. */</a>
<a name="ln269">void</a>
<a name="ln270">ecommunity_init (void)</a>
<a name="ln271">{</a>
<a name="ln272">  ecomhash = hash_create (ecommunity_hash_make, ecommunity_cmp);</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">void</a>
<a name="ln276">ecommunity_finish (void)</a>
<a name="ln277">{</a>
<a name="ln278">  hash_free (ecomhash);</a>
<a name="ln279">  ecomhash = NULL;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">/* Extended Communities token enum. */</a>
<a name="ln283">enum ecommunity_token</a>
<a name="ln284">{</a>
<a name="ln285">  ecommunity_token_unknown = 0,</a>
<a name="ln286">  ecommunity_token_rt,</a>
<a name="ln287">  ecommunity_token_soo,</a>
<a name="ln288">  ecommunity_token_val,</a>
<a name="ln289">};</a>
<a name="ln290"> </a>
<a name="ln291">/* Get next Extended Communities token from the string. */</a>
<a name="ln292">static const char *</a>
<a name="ln293">ecommunity_gettoken (const char *str, struct ecommunity_val *eval,</a>
<a name="ln294">		     enum ecommunity_token *token)</a>
<a name="ln295">{</a>
<a name="ln296">  int ret;</a>
<a name="ln297">  int dot = 0;</a>
<a name="ln298">  int digit = 0;</a>
<a name="ln299">  int separator = 0;</a>
<a name="ln300">  const char *p = str;</a>
<a name="ln301">  char *endptr;</a>
<a name="ln302">  struct in_addr ip;</a>
<a name="ln303">  as_t as = 0;</a>
<a name="ln304">  u_int32_t val = 0;</a>
<a name="ln305">  char buf[INET_ADDRSTRLEN + 1];</a>
<a name="ln306"> </a>
<a name="ln307">  /* Skip white space. */</a>
<a name="ln308">  while (isspace ((int) *p))</a>
<a name="ln309">    {</a>
<a name="ln310">      p++;</a>
<a name="ln311">      str++;</a>
<a name="ln312">    }</a>
<a name="ln313"> </a>
<a name="ln314">  /* Check the end of the line. */</a>
<a name="ln315">  if (*p == '\0')</a>
<a name="ln316">    return NULL;</a>
<a name="ln317"> </a>
<a name="ln318">  /* &quot;rt&quot; and &quot;soo&quot; keyword parse. */</a>
<a name="ln319">  if (! isdigit ((int) *p)) </a>
<a name="ln320">    {</a>
<a name="ln321">      /* &quot;rt&quot; match check.  */</a>
<a name="ln322">      if (tolower ((int) *p) == 'r')</a>
<a name="ln323">	{</a>
<a name="ln324">	  p++;</a>
<a name="ln325"> 	  if (tolower ((int) *p) == 't')</a>
<a name="ln326">	    {</a>
<a name="ln327">	      p++;</a>
<a name="ln328">	      *token = ecommunity_token_rt;</a>
<a name="ln329">	      return p;</a>
<a name="ln330">	    }</a>
<a name="ln331">	  if (isspace ((int) *p) || *p == '\0')</a>
<a name="ln332">	    {</a>
<a name="ln333">	      *token = ecommunity_token_rt;</a>
<a name="ln334">	      return p;</a>
<a name="ln335">	    }</a>
<a name="ln336">	  goto error;</a>
<a name="ln337">	}</a>
<a name="ln338">      /* &quot;soo&quot; match check.  */</a>
<a name="ln339">      else if (tolower ((int) *p) == 's')</a>
<a name="ln340">	{</a>
<a name="ln341">	  p++;</a>
<a name="ln342"> 	  if (tolower ((int) *p) == 'o')</a>
<a name="ln343">	    {</a>
<a name="ln344">	      p++;</a>
<a name="ln345">	      if (tolower ((int) *p) == 'o')</a>
<a name="ln346">		{</a>
<a name="ln347">		  p++;</a>
<a name="ln348">		  *token = ecommunity_token_soo;</a>
<a name="ln349">		  return p;</a>
<a name="ln350">		}</a>
<a name="ln351">	      if (isspace ((int) *p) || *p == '\0')</a>
<a name="ln352">		{</a>
<a name="ln353">		  *token = ecommunity_token_soo;</a>
<a name="ln354">		  return p;</a>
<a name="ln355">		}</a>
<a name="ln356">	      goto error;</a>
<a name="ln357">	    }</a>
<a name="ln358">	  if (isspace ((int) *p) || *p == '\0')</a>
<a name="ln359">	    {</a>
<a name="ln360">	      *token = ecommunity_token_soo;</a>
<a name="ln361">	      return p;</a>
<a name="ln362">	    }</a>
<a name="ln363">	  goto error;</a>
<a name="ln364">	}</a>
<a name="ln365">      goto error;</a>
<a name="ln366">    }</a>
<a name="ln367">  </a>
<a name="ln368">  /* What a mess, there are several possibilities:</a>
<a name="ln369">   *</a>
<a name="ln370">   * a) A.B.C.D:MN</a>
<a name="ln371">   * b) EF:OPQR</a>
<a name="ln372">   * c) GHJK:MN</a>
<a name="ln373">   *</a>
<a name="ln374">   * A.B.C.D: Four Byte IP</a>
<a name="ln375">   * EF:      Two byte ASN</a>
<a name="ln376">   * GHJK:    Four-byte ASN</a>
<a name="ln377">   * MN:      Two byte value</a>
<a name="ln378">   * OPQR:    Four byte value</a>
<a name="ln379">   *</a>
<a name="ln380">   */</a>
<a name="ln381">  while (isdigit ((int) *p) || *p == ':' || *p == '.') </a>
<a name="ln382">    {</a>
<a name="ln383">      if (*p == ':')</a>
<a name="ln384">	{</a>
<a name="ln385">	  if (separator)</a>
<a name="ln386">	    goto error;</a>
<a name="ln387"> </a>
<a name="ln388">	  separator = 1;</a>
<a name="ln389">	  digit = 0;</a>
<a name="ln390">	  </a>
<a name="ln391">	  if ((p - str) &gt; INET_ADDRSTRLEN)</a>
<a name="ln392">	    goto error;</a>
<a name="ln393">          memset (buf, 0, INET_ADDRSTRLEN + 1);</a>
<a name="ln394">          memcpy (buf, str, p - str);</a>
<a name="ln395">          </a>
<a name="ln396">	  if (dot)</a>
<a name="ln397">	    {</a>
<a name="ln398">	      /* Parsing A.B.C.D in:</a>
<a name="ln399">               * A.B.C.D:MN</a>
<a name="ln400">               */</a>
<a name="ln401">	      ret = inet_aton (buf, &amp;ip);</a>
<a name="ln402">	      if (ret == 0)</a>
<a name="ln403">	        goto error;</a>
<a name="ln404">	    }</a>
<a name="ln405">          else</a>
<a name="ln406">            {</a>
<a name="ln407">              /* ASN */</a>
<a name="ln408">              as = strtoul (buf, &amp;endptr, 10);</a>
<a name="ln409">              if (*endptr != '\0' || as == BGP_AS4_MAX)</a>
<a name="ln410">                goto error;</a>
<a name="ln411">            }</a>
<a name="ln412">	}</a>
<a name="ln413">      else if (*p == '.')</a>
<a name="ln414">	{</a>
<a name="ln415">	  if (separator)</a>
<a name="ln416">	    goto error;</a>
<a name="ln417">	  dot++;</a>
<a name="ln418">	  if (dot &gt; 4)</a>
<a name="ln419">	    goto error;</a>
<a name="ln420">	}</a>
<a name="ln421">      else</a>
<a name="ln422">	{</a>
<a name="ln423">	  digit = 1;</a>
<a name="ln424">	  </a>
<a name="ln425">	  /* We're past the IP/ASN part */</a>
<a name="ln426">	  if (separator)</a>
<a name="ln427">	    {</a>
<a name="ln428">	      val *= 10;</a>
<a name="ln429">	      val += (*p - '0');</a>
<a name="ln430">            }</a>
<a name="ln431">	}</a>
<a name="ln432">      p++;</a>
<a name="ln433">    }</a>
<a name="ln434"> </a>
<a name="ln435">  /* Low digit part must be there. */</a>
<a name="ln436">  if (!digit || !separator)</a>
<a name="ln437">    goto error;</a>
<a name="ln438"> </a>
<a name="ln439">  /* Encode result into routing distinguisher.  */</a>
<a name="ln440">  if (dot)</a>
<a name="ln441">    {</a>
<a name="ln442">      if (val &gt; UINT16_MAX)</a>
<a name="ln443">        goto error;</a>
<a name="ln444">      </a>
<a name="ln445">      eval-&gt;val[0] = ECOMMUNITY_ENCODE_IP;</a>
<a name="ln446">      eval-&gt;val[1] = 0;</a>
<a name="ln447">      memcpy (&amp;eval-&gt;val[2], &amp;ip, sizeof (struct in_addr));</a>
<a name="ln448">      eval-&gt;val[6] = (val &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln449">      eval-&gt;val[7] = val &amp; 0xff;</a>
<a name="ln450">    }</a>
<a name="ln451">  else if (as &gt; BGP_AS_MAX)</a>
<a name="ln452">    {</a>
<a name="ln453">      if (val &gt; UINT16_MAX)</a>
<a name="ln454">        goto error;</a>
<a name="ln455">      </a>
<a name="ln456">      eval-&gt;val[0] = ECOMMUNITY_ENCODE_AS4;</a>
<a name="ln457">      eval-&gt;val[1] = 0;</a>
<a name="ln458">      eval-&gt;val[2] = (as &gt;&gt;24) &amp; 0xff;</a>
<a name="ln459">      eval-&gt;val[3] = (as &gt;&gt;16) &amp; 0xff;</a>
<a name="ln460">      eval-&gt;val[4] = (as &gt;&gt;8) &amp; 0xff;</a>
<a name="ln461">      eval-&gt;val[5] =  as &amp; 0xff;</a>
<a name="ln462">      eval-&gt;val[6] = (val &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln463">      eval-&gt;val[7] = val &amp; 0xff;</a>
<a name="ln464">    }</a>
<a name="ln465">  else</a>
<a name="ln466">    {</a>
<a name="ln467">      eval-&gt;val[0] = ECOMMUNITY_ENCODE_AS;</a>
<a name="ln468">      eval-&gt;val[1] = 0;</a>
<a name="ln469">      </a>
<a name="ln470">      eval-&gt;val[2] = (as &gt;&gt;8) &amp; 0xff;</a>
<a name="ln471">      eval-&gt;val[3] = as &amp; 0xff;</a>
<a name="ln472">      eval-&gt;val[4] = (val &gt;&gt;24) &amp; 0xff;</a>
<a name="ln473">      eval-&gt;val[5] = (val &gt;&gt;16) &amp; 0xff;</a>
<a name="ln474">      eval-&gt;val[6] = (val &gt;&gt;8) &amp; 0xff;</a>
<a name="ln475">      eval-&gt;val[7] = val &amp; 0xff;</a>
<a name="ln476">    }</a>
<a name="ln477">  *token = ecommunity_token_val;</a>
<a name="ln478">  return p;</a>
<a name="ln479"> </a>
<a name="ln480"> error:</a>
<a name="ln481">  *token = ecommunity_token_unknown;</a>
<a name="ln482">  return p;</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">/* Convert string to extended community attribute. </a>
<a name="ln486"> </a>
<a name="ln487">   When type is already known, please specify both str and type.  str</a>
<a name="ln488">   should not include keyword such as &quot;rt&quot; and &quot;soo&quot;.  Type is</a>
<a name="ln489">   ECOMMUNITY_ROUTE_TARGET or ECOMMUNITY_SITE_ORIGIN.</a>
<a name="ln490">   keyword_included should be zero.</a>
<a name="ln491"> </a>
<a name="ln492">   For example route-map's &quot;set extcommunity&quot; command case:</a>
<a name="ln493"> </a>
<a name="ln494">   &quot;rt 100:1 100:2 100:3&quot;        -&gt; str = &quot;100:1 100:2 100:3&quot;</a>
<a name="ln495">                                    type = ECOMMUNITY_ROUTE_TARGET</a>
<a name="ln496">                                    keyword_included = 0</a>
<a name="ln497"> </a>
<a name="ln498">   &quot;soo 100:1&quot;                   -&gt; str = &quot;100:1&quot;</a>
<a name="ln499">                                    type = ECOMMUNITY_SITE_ORIGIN</a>
<a name="ln500">                                    keyword_included = 0</a>
<a name="ln501"> </a>
<a name="ln502">   When string includes keyword for each extended community value.</a>
<a name="ln503">   Please specify keyword_included as non-zero value.</a>
<a name="ln504"> </a>
<a name="ln505">   For example standard extcommunity-list case:</a>
<a name="ln506"> </a>
<a name="ln507">   &quot;rt 100:1 rt 100:2 soo 100:1&quot; -&gt; str = &quot;rt 100:1 rt 100:2 soo 100:1&quot;</a>
<a name="ln508">                                    type = 0</a>
<a name="ln509">                                    keyword_include = 1</a>
<a name="ln510">*/</a>
<a name="ln511">struct ecommunity *</a>
<a name="ln512">ecommunity_str2com (const char *str, int type, int keyword_included)</a>
<a name="ln513">{</a>
<a name="ln514">  struct ecommunity *ecom = NULL;</a>
<a name="ln515">  enum ecommunity_token token = ecommunity_token_unknown;</a>
<a name="ln516">  struct ecommunity_val eval;</a>
<a name="ln517">  int keyword = 0;</a>
<a name="ln518"> </a>
<a name="ln519">  while ((str = ecommunity_gettoken (str, &amp;eval, &amp;token)))</a>
<a name="ln520">    {</a>
<a name="ln521">      switch (token)</a>
<a name="ln522">	{</a>
<a name="ln523">	case ecommunity_token_rt:</a>
<a name="ln524">	case ecommunity_token_soo:</a>
<a name="ln525">	  if (! keyword_included || keyword)</a>
<a name="ln526">	    {</a>
<a name="ln527">	      if (ecom)</a>
<a name="ln528">		ecommunity_free (&amp;ecom);</a>
<a name="ln529">	      return NULL;</a>
<a name="ln530">	    }</a>
<a name="ln531">	  keyword = 1;</a>
<a name="ln532"> </a>
<a name="ln533">	  if (token == ecommunity_token_rt)</a>
<a name="ln534">	    {</a>
<a name="ln535">	      type = ECOMMUNITY_ROUTE_TARGET;</a>
<a name="ln536">	    }</a>
<a name="ln537">	  if (token == ecommunity_token_soo)</a>
<a name="ln538">	    {</a>
<a name="ln539">	      type = ECOMMUNITY_SITE_ORIGIN;</a>
<a name="ln540">	    }</a>
<a name="ln541">	  break;</a>
<a name="ln542">	case ecommunity_token_val:</a>
<a name="ln543">	  if (keyword_included)</a>
<a name="ln544">	    {</a>
<a name="ln545">	      if (! keyword)</a>
<a name="ln546">		{</a>
<a name="ln547">		  if (ecom)</a>
<a name="ln548">		    ecommunity_free (&amp;ecom);</a>
<a name="ln549">		  return NULL;</a>
<a name="ln550">		}</a>
<a name="ln551">	      keyword = 0;</a>
<a name="ln552">	    }</a>
<a name="ln553">	  if (ecom == NULL)</a>
<a name="ln554">	    ecom = ecommunity_new ();</a>
<a name="ln555">	  eval.val[1] = type;</a>
<a name="ln556">	  ecommunity_add_val (ecom, &amp;eval);</a>
<a name="ln557">	  break;</a>
<a name="ln558">	case ecommunity_token_unknown:</a>
<a name="ln559">	default:</a>
<a name="ln560">	  if (ecom)</a>
<a name="ln561">	    ecommunity_free (&amp;ecom);</a>
<a name="ln562">	  return NULL;</a>
<a name="ln563">	}</a>
<a name="ln564">    }</a>
<a name="ln565">  return ecom;</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">/* Convert extended community attribute to string.  </a>
<a name="ln569"> </a>
<a name="ln570">   Due to historical reason of industry standard implementation, there</a>
<a name="ln571">   are three types of format.</a>
<a name="ln572"> </a>
<a name="ln573">   route-map set extcommunity format</a>
<a name="ln574">        &quot;rt 100:1 100:2&quot;</a>
<a name="ln575">        &quot;soo 100:3&quot;</a>
<a name="ln576"> </a>
<a name="ln577">   extcommunity-list</a>
<a name="ln578">        &quot;rt 100:1 rt 100:2 soo 100:3&quot;</a>
<a name="ln579"> </a>
<a name="ln580">   &quot;show ip bgp&quot; and extcommunity-list regular expression matching</a>
<a name="ln581">        &quot;RT:100:1 RT:100:2 SoO:100:3&quot;</a>
<a name="ln582"> </a>
<a name="ln583">   For each formath please use below definition for format:</a>
<a name="ln584"> </a>
<a name="ln585">   ECOMMUNITY_FORMAT_ROUTE_MAP</a>
<a name="ln586">   ECOMMUNITY_FORMAT_COMMUNITY_LIST</a>
<a name="ln587">   ECOMMUNITY_FORMAT_DISPLAY</a>
<a name="ln588">*/</a>
<a name="ln589">char *</a>
<a name="ln590">ecommunity_ecom2str (struct ecommunity *ecom, int format)</a>
<a name="ln591">{</a>
<a name="ln592">  int i;</a>
<a name="ln593">  u_int8_t *pnt;</a>
<a name="ln594">  int encode = 0;</a>
<a name="ln595">  int type = 0;</a>
<a name="ln596">#define ECOMMUNITY_STR_DEFAULT_LEN  27</a>
<a name="ln597">  int str_size;</a>
<a name="ln598">  int str_pnt;</a>
<a name="ln599">  char *str_buf;</a>
<a name="ln600">  const char *prefix;</a>
<a name="ln601">  int len = 0;</a>
<a name="ln602">  int first = 1;</a>
<a name="ln603"> </a>
<a name="ln604">  /* For parse Extended Community attribute tupple. */</a>
<a name="ln605">  struct ecommunity_as</a>
<a name="ln606">  {</a>
<a name="ln607">    as_t as;</a>
<a name="ln608">    u_int32_t val;</a>
<a name="ln609">  } eas;</a>
<a name="ln610"> </a>
<a name="ln611">  struct ecommunity_ip</a>
<a name="ln612">  {</a>
<a name="ln613">    struct in_addr ip;</a>
<a name="ln614">    u_int16_t val;</a>
<a name="ln615">  } eip;</a>
<a name="ln616"> </a>
<a name="ln617">  if (ecom-&gt;size == 0)</a>
<a name="ln618">    {</a>
<a name="ln619">      str_buf = XMALLOC (MTYPE_ECOMMUNITY_STR, 1);</a>
<a name="ln620">      str_buf[0] = '\0';</a>
<a name="ln621">      return str_buf;</a>
<a name="ln622">    }</a>
<a name="ln623"> </a>
<a name="ln624">  /* Prepare buffer.  */</a>
<a name="ln625">  str_buf = XMALLOC (MTYPE_ECOMMUNITY_STR, ECOMMUNITY_STR_DEFAULT_LEN + 1);</a>
<a name="ln626">  str_size = ECOMMUNITY_STR_DEFAULT_LEN + 1;</a>
<a name="ln627">  str_pnt = 0;</a>
<a name="ln628"> </a>
<a name="ln629">  for (i = 0; i &lt; ecom-&gt;size; i++)</a>
<a name="ln630">    {</a>
<a name="ln631">      /* Make it sure size is enough.  */</a>
<a name="ln632">      while (str_pnt + ECOMMUNITY_STR_DEFAULT_LEN &gt;= str_size)</a>
<a name="ln633">	{</a>
<a name="ln634">	  str_size *= 2;</a>
<a name="ln635">	  str_buf = XREALLOC (MTYPE_ECOMMUNITY_STR, str_buf, str_size);</a>
<a name="ln636">	}</a>
<a name="ln637"> </a>
<a name="ln638">      /* Space between each value.  */</a>
<a name="ln639">      if (! first)</a>
<a name="ln640">	str_buf[str_pnt++] = ' ';</a>
<a name="ln641"> </a>
<a name="ln642">      pnt = ecom-&gt;val + (i * 8);</a>
<a name="ln643"> </a>
<a name="ln644">      /* High-order octet of type. */</a>
<a name="ln645">      encode = *pnt++;</a>
<a name="ln646"> </a>
<a name="ln647">      switch (encode)</a>
<a name="ln648">        {</a>
<a name="ln649">        case ECOMMUNITY_ENCODE_AS:</a>
<a name="ln650">        case ECOMMUNITY_ENCODE_IP:</a>
<a name="ln651">        case ECOMMUNITY_ENCODE_AS4:</a>
<a name="ln652">          break;</a>
<a name="ln653"> </a>
<a name="ln654">        case ECOMMUNITY_ENCODE_OPAQUE:</a>
<a name="ln655">          if (*pnt == ECOMMUNITY_OPAQUE_SUBTYPE_ENCAP)</a>
<a name="ln656">            {</a>
<a name="ln657">              uint16_t tunneltype;</a>
<a name="ln658">              memcpy (&amp;tunneltype, pnt + 5, 2);</a>
<a name="ln659">              tunneltype = ntohs(tunneltype);</a>
<a name="ln660">              len = sprintf (str_buf + str_pnt, &quot;ET:%d&quot;, tunneltype);</a>
<a name="ln661">              str_pnt += len;</a>
<a name="ln662">              first = 0;</a>
<a name="ln663">              continue;</a>
<a name="ln664">            }</a>
<a name="ln665">            /* fall through */</a>
<a name="ln666"> </a>
<a name="ln667">        default:</a>
<a name="ln668">          len = sprintf (str_buf + str_pnt, &quot;?&quot;);</a>
<a name="ln669">          str_pnt += len;</a>
<a name="ln670">          first = 0;</a>
<a name="ln671">          continue;</a>
<a name="ln672">        }</a>
<a name="ln673"> </a>
<a name="ln674">      /* Low-order octet of type. */</a>
<a name="ln675">      type = *pnt++;</a>
<a name="ln676">      if (type !=  ECOMMUNITY_ROUTE_TARGET &amp;&amp; type != ECOMMUNITY_SITE_ORIGIN)</a>
<a name="ln677">	{</a>
<a name="ln678">	  len = sprintf (str_buf + str_pnt, &quot;?&quot;);</a>
<a name="ln679">	  str_pnt += len;</a>
<a name="ln680">	  first = 0;</a>
<a name="ln681">	  continue;</a>
<a name="ln682">	}</a>
<a name="ln683"> </a>
<a name="ln684">      switch (format)</a>
<a name="ln685">	{</a>
<a name="ln686">	case ECOMMUNITY_FORMAT_COMMUNITY_LIST:</a>
<a name="ln687">	  prefix = (type == ECOMMUNITY_ROUTE_TARGET ? &quot;rt &quot; : &quot;soo &quot;);</a>
<a name="ln688">	  break;</a>
<a name="ln689">	case ECOMMUNITY_FORMAT_DISPLAY:</a>
<a name="ln690">	  prefix = (type == ECOMMUNITY_ROUTE_TARGET ? &quot;RT:&quot; : &quot;SoO:&quot;);</a>
<a name="ln691">	  break;</a>
<a name="ln692">	case ECOMMUNITY_FORMAT_ROUTE_MAP:</a>
<a name="ln693">	  prefix = &quot;&quot;;</a>
<a name="ln694">	  break;</a>
<a name="ln695">	default:</a>
<a name="ln696">	  prefix = &quot;&quot;;</a>
<a name="ln697">	  break;</a>
<a name="ln698">	}</a>
<a name="ln699"> </a>
<a name="ln700">      /* Put string into buffer.  */</a>
<a name="ln701">      if (encode == ECOMMUNITY_ENCODE_AS4)</a>
<a name="ln702">	{</a>
<a name="ln703">	  eas.as = (*pnt++ &lt;&lt; 24);</a>
<a name="ln704">	  eas.as |= (*pnt++ &lt;&lt; 16);</a>
<a name="ln705">	  eas.as |= (*pnt++ &lt;&lt; 8);</a>
<a name="ln706">	  eas.as |= (*pnt++);</a>
<a name="ln707"> </a>
<a name="ln708">	  eas.val = (*pnt++ &lt;&lt; 8);</a>
<a name="ln709">	  eas.val |= (*pnt++);</a>
<a name="ln710"> </a>
<a name="ln711">	  len = sprintf( str_buf + str_pnt, &quot;%s%u:%u&quot;, prefix,</a>
<a name="ln712">                        eas.as, eas.val );</a>
<a name="ln713">	  str_pnt += len;</a>
<a name="ln714">	  first = 0;</a>
<a name="ln715">	}</a>
<a name="ln716">      if (encode == ECOMMUNITY_ENCODE_AS)</a>
<a name="ln717">	{</a>
<a name="ln718">	  eas.as = (*pnt++ &lt;&lt; 8);</a>
<a name="ln719">	  eas.as |= (*pnt++);</a>
<a name="ln720"> </a>
<a name="ln721">	  eas.val = (*pnt++ &lt;&lt; 24);</a>
<a name="ln722">	  eas.val |= (*pnt++ &lt;&lt; 16);</a>
<a name="ln723">	  eas.val |= (*pnt++ &lt;&lt; 8);</a>
<a name="ln724">	  eas.val |= (*pnt++);</a>
<a name="ln725"> </a>
<a name="ln726">	  len = sprintf (str_buf + str_pnt, &quot;%s%u:%u&quot;, prefix,</a>
<a name="ln727">			 eas.as, eas.val);</a>
<a name="ln728">	  str_pnt += len;</a>
<a name="ln729">	  first = 0;</a>
<a name="ln730">	}</a>
<a name="ln731">      else if (encode == ECOMMUNITY_ENCODE_IP)</a>
<a name="ln732">	{</a>
<a name="ln733">	  memcpy (&amp;eip.ip, pnt, 4);</a>
<a name="ln734">	  pnt += 4;</a>
<a name="ln735">	  eip.val = (*pnt++ &lt;&lt; 8);</a>
<a name="ln736">	  eip.val |= (*pnt++);</a>
<a name="ln737"> </a>
<a name="ln738">	  len = sprintf (str_buf + str_pnt, &quot;%s%s:%u&quot;, prefix,</a>
<a name="ln739">			 inet_ntoa (eip.ip), eip.val);</a>
<a name="ln740">	  str_pnt += len;</a>
<a name="ln741">	  first = 0;</a>
<a name="ln742">	}</a>
<a name="ln743">    }</a>
<a name="ln744">  return str_buf;</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">int</a>
<a name="ln748">ecommunity_match (const struct ecommunity *ecom1, </a>
<a name="ln749">                  const struct ecommunity *ecom2)</a>
<a name="ln750">{</a>
<a name="ln751">  int i = 0;</a>
<a name="ln752">  int j = 0;</a>
<a name="ln753"> </a>
<a name="ln754">  if (ecom1 == NULL &amp;&amp; ecom2 == NULL)</a>
<a name="ln755">    return 1;</a>
<a name="ln756"> </a>
<a name="ln757">  if (ecom1 == NULL || ecom2 == NULL)</a>
<a name="ln758">    return 0;</a>
<a name="ln759"> </a>
<a name="ln760">  if (ecom1-&gt;size &lt; ecom2-&gt;size)</a>
<a name="ln761">    return 0;</a>
<a name="ln762"> </a>
<a name="ln763">  /* Every community on com2 needs to be on com1 for this to match */</a>
<a name="ln764">  while (i &lt; ecom1-&gt;size &amp;&amp; j &lt; ecom2-&gt;size)</a>
<a name="ln765">    {</a>
<a name="ln766">      if (memcmp (ecom1-&gt;val + i, ecom2-&gt;val + j, ECOMMUNITY_SIZE) == 0)</a>
<a name="ln767">        j++;</a>
<a name="ln768">      i++;</a>
<a name="ln769">    }</a>
<a name="ln770"> </a>
<a name="ln771">  if (j == ecom2-&gt;size)</a>
<a name="ln772">    return 1;</a>
<a name="ln773">  else</a>
<a name="ln774">    return 0;</a>
<a name="ln775">}</a>
<a name="ln776"> </a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
