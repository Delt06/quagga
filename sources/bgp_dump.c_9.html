
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_dump.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP-4 dump routine</a>
<a name="ln2">   Copyright (C) 1999 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;log.h&quot;</a>
<a name="ln24">#include &quot;stream.h&quot;</a>
<a name="ln25">#include &quot;sockunion.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;thread.h&quot;</a>
<a name="ln29">#include &quot;linklist.h&quot;</a>
<a name="ln30">#include &quot;filter.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln33">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln34">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln35">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_dump.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">enum bgp_dump_type</a>
<a name="ln39">{</a>
<a name="ln40">  BGP_DUMP_ALL,</a>
<a name="ln41">  BGP_DUMP_ALL_ET,</a>
<a name="ln42">  BGP_DUMP_UPDATES,</a>
<a name="ln43">  BGP_DUMP_UPDATES_ET,</a>
<a name="ln44">  BGP_DUMP_ROUTES</a>
<a name="ln45">};</a>
<a name="ln46"> </a>
<a name="ln47">static const struct bgp_dump_type_map {</a>
<a name="ln48">  enum bgp_dump_type type;</a>
<a name="ln49">  const char *str;</a>
<a name="ln50">} bgp_dump_type_map[] =</a>
<a name="ln51">  {</a>
<a name="ln52">    {BGP_DUMP_ALL, &quot;all&quot;},</a>
<a name="ln53">    {BGP_DUMP_ALL_ET, &quot;all-et&quot;},</a>
<a name="ln54">    {BGP_DUMP_UPDATES, &quot;updates&quot;},</a>
<a name="ln55">    {BGP_DUMP_UPDATES_ET, &quot;updates-et&quot;},</a>
<a name="ln56">    {BGP_DUMP_ROUTES, &quot;routes-mrt&quot;},</a>
<a name="ln57">    {0, NULL},</a>
<a name="ln58">  };</a>
<a name="ln59"> </a>
<a name="ln60">enum MRT_MSG_TYPES {</a>
<a name="ln61">   MSG_NULL,</a>
<a name="ln62">   MSG_START,                   /* sender is starting up */</a>
<a name="ln63">   MSG_DIE,                     /* receiver should shut down */</a>
<a name="ln64">   MSG_I_AM_DEAD,               /* sender is shutting down */</a>
<a name="ln65">   MSG_PEER_DOWN,               /* sender's peer is down */</a>
<a name="ln66">   MSG_PROTOCOL_BGP,            /* msg is a BGP packet */</a>
<a name="ln67">   MSG_PROTOCOL_RIP,            /* msg is a RIP packet */</a>
<a name="ln68">   MSG_PROTOCOL_IDRP,           /* msg is an IDRP packet */</a>
<a name="ln69">   MSG_PROTOCOL_RIPNG,          /* msg is a RIPNG packet */</a>
<a name="ln70">   MSG_PROTOCOL_BGP4PLUS,       /* msg is a BGP4+ packet */</a>
<a name="ln71">   MSG_PROTOCOL_BGP4PLUS_01,    /* msg is a BGP4+ (draft 01) packet */</a>
<a name="ln72">   MSG_PROTOCOL_OSPF,           /* msg is an OSPF packet */</a>
<a name="ln73">   MSG_TABLE_DUMP,              /* routing table dump */</a>
<a name="ln74">   MSG_TABLE_DUMP_V2            /* routing table dump, version 2 */</a>
<a name="ln75">};</a>
<a name="ln76"> </a>
<a name="ln77">struct bgp_dump</a>
<a name="ln78">{</a>
<a name="ln79">  enum bgp_dump_type type;</a>
<a name="ln80"> </a>
<a name="ln81">  char *filename;</a>
<a name="ln82"> </a>
<a name="ln83">  FILE *fp;</a>
<a name="ln84"> </a>
<a name="ln85">  unsigned int interval;</a>
<a name="ln86"> </a>
<a name="ln87">  char *interval_str;</a>
<a name="ln88"> </a>
<a name="ln89">  struct thread *t_interval;</a>
<a name="ln90">};</a>
<a name="ln91"> </a>
<a name="ln92">static int bgp_dump_unset (struct vty *vty, struct bgp_dump *bgp_dump);</a>
<a name="ln93">static int bgp_dump_interval_func (struct thread *);</a>
<a name="ln94"> </a>
<a name="ln95">/* BGP packet dump output buffer. */</a>
<a name="ln96">struct stream *bgp_dump_obuf;</a>
<a name="ln97"> </a>
<a name="ln98">/* BGP dump strucuture for 'dump bgp all' */</a>
<a name="ln99">struct bgp_dump bgp_dump_all;</a>
<a name="ln100"> </a>
<a name="ln101">/* BGP dump structure for 'dump bgp updates' */</a>
<a name="ln102">struct bgp_dump bgp_dump_updates;</a>
<a name="ln103"> </a>
<a name="ln104">/* BGP dump structure for 'dump bgp routes' */</a>
<a name="ln105">struct bgp_dump bgp_dump_routes;</a>
<a name="ln106"> </a>
<a name="ln107">static FILE *</a>
<a name="ln108">bgp_dump_open_file (struct bgp_dump *bgp_dump)</a>
<a name="ln109">{</a>
<a name="ln110">  int ret;</a>
<a name="ln111">  time_t clock;</a>
<a name="ln112">  struct tm *tm;</a>
<a name="ln113">  char fullpath[MAXPATHLEN];</a>
<a name="ln114">  char realpath[MAXPATHLEN];</a>
<a name="ln115">  mode_t oldumask;</a>
<a name="ln116"> </a>
<a name="ln117">  time (&amp;clock);</a>
<a name="ln118">  tm = localtime (&amp;clock);</a>
<a name="ln119"> </a>
<a name="ln120">  if (bgp_dump-&gt;filename[0] != DIRECTORY_SEP)</a>
<a name="ln121">    {</a>
<a name="ln122">      sprintf (fullpath, &quot;%s/%s&quot;, vty_get_cwd (), bgp_dump-&gt;filename);</a>
<a name="ln123">      ret = strftime (realpath, MAXPATHLEN, fullpath, tm);</a>
<a name="ln124">    }</a>
<a name="ln125">  else</a>
<a name="ln126">    ret = strftime (realpath, MAXPATHLEN, bgp_dump-&gt;filename, tm);</a>
<a name="ln127"> </a>
<a name="ln128">  if (ret == 0)</a>
<a name="ln129">    {</a>
<a name="ln130">      zlog_warn (&quot;bgp_dump_open_file: strftime error&quot;);</a>
<a name="ln131">      return NULL;</a>
<a name="ln132">    }</a>
<a name="ln133"> </a>
<a name="ln134">  if (bgp_dump-&gt;fp)</a>
<a name="ln135">    fclose (bgp_dump-&gt;fp);</a>
<a name="ln136"> </a>
<a name="ln137"> </a>
<a name="ln138">  oldumask = umask(0777 &amp; ~LOGFILE_MASK);</a>
<a name="ln139">  bgp_dump-&gt;fp = fopen (realpath, &quot;w&quot;);</a>
<a name="ln140"> </a>
<a name="ln141">  if (bgp_dump-&gt;fp == NULL)</a>
<a name="ln142">    {</a>
<a name="ln143">      zlog_warn (&quot;bgp_dump_open_file: %s: %s&quot;, realpath, strerror (errno));</a>
<a name="ln144">      umask(oldumask);</a>
<a name="ln145">      return NULL;</a>
<a name="ln146">    }</a>
<a name="ln147">  umask(oldumask);  </a>
<a name="ln148"> </a>
<a name="ln149">  return bgp_dump-&gt;fp;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">static int</a>
<a name="ln153">bgp_dump_interval_add (struct bgp_dump *bgp_dump, int interval)</a>
<a name="ln154">{</a>
<a name="ln155">  int secs_into_day;</a>
<a name="ln156">  time_t t;</a>
<a name="ln157">  struct tm *tm;</a>
<a name="ln158"> </a>
<a name="ln159">  if (interval &gt; 0)</a>
<a name="ln160">    {</a>
<a name="ln161">      /* Periodic dump every interval seconds */</a>
<a name="ln162">      if ((interval &lt; 86400) &amp;&amp; ((86400 % interval) == 0))</a>
<a name="ln163">	{</a>
<a name="ln164">	  /* Dump at predictable times: if a day has a whole number of</a>
<a name="ln165">	   * intervals, dump every interval seconds starting from midnight</a>
<a name="ln166">	   */</a>
<a name="ln167">	  (void) time(&amp;t);</a>
<a name="ln168">	  tm = localtime(&amp;t);</a>
<a name="ln169">	  secs_into_day = tm-&gt;tm_sec + 60*tm-&gt;tm_min + 60*60*tm-&gt;tm_hour;</a>
<a name="ln170">	  interval = interval - secs_into_day % interval; /* always &gt; 0 */</a>
<a name="ln171">	}</a>
<a name="ln172">      bgp_dump-&gt;t_interval = thread_add_timer (bm-&gt;master, bgp_dump_interval_func,</a>
<a name="ln173">					       bgp_dump, interval);</a>
<a name="ln174">    }</a>
<a name="ln175">  else</a>
<a name="ln176">    {</a>
<a name="ln177">      /* One-off dump: execute immediately, don't affect any scheduled dumps */</a>
<a name="ln178">      bgp_dump-&gt;t_interval = thread_add_event (bm-&gt;master, bgp_dump_interval_func,</a>
<a name="ln179">					       bgp_dump, 0);</a>
<a name="ln180">    }</a>
<a name="ln181"> </a>
<a name="ln182">  return 0;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">/* Dump common header. */</a>
<a name="ln186">static void</a>
<a name="ln187">bgp_dump_header (struct stream *obuf, int type, int subtype, int dump_type)</a>
<a name="ln188">{</a>
<a name="ln189">  struct timeval clock;</a>
<a name="ln190">  long msecs;</a>
<a name="ln191">  time_t secs;</a>
<a name="ln192"> </a>
<a name="ln193">  if ((dump_type == BGP_DUMP_ALL_ET || dump_type == BGP_DUMP_UPDATES_ET)</a>
<a name="ln194">      &amp;&amp; type == MSG_PROTOCOL_BGP4MP)</a>
<a name="ln195">    type = MSG_PROTOCOL_BGP4MP_ET;</a>
<a name="ln196"> </a>
<a name="ln197">  gettimeofday(&amp;clock, NULL);</a>
<a name="ln198"> </a>
<a name="ln199">  secs = clock.tv_sec;</a>
<a name="ln200">  msecs = clock.tv_usec;</a>
<a name="ln201"> </a>
<a name="ln202">  /* Put dump packet header. */</a>
<a name="ln203">  stream_putl (obuf, secs);</a>
<a name="ln204">  stream_putw (obuf, type);</a>
<a name="ln205">  stream_putw (obuf, subtype);</a>
<a name="ln206">  stream_putl (obuf, 0);	/* len */</a>
<a name="ln207"> </a>
<a name="ln208">  /* Adding microseconds for the MRT Extended Header */</a>
<a name="ln209">  if (type == MSG_PROTOCOL_BGP4MP_ET)</a>
<a name="ln210">    stream_putl (obuf, msecs);</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static void</a>
<a name="ln214">bgp_dump_set_size (struct stream *s, int type)</a>
<a name="ln215">{</a>
<a name="ln216">  /*</a>
<a name="ln217">   * The BGP_DUMP_HEADER_SIZE stay at 12 event when ET:</a>
<a name="ln218">   * &quot;The Microsecond Timestamp is included in the computation</a>
<a name="ln219">   *  of the Length field value.&quot; (RFC6396 2011)</a>
<a name="ln220">   */</a>
<a name="ln221">  stream_putl_at (s, 8, stream_get_endp (s) - BGP_DUMP_HEADER_SIZE);</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">static void</a>
<a name="ln225">bgp_dump_routes_index_table(struct bgp *bgp)</a>
<a name="ln226">{</a>
<a name="ln227">  struct peer *peer;</a>
<a name="ln228">  struct listnode *node;</a>
<a name="ln229">  uint16_t peerno = 1;</a>
<a name="ln230">  struct stream *obuf;</a>
<a name="ln231"> </a>
<a name="ln232">  obuf = bgp_dump_obuf;</a>
<a name="ln233">  stream_reset (obuf);</a>
<a name="ln234"> </a>
<a name="ln235">  /* MRT header */</a>
<a name="ln236">  bgp_dump_header (obuf, MSG_TABLE_DUMP_V2, TABLE_DUMP_V2_PEER_INDEX_TABLE,</a>
<a name="ln237">		   BGP_DUMP_ROUTES);</a>
<a name="ln238"> </a>
<a name="ln239">  /* Collector BGP ID */</a>
<a name="ln240">  stream_put_in_addr (obuf, &amp;bgp-&gt;router_id);</a>
<a name="ln241"> </a>
<a name="ln242">  /* View name */</a>
<a name="ln243">  if(bgp-&gt;name)</a>
<a name="ln244">    {</a>
<a name="ln245">      stream_putw (obuf, strlen(bgp-&gt;name));</a>
<a name="ln246">      stream_put(obuf, bgp-&gt;name, strlen(bgp-&gt;name));</a>
<a name="ln247">    }</a>
<a name="ln248">  else</a>
<a name="ln249">    {</a>
<a name="ln250">      stream_putw(obuf, 0);</a>
<a name="ln251">    }</a>
<a name="ln252"> </a>
<a name="ln253">  /* Peer count ( plus one extra internal peer ) */</a>
<a name="ln254">  stream_putw (obuf, listcount(bgp-&gt;peer) + 1);</a>
<a name="ln255"> </a>
<a name="ln256">  /* Populate fake peer at index 0, for locally originated routes */</a>
<a name="ln257">  /* Peer type (IPv4) */</a>
<a name="ln258">  stream_putc (obuf, TABLE_DUMP_V2_PEER_INDEX_TABLE_AS4+TABLE_DUMP_V2_PEER_INDEX_TABLE_IP);</a>
<a name="ln259">  /* Peer BGP ID (0.0.0.0) */</a>
<a name="ln260">  stream_putl (obuf, 0);</a>
<a name="ln261">  /* Peer IP address (0.0.0.0) */</a>
<a name="ln262">  stream_putl (obuf, 0);</a>
<a name="ln263">  /* Peer ASN (0) */</a>
<a name="ln264">  stream_putl (obuf, 0);</a>
<a name="ln265"> </a>
<a name="ln266">  /* Walk down all peers */</a>
<a name="ln267">  for(ALL_LIST_ELEMENTS_RO (bgp-&gt;peer, node, peer))</a>
<a name="ln268">    {</a>
<a name="ln269"> </a>
<a name="ln270">      /* Peer's type */</a>
<a name="ln271">      if (sockunion_family(&amp;peer-&gt;su) == AF_INET)</a>
<a name="ln272">        {</a>
<a name="ln273">          stream_putc (obuf, TABLE_DUMP_V2_PEER_INDEX_TABLE_AS4+TABLE_DUMP_V2_PEER_INDEX_TABLE_IP);</a>
<a name="ln274">        }</a>
<a name="ln275">      else if (sockunion_family(&amp;peer-&gt;su) == AF_INET6)</a>
<a name="ln276">        {</a>
<a name="ln277">          stream_putc (obuf, TABLE_DUMP_V2_PEER_INDEX_TABLE_AS4+TABLE_DUMP_V2_PEER_INDEX_TABLE_IP6);</a>
<a name="ln278">        }</a>
<a name="ln279"> </a>
<a name="ln280">      /* Peer's BGP ID */</a>
<a name="ln281">      stream_put_in_addr (obuf, &amp;peer-&gt;remote_id);</a>
<a name="ln282"> </a>
<a name="ln283">      /* Peer's IP address */</a>
<a name="ln284">      if (sockunion_family(&amp;peer-&gt;su) == AF_INET)</a>
<a name="ln285">        {</a>
<a name="ln286">          stream_put_in_addr (obuf, &amp;peer-&gt;su.sin.sin_addr);</a>
<a name="ln287">        }</a>
<a name="ln288">      else if (sockunion_family(&amp;peer-&gt;su) == AF_INET6)</a>
<a name="ln289">        {</a>
<a name="ln290">          stream_write (obuf, (u_char *)&amp;peer-&gt;su.sin6.sin6_addr,</a>
<a name="ln291">                        IPV6_MAX_BYTELEN);</a>
<a name="ln292">        }</a>
<a name="ln293"> </a>
<a name="ln294">      /* Peer's AS number. */</a>
<a name="ln295">      /* Note that, as this is an AS4 compliant quagga, the RIB is always AS4 */</a>
<a name="ln296">      stream_putl (obuf, peer-&gt;as);</a>
<a name="ln297"> </a>
<a name="ln298">      /* Store the peer number for this peer */</a>
<a name="ln299">      peer-&gt;table_dump_index = peerno;</a>
<a name="ln300">      peerno++;</a>
<a name="ln301">    }</a>
<a name="ln302"> </a>
<a name="ln303">  bgp_dump_set_size(obuf, MSG_TABLE_DUMP_V2);</a>
<a name="ln304"> </a>
<a name="ln305">  fwrite (STREAM_DATA (obuf), stream_get_endp (obuf), 1, bgp_dump_routes.fp);</a>
<a name="ln306">  fflush (bgp_dump_routes.fp);</a>
<a name="ln307">}</a>
<a name="ln308"> </a>
<a name="ln309"> </a>
<a name="ln310">static struct bgp_info *</a>
<a name="ln311">bgp_dump_route_node_record (int afi, struct bgp_node *rn,</a>
<a name="ln312">                            struct bgp_info *info, unsigned int seq)</a>
<a name="ln313">{</a>
<a name="ln314">  struct stream *obuf;</a>
<a name="ln315">  size_t sizep;</a>
<a name="ln316">  size_t endp;</a>
<a name="ln317"> </a>
<a name="ln318">  obuf = bgp_dump_obuf;</a>
<a name="ln319">  stream_reset (obuf);</a>
<a name="ln320"> </a>
<a name="ln321">  /* MRT header */</a>
<a name="ln322">  if (afi == AFI_IP)</a>
<a name="ln323">    bgp_dump_header (obuf, MSG_TABLE_DUMP_V2, TABLE_DUMP_V2_RIB_IPV4_UNICAST,</a>
<a name="ln324">                     BGP_DUMP_ROUTES);</a>
<a name="ln325">  else if (afi == AFI_IP6)</a>
<a name="ln326">    bgp_dump_header (obuf, MSG_TABLE_DUMP_V2, TABLE_DUMP_V2_RIB_IPV6_UNICAST,</a>
<a name="ln327">                     BGP_DUMP_ROUTES);</a>
<a name="ln328"> </a>
<a name="ln329">  /* Sequence number */</a>
<a name="ln330">  stream_putl (obuf, seq);</a>
<a name="ln331"> </a>
<a name="ln332">  /* Prefix length */</a>
<a name="ln333">  stream_putc (obuf, rn-&gt;p.prefixlen);</a>
<a name="ln334"> </a>
<a name="ln335">  /* Prefix */</a>
<a name="ln336">  if (afi == AFI_IP)</a>
<a name="ln337">    {</a>
<a name="ln338">      /* We'll dump only the useful bits (those not 0), but have to</a>
<a name="ln339">       * align on 8 bits */</a>
<a name="ln340">      stream_write (obuf, (u_char *) &amp;rn-&gt;p.u.prefix4, </a>
<a name="ln341">                    (rn-&gt;p.prefixlen + 7) / 8);</a>
<a name="ln342">    }</a>
<a name="ln343">  else if (afi == AFI_IP6)</a>
<a name="ln344">    {</a>
<a name="ln345">      /* We'll dump only the useful bits (those not 0), but have to</a>
<a name="ln346">       * align on 8 bits */</a>
<a name="ln347">      stream_write (obuf, (u_char *) &amp;rn-&gt;p.u.prefix6,</a>
<a name="ln348">                    (rn-&gt;p.prefixlen + 7) / 8);</a>
<a name="ln349">    }</a>
<a name="ln350"> </a>
<a name="ln351">  /* Save where we are now, so we can overwride the entry count later */</a>
<a name="ln352">  sizep = stream_get_endp (obuf);</a>
<a name="ln353"> </a>
<a name="ln354">  /* Entry count */</a>
<a name="ln355">  uint16_t entry_count = 0;</a>
<a name="ln356"> </a>
<a name="ln357">  /* Entry count, note that this is overwritten later */</a>
<a name="ln358">  stream_putw (obuf, 0);</a>
<a name="ln359"> </a>
<a name="ln360">  endp = stream_get_endp (obuf);</a>
<a name="ln361">  for (; info; info = info-&gt;next)</a>
<a name="ln362">    {</a>
<a name="ln363">      size_t cur_endp;</a>
<a name="ln364"> </a>
<a name="ln365">      /* Peer index */</a>
<a name="ln366">      stream_putw (obuf, info-&gt;peer-&gt;table_dump_index);</a>
<a name="ln367"> </a>
<a name="ln368">      /* Originated */</a>
<a name="ln369">#ifdef HAVE_CLOCK_MONOTONIC</a>
<a name="ln370">      stream_putl (obuf, time (NULL) - (bgp_clock () - info-&gt;uptime));</a>
<a name="ln371">#else</a>
<a name="ln372">      stream_putl (obuf, info-&gt;uptime);</a>
<a name="ln373">#endif /* HAVE_CLOCK_MONOTONIC */</a>
<a name="ln374"> </a>
<a name="ln375">      /* Dump attribute. */</a>
<a name="ln376">      /* Skip prefix &amp; AFI/SAFI for MP_NLRI */</a>
<a name="ln377">      bgp_dump_routes_attr (obuf, info-&gt;attr, &amp;rn-&gt;p);</a>
<a name="ln378"> </a>
<a name="ln379">      cur_endp = stream_get_endp (obuf);</a>
<a name="ln380">      if (cur_endp &gt; BGP_MAX_PACKET_SIZE + BGP_DUMP_MSG_HEADER</a>
<a name="ln381">          + BGP_DUMP_HEADER_SIZE)</a>
<a name="ln382">        {</a>
<a name="ln383">          stream_set_endp (obuf, endp);</a>
<a name="ln384">          break;</a>
<a name="ln385">        }</a>
<a name="ln386"> </a>
<a name="ln387">      entry_count++;</a>
<a name="ln388">      endp = cur_endp;</a>
<a name="ln389">    }</a>
<a name="ln390"> </a>
<a name="ln391">  /* Overwrite the entry count, now that we know the right number */</a>
<a name="ln392">  stream_putw_at (obuf, sizep, entry_count);</a>
<a name="ln393"> </a>
<a name="ln394">  bgp_dump_set_size (obuf, MSG_TABLE_DUMP_V2);</a>
<a name="ln395">  fwrite (STREAM_DATA (obuf), stream_get_endp (obuf), 1, bgp_dump_routes.fp);</a>
<a name="ln396"> </a>
<a name="ln397">  return info;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">/* Runs under child process. */</a>
<a name="ln401">static unsigned int</a>
<a name="ln402">bgp_dump_routes_func (int afi, int first_run, unsigned int seq)</a>
<a name="ln403">{</a>
<a name="ln404">  struct bgp_info *info;</a>
<a name="ln405">  struct bgp_node *rn;</a>
<a name="ln406">  struct bgp *bgp;</a>
<a name="ln407">  struct bgp_table *table;</a>
<a name="ln408"> </a>
<a name="ln409">  bgp = bgp_get_default ();</a>
<a name="ln410">  if (!bgp)</a>
<a name="ln411">    return seq;</a>
<a name="ln412"> </a>
<a name="ln413">  if (bgp_dump_routes.fp == NULL)</a>
<a name="ln414">    return seq;</a>
<a name="ln415"> </a>
<a name="ln416">  /* Note that bgp_dump_routes_index_table will do ipv4 and ipv6 peers,</a>
<a name="ln417">     so this should only be done on the first call to bgp_dump_routes_func.</a>
<a name="ln418">     ( this function will be called once for ipv4 and once for ipv6 ) */</a>
<a name="ln419">  if(first_run)</a>
<a name="ln420">    bgp_dump_routes_index_table(bgp);</a>
<a name="ln421"> </a>
<a name="ln422">  /* Walk down each BGP route. */</a>
<a name="ln423">  table = bgp-&gt;rib[afi][SAFI_UNICAST];</a>
<a name="ln424"> </a>
<a name="ln425">  for (rn = bgp_table_top (table); rn; rn = bgp_route_next (rn))</a>
<a name="ln426">    {</a>
<a name="ln427">      info = rn-&gt;info;</a>
<a name="ln428">      while (info)</a>
<a name="ln429">      {</a>
<a name="ln430">        info = bgp_dump_route_node_record(afi, rn, info, seq);</a>
<a name="ln431">        seq++;</a>
<a name="ln432">      }</a>
<a name="ln433">    }</a>
<a name="ln434"> </a>
<a name="ln435">  fflush (bgp_dump_routes.fp);</a>
<a name="ln436"> </a>
<a name="ln437">  return seq;</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">static int</a>
<a name="ln441">bgp_dump_interval_func (struct thread *t)</a>
<a name="ln442">{</a>
<a name="ln443">  struct bgp_dump *bgp_dump;</a>
<a name="ln444">  bgp_dump = THREAD_ARG (t);</a>
<a name="ln445">  bgp_dump-&gt;t_interval = NULL;</a>
<a name="ln446"> </a>
<a name="ln447">  /* Reschedule dump even if file couldn't be opened this time... */</a>
<a name="ln448">  if (bgp_dump_open_file (bgp_dump) != NULL)</a>
<a name="ln449">    {</a>
<a name="ln450">      /* In case of bgp_dump_routes, we need special route dump function. */</a>
<a name="ln451">      if (bgp_dump-&gt;type == BGP_DUMP_ROUTES)</a>
<a name="ln452">	{</a>
<a name="ln453">	  unsigned int seq = bgp_dump_routes_func (AFI_IP, 1, 0);</a>
<a name="ln454">	  bgp_dump_routes_func (AFI_IP6, 0, seq);</a>
<a name="ln455">	  /* Close the file now. For a RIB dump there's no point in leaving</a>
<a name="ln456">	   * it open until the next scheduled dump starts. */</a>
<a name="ln457">	  fclose(bgp_dump-&gt;fp); bgp_dump-&gt;fp = NULL;</a>
<a name="ln458">	}</a>
<a name="ln459">    }</a>
<a name="ln460"> </a>
<a name="ln461">  /* if interval is set reschedule */</a>
<a name="ln462">  if (bgp_dump-&gt;interval &gt; 0)</a>
<a name="ln463">    bgp_dump_interval_add (bgp_dump, bgp_dump-&gt;interval);</a>
<a name="ln464"> </a>
<a name="ln465">  return 0;</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468">/* Dump common information. */</a>
<a name="ln469">static void</a>
<a name="ln470">bgp_dump_common (struct stream *obuf, struct peer *peer, int forceas4)</a>
<a name="ln471">{</a>
<a name="ln472">  char empty[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};</a>
<a name="ln473"> </a>
<a name="ln474">  /* Source AS number and Destination AS number. */</a>
<a name="ln475">  if (forceas4 || CHECK_FLAG (peer-&gt;cap, PEER_CAP_AS4_RCV) )</a>
<a name="ln476">    {</a>
<a name="ln477">      stream_putl (obuf, peer-&gt;as);</a>
<a name="ln478">      stream_putl (obuf, peer-&gt;local_as);</a>
<a name="ln479">    }</a>
<a name="ln480">  else</a>
<a name="ln481">    {</a>
<a name="ln482">      stream_putw (obuf, peer-&gt;as);</a>
<a name="ln483">      stream_putw (obuf, peer-&gt;local_as);</a>
<a name="ln484">    }</a>
<a name="ln485"> </a>
<a name="ln486">  if (peer-&gt;su.sa.sa_family == AF_INET)</a>
<a name="ln487">    {</a>
<a name="ln488">      stream_putw (obuf, peer-&gt;ifindex);</a>
<a name="ln489">      stream_putw (obuf, AFI_IP);</a>
<a name="ln490"> </a>
<a name="ln491">      stream_put (obuf, &amp;peer-&gt;su.sin.sin_addr, IPV4_MAX_BYTELEN);</a>
<a name="ln492"> </a>
<a name="ln493">      if (peer-&gt;su_local)</a>
<a name="ln494">	stream_put (obuf, &amp;peer-&gt;su_local-&gt;sin.sin_addr, IPV4_MAX_BYTELEN);</a>
<a name="ln495">      else</a>
<a name="ln496">	stream_put (obuf, empty, IPV4_MAX_BYTELEN);</a>
<a name="ln497">    }</a>
<a name="ln498">  else if (peer-&gt;su.sa.sa_family == AF_INET6)</a>
<a name="ln499">    {</a>
<a name="ln500">      /* Interface Index and Address family. */</a>
<a name="ln501">      stream_putw (obuf, peer-&gt;ifindex);</a>
<a name="ln502">      stream_putw (obuf, AFI_IP6);</a>
<a name="ln503"> </a>
<a name="ln504">      /* Source IP Address and Destination IP Address. */</a>
<a name="ln505">      stream_put (obuf, &amp;peer-&gt;su.sin6.sin6_addr, IPV6_MAX_BYTELEN);</a>
<a name="ln506"> </a>
<a name="ln507">      if (peer-&gt;su_local)</a>
<a name="ln508">	stream_put (obuf, &amp;peer-&gt;su_local-&gt;sin6.sin6_addr, IPV6_MAX_BYTELEN);</a>
<a name="ln509">      else</a>
<a name="ln510">	stream_put (obuf, empty, IPV6_MAX_BYTELEN);</a>
<a name="ln511">    }</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/* Dump BGP status change. */</a>
<a name="ln515">void</a>
<a name="ln516">bgp_dump_state (struct peer *peer, int status_old, int status_new)</a>
<a name="ln517">{</a>
<a name="ln518">  struct stream *obuf;</a>
<a name="ln519"> </a>
<a name="ln520">  /* If dump file pointer is disabled return immediately. */</a>
<a name="ln521">  if (bgp_dump_all.fp == NULL)</a>
<a name="ln522">    return;</a>
<a name="ln523"> </a>
<a name="ln524">  /* Make dump stream. */</a>
<a name="ln525">  obuf = bgp_dump_obuf;</a>
<a name="ln526">  stream_reset (obuf);</a>
<a name="ln527"> </a>
<a name="ln528">  bgp_dump_header (obuf, MSG_PROTOCOL_BGP4MP, BGP4MP_STATE_CHANGE_AS4,</a>
<a name="ln529">		   bgp_dump_all.type);</a>
<a name="ln530">  bgp_dump_common (obuf, peer, 1);/* force this in as4speak*/</a>
<a name="ln531"> </a>
<a name="ln532">  stream_putw (obuf, status_old);</a>
<a name="ln533">  stream_putw (obuf, status_new);</a>
<a name="ln534"> </a>
<a name="ln535">  /* Set length. */</a>
<a name="ln536">  bgp_dump_set_size (obuf, MSG_PROTOCOL_BGP4MP);</a>
<a name="ln537"> </a>
<a name="ln538">  /* Write to the stream. */</a>
<a name="ln539">  fwrite (STREAM_DATA (obuf), stream_get_endp (obuf), 1, bgp_dump_all.fp);</a>
<a name="ln540">  fflush (bgp_dump_all.fp);</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">static void</a>
<a name="ln544">bgp_dump_packet_func (struct bgp_dump *bgp_dump, struct peer *peer,</a>
<a name="ln545">		      struct stream *packet)</a>
<a name="ln546">{</a>
<a name="ln547">  struct stream *obuf;</a>
<a name="ln548"> </a>
<a name="ln549">  /* If dump file pointer is disabled return immediately. */</a>
<a name="ln550">  if (bgp_dump-&gt;fp == NULL)</a>
<a name="ln551">    return;</a>
<a name="ln552"> </a>
<a name="ln553">  /* Make dump stream. */</a>
<a name="ln554">  obuf = bgp_dump_obuf;</a>
<a name="ln555">  stream_reset (obuf);</a>
<a name="ln556"> </a>
<a name="ln557">  /* Dump header and common part. */</a>
<a name="ln558">  if (CHECK_FLAG (peer-&gt;cap, PEER_CAP_AS4_RCV) )</a>
<a name="ln559">    { </a>
<a name="ln560">      bgp_dump_header (obuf, MSG_PROTOCOL_BGP4MP, BGP4MP_MESSAGE_AS4,</a>
<a name="ln561">		       bgp_dump-&gt;type);</a>
<a name="ln562">    }</a>
<a name="ln563">  else</a>
<a name="ln564">    {</a>
<a name="ln565">      bgp_dump_header (obuf, MSG_PROTOCOL_BGP4MP, BGP4MP_MESSAGE,</a>
<a name="ln566">		       bgp_dump-&gt;type);</a>
<a name="ln567">    }</a>
<a name="ln568">  bgp_dump_common (obuf, peer, 0);</a>
<a name="ln569"> </a>
<a name="ln570">  /* Packet contents. */</a>
<a name="ln571">  stream_put (obuf, STREAM_DATA (packet), stream_get_endp (packet));</a>
<a name="ln572">  </a>
<a name="ln573">  /* Set length. */</a>
<a name="ln574">  bgp_dump_set_size (obuf, MSG_PROTOCOL_BGP4MP);</a>
<a name="ln575"> </a>
<a name="ln576">  /* Write to the stream. */</a>
<a name="ln577">  fwrite (STREAM_DATA (obuf), stream_get_endp (obuf), 1, bgp_dump-&gt;fp);</a>
<a name="ln578">  fflush (bgp_dump-&gt;fp);</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">/* Called from bgp_packet.c when BGP packet is received. */</a>
<a name="ln582">void</a>
<a name="ln583">bgp_dump_packet (struct peer *peer, int type, struct stream *packet)</a>
<a name="ln584">{</a>
<a name="ln585">  /* bgp_dump_all. */</a>
<a name="ln586">  bgp_dump_packet_func (&amp;bgp_dump_all, peer, packet);</a>
<a name="ln587"> </a>
<a name="ln588">  /* bgp_dump_updates. */</a>
<a name="ln589">  if (type == BGP_MSG_UPDATE)</a>
<a name="ln590">    bgp_dump_packet_func (&amp;bgp_dump_updates, peer, packet);</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">static unsigned int</a>
<a name="ln594">bgp_dump_parse_time (const char *str)</a>
<a name="ln595">{</a>
<a name="ln596">  int i;</a>
<a name="ln597">  int len;</a>
<a name="ln598">  int seen_h;</a>
<a name="ln599">  int seen_m;</a>
<a name="ln600">  int time;</a>
<a name="ln601">  unsigned int total;</a>
<a name="ln602"> </a>
<a name="ln603">  time = 0;</a>
<a name="ln604">  total = 0;</a>
<a name="ln605">  seen_h = 0;</a>
<a name="ln606">  seen_m = 0;</a>
<a name="ln607">  len = strlen (str);</a>
<a name="ln608"> </a>
<a name="ln609">  for (i = 0; i &lt; len; i++)</a>
<a name="ln610">    {</a>
<a name="ln611">      if (isdigit ((int) str[i]))</a>
<a name="ln612">	{</a>
<a name="ln613">	  time *= 10;</a>
<a name="ln614">	  time += str[i] - '0';</a>
<a name="ln615">	}</a>
<a name="ln616">      else if (str[i] == 'H' || str[i] == 'h')</a>
<a name="ln617">	{</a>
<a name="ln618">	  if (seen_h)</a>
<a name="ln619">	    return 0;</a>
<a name="ln620">	  if (seen_m)</a>
<a name="ln621">	    return 0;</a>
<a name="ln622">	  total += time * 60 *60;</a>
<a name="ln623">	  time = 0;</a>
<a name="ln624">	  seen_h = 1;</a>
<a name="ln625">	}</a>
<a name="ln626">      else if (str[i] == 'M' || str[i] == 'm')</a>
<a name="ln627">	{</a>
<a name="ln628">	  if (seen_m)</a>
<a name="ln629">	    return 0;</a>
<a name="ln630">	  total += time * 60;</a>
<a name="ln631">	  time = 0;</a>
<a name="ln632">	  seen_h = 1;</a>
<a name="ln633">	}</a>
<a name="ln634">      else</a>
<a name="ln635">	return 0;</a>
<a name="ln636">    }</a>
<a name="ln637">  return total + time;</a>
<a name="ln638">}</a>
<a name="ln639"> </a>
<a name="ln640">static int</a>
<a name="ln641">bgp_dump_set (struct vty *vty, struct bgp_dump *bgp_dump,</a>
<a name="ln642">              enum bgp_dump_type type, const char *path,</a>
<a name="ln643">              const char *interval_str)</a>
<a name="ln644">{</a>
<a name="ln645">  unsigned int interval;</a>
<a name="ln646">  </a>
<a name="ln647">  /* Don't schedule duplicate dumps if the dump command is given twice */</a>
<a name="ln648">  if (bgp_dump-&gt;filename &amp;&amp; strcmp(path, bgp_dump-&gt;filename) == 0</a>
<a name="ln649">      &amp;&amp; type == bgp_dump-&gt;type)</a>
<a name="ln650">    {</a>
<a name="ln651">      if (interval_str)</a>
<a name="ln652">	{</a>
<a name="ln653">          if (bgp_dump-&gt;interval_str &amp;&amp;</a>
<a name="ln654">	      strcmp(bgp_dump-&gt;interval_str, interval_str) == 0)</a>
<a name="ln655">            return CMD_SUCCESS;</a>
<a name="ln656">        }</a>
<a name="ln657">      else</a>
<a name="ln658">        {</a>
<a name="ln659">          if (!bgp_dump-&gt;interval_str)</a>
<a name="ln660">            return CMD_SUCCESS;</a>
<a name="ln661">        }</a>
<a name="ln662">    }</a>
<a name="ln663"> </a>
<a name="ln664">  /* Removing previous config */</a>
<a name="ln665">  bgp_dump_unset(vty, bgp_dump);</a>
<a name="ln666"> </a>
<a name="ln667">  if (interval_str)</a>
<a name="ln668">    {</a>
<a name="ln669">      /* Check interval string. */</a>
<a name="ln670">      interval = bgp_dump_parse_time (interval_str);</a>
<a name="ln671">      if (interval == 0)</a>
<a name="ln672">	{</a>
<a name="ln673">	  vty_out (vty, &quot;Malformed interval string%s&quot;, VTY_NEWLINE);</a>
<a name="ln674">	  return CMD_WARNING;</a>
<a name="ln675">	}</a>
<a name="ln676"> </a>
<a name="ln677">      /* Setting interval string */</a>
<a name="ln678">      bgp_dump-&gt;interval_str = strdup (interval_str);</a>
<a name="ln679">    }</a>
<a name="ln680">  else</a>
<a name="ln681">    {</a>
<a name="ln682">      interval = 0;</a>
<a name="ln683">    }</a>
<a name="ln684"> </a>
<a name="ln685">  /* Set type. */</a>
<a name="ln686">  bgp_dump-&gt;type = type;</a>
<a name="ln687"> </a>
<a name="ln688">  /* Set interval */</a>
<a name="ln689">  bgp_dump-&gt;interval = interval;</a>
<a name="ln690"> </a>
<a name="ln691">  /* Set file name. */</a>
<a name="ln692">  bgp_dump-&gt;filename = strdup (path);</a>
<a name="ln693"> </a>
<a name="ln694">  /* Create interval thread. */</a>
<a name="ln695">  bgp_dump_interval_add (bgp_dump, interval);</a>
<a name="ln696"> </a>
<a name="ln697">  /* This should be called when interval is expired. */</a>
<a name="ln698">  bgp_dump_open_file (bgp_dump);</a>
<a name="ln699"> </a>
<a name="ln700">  return CMD_SUCCESS;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">static int</a>
<a name="ln704">bgp_dump_unset (struct vty *vty, struct bgp_dump *bgp_dump)</a>
<a name="ln705">{</a>
<a name="ln706">  /* Removing file name. */</a>
<a name="ln707">  if (bgp_dump-&gt;filename)</a>
<a name="ln708">    {</a>
<a name="ln709">      free (bgp_dump-&gt;filename);</a>
<a name="ln710">      bgp_dump-&gt;filename = NULL;</a>
<a name="ln711">    }</a>
<a name="ln712"> </a>
<a name="ln713">  /* Closing file. */</a>
<a name="ln714">  if (bgp_dump-&gt;fp)</a>
<a name="ln715">    {</a>
<a name="ln716">      fclose (bgp_dump-&gt;fp);</a>
<a name="ln717">      bgp_dump-&gt;fp = NULL;</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">  /* Removing interval thread. */</a>
<a name="ln721">  if (bgp_dump-&gt;t_interval)</a>
<a name="ln722">    {</a>
<a name="ln723">      thread_cancel (bgp_dump-&gt;t_interval);</a>
<a name="ln724">      bgp_dump-&gt;t_interval = NULL;</a>
<a name="ln725">    }</a>
<a name="ln726"> </a>
<a name="ln727">  bgp_dump-&gt;interval = 0;</a>
<a name="ln728"> </a>
<a name="ln729">  /* Removing interval string. */</a>
<a name="ln730">  if (bgp_dump-&gt;interval_str)</a>
<a name="ln731">    {</a>
<a name="ln732">      free (bgp_dump-&gt;interval_str);</a>
<a name="ln733">      bgp_dump-&gt;interval_str = NULL;</a>
<a name="ln734">    }</a>
<a name="ln735">  </a>
<a name="ln736">  return CMD_SUCCESS;</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">DEFUN (dump_bgp_all,</a>
<a name="ln740">       dump_bgp_all_cmd,</a>
<a name="ln741">       &quot;dump bgp (all|all-et|updates|updates-et|routes-mrt) PATH [INTERVAL]&quot;,</a>
<a name="ln742">       &quot;Dump packet\n&quot;</a>
<a name="ln743">       &quot;BGP packet dump\n&quot;</a>
<a name="ln744">       &quot;Dump all BGP packets\nDump all BGP packets (Extended Tiemstamp Header)\n&quot;</a>
<a name="ln745">       &quot;Dump BGP updates only\nDump BGP updates only (Extended Tiemstamp Header)\n&quot;</a>
<a name="ln746">       &quot;Dump whole BGP routing table\n&quot;</a>
<a name="ln747">       &quot;Output filename\n&quot;</a>
<a name="ln748">       &quot;Interval of output\n&quot;)</a>
<a name="ln749">{</a>
<a name="ln750">  int bgp_dump_type = 0;</a>
<a name="ln751">  const char *interval = NULL;</a>
<a name="ln752">  struct bgp_dump *bgp_dump_struct = NULL;</a>
<a name="ln753">  const struct bgp_dump_type_map *map = NULL;</a>
<a name="ln754"> </a>
<a name="ln755">  for (map = bgp_dump_type_map; map-&gt;str; map++)</a>
<a name="ln756">    if (strcmp(argv[0], map-&gt;str) == 0)</a>
<a name="ln757">      bgp_dump_type = map-&gt;type;</a>
<a name="ln758"> </a>
<a name="ln759">  switch (bgp_dump_type)</a>
<a name="ln760">    {</a>
<a name="ln761">      case BGP_DUMP_ALL:</a>
<a name="ln762">      case BGP_DUMP_ALL_ET:</a>
<a name="ln763">        bgp_dump_struct = &amp;bgp_dump_all;</a>
<a name="ln764">        break;</a>
<a name="ln765">      case BGP_DUMP_UPDATES:</a>
<a name="ln766">      case BGP_DUMP_UPDATES_ET:</a>
<a name="ln767">        bgp_dump_struct = &amp;bgp_dump_updates;</a>
<a name="ln768">        break;</a>
<a name="ln769">      case BGP_DUMP_ROUTES:</a>
<a name="ln770">      default:</a>
<a name="ln771">        bgp_dump_struct = &amp;bgp_dump_routes;</a>
<a name="ln772">        break;</a>
<a name="ln773">    }</a>
<a name="ln774"> </a>
<a name="ln775">  /* When an interval is given */</a>
<a name="ln776">  if (argc == 3)</a>
<a name="ln777">      interval = argv[2];</a>
<a name="ln778"> </a>
<a name="ln779">  return bgp_dump_set (vty, bgp_dump_struct, bgp_dump_type,</a>
<a name="ln780">                       argv[1], interval);</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">DEFUN (no_dump_bgp_all,</a>
<a name="ln784">       no_dump_bgp_all_cmd,</a>
<a name="ln785">       &quot;no dump bgp (all|updates|routes-mrt) [PATH] [INTERVAL]&quot;,</a>
<a name="ln786">       NO_STR</a>
<a name="ln787">       &quot;Stop dump packet\n&quot;</a>
<a name="ln788">       &quot;Stop BGP packet dump\n&quot;</a>
<a name="ln789">       &quot;Stop dump process all/all-et\n&quot;</a>
<a name="ln790">       &quot;Stop dump process updates/updates-et\n&quot;</a>
<a name="ln791">       &quot;Stop dump process route-mrt\n&quot;)</a>
<a name="ln792">{</a>
<a name="ln793">  return bgp_dump_unset (vty, &amp;bgp_dump_all);</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">/* BGP node structure. */</a>
<a name="ln797">static struct cmd_node bgp_dump_node =</a>
<a name="ln798">{</a>
<a name="ln799">  DUMP_NODE,</a>
<a name="ln800">  &quot;&quot;,</a>
<a name="ln801">  1</a>
<a name="ln802">};</a>
<a name="ln803"> </a>
<a name="ln804">#if 0</a>
<a name="ln805">char *</a>
<a name="ln806">config_time2str (unsigned int interval)</a>
<a name="ln807">{</a>
<a name="ln808">  static char buf[BUFSIZ];</a>
<a name="ln809"> </a>
<a name="ln810">  buf[0] = '\0';</a>
<a name="ln811"> </a>
<a name="ln812">  if (interval / 3600)</a>
<a name="ln813">    {</a>
<a name="ln814">      sprintf (buf, &quot;%dh&quot;, interval / 3600);</a>
<a name="ln815">      interval %= 3600;</a>
<a name="ln816">    }</a>
<a name="ln817">  if (interval / 60)</a>
<a name="ln818">    {</a>
<a name="ln819">      sprintf (buf + strlen (buf), &quot;%dm&quot;, interval /60);</a>
<a name="ln820">      interval %= 60;</a>
<a name="ln821">    }</a>
<a name="ln822">  if (interval)</a>
<a name="ln823">    {</a>
<a name="ln824">      sprintf (buf + strlen (buf), &quot;%d&quot;, interval);</a>
<a name="ln825">    }</a>
<a name="ln826">  return buf;</a>
<a name="ln827">}</a>
<a name="ln828">#endif</a>
<a name="ln829"> </a>
<a name="ln830">static int</a>
<a name="ln831">config_write_bgp_dump (struct vty *vty)</a>
<a name="ln832">{</a>
<a name="ln833">  if (bgp_dump_all.filename)</a>
<a name="ln834">    {</a>
<a name="ln835">      const char *type_str = &quot;all&quot;;</a>
<a name="ln836">      if (bgp_dump_all.type == BGP_DUMP_ALL_ET)</a>
<a name="ln837">          type_str = &quot;all-et&quot;;</a>
<a name="ln838"> </a>
<a name="ln839">      if (bgp_dump_all.interval_str)</a>
<a name="ln840">	vty_out (vty, &quot;dump bgp %s %s %s%s&quot;, type_str,</a>
<a name="ln841">		 bgp_dump_all.filename, bgp_dump_all.interval_str,</a>
<a name="ln842">		 VTY_NEWLINE);</a>
<a name="ln843">      else</a>
<a name="ln844">	vty_out (vty, &quot;dump bgp %s %s%s&quot;, type_str,</a>
<a name="ln845">		 bgp_dump_all.filename, VTY_NEWLINE);</a>
<a name="ln846">    }</a>
<a name="ln847">  if (bgp_dump_updates.filename)</a>
<a name="ln848">    {</a>
<a name="ln849">      const char *type_str = &quot;updates&quot;;</a>
<a name="ln850">      if (bgp_dump_updates.type == BGP_DUMP_UPDATES_ET)</a>
<a name="ln851">        type_str = &quot;updates-et&quot;;</a>
<a name="ln852"> </a>
<a name="ln853">      if (bgp_dump_updates.interval_str)</a>
<a name="ln854">	vty_out (vty, &quot;dump bgp %s %s %s%s&quot;, type_str,</a>
<a name="ln855">		 bgp_dump_updates.filename, bgp_dump_updates.interval_str,</a>
<a name="ln856">		 VTY_NEWLINE);</a>
<a name="ln857">      else</a>
<a name="ln858">	vty_out (vty, &quot;dump bgp updates %s%s&quot;, </a>
<a name="ln859">		 bgp_dump_updates.filename, VTY_NEWLINE);</a>
<a name="ln860">    }</a>
<a name="ln861">  if (bgp_dump_routes.filename)</a>
<a name="ln862">    {</a>
<a name="ln863">      if (bgp_dump_routes.interval_str)</a>
<a name="ln864">	vty_out (vty, &quot;dump bgp routes-mrt %s %s%s&quot;, </a>
<a name="ln865">		 bgp_dump_routes.filename, bgp_dump_routes.interval_str,</a>
<a name="ln866">		 VTY_NEWLINE);</a>
<a name="ln867">    }</a>
<a name="ln868">  return 0;</a>
<a name="ln869">}</a>
<a name="ln870"> </a>
<a name="ln871">/* Initialize BGP packet dump functionality. */</a>
<a name="ln872">void</a>
<a name="ln873">bgp_dump_init (void)</a>
<a name="ln874">{</a>
<a name="ln875">  memset (&amp;bgp_dump_all, 0, sizeof (struct bgp_dump));</a>
<a name="ln876">  memset (&amp;bgp_dump_updates, 0, sizeof (struct bgp_dump));</a>
<a name="ln877">  memset (&amp;bgp_dump_routes, 0, sizeof (struct bgp_dump));</a>
<a name="ln878"> </a>
<a name="ln879">  bgp_dump_obuf = stream_new ((BGP_MAX_PACKET_SIZE &lt;&lt; 1)</a>
<a name="ln880">                              + BGP_DUMP_MSG_HEADER + BGP_DUMP_HEADER_SIZE);</a>
<a name="ln881"> </a>
<a name="ln882">  install_node (&amp;bgp_dump_node, config_write_bgp_dump);</a>
<a name="ln883"> </a>
<a name="ln884">  install_element (CONFIG_NODE, &amp;dump_bgp_all_cmd);</a>
<a name="ln885">  install_element (CONFIG_NODE, &amp;no_dump_bgp_all_cmd);</a>
<a name="ln886">}</a>
<a name="ln887"> </a>
<a name="ln888">void</a>
<a name="ln889">bgp_dump_finish (void)</a>
<a name="ln890">{</a>
<a name="ln891">  stream_free (bgp_dump_obuf);</a>
<a name="ln892">  bgp_dump_obuf = NULL;</a>
<a name="ln893">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="620"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'seen_m' is always false.</p></div>
<div class="balloon" rel="628"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'seen_m' is always false.</p></div>
<div class="balloon" rel="698"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v773/" target="_blank">V773</a> The return value of function 'bgp_dump_open_file' is required to be utilized. A resource leak is possible.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
