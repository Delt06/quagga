
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf6_route.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (C) 2003 Yasuhiro Ohara</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the </a>
<a name="ln18"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330, </a>
<a name="ln19"> * Boston, MA 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;log.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;table.h&quot;</a>
<a name="ln28">#include &quot;vty.h&quot;</a>
<a name="ln29">#include &quot;command.h&quot;</a>
<a name="ln30">#include &quot;linklist.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;ospf6_proto.h&quot;</a>
<a name="ln33">#include &quot;ospf6_lsa.h&quot;</a>
<a name="ln34">#include &quot;ospf6_lsdb.h&quot;</a>
<a name="ln35">#include &quot;ospf6_route.h&quot;</a>
<a name="ln36">#include &quot;ospf6_top.h&quot;</a>
<a name="ln37">#include &quot;ospf6_area.h&quot;</a>
<a name="ln38">#include &quot;ospf6_interface.h&quot;</a>
<a name="ln39">#include &quot;ospf6d.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">unsigned char conf_debug_ospf6_route = 0;</a>
<a name="ln42"> </a>
<a name="ln43">static char *</a>
<a name="ln44">ospf6_route_table_name (struct ospf6_route_table *table)</a>
<a name="ln45">{</a>
<a name="ln46">  static char name[32];</a>
<a name="ln47">  switch (table-&gt;scope_type)</a>
<a name="ln48">    {</a>
<a name="ln49">      case OSPF6_SCOPE_TYPE_GLOBAL:</a>
<a name="ln50">        {</a>
<a name="ln51">          switch (table-&gt;table_type)</a>
<a name="ln52">            {</a>
<a name="ln53">              case OSPF6_TABLE_TYPE_ROUTES:</a>
<a name="ln54">                snprintf (name, sizeof (name), &quot;global route table&quot;);</a>
<a name="ln55">                break;</a>
<a name="ln56">              case OSPF6_TABLE_TYPE_BORDER_ROUTERS:</a>
<a name="ln57">                snprintf (name, sizeof (name), &quot;global brouter table&quot;);</a>
<a name="ln58">                break;</a>
<a name="ln59">              case OSPF6_TABLE_TYPE_EXTERNAL_ROUTES:</a>
<a name="ln60">                snprintf (name, sizeof (name), &quot;global external table&quot;);</a>
<a name="ln61">                break;</a>
<a name="ln62">              default:</a>
<a name="ln63">                snprintf (name, sizeof (name), &quot;global unknown table&quot;);</a>
<a name="ln64">                break;</a>
<a name="ln65">            }</a>
<a name="ln66">        }</a>
<a name="ln67">        break;</a>
<a name="ln68"> </a>
<a name="ln69">      case OSPF6_SCOPE_TYPE_AREA:</a>
<a name="ln70">        {</a>
<a name="ln71">          struct ospf6_area *oa = (struct ospf6_area *) table-&gt;scope;</a>
<a name="ln72">          switch (table-&gt;table_type)</a>
<a name="ln73">            {</a>
<a name="ln74">              case OSPF6_TABLE_TYPE_SPF_RESULTS:</a>
<a name="ln75">                snprintf (name, sizeof (name),</a>
<a name="ln76">                          &quot;area %s spf table&quot;, oa-&gt;name);</a>
<a name="ln77">                break;</a>
<a name="ln78">              case OSPF6_TABLE_TYPE_ROUTES:</a>
<a name="ln79">                snprintf (name, sizeof (name),</a>
<a name="ln80">                          &quot;area %s route table&quot;, oa-&gt;name);</a>
<a name="ln81">                break;</a>
<a name="ln82">              case OSPF6_TABLE_TYPE_PREFIX_RANGES:</a>
<a name="ln83">                snprintf (name, sizeof (name),</a>
<a name="ln84">                          &quot;area %s range table&quot;, oa-&gt;name);</a>
<a name="ln85">                break;</a>
<a name="ln86">              case OSPF6_TABLE_TYPE_SUMMARY_PREFIXES:</a>
<a name="ln87">                snprintf (name, sizeof (name),</a>
<a name="ln88">                          &quot;area %s summary prefix table&quot;, oa-&gt;name);</a>
<a name="ln89">                break;</a>
<a name="ln90">              case OSPF6_TABLE_TYPE_SUMMARY_ROUTERS:</a>
<a name="ln91">                snprintf (name, sizeof (name),</a>
<a name="ln92">                          &quot;area %s summary router table&quot;, oa-&gt;name);</a>
<a name="ln93">                break;</a>
<a name="ln94">              default:</a>
<a name="ln95">                snprintf (name, sizeof (name),</a>
<a name="ln96">                          &quot;area %s unknown table&quot;, oa-&gt;name);</a>
<a name="ln97">                break;</a>
<a name="ln98">            }</a>
<a name="ln99">        }</a>
<a name="ln100">        break;</a>
<a name="ln101"> </a>
<a name="ln102">      case OSPF6_SCOPE_TYPE_INTERFACE:</a>
<a name="ln103">        {</a>
<a name="ln104">          struct ospf6_interface *oi = (struct ospf6_interface *) table-&gt;scope;</a>
<a name="ln105">          switch (table-&gt;table_type)</a>
<a name="ln106">            {</a>
<a name="ln107">              case OSPF6_TABLE_TYPE_CONNECTED_ROUTES:</a>
<a name="ln108">                snprintf (name, sizeof (name), &quot;interface %s connected table&quot;,</a>
<a name="ln109">                          oi-&gt;interface-&gt;name);</a>
<a name="ln110">                break;</a>
<a name="ln111">              default:</a>
<a name="ln112">                snprintf (name, sizeof (name), &quot;interface %s unknown table&quot;,</a>
<a name="ln113">                          oi-&gt;interface-&gt;name);</a>
<a name="ln114">                break;</a>
<a name="ln115">            }</a>
<a name="ln116">        }</a>
<a name="ln117">        break;</a>
<a name="ln118"> </a>
<a name="ln119">      default:</a>
<a name="ln120">        {</a>
<a name="ln121">          switch (table-&gt;table_type)</a>
<a name="ln122">            {</a>
<a name="ln123">              case OSPF6_TABLE_TYPE_SPF_RESULTS:</a>
<a name="ln124">                snprintf (name, sizeof (name), &quot;temporary spf table&quot;);</a>
<a name="ln125">                break;</a>
<a name="ln126">              default:</a>
<a name="ln127">                snprintf (name, sizeof (name), &quot;temporary unknown table&quot;);</a>
<a name="ln128">                break;</a>
<a name="ln129">            }</a>
<a name="ln130">        }</a>
<a name="ln131">        break;</a>
<a name="ln132">    }</a>
<a name="ln133">  return name;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">void</a>
<a name="ln137">ospf6_linkstate_prefix (u_int32_t adv_router, u_int32_t id,</a>
<a name="ln138">                        struct prefix *prefix)</a>
<a name="ln139">{</a>
<a name="ln140">  memset (prefix, 0, sizeof (struct prefix));</a>
<a name="ln141">  prefix-&gt;family = AF_INET6;</a>
<a name="ln142">  prefix-&gt;prefixlen = 64;</a>
<a name="ln143">  memcpy (&amp;prefix-&gt;u.prefix6.s6_addr[0], &amp;adv_router, 4);</a>
<a name="ln144">  memcpy (&amp;prefix-&gt;u.prefix6.s6_addr[4], &amp;id, 4);</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">void</a>
<a name="ln148">ospf6_linkstate_prefix2str (struct prefix *prefix, char *buf, int size)</a>
<a name="ln149">{</a>
<a name="ln150">  u_int32_t adv_router, id;</a>
<a name="ln151">  char adv_router_str[16], id_str[16];</a>
<a name="ln152">  memcpy (&amp;adv_router, &amp;prefix-&gt;u.prefix6.s6_addr[0], 4);</a>
<a name="ln153">  memcpy (&amp;id, &amp;prefix-&gt;u.prefix6.s6_addr[4], 4);</a>
<a name="ln154">  inet_ntop (AF_INET, &amp;adv_router, adv_router_str, sizeof (adv_router_str));</a>
<a name="ln155">  inet_ntop (AF_INET, &amp;id, id_str, sizeof (id_str));</a>
<a name="ln156">  if (ntohl (id))</a>
<a name="ln157">    snprintf (buf, size, &quot;%s Net-ID: %s&quot;, adv_router_str, id_str);</a>
<a name="ln158">  else</a>
<a name="ln159">    snprintf (buf, size, &quot;%s&quot;, adv_router_str);</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">/* Global strings for logging */</a>
<a name="ln163">const char *ospf6_dest_type_str[OSPF6_DEST_TYPE_MAX] =</a>
<a name="ln164">{ &quot;Unknown&quot;, &quot;Router&quot;, &quot;Network&quot;, &quot;Discard&quot;, &quot;Linkstate&quot;, &quot;AddressRange&quot;, };</a>
<a name="ln165"> </a>
<a name="ln166">const char *ospf6_dest_type_substr[OSPF6_DEST_TYPE_MAX] =</a>
<a name="ln167">{ &quot;?&quot;, &quot;R&quot;, &quot;N&quot;, &quot;D&quot;, &quot;L&quot;, &quot;A&quot;, };</a>
<a name="ln168"> </a>
<a name="ln169">const char *ospf6_path_type_str[OSPF6_PATH_TYPE_MAX] =</a>
<a name="ln170">{ &quot;Unknown&quot;, &quot;Intra-Area&quot;, &quot;Inter-Area&quot;, &quot;External-1&quot;, &quot;External-2&quot;, };</a>
<a name="ln171"> </a>
<a name="ln172">const char *ospf6_path_type_substr[OSPF6_PATH_TYPE_MAX] =</a>
<a name="ln173">{ &quot;??&quot;, &quot;IA&quot;, &quot;IE&quot;, &quot;E1&quot;, &quot;E2&quot;, };</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">struct ospf6_route *</a>
<a name="ln177">ospf6_route_create (void)</a>
<a name="ln178">{</a>
<a name="ln179">  struct ospf6_route *route;</a>
<a name="ln180">  route = XCALLOC (MTYPE_OSPF6_ROUTE, sizeof (struct ospf6_route));</a>
<a name="ln181">  return route;</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">void</a>
<a name="ln185">ospf6_route_delete (struct ospf6_route *route)</a>
<a name="ln186">{</a>
<a name="ln187">  XFREE (MTYPE_OSPF6_ROUTE, route);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">struct ospf6_route *</a>
<a name="ln191">ospf6_route_copy (struct ospf6_route *route)</a>
<a name="ln192">{</a>
<a name="ln193">  struct ospf6_route *new;</a>
<a name="ln194"> </a>
<a name="ln195">  new = ospf6_route_create ();</a>
<a name="ln196">  memcpy (new, route, sizeof (struct ospf6_route));</a>
<a name="ln197">  new-&gt;rnode = NULL;</a>
<a name="ln198">  new-&gt;prev = NULL;</a>
<a name="ln199">  new-&gt;next = NULL;</a>
<a name="ln200">  new-&gt;table = NULL;</a>
<a name="ln201">  new-&gt;lock = 0;</a>
<a name="ln202">  return new;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">void</a>
<a name="ln206">ospf6_route_lock (struct ospf6_route *route)</a>
<a name="ln207">{</a>
<a name="ln208">  route-&gt;lock++;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">void</a>
<a name="ln212">ospf6_route_unlock (struct ospf6_route *route)</a>
<a name="ln213">{</a>
<a name="ln214">  assert (route-&gt;lock &gt; 0);</a>
<a name="ln215">  route-&gt;lock--;</a>
<a name="ln216">  if (route-&gt;lock == 0)</a>
<a name="ln217">    {</a>
<a name="ln218">      /* Can't detach from the table until here</a>
<a name="ln219">         because ospf6_route_next () will use</a>
<a name="ln220">         the 'route-&gt;table' pointer for logging */</a>
<a name="ln221">      route-&gt;table = NULL;</a>
<a name="ln222">      ospf6_route_delete (route);</a>
<a name="ln223">    }</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/* Route compare function. If ra is more preferred, it returns</a>
<a name="ln227">   less than 0. If rb is more preferred returns greater than 0.</a>
<a name="ln228">   Otherwise (neither one is preferred), returns 0 */</a>
<a name="ln229">static int</a>
<a name="ln230">ospf6_route_cmp (struct ospf6_route *ra, struct ospf6_route *rb)</a>
<a name="ln231">{</a>
<a name="ln232">  assert (ospf6_route_is_same (ra, rb));</a>
<a name="ln233">  assert (OSPF6_PATH_TYPE_NONE &lt; ra-&gt;path.type &amp;&amp;</a>
<a name="ln234">          ra-&gt;path.type &lt; OSPF6_PATH_TYPE_MAX);</a>
<a name="ln235">  assert (OSPF6_PATH_TYPE_NONE &lt; rb-&gt;path.type &amp;&amp;</a>
<a name="ln236">          rb-&gt;path.type &lt; OSPF6_PATH_TYPE_MAX);</a>
<a name="ln237"> </a>
<a name="ln238">  if (ra-&gt;type != rb-&gt;type)</a>
<a name="ln239">    return (ra-&gt;type - rb-&gt;type);</a>
<a name="ln240"> </a>
<a name="ln241">  if (ra-&gt;path.area_id != rb-&gt;path.area_id)</a>
<a name="ln242">    return (ntohl (ra-&gt;path.area_id) - ntohl (rb-&gt;path.area_id));</a>
<a name="ln243"> </a>
<a name="ln244">  if (ra-&gt;path.type != rb-&gt;path.type)</a>
<a name="ln245">    return (ra-&gt;path.type - rb-&gt;path.type);</a>
<a name="ln246"> </a>
<a name="ln247">  if (ra-&gt;path.type == OSPF6_PATH_TYPE_EXTERNAL2)</a>
<a name="ln248">    {</a>
<a name="ln249">      if (ra-&gt;path.cost_e2 != rb-&gt;path.cost_e2)</a>
<a name="ln250">        return (ra-&gt;path.cost_e2 - rb-&gt;path.cost_e2);</a>
<a name="ln251">    }</a>
<a name="ln252">  else</a>
<a name="ln253">    {</a>
<a name="ln254">      if (ra-&gt;path.cost != rb-&gt;path.cost)</a>
<a name="ln255">        return (ra-&gt;path.cost - rb-&gt;path.cost);</a>
<a name="ln256">    }</a>
<a name="ln257"> </a>
<a name="ln258">  return 0;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">struct ospf6_route *</a>
<a name="ln262">ospf6_route_lookup (struct prefix *prefix,</a>
<a name="ln263">                    struct ospf6_route_table *table)</a>
<a name="ln264">{</a>
<a name="ln265">  struct route_node *node;</a>
<a name="ln266">  struct ospf6_route *route;</a>
<a name="ln267"> </a>
<a name="ln268">  node = route_node_lookup (table-&gt;table, prefix);</a>
<a name="ln269">  if (node == NULL)</a>
<a name="ln270">    return NULL;</a>
<a name="ln271"> </a>
<a name="ln272">  route = (struct ospf6_route *) node-&gt;info;</a>
<a name="ln273">  return route;</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">struct ospf6_route *</a>
<a name="ln277">ospf6_route_lookup_identical (struct ospf6_route *route,</a>
<a name="ln278">                              struct ospf6_route_table *table)</a>
<a name="ln279">{</a>
<a name="ln280">  struct ospf6_route *target;</a>
<a name="ln281"> </a>
<a name="ln282">  for (target = ospf6_route_lookup (&amp;route-&gt;prefix, table);</a>
<a name="ln283">       target; target = target-&gt;next)</a>
<a name="ln284">    {</a>
<a name="ln285">      if (ospf6_route_is_identical (target, route))</a>
<a name="ln286">        return target;</a>
<a name="ln287">    }</a>
<a name="ln288">  return NULL;</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">struct ospf6_route *</a>
<a name="ln292">ospf6_route_lookup_bestmatch (struct prefix *prefix,</a>
<a name="ln293">                              struct ospf6_route_table *table)</a>
<a name="ln294">{</a>
<a name="ln295">  struct route_node *node;</a>
<a name="ln296">  struct ospf6_route *route;</a>
<a name="ln297"> </a>
<a name="ln298">  node = route_node_match (table-&gt;table, prefix);</a>
<a name="ln299">  if (node == NULL)</a>
<a name="ln300">    return NULL;</a>
<a name="ln301">  route_unlock_node (node);</a>
<a name="ln302"> </a>
<a name="ln303">  route = (struct ospf6_route *) node-&gt;info;</a>
<a name="ln304">  return route;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">#ifdef DEBUG</a>
<a name="ln308">static void</a>
<a name="ln309">route_table_assert (struct ospf6_route_table *table)</a>
<a name="ln310">{</a>
<a name="ln311">  struct ospf6_route *prev, *r, *next;</a>
<a name="ln312">  char buf[64];</a>
<a name="ln313">  unsigned int link_error = 0, num = 0;</a>
<a name="ln314">  </a>
<a name="ln315">  r = ospf6_route_head (table);</a>
<a name="ln316">  prev = NULL;</a>
<a name="ln317">  while (r)</a>
<a name="ln318">    {</a>
<a name="ln319">      if (r-&gt;prev != prev)</a>
<a name="ln320">        link_error++;</a>
<a name="ln321">      </a>
<a name="ln322">      next = ospf6_route_next (r);</a>
<a name="ln323">      </a>
<a name="ln324">      if (r-&gt;next != next)</a>
<a name="ln325">        link_error++;</a>
<a name="ln326">      </a>
<a name="ln327">      prev = r;</a>
<a name="ln328">      r = next;</a>
<a name="ln329">    }</a>
<a name="ln330">  </a>
<a name="ln331">  for (r = ospf6_route_head (table); r; r = ospf6_route_next (r))</a>
<a name="ln332">    num++;</a>
<a name="ln333">  </a>
<a name="ln334">  if (link_error == 0 &amp;&amp; num == table-&gt;count)</a>
<a name="ln335">    return;</a>
<a name="ln336"> </a>
<a name="ln337">  zlog_err (&quot;PANIC !!&quot;);</a>
<a name="ln338">  zlog_err (&quot;Something has gone wrong with ospf6_route_table[%p]&quot;, table);</a>
<a name="ln339">  zlog_debug (&quot;table count = %d, real number = %d&quot;, table-&gt;count, num);</a>
<a name="ln340">  zlog_debug (&quot;DUMP START&quot;);</a>
<a name="ln341">  for (r = ospf6_route_head (table); r; r = ospf6_route_next (r))</a>
<a name="ln342">    {</a>
<a name="ln343">      prefix2str (&amp;r-&gt;prefix, buf, sizeof (buf));</a>
<a name="ln344">      zlog_info (&quot;%p&lt;-[%p]-&gt;%p : %s&quot;, r-&gt;prev, r, r-&gt;next, buf);</a>
<a name="ln345">    }</a>
<a name="ln346">  zlog_debug (&quot;DUMP END&quot;);</a>
<a name="ln347"> </a>
<a name="ln348">  assert (link_error == 0 &amp;&amp; num == table-&gt;count);</a>
<a name="ln349">}</a>
<a name="ln350">#define ospf6_route_table_assert(t) (route_table_assert (t))</a>
<a name="ln351">#else</a>
<a name="ln352">#define ospf6_route_table_assert(t) ((void) 0)</a>
<a name="ln353">#endif /*DEBUG*/</a>
<a name="ln354"> </a>
<a name="ln355">struct ospf6_route *</a>
<a name="ln356">ospf6_route_add (struct ospf6_route *route,</a>
<a name="ln357">                 struct ospf6_route_table *table)</a>
<a name="ln358">{</a>
<a name="ln359">  struct route_node *node, *nextnode, *prevnode;</a>
<a name="ln360">  struct ospf6_route *current = NULL;</a>
<a name="ln361">  struct ospf6_route *prev = NULL, *old = NULL, *next = NULL;</a>
<a name="ln362">  char buf[64];</a>
<a name="ln363">  struct timeval now;</a>
<a name="ln364"> </a>
<a name="ln365">  assert (route-&gt;rnode == NULL);</a>
<a name="ln366">  assert (route-&gt;lock == 0);</a>
<a name="ln367">  assert (route-&gt;next == NULL);</a>
<a name="ln368">  assert (route-&gt;prev == NULL);</a>
<a name="ln369"> </a>
<a name="ln370">  if (route-&gt;type == OSPF6_DEST_TYPE_LINKSTATE)</a>
<a name="ln371">    ospf6_linkstate_prefix2str (&amp;route-&gt;prefix, buf, sizeof (buf));</a>
<a name="ln372">  else</a>
<a name="ln373">    prefix2str (&amp;route-&gt;prefix, buf, sizeof (buf));</a>
<a name="ln374"> </a>
<a name="ln375">  if (IS_OSPF6_DEBUG_ROUTE (MEMORY))</a>
<a name="ln376">    zlog_debug (&quot;%s %p: route add %p: %s&quot;, ospf6_route_table_name (table),</a>
<a name="ln377">                (void *)table, (void *)route, buf);</a>
<a name="ln378">  else if (IS_OSPF6_DEBUG_ROUTE (TABLE))</a>
<a name="ln379">    zlog_debug (&quot;%s: route add: %s&quot;, ospf6_route_table_name (table), buf);</a>
<a name="ln380"> </a>
<a name="ln381">  quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now);</a>
<a name="ln382"> </a>
<a name="ln383">  node = route_node_get (table-&gt;table, &amp;route-&gt;prefix);</a>
<a name="ln384">  route-&gt;rnode = node;</a>
<a name="ln385"> </a>
<a name="ln386">  /* find place to insert */</a>
<a name="ln387">  for (current = node-&gt;info; current; current = current-&gt;next)</a>
<a name="ln388">    {</a>
<a name="ln389">      if (! ospf6_route_is_same (current, route))</a>
<a name="ln390">        next = current;</a>
<a name="ln391">      else if (current-&gt;type != route-&gt;type)</a>
<a name="ln392">        prev = current;</a>
<a name="ln393">      else if (ospf6_route_is_same_origin (current, route))</a>
<a name="ln394">        old = current;</a>
<a name="ln395">      else if (ospf6_route_cmp (current, route) &gt; 0)</a>
<a name="ln396">        next = current;</a>
<a name="ln397">      else</a>
<a name="ln398">        prev = current;</a>
<a name="ln399"> </a>
<a name="ln400">      if (old || next)</a>
<a name="ln401">        break;</a>
<a name="ln402">    }</a>
<a name="ln403"> </a>
<a name="ln404">  if (old)</a>
<a name="ln405">    {</a>
<a name="ln406">      /* if route does not actually change, return unchanged */</a>
<a name="ln407">      if (ospf6_route_is_identical (old, route))</a>
<a name="ln408">        {</a>
<a name="ln409">          if (IS_OSPF6_DEBUG_ROUTE (MEMORY))</a>
<a name="ln410">            zlog_debug (&quot;%s %p: route add %p: needless update of %p&quot;,</a>
<a name="ln411">                        ospf6_route_table_name (table),</a>
<a name="ln412">                        (void *)table, (void *)route, (void *)old);</a>
<a name="ln413">          else if (IS_OSPF6_DEBUG_ROUTE (TABLE))</a>
<a name="ln414">            zlog_debug (&quot;%s: route add: needless update&quot;,</a>
<a name="ln415">                        ospf6_route_table_name (table));</a>
<a name="ln416"> </a>
<a name="ln417">          ospf6_route_delete (route);</a>
<a name="ln418">          SET_FLAG (old-&gt;flag, OSPF6_ROUTE_ADD);</a>
<a name="ln419">          ospf6_route_table_assert (table);</a>
<a name="ln420"> </a>
<a name="ln421">          return old;</a>
<a name="ln422">        }</a>
<a name="ln423"> </a>
<a name="ln424">      if (IS_OSPF6_DEBUG_ROUTE (MEMORY))</a>
<a name="ln425">        zlog_debug (&quot;%s %p: route add %p: update of %p&quot;,</a>
<a name="ln426">                    ospf6_route_table_name (table),</a>
<a name="ln427">                    (void *)table, (void *)route, (void *)old);</a>
<a name="ln428">      else if (IS_OSPF6_DEBUG_ROUTE (TABLE))</a>
<a name="ln429">        zlog_debug (&quot;%s: route add: update&quot;,</a>
<a name="ln430">                    ospf6_route_table_name (table));</a>
<a name="ln431"> </a>
<a name="ln432">      /* replace old one if exists */</a>
<a name="ln433">      if (node-&gt;info == old)</a>
<a name="ln434">        {</a>
<a name="ln435">          node-&gt;info = route;</a>
<a name="ln436">          SET_FLAG (route-&gt;flag, OSPF6_ROUTE_BEST);</a>
<a name="ln437">        }</a>
<a name="ln438"> </a>
<a name="ln439">      if (old-&gt;prev)</a>
<a name="ln440">        old-&gt;prev-&gt;next = route;</a>
<a name="ln441">      route-&gt;prev = old-&gt;prev;</a>
<a name="ln442">      if (old-&gt;next)</a>
<a name="ln443">        old-&gt;next-&gt;prev = route;</a>
<a name="ln444">      route-&gt;next = old-&gt;next;</a>
<a name="ln445"> </a>
<a name="ln446">      route-&gt;installed = old-&gt;installed;</a>
<a name="ln447">      route-&gt;changed = now;</a>
<a name="ln448">      assert (route-&gt;table == NULL);</a>
<a name="ln449">      route-&gt;table = table;</a>
<a name="ln450"> </a>
<a name="ln451">      ospf6_route_unlock (old); /* will be deleted later */</a>
<a name="ln452">      ospf6_route_lock (route);</a>
<a name="ln453"> </a>
<a name="ln454">      SET_FLAG (route-&gt;flag, OSPF6_ROUTE_CHANGE);</a>
<a name="ln455">      ospf6_route_table_assert (table);</a>
<a name="ln456"> </a>
<a name="ln457">      if (table-&gt;hook_add)</a>
<a name="ln458">        (*table-&gt;hook_add) (route);</a>
<a name="ln459"> </a>
<a name="ln460">      return route;</a>
<a name="ln461">    }</a>
<a name="ln462"> </a>
<a name="ln463">  /* insert if previous or next node found */</a>
<a name="ln464">  if (prev || next)</a>
<a name="ln465">    {</a>
<a name="ln466">      if (IS_OSPF6_DEBUG_ROUTE (MEMORY))</a>
<a name="ln467">        zlog_debug (&quot;%s %p: route add %p: another path: prev %p, next %p&quot;,</a>
<a name="ln468">                    ospf6_route_table_name (table),</a>
<a name="ln469">                    (void *)table, (void *)route, (void *)prev, (void *)next);</a>
<a name="ln470">      else if (IS_OSPF6_DEBUG_ROUTE (TABLE))</a>
<a name="ln471">        zlog_debug (&quot;%s: route add: another path found&quot;,</a>
<a name="ln472">                    ospf6_route_table_name (table));</a>
<a name="ln473"> </a>
<a name="ln474">      if (prev == NULL)</a>
<a name="ln475">        prev = next-&gt;prev;</a>
<a name="ln476">      if (next == NULL)</a>
<a name="ln477">        next = prev-&gt;next;</a>
<a name="ln478"> </a>
<a name="ln479">      if (prev)</a>
<a name="ln480">        prev-&gt;next = route;</a>
<a name="ln481">      route-&gt;prev = prev;</a>
<a name="ln482">      if (next)</a>
<a name="ln483">        next-&gt;prev = route;</a>
<a name="ln484">      route-&gt;next = next;</a>
<a name="ln485"> </a>
<a name="ln486">      if (node-&gt;info == next)</a>
<a name="ln487">        {</a>
<a name="ln488">          assert (next-&gt;rnode == node);</a>
<a name="ln489">          node-&gt;info = route;</a>
<a name="ln490">          UNSET_FLAG (next-&gt;flag, OSPF6_ROUTE_BEST);</a>
<a name="ln491">          SET_FLAG (route-&gt;flag, OSPF6_ROUTE_BEST);</a>
<a name="ln492">          if (IS_OSPF6_DEBUG_ROUTE (MEMORY))</a>
<a name="ln493">            zlog_info (&quot;%s %p: route add %p: replacing previous best: %p&quot;,</a>
<a name="ln494">                       ospf6_route_table_name (table),</a>
<a name="ln495">                       (void *)table, (void *)route, (void *)next);</a>
<a name="ln496">        }</a>
<a name="ln497"> </a>
<a name="ln498">      route-&gt;installed = now;</a>
<a name="ln499">      route-&gt;changed = now;</a>
<a name="ln500">      assert (route-&gt;table == NULL);</a>
<a name="ln501">      route-&gt;table = table;</a>
<a name="ln502"> </a>
<a name="ln503">      ospf6_route_lock (route);</a>
<a name="ln504">      table-&gt;count++;</a>
<a name="ln505">      ospf6_route_table_assert (table);</a>
<a name="ln506"> </a>
<a name="ln507">      SET_FLAG (route-&gt;flag, OSPF6_ROUTE_ADD);</a>
<a name="ln508">      if (table-&gt;hook_add)</a>
<a name="ln509">        (*table-&gt;hook_add) (route);</a>
<a name="ln510"> </a>
<a name="ln511">      return route;</a>
<a name="ln512">    }</a>
<a name="ln513"> </a>
<a name="ln514">  /* Else, this is the brand new route regarding to the prefix */</a>
<a name="ln515">  if (IS_OSPF6_DEBUG_ROUTE (MEMORY))</a>
<a name="ln516">    zlog_debug (&quot;%s %p: route add %p: brand new route&quot;,</a>
<a name="ln517">                ospf6_route_table_name (table), (void *)table, (void *)route);</a>
<a name="ln518">  else if (IS_OSPF6_DEBUG_ROUTE (TABLE))</a>
<a name="ln519">    zlog_debug (&quot;%s: route add: brand new route&quot;,</a>
<a name="ln520">                ospf6_route_table_name (table));</a>
<a name="ln521"> </a>
<a name="ln522">  assert (node-&gt;info == NULL);</a>
<a name="ln523">  node-&gt;info = route;</a>
<a name="ln524">  SET_FLAG (route-&gt;flag, OSPF6_ROUTE_BEST);</a>
<a name="ln525">  ospf6_route_lock (route);</a>
<a name="ln526">  route-&gt;installed = now;</a>
<a name="ln527">  route-&gt;changed = now;</a>
<a name="ln528">  assert (route-&gt;table == NULL);</a>
<a name="ln529">  route-&gt;table = table;</a>
<a name="ln530"> </a>
<a name="ln531">  /* lookup real existing next route */</a>
<a name="ln532">  nextnode = node;</a>
<a name="ln533">  route_lock_node (nextnode);</a>
<a name="ln534">  do {</a>
<a name="ln535">    nextnode = route_next (nextnode);</a>
<a name="ln536">  } while (nextnode &amp;&amp; nextnode-&gt;info == NULL);</a>
<a name="ln537"> </a>
<a name="ln538">  /* set next link */</a>
<a name="ln539">  if (nextnode == NULL)</a>
<a name="ln540">    route-&gt;next = NULL;</a>
<a name="ln541">  else</a>
<a name="ln542">    {</a>
<a name="ln543">      route_unlock_node (nextnode);</a>
<a name="ln544"> </a>
<a name="ln545">      next = nextnode-&gt;info;</a>
<a name="ln546">      route-&gt;next = next;</a>
<a name="ln547">      next-&gt;prev = route;</a>
<a name="ln548">    }</a>
<a name="ln549"> </a>
<a name="ln550">  /* lookup real existing prev route */</a>
<a name="ln551">  prevnode = node;</a>
<a name="ln552">  route_lock_node (prevnode);</a>
<a name="ln553">  do {</a>
<a name="ln554">    prevnode = route_prev (prevnode);</a>
<a name="ln555">  } while (prevnode &amp;&amp; prevnode-&gt;info == NULL);</a>
<a name="ln556"> </a>
<a name="ln557">  /* set prev link */</a>
<a name="ln558">  if (prevnode == NULL)</a>
<a name="ln559">    route-&gt;prev = NULL;</a>
<a name="ln560">  else</a>
<a name="ln561">    {</a>
<a name="ln562">      route_unlock_node (prevnode);</a>
<a name="ln563"> </a>
<a name="ln564">      prev = prevnode-&gt;info;</a>
<a name="ln565">      while (prev-&gt;next &amp;&amp; ospf6_route_is_same (prev, prev-&gt;next))</a>
<a name="ln566">        prev = prev-&gt;next;</a>
<a name="ln567">      route-&gt;prev = prev;</a>
<a name="ln568">      prev-&gt;next = route;</a>
<a name="ln569">    }</a>
<a name="ln570"> </a>
<a name="ln571">  table-&gt;count++;</a>
<a name="ln572">  ospf6_route_table_assert (table);</a>
<a name="ln573"> </a>
<a name="ln574">  SET_FLAG (route-&gt;flag, OSPF6_ROUTE_ADD);</a>
<a name="ln575">  if (table-&gt;hook_add)</a>
<a name="ln576">    (*table-&gt;hook_add) (route);</a>
<a name="ln577"> </a>
<a name="ln578">  return route;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">void</a>
<a name="ln582">ospf6_route_remove (struct ospf6_route *route,</a>
<a name="ln583">                    struct ospf6_route_table *table)</a>
<a name="ln584">{</a>
<a name="ln585">  struct route_node *node;</a>
<a name="ln586">  struct ospf6_route *current;</a>
<a name="ln587">  char buf[64];</a>
<a name="ln588"> </a>
<a name="ln589">  if (route-&gt;type == OSPF6_DEST_TYPE_LINKSTATE)</a>
<a name="ln590">    ospf6_linkstate_prefix2str (&amp;route-&gt;prefix, buf, sizeof (buf));</a>
<a name="ln591">  else</a>
<a name="ln592">    prefix2str (&amp;route-&gt;prefix, buf, sizeof (buf));</a>
<a name="ln593"> </a>
<a name="ln594">  if (IS_OSPF6_DEBUG_ROUTE (MEMORY))</a>
<a name="ln595">    zlog_debug (&quot;%s %p: route remove %p: %s&quot;,</a>
<a name="ln596">                ospf6_route_table_name (table),</a>
<a name="ln597">                (void *)table, (void *)route, buf);</a>
<a name="ln598">  else if (IS_OSPF6_DEBUG_ROUTE (TABLE))</a>
<a name="ln599">    zlog_debug (&quot;%s: route remove: %s&quot;, ospf6_route_table_name (table), buf);</a>
<a name="ln600"> </a>
<a name="ln601">  node = route_node_lookup (table-&gt;table, &amp;route-&gt;prefix);</a>
<a name="ln602">  assert (node);</a>
<a name="ln603"> </a>
<a name="ln604">  /* find the route to remove, making sure that the route pointer</a>
<a name="ln605">     is from the route table. */</a>
<a name="ln606">  current = node-&gt;info;</a>
<a name="ln607">  while (current &amp;&amp; ospf6_route_is_same (current, route))</a>
<a name="ln608">    {</a>
<a name="ln609">      if (current == route)</a>
<a name="ln610">        break;</a>
<a name="ln611">      current = current-&gt;next;</a>
<a name="ln612">    }</a>
<a name="ln613">  assert (current == route);</a>
<a name="ln614"> </a>
<a name="ln615">  /* adjust doubly linked list */</a>
<a name="ln616">  if (route-&gt;prev)</a>
<a name="ln617">    route-&gt;prev-&gt;next = route-&gt;next;</a>
<a name="ln618">  if (route-&gt;next)</a>
<a name="ln619">    route-&gt;next-&gt;prev = route-&gt;prev;</a>
<a name="ln620"> </a>
<a name="ln621">  if (node-&gt;info == route)</a>
<a name="ln622">    {</a>
<a name="ln623">      if (route-&gt;next &amp;&amp; route-&gt;next-&gt;rnode == node)</a>
<a name="ln624">        {</a>
<a name="ln625">          node-&gt;info = route-&gt;next;</a>
<a name="ln626">          SET_FLAG (route-&gt;next-&gt;flag, OSPF6_ROUTE_BEST);</a>
<a name="ln627">        }</a>
<a name="ln628">      else</a>
<a name="ln629">        node-&gt;info = NULL; /* should unlock route_node here ? */</a>
<a name="ln630">    }</a>
<a name="ln631"> </a>
<a name="ln632">  table-&gt;count--;</a>
<a name="ln633">  ospf6_route_table_assert (table);</a>
<a name="ln634"> </a>
<a name="ln635">  SET_FLAG (route-&gt;flag, OSPF6_ROUTE_WAS_REMOVED);</a>
<a name="ln636"> </a>
<a name="ln637">  if (table-&gt;hook_remove)</a>
<a name="ln638">    (*table-&gt;hook_remove) (route);</a>
<a name="ln639"> </a>
<a name="ln640">  ospf6_route_unlock (route);</a>
<a name="ln641">}</a>
<a name="ln642"> </a>
<a name="ln643">struct ospf6_route *</a>
<a name="ln644">ospf6_route_head (struct ospf6_route_table *table)</a>
<a name="ln645">{</a>
<a name="ln646">  struct route_node *node;</a>
<a name="ln647">  struct ospf6_route *route;</a>
<a name="ln648"> </a>
<a name="ln649">  node = route_top (table-&gt;table);</a>
<a name="ln650">  if (node == NULL)</a>
<a name="ln651">    return NULL;</a>
<a name="ln652"> </a>
<a name="ln653">  /* skip to the real existing entry */</a>
<a name="ln654">  while (node &amp;&amp; node-&gt;info == NULL)</a>
<a name="ln655">    node = route_next (node);</a>
<a name="ln656">  if (node == NULL)</a>
<a name="ln657">    return NULL;</a>
<a name="ln658"> </a>
<a name="ln659">  route_unlock_node (node);</a>
<a name="ln660">  assert (node-&gt;info);</a>
<a name="ln661"> </a>
<a name="ln662">  route = (struct ospf6_route *) node-&gt;info;</a>
<a name="ln663">  assert (route-&gt;prev == NULL);</a>
<a name="ln664">  assert (route-&gt;table == table);</a>
<a name="ln665">  ospf6_route_lock (route);</a>
<a name="ln666"> </a>
<a name="ln667">  if (IS_OSPF6_DEBUG_ROUTE (MEMORY))</a>
<a name="ln668">    zlog_info (&quot;%s %p: route head: %p&lt;-[%p]-&gt;%p&quot;,</a>
<a name="ln669">               ospf6_route_table_name (table), (void *)table,</a>
<a name="ln670">               (void *)route-&gt;prev, (void *)route, (void *)route-&gt;next);</a>
<a name="ln671"> </a>
<a name="ln672">  return route;</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">struct ospf6_route *</a>
<a name="ln676">ospf6_route_next (struct ospf6_route *route)</a>
<a name="ln677">{</a>
<a name="ln678">  struct ospf6_route *next = route-&gt;next;</a>
<a name="ln679"> </a>
<a name="ln680">  if (IS_OSPF6_DEBUG_ROUTE (MEMORY))</a>
<a name="ln681">    zlog_info (&quot;%s %p: route next: %p&lt;-[%p]-&gt;%p&quot;,</a>
<a name="ln682">               ospf6_route_table_name (route-&gt;table), (void *)route-&gt;table,</a>
<a name="ln683">               (void *)route-&gt;prev, (void *)route, (void *)route-&gt;next);</a>
<a name="ln684"> </a>
<a name="ln685">  ospf6_route_unlock (route);</a>
<a name="ln686">  if (next)</a>
<a name="ln687">    ospf6_route_lock (next);</a>
<a name="ln688"> </a>
<a name="ln689">  return next;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">struct ospf6_route *</a>
<a name="ln693">ospf6_route_best_next (struct ospf6_route *route)</a>
<a name="ln694">{</a>
<a name="ln695">  struct route_node *rnode;</a>
<a name="ln696">  struct ospf6_route *next;</a>
<a name="ln697"> </a>
<a name="ln698">  ospf6_route_unlock (route);</a>
<a name="ln699"> </a>
<a name="ln700">  rnode = route-&gt;rnode;</a>
<a name="ln701">  route_lock_node (rnode);</a>
<a name="ln702">  rnode = route_next (rnode);</a>
<a name="ln703">  while (rnode &amp;&amp; rnode-&gt;info == NULL)</a>
<a name="ln704">    rnode = route_next (rnode);</a>
<a name="ln705">  if (rnode == NULL)</a>
<a name="ln706">    return NULL;</a>
<a name="ln707">  route_unlock_node (rnode);</a>
<a name="ln708"> </a>
<a name="ln709">  assert (rnode-&gt;info);</a>
<a name="ln710">  next = (struct ospf6_route *) rnode-&gt;info;</a>
<a name="ln711">  ospf6_route_lock (next);</a>
<a name="ln712">  return next;</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">struct ospf6_route *</a>
<a name="ln716">ospf6_route_match_head (struct prefix *prefix,</a>
<a name="ln717">                        struct ospf6_route_table *table)</a>
<a name="ln718">{</a>
<a name="ln719">  struct route_node *node;</a>
<a name="ln720">  struct ospf6_route *route;</a>
<a name="ln721"> </a>
<a name="ln722">  /* Walk down tree. */</a>
<a name="ln723">  node = table-&gt;table-&gt;top;</a>
<a name="ln724">  while (node &amp;&amp; node-&gt;p.prefixlen &lt; prefix-&gt;prefixlen &amp;&amp;</a>
<a name="ln725">	 prefix_match (&amp;node-&gt;p, prefix))</a>
<a name="ln726">    node = node-&gt;link[prefix_bit(&amp;prefix-&gt;u.prefix, node-&gt;p.prefixlen)];</a>
<a name="ln727"> </a>
<a name="ln728">  if (node)</a>
<a name="ln729">    route_lock_node (node);</a>
<a name="ln730">  while (node &amp;&amp; node-&gt;info == NULL)</a>
<a name="ln731">    node = route_next (node);</a>
<a name="ln732">  if (node == NULL)</a>
<a name="ln733">    return NULL;</a>
<a name="ln734">  route_unlock_node (node);</a>
<a name="ln735"> </a>
<a name="ln736">  if (! prefix_match (prefix, &amp;node-&gt;p))</a>
<a name="ln737">    return NULL;</a>
<a name="ln738"> </a>
<a name="ln739">  route = node-&gt;info;</a>
<a name="ln740">  ospf6_route_lock (route);</a>
<a name="ln741">  return route;</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">struct ospf6_route *</a>
<a name="ln745">ospf6_route_match_next (struct prefix *prefix,</a>
<a name="ln746">                        struct ospf6_route *route)</a>
<a name="ln747">{</a>
<a name="ln748">  struct ospf6_route *next;</a>
<a name="ln749"> </a>
<a name="ln750">  next = ospf6_route_next (route);</a>
<a name="ln751">  if (next &amp;&amp; ! prefix_match (prefix, &amp;next-&gt;prefix))</a>
<a name="ln752">    {</a>
<a name="ln753">      ospf6_route_unlock (next);</a>
<a name="ln754">      next = NULL;</a>
<a name="ln755">    }</a>
<a name="ln756"> </a>
<a name="ln757">  return next;</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">void</a>
<a name="ln761">ospf6_route_remove_all (struct ospf6_route_table *table)</a>
<a name="ln762">{</a>
<a name="ln763">  struct ospf6_route *route;</a>
<a name="ln764">  for (route = ospf6_route_head (table); route;</a>
<a name="ln765">       route = ospf6_route_next (route))</a>
<a name="ln766">    ospf6_route_remove (route, table);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">struct ospf6_route_table *</a>
<a name="ln770">ospf6_route_table_create (int s, int t)</a>
<a name="ln771">{</a>
<a name="ln772">  struct ospf6_route_table *new;</a>
<a name="ln773">  new = XCALLOC (MTYPE_OSPF6_ROUTE, sizeof (struct ospf6_route_table));</a>
<a name="ln774">  new-&gt;table = route_table_init ();</a>
<a name="ln775">  new-&gt;scope_type = s;</a>
<a name="ln776">  new-&gt;table_type = t;</a>
<a name="ln777">  return new;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">void</a>
<a name="ln781">ospf6_route_table_delete (struct ospf6_route_table *table)</a>
<a name="ln782">{</a>
<a name="ln783">  ospf6_route_remove_all (table);</a>
<a name="ln784">  route_table_finish (table-&gt;table);</a>
<a name="ln785">  XFREE (MTYPE_OSPF6_ROUTE, table);</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788"> </a>
<a name="ln789">/* VTY commands */</a>
<a name="ln790">void</a>
<a name="ln791">ospf6_route_show (struct vty *vty, struct ospf6_route *route)</a>
<a name="ln792">{</a>
<a name="ln793">  int i;</a>
<a name="ln794">  char destination[64], nexthop[64];</a>
<a name="ln795">  char duration[16];</a>
<a name="ln796">  const char *ifname;</a>
<a name="ln797">  struct timeval now, res;</a>
<a name="ln798"> </a>
<a name="ln799">  quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now);</a>
<a name="ln800">  timersub (&amp;now, &amp;route-&gt;changed, &amp;res);</a>
<a name="ln801">  timerstring (&amp;res, duration, sizeof (duration));</a>
<a name="ln802"> </a>
<a name="ln803">  /* destination */</a>
<a name="ln804">  if (route-&gt;type == OSPF6_DEST_TYPE_LINKSTATE)</a>
<a name="ln805">    ospf6_linkstate_prefix2str (&amp;route-&gt;prefix, destination,</a>
<a name="ln806">                                sizeof (destination));</a>
<a name="ln807">  else if (route-&gt;type == OSPF6_DEST_TYPE_ROUTER)</a>
<a name="ln808">    inet_ntop (route-&gt;prefix.family, &amp;route-&gt;prefix.u.prefix,</a>
<a name="ln809">               destination, sizeof (destination));</a>
<a name="ln810">  else</a>
<a name="ln811">    prefix2str (&amp;route-&gt;prefix, destination, sizeof (destination));</a>
<a name="ln812"> </a>
<a name="ln813">  /* nexthop */</a>
<a name="ln814">  inet_ntop (AF_INET6, &amp;route-&gt;nexthop[0].address, nexthop,</a>
<a name="ln815">             sizeof (nexthop));</a>
<a name="ln816">  ifname = ifindex2ifname (route-&gt;nexthop[0].ifindex);</a>
<a name="ln817"> </a>
<a name="ln818">  vty_out (vty, &quot;%c%1s %2s %-30s %-25s %6.*s %s%s&quot;,</a>
<a name="ln819">           (ospf6_route_is_best (route) ? '*' : ' '),</a>
<a name="ln820">           OSPF6_DEST_TYPE_SUBSTR (route-&gt;type),</a>
<a name="ln821">           OSPF6_PATH_TYPE_SUBSTR (route-&gt;path.type),</a>
<a name="ln822">           destination, nexthop, IFNAMSIZ, ifname, duration, VNL);</a>
<a name="ln823"> </a>
<a name="ln824">  for (i = 1; i &lt; OSPF6_MULTI_PATH_LIMIT &amp;&amp;</a>
<a name="ln825">       ospf6_nexthop_is_set (&amp;route-&gt;nexthop[i]); i++)</a>
<a name="ln826">    {</a>
<a name="ln827">      /* nexthop */</a>
<a name="ln828">      inet_ntop (AF_INET6, &amp;route-&gt;nexthop[i].address, nexthop,</a>
<a name="ln829">                 sizeof (nexthop));</a>
<a name="ln830">      ifname = ifindex2ifname (route-&gt;nexthop[i].ifindex);</a>
<a name="ln831"> </a>
<a name="ln832">      vty_out (vty, &quot;%c%1s %2s %-30s %-25s %6.*s %s%s&quot;,</a>
<a name="ln833">               ' ', &quot;&quot;, &quot;&quot;, &quot;&quot;, nexthop, IFNAMSIZ, ifname, &quot;&quot;, VNL);</a>
<a name="ln834">    }</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">void</a>
<a name="ln838">ospf6_route_show_detail (struct vty *vty, struct ospf6_route *route)</a>
<a name="ln839">{</a>
<a name="ln840">  const char *ifname;</a>
<a name="ln841">  char destination[64], nexthop[64];</a>
<a name="ln842">  char area_id[16], id[16], adv_router[16], capa[16], options[16];</a>
<a name="ln843">  struct timeval now, res;</a>
<a name="ln844">  char duration[16];</a>
<a name="ln845">  int i;</a>
<a name="ln846"> </a>
<a name="ln847">  quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now);</a>
<a name="ln848"> </a>
<a name="ln849">  /* destination */</a>
<a name="ln850">  if (route-&gt;type == OSPF6_DEST_TYPE_LINKSTATE)</a>
<a name="ln851">    ospf6_linkstate_prefix2str (&amp;route-&gt;prefix, destination,</a>
<a name="ln852">                                sizeof (destination));</a>
<a name="ln853">  else if (route-&gt;type == OSPF6_DEST_TYPE_ROUTER)</a>
<a name="ln854">    inet_ntop (route-&gt;prefix.family, &amp;route-&gt;prefix.u.prefix,</a>
<a name="ln855">               destination, sizeof (destination));</a>
<a name="ln856">  else</a>
<a name="ln857">    prefix2str (&amp;route-&gt;prefix, destination, sizeof (destination));</a>
<a name="ln858">  vty_out (vty, &quot;Destination: %s%s&quot;, destination, VNL);</a>
<a name="ln859"> </a>
<a name="ln860">  /* destination type */</a>
<a name="ln861">  vty_out (vty, &quot;Destination type: %s%s&quot;,</a>
<a name="ln862">           OSPF6_DEST_TYPE_NAME (route-&gt;type),</a>
<a name="ln863">           VNL);</a>
<a name="ln864"> </a>
<a name="ln865">  /* Time */</a>
<a name="ln866">  timersub (&amp;now, &amp;route-&gt;installed, &amp;res);</a>
<a name="ln867">  timerstring (&amp;res, duration, sizeof (duration));</a>
<a name="ln868">  vty_out (vty, &quot;Installed Time: %s ago%s&quot;, duration, VNL);</a>
<a name="ln869"> </a>
<a name="ln870">  timersub (&amp;now, &amp;route-&gt;changed, &amp;res);</a>
<a name="ln871">  timerstring (&amp;res, duration, sizeof (duration));</a>
<a name="ln872">  vty_out (vty, &quot;  Changed Time: %s ago%s&quot;, duration, VNL);</a>
<a name="ln873"> </a>
<a name="ln874">  /* Debugging info */</a>
<a name="ln875">  vty_out (vty, &quot;Lock: %d Flags: %s%s%s%s%s&quot;, route-&gt;lock,</a>
<a name="ln876">           (CHECK_FLAG (route-&gt;flag, OSPF6_ROUTE_BEST)   ? &quot;B&quot; : &quot;-&quot;),</a>
<a name="ln877">           (CHECK_FLAG (route-&gt;flag, OSPF6_ROUTE_ADD)    ? &quot;A&quot; : &quot;-&quot;),</a>
<a name="ln878">           (CHECK_FLAG (route-&gt;flag, OSPF6_ROUTE_REMOVE) ? &quot;R&quot; : &quot;-&quot;),</a>
<a name="ln879">           (CHECK_FLAG (route-&gt;flag, OSPF6_ROUTE_CHANGE) ? &quot;C&quot; : &quot;-&quot;),</a>
<a name="ln880">           VNL);</a>
<a name="ln881">  vty_out (vty, &quot;Memory: prev: %p this: %p next: %p%s&quot;,</a>
<a name="ln882">           (void *)route-&gt;prev, (void *)route, (void *)route-&gt;next, VNL);</a>
<a name="ln883"> </a>
<a name="ln884">  /* Path section */</a>
<a name="ln885"> </a>
<a name="ln886">  /* Area-ID */</a>
<a name="ln887">  inet_ntop (AF_INET, &amp;route-&gt;path.area_id, area_id, sizeof (area_id));</a>
<a name="ln888">  vty_out (vty, &quot;Associated Area: %s%s&quot;, area_id, VNL);</a>
<a name="ln889"> </a>
<a name="ln890">  /* Path type */</a>
<a name="ln891">  vty_out (vty, &quot;Path Type: %s%s&quot;,</a>
<a name="ln892">           OSPF6_PATH_TYPE_NAME (route-&gt;path.type), VNL);</a>
<a name="ln893"> </a>
<a name="ln894">  /* LS Origin */</a>
<a name="ln895">  inet_ntop (AF_INET, &amp;route-&gt;path.origin.id, id, sizeof (id));</a>
<a name="ln896">  inet_ntop (AF_INET, &amp;route-&gt;path.origin.adv_router, adv_router,</a>
<a name="ln897">             sizeof (adv_router));</a>
<a name="ln898">  vty_out (vty, &quot;LS Origin: %s Id: %s Adv: %s%s&quot;,</a>
<a name="ln899">           ospf6_lstype_name (route-&gt;path.origin.type),</a>
<a name="ln900">           id, adv_router, VNL);</a>
<a name="ln901"> </a>
<a name="ln902">  /* Options */</a>
<a name="ln903">  ospf6_options_printbuf (route-&gt;path.options, options, sizeof (options));</a>
<a name="ln904">  vty_out (vty, &quot;Options: %s%s&quot;, options, VNL);</a>
<a name="ln905"> </a>
<a name="ln906">  /* Router Bits */</a>
<a name="ln907">  ospf6_capability_printbuf (route-&gt;path.router_bits, capa, sizeof (capa));</a>
<a name="ln908">  vty_out (vty, &quot;Router Bits: %s%s&quot;, capa, VNL);</a>
<a name="ln909"> </a>
<a name="ln910">  /* Prefix Options */</a>
<a name="ln911">  vty_out (vty, &quot;Prefix Options: xxx%s&quot;, VNL);</a>
<a name="ln912"> </a>
<a name="ln913">  /* Metrics */</a>
<a name="ln914">  vty_out (vty, &quot;Metric Type: %d%s&quot;, route-&gt;path.metric_type,</a>
<a name="ln915">           VNL);</a>
<a name="ln916">  vty_out (vty, &quot;Metric: %d (%d)%s&quot;,</a>
<a name="ln917">           route-&gt;path.cost, route-&gt;path.cost_e2, VNL);</a>
<a name="ln918"> </a>
<a name="ln919">  /* Nexthops */</a>
<a name="ln920">  vty_out (vty, &quot;Nexthop:%s&quot;, VNL);</a>
<a name="ln921">  for (i = 0; i &lt; OSPF6_MULTI_PATH_LIMIT &amp;&amp;</a>
<a name="ln922">       ospf6_nexthop_is_set (&amp;route-&gt;nexthop[i]); i++)</a>
<a name="ln923">    {</a>
<a name="ln924">      /* nexthop */</a>
<a name="ln925">      inet_ntop (AF_INET6, &amp;route-&gt;nexthop[i].address, nexthop,</a>
<a name="ln926">                 sizeof (nexthop));</a>
<a name="ln927">      ifname = ifindex2ifname (route-&gt;nexthop[i].ifindex);</a>
<a name="ln928">      vty_out (vty, &quot;  %s %.*s%s&quot;, nexthop, IFNAMSIZ, ifname, VNL);</a>
<a name="ln929">    }</a>
<a name="ln930">  vty_out (vty, &quot;%s&quot;, VNL);</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">static void</a>
<a name="ln934">ospf6_route_show_table_summary (struct vty *vty,</a>
<a name="ln935">                                struct ospf6_route_table *table)</a>
<a name="ln936">{</a>
<a name="ln937">  struct ospf6_route *route, *prev = NULL;</a>
<a name="ln938">  int i, pathtype[OSPF6_PATH_TYPE_MAX];</a>
<a name="ln939">  unsigned int number = 0;</a>
<a name="ln940">  int nhinval = 0, ecmp = 0;</a>
<a name="ln941">  int alternative = 0, destination = 0;</a>
<a name="ln942"> </a>
<a name="ln943">  for (i = 0; i &lt; OSPF6_PATH_TYPE_MAX; i++)</a>
<a name="ln944">    pathtype[i] = 0;</a>
<a name="ln945"> </a>
<a name="ln946">  for (route = ospf6_route_head (table); route;</a>
<a name="ln947">       route = ospf6_route_next (route))</a>
<a name="ln948">    {</a>
<a name="ln949">      if (prev == NULL || ! ospf6_route_is_same (prev, route))</a>
<a name="ln950">        destination++;</a>
<a name="ln951">      else</a>
<a name="ln952">        alternative++;</a>
<a name="ln953">      if (! ospf6_nexthop_is_set (&amp;route-&gt;nexthop[0]))</a>
<a name="ln954">        nhinval++;</a>
<a name="ln955">      else if (ospf6_nexthop_is_set (&amp;route-&gt;nexthop[1]))</a>
<a name="ln956">        ecmp++;</a>
<a name="ln957">      pathtype[route-&gt;path.type]++;</a>
<a name="ln958">      number++;</a>
<a name="ln959"> </a>
<a name="ln960">      prev = route;</a>
<a name="ln961">    }</a>
<a name="ln962"> </a>
<a name="ln963">  assert (number == table-&gt;count);</a>
<a name="ln964"> </a>
<a name="ln965">  vty_out (vty, &quot;Number of OSPFv3 routes: %d%s&quot;, number, VNL);</a>
<a name="ln966">  vty_out (vty, &quot;Number of Destination: %d%s&quot;, destination, VNL);</a>
<a name="ln967">  vty_out (vty, &quot;Number of Alternative routes: %d%s&quot;, alternative, VNL);</a>
<a name="ln968">  vty_out (vty, &quot;Number of Equal Cost Multi Path: %d%s&quot;, ecmp, VNL);</a>
<a name="ln969">  for (i = OSPF6_PATH_TYPE_INTRA; i &lt;= OSPF6_PATH_TYPE_EXTERNAL2; i++)</a>
<a name="ln970">    {</a>
<a name="ln971">      vty_out (vty, &quot;Number of %s routes: %d%s&quot;,</a>
<a name="ln972">               OSPF6_PATH_TYPE_NAME (i), pathtype[i], VNL);</a>
<a name="ln973">    }</a>
<a name="ln974">}</a>
<a name="ln975"> </a>
<a name="ln976">static void</a>
<a name="ln977">ospf6_route_show_table_prefix (struct vty *vty,</a>
<a name="ln978">                               struct prefix *prefix,</a>
<a name="ln979">                               struct ospf6_route_table *table)</a>
<a name="ln980">{</a>
<a name="ln981">  struct ospf6_route *route;</a>
<a name="ln982"> </a>
<a name="ln983">  route = ospf6_route_lookup (prefix, table);</a>
<a name="ln984">  if (route == NULL)</a>
<a name="ln985">    return;</a>
<a name="ln986"> </a>
<a name="ln987">  ospf6_route_lock (route);</a>
<a name="ln988">  while (route &amp;&amp; ospf6_route_is_prefix (prefix, route))</a>
<a name="ln989">    {</a>
<a name="ln990">      /* Specifying a prefix will always display details */</a>
<a name="ln991">      ospf6_route_show_detail (vty, route);</a>
<a name="ln992">      route = ospf6_route_next (route);</a>
<a name="ln993">    }</a>
<a name="ln994">  if (route)</a>
<a name="ln995">    ospf6_route_unlock (route);</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">static void</a>
<a name="ln999">ospf6_route_show_table_address (struct vty *vty,</a>
<a name="ln1000">                                struct prefix *prefix,</a>
<a name="ln1001">                                struct ospf6_route_table *table)</a>
<a name="ln1002">{</a>
<a name="ln1003">  struct ospf6_route *route;</a>
<a name="ln1004"> </a>
<a name="ln1005">  route = ospf6_route_lookup_bestmatch (prefix, table);</a>
<a name="ln1006">  if (route == NULL)</a>
<a name="ln1007">    return;</a>
<a name="ln1008"> </a>
<a name="ln1009">  prefix = &amp;route-&gt;prefix;</a>
<a name="ln1010">  ospf6_route_lock (route);</a>
<a name="ln1011">  while (route &amp;&amp; ospf6_route_is_prefix (prefix, route))</a>
<a name="ln1012">    {</a>
<a name="ln1013">      /* Specifying a prefix will always display details */</a>
<a name="ln1014">      ospf6_route_show_detail (vty, route);</a>
<a name="ln1015">      route = ospf6_route_next (route);</a>
<a name="ln1016">    }</a>
<a name="ln1017">  if (route)</a>
<a name="ln1018">    ospf6_route_unlock (route);</a>
<a name="ln1019">}</a>
<a name="ln1020"> </a>
<a name="ln1021">static void</a>
<a name="ln1022">ospf6_route_show_table_match (struct vty *vty, int detail,</a>
<a name="ln1023">                              struct prefix *prefix,</a>
<a name="ln1024">                              struct ospf6_route_table *table)</a>
<a name="ln1025">{</a>
<a name="ln1026">  struct ospf6_route *route;</a>
<a name="ln1027">  assert (prefix-&gt;family);</a>
<a name="ln1028"> </a>
<a name="ln1029">  route = ospf6_route_match_head (prefix, table);</a>
<a name="ln1030">  while (route)</a>
<a name="ln1031">    {</a>
<a name="ln1032">      if (detail)</a>
<a name="ln1033">        ospf6_route_show_detail (vty, route);</a>
<a name="ln1034">      else</a>
<a name="ln1035">        ospf6_route_show (vty, route);</a>
<a name="ln1036">      route = ospf6_route_match_next (prefix, route);</a>
<a name="ln1037">    }</a>
<a name="ln1038">}</a>
<a name="ln1039"> </a>
<a name="ln1040">static void</a>
<a name="ln1041">ospf6_route_show_table_type (struct vty *vty, int detail, u_char type,</a>
<a name="ln1042">                             struct ospf6_route_table *table)</a>
<a name="ln1043">{</a>
<a name="ln1044">  struct ospf6_route *route;</a>
<a name="ln1045"> </a>
<a name="ln1046">  route = ospf6_route_head (table);</a>
<a name="ln1047">  while (route)</a>
<a name="ln1048">    {</a>
<a name="ln1049">      if (route-&gt;path.type == type)</a>
<a name="ln1050">        {</a>
<a name="ln1051">          if (detail)</a>
<a name="ln1052">            ospf6_route_show_detail (vty, route);</a>
<a name="ln1053">          else</a>
<a name="ln1054">            ospf6_route_show (vty, route);</a>
<a name="ln1055">        }</a>
<a name="ln1056">      route = ospf6_route_next (route);</a>
<a name="ln1057">    }</a>
<a name="ln1058">}</a>
<a name="ln1059"> </a>
<a name="ln1060">static void</a>
<a name="ln1061">ospf6_route_show_table (struct vty *vty, int detail,</a>
<a name="ln1062">                        struct ospf6_route_table *table)</a>
<a name="ln1063">{</a>
<a name="ln1064">  struct ospf6_route *route;</a>
<a name="ln1065"> </a>
<a name="ln1066">  route = ospf6_route_head (table);</a>
<a name="ln1067">  while (route)</a>
<a name="ln1068">    {</a>
<a name="ln1069">      if (detail)</a>
<a name="ln1070">        ospf6_route_show_detail (vty, route);</a>
<a name="ln1071">      else</a>
<a name="ln1072">        ospf6_route_show (vty, route);</a>
<a name="ln1073">      route = ospf6_route_next (route);</a>
<a name="ln1074">    }</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">int</a>
<a name="ln1078">ospf6_route_table_show (struct vty *vty, int argc, const char *argv[],</a>
<a name="ln1079">                        struct ospf6_route_table *table)</a>
<a name="ln1080">{</a>
<a name="ln1081">  int summary = 0;</a>
<a name="ln1082">  int match = 0;</a>
<a name="ln1083">  int detail = 0;</a>
<a name="ln1084">  int slash = 0;</a>
<a name="ln1085">  int isprefix = 0;</a>
<a name="ln1086">  int i, ret;</a>
<a name="ln1087">  struct prefix prefix;</a>
<a name="ln1088">  u_char type = 0;</a>
<a name="ln1089"> </a>
<a name="ln1090">  memset (&amp;prefix, 0, sizeof (struct prefix));</a>
<a name="ln1091"> </a>
<a name="ln1092">  for (i = 0; i &lt; argc; i++)</a>
<a name="ln1093">    {</a>
<a name="ln1094">      if (! strcmp (argv[i], &quot;summary&quot;))</a>
<a name="ln1095">        {</a>
<a name="ln1096">          summary++;</a>
<a name="ln1097">          continue;</a>
<a name="ln1098">        }</a>
<a name="ln1099"> </a>
<a name="ln1100">      if (! strcmp (argv[i], &quot;intra-area&quot;))</a>
<a name="ln1101">        {</a>
<a name="ln1102">          type = OSPF6_PATH_TYPE_INTRA;</a>
<a name="ln1103">          continue;</a>
<a name="ln1104">        }</a>
<a name="ln1105"> </a>
<a name="ln1106">      if (! strcmp (argv[i], &quot;inter-area&quot;))</a>
<a name="ln1107">        {</a>
<a name="ln1108">          type = OSPF6_PATH_TYPE_INTER;</a>
<a name="ln1109">          continue;</a>
<a name="ln1110">        }</a>
<a name="ln1111"> </a>
<a name="ln1112">      if (! strcmp (argv[i], &quot;external-1&quot;))</a>
<a name="ln1113">        {</a>
<a name="ln1114">          type = OSPF6_PATH_TYPE_EXTERNAL1;</a>
<a name="ln1115">          continue;</a>
<a name="ln1116">        }</a>
<a name="ln1117"> </a>
<a name="ln1118">      if (! strcmp (argv[i], &quot;external-2&quot;))</a>
<a name="ln1119">        {</a>
<a name="ln1120">          type = OSPF6_PATH_TYPE_EXTERNAL2;</a>
<a name="ln1121">          continue;</a>
<a name="ln1122">        }</a>
<a name="ln1123"> </a>
<a name="ln1124">      if (! strcmp (argv[i], &quot;detail&quot;))</a>
<a name="ln1125">        {</a>
<a name="ln1126">          detail++;</a>
<a name="ln1127">          continue;</a>
<a name="ln1128">        }</a>
<a name="ln1129"> </a>
<a name="ln1130">      if (! strcmp (argv[i], &quot;match&quot;))</a>
<a name="ln1131">        {</a>
<a name="ln1132">          match++;</a>
<a name="ln1133">          continue;</a>
<a name="ln1134">        }</a>
<a name="ln1135"> </a>
<a name="ln1136">      ret = str2prefix (argv[i], &amp;prefix);</a>
<a name="ln1137">      if (ret == 1 &amp;&amp; prefix.family == AF_INET6)</a>
<a name="ln1138">        {</a>
<a name="ln1139">          isprefix++;</a>
<a name="ln1140">          if (strchr (argv[i], '/'))</a>
<a name="ln1141">            slash++;</a>
<a name="ln1142">          continue;</a>
<a name="ln1143">        }</a>
<a name="ln1144"> </a>
<a name="ln1145">      vty_out (vty, &quot;Malformed argument: %s%s&quot;, argv[i], VNL);</a>
<a name="ln1146">      return CMD_SUCCESS;</a>
<a name="ln1147">    }</a>
<a name="ln1148"> </a>
<a name="ln1149">  /* Give summary of this route table */</a>
<a name="ln1150">  if (summary)</a>
<a name="ln1151">    {</a>
<a name="ln1152">      ospf6_route_show_table_summary (vty, table);</a>
<a name="ln1153">      return CMD_SUCCESS;</a>
<a name="ln1154">    }</a>
<a name="ln1155"> </a>
<a name="ln1156">  /* Give exact prefix-match route */</a>
<a name="ln1157">  if (isprefix &amp;&amp; ! match)</a>
<a name="ln1158">    {</a>
<a name="ln1159">      /* If exact address, give best matching route */</a>
<a name="ln1160">      if (! slash)</a>
<a name="ln1161">        ospf6_route_show_table_address (vty, &amp;prefix, table);</a>
<a name="ln1162">      else</a>
<a name="ln1163">        ospf6_route_show_table_prefix (vty, &amp;prefix, table);</a>
<a name="ln1164"> </a>
<a name="ln1165">      return CMD_SUCCESS;</a>
<a name="ln1166">    }</a>
<a name="ln1167"> </a>
<a name="ln1168">  if (match)</a>
<a name="ln1169">    ospf6_route_show_table_match (vty, detail, &amp;prefix, table);</a>
<a name="ln1170">  else if (type)</a>
<a name="ln1171">    ospf6_route_show_table_type (vty, detail, type, table);</a>
<a name="ln1172">  else</a>
<a name="ln1173">    ospf6_route_show_table (vty, detail, table);</a>
<a name="ln1174"> </a>
<a name="ln1175">  return CMD_SUCCESS;</a>
<a name="ln1176">}</a>
<a name="ln1177"> </a>
<a name="ln1178">static void</a>
<a name="ln1179">ospf6_linkstate_show_header (struct vty *vty)</a>
<a name="ln1180">{</a>
<a name="ln1181">  vty_out (vty, &quot;%-7s %-15s %-15s %-8s %-14s %s%s&quot;,</a>
<a name="ln1182">           &quot;Type&quot;, &quot;Router-ID&quot;, &quot;Net-ID&quot;, &quot;Rtr-Bits&quot;, &quot;Options&quot;, &quot;Cost&quot;, VNL);</a>
<a name="ln1183">}</a>
<a name="ln1184"> </a>
<a name="ln1185">static void</a>
<a name="ln1186">ospf6_linkstate_show (struct vty *vty, struct ospf6_route *route)</a>
<a name="ln1187">{</a>
<a name="ln1188">  u_int32_t router, id;</a>
<a name="ln1189">  char routername[16], idname[16], rbits[16], options[16];</a>
<a name="ln1190"> </a>
<a name="ln1191">  router = ospf6_linkstate_prefix_adv_router (&amp;route-&gt;prefix);</a>
<a name="ln1192">  inet_ntop (AF_INET, &amp;router, routername, sizeof (routername));</a>
<a name="ln1193">  id = ospf6_linkstate_prefix_id (&amp;route-&gt;prefix);</a>
<a name="ln1194">  inet_ntop (AF_INET, &amp;id, idname, sizeof (idname));</a>
<a name="ln1195"> </a>
<a name="ln1196">  ospf6_capability_printbuf (route-&gt;path.router_bits, rbits, sizeof (rbits));</a>
<a name="ln1197">  ospf6_options_printbuf (route-&gt;path.options, options, sizeof (options));</a>
<a name="ln1198"> </a>
<a name="ln1199">  if (ntohl (id))</a>
<a name="ln1200">    vty_out (vty, &quot;%-7s %-15s %-15s %-8s %-14s %lu%s&quot;,</a>
<a name="ln1201">             &quot;Network&quot;, routername, idname, rbits, options,</a>
<a name="ln1202">             (unsigned long) route-&gt;path.cost, VNL);</a>
<a name="ln1203">  else</a>
<a name="ln1204">    vty_out (vty, &quot;%-7s %-15s %-15s %-8s %-14s %lu%s&quot;,</a>
<a name="ln1205">             &quot;Router&quot;, routername, idname, rbits, options,</a>
<a name="ln1206">             (unsigned long) route-&gt;path.cost, VNL);</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209"> </a>
<a name="ln1210">static void</a>
<a name="ln1211">ospf6_linkstate_show_table_exact (struct vty *vty,</a>
<a name="ln1212">                                  struct prefix *prefix,</a>
<a name="ln1213">                                  struct ospf6_route_table *table)</a>
<a name="ln1214">{</a>
<a name="ln1215">  struct ospf6_route *route;</a>
<a name="ln1216"> </a>
<a name="ln1217">  route = ospf6_route_lookup (prefix, table);</a>
<a name="ln1218">  if (route == NULL)</a>
<a name="ln1219">    return;</a>
<a name="ln1220"> </a>
<a name="ln1221">  ospf6_route_lock (route);</a>
<a name="ln1222">  while (route &amp;&amp; ospf6_route_is_prefix (prefix, route))</a>
<a name="ln1223">    {</a>
<a name="ln1224">      /* Specifying a prefix will always display details */</a>
<a name="ln1225">      ospf6_route_show_detail (vty, route);</a>
<a name="ln1226">      route = ospf6_route_next (route);</a>
<a name="ln1227">    }</a>
<a name="ln1228">  if (route)</a>
<a name="ln1229">    ospf6_route_unlock (route);</a>
<a name="ln1230">}</a>
<a name="ln1231"> </a>
<a name="ln1232">static void</a>
<a name="ln1233">ospf6_linkstate_show_table (struct vty *vty, int detail,</a>
<a name="ln1234">                            struct ospf6_route_table *table)</a>
<a name="ln1235">{</a>
<a name="ln1236">  struct ospf6_route *route;</a>
<a name="ln1237"> </a>
<a name="ln1238">  if (! detail)</a>
<a name="ln1239">    ospf6_linkstate_show_header (vty);</a>
<a name="ln1240"> </a>
<a name="ln1241">  route = ospf6_route_head (table);</a>
<a name="ln1242">  while (route)</a>
<a name="ln1243">    {</a>
<a name="ln1244">      if (detail)</a>
<a name="ln1245">        ospf6_route_show_detail (vty, route);</a>
<a name="ln1246">      else</a>
<a name="ln1247">        ospf6_linkstate_show (vty, route);</a>
<a name="ln1248">      route = ospf6_route_next (route);</a>
<a name="ln1249">    }</a>
<a name="ln1250">}</a>
<a name="ln1251"> </a>
<a name="ln1252">int</a>
<a name="ln1253">ospf6_linkstate_table_show (struct vty *vty, int argc, const char *argv[],</a>
<a name="ln1254">                            struct ospf6_route_table *table)</a>
<a name="ln1255">{</a>
<a name="ln1256">  int detail = 0;</a>
<a name="ln1257">  int is_id = 0;</a>
<a name="ln1258">  int is_router = 0;</a>
<a name="ln1259">  int i, ret;</a>
<a name="ln1260">  struct prefix router, id, prefix;</a>
<a name="ln1261"> </a>
<a name="ln1262">  memset (&amp;router, 0, sizeof (struct prefix));</a>
<a name="ln1263">  memset (&amp;id, 0, sizeof (struct prefix));</a>
<a name="ln1264">  memset (&amp;prefix, 0, sizeof (struct prefix));</a>
<a name="ln1265"> </a>
<a name="ln1266">  for (i = 0; i &lt; argc; i++)</a>
<a name="ln1267">    {</a>
<a name="ln1268">      if (! strcmp (argv[i], &quot;detail&quot;))</a>
<a name="ln1269">        {</a>
<a name="ln1270">          detail++;</a>
<a name="ln1271">          continue;</a>
<a name="ln1272">        }</a>
<a name="ln1273"> </a>
<a name="ln1274">      if (! is_router)</a>
<a name="ln1275">        {</a>
<a name="ln1276">          ret = str2prefix (argv[i], &amp;router);</a>
<a name="ln1277">          if (ret == 1 &amp;&amp; router.family == AF_INET)</a>
<a name="ln1278">            {</a>
<a name="ln1279">              is_router++;</a>
<a name="ln1280">              continue;</a>
<a name="ln1281">            }</a>
<a name="ln1282">          vty_out (vty, &quot;Malformed argument: %s%s&quot;, argv[i], VNL);</a>
<a name="ln1283">          return CMD_SUCCESS;</a>
<a name="ln1284">        }</a>
<a name="ln1285"> </a>
<a name="ln1286">      if (! is_id)</a>
<a name="ln1287">        {</a>
<a name="ln1288">          ret = str2prefix (argv[i], &amp;id);</a>
<a name="ln1289">          if (ret == 1 &amp;&amp; id.family == AF_INET)</a>
<a name="ln1290">            {</a>
<a name="ln1291">              is_id++;</a>
<a name="ln1292">              continue;</a>
<a name="ln1293">            }</a>
<a name="ln1294">          vty_out (vty, &quot;Malformed argument: %s%s&quot;, argv[i], VNL);</a>
<a name="ln1295">          return CMD_SUCCESS;</a>
<a name="ln1296">        }</a>
<a name="ln1297"> </a>
<a name="ln1298">      vty_out (vty, &quot;Malformed argument: %s%s&quot;, argv[i], VNL);</a>
<a name="ln1299">      return CMD_SUCCESS;</a>
<a name="ln1300">    }</a>
<a name="ln1301"> </a>
<a name="ln1302">  if (is_router)</a>
<a name="ln1303">    ospf6_linkstate_prefix (router.u.prefix4.s_addr,</a>
<a name="ln1304">                            id.u.prefix4.s_addr, &amp;prefix);</a>
<a name="ln1305"> </a>
<a name="ln1306">  if (prefix.family)</a>
<a name="ln1307">    ospf6_linkstate_show_table_exact (vty, &amp;prefix, table);</a>
<a name="ln1308">  else</a>
<a name="ln1309">    ospf6_linkstate_show_table (vty, detail, table);</a>
<a name="ln1310"> </a>
<a name="ln1311">  return CMD_SUCCESS;</a>
<a name="ln1312">}</a>
<a name="ln1313"> </a>
<a name="ln1314"> </a>
<a name="ln1315">void</a>
<a name="ln1316">ospf6_brouter_show_header (struct vty *vty)</a>
<a name="ln1317">{</a>
<a name="ln1318">  vty_out (vty, &quot;%-15s %-8s %-14s %-10s %-15s%s&quot;,</a>
<a name="ln1319">           &quot;Router-ID&quot;, &quot;Rtr-Bits&quot;, &quot;Options&quot;, &quot;Path-Type&quot;, &quot;Area&quot;, VNL);</a>
<a name="ln1320">}</a>
<a name="ln1321"> </a>
<a name="ln1322">void</a>
<a name="ln1323">ospf6_brouter_show (struct vty *vty, struct ospf6_route *route)</a>
<a name="ln1324">{</a>
<a name="ln1325">  u_int32_t adv_router;</a>
<a name="ln1326">  char adv[16], rbits[16], options[16], area[16];</a>
<a name="ln1327"> </a>
<a name="ln1328">  adv_router = ospf6_linkstate_prefix_adv_router (&amp;route-&gt;prefix);</a>
<a name="ln1329">  inet_ntop (AF_INET, &amp;adv_router, adv, sizeof (adv));</a>
<a name="ln1330">  ospf6_capability_printbuf (route-&gt;path.router_bits, rbits, sizeof (rbits));</a>
<a name="ln1331">  ospf6_options_printbuf (route-&gt;path.options, options, sizeof (options));</a>
<a name="ln1332">  inet_ntop (AF_INET, &amp;route-&gt;path.area_id, area, sizeof (area));</a>
<a name="ln1333"> </a>
<a name="ln1334">  /* vty_out (vty, &quot;%-15s %-8s %-14s %-10s %-15s%s&quot;,</a>
<a name="ln1335">           &quot;Router-ID&quot;, &quot;Rtr-Bits&quot;, &quot;Options&quot;, &quot;Path-Type&quot;, &quot;Area&quot;, VNL); */</a>
<a name="ln1336">  vty_out (vty, &quot;%-15s %-8s %-14s %-10s %-15s%s&quot;,</a>
<a name="ln1337">           adv, rbits, options, OSPF6_PATH_TYPE_NAME (route-&gt;path.type),</a>
<a name="ln1338">           area, VNL);</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">DEFUN (debug_ospf6_route,</a>
<a name="ln1342">       debug_ospf6_route_cmd,</a>
<a name="ln1343">       &quot;debug ospf6 route (table|intra-area|inter-area|memory)&quot;,</a>
<a name="ln1344">       DEBUG_STR</a>
<a name="ln1345">       OSPF6_STR</a>
<a name="ln1346">       &quot;Debug route table calculation\n&quot;</a>
<a name="ln1347">       &quot;Debug detail\n&quot;</a>
<a name="ln1348">       &quot;Debug intra-area route calculation\n&quot;</a>
<a name="ln1349">       &quot;Debug inter-area route calculation\n&quot;</a>
<a name="ln1350">       &quot;Debug route memory use\n&quot;</a>
<a name="ln1351">       )</a>
<a name="ln1352">{</a>
<a name="ln1353">  unsigned char level = 0;</a>
<a name="ln1354"> </a>
<a name="ln1355">  if (! strncmp (argv[0], &quot;table&quot;, 5))</a>
<a name="ln1356">    level = OSPF6_DEBUG_ROUTE_TABLE;</a>
<a name="ln1357">  else if (! strncmp (argv[0], &quot;intra&quot;, 5))</a>
<a name="ln1358">    level = OSPF6_DEBUG_ROUTE_INTRA;</a>
<a name="ln1359">  else if (! strncmp (argv[0], &quot;inter&quot;, 5))</a>
<a name="ln1360">    level = OSPF6_DEBUG_ROUTE_INTER;</a>
<a name="ln1361">  else if (! strncmp (argv[0], &quot;memor&quot;, 5))</a>
<a name="ln1362">    level = OSPF6_DEBUG_ROUTE_MEMORY;</a>
<a name="ln1363">  OSPF6_DEBUG_ROUTE_ON (level);</a>
<a name="ln1364">  return CMD_SUCCESS;</a>
<a name="ln1365">}</a>
<a name="ln1366"> </a>
<a name="ln1367">DEFUN (no_debug_ospf6_route,</a>
<a name="ln1368">       no_debug_ospf6_route_cmd,</a>
<a name="ln1369">       &quot;no debug ospf6 route (table|intra-area|inter-area|memory)&quot;,</a>
<a name="ln1370">       NO_STR</a>
<a name="ln1371">       DEBUG_STR</a>
<a name="ln1372">       OSPF6_STR</a>
<a name="ln1373">       &quot;Debug route table calculation\n&quot;</a>
<a name="ln1374">       &quot;Debug intra-area route calculation\n&quot;</a>
<a name="ln1375">       &quot;Debug route memory use\n&quot;)</a>
<a name="ln1376">{</a>
<a name="ln1377">  unsigned char level = 0;</a>
<a name="ln1378"> </a>
<a name="ln1379">  if (! strncmp (argv[0], &quot;table&quot;, 5))</a>
<a name="ln1380">    level = OSPF6_DEBUG_ROUTE_TABLE;</a>
<a name="ln1381">  else if (! strncmp (argv[0], &quot;intra&quot;, 5))</a>
<a name="ln1382">    level = OSPF6_DEBUG_ROUTE_INTRA;</a>
<a name="ln1383">  else if (! strncmp (argv[0], &quot;inter&quot;, 5))</a>
<a name="ln1384">    level = OSPF6_DEBUG_ROUTE_INTER;</a>
<a name="ln1385">  else if (! strncmp (argv[0], &quot;memor&quot;, 5))</a>
<a name="ln1386">    level = OSPF6_DEBUG_ROUTE_MEMORY;</a>
<a name="ln1387">  OSPF6_DEBUG_ROUTE_OFF (level);</a>
<a name="ln1388">  return CMD_SUCCESS;</a>
<a name="ln1389">}</a>
<a name="ln1390"> </a>
<a name="ln1391">int</a>
<a name="ln1392">config_write_ospf6_debug_route (struct vty *vty)</a>
<a name="ln1393">{</a>
<a name="ln1394">  if (IS_OSPF6_DEBUG_ROUTE (TABLE))</a>
<a name="ln1395">    vty_out (vty, &quot;debug ospf6 route table%s&quot;, VNL);</a>
<a name="ln1396">  if (IS_OSPF6_DEBUG_ROUTE (INTRA))</a>
<a name="ln1397">    vty_out (vty, &quot;debug ospf6 route intra-area%s&quot;, VNL);</a>
<a name="ln1398">  if (IS_OSPF6_DEBUG_ROUTE (INTER))</a>
<a name="ln1399">    vty_out (vty, &quot;debug ospf6 route inter-area%s&quot;, VNL);</a>
<a name="ln1400">  return 0;</a>
<a name="ln1401">}</a>
<a name="ln1402"> </a>
<a name="ln1403">void</a>
<a name="ln1404">install_element_ospf6_debug_route (void)</a>
<a name="ln1405">{</a>
<a name="ln1406">  install_element (ENABLE_NODE, &amp;debug_ospf6_route_cmd);</a>
<a name="ln1407">  install_element (ENABLE_NODE, &amp;no_debug_ospf6_route_cmd);</a>
<a name="ln1408">  install_element (CONFIG_NODE, &amp;debug_ospf6_route_cmd);</a>
<a name="ln1409">  install_element (CONFIG_NODE, &amp;no_debug_ospf6_route_cmd);</a>
<a name="ln1410">}</a>
<a name="ln1411"> </a>
<a name="ln1412"> </a>
<a name="ln1413"> </a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="578"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'route_unlock_node' function. Check lines: 578, 533.</p></div>
<div class="balloon" rel="578"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'route_unlock_node' function. Check lines: 578, 552.</p></div>
<div class="balloon" rel="706"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'route_unlock_node' function. Check lines: 706, 701.</p></div>
<div class="balloon" rel="733"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'route_unlock_node' function. Check lines: 733, 729.</p></div>
<div class="balloon" rel="994"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'ospf6_route_unlock' function. Check lines: 994, 987.</p></div>
<div class="balloon" rel="1017"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'ospf6_route_unlock' function. Check lines: 1017, 1010.</p></div>
<div class="balloon" rel="1228"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'ospf6_route_unlock' function. Check lines: 1228, 1221.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
