
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>watchquagga.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">    Monitor status of quagga daemons and restart if necessary.</a>
<a name="ln3"> </a>
<a name="ln4">    Copyright (C) 2004  Andrew J. Schorr</a>
<a name="ln5"> </a>
<a name="ln6">    This program is free software; you can redistribute it and/or modify</a>
<a name="ln7">    it under the terms of the GNU General Public License as published by</a>
<a name="ln8">    the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln9">    (at your option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">    This program is distributed in the hope that it will be useful,</a>
<a name="ln12">    but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln14">    GNU General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">    You should have received a copy of the GNU General Public License</a>
<a name="ln17">    along with this program; if not, write to the Free Software</a>
<a name="ln18">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</a>
<a name="ln19"> */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22">#include &lt;thread.h&gt;</a>
<a name="ln23">#include &lt;log.h&gt;</a>
<a name="ln24">#include &lt;network.h&gt;</a>
<a name="ln25">#include &lt;sigevent.h&gt;</a>
<a name="ln26">#include &lt;lib/version.h&gt;</a>
<a name="ln27">#include &lt;getopt.h&gt;</a>
<a name="ln28">#include &lt;sys/un.h&gt;</a>
<a name="ln29">#include &lt;sys/wait.h&gt;</a>
<a name="ln30">#include &lt;memory.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#ifndef MIN</a>
<a name="ln33">#define MIN(X,Y) (((X) &lt;= (Y)) ? (X) : (Y))</a>
<a name="ln34">#endif</a>
<a name="ln35"> </a>
<a name="ln36">/* Macros to help randomize timers. */</a>
<a name="ln37">#define JITTER(X) ((random() % ((X)+1))-((X)/2))</a>
<a name="ln38">#define FUZZY(X) ((X)+JITTER((X)/20))</a>
<a name="ln39"> </a>
<a name="ln40">#define DEFAULT_PERIOD		5</a>
<a name="ln41">#define DEFAULT_TIMEOUT		10</a>
<a name="ln42">#define DEFAULT_RESTART_TIMEOUT	20</a>
<a name="ln43">#define DEFAULT_LOGLEVEL	LOG_INFO</a>
<a name="ln44">#define DEFAULT_MIN_RESTART	60</a>
<a name="ln45">#define DEFAULT_MAX_RESTART	600</a>
<a name="ln46">#ifdef PATH_WATCHQUAGGA_PID</a>
<a name="ln47">#define DEFAULT_PIDFILE		PATH_WATCHQUAGGA_PID</a>
<a name="ln48">#else</a>
<a name="ln49">#define DEFAULT_PIDFILE		STATEDIR &quot;/watchquagga.pid&quot;</a>
<a name="ln50">#endif</a>
<a name="ln51">#ifdef DAEMON_VTY_DIR</a>
<a name="ln52">#define VTYDIR			DAEMON_VTY_DIR</a>
<a name="ln53">#else</a>
<a name="ln54">#define VTYDIR			STATEDIR</a>
<a name="ln55">#endif</a>
<a name="ln56"> </a>
<a name="ln57">#define PING_TOKEN	&quot;PING&quot;</a>
<a name="ln58"> </a>
<a name="ln59">/* Needs to be global, referenced somewhere inside libzebra. */</a>
<a name="ln60">struct thread_master *master;</a>
<a name="ln61"> </a>
<a name="ln62">typedef enum</a>
<a name="ln63">{</a>
<a name="ln64">  MODE_MONITOR = 0,</a>
<a name="ln65">  MODE_GLOBAL_RESTART,</a>
<a name="ln66">  MODE_SEPARATE_RESTART,</a>
<a name="ln67">  MODE_PHASED_ZEBRA_RESTART,</a>
<a name="ln68">  MODE_PHASED_ALL_RESTART</a>
<a name="ln69">} watch_mode_t;</a>
<a name="ln70"> </a>
<a name="ln71">static const char *mode_str[] =</a>
<a name="ln72">{</a>
<a name="ln73">  &quot;monitor&quot;,</a>
<a name="ln74">  &quot;global restart&quot;,</a>
<a name="ln75">  &quot;individual daemon restart&quot;,</a>
<a name="ln76">  &quot;phased zebra restart&quot;,</a>
<a name="ln77">  &quot;phased global restart for any failure&quot;,</a>
<a name="ln78">};</a>
<a name="ln79"> </a>
<a name="ln80">typedef enum</a>
<a name="ln81">{</a>
<a name="ln82">  PHASE_NONE = 0,</a>
<a name="ln83">  PHASE_STOPS_PENDING,</a>
<a name="ln84">  PHASE_WAITING_DOWN,</a>
<a name="ln85">  PHASE_ZEBRA_RESTART_PENDING,</a>
<a name="ln86">  PHASE_WAITING_ZEBRA_UP</a>
<a name="ln87">} restart_phase_t;</a>
<a name="ln88"> </a>
<a name="ln89">static const char *phase_str[] =</a>
<a name="ln90">{</a>
<a name="ln91">  &quot;None&quot;,</a>
<a name="ln92">  &quot;Stop jobs running&quot;,</a>
<a name="ln93">  &quot;Waiting for other daemons to come down&quot;,</a>
<a name="ln94">  &quot;Zebra restart job running&quot;,</a>
<a name="ln95">  &quot;Waiting for zebra to come up&quot;,</a>
<a name="ln96">  &quot;Start jobs running&quot;,</a>
<a name="ln97">};</a>
<a name="ln98"> </a>
<a name="ln99">#define PHASE_TIMEOUT (3*gs.restart_timeout)</a>
<a name="ln100"> </a>
<a name="ln101">struct restart_info</a>
<a name="ln102">{</a>
<a name="ln103">  const char *name;</a>
<a name="ln104">  const char *what;</a>
<a name="ln105">  pid_t pid;</a>
<a name="ln106">  struct timeval time;</a>
<a name="ln107">  long interval;</a>
<a name="ln108">  struct thread *t_kill;</a>
<a name="ln109">  int kills;</a>
<a name="ln110">};</a>
<a name="ln111"> </a>
<a name="ln112">static struct global_state</a>
<a name="ln113">{</a>
<a name="ln114">  watch_mode_t mode;</a>
<a name="ln115">  restart_phase_t phase;</a>
<a name="ln116">  struct thread *t_phase_hanging;</a>
<a name="ln117">  const char *vtydir;</a>
<a name="ln118">  long period;</a>
<a name="ln119">  long timeout;</a>
<a name="ln120">  long restart_timeout;</a>
<a name="ln121">  long min_restart_interval;</a>
<a name="ln122">  long max_restart_interval;</a>
<a name="ln123">  int do_ping;</a>
<a name="ln124">  struct daemon *daemons;</a>
<a name="ln125">  const char *restart_command;</a>
<a name="ln126">  const char *start_command;</a>
<a name="ln127">  const char *stop_command;</a>
<a name="ln128">  struct restart_info restart;</a>
<a name="ln129">  int unresponsive_restart;</a>
<a name="ln130">  int loglevel;</a>
<a name="ln131">  struct daemon *special;	/* points to zebra when doing phased restart */</a>
<a name="ln132">  int numdaemons;</a>
<a name="ln133">  int numpids;</a>
<a name="ln134">  int numdown;		/* # of daemons that are not UP or UNRESPONSIVE */</a>
<a name="ln135">} gs = {</a>
<a name="ln136">  .mode = MODE_MONITOR,</a>
<a name="ln137">  .phase = PHASE_NONE,</a>
<a name="ln138">  .vtydir = VTYDIR,</a>
<a name="ln139">  .period = 1000*DEFAULT_PERIOD,</a>
<a name="ln140">  .timeout = DEFAULT_TIMEOUT,</a>
<a name="ln141">  .restart_timeout = DEFAULT_RESTART_TIMEOUT,</a>
<a name="ln142">  .loglevel = DEFAULT_LOGLEVEL,</a>
<a name="ln143">  .min_restart_interval = DEFAULT_MIN_RESTART,</a>
<a name="ln144">  .max_restart_interval = DEFAULT_MAX_RESTART,</a>
<a name="ln145">  .do_ping = 1,</a>
<a name="ln146">};</a>
<a name="ln147"> </a>
<a name="ln148">typedef enum</a>
<a name="ln149">{</a>
<a name="ln150">  DAEMON_INIT,</a>
<a name="ln151">  DAEMON_DOWN,</a>
<a name="ln152">  DAEMON_CONNECTING,</a>
<a name="ln153">  DAEMON_UP,</a>
<a name="ln154">  DAEMON_UNRESPONSIVE</a>
<a name="ln155">} daemon_state_t;</a>
<a name="ln156"> </a>
<a name="ln157">#define IS_UP(DMN) \</a>
<a name="ln158">  (((DMN)-&gt;state == DAEMON_UP) || ((DMN)-&gt;state == DAEMON_UNRESPONSIVE))</a>
<a name="ln159"> </a>
<a name="ln160">static const char *state_str[] =</a>
<a name="ln161">{</a>
<a name="ln162">  &quot;Init&quot;,</a>
<a name="ln163">  &quot;Down&quot;,</a>
<a name="ln164">  &quot;Connecting&quot;,</a>
<a name="ln165">  &quot;Up&quot;,</a>
<a name="ln166">  &quot;Unresponsive&quot;,</a>
<a name="ln167">};</a>
<a name="ln168"> </a>
<a name="ln169">struct daemon {</a>
<a name="ln170">  const char *name;</a>
<a name="ln171">  daemon_state_t state;</a>
<a name="ln172">  int fd;</a>
<a name="ln173">  struct timeval echo_sent;</a>
<a name="ln174">  u_int connect_tries;</a>
<a name="ln175">  struct thread *t_wakeup;</a>
<a name="ln176">  struct thread *t_read;</a>
<a name="ln177">  struct thread *t_write;</a>
<a name="ln178">  struct daemon *next;</a>
<a name="ln179">  struct restart_info restart;</a>
<a name="ln180">};</a>
<a name="ln181"> </a>
<a name="ln182">static const struct option longopts[] = </a>
<a name="ln183">{</a>
<a name="ln184">  { &quot;daemon&quot;, no_argument, NULL, 'd'},</a>
<a name="ln185">  { &quot;statedir&quot;, required_argument, NULL, 'S'},</a>
<a name="ln186">  { &quot;no-echo&quot;, no_argument, NULL, 'e'},</a>
<a name="ln187">  { &quot;loglevel&quot;, required_argument, NULL, 'l'},</a>
<a name="ln188">  { &quot;interval&quot;, required_argument, NULL, 'i'},</a>
<a name="ln189">  { &quot;timeout&quot;, required_argument, NULL, 't'},</a>
<a name="ln190">  { &quot;restart-timeout&quot;, required_argument, NULL, 'T'},</a>
<a name="ln191">  { &quot;restart&quot;, required_argument, NULL, 'r'},</a>
<a name="ln192">  { &quot;start-command&quot;, required_argument, NULL, 's'},</a>
<a name="ln193">  { &quot;kill-command&quot;, required_argument, NULL, 'k'},</a>
<a name="ln194">  { &quot;restart-all&quot;, required_argument, NULL, 'R'},</a>
<a name="ln195">  { &quot;all-restart&quot;, no_argument, NULL, 'a'},</a>
<a name="ln196">  { &quot;always-all-restart&quot;, no_argument, NULL, 'A'},</a>
<a name="ln197">  { &quot;unresponsive-restart&quot;, no_argument, NULL, 'z'},</a>
<a name="ln198">  { &quot;min-restart-interval&quot;, required_argument, NULL, 'm'},</a>
<a name="ln199">  { &quot;max-restart-interval&quot;, required_argument, NULL, 'M'},</a>
<a name="ln200">  { &quot;pid-file&quot;, required_argument, NULL, 'p'},</a>
<a name="ln201">  { &quot;blank-string&quot;, required_argument, NULL, 'b'},</a>
<a name="ln202">  { &quot;help&quot;, no_argument, NULL, 'h'},</a>
<a name="ln203">  { &quot;version&quot;, no_argument, NULL, 'v'},</a>
<a name="ln204">  { NULL, 0, NULL, 0 }</a>
<a name="ln205">};</a>
<a name="ln206"> </a>
<a name="ln207">static int try_connect(struct daemon *dmn);</a>
<a name="ln208">static int wakeup_send_echo(struct thread *t_wakeup);</a>
<a name="ln209">static void try_restart(struct daemon *dmn);</a>
<a name="ln210">static void phase_check(void);</a>
<a name="ln211"> </a>
<a name="ln212">static int</a>
<a name="ln213">usage(const char *progname, int status)</a>
<a name="ln214">{</a>
<a name="ln215">  if (status != 0)</a>
<a name="ln216">    fprintf(stderr, &quot;Try `%s --help' for more information.\n&quot;, progname);</a>
<a name="ln217">  else</a>
<a name="ln218">    {</a>
<a name="ln219">      printf(&quot;Usage : %s [OPTION...] &lt;daemon name&gt; ...\n\n\</a>
<a name="ln220">Watchdog program to monitor status of quagga daemons and try to restart\n\</a>
<a name="ln221">them if they are down or unresponsive.  It determines whether a daemon is\n\</a>
<a name="ln222">up based on whether it can connect to the daemon's vty unix stream socket.\n\</a>
<a name="ln223">It then repeatedly sends echo commands over that socket to determine whether\n\</a>
<a name="ln224">the daemon is responsive.  If the daemon crashes, we will receive an EOF\n\</a>
<a name="ln225">on the socket connection and know immediately that the daemon is down.\n\n\</a>
<a name="ln226">The daemons to be monitored should be listed on the command line.\n\n\</a>
<a name="ln227">This program can run in one of 5 modes:\n\n\</a>
<a name="ln228">0. Mode: %s.\n\</a>
<a name="ln229">  Just monitor and report on status changes.  Example:\n\</a>
<a name="ln230">    %s -d zebra ospfd bgpd\n\n\</a>
<a name="ln231">1. Mode: %s.\n\</a>
<a name="ln232">  Whenever any daemon hangs or crashes, use the given command to restart\n\</a>
<a name="ln233">  them all.  Example:\n\</a>
<a name="ln234">    %s -dz \\\n\</a>
<a name="ln235">      -R '/sbin/service zebra restart; /sbin/service ospfd restart' \\\n\</a>
<a name="ln236">      zebra ospfd\n\n\</a>
<a name="ln237">2. Mode: %s.\n\</a>
<a name="ln238">  When any single daemon hangs or crashes, restart only the daemon that's\n\</a>
<a name="ln239">  in trouble using the supplied restart command.  Example:\n\</a>
<a name="ln240">    %s -dz -r '/sbin/service %%s restart' zebra ospfd bgpd\n\n\</a>
<a name="ln241">3. Mode: %s.\n\</a>
<a name="ln242">  The same as the previous mode, except that there is special treatment when\n\</a>
<a name="ln243">  the zebra daemon is in trouble.  In that case, a phased restart approach\n\</a>
<a name="ln244">  is used: 1. stop all other daemons; 2. restart zebra; 3. start the other\n\</a>
<a name="ln245">  daemons.  Example:\n\</a>
<a name="ln246">    %s -adz -r '/sbin/service %%s restart' \\\n\</a>
<a name="ln247">      -s '/sbin/service %%s start' \\\n\</a>
<a name="ln248">      -k '/sbin/service %%s stop' zebra ospfd bgpd\n\n\</a>
<a name="ln249">4. Mode: %s.\n\</a>
<a name="ln250">  This is the same as the previous mode, except that the phased restart\n\</a>
<a name="ln251">  procedure is used whenever any of the daemons hangs or crashes.  Example:\n\</a>
<a name="ln252">    %s -Adz -r '/sbin/service %%s restart' \\\n\</a>
<a name="ln253">      -s '/sbin/service %%s start' \\\n\</a>
<a name="ln254">      -k '/sbin/service %%s stop' zebra ospfd bgpd\n\n\</a>
<a name="ln255">As of this writing, it is believed that mode 2 [%s]\n\</a>
<a name="ln256">is not safe, and mode 3 [%s] may not be safe with some of the\n\</a>
<a name="ln257">routing daemons.\n\n\</a>
<a name="ln258">In order to avoid attempting to restart the daemons in a fast loop,\n\</a>
<a name="ln259">the -m and -M options allow you to control the minimum delay between\n\</a>
<a name="ln260">restart commands.  The minimum restart delay is recalculated each time\n\</a>
<a name="ln261">a restart is attempted: if the time since the last restart attempt exceeds\n\</a>
<a name="ln262">twice the -M value, then the restart delay is set to the -m value.\n\</a>
<a name="ln263">Otherwise, the interval is doubled (but capped at the -M value).\n\n&quot;,</a>
<a name="ln264">        progname,mode_str[0],progname,mode_str[1],progname,mode_str[2],</a>
<a name="ln265">        progname,mode_str[3],progname,mode_str[4],progname,mode_str[2],</a>
<a name="ln266">        mode_str[3]);</a>
<a name="ln267"> </a>
<a name="ln268">      printf(&quot;Options:\n\</a>
<a name="ln269">-d, --daemon	Run in daemon mode.  In this mode, error messages are sent\n\</a>
<a name="ln270">		to syslog instead of stdout.\n\</a>
<a name="ln271">-S, --statedir	Set the vty socket directory (default is %s)\n\</a>
<a name="ln272">-e, --no-echo	Do not ping the daemons to test responsiveness (this\n\</a>
<a name="ln273">		option is necessary if the daemons do not support the\n\</a>
<a name="ln274">		echo command)\n\</a>
<a name="ln275">-l, --loglevel	Set the logging level (default is %d).\n\</a>
<a name="ln276">		The value should range from %d (LOG_EMERG) to %d (LOG_DEBUG),\n\</a>
<a name="ln277">		but it can be set higher than %d if extra-verbose debugging\n\</a>
<a name="ln278">		messages are desired.\n\</a>
<a name="ln279">-m, --min-restart-interval\n\</a>
<a name="ln280">		Set the minimum seconds to wait between invocations of daemon\n\</a>
<a name="ln281">		restart commands (default is %d).\n\</a>
<a name="ln282">-M, --max-restart-interval\n\</a>
<a name="ln283">		Set the maximum seconds to wait between invocations of daemon\n\</a>
<a name="ln284">		restart commands (default is %d).\n\</a>
<a name="ln285">-i, --interval	Set the status polling interval in seconds (default is %d)\n\</a>
<a name="ln286">-t, --timeout	Set the unresponsiveness timeout in seconds (default is %d)\n\</a>
<a name="ln287">-T, --restart-timeout\n\</a>
<a name="ln288">		Set the restart (kill) timeout in seconds (default is %d).\n\</a>
<a name="ln289">		If any background jobs are still running after this much\n\</a>
<a name="ln290">		time has elapsed, they will be killed.\n\</a>
<a name="ln291">-r, --restart	Supply a Bourne shell command to use to restart a single\n\</a>
<a name="ln292">		daemon.  The command string should include '%%s' where the\n\</a>
<a name="ln293">		name of the daemon should be substituted.\n\</a>
<a name="ln294">		Note that -r and -R are incompatible.\n\</a>
<a name="ln295">-s, --start-command\n\</a>
<a name="ln296">		Supply a Bourne shell to command to use to start a single\n\</a>
<a name="ln297">		daemon.  The command string should include '%%s' where the\n\</a>
<a name="ln298">		name of the daemon should be substituted.\n\</a>
<a name="ln299">-k, --kill-command\n\</a>
<a name="ln300">		Supply a Bourne shell to command to use to stop a single\n\</a>
<a name="ln301">		daemon.  The command string should include '%%s' where the\n\</a>
<a name="ln302">		name of the daemon should be substituted.\n\</a>
<a name="ln303">-R, --restart-all\n\</a>
<a name="ln304">		When one or more daemons is down, try to restart everything\n\</a>
<a name="ln305">		using the Bourne shell command supplied as the argument.\n\</a>
<a name="ln306">		Note that -r and -R are incompatible.\n\</a>
<a name="ln307">-z, --unresponsive-restart\n\</a>
<a name="ln308">		When a daemon is unresponsive, treat it as being down for\n\</a>
<a name="ln309">		restart purposes.\n\</a>
<a name="ln310">-a, --all-restart\n\</a>
<a name="ln311">		When zebra hangs or crashes, restart all daemons using\n\</a>
<a name="ln312">		this phased approach: 1. stop all other daemons; 2. restart\n\</a>
<a name="ln313">		zebra; 3. start other daemons.  Requires -r, -s, and -k.\n\</a>
<a name="ln314">-A, --always-all-restart\n\</a>
<a name="ln315">		When any daemon (not just zebra) hangs or crashes, use the\n\</a>
<a name="ln316">		same phased restart mechanism described above for -a.\n\</a>
<a name="ln317">		Requires -r, -s, and -k.\n\</a>
<a name="ln318">-p, --pid-file	Set process identifier file name\n\</a>
<a name="ln319">		(default is %s).\n\</a>
<a name="ln320">-b, --blank-string\n\</a>
<a name="ln321">		When the supplied argument string is found in any of the\n\</a>
<a name="ln322">		various shell command arguments (-r, -s, -k, or -R), replace\n\</a>
<a name="ln323">		it with a space.  This is an ugly hack to circumvent problems\n\</a>
<a name="ln324">		passing command-line arguments with embedded spaces.\n\</a>
<a name="ln325">-v, --version	Print program version\n\</a>
<a name="ln326">-h, --help	Display this help and exit\n&quot;,</a>
<a name="ln327">        VTYDIR,DEFAULT_LOGLEVEL,LOG_EMERG,LOG_DEBUG,LOG_DEBUG,</a>
<a name="ln328">        DEFAULT_MIN_RESTART,DEFAULT_MAX_RESTART,</a>
<a name="ln329">        DEFAULT_PERIOD,DEFAULT_TIMEOUT,DEFAULT_RESTART_TIMEOUT,</a>
<a name="ln330">        DEFAULT_PIDFILE);</a>
<a name="ln331">    }</a>
<a name="ln332"> </a>
<a name="ln333">  return status;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">static pid_t</a>
<a name="ln337">run_background(char *shell_cmd)</a>
<a name="ln338">{</a>
<a name="ln339">  pid_t child;</a>
<a name="ln340"> </a>
<a name="ln341">  switch (child = fork())</a>
<a name="ln342">    {</a>
<a name="ln343">    case -1:</a>
<a name="ln344">      zlog_err(&quot;fork failed, cannot run command [%s]: %s&quot;,</a>
<a name="ln345">	       shell_cmd,safe_strerror(errno));</a>
<a name="ln346">      return -1;</a>
<a name="ln347">    case 0:</a>
<a name="ln348">      /* Child process. */</a>
<a name="ln349">      /* Use separate process group so child processes can be killed easily. */</a>
<a name="ln350">      if (setpgid(0,0) &lt; 0)</a>
<a name="ln351">        zlog_warn(&quot;warning: setpgid(0,0) failed: %s&quot;,safe_strerror(errno));</a>
<a name="ln352">      {</a>
<a name="ln353">	char shell[] = &quot;sh&quot;;</a>
<a name="ln354">	char dashc[] = &quot;-c&quot;;</a>
<a name="ln355">        char *const argv[4] = { shell, dashc, shell_cmd, NULL};</a>
<a name="ln356">	execv(&quot;/bin/sh&quot;, argv);</a>
<a name="ln357">	zlog_err(&quot;execv(/bin/sh -c '%s') failed: %s&quot;,</a>
<a name="ln358">		 shell_cmd,safe_strerror(errno));</a>
<a name="ln359">	_exit(127);</a>
<a name="ln360">      }</a>
<a name="ln361">    default:</a>
<a name="ln362">      /* Parent process: we will reap the child later. */</a>
<a name="ln363">      zlog_err(&quot;Forked background command [pid %d]: %s&quot;,(int)child,shell_cmd);</a>
<a name="ln364">      return child;</a>
<a name="ln365">    }</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">static struct timeval *</a>
<a name="ln369">time_elapsed(struct timeval *result, const struct timeval *start_time)</a>
<a name="ln370">{</a>
<a name="ln371">  gettimeofday(result,NULL);</a>
<a name="ln372">  result-&gt;tv_sec -= start_time-&gt;tv_sec;</a>
<a name="ln373">  result-&gt;tv_usec -= start_time-&gt;tv_usec;</a>
<a name="ln374">  while (result-&gt;tv_usec &lt; 0)</a>
<a name="ln375">    {</a>
<a name="ln376">      result-&gt;tv_usec += 1000000L;</a>
<a name="ln377">      result-&gt;tv_sec--;</a>
<a name="ln378">    }</a>
<a name="ln379">  return result;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">static int</a>
<a name="ln383">restart_kill(struct thread *t_kill)</a>
<a name="ln384">{</a>
<a name="ln385">  struct restart_info *restart = THREAD_ARG(t_kill);</a>
<a name="ln386">  struct timeval delay;</a>
<a name="ln387"> </a>
<a name="ln388">  time_elapsed(&amp;delay,&amp;restart-&gt;time);</a>
<a name="ln389">  zlog_warn(&quot;Warning: %s %s child process %d still running after &quot;</a>
<a name="ln390">	    &quot;%ld seconds, sending signal %d&quot;,</a>
<a name="ln391">	    restart-&gt;what,restart-&gt;name,(int)restart-&gt;pid, (long)delay.tv_sec,</a>
<a name="ln392">	    (restart-&gt;kills ? SIGKILL : SIGTERM));</a>
<a name="ln393">  kill(-restart-&gt;pid,(restart-&gt;kills ? SIGKILL : SIGTERM));</a>
<a name="ln394">  restart-&gt;kills++;</a>
<a name="ln395">  restart-&gt;t_kill = thread_add_timer(master,restart_kill,restart,</a>
<a name="ln396">				     gs.restart_timeout);</a>
<a name="ln397">  return 0;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">static struct restart_info *</a>
<a name="ln401">find_child(pid_t child)</a>
<a name="ln402">{</a>
<a name="ln403">  if (gs.mode == MODE_GLOBAL_RESTART)</a>
<a name="ln404">    {</a>
<a name="ln405">      if (gs.restart.pid == child)</a>
<a name="ln406">        return &amp;gs.restart;</a>
<a name="ln407">    }</a>
<a name="ln408">  else</a>
<a name="ln409">    {</a>
<a name="ln410">      struct daemon *dmn;</a>
<a name="ln411">      for (dmn = gs.daemons; dmn; dmn = dmn-&gt;next)</a>
<a name="ln412">        {</a>
<a name="ln413">	  if (dmn-&gt;restart.pid == child)</a>
<a name="ln414">	    return &amp;dmn-&gt;restart;</a>
<a name="ln415">        }</a>
<a name="ln416">    }</a>
<a name="ln417">  return NULL;</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">static void</a>
<a name="ln421">sigchild(void)</a>
<a name="ln422">{</a>
<a name="ln423">  pid_t child;</a>
<a name="ln424">  int status;</a>
<a name="ln425">  const char *name;</a>
<a name="ln426">  const char *what;</a>
<a name="ln427">  struct restart_info *restart;</a>
<a name="ln428"> </a>
<a name="ln429">  switch (child = waitpid(-1,&amp;status,WNOHANG)) </a>
<a name="ln430">    {</a>
<a name="ln431">    case -1:</a>
<a name="ln432">      zlog_err(&quot;waitpid failed: %s&quot;,safe_strerror(errno));</a>
<a name="ln433">      return;</a>
<a name="ln434">    case 0:</a>
<a name="ln435">      zlog_warn(&quot;SIGCHLD received, but waitpid did not reap a child&quot;);</a>
<a name="ln436">      return;</a>
<a name="ln437">    }</a>
<a name="ln438"> </a>
<a name="ln439">  if ((restart = find_child(child)) != NULL)</a>
<a name="ln440">    {</a>
<a name="ln441">      name = restart-&gt;name;</a>
<a name="ln442">      what = restart-&gt;what;</a>
<a name="ln443">      restart-&gt;pid = 0;</a>
<a name="ln444">      gs.numpids--;</a>
<a name="ln445">      thread_cancel(restart-&gt;t_kill);</a>
<a name="ln446">      restart-&gt;t_kill = NULL;</a>
<a name="ln447">      /* Update restart time to reflect the time the command completed. */</a>
<a name="ln448">      gettimeofday(&amp;restart-&gt;time,NULL);</a>
<a name="ln449">    }</a>
<a name="ln450">  else</a>
<a name="ln451">    {</a>
<a name="ln452">      zlog_err(&quot;waitpid returned status for an unknown child process %d&quot;,</a>
<a name="ln453">	       (int)child);</a>
<a name="ln454">      name = &quot;(unknown)&quot;;</a>
<a name="ln455">      what = &quot;background&quot;;</a>
<a name="ln456">    }</a>
<a name="ln457">  if (WIFSTOPPED(status))</a>
<a name="ln458">      zlog_warn(&quot;warning: %s %s process %d is stopped&quot;,</a>
<a name="ln459">		what,name,(int)child);</a>
<a name="ln460">  else if (WIFSIGNALED(status))</a>
<a name="ln461">    zlog_warn(&quot;%s %s process %d terminated due to signal %d&quot;,</a>
<a name="ln462">	      what,name,(int)child,WTERMSIG(status));</a>
<a name="ln463">  else if (WIFEXITED(status))</a>
<a name="ln464">    {</a>
<a name="ln465">      if (WEXITSTATUS(status) != 0)</a>
<a name="ln466">	zlog_warn(&quot;%s %s process %d exited with non-zero status %d&quot;,</a>
<a name="ln467">		  what,name,(int)child,WEXITSTATUS(status));</a>
<a name="ln468">      else</a>
<a name="ln469">	zlog_debug(&quot;%s %s process %d exited normally&quot;,what,name,(int)child);</a>
<a name="ln470">    }</a>
<a name="ln471">  else</a>
<a name="ln472">    zlog_err(&quot;cannot interpret %s %s process %d wait status 0x%x&quot;,</a>
<a name="ln473">	     what,name,(int)child,status);</a>
<a name="ln474">  phase_check();</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">static int</a>
<a name="ln478">run_job(struct restart_info *restart, const char *cmdtype, const char *command,</a>
<a name="ln479">	int force, int update_interval)</a>
<a name="ln480">{</a>
<a name="ln481">  struct timeval delay;</a>
<a name="ln482"> </a>
<a name="ln483">  if (gs.loglevel &gt; LOG_DEBUG+1)</a>
<a name="ln484">    zlog_debug(&quot;attempting to %s %s&quot;,cmdtype,restart-&gt;name);</a>
<a name="ln485"> </a>
<a name="ln486">  if (restart-&gt;pid)</a>
<a name="ln487">    {</a>
<a name="ln488">      if (gs.loglevel &gt; LOG_DEBUG+1)</a>
<a name="ln489">        zlog_debug(&quot;cannot %s %s, previous pid %d still running&quot;,</a>
<a name="ln490">		   cmdtype,restart-&gt;name,(int)restart-&gt;pid);</a>
<a name="ln491">      return -1;</a>
<a name="ln492">    }</a>
<a name="ln493"> </a>
<a name="ln494">  /* Note: time_elapsed test must come before the force test, since we need</a>
<a name="ln495">     to make sure that delay is initialized for use below in updating the</a>
<a name="ln496">     restart interval. */</a>
<a name="ln497">  if ((time_elapsed(&amp;delay,&amp;restart-&gt;time)-&gt;tv_sec &lt; restart-&gt;interval) &amp;&amp;</a>
<a name="ln498">      !force)</a>
<a name="ln499">    {</a>
<a name="ln500">      if (gs.loglevel &gt; LOG_DEBUG+1)</a>
<a name="ln501">        zlog_debug(&quot;postponing %s %s: &quot;</a>
<a name="ln502">		   &quot;elapsed time %ld &lt; retry interval %ld&quot;,</a>
<a name="ln503">		   cmdtype,restart-&gt;name,(long)delay.tv_sec,restart-&gt;interval);</a>
<a name="ln504">      return -1;</a>
<a name="ln505">    }</a>
<a name="ln506"> </a>
<a name="ln507">  gettimeofday(&amp;restart-&gt;time,NULL);</a>
<a name="ln508">  restart-&gt;kills = 0;</a>
<a name="ln509">  {</a>
<a name="ln510">    char cmd[strlen(command)+strlen(restart-&gt;name)+1];</a>
<a name="ln511">    snprintf(cmd,sizeof(cmd),command,restart-&gt;name);</a>
<a name="ln512">    if ((restart-&gt;pid = run_background(cmd)) &gt; 0)</a>
<a name="ln513">      {</a>
<a name="ln514">	restart-&gt;t_kill = thread_add_timer(master,restart_kill,restart,</a>
<a name="ln515">					   gs.restart_timeout);</a>
<a name="ln516">	restart-&gt;what = cmdtype;</a>
<a name="ln517">	gs.numpids++;</a>
<a name="ln518">      }</a>
<a name="ln519">    else</a>
<a name="ln520">      restart-&gt;pid = 0;</a>
<a name="ln521">  }</a>
<a name="ln522"> </a>
<a name="ln523">  /* Calculate the new restart interval. */</a>
<a name="ln524">  if (update_interval)</a>
<a name="ln525">    {</a>
<a name="ln526">      if (delay.tv_sec &gt; 2*gs.max_restart_interval)</a>
<a name="ln527">	restart-&gt;interval = gs.min_restart_interval;</a>
<a name="ln528">      else if ((restart-&gt;interval *= 2) &gt; gs.max_restart_interval)</a>
<a name="ln529">	restart-&gt;interval = gs.max_restart_interval;</a>
<a name="ln530">      if (gs.loglevel &gt; LOG_DEBUG+1)</a>
<a name="ln531">	zlog_debug(&quot;restart %s interval is now %ld&quot;,</a>
<a name="ln532">		   restart-&gt;name,restart-&gt;interval);</a>
<a name="ln533">    }</a>
<a name="ln534">  return restart-&gt;pid;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">#define SET_READ_HANDLER(DMN) \</a>
<a name="ln538">  (DMN)-&gt;t_read = thread_add_read(master,handle_read,(DMN),(DMN)-&gt;fd)</a>
<a name="ln539"> </a>
<a name="ln540">#define SET_WAKEUP_DOWN(DMN)	\</a>
<a name="ln541">  (DMN)-&gt;t_wakeup = thread_add_timer_msec(master,wakeup_down,(DMN),	\</a>
<a name="ln542">    					  FUZZY(gs.period))</a>
<a name="ln543"> </a>
<a name="ln544">#define SET_WAKEUP_UNRESPONSIVE(DMN)	\</a>
<a name="ln545">  (DMN)-&gt;t_wakeup = thread_add_timer_msec(master,wakeup_unresponsive,(DMN), \</a>
<a name="ln546">    					  FUZZY(gs.period))</a>
<a name="ln547"> </a>
<a name="ln548">#define SET_WAKEUP_ECHO(DMN) \</a>
<a name="ln549">  (DMN)-&gt;t_wakeup = thread_add_timer_msec(master,wakeup_send_echo,(DMN), \</a>
<a name="ln550">					  FUZZY(gs.period))</a>
<a name="ln551"> </a>
<a name="ln552">static int</a>
<a name="ln553">wakeup_down(struct thread *t_wakeup)</a>
<a name="ln554">{</a>
<a name="ln555">  struct daemon *dmn = THREAD_ARG(t_wakeup);</a>
<a name="ln556"> </a>
<a name="ln557">  dmn-&gt;t_wakeup = NULL;</a>
<a name="ln558">  if (try_connect(dmn) &lt; 0)</a>
<a name="ln559">    SET_WAKEUP_DOWN(dmn);</a>
<a name="ln560">  if ((dmn-&gt;connect_tries &gt; 1) &amp;&amp; (dmn-&gt;state != DAEMON_UP))</a>
<a name="ln561">    try_restart(dmn);</a>
<a name="ln562">  return 0;</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">static int</a>
<a name="ln566">wakeup_init(struct thread *t_wakeup)</a>
<a name="ln567">{</a>
<a name="ln568">  struct daemon *dmn = THREAD_ARG(t_wakeup);</a>
<a name="ln569"> </a>
<a name="ln570">  dmn-&gt;t_wakeup = NULL;</a>
<a name="ln571">  if (try_connect(dmn) &lt; 0)</a>
<a name="ln572">    {</a>
<a name="ln573">      SET_WAKEUP_DOWN(dmn);</a>
<a name="ln574">      zlog_err(&quot;%s state -&gt; down : initial connection attempt failed&quot;,</a>
<a name="ln575">	       dmn-&gt;name);</a>
<a name="ln576">      dmn-&gt;state = DAEMON_DOWN;</a>
<a name="ln577">    }</a>
<a name="ln578">  return 0;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">static void</a>
<a name="ln582">daemon_down(struct daemon *dmn, const char *why)</a>
<a name="ln583">{</a>
<a name="ln584">  if (IS_UP(dmn) || (dmn-&gt;state == DAEMON_INIT))</a>
<a name="ln585">    zlog_err(&quot;%s state -&gt; down : %s&quot;,dmn-&gt;name,why);</a>
<a name="ln586">  else if (gs.loglevel &gt; LOG_DEBUG)</a>
<a name="ln587">    zlog_debug(&quot;%s still down : %s&quot;,dmn-&gt;name,why);</a>
<a name="ln588">  if (IS_UP(dmn))</a>
<a name="ln589">    gs.numdown++;</a>
<a name="ln590">  dmn-&gt;state = DAEMON_DOWN;</a>
<a name="ln591">  if (dmn-&gt;fd &gt;= 0)</a>
<a name="ln592">    {</a>
<a name="ln593">      close(dmn-&gt;fd);</a>
<a name="ln594">      dmn-&gt;fd = -1;</a>
<a name="ln595">    }</a>
<a name="ln596">  THREAD_OFF(dmn-&gt;t_read);</a>
<a name="ln597">  THREAD_OFF(dmn-&gt;t_write);</a>
<a name="ln598">  THREAD_OFF(dmn-&gt;t_wakeup);</a>
<a name="ln599">  if (try_connect(dmn) &lt; 0)</a>
<a name="ln600">    SET_WAKEUP_DOWN(dmn);</a>
<a name="ln601">  phase_check();</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">static int</a>
<a name="ln605">handle_read(struct thread *t_read)</a>
<a name="ln606">{</a>
<a name="ln607">  struct daemon *dmn = THREAD_ARG(t_read);</a>
<a name="ln608">  static const char resp[sizeof(PING_TOKEN)+4] = PING_TOKEN &quot;\n&quot;;</a>
<a name="ln609">  char buf[sizeof(resp)+100];</a>
<a name="ln610">  ssize_t rc;</a>
<a name="ln611">  struct timeval delay;</a>
<a name="ln612"> </a>
<a name="ln613">  dmn-&gt;t_read = NULL;</a>
<a name="ln614">  if ((rc = read(dmn-&gt;fd,buf,sizeof(buf))) &lt; 0)</a>
<a name="ln615">    {</a>
<a name="ln616">      char why[100];</a>
<a name="ln617"> </a>
<a name="ln618">      if (ERRNO_IO_RETRY(errno))</a>
<a name="ln619">	{</a>
<a name="ln620">	  /* Pretend it never happened. */</a>
<a name="ln621">	  SET_READ_HANDLER(dmn);</a>
<a name="ln622">	  return 0;</a>
<a name="ln623">	}</a>
<a name="ln624">      snprintf(why,sizeof(why),&quot;unexpected read error: %s&quot;,</a>
<a name="ln625">	       safe_strerror(errno));</a>
<a name="ln626">      daemon_down(dmn,why);</a>
<a name="ln627">      return 0;</a>
<a name="ln628">    }</a>
<a name="ln629">  if (rc == 0)</a>
<a name="ln630">    {</a>
<a name="ln631">      daemon_down(dmn,&quot;read returned EOF&quot;);</a>
<a name="ln632">      return 0;</a>
<a name="ln633">    }</a>
<a name="ln634">  if (!dmn-&gt;echo_sent.tv_sec)</a>
<a name="ln635">    {</a>
<a name="ln636">      char why[sizeof(buf)+100];</a>
<a name="ln637">      snprintf(why,sizeof(why),&quot;unexpected read returns %d bytes: %.*s&quot;,</a>
<a name="ln638">	       (int)rc,(int)rc,buf);</a>
<a name="ln639">      daemon_down(dmn,why);</a>
<a name="ln640">      return 0;</a>
<a name="ln641">    }</a>
<a name="ln642"> </a>
<a name="ln643">  /* We are expecting an echo response: is there any chance that the</a>
<a name="ln644">     response would not be returned entirely in the first read?  That</a>
<a name="ln645">     seems inconceivable... */</a>
<a name="ln646">  if ((rc != sizeof(resp)) || memcmp(buf,resp,sizeof(resp)))</a>
<a name="ln647">    {</a>
<a name="ln648">      char why[100+sizeof(buf)];</a>
<a name="ln649">      snprintf(why,sizeof(why),&quot;read returned bad echo response of %d bytes &quot;</a>
<a name="ln650">			       &quot;(expecting %u): %.*s&quot;,</a>
<a name="ln651">	       (int)rc,(u_int)sizeof(resp),(int)rc,buf);</a>
<a name="ln652">      daemon_down(dmn,why);</a>
<a name="ln653">      return 0;</a>
<a name="ln654">    }</a>
<a name="ln655"> </a>
<a name="ln656">  time_elapsed(&amp;delay,&amp;dmn-&gt;echo_sent);</a>
<a name="ln657">  dmn-&gt;echo_sent.tv_sec = 0;</a>
<a name="ln658">  if (dmn-&gt;state == DAEMON_UNRESPONSIVE)</a>
<a name="ln659">    {</a>
<a name="ln660">      if (delay.tv_sec &lt; gs.timeout)</a>
<a name="ln661">	{</a>
<a name="ln662">	  dmn-&gt;state = DAEMON_UP;</a>
<a name="ln663">	  zlog_warn(&quot;%s state -&gt; up : echo response received after %ld.%06ld &quot;</a>
<a name="ln664">		    &quot;seconds&quot;, dmn-&gt;name,</a>
<a name="ln665">		    (long)delay.tv_sec, (long)delay.tv_usec);</a>
<a name="ln666">	}</a>
<a name="ln667">      else</a>
<a name="ln668">	zlog_warn(&quot;%s: slow echo response finally received after %ld.%06ld &quot;</a>
<a name="ln669">		  &quot;seconds&quot;, dmn-&gt;name,</a>
<a name="ln670">		  (long)delay.tv_sec, (long)delay.tv_usec);</a>
<a name="ln671">    }</a>
<a name="ln672">  else if (gs.loglevel &gt; LOG_DEBUG+1)</a>
<a name="ln673">    zlog_debug(&quot;%s: echo response received after %ld.%06ld seconds&quot;,</a>
<a name="ln674">	       dmn-&gt;name, (long)delay.tv_sec, (long)delay.tv_usec);</a>
<a name="ln675"> </a>
<a name="ln676">  SET_READ_HANDLER(dmn);</a>
<a name="ln677">  if (dmn-&gt;t_wakeup)</a>
<a name="ln678">    thread_cancel(dmn-&gt;t_wakeup);</a>
<a name="ln679">  SET_WAKEUP_ECHO(dmn);</a>
<a name="ln680"> </a>
<a name="ln681">  return 0;</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">static void</a>
<a name="ln685">daemon_up(struct daemon *dmn, const char *why)</a>
<a name="ln686">{</a>
<a name="ln687">  dmn-&gt;state = DAEMON_UP;</a>
<a name="ln688">  gs.numdown--;</a>
<a name="ln689">  dmn-&gt;connect_tries = 0;</a>
<a name="ln690">  zlog_notice(&quot;%s state -&gt; up : %s&quot;,dmn-&gt;name,why);</a>
<a name="ln691">  if (gs.do_ping)</a>
<a name="ln692">    SET_WAKEUP_ECHO(dmn);</a>
<a name="ln693">  phase_check();</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">static int</a>
<a name="ln697">check_connect(struct thread *t_write)</a>
<a name="ln698">{</a>
<a name="ln699">  struct daemon *dmn = THREAD_ARG(t_write);</a>
<a name="ln700">  int sockerr;</a>
<a name="ln701">  socklen_t reslen = sizeof(sockerr);</a>
<a name="ln702"> </a>
<a name="ln703">  dmn-&gt;t_write = NULL;</a>
<a name="ln704">  if (getsockopt(dmn-&gt;fd,SOL_SOCKET,SO_ERROR,(char *)&amp;sockerr,&amp;reslen) &lt; 0)</a>
<a name="ln705">    {</a>
<a name="ln706">      zlog_warn(&quot;%s: check_connect: getsockopt failed: %s&quot;,</a>
<a name="ln707">	        dmn-&gt;name,safe_strerror(errno));</a>
<a name="ln708">      daemon_down(dmn,&quot;getsockopt failed checking connection success&quot;);</a>
<a name="ln709">      return 0;</a>
<a name="ln710">    }</a>
<a name="ln711">  if ((reslen == sizeof(sockerr)) &amp;&amp; sockerr)</a>
<a name="ln712">    {</a>
<a name="ln713">      char why[100];</a>
<a name="ln714">      snprintf(why,sizeof(why),</a>
<a name="ln715">	       &quot;getsockopt reports that connection attempt failed: %s&quot;,</a>
<a name="ln716">	       safe_strerror(sockerr));</a>
<a name="ln717">      daemon_down(dmn,why);</a>
<a name="ln718">      return 0;</a>
<a name="ln719">    }</a>
<a name="ln720"> </a>
<a name="ln721">  daemon_up(dmn,&quot;delayed connect succeeded&quot;);</a>
<a name="ln722">  return 0;</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">static int</a>
<a name="ln726">wakeup_connect_hanging(struct thread *t_wakeup)</a>
<a name="ln727">{</a>
<a name="ln728">  struct daemon *dmn = THREAD_ARG(t_wakeup);</a>
<a name="ln729">  char why[100];</a>
<a name="ln730"> </a>
<a name="ln731">  dmn-&gt;t_wakeup = NULL;</a>
<a name="ln732">  snprintf(why,sizeof(why),&quot;connection attempt timed out after %ld seconds&quot;,</a>
<a name="ln733">	   gs.timeout);</a>
<a name="ln734">  daemon_down(dmn,why);</a>
<a name="ln735">  return 0;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">/* Making connection to protocol daemon. */</a>
<a name="ln739">static int</a>
<a name="ln740">try_connect(struct daemon *dmn)</a>
<a name="ln741">{</a>
<a name="ln742">  int sock;</a>
<a name="ln743">  struct sockaddr_un addr;</a>
<a name="ln744">  socklen_t len;</a>
<a name="ln745"> </a>
<a name="ln746">  if (gs.loglevel &gt; LOG_DEBUG+1)</a>
<a name="ln747">    zlog_debug(&quot;%s: attempting to connect&quot;,dmn-&gt;name);</a>
<a name="ln748">  dmn-&gt;connect_tries++;</a>
<a name="ln749"> </a>
<a name="ln750">  memset (&amp;addr, 0, sizeof (struct sockaddr_un));</a>
<a name="ln751">  addr.sun_family = AF_UNIX;</a>
<a name="ln752">  snprintf(addr.sun_path, sizeof(addr.sun_path), &quot;%s/%s.vty&quot;,</a>
<a name="ln753">	   gs.vtydir,dmn-&gt;name);</a>
<a name="ln754">#ifdef HAVE_STRUCT_SOCKADDR_UN_SUN_LEN</a>
<a name="ln755">  len = addr.sun_len = SUN_LEN(&amp;addr);</a>
<a name="ln756">#else</a>
<a name="ln757">  len = sizeof (addr.sun_family) + strlen (addr.sun_path);</a>
<a name="ln758">#endif /* HAVE_STRUCT_SOCKADDR_UN_SUN_LEN */</a>
<a name="ln759"> </a>
<a name="ln760">  /* Quick check to see if we might succeed before we go to the trouble</a>
<a name="ln761">     of creating a socket. */</a>
<a name="ln762">  if (access(addr.sun_path, W_OK) &lt; 0)</a>
<a name="ln763">    {</a>
<a name="ln764">      if (errno != ENOENT)</a>
<a name="ln765">        zlog_err(&quot;%s: access to socket %s denied: %s&quot;,</a>
<a name="ln766">		dmn-&gt;name,addr.sun_path,safe_strerror(errno));</a>
<a name="ln767">      return -1;</a>
<a name="ln768">    }</a>
<a name="ln769"> </a>
<a name="ln770">  if ((sock = socket (AF_UNIX, SOCK_STREAM, 0)) &lt; 0)</a>
<a name="ln771">    {</a>
<a name="ln772">      zlog_err(&quot;%s(%s): cannot make socket: %s&quot;,</a>
<a name="ln773">	       __func__,addr.sun_path, safe_strerror(errno));</a>
<a name="ln774">      return -1;</a>
<a name="ln775">    }</a>
<a name="ln776"> </a>
<a name="ln777">  if (set_nonblocking(sock) &lt; 0)</a>
<a name="ln778">    {</a>
<a name="ln779">      zlog_err(&quot;%s(%s): set_nonblocking(%d) failed&quot;,</a>
<a name="ln780">	       __func__, addr.sun_path, sock);</a>
<a name="ln781">      close(sock);</a>
<a name="ln782">      return -1;</a>
<a name="ln783">    }</a>
<a name="ln784"> </a>
<a name="ln785">  if (connect (sock, (struct sockaddr *) &amp;addr, len) &lt; 0)</a>
<a name="ln786">    {</a>
<a name="ln787">      if ((errno != EINPROGRESS) &amp;&amp; (errno != EWOULDBLOCK))</a>
<a name="ln788">	{</a>
<a name="ln789">	  if (gs.loglevel &gt; LOG_DEBUG)</a>
<a name="ln790">	    zlog_debug(&quot;%s(%s): connect failed: %s&quot;,</a>
<a name="ln791">		       __func__,addr.sun_path, safe_strerror(errno));</a>
<a name="ln792">	  close (sock);</a>
<a name="ln793">	  return -1;</a>
<a name="ln794">	}</a>
<a name="ln795">      if (gs.loglevel &gt; LOG_DEBUG)</a>
<a name="ln796">	zlog_debug(&quot;%s: connection in progress&quot;,dmn-&gt;name);</a>
<a name="ln797">      dmn-&gt;state = DAEMON_CONNECTING;</a>
<a name="ln798">      dmn-&gt;fd = sock;</a>
<a name="ln799">      dmn-&gt;t_write = thread_add_write(master,check_connect,dmn,dmn-&gt;fd);</a>
<a name="ln800">      dmn-&gt;t_wakeup = thread_add_timer(master,wakeup_connect_hanging,dmn,</a>
<a name="ln801">				       gs.timeout);</a>
<a name="ln802">      SET_READ_HANDLER(dmn);</a>
<a name="ln803">      return 0;</a>
<a name="ln804">    }</a>
<a name="ln805"> </a>
<a name="ln806">  dmn-&gt;fd = sock;</a>
<a name="ln807">  SET_READ_HANDLER(dmn);</a>
<a name="ln808">  daemon_up(dmn,&quot;connect succeeded&quot;);</a>
<a name="ln809">  return 1;</a>
<a name="ln810">}</a>
<a name="ln811"> </a>
<a name="ln812">static int</a>
<a name="ln813">phase_hanging(struct thread *t_hanging)</a>
<a name="ln814">{</a>
<a name="ln815">  gs.t_phase_hanging = NULL;</a>
<a name="ln816">  zlog_err(&quot;Phase [%s] hanging for %ld seconds, aborting phased restart&quot;,</a>
<a name="ln817">           phase_str[gs.phase],PHASE_TIMEOUT);</a>
<a name="ln818">  gs.phase = PHASE_NONE;</a>
<a name="ln819">  return 0;</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">static void</a>
<a name="ln823">set_phase(restart_phase_t new_phase)</a>
<a name="ln824">{</a>
<a name="ln825">  gs.phase = new_phase;</a>
<a name="ln826">  if (gs.t_phase_hanging)</a>
<a name="ln827">    thread_cancel(gs.t_phase_hanging);</a>
<a name="ln828">  gs.t_phase_hanging = thread_add_timer(master,phase_hanging,NULL,</a>
<a name="ln829">  					PHASE_TIMEOUT);</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">static void</a>
<a name="ln833">phase_check(void)</a>
<a name="ln834">{</a>
<a name="ln835">  switch (gs.phase)</a>
<a name="ln836">    {</a>
<a name="ln837">    case PHASE_NONE:</a>
<a name="ln838">      break;</a>
<a name="ln839">    case PHASE_STOPS_PENDING:</a>
<a name="ln840">      if (gs.numpids)</a>
<a name="ln841">	break;</a>
<a name="ln842">      zlog_info(&quot;Phased restart: all routing daemon stop jobs have completed.&quot;);</a>
<a name="ln843">      set_phase(PHASE_WAITING_DOWN);</a>
<a name="ln844">      /*FALLTHRU*/</a>
<a name="ln845">    case PHASE_WAITING_DOWN:</a>
<a name="ln846">      if (gs.numdown+IS_UP(gs.special) &lt; gs.numdaemons)</a>
<a name="ln847">        break;</a>
<a name="ln848">      zlog_info(&quot;Phased restart: all routing daemons now down.&quot;);</a>
<a name="ln849">      run_job(&amp;gs.special-&gt;restart,&quot;restart&quot;,gs.restart_command,1,1);</a>
<a name="ln850">      set_phase(PHASE_ZEBRA_RESTART_PENDING);</a>
<a name="ln851">      /*FALLTHRU*/</a>
<a name="ln852">    case PHASE_ZEBRA_RESTART_PENDING:</a>
<a name="ln853">      if (gs.special-&gt;restart.pid)</a>
<a name="ln854">	break;</a>
<a name="ln855">      zlog_info(&quot;Phased restart: %s restart job completed.&quot;,gs.special-&gt;name);</a>
<a name="ln856">      set_phase(PHASE_WAITING_ZEBRA_UP);</a>
<a name="ln857">      /*FALLTHRU*/</a>
<a name="ln858">    case PHASE_WAITING_ZEBRA_UP:</a>
<a name="ln859">      if (!IS_UP(gs.special))</a>
<a name="ln860">        break;</a>
<a name="ln861">      zlog_info(&quot;Phased restart: %s is now up.&quot;,gs.special-&gt;name);</a>
<a name="ln862">      {</a>
<a name="ln863">        struct daemon *dmn;</a>
<a name="ln864">	for (dmn = gs.daemons; dmn; dmn = dmn-&gt;next)</a>
<a name="ln865">	  {</a>
<a name="ln866">	    if (dmn != gs.special)</a>
<a name="ln867">	      run_job(&amp;dmn-&gt;restart,&quot;start&quot;,gs.start_command,1,0);</a>
<a name="ln868">	  }</a>
<a name="ln869">      }</a>
<a name="ln870">      gs.phase = PHASE_NONE;</a>
<a name="ln871">      THREAD_OFF(gs.t_phase_hanging);</a>
<a name="ln872">      zlog_notice(&quot;Phased global restart has completed.&quot;);</a>
<a name="ln873">      break;</a>
<a name="ln874">    }</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">static void</a>
<a name="ln878">try_restart(struct daemon *dmn)</a>
<a name="ln879">{</a>
<a name="ln880">  switch (gs.mode)</a>
<a name="ln881">  {</a>
<a name="ln882">  case MODE_MONITOR:</a>
<a name="ln883">    return;</a>
<a name="ln884">  case MODE_GLOBAL_RESTART:</a>
<a name="ln885">    run_job(&amp;gs.restart,&quot;restart&quot;,gs.restart_command,0,1);</a>
<a name="ln886">    break;</a>
<a name="ln887">  case MODE_SEPARATE_RESTART:</a>
<a name="ln888">    run_job(&amp;dmn-&gt;restart,&quot;restart&quot;,gs.restart_command,0,1);</a>
<a name="ln889">    break;</a>
<a name="ln890">  case MODE_PHASED_ZEBRA_RESTART:</a>
<a name="ln891">    if (dmn != gs.special)</a>
<a name="ln892">      {</a>
<a name="ln893">        if ((gs.special-&gt;state == DAEMON_UP) &amp;&amp; (gs.phase == PHASE_NONE))</a>
<a name="ln894">	  run_job(&amp;dmn-&gt;restart,&quot;restart&quot;,gs.restart_command,0,1);</a>
<a name="ln895">	else</a>
<a name="ln896">	  zlog_debug(&quot;%s: postponing restart attempt because master %s daemon &quot;</a>
<a name="ln897">		     &quot;not up [%s], or phased restart in progress&quot;,</a>
<a name="ln898">		     dmn-&gt;name,gs.special-&gt;name,state_str[gs.special-&gt;state]);</a>
<a name="ln899">	break;</a>
<a name="ln900">      }</a>
<a name="ln901">    /*FALLTHRU*/</a>
<a name="ln902">  case MODE_PHASED_ALL_RESTART:</a>
<a name="ln903">    if ((gs.phase != PHASE_NONE) || gs.numpids)</a>
<a name="ln904">      {</a>
<a name="ln905">	if (gs.loglevel &gt; LOG_DEBUG+1)</a>
<a name="ln906">	  zlog_debug(&quot;postponing phased global restart: restart already in &quot;</a>
<a name="ln907">		     &quot;progress [%s], or outstanding child processes [%d]&quot;,</a>
<a name="ln908">		     phase_str[gs.phase],gs.numpids);</a>
<a name="ln909">        break;</a>
<a name="ln910">      }</a>
<a name="ln911">    /* Is it too soon for a restart? */</a>
<a name="ln912">    {</a>
<a name="ln913">      struct timeval delay;</a>
<a name="ln914">      if (time_elapsed(&amp;delay,&amp;gs.special-&gt;restart.time)-&gt;tv_sec &lt;</a>
<a name="ln915">      	  gs.special-&gt;restart.interval)</a>
<a name="ln916">	{</a>
<a name="ln917">	  if (gs.loglevel &gt; LOG_DEBUG+1)</a>
<a name="ln918">	    zlog_debug(&quot;postponing phased global restart: &quot;</a>
<a name="ln919">		       &quot;elapsed time %ld &lt; retry interval %ld&quot;,</a>
<a name="ln920">		       (long)delay.tv_sec,gs.special-&gt;restart.interval);</a>
<a name="ln921">	  break;</a>
<a name="ln922">	}</a>
<a name="ln923">    }</a>
<a name="ln924">    zlog_info(&quot;Phased restart: stopping all routing daemons.&quot;);</a>
<a name="ln925">    /* First step: stop all other daemons. */</a>
<a name="ln926">    for (dmn = gs.daemons; dmn; dmn = dmn-&gt;next)</a>
<a name="ln927">      {</a>
<a name="ln928">        if (dmn != gs.special)</a>
<a name="ln929">	  run_job(&amp;dmn-&gt;restart,&quot;stop&quot;,gs.stop_command,1,1);</a>
<a name="ln930">      }</a>
<a name="ln931">    set_phase(PHASE_STOPS_PENDING);</a>
<a name="ln932">    break;</a>
<a name="ln933">  default:</a>
<a name="ln934">    zlog_err(&quot;error: unknown restart mode %d&quot;,gs.mode);</a>
<a name="ln935">    break;</a>
<a name="ln936">  }</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939">static int</a>
<a name="ln940">wakeup_unresponsive(struct thread *t_wakeup)</a>
<a name="ln941">{</a>
<a name="ln942">  struct daemon *dmn = THREAD_ARG(t_wakeup);</a>
<a name="ln943"> </a>
<a name="ln944">  dmn-&gt;t_wakeup = NULL;</a>
<a name="ln945">  if (dmn-&gt;state != DAEMON_UNRESPONSIVE)</a>
<a name="ln946">    zlog_err(&quot;%s: no longer unresponsive (now %s), &quot;</a>
<a name="ln947">	     &quot;wakeup should have been cancelled!&quot;,</a>
<a name="ln948">	     dmn-&gt;name,state_str[dmn-&gt;state]);</a>
<a name="ln949">  else</a>
<a name="ln950">    {</a>
<a name="ln951">      SET_WAKEUP_UNRESPONSIVE(dmn);</a>
<a name="ln952">      try_restart(dmn);</a>
<a name="ln953">    }</a>
<a name="ln954">  return 0;</a>
<a name="ln955">}</a>
<a name="ln956"> </a>
<a name="ln957">static int</a>
<a name="ln958">wakeup_no_answer(struct thread *t_wakeup)</a>
<a name="ln959">{</a>
<a name="ln960">  struct daemon *dmn = THREAD_ARG(t_wakeup);</a>
<a name="ln961"> </a>
<a name="ln962">  dmn-&gt;t_wakeup = NULL;</a>
<a name="ln963">  dmn-&gt;state = DAEMON_UNRESPONSIVE;</a>
<a name="ln964">  zlog_err(&quot;%s state -&gt; unresponsive : no response yet to ping &quot;</a>
<a name="ln965">	   &quot;sent %ld seconds ago&quot;,dmn-&gt;name,gs.timeout);</a>
<a name="ln966">  if (gs.unresponsive_restart)</a>
<a name="ln967">    {</a>
<a name="ln968">      SET_WAKEUP_UNRESPONSIVE(dmn);</a>
<a name="ln969">      try_restart(dmn);</a>
<a name="ln970">    }</a>
<a name="ln971">  return 0;</a>
<a name="ln972">}</a>
<a name="ln973"> </a>
<a name="ln974">static int</a>
<a name="ln975">wakeup_send_echo(struct thread *t_wakeup)</a>
<a name="ln976">{</a>
<a name="ln977">  static const char echocmd[] = &quot;echo &quot; PING_TOKEN;</a>
<a name="ln978">  ssize_t rc;</a>
<a name="ln979">  struct daemon *dmn = THREAD_ARG(t_wakeup);</a>
<a name="ln980"> </a>
<a name="ln981">  dmn-&gt;t_wakeup = NULL;</a>
<a name="ln982">  if (((rc = write(dmn-&gt;fd,echocmd,sizeof(echocmd))) &lt; 0) ||</a>
<a name="ln983">      ((size_t)rc != sizeof(echocmd)))</a>
<a name="ln984">    {</a>
<a name="ln985">      char why[100+sizeof(echocmd)];</a>
<a name="ln986">      snprintf(why,sizeof(why),&quot;write '%s' returned %d instead of %u&quot;,</a>
<a name="ln987">               echocmd,(int)rc,(u_int)sizeof(echocmd));</a>
<a name="ln988">      daemon_down(dmn,why);</a>
<a name="ln989">    }</a>
<a name="ln990">  else</a>
<a name="ln991">    {</a>
<a name="ln992">      gettimeofday(&amp;dmn-&gt;echo_sent,NULL);</a>
<a name="ln993">      dmn-&gt;t_wakeup = thread_add_timer(master,wakeup_no_answer,dmn,gs.timeout);</a>
<a name="ln994">    }</a>
<a name="ln995">  return 0;</a>
<a name="ln996">}</a>
<a name="ln997"> </a>
<a name="ln998">static void</a>
<a name="ln999">sigint(void)</a>
<a name="ln1000">{</a>
<a name="ln1001">  zlog_notice(&quot;Terminating on signal&quot;);</a>
<a name="ln1002">  exit(0);</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005">static int</a>
<a name="ln1006">valid_command(const char *cmd)</a>
<a name="ln1007">{</a>
<a name="ln1008">  char *p;</a>
<a name="ln1009"> </a>
<a name="ln1010">  return ((p = strchr(cmd,'%')) != NULL) &amp;&amp; (*(p+1) == 's') &amp;&amp; !strchr(p+1,'%');</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">/* This is an ugly hack to circumvent problems with passing command-line</a>
<a name="ln1014">   arguments that contain spaces.  The fix is to use a configuration file. */</a>
<a name="ln1015">static char *</a>
<a name="ln1016">translate_blanks(const char *cmd, const char *blankstr)</a>
<a name="ln1017">{</a>
<a name="ln1018">  char *res;</a>
<a name="ln1019">  char *p;</a>
<a name="ln1020">  size_t bslen = strlen(blankstr);</a>
<a name="ln1021"> </a>
<a name="ln1022">  if (!(res = strdup(cmd)))</a>
<a name="ln1023">    {</a>
<a name="ln1024">      perror(&quot;strdup&quot;);</a>
<a name="ln1025">      exit(1);</a>
<a name="ln1026">    }</a>
<a name="ln1027">  while ((p = strstr(res,blankstr)) != NULL)</a>
<a name="ln1028">    {</a>
<a name="ln1029">      *p = ' ';</a>
<a name="ln1030">      if (bslen != 1)</a>
<a name="ln1031">	 memmove(p+1,p+bslen,strlen(p+bslen)+1);</a>
<a name="ln1032">    }</a>
<a name="ln1033">  return res;</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036">int</a>
<a name="ln1037">main(int argc, char **argv)</a>
<a name="ln1038">{</a>
<a name="ln1039">  const char *progname;</a>
<a name="ln1040">  int opt;</a>
<a name="ln1041">  int daemon_mode = 0;</a>
<a name="ln1042">  const char *pidfile = DEFAULT_PIDFILE;</a>
<a name="ln1043">  const char *special = &quot;zebra&quot;;</a>
<a name="ln1044">  const char *blankstr = NULL;</a>
<a name="ln1045">  static struct quagga_signal_t my_signals[] =</a>
<a name="ln1046">  {</a>
<a name="ln1047">    {</a>
<a name="ln1048">      .signal = SIGINT,</a>
<a name="ln1049">      .handler = sigint,</a>
<a name="ln1050">    },</a>
<a name="ln1051">    {</a>
<a name="ln1052">      .signal = SIGTERM,</a>
<a name="ln1053">      .handler = sigint,</a>
<a name="ln1054">    },</a>
<a name="ln1055">    {</a>
<a name="ln1056">      .signal = SIGCHLD,</a>
<a name="ln1057">      .handler = sigchild,</a>
<a name="ln1058">    },</a>
<a name="ln1059">  };</a>
<a name="ln1060"> </a>
<a name="ln1061">  if ((progname = strrchr (argv[0], '/')) != NULL)</a>
<a name="ln1062">    progname++;</a>
<a name="ln1063">  else</a>
<a name="ln1064">    progname = argv[0];</a>
<a name="ln1065"> </a>
<a name="ln1066">  gs.restart.name = &quot;all&quot;;</a>
<a name="ln1067">  while ((opt = getopt_long(argc, argv, &quot;aAb:dek:l:m:M:i:p:r:R:S:s:t:T:zvh&quot;,</a>
<a name="ln1068">			    longopts, 0)) != EOF)</a>
<a name="ln1069">    {</a>
<a name="ln1070">      switch (opt)</a>
<a name="ln1071">        {</a>
<a name="ln1072">	case 0:</a>
<a name="ln1073">	  break;</a>
<a name="ln1074">        case 'a':</a>
<a name="ln1075">	  if ((gs.mode != MODE_MONITOR) &amp;&amp; (gs.mode != MODE_SEPARATE_RESTART))</a>
<a name="ln1076">	    {</a>
<a name="ln1077">	      fputs(&quot;Ambiguous operating mode selected.\n&quot;,stderr);</a>
<a name="ln1078">	      return usage(progname,1);</a>
<a name="ln1079">	    }</a>
<a name="ln1080">	  gs.mode = MODE_PHASED_ZEBRA_RESTART;</a>
<a name="ln1081">	  break;</a>
<a name="ln1082">        case 'A':</a>
<a name="ln1083">	  if ((gs.mode != MODE_MONITOR) &amp;&amp; (gs.mode != MODE_SEPARATE_RESTART))</a>
<a name="ln1084">	    {</a>
<a name="ln1085">	      fputs(&quot;Ambiguous operating mode selected.\n&quot;,stderr);</a>
<a name="ln1086">	      return usage(progname,1);</a>
<a name="ln1087">	    }</a>
<a name="ln1088">	  gs.mode = MODE_PHASED_ALL_RESTART;</a>
<a name="ln1089">	  break;</a>
<a name="ln1090">	case 'b':</a>
<a name="ln1091">	  blankstr = optarg;</a>
<a name="ln1092">	  break;</a>
<a name="ln1093">        case 'd':</a>
<a name="ln1094">	  daemon_mode = 1;</a>
<a name="ln1095">	  break;</a>
<a name="ln1096">        case 'e':</a>
<a name="ln1097">	  gs.do_ping = 0;</a>
<a name="ln1098">	  break;</a>
<a name="ln1099">        case 'k':</a>
<a name="ln1100">	  if (!valid_command(optarg))</a>
<a name="ln1101">	  {</a>
<a name="ln1102">	    fprintf(stderr,&quot;Invalid kill command, must contain '%%s': %s\n&quot;,</a>
<a name="ln1103">		    optarg);</a>
<a name="ln1104">	    return usage(progname,1);</a>
<a name="ln1105">	  }</a>
<a name="ln1106">	  gs.stop_command = optarg;</a>
<a name="ln1107">	  break;</a>
<a name="ln1108">	case 'l':</a>
<a name="ln1109">	  {</a>
<a name="ln1110">	    char garbage[3];</a>
<a name="ln1111">	    if ((sscanf(optarg,&quot;%d%1s&quot;,&amp;gs.loglevel,garbage) != 1) ||</a>
<a name="ln1112">	        (gs.loglevel &lt; LOG_EMERG))</a>
<a name="ln1113">	      {</a>
<a name="ln1114">	        fprintf(stderr,&quot;Invalid loglevel argument: %s\n&quot;,optarg);</a>
<a name="ln1115">		return usage(progname,1);</a>
<a name="ln1116">	      }</a>
<a name="ln1117">	  }</a>
<a name="ln1118">	  break;</a>
<a name="ln1119">	case 'm':</a>
<a name="ln1120">	  {</a>
<a name="ln1121">	    char garbage[3];</a>
<a name="ln1122">	    if ((sscanf(optarg,&quot;%ld%1s&quot;,</a>
<a name="ln1123">	    		&amp;gs.min_restart_interval,garbage) != 1) ||</a>
<a name="ln1124">	        (gs.min_restart_interval &lt; 0))</a>
<a name="ln1125">	      {</a>
<a name="ln1126">	        fprintf(stderr,&quot;Invalid min_restart_interval argument: %s\n&quot;,</a>
<a name="ln1127">		        optarg);</a>
<a name="ln1128">		return usage(progname,1);</a>
<a name="ln1129">	      }</a>
<a name="ln1130">	  }</a>
<a name="ln1131">	  break;</a>
<a name="ln1132">	case 'M':</a>
<a name="ln1133">	  {</a>
<a name="ln1134">	    char garbage[3];</a>
<a name="ln1135">	    if ((sscanf(optarg,&quot;%ld%1s&quot;,</a>
<a name="ln1136">	    		&amp;gs.max_restart_interval,garbage) != 1) ||</a>
<a name="ln1137">	        (gs.max_restart_interval &lt; 0))</a>
<a name="ln1138">	      {</a>
<a name="ln1139">	        fprintf(stderr,&quot;Invalid max_restart_interval argument: %s\n&quot;,</a>
<a name="ln1140">		        optarg);</a>
<a name="ln1141">		return usage(progname,1);</a>
<a name="ln1142">	      }</a>
<a name="ln1143">	  }</a>
<a name="ln1144">	  break;</a>
<a name="ln1145">	case 'i':</a>
<a name="ln1146">	  {</a>
<a name="ln1147">	    char garbage[3];</a>
<a name="ln1148">	    int period;</a>
<a name="ln1149">	    if ((sscanf(optarg,&quot;%d%1s&quot;,&amp;period,garbage) != 1) ||</a>
<a name="ln1150">	        (gs.period &lt; 1))</a>
<a name="ln1151">	      {</a>
<a name="ln1152">	        fprintf(stderr,&quot;Invalid interval argument: %s\n&quot;,optarg);</a>
<a name="ln1153">		return usage(progname,1);</a>
<a name="ln1154">	      }</a>
<a name="ln1155">	    gs.period = 1000*period;</a>
<a name="ln1156">	  }</a>
<a name="ln1157">	  break;</a>
<a name="ln1158">        case 'p':</a>
<a name="ln1159">	  pidfile = optarg;</a>
<a name="ln1160">	  break;</a>
<a name="ln1161">        case 'r':</a>
<a name="ln1162">	  if ((gs.mode == MODE_GLOBAL_RESTART) ||</a>
<a name="ln1163">	      (gs.mode == MODE_SEPARATE_RESTART))</a>
<a name="ln1164">	    {</a>
<a name="ln1165">	      fputs(&quot;Ambiguous operating mode selected.\n&quot;,stderr);</a>
<a name="ln1166">	      return usage(progname,1);</a>
<a name="ln1167">	    }</a>
<a name="ln1168">	  if (!valid_command(optarg))</a>
<a name="ln1169">	  {</a>
<a name="ln1170">	    fprintf(stderr,</a>
<a name="ln1171">		    &quot;Invalid restart command, must contain '%%s': %s\n&quot;,</a>
<a name="ln1172">		    optarg);</a>
<a name="ln1173">	    return usage(progname,1);</a>
<a name="ln1174">	  }</a>
<a name="ln1175">	  gs.restart_command = optarg;</a>
<a name="ln1176">	  if (gs.mode == MODE_MONITOR)</a>
<a name="ln1177">	    gs.mode = MODE_SEPARATE_RESTART;</a>
<a name="ln1178">	  break;</a>
<a name="ln1179">        case 'R':</a>
<a name="ln1180">	  if (gs.mode != MODE_MONITOR)</a>
<a name="ln1181">	    {</a>
<a name="ln1182">	      fputs(&quot;Ambiguous operating mode selected.\n&quot;,stderr);</a>
<a name="ln1183">	      return usage(progname,1);</a>
<a name="ln1184">	    }</a>
<a name="ln1185">	  if (strchr(optarg,'%'))</a>
<a name="ln1186">	    {</a>
<a name="ln1187">	      fprintf(stderr,</a>
<a name="ln1188">		      &quot;Invalid restart-all arg, must not contain '%%s': %s\n&quot;,</a>
<a name="ln1189">		      optarg);</a>
<a name="ln1190">	      return usage(progname,1);</a>
<a name="ln1191">	    }</a>
<a name="ln1192">	  gs.restart_command = optarg;</a>
<a name="ln1193">	  gs.mode = MODE_GLOBAL_RESTART;</a>
<a name="ln1194">	  break;</a>
<a name="ln1195">        case 's':</a>
<a name="ln1196">	  if (!valid_command(optarg))</a>
<a name="ln1197">	  {</a>
<a name="ln1198">	    fprintf(stderr,&quot;Invalid start command, must contain '%%s': %s\n&quot;,</a>
<a name="ln1199">		    optarg);</a>
<a name="ln1200">	    return usage(progname,1);</a>
<a name="ln1201">	  }</a>
<a name="ln1202">	  gs.start_command = optarg;</a>
<a name="ln1203">	  break;</a>
<a name="ln1204">	case 'S':</a>
<a name="ln1205">	  gs.vtydir = optarg;</a>
<a name="ln1206">	  break;</a>
<a name="ln1207">	case 't':</a>
<a name="ln1208">	  {</a>
<a name="ln1209">	    char garbage[3];</a>
<a name="ln1210">	    if ((sscanf(optarg,&quot;%ld%1s&quot;,&amp;gs.timeout,garbage) != 1) ||</a>
<a name="ln1211">	        (gs.timeout &lt; 1))</a>
<a name="ln1212">	      {</a>
<a name="ln1213">	        fprintf(stderr,&quot;Invalid timeout argument: %s\n&quot;,optarg);</a>
<a name="ln1214">		return usage(progname,1);</a>
<a name="ln1215">	      }</a>
<a name="ln1216">	  }</a>
<a name="ln1217">	  break;</a>
<a name="ln1218">	case 'T':</a>
<a name="ln1219">	  {</a>
<a name="ln1220">	    char garbage[3];</a>
<a name="ln1221">	    if ((sscanf(optarg,&quot;%ld%1s&quot;,&amp;gs.restart_timeout,garbage) != 1) ||</a>
<a name="ln1222">	        (gs.restart_timeout &lt; 1))</a>
<a name="ln1223">	      {</a>
<a name="ln1224">	        fprintf(stderr,&quot;Invalid restart timeout argument: %s\n&quot;,optarg);</a>
<a name="ln1225">		return usage(progname,1);</a>
<a name="ln1226">	      }</a>
<a name="ln1227">	  }</a>
<a name="ln1228">	  break;</a>
<a name="ln1229">        case 'z':</a>
<a name="ln1230">	  gs.unresponsive_restart = 1;</a>
<a name="ln1231">	  break;</a>
<a name="ln1232">	case 'v':</a>
<a name="ln1233">	  printf (&quot;%s version %s\n&quot;, progname, QUAGGA_VERSION);</a>
<a name="ln1234">	  puts(&quot;Copyright 2004 Andrew J. Schorr&quot;);</a>
<a name="ln1235">	  return 0;</a>
<a name="ln1236">        case 'h':</a>
<a name="ln1237">	  return usage(progname,0);</a>
<a name="ln1238">        default:</a>
<a name="ln1239">	  fputs(&quot;Invalid option.\n&quot;,stderr);</a>
<a name="ln1240">	  return usage(progname,1);</a>
<a name="ln1241">        }</a>
<a name="ln1242">    }</a>
<a name="ln1243">  </a>
<a name="ln1244">  if (gs.unresponsive_restart &amp;&amp; (gs.mode == MODE_MONITOR))</a>
<a name="ln1245">    {</a>
<a name="ln1246">      fputs(&quot;Option -z requires a -r or -R restart option.\n&quot;,stderr);</a>
<a name="ln1247">      return usage(progname,1);</a>
<a name="ln1248">    }</a>
<a name="ln1249">  switch (gs.mode)</a>
<a name="ln1250">    {</a>
<a name="ln1251">    case MODE_MONITOR:</a>
<a name="ln1252">      if (gs.restart_command || gs.start_command || gs.stop_command)</a>
<a name="ln1253">        {</a>
<a name="ln1254">	  fprintf(stderr,&quot;No kill/(re)start commands needed for %s mode.\n&quot;,</a>
<a name="ln1255">		  mode_str[gs.mode]);</a>
<a name="ln1256">	  return usage(progname,1);</a>
<a name="ln1257">	}</a>
<a name="ln1258">      break;</a>
<a name="ln1259">    case MODE_GLOBAL_RESTART:</a>
<a name="ln1260">    case MODE_SEPARATE_RESTART:</a>
<a name="ln1261">      if (!gs.restart_command || gs.start_command || gs.stop_command)</a>
<a name="ln1262">        {</a>
<a name="ln1263">	  fprintf(stderr,&quot;No start/kill commands needed in [%s] mode.\n&quot;,</a>
<a name="ln1264">		  mode_str[gs.mode]);</a>
<a name="ln1265">	  return usage(progname,1);</a>
<a name="ln1266">	}</a>
<a name="ln1267">      break;</a>
<a name="ln1268">    case MODE_PHASED_ZEBRA_RESTART:</a>
<a name="ln1269">    case MODE_PHASED_ALL_RESTART:</a>
<a name="ln1270">      if (!gs.restart_command || !gs.start_command || !gs.stop_command)</a>
<a name="ln1271">        {</a>
<a name="ln1272">	  fprintf(stderr,</a>
<a name="ln1273">	  	  &quot;Need start, kill, and restart commands in [%s] mode.\n&quot;,</a>
<a name="ln1274">		  mode_str[gs.mode]);</a>
<a name="ln1275">	  return usage(progname,1);</a>
<a name="ln1276">	}</a>
<a name="ln1277">      break;</a>
<a name="ln1278">    }</a>
<a name="ln1279"> </a>
<a name="ln1280">  if (blankstr)</a>
<a name="ln1281">    {</a>
<a name="ln1282">      if (gs.restart_command)</a>
<a name="ln1283">        gs.restart_command = translate_blanks(gs.restart_command,blankstr);</a>
<a name="ln1284">      if (gs.start_command)</a>
<a name="ln1285">        gs.start_command = translate_blanks(gs.start_command,blankstr);</a>
<a name="ln1286">      if (gs.stop_command)</a>
<a name="ln1287">        gs.stop_command = translate_blanks(gs.stop_command,blankstr);</a>
<a name="ln1288">    }</a>
<a name="ln1289">      </a>
<a name="ln1290">  gs.restart.interval = gs.min_restart_interval;</a>
<a name="ln1291">  master = thread_master_create();</a>
<a name="ln1292">  signal_init (master, array_size(my_signals), my_signals);</a>
<a name="ln1293">  srandom(time(NULL));</a>
<a name="ln1294"> </a>
<a name="ln1295">  {</a>
<a name="ln1296">    int i;</a>
<a name="ln1297">    struct daemon *tail = NULL;</a>
<a name="ln1298"> </a>
<a name="ln1299">    for (i = optind; i &lt; argc; i++)</a>
<a name="ln1300">      {</a>
<a name="ln1301">	struct daemon *dmn;</a>
<a name="ln1302"> </a>
<a name="ln1303">	if (!(dmn = (struct daemon *)calloc(1,sizeof(*dmn))))</a>
<a name="ln1304">	  {</a>
<a name="ln1305">	    fprintf(stderr,&quot;calloc(1,%u) failed: %s\n&quot;,</a>
<a name="ln1306">		    (u_int)sizeof(*dmn), safe_strerror(errno));</a>
<a name="ln1307">	    return 1;</a>
<a name="ln1308">	  }</a>
<a name="ln1309">	dmn-&gt;name = dmn-&gt;restart.name = argv[i];</a>
<a name="ln1310">	dmn-&gt;state = DAEMON_INIT;</a>
<a name="ln1311">	gs.numdaemons++;</a>
<a name="ln1312">	gs.numdown++;</a>
<a name="ln1313">	dmn-&gt;fd = -1;</a>
<a name="ln1314">	dmn-&gt;t_wakeup = thread_add_timer_msec(master,wakeup_init,dmn,</a>
<a name="ln1315">					      100+(random() % 900));</a>
<a name="ln1316">	dmn-&gt;restart.interval = gs.min_restart_interval;</a>
<a name="ln1317">	if (tail)</a>
<a name="ln1318">	  tail-&gt;next = dmn;</a>
<a name="ln1319">	else</a>
<a name="ln1320">	  gs.daemons = dmn;</a>
<a name="ln1321">	tail = dmn;</a>
<a name="ln1322"> </a>
<a name="ln1323">	if (((gs.mode == MODE_PHASED_ZEBRA_RESTART) ||</a>
<a name="ln1324">	     (gs.mode == MODE_PHASED_ALL_RESTART)) &amp;&amp;</a>
<a name="ln1325">	    !strcmp(dmn-&gt;name,special))</a>
<a name="ln1326">	  gs.special = dmn;</a>
<a name="ln1327">      }</a>
<a name="ln1328">  }</a>
<a name="ln1329">  if (!gs.daemons)</a>
<a name="ln1330">    {</a>
<a name="ln1331">      fputs(&quot;Must specify one or more daemons to monitor.\n&quot;,stderr);</a>
<a name="ln1332">      return usage(progname,1);</a>
<a name="ln1333">    }</a>
<a name="ln1334">  if (((gs.mode == MODE_PHASED_ZEBRA_RESTART) ||</a>
<a name="ln1335">      (gs.mode == MODE_PHASED_ALL_RESTART)) &amp;&amp; !gs.special)</a>
<a name="ln1336">    {</a>
<a name="ln1337">      fprintf(stderr,&quot;In mode [%s], but cannot find master daemon %s\n&quot;,</a>
<a name="ln1338">	      mode_str[gs.mode],special);</a>
<a name="ln1339">      return usage(progname,1);</a>
<a name="ln1340">    }</a>
<a name="ln1341">  if (gs.special &amp;&amp; (gs.numdaemons &lt; 2))</a>
<a name="ln1342">    {</a>
<a name="ln1343">      fprintf(stderr,&quot;Mode [%s] does not make sense with only 1 daemon &quot;</a>
<a name="ln1344">		     &quot;to watch.\n&quot;,mode_str[gs.mode]);</a>
<a name="ln1345">      return usage(progname,1);</a>
<a name="ln1346">    }</a>
<a name="ln1347"> </a>
<a name="ln1348">  zlog_default = openzlog(progname, ZLOG_NONE,</a>
<a name="ln1349">			  LOG_CONS|LOG_NDELAY|LOG_PID, LOG_DAEMON);</a>
<a name="ln1350">  zlog_set_level(NULL, ZLOG_DEST_MONITOR, ZLOG_DISABLED);</a>
<a name="ln1351">  if (daemon_mode)</a>
<a name="ln1352">    {</a>
<a name="ln1353">      zlog_set_level(NULL, ZLOG_DEST_SYSLOG, MIN(gs.loglevel,LOG_DEBUG));</a>
<a name="ln1354">      if (daemon (0, 0) &lt; 0)</a>
<a name="ln1355">	{</a>
<a name="ln1356">	  fprintf(stderr, &quot;Watchquagga daemon failed: %s&quot;, strerror(errno));</a>
<a name="ln1357">	  exit (1);</a>
<a name="ln1358">	}</a>
<a name="ln1359">    }</a>
<a name="ln1360">  else</a>
<a name="ln1361">    zlog_set_level(NULL, ZLOG_DEST_STDOUT, MIN(gs.loglevel,LOG_DEBUG));</a>
<a name="ln1362"> </a>
<a name="ln1363">  /* Make sure we're not already running. */</a>
<a name="ln1364">  pid_output (pidfile);</a>
<a name="ln1365"> </a>
<a name="ln1366">  /* Announce which daemons are being monitored. */</a>
<a name="ln1367">  {</a>
<a name="ln1368">    struct daemon *dmn;</a>
<a name="ln1369">    size_t len = 0;</a>
<a name="ln1370"> </a>
<a name="ln1371">    for (dmn = gs.daemons; dmn; dmn = dmn-&gt;next)</a>
<a name="ln1372">      len += strlen(dmn-&gt;name)+1;</a>
<a name="ln1373"> </a>
<a name="ln1374">    {</a>
<a name="ln1375">      char buf[len+1];</a>
<a name="ln1376">      char *p = buf;</a>
<a name="ln1377"> </a>
<a name="ln1378">      for (dmn = gs.daemons; dmn; dmn = dmn-&gt;next)</a>
<a name="ln1379">	{</a>
<a name="ln1380">	  if (p != buf)</a>
<a name="ln1381">	    *p++ = ' ';</a>
<a name="ln1382">	  strcpy(p,dmn-&gt;name);</a>
<a name="ln1383">	  p += strlen(p);</a>
<a name="ln1384">	}</a>
<a name="ln1385">      zlog_notice(&quot;%s %s watching [%s], mode [%s]&quot;,</a>
<a name="ln1386">      		  progname, QUAGGA_VERSION, buf, mode_str[gs.mode]);</a>
<a name="ln1387">    }</a>
<a name="ln1388">  }</a>
<a name="ln1389">  </a>
<a name="ln1390">  thread_main (master);</a>
<a name="ln1391">  </a>
<a name="ln1392">  /* Not reached. */</a>
<a name="ln1393">  return 0;</a>
<a name="ln1394">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
