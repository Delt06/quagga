
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1"> </a>
<a name="ln2">/* </a>
<a name="ln3"> * Interface functions.</a>
<a name="ln4"> * Copyright (C) 1997, 98 Kunihiro Ishiguro</a>
<a name="ln5"> *</a>
<a name="ln6"> * This file is part of GNU Zebra.</a>
<a name="ln7"> * </a>
<a name="ln8"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln9"> * it under the terms of the GNU General Public License as published</a>
<a name="ln10"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln11"> * option) any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln14"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public License</a>
<a name="ln19"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln20"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln21"> * Boston, MA 02111-1307, USA.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;linklist.h&quot;</a>
<a name="ln27">#include &quot;vector.h&quot;</a>
<a name="ln28">#include &quot;vty.h&quot;</a>
<a name="ln29">#include &quot;command.h&quot;</a>
<a name="ln30">#include &quot;vrf.h&quot;</a>
<a name="ln31">#include &quot;if.h&quot;</a>
<a name="ln32">#include &quot;sockunion.h&quot;</a>
<a name="ln33">#include &quot;prefix.h&quot;</a>
<a name="ln34">#include &quot;memory.h&quot;</a>
<a name="ln35">#include &quot;table.h&quot;</a>
<a name="ln36">#include &quot;buffer.h&quot;</a>
<a name="ln37">#include &quot;str.h&quot;</a>
<a name="ln38">#include &quot;log.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">/* List of interfaces in only the default VRF */</a>
<a name="ln41">struct list *iflist;</a>
<a name="ln42"> </a>
<a name="ln43">/* One for each program.  This structure is needed to store hooks. */</a>
<a name="ln44">struct if_master</a>
<a name="ln45">{</a>
<a name="ln46">  int (*if_new_hook) (struct interface *);</a>
<a name="ln47">  int (*if_delete_hook) (struct interface *);</a>
<a name="ln48">} if_master = {0,};</a>
<a name="ln49"> </a>
<a name="ln50">/* Compare interface names, returning an integer greater than, equal to, or</a>
<a name="ln51"> * less than 0, (following the strcmp convention), according to the</a>
<a name="ln52"> * relationship between ifp1 and ifp2.  Interface names consist of an</a>
<a name="ln53"> * alphabetic prefix and a numeric suffix.  The primary sort key is</a>
<a name="ln54"> * lexicographic by name, and then numeric by number.  No number sorts</a>
<a name="ln55"> * before all numbers.  Examples: de0 &lt; de1, de100 &lt; fxp0 &lt; xl0, devpty &lt;</a>
<a name="ln56"> * devpty0, de0 &lt; del0</a>
<a name="ln57"> */         </a>
<a name="ln58">int</a>
<a name="ln59">if_cmp_func (struct interface *ifp1, struct interface *ifp2)</a>
<a name="ln60">{</a>
<a name="ln61">  unsigned int l1, l2;</a>
<a name="ln62">  long int x1, x2;</a>
<a name="ln63">  char *p1, *p2;</a>
<a name="ln64">  int res;</a>
<a name="ln65"> </a>
<a name="ln66">  p1 = ifp1-&gt;name;</a>
<a name="ln67">  p2 = ifp2-&gt;name;</a>
<a name="ln68"> </a>
<a name="ln69">  while (*p1 &amp;&amp; *p2) {</a>
<a name="ln70">    /* look up to any number */</a>
<a name="ln71">    l1 = strcspn(p1, &quot;0123456789&quot;);</a>
<a name="ln72">    l2 = strcspn(p2, &quot;0123456789&quot;);</a>
<a name="ln73"> </a>
<a name="ln74">    /* name lengths are different -&gt; compare names */</a>
<a name="ln75">    if (l1 != l2)</a>
<a name="ln76">      return (strcmp(p1, p2));</a>
<a name="ln77"> </a>
<a name="ln78">    /* Note that this relies on all numbers being less than all letters, so</a>
<a name="ln79">     * that de0 &lt; del0.</a>
<a name="ln80">     */</a>
<a name="ln81">    res = strncmp(p1, p2, l1);</a>
<a name="ln82"> </a>
<a name="ln83">    /* names are different -&gt; compare them */</a>
<a name="ln84">    if (res)</a>
<a name="ln85">      return res;</a>
<a name="ln86"> </a>
<a name="ln87">    /* with identical name part, go to numeric part */</a>
<a name="ln88">    p1 += l1;</a>
<a name="ln89">    p2 += l1;</a>
<a name="ln90"> </a>
<a name="ln91">    if (!*p1) </a>
<a name="ln92">      return -1;</a>
<a name="ln93">    if (!*p2) </a>
<a name="ln94">      return 1;</a>
<a name="ln95"> </a>
<a name="ln96">    x1 = strtol(p1, &amp;p1, 10);</a>
<a name="ln97">    x2 = strtol(p2, &amp;p2, 10);</a>
<a name="ln98"> </a>
<a name="ln99">    /* let's compare numbers now */</a>
<a name="ln100">    if (x1 &lt; x2)</a>
<a name="ln101">      return -1;</a>
<a name="ln102">    if (x1 &gt; x2)</a>
<a name="ln103">      return 1;</a>
<a name="ln104"> </a>
<a name="ln105">    /* numbers were equal, lets do it again..</a>
<a name="ln106">    (it happens with name like &quot;eth123.456:789&quot;) */</a>
<a name="ln107">  }</a>
<a name="ln108">  if (*p1)</a>
<a name="ln109">    return 1;</a>
<a name="ln110">  if (*p2)</a>
<a name="ln111">    return -1;</a>
<a name="ln112">  return 0;</a>
<a name="ln113">}</a>
<a name="ln114"> </a>
<a name="ln115">/* Create new interface structure. */</a>
<a name="ln116">struct interface *</a>
<a name="ln117">if_create_vrf (const char *name, int namelen, vrf_id_t vrf_id)</a>
<a name="ln118">{</a>
<a name="ln119">  struct interface *ifp;</a>
<a name="ln120">  struct list *intf_list = vrf_iflist_get (vrf_id);</a>
<a name="ln121"> </a>
<a name="ln122">  ifp = XCALLOC (MTYPE_IF, sizeof (struct interface));</a>
<a name="ln123">  ifp-&gt;ifindex = IFINDEX_INTERNAL;</a>
<a name="ln124">  </a>
<a name="ln125">  assert (name);</a>
<a name="ln126">  assert (namelen &lt;= INTERFACE_NAMSIZ);	/* Need space for '\0' at end. */</a>
<a name="ln127">  strncpy (ifp-&gt;name, name, namelen);</a>
<a name="ln128">  ifp-&gt;name[namelen] = '\0';</a>
<a name="ln129">  ifp-&gt;vrf_id = vrf_id;</a>
<a name="ln130">  if (if_lookup_by_name_vrf (ifp-&gt;name, vrf_id) == NULL)</a>
<a name="ln131">    listnode_add_sort (intf_list, ifp);</a>
<a name="ln132">  else</a>
<a name="ln133">    zlog_err(&quot;if_create(%s): corruption detected -- interface with this &quot;</a>
<a name="ln134">             &quot;name exists already in VRF %u!&quot;, ifp-&gt;name, vrf_id);</a>
<a name="ln135">  ifp-&gt;connected = list_new ();</a>
<a name="ln136">  ifp-&gt;connected-&gt;del = (void (*) (void *)) connected_free;</a>
<a name="ln137"> </a>
<a name="ln138">  if (if_master.if_new_hook)</a>
<a name="ln139">    (*if_master.if_new_hook) (ifp);</a>
<a name="ln140"> </a>
<a name="ln141">  return ifp;</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">struct interface *</a>
<a name="ln145">if_create (const char *name, int namelen)</a>
<a name="ln146">{</a>
<a name="ln147">  return if_create_vrf (name, namelen, VRF_DEFAULT);</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">/* Delete interface structure. */</a>
<a name="ln151">void</a>
<a name="ln152">if_delete_retain (struct interface *ifp)</a>
<a name="ln153">{</a>
<a name="ln154">  if (if_master.if_delete_hook)</a>
<a name="ln155">    (*if_master.if_delete_hook) (ifp);</a>
<a name="ln156"> </a>
<a name="ln157">  /* Free connected address list */</a>
<a name="ln158">  list_delete_all_node (ifp-&gt;connected);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">/* Delete and free interface structure. */</a>
<a name="ln162">void</a>
<a name="ln163">if_delete (struct interface *ifp)</a>
<a name="ln164">{</a>
<a name="ln165">  listnode_delete (vrf_iflist (ifp-&gt;vrf_id), ifp);</a>
<a name="ln166"> </a>
<a name="ln167">  if_delete_retain(ifp);</a>
<a name="ln168"> </a>
<a name="ln169">  list_free (ifp-&gt;connected);</a>
<a name="ln170"> </a>
<a name="ln171">  if_link_params_free (ifp);</a>
<a name="ln172">  </a>
<a name="ln173">  XFREE (MTYPE_IF, ifp);</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">/* Add hook to interface master. */</a>
<a name="ln177">void</a>
<a name="ln178">if_add_hook (int type, int (*func)(struct interface *ifp))</a>
<a name="ln179">{</a>
<a name="ln180">  switch (type) {</a>
<a name="ln181">  case IF_NEW_HOOK:</a>
<a name="ln182">    if_master.if_new_hook = func;</a>
<a name="ln183">    break;</a>
<a name="ln184">  case IF_DELETE_HOOK:</a>
<a name="ln185">    if_master.if_delete_hook = func;</a>
<a name="ln186">    break;</a>
<a name="ln187">  default:</a>
<a name="ln188">    break;</a>
<a name="ln189">  }</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">/* Interface existance check by index. */</a>
<a name="ln193">struct interface *</a>
<a name="ln194">if_lookup_by_index_vrf (ifindex_t ifindex, vrf_id_t vrf_id)</a>
<a name="ln195">{</a>
<a name="ln196">  struct listnode *node;</a>
<a name="ln197">  struct interface *ifp;</a>
<a name="ln198"> </a>
<a name="ln199">  for (ALL_LIST_ELEMENTS_RO (vrf_iflist (vrf_id), node, ifp))</a>
<a name="ln200">    {</a>
<a name="ln201">      if (ifp-&gt;ifindex == ifindex)</a>
<a name="ln202">	return ifp;</a>
<a name="ln203">    }</a>
<a name="ln204">  return NULL;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">struct interface *</a>
<a name="ln208">if_lookup_by_index (ifindex_t ifindex)</a>
<a name="ln209">{</a>
<a name="ln210">  return if_lookup_by_index_vrf (ifindex, VRF_DEFAULT);</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">const char *</a>
<a name="ln214">ifindex2ifname_vrf (ifindex_t ifindex, vrf_id_t vrf_id)</a>
<a name="ln215">{</a>
<a name="ln216">  struct interface *ifp;</a>
<a name="ln217"> </a>
<a name="ln218">  return ((ifp = if_lookup_by_index_vrf (ifindex, vrf_id)) != NULL) ?</a>
<a name="ln219">  	 ifp-&gt;name : &quot;unknown&quot;;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">const char *</a>
<a name="ln223">ifindex2ifname (ifindex_t ifindex)</a>
<a name="ln224">{</a>
<a name="ln225">  return ifindex2ifname_vrf (ifindex, VRF_DEFAULT);</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">ifindex_t</a>
<a name="ln229">ifname2ifindex_vrf (const char *name, vrf_id_t vrf_id)</a>
<a name="ln230">{</a>
<a name="ln231">  struct interface *ifp;</a>
<a name="ln232"> </a>
<a name="ln233">  return ((ifp = if_lookup_by_name_vrf (name, vrf_id)) != NULL) ? ifp-&gt;ifindex</a>
<a name="ln234">                                                   : IFINDEX_INTERNAL;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">ifindex_t</a>
<a name="ln238">ifname2ifindex (const char *name)</a>
<a name="ln239">{</a>
<a name="ln240">  return ifname2ifindex_vrf (name, VRF_DEFAULT);</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">/* Interface existance check by interface name. */</a>
<a name="ln244">struct interface *</a>
<a name="ln245">if_lookup_by_name_vrf (const char *name, vrf_id_t vrf_id)</a>
<a name="ln246">{</a>
<a name="ln247">  struct listnode *node;</a>
<a name="ln248">  struct interface *ifp;</a>
<a name="ln249">  </a>
<a name="ln250">  if (name)</a>
<a name="ln251">    for (ALL_LIST_ELEMENTS_RO (vrf_iflist (vrf_id), node, ifp))</a>
<a name="ln252">      {</a>
<a name="ln253">        if (strcmp(name, ifp-&gt;name) == 0)</a>
<a name="ln254">          return ifp;</a>
<a name="ln255">      }</a>
<a name="ln256">  return NULL;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">struct interface *</a>
<a name="ln260">if_lookup_by_name (const char *name)</a>
<a name="ln261">{</a>
<a name="ln262">  return if_lookup_by_name_vrf (name, VRF_DEFAULT);</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">struct interface *</a>
<a name="ln266">if_lookup_by_name_len_vrf (const char *name, size_t namelen, vrf_id_t vrf_id)</a>
<a name="ln267">{</a>
<a name="ln268">  struct listnode *node;</a>
<a name="ln269">  struct interface *ifp;</a>
<a name="ln270"> </a>
<a name="ln271">  if (namelen &gt; INTERFACE_NAMSIZ)</a>
<a name="ln272">    return NULL;</a>
<a name="ln273"> </a>
<a name="ln274">  for (ALL_LIST_ELEMENTS_RO (vrf_iflist (vrf_id), node, ifp))</a>
<a name="ln275">    {</a>
<a name="ln276">      if (!memcmp(name, ifp-&gt;name, namelen) &amp;&amp; (ifp-&gt;name[namelen] == '\0'))</a>
<a name="ln277">	return ifp;</a>
<a name="ln278">    }</a>
<a name="ln279">  return NULL;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">struct interface *</a>
<a name="ln283">if_lookup_by_name_len(const char *name, size_t namelen)</a>
<a name="ln284">{</a>
<a name="ln285">  return if_lookup_by_name_len_vrf (name, namelen, VRF_DEFAULT);</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">/* Lookup interface by IPv4 address. */</a>
<a name="ln289">struct interface *</a>
<a name="ln290">if_lookup_exact_address_vrf (struct in_addr src, vrf_id_t vrf_id)</a>
<a name="ln291">{</a>
<a name="ln292">  struct listnode *node;</a>
<a name="ln293">  struct listnode *cnode;</a>
<a name="ln294">  struct interface *ifp;</a>
<a name="ln295">  struct prefix *p;</a>
<a name="ln296">  struct connected *c;</a>
<a name="ln297"> </a>
<a name="ln298">  for (ALL_LIST_ELEMENTS_RO (vrf_iflist (vrf_id), node, ifp))</a>
<a name="ln299">    {</a>
<a name="ln300">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, c))</a>
<a name="ln301">	{</a>
<a name="ln302">	  p = c-&gt;address;</a>
<a name="ln303"> </a>
<a name="ln304">	  if (p &amp;&amp; p-&gt;family == AF_INET)</a>
<a name="ln305">	    {</a>
<a name="ln306">	      if (IPV4_ADDR_SAME (&amp;p-&gt;u.prefix4, &amp;src))</a>
<a name="ln307">		return ifp;</a>
<a name="ln308">	    }	      </a>
<a name="ln309">	}</a>
<a name="ln310">    }</a>
<a name="ln311">  return NULL;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">struct interface *</a>
<a name="ln315">if_lookup_exact_address (struct in_addr src)</a>
<a name="ln316">{</a>
<a name="ln317">  return if_lookup_exact_address_vrf (src, VRF_DEFAULT);</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">/* Lookup interface by IPv4 address. */</a>
<a name="ln321">struct interface *</a>
<a name="ln322">if_lookup_address_vrf (struct in_addr src, vrf_id_t vrf_id)</a>
<a name="ln323">{</a>
<a name="ln324">  struct listnode *node;</a>
<a name="ln325">  struct prefix addr;</a>
<a name="ln326">  int bestlen = 0;</a>
<a name="ln327">  struct listnode *cnode;</a>
<a name="ln328">  struct interface *ifp;</a>
<a name="ln329">  struct connected *c;</a>
<a name="ln330">  struct interface *match;</a>
<a name="ln331"> </a>
<a name="ln332">  addr.family = AF_INET;</a>
<a name="ln333">  addr.u.prefix4 = src;</a>
<a name="ln334">  addr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln335"> </a>
<a name="ln336">  match = NULL;</a>
<a name="ln337"> </a>
<a name="ln338">  for (ALL_LIST_ELEMENTS_RO (vrf_iflist (vrf_id), node, ifp))</a>
<a name="ln339">    {</a>
<a name="ln340">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, c))</a>
<a name="ln341">	{</a>
<a name="ln342">	  if (c-&gt;address &amp;&amp; (c-&gt;address-&gt;family == AF_INET) &amp;&amp;</a>
<a name="ln343">	      prefix_match(CONNECTED_PREFIX(c), &amp;addr) &amp;&amp;</a>
<a name="ln344">	      (c-&gt;address-&gt;prefixlen &gt; bestlen))</a>
<a name="ln345">	    {</a>
<a name="ln346">	      bestlen = c-&gt;address-&gt;prefixlen;</a>
<a name="ln347">	      match = ifp;</a>
<a name="ln348">	    }</a>
<a name="ln349">	}</a>
<a name="ln350">    }</a>
<a name="ln351">  return match;</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">struct interface *</a>
<a name="ln355">if_lookup_address (struct in_addr src)</a>
<a name="ln356">{</a>
<a name="ln357">  return if_lookup_address_vrf (src, VRF_DEFAULT);</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">/* Lookup interface by prefix */</a>
<a name="ln361">struct interface *</a>
<a name="ln362">if_lookup_prefix_vrf (struct prefix *prefix, vrf_id_t vrf_id)</a>
<a name="ln363">{</a>
<a name="ln364">  struct listnode *node;</a>
<a name="ln365">  struct listnode *cnode;</a>
<a name="ln366">  struct interface *ifp;</a>
<a name="ln367">  struct connected *c;</a>
<a name="ln368"> </a>
<a name="ln369">  for (ALL_LIST_ELEMENTS_RO (vrf_iflist (vrf_id), node, ifp))</a>
<a name="ln370">    {</a>
<a name="ln371">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, c))</a>
<a name="ln372">        {</a>
<a name="ln373">          if (prefix_cmp(c-&gt;address, prefix) == 0)</a>
<a name="ln374">            {</a>
<a name="ln375">              return ifp;</a>
<a name="ln376">            }</a>
<a name="ln377">        }</a>
<a name="ln378">    }</a>
<a name="ln379">  return NULL;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">struct interface *</a>
<a name="ln383">if_lookup_prefix (struct prefix *prefix)</a>
<a name="ln384">{</a>
<a name="ln385">  return if_lookup_prefix_vrf (prefix, VRF_DEFAULT);</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">/* Get interface by name if given name interface doesn't exist create</a>
<a name="ln389">   one. */</a>
<a name="ln390">struct interface *</a>
<a name="ln391">if_get_by_name_vrf (const char *name, vrf_id_t vrf_id)</a>
<a name="ln392">{</a>
<a name="ln393">  struct interface *ifp;</a>
<a name="ln394"> </a>
<a name="ln395">  return ((ifp = if_lookup_by_name_vrf (name, vrf_id)) != NULL) ? ifp :</a>
<a name="ln396">         if_create_vrf (name, strlen(name), vrf_id);</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399">struct interface *</a>
<a name="ln400">if_get_by_name (const char *name)</a>
<a name="ln401">{</a>
<a name="ln402">  return if_get_by_name_vrf (name, VRF_DEFAULT);</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">struct interface *</a>
<a name="ln406">if_get_by_name_len_vrf (const char *name, size_t namelen, vrf_id_t vrf_id)</a>
<a name="ln407">{</a>
<a name="ln408">  struct interface *ifp;</a>
<a name="ln409"> </a>
<a name="ln410">  return ((ifp = if_lookup_by_name_len_vrf (name, namelen, vrf_id)) != NULL) ? \</a>
<a name="ln411">         ifp : if_create_vrf (name, namelen, vrf_id);</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">struct interface *</a>
<a name="ln415">if_get_by_name_len (const char *name, size_t namelen)</a>
<a name="ln416">{</a>
<a name="ln417">  return if_get_by_name_len_vrf (name, namelen, VRF_DEFAULT);</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">/* Does interface up ? */</a>
<a name="ln421">int</a>
<a name="ln422">if_is_up (struct interface *ifp)</a>
<a name="ln423">{</a>
<a name="ln424">  return ifp-&gt;flags &amp; IFF_UP;</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">/* Is interface running? */</a>
<a name="ln428">int</a>
<a name="ln429">if_is_running (struct interface *ifp)</a>
<a name="ln430">{</a>
<a name="ln431">  return ifp-&gt;flags &amp; IFF_RUNNING;</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">/* Is the interface operative, eg. either UP &amp; RUNNING</a>
<a name="ln435">   or UP &amp; !ZEBRA_INTERFACE_LINK_DETECTION */</a>
<a name="ln436">int</a>
<a name="ln437">if_is_operative (struct interface *ifp)</a>
<a name="ln438">{</a>
<a name="ln439">  return ((ifp-&gt;flags &amp; IFF_UP) &amp;&amp;</a>
<a name="ln440">	  (ifp-&gt;flags &amp; IFF_RUNNING || !CHECK_FLAG(ifp-&gt;status, ZEBRA_INTERFACE_LINKDETECTION)));</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">/* Is this loopback interface ? */</a>
<a name="ln444">int</a>
<a name="ln445">if_is_loopback (struct interface *ifp)</a>
<a name="ln446">{</a>
<a name="ln447">  /* XXX: Do this better, eg what if IFF_WHATEVER means X on platform M</a>
<a name="ln448">   * but Y on platform N?</a>
<a name="ln449">   */</a>
<a name="ln450">  return (ifp-&gt;flags &amp; (IFF_LOOPBACK|IFF_NOXMIT|IFF_VIRTUAL));</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">/* Does this interface support broadcast ? */</a>
<a name="ln454">int</a>
<a name="ln455">if_is_broadcast (struct interface *ifp)</a>
<a name="ln456">{</a>
<a name="ln457">  return ifp-&gt;flags &amp; IFF_BROADCAST;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">/* Does this interface support broadcast ? */</a>
<a name="ln461">int</a>
<a name="ln462">if_is_pointopoint (struct interface *ifp)</a>
<a name="ln463">{</a>
<a name="ln464">  return ifp-&gt;flags &amp; IFF_POINTOPOINT;</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">/* Does this interface support multicast ? */</a>
<a name="ln468">int</a>
<a name="ln469">if_is_multicast (struct interface *ifp)</a>
<a name="ln470">{</a>
<a name="ln471">  return ifp-&gt;flags &amp; IFF_MULTICAST;</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">/* Printout flag information into log */</a>
<a name="ln475">const char *</a>
<a name="ln476">if_flag_dump (unsigned long flag)</a>
<a name="ln477">{</a>
<a name="ln478">  int separator = 0;</a>
<a name="ln479">  static char logbuf[BUFSIZ];</a>
<a name="ln480"> </a>
<a name="ln481">#define IFF_OUT_LOG(X,STR) \</a>
<a name="ln482">  if (flag &amp; (X)) \</a>
<a name="ln483">    { \</a>
<a name="ln484">      if (separator) \</a>
<a name="ln485">	strlcat (logbuf, &quot;,&quot;, BUFSIZ); \</a>
<a name="ln486">      else \</a>
<a name="ln487">	separator = 1; \</a>
<a name="ln488">      strlcat (logbuf, STR, BUFSIZ); \</a>
<a name="ln489">    }</a>
<a name="ln490"> </a>
<a name="ln491">  strlcpy (logbuf, &quot;&lt;&quot;, BUFSIZ);</a>
<a name="ln492">  IFF_OUT_LOG (IFF_UP, &quot;UP&quot;);</a>
<a name="ln493">  IFF_OUT_LOG (IFF_BROADCAST, &quot;BROADCAST&quot;);</a>
<a name="ln494">  IFF_OUT_LOG (IFF_DEBUG, &quot;DEBUG&quot;);</a>
<a name="ln495">  IFF_OUT_LOG (IFF_LOOPBACK, &quot;LOOPBACK&quot;);</a>
<a name="ln496">  IFF_OUT_LOG (IFF_POINTOPOINT, &quot;POINTOPOINT&quot;);</a>
<a name="ln497">  IFF_OUT_LOG (IFF_NOTRAILERS, &quot;NOTRAILERS&quot;);</a>
<a name="ln498">  IFF_OUT_LOG (IFF_RUNNING, &quot;RUNNING&quot;);</a>
<a name="ln499">  IFF_OUT_LOG (IFF_NOARP, &quot;NOARP&quot;);</a>
<a name="ln500">  IFF_OUT_LOG (IFF_PROMISC, &quot;PROMISC&quot;);</a>
<a name="ln501">  IFF_OUT_LOG (IFF_ALLMULTI, &quot;ALLMULTI&quot;);</a>
<a name="ln502">  IFF_OUT_LOG (IFF_OACTIVE, &quot;OACTIVE&quot;);</a>
<a name="ln503">  IFF_OUT_LOG (IFF_SIMPLEX, &quot;SIMPLEX&quot;);</a>
<a name="ln504">  IFF_OUT_LOG (IFF_LINK0, &quot;LINK0&quot;);</a>
<a name="ln505">  IFF_OUT_LOG (IFF_LINK1, &quot;LINK1&quot;);</a>
<a name="ln506">  IFF_OUT_LOG (IFF_LINK2, &quot;LINK2&quot;);</a>
<a name="ln507">  IFF_OUT_LOG (IFF_MULTICAST, &quot;MULTICAST&quot;);</a>
<a name="ln508">  IFF_OUT_LOG (IFF_NOXMIT, &quot;NOXMIT&quot;);</a>
<a name="ln509">  IFF_OUT_LOG (IFF_NORTEXCH, &quot;NORTEXCH&quot;);</a>
<a name="ln510">  IFF_OUT_LOG (IFF_VIRTUAL, &quot;VIRTUAL&quot;);</a>
<a name="ln511">  IFF_OUT_LOG (IFF_IPV4, &quot;IPv4&quot;);</a>
<a name="ln512">  IFF_OUT_LOG (IFF_IPV6, &quot;IPv6&quot;);</a>
<a name="ln513"> </a>
<a name="ln514">  strlcat (logbuf, &quot;&gt;&quot;, BUFSIZ);</a>
<a name="ln515"> </a>
<a name="ln516">  return logbuf;</a>
<a name="ln517">#undef IFF_OUT_LOG</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">/* For debugging */</a>
<a name="ln521">static void</a>
<a name="ln522">if_dump (const struct interface *ifp)</a>
<a name="ln523">{</a>
<a name="ln524">  struct listnode *node;</a>
<a name="ln525">  struct connected *c __attribute__((unused));</a>
<a name="ln526"> </a>
<a name="ln527">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, node, c))</a>
<a name="ln528">    zlog_info (&quot;Interface %s vrf %u index %d metric %d mtu %d &quot;</a>
<a name="ln529">#ifdef HAVE_IPV6</a>
<a name="ln530">               &quot;mtu6 %d &quot;</a>
<a name="ln531">#endif /* HAVE_IPV6 */</a>
<a name="ln532">               &quot;%s&quot;,</a>
<a name="ln533">               ifp-&gt;name, ifp-&gt;vrf_id, ifp-&gt;ifindex, ifp-&gt;metric, ifp-&gt;mtu,</a>
<a name="ln534">#ifdef HAVE_IPV6</a>
<a name="ln535">               ifp-&gt;mtu6,</a>
<a name="ln536">#endif /* HAVE_IPV6 */</a>
<a name="ln537">               if_flag_dump (ifp-&gt;flags));</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">/* Interface printing for all interface. */</a>
<a name="ln541">void</a>
<a name="ln542">if_dump_all (void)</a>
<a name="ln543">{</a>
<a name="ln544">  struct list *intf_list;</a>
<a name="ln545">  struct listnode *node;</a>
<a name="ln546">  void *p;</a>
<a name="ln547">  vrf_iter_t iter;</a>
<a name="ln548"> </a>
<a name="ln549">  for (iter = vrf_first (); iter != VRF_ITER_INVALID; iter = vrf_next (iter))</a>
<a name="ln550">    if ((intf_list = vrf_iter2iflist (iter)) != NULL)</a>
<a name="ln551">      for (ALL_LIST_ELEMENTS_RO (intf_list, node, p))</a>
<a name="ln552">        if_dump (p);</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">DEFUN (interface_desc, </a>
<a name="ln556">       interface_desc_cmd,</a>
<a name="ln557">       &quot;description .LINE&quot;,</a>
<a name="ln558">       &quot;Interface specific description\n&quot;</a>
<a name="ln559">       &quot;Characters describing this interface\n&quot;)</a>
<a name="ln560">{</a>
<a name="ln561">  struct interface *ifp;</a>
<a name="ln562"> </a>
<a name="ln563">  if (argc == 0)</a>
<a name="ln564">    return CMD_SUCCESS;</a>
<a name="ln565"> </a>
<a name="ln566">  ifp = vty-&gt;index;</a>
<a name="ln567">  if (ifp-&gt;desc)</a>
<a name="ln568">    XFREE (MTYPE_TMP, ifp-&gt;desc);</a>
<a name="ln569">  ifp-&gt;desc = argv_concat(argv, argc, 0);</a>
<a name="ln570"> </a>
<a name="ln571">  return CMD_SUCCESS;</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">DEFUN (no_interface_desc, </a>
<a name="ln575">       no_interface_desc_cmd,</a>
<a name="ln576">       &quot;no description&quot;,</a>
<a name="ln577">       NO_STR</a>
<a name="ln578">       &quot;Interface specific description\n&quot;)</a>
<a name="ln579">{</a>
<a name="ln580">  struct interface *ifp;</a>
<a name="ln581"> </a>
<a name="ln582">  ifp = vty-&gt;index;</a>
<a name="ln583">  if (ifp-&gt;desc)</a>
<a name="ln584">    XFREE (MTYPE_TMP, ifp-&gt;desc);</a>
<a name="ln585">  ifp-&gt;desc = NULL;</a>
<a name="ln586"> </a>
<a name="ln587">  return CMD_SUCCESS;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">#ifdef SUNOS_5</a>
<a name="ln591">/* Need to handle upgrade from SUNWzebra to Quagga. SUNWzebra created</a>
<a name="ln592"> * a seperate struct interface for each logical interface, so config</a>
<a name="ln593"> * file may be full of 'interface fooX:Y'. Solaris however does not</a>
<a name="ln594"> * expose logical interfaces via PF_ROUTE, so trying to track logical</a>
<a name="ln595"> * interfaces can be fruitless, for that reason Quagga only tracks</a>
<a name="ln596"> * the primary IP interface.</a>
<a name="ln597"> *</a>
<a name="ln598"> * We try accomodate SUNWzebra by:</a>
<a name="ln599"> * - looking up the interface name, to see whether it exists, if so</a>
<a name="ln600"> *   its useable</a>
<a name="ln601"> *   - for protocol daemons, this could only because zebra told us of</a>
<a name="ln602"> *     the interface</a>
<a name="ln603"> *   - for zebra, only because it learnt from kernel</a>
<a name="ln604"> * - if not:</a>
<a name="ln605"> *   - search the name to see if it contains a sub-ipif / logical interface</a>
<a name="ln606"> *     seperator, the ':' char. If it does:</a>
<a name="ln607"> *     - text up to that char must be the primary name - get that name.</a>
<a name="ln608"> *     if not:</a>
<a name="ln609"> *     - no idea, just get the name in its entirety.</a>
<a name="ln610"> */</a>
<a name="ln611">static struct interface *</a>
<a name="ln612">if_sunwzebra_get (const char *name, size_t nlen, vrf_id_t vrf_id)</a>
<a name="ln613">{</a>
<a name="ln614">  struct interface *ifp;</a>
<a name="ln615">  size_t seppos = 0;</a>
<a name="ln616"> </a>
<a name="ln617">  if ( (ifp = if_lookup_by_name_len_vrf (name, nlen, vrf_id)) != NULL)</a>
<a name="ln618">    return ifp;</a>
<a name="ln619">  </a>
<a name="ln620">  /* hunt the primary interface name... */</a>
<a name="ln621">  while (seppos &lt; nlen &amp;&amp; name[seppos] != ':')</a>
<a name="ln622">    seppos++;</a>
<a name="ln623">  </a>
<a name="ln624">  /* Wont catch seperator as last char, e.g. 'foo0:' but thats invalid */</a>
<a name="ln625">  if (seppos &lt; nlen)</a>
<a name="ln626">    return if_get_by_name_len_vrf (name, seppos, vrf_id);</a>
<a name="ln627">  else</a>
<a name="ln628">    return if_get_by_name_len_vrf (name, nlen, vrf_id);</a>
<a name="ln629">}</a>
<a name="ln630">#endif /* SUNOS_5 */</a>
<a name="ln631"> </a>
<a name="ln632">DEFUN (interface,</a>
<a name="ln633">       interface_cmd,</a>
<a name="ln634">       &quot;interface IFNAME&quot;,</a>
<a name="ln635">       &quot;Select an interface to configure\n&quot;</a>
<a name="ln636">       &quot;Interface's name\n&quot;)</a>
<a name="ln637">{</a>
<a name="ln638">  struct interface *ifp;</a>
<a name="ln639">  size_t sl;</a>
<a name="ln640">  vrf_id_t vrf_id = VRF_DEFAULT;</a>
<a name="ln641"> </a>
<a name="ln642">  if ((sl = strlen(argv[0])) &gt; INTERFACE_NAMSIZ)</a>
<a name="ln643">    {</a>
<a name="ln644">      vty_out (vty, &quot;%% Interface name %s is invalid: length exceeds &quot;</a>
<a name="ln645">		    &quot;%d characters%s&quot;,</a>
<a name="ln646">	       argv[0], INTERFACE_NAMSIZ, VTY_NEWLINE);</a>
<a name="ln647">      return CMD_WARNING;</a>
<a name="ln648">    }</a>
<a name="ln649"> </a>
<a name="ln650">  if (argc &gt; 1)</a>
<a name="ln651">    VTY_GET_INTEGER (&quot;VRF ID&quot;, vrf_id, argv[1]);</a>
<a name="ln652"> </a>
<a name="ln653">#ifdef SUNOS_5</a>
<a name="ln654">  ifp = if_sunwzebra_get (argv[0], sl, vrf_id);</a>
<a name="ln655">#else</a>
<a name="ln656">  ifp = if_get_by_name_len_vrf (argv[0], sl, vrf_id);</a>
<a name="ln657">#endif /* SUNOS_5 */</a>
<a name="ln658"> </a>
<a name="ln659">  vty-&gt;index = ifp;</a>
<a name="ln660">  vty-&gt;node = INTERFACE_NODE;</a>
<a name="ln661"> </a>
<a name="ln662">  return CMD_SUCCESS;</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">ALIAS (interface,</a>
<a name="ln666">       interface_vrf_cmd,</a>
<a name="ln667">       &quot;interface IFNAME &quot; VRF_CMD_STR,</a>
<a name="ln668">       &quot;Select an interface to configure\n&quot;</a>
<a name="ln669">       &quot;Interface's name\n&quot;</a>
<a name="ln670">       VRF_CMD_HELP_STR)</a>
<a name="ln671"> </a>
<a name="ln672">DEFUN_NOSH (no_interface,</a>
<a name="ln673">           no_interface_cmd,</a>
<a name="ln674">           &quot;no interface IFNAME&quot;,</a>
<a name="ln675">           NO_STR</a>
<a name="ln676">           &quot;Delete a pseudo interface's configuration\n&quot;</a>
<a name="ln677">           &quot;Interface's name\n&quot;)</a>
<a name="ln678">{</a>
<a name="ln679">  // deleting interface</a>
<a name="ln680">  struct interface *ifp;</a>
<a name="ln681">  vrf_id_t vrf_id = VRF_DEFAULT;</a>
<a name="ln682"> </a>
<a name="ln683">  if (argc &gt; 1)</a>
<a name="ln684">    VTY_GET_INTEGER (&quot;VRF ID&quot;, vrf_id, argv[1]);</a>
<a name="ln685"> </a>
<a name="ln686">  ifp = if_lookup_by_name_vrf (argv[0], vrf_id);</a>
<a name="ln687"> </a>
<a name="ln688">  if (ifp == NULL)</a>
<a name="ln689">    {</a>
<a name="ln690">      vty_out (vty, &quot;%% Interface %s does not exist%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln691">      return CMD_WARNING;</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">  if (CHECK_FLAG (ifp-&gt;status, ZEBRA_INTERFACE_ACTIVE)) </a>
<a name="ln695">    {</a>
<a name="ln696">      vty_out (vty, &quot;%% Only inactive interfaces can be deleted%s&quot;,</a>
<a name="ln697">	      VTY_NEWLINE);</a>
<a name="ln698">      return CMD_WARNING;</a>
<a name="ln699">    }</a>
<a name="ln700"> </a>
<a name="ln701">  if_delete(ifp);</a>
<a name="ln702"> </a>
<a name="ln703">  return CMD_SUCCESS;</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">ALIAS (no_interface,</a>
<a name="ln707">       no_interface_vrf_cmd,</a>
<a name="ln708">       &quot;no interface IFNAME &quot; VRF_CMD_STR,</a>
<a name="ln709">       NO_STR</a>
<a name="ln710">       &quot;Delete a pseudo interface's configuration\n&quot;</a>
<a name="ln711">       &quot;Interface's name\n&quot;</a>
<a name="ln712">       VRF_CMD_HELP_STR)</a>
<a name="ln713"> </a>
<a name="ln714">/* For debug purpose. */</a>
<a name="ln715">DEFUN (show_address,</a>
<a name="ln716">       show_address_cmd,</a>
<a name="ln717">       &quot;show address&quot;,</a>
<a name="ln718">       SHOW_STR</a>
<a name="ln719">       &quot;address\n&quot;)</a>
<a name="ln720">{</a>
<a name="ln721">  struct listnode *node;</a>
<a name="ln722">  struct listnode *node2;</a>
<a name="ln723">  struct interface *ifp;</a>
<a name="ln724">  struct connected *ifc;</a>
<a name="ln725">  struct prefix *p;</a>
<a name="ln726">  vrf_id_t vrf_id = VRF_DEFAULT;</a>
<a name="ln727"> </a>
<a name="ln728">  if (argc &gt; 0)</a>
<a name="ln729">    VTY_GET_INTEGER (&quot;VRF ID&quot;, vrf_id, argv[0]);</a>
<a name="ln730"> </a>
<a name="ln731">  for (ALL_LIST_ELEMENTS_RO (vrf_iflist (vrf_id), node, ifp))</a>
<a name="ln732">    {</a>
<a name="ln733">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, node2, ifc))</a>
<a name="ln734">	{</a>
<a name="ln735">	  p = ifc-&gt;address;</a>
<a name="ln736"> </a>
<a name="ln737">	  if (p-&gt;family == AF_INET)</a>
<a name="ln738">	    vty_out (vty, &quot;%s/%d%s&quot;, inet_ntoa (p-&gt;u.prefix4), p-&gt;prefixlen,</a>
<a name="ln739">		     VTY_NEWLINE);</a>
<a name="ln740">	}</a>
<a name="ln741">    }</a>
<a name="ln742">  return CMD_SUCCESS;</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">ALIAS (show_address,</a>
<a name="ln746">       show_address_vrf_cmd,</a>
<a name="ln747">       &quot;show address &quot; VRF_CMD_STR,</a>
<a name="ln748">       SHOW_STR</a>
<a name="ln749">       &quot;address\n&quot;</a>
<a name="ln750">       VRF_CMD_HELP_STR)</a>
<a name="ln751"> </a>
<a name="ln752">DEFUN (show_address_vrf_all,</a>
<a name="ln753">       show_address_vrf_all_cmd,</a>
<a name="ln754">       &quot;show address &quot; VRF_ALL_CMD_STR,</a>
<a name="ln755">       SHOW_STR</a>
<a name="ln756">       &quot;address\n&quot;</a>
<a name="ln757">       VRF_ALL_CMD_HELP_STR)</a>
<a name="ln758">{</a>
<a name="ln759">  struct list *intf_list;</a>
<a name="ln760">  struct listnode *node;</a>
<a name="ln761">  struct listnode *node2;</a>
<a name="ln762">  struct interface *ifp;</a>
<a name="ln763">  struct connected *ifc;</a>
<a name="ln764">  struct prefix *p;</a>
<a name="ln765">  vrf_iter_t iter;</a>
<a name="ln766"> </a>
<a name="ln767">  for (iter = vrf_first (); iter != VRF_ITER_INVALID; iter = vrf_next (iter))</a>
<a name="ln768">    {</a>
<a name="ln769">      intf_list = vrf_iter2iflist (iter);</a>
<a name="ln770">      if (!intf_list || !listcount (intf_list))</a>
<a name="ln771">        continue;</a>
<a name="ln772"> </a>
<a name="ln773">      vty_out (vty, &quot;%sVRF %u%s%s&quot;, VTY_NEWLINE, vrf_iter2id (iter),</a>
<a name="ln774">               VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln775"> </a>
<a name="ln776">      for (ALL_LIST_ELEMENTS_RO (intf_list, node, ifp))</a>
<a name="ln777">        {</a>
<a name="ln778">          for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, node2, ifc))</a>
<a name="ln779">            {</a>
<a name="ln780">              p = ifc-&gt;address;</a>
<a name="ln781"> </a>
<a name="ln782">              if (p-&gt;family == AF_INET)</a>
<a name="ln783">                vty_out (vty, &quot;%s/%d%s&quot;, inet_ntoa (p-&gt;u.prefix4), p-&gt;prefixlen,</a>
<a name="ln784">                         VTY_NEWLINE);</a>
<a name="ln785">            }</a>
<a name="ln786">        }</a>
<a name="ln787">    }</a>
<a name="ln788">  return CMD_SUCCESS;</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">/* Allocate connected structure. */</a>
<a name="ln792">struct connected *</a>
<a name="ln793">connected_new (void)</a>
<a name="ln794">{</a>
<a name="ln795">  return XCALLOC (MTYPE_CONNECTED, sizeof (struct connected));</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">/* Free connected structure. */</a>
<a name="ln799">void</a>
<a name="ln800">connected_free (struct connected *connected)</a>
<a name="ln801">{</a>
<a name="ln802">  if (connected-&gt;address)</a>
<a name="ln803">    prefix_free (connected-&gt;address);</a>
<a name="ln804"> </a>
<a name="ln805">  if (connected-&gt;destination)</a>
<a name="ln806">    prefix_free (connected-&gt;destination);</a>
<a name="ln807"> </a>
<a name="ln808">  if (connected-&gt;label)</a>
<a name="ln809">    XFREE (MTYPE_CONNECTED_LABEL, connected-&gt;label);</a>
<a name="ln810"> </a>
<a name="ln811">  XFREE (MTYPE_CONNECTED, connected);</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814">/* Print if_addr structure. */</a>
<a name="ln815">static void __attribute__ ((unused))</a>
<a name="ln816">connected_log (struct connected *connected, char *str)</a>
<a name="ln817">{</a>
<a name="ln818">  struct prefix *p;</a>
<a name="ln819">  struct interface *ifp;</a>
<a name="ln820">  char logbuf[BUFSIZ];</a>
<a name="ln821">  char buf[BUFSIZ];</a>
<a name="ln822">  </a>
<a name="ln823">  ifp = connected-&gt;ifp;</a>
<a name="ln824">  p = connected-&gt;address;</a>
<a name="ln825"> </a>
<a name="ln826">  snprintf (logbuf, BUFSIZ, &quot;%s interface %s vrf %u %s %s/%d &quot;,</a>
<a name="ln827">	    str, ifp-&gt;name, ifp-&gt;vrf_id, prefix_family_str (p),</a>
<a name="ln828">	    inet_ntop (p-&gt;family, &amp;p-&gt;u.prefix, buf, BUFSIZ),</a>
<a name="ln829">	    p-&gt;prefixlen);</a>
<a name="ln830"> </a>
<a name="ln831">  p = connected-&gt;destination;</a>
<a name="ln832">  if (p)</a>
<a name="ln833">    {</a>
<a name="ln834">      strncat (logbuf, inet_ntop (p-&gt;family, &amp;p-&gt;u.prefix, buf, BUFSIZ),</a>
<a name="ln835">	       BUFSIZ - strlen(logbuf));</a>
<a name="ln836">    }</a>
<a name="ln837">  zlog (NULL, LOG_INFO, &quot;%s&quot;, logbuf);</a>
<a name="ln838">}</a>
<a name="ln839"> </a>
<a name="ln840">/* If two connected address has same prefix return 1. */</a>
<a name="ln841">static int</a>
<a name="ln842">connected_same_prefix (struct prefix *p1, struct prefix *p2)</a>
<a name="ln843">{</a>
<a name="ln844">  if (p1-&gt;family == p2-&gt;family)</a>
<a name="ln845">    {</a>
<a name="ln846">      if (p1-&gt;family == AF_INET &amp;&amp;</a>
<a name="ln847">	  IPV4_ADDR_SAME (&amp;p1-&gt;u.prefix4, &amp;p2-&gt;u.prefix4))</a>
<a name="ln848">	return 1;</a>
<a name="ln849">#ifdef HAVE_IPV6</a>
<a name="ln850">      if (p1-&gt;family == AF_INET6 &amp;&amp;</a>
<a name="ln851">	  IPV6_ADDR_SAME (&amp;p1-&gt;u.prefix6, &amp;p2-&gt;u.prefix6))</a>
<a name="ln852">	return 1;</a>
<a name="ln853">#endif /* HAVE_IPV6 */</a>
<a name="ln854">    }</a>
<a name="ln855">  return 0;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">struct connected *</a>
<a name="ln859">connected_delete_by_prefix (struct interface *ifp, struct prefix *p)</a>
<a name="ln860">{</a>
<a name="ln861">  struct listnode *node;</a>
<a name="ln862">  struct listnode *next;</a>
<a name="ln863">  struct connected *ifc;</a>
<a name="ln864"> </a>
<a name="ln865">  /* In case of same prefix come, replace it with new one. */</a>
<a name="ln866">  for (node = listhead (ifp-&gt;connected); node; node = next)</a>
<a name="ln867">    {</a>
<a name="ln868">      ifc = listgetdata (node);</a>
<a name="ln869">      next = node-&gt;next;</a>
<a name="ln870"> </a>
<a name="ln871">      if (connected_same_prefix (ifc-&gt;address, p))</a>
<a name="ln872">	{</a>
<a name="ln873">	  listnode_delete (ifp-&gt;connected, ifc);</a>
<a name="ln874">	  return ifc;</a>
<a name="ln875">	}</a>
<a name="ln876">    }</a>
<a name="ln877">  return NULL;</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">/* Find the IPv4 address on our side that will be used when packets</a>
<a name="ln881">   are sent to dst. */</a>
<a name="ln882">struct connected *</a>
<a name="ln883">connected_lookup_address (struct interface *ifp, struct in_addr dst)</a>
<a name="ln884">{</a>
<a name="ln885">  struct prefix addr;</a>
<a name="ln886">  struct listnode *cnode;</a>
<a name="ln887">  struct connected *c;</a>
<a name="ln888">  struct connected *match;</a>
<a name="ln889"> </a>
<a name="ln890">  addr.family = AF_INET;</a>
<a name="ln891">  addr.u.prefix4 = dst;</a>
<a name="ln892">  addr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln893"> </a>
<a name="ln894">  match = NULL;</a>
<a name="ln895"> </a>
<a name="ln896">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, c))</a>
<a name="ln897">    {</a>
<a name="ln898">      if (c-&gt;address &amp;&amp; (c-&gt;address-&gt;family == AF_INET) &amp;&amp;</a>
<a name="ln899">	  prefix_match(CONNECTED_PREFIX(c), &amp;addr) &amp;&amp;</a>
<a name="ln900">	  (!match || (c-&gt;address-&gt;prefixlen &gt; match-&gt;address-&gt;prefixlen)))</a>
<a name="ln901">	match = c;</a>
<a name="ln902">    }</a>
<a name="ln903">  return match;</a>
<a name="ln904">}</a>
<a name="ln905"> </a>
<a name="ln906">struct connected *</a>
<a name="ln907">connected_add_by_prefix (struct interface *ifp, struct prefix *p, </a>
<a name="ln908">                         struct prefix *destination)</a>
<a name="ln909">{</a>
<a name="ln910">  struct connected *ifc;</a>
<a name="ln911"> </a>
<a name="ln912">  /* Allocate new connected address. */</a>
<a name="ln913">  ifc = connected_new ();</a>
<a name="ln914">  ifc-&gt;ifp = ifp;</a>
<a name="ln915"> </a>
<a name="ln916">  /* Fetch interface address */</a>
<a name="ln917">  ifc-&gt;address = prefix_new();</a>
<a name="ln918">  memcpy (ifc-&gt;address, p, sizeof(struct prefix));</a>
<a name="ln919"> </a>
<a name="ln920">  /* Fetch dest address */</a>
<a name="ln921">  if (destination)</a>
<a name="ln922">    {</a>
<a name="ln923">      ifc-&gt;destination = prefix_new();</a>
<a name="ln924">      memcpy (ifc-&gt;destination, destination, sizeof(struct prefix));</a>
<a name="ln925">    }</a>
<a name="ln926"> </a>
<a name="ln927">  /* Add connected address to the interface. */</a>
<a name="ln928">  listnode_add (ifp-&gt;connected, ifc);</a>
<a name="ln929">  return ifc;</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">#ifndef HAVE_IF_NAMETOINDEX</a>
<a name="ln933">ifindex_t</a>
<a name="ln934">if_nametoindex (const char *name)</a>
<a name="ln935">{</a>
<a name="ln936">  struct interface *ifp;</a>
<a name="ln937"> </a>
<a name="ln938">  return ((ifp = if_lookup_by_name_len(name, strnlen(name, IFNAMSIZ))) != NULL)</a>
<a name="ln939">  	 ? ifp-&gt;ifindex : 0;</a>
<a name="ln940">}</a>
<a name="ln941">#endif</a>
<a name="ln942"> </a>
<a name="ln943">#ifndef HAVE_IF_INDEXTONAME</a>
<a name="ln944">char *</a>
<a name="ln945">if_indextoname (ifindex_t ifindex, char *name)</a>
<a name="ln946">{</a>
<a name="ln947">  struct interface *ifp;</a>
<a name="ln948"> </a>
<a name="ln949">  if (!(ifp = if_lookup_by_index(ifindex)))</a>
<a name="ln950">    return NULL;</a>
<a name="ln951">  strncpy (name, ifp-&gt;name, IFNAMSIZ);</a>
<a name="ln952">  return ifp-&gt;name;</a>
<a name="ln953">}</a>
<a name="ln954">#endif</a>
<a name="ln955"> </a>
<a name="ln956">#if 0 /* this route_table of struct connected's is unused</a>
<a name="ln957">       * however, it would be good to use a route_table rather than</a>
<a name="ln958">       * a list..</a>
<a name="ln959">       */</a>
<a name="ln960">/* Interface looking up by interface's address. */</a>
<a name="ln961">/* Interface's IPv4 address reverse lookup table. */</a>
<a name="ln962">struct route_table *ifaddr_ipv4_table;</a>
<a name="ln963">/* struct route_table *ifaddr_ipv6_table; */</a>
<a name="ln964"> </a>
<a name="ln965">static void</a>
<a name="ln966">ifaddr_ipv4_add (struct in_addr *ifaddr, struct interface *ifp)</a>
<a name="ln967">{</a>
<a name="ln968">  struct route_node *rn;</a>
<a name="ln969">  struct prefix_ipv4 p;</a>
<a name="ln970"> </a>
<a name="ln971">  p.family = AF_INET;</a>
<a name="ln972">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln973">  p.prefix = *ifaddr;</a>
<a name="ln974"> </a>
<a name="ln975">  rn = route_node_get (ifaddr_ipv4_table, (struct prefix *) &amp;p);</a>
<a name="ln976">  if (rn)</a>
<a name="ln977">    {</a>
<a name="ln978">      route_unlock_node (rn);</a>
<a name="ln979">      zlog_info (&quot;ifaddr_ipv4_add(): address %s is already added&quot;,</a>
<a name="ln980">		 inet_ntoa (*ifaddr));</a>
<a name="ln981">      return;</a>
<a name="ln982">    }</a>
<a name="ln983">  rn-&gt;info = ifp;</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">static void</a>
<a name="ln987">ifaddr_ipv4_delete (struct in_addr *ifaddr, struct interface *ifp)</a>
<a name="ln988">{</a>
<a name="ln989">  struct route_node *rn;</a>
<a name="ln990">  struct prefix_ipv4 p;</a>
<a name="ln991"> </a>
<a name="ln992">  p.family = AF_INET;</a>
<a name="ln993">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln994">  p.prefix = *ifaddr;</a>
<a name="ln995"> </a>
<a name="ln996">  rn = route_node_lookup (ifaddr_ipv4_table, (struct prefix *) &amp;p);</a>
<a name="ln997">  if (! rn)</a>
<a name="ln998">    {</a>
<a name="ln999">      zlog_info (&quot;ifaddr_ipv4_delete(): can't find address %s&quot;,</a>
<a name="ln1000">		 inet_ntoa (*ifaddr));</a>
<a name="ln1001">      return;</a>
<a name="ln1002">    }</a>
<a name="ln1003">  rn-&gt;info = NULL;</a>
<a name="ln1004">  route_unlock_node (rn);</a>
<a name="ln1005">  route_unlock_node (rn);</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">/* Lookup interface by interface's IP address or interface index. */</a>
<a name="ln1009">static struct interface *</a>
<a name="ln1010">ifaddr_ipv4_lookup (struct in_addr *addr, ifindex_t ifindex)</a>
<a name="ln1011">{</a>
<a name="ln1012">  struct prefix_ipv4 p;</a>
<a name="ln1013">  struct route_node *rn;</a>
<a name="ln1014">  struct interface *ifp;</a>
<a name="ln1015"> </a>
<a name="ln1016">  if (addr)</a>
<a name="ln1017">    {</a>
<a name="ln1018">      p.family = AF_INET;</a>
<a name="ln1019">      p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln1020">      p.prefix = *addr;</a>
<a name="ln1021"> </a>
<a name="ln1022">      rn = route_node_lookup (ifaddr_ipv4_table, (struct prefix *) &amp;p);</a>
<a name="ln1023">      if (! rn)</a>
<a name="ln1024">	return NULL;</a>
<a name="ln1025">      </a>
<a name="ln1026">      ifp = rn-&gt;info;</a>
<a name="ln1027">      route_unlock_node (rn);</a>
<a name="ln1028">      return ifp;</a>
<a name="ln1029">    }</a>
<a name="ln1030">  else</a>
<a name="ln1031">    return if_lookup_by_index(ifindex);</a>
<a name="ln1032">}</a>
<a name="ln1033">#endif /* ifaddr_ipv4_table */</a>
<a name="ln1034"> </a>
<a name="ln1035">/* Initialize interface list. */</a>
<a name="ln1036">void</a>
<a name="ln1037">if_init (vrf_id_t vrf_id, struct list **intf_list)</a>
<a name="ln1038">{</a>
<a name="ln1039">  *intf_list = list_new ();</a>
<a name="ln1040">#if 0</a>
<a name="ln1041">  ifaddr_ipv4_table = route_table_init ();</a>
<a name="ln1042">#endif /* ifaddr_ipv4_table */</a>
<a name="ln1043"> </a>
<a name="ln1044">  (*intf_list)-&gt;cmp = (int (*)(void *, void *))if_cmp_func;</a>
<a name="ln1045"> </a>
<a name="ln1046">  if (vrf_id == VRF_DEFAULT)</a>
<a name="ln1047">    iflist = *intf_list;</a>
<a name="ln1048">}</a>
<a name="ln1049"> </a>
<a name="ln1050">void</a>
<a name="ln1051">if_terminate (vrf_id_t vrf_id, struct list **intf_list)</a>
<a name="ln1052">{</a>
<a name="ln1053">  for (;;)</a>
<a name="ln1054">    {</a>
<a name="ln1055">      struct interface *ifp;</a>
<a name="ln1056"> </a>
<a name="ln1057">      ifp = listnode_head (*intf_list);</a>
<a name="ln1058">      if (ifp == NULL)</a>
<a name="ln1059">	break;</a>
<a name="ln1060"> </a>
<a name="ln1061">      if_delete (ifp);</a>
<a name="ln1062">    }</a>
<a name="ln1063"> </a>
<a name="ln1064">  list_delete (*intf_list);</a>
<a name="ln1065">  *intf_list = NULL;</a>
<a name="ln1066"> </a>
<a name="ln1067">  if (vrf_id == VRF_DEFAULT)</a>
<a name="ln1068">    iflist = NULL;</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">const char *</a>
<a name="ln1072">if_link_type_str (enum zebra_link_type llt)</a>
<a name="ln1073">{</a>
<a name="ln1074">  switch (llt)</a>
<a name="ln1075">    {</a>
<a name="ln1076">#define llts(T,S) case (T): return (S)</a>
<a name="ln1077">      llts(ZEBRA_LLT_UNKNOWN,               &quot;Unknown&quot;);</a>
<a name="ln1078">      llts(ZEBRA_LLT_ETHER,                 &quot;Ethernet&quot;);</a>
<a name="ln1079">      llts(ZEBRA_LLT_EETHER,                &quot;Experimental Ethernet&quot;);</a>
<a name="ln1080">      llts(ZEBRA_LLT_AX25,                  &quot;AX.25 Level 2&quot;);</a>
<a name="ln1081">      llts(ZEBRA_LLT_PRONET,                &quot;PROnet token ring&quot;);</a>
<a name="ln1082">      llts(ZEBRA_LLT_IEEE802,               &quot;IEEE 802.2 Ethernet/TR/TB&quot;);</a>
<a name="ln1083">      llts(ZEBRA_LLT_ARCNET,                &quot;ARCnet&quot;);</a>
<a name="ln1084">      llts(ZEBRA_LLT_APPLETLK,              &quot;AppleTalk&quot;);</a>
<a name="ln1085">      llts(ZEBRA_LLT_DLCI,                  &quot;Frame Relay DLCI&quot;);</a>
<a name="ln1086">      llts(ZEBRA_LLT_ATM,                   &quot;ATM&quot;);</a>
<a name="ln1087">      llts(ZEBRA_LLT_METRICOM,              &quot;Metricom STRIP&quot;);</a>
<a name="ln1088">      llts(ZEBRA_LLT_IEEE1394,              &quot;IEEE 1394 IPv4&quot;);</a>
<a name="ln1089">      llts(ZEBRA_LLT_EUI64,                 &quot;EUI-64&quot;);</a>
<a name="ln1090">      llts(ZEBRA_LLT_INFINIBAND,            &quot;InfiniBand&quot;);</a>
<a name="ln1091">      llts(ZEBRA_LLT_SLIP,                  &quot;SLIP&quot;);</a>
<a name="ln1092">      llts(ZEBRA_LLT_CSLIP,                 &quot;Compressed SLIP&quot;);</a>
<a name="ln1093">      llts(ZEBRA_LLT_SLIP6,                 &quot;SLIPv6&quot;);</a>
<a name="ln1094">      llts(ZEBRA_LLT_CSLIP6,                &quot;Compressed SLIPv6&quot;);</a>
<a name="ln1095">      llts(ZEBRA_LLT_ROSE,                  &quot;ROSE packet radio&quot;);</a>
<a name="ln1096">      llts(ZEBRA_LLT_X25,                   &quot;CCITT X.25&quot;);</a>
<a name="ln1097">      llts(ZEBRA_LLT_PPP,                   &quot;PPP&quot;);</a>
<a name="ln1098">      llts(ZEBRA_LLT_CHDLC,                 &quot;Cisco HDLC&quot;);</a>
<a name="ln1099">      llts(ZEBRA_LLT_RAWHDLC,               &quot;Raw HDLC&quot;);</a>
<a name="ln1100">      llts(ZEBRA_LLT_LAPB,                  &quot;LAPB&quot;);</a>
<a name="ln1101">      llts(ZEBRA_LLT_IPIP,                  &quot;IPIP Tunnel&quot;);</a>
<a name="ln1102">      llts(ZEBRA_LLT_IPIP6,                 &quot;IPIP6 Tunnel&quot;);</a>
<a name="ln1103">      llts(ZEBRA_LLT_FRAD,                  &quot;FRAD&quot;);</a>
<a name="ln1104">      llts(ZEBRA_LLT_SKIP,                  &quot;SKIP vif&quot;);</a>
<a name="ln1105">      llts(ZEBRA_LLT_LOOPBACK,              &quot;Loopback&quot;);</a>
<a name="ln1106">      llts(ZEBRA_LLT_LOCALTLK,              &quot;Localtalk&quot;);</a>
<a name="ln1107">      llts(ZEBRA_LLT_FDDI,                  &quot;FDDI&quot;);</a>
<a name="ln1108">      llts(ZEBRA_LLT_SIT,                   &quot;IPv6-in-IPv4 SIT&quot;);</a>
<a name="ln1109">      llts(ZEBRA_LLT_IPDDP,                 &quot;IP-in-DDP tunnel&quot;);</a>
<a name="ln1110">      llts(ZEBRA_LLT_IPGRE,                 &quot;GRE over IP&quot;);</a>
<a name="ln1111">      llts(ZEBRA_LLT_PIMREG,                &quot;PIMSM registration&quot;);</a>
<a name="ln1112">      llts(ZEBRA_LLT_HIPPI,                 &quot;HiPPI&quot;);</a>
<a name="ln1113">      llts(ZEBRA_LLT_IRDA,                  &quot;IrDA&quot;);</a>
<a name="ln1114">      llts(ZEBRA_LLT_FCPP,                  &quot;Fibre-Channel PtP&quot;);</a>
<a name="ln1115">      llts(ZEBRA_LLT_FCAL,                  &quot;Fibre-Channel Arbitrated Loop&quot;);</a>
<a name="ln1116">      llts(ZEBRA_LLT_FCPL,                  &quot;Fibre-Channel Public Loop&quot;);</a>
<a name="ln1117">      llts(ZEBRA_LLT_FCFABRIC,              &quot;Fibre-Channel Fabric&quot;);</a>
<a name="ln1118">      llts(ZEBRA_LLT_IEEE802_TR,            &quot;IEEE 802.2 Token Ring&quot;);</a>
<a name="ln1119">      llts(ZEBRA_LLT_IEEE80211,             &quot;IEEE 802.11&quot;);</a>
<a name="ln1120">      llts(ZEBRA_LLT_IEEE80211_RADIOTAP,    &quot;IEEE 802.11 Radiotap&quot;);</a>
<a name="ln1121">      llts(ZEBRA_LLT_IEEE802154,            &quot;IEEE 802.15.4&quot;);</a>
<a name="ln1122">      llts(ZEBRA_LLT_IEEE802154_PHY,        &quot;IEEE 802.15.4 Phy&quot;);</a>
<a name="ln1123">      default:</a>
<a name="ln1124">        zlog_warn (&quot;Unknown value %d&quot;, llt);</a>
<a name="ln1125">        return &quot;Unknown type!&quot;;</a>
<a name="ln1126">#undef llts</a>
<a name="ln1127">    }</a>
<a name="ln1128">  return NULL;</a>
<a name="ln1129">}</a>
<a name="ln1130"> </a>
<a name="ln1131">struct if_link_params *</a>
<a name="ln1132">if_link_params_get (struct interface *ifp)</a>
<a name="ln1133">{</a>
<a name="ln1134">  int i;</a>
<a name="ln1135">  </a>
<a name="ln1136">  if (ifp-&gt;link_params != NULL)</a>
<a name="ln1137">    return ifp-&gt;link_params;</a>
<a name="ln1138">  </a>
<a name="ln1139">  struct if_link_params *iflp = XCALLOC(MTYPE_IF_LINK_PARAMS,</a>
<a name="ln1140">                                      sizeof (struct if_link_params));</a>
<a name="ln1141">  if (iflp == NULL) return NULL;</a>
<a name="ln1142">  </a>
<a name="ln1143">  /* Set TE metric == standard metric */</a>
<a name="ln1144">  iflp-&gt;te_metric = ifp-&gt;metric;</a>
<a name="ln1145"> </a>
<a name="ln1146">  /* Compute default bandwidth based on interface */</a>
<a name="ln1147">  int bw = (float)((ifp-&gt;bandwidth ? ifp-&gt;bandwidth : DEFAULT_BANDWIDTH) </a>
<a name="ln1148">                   * TE_KILO_BIT / TE_BYTE);</a>
<a name="ln1149">  </a>
<a name="ln1150">  /* Set Max, Reservable and Unreserved Bandwidth */</a>
<a name="ln1151">  iflp-&gt;max_bw = bw;</a>
<a name="ln1152">  iflp-&gt;max_rsv_bw = bw;</a>
<a name="ln1153">  for (i = 0; i &lt; MAX_CLASS_TYPE; i++)</a>
<a name="ln1154">    iflp-&gt;unrsv_bw[i] = bw;</a>
<a name="ln1155">  </a>
<a name="ln1156">  /* Update Link parameters status */</a>
<a name="ln1157">  iflp-&gt;lp_status = LP_TE | LP_MAX_BW | LP_MAX_RSV_BW | LP_UNRSV_BW;</a>
<a name="ln1158"> </a>
<a name="ln1159">  /* Finally attach newly created Link Parameters */</a>
<a name="ln1160">  ifp-&gt;link_params = iflp;</a>
<a name="ln1161"> </a>
<a name="ln1162">  return iflp;</a>
<a name="ln1163">}</a>
<a name="ln1164"> </a>
<a name="ln1165">void</a>
<a name="ln1166">if_link_params_free (struct interface *ifp)</a>
<a name="ln1167">{</a>
<a name="ln1168">  if (ifp-&gt;link_params == NULL) return;</a>
<a name="ln1169">  XFREE(MTYPE_IF_LINK_PARAMS, ifp-&gt;link_params);</a>
<a name="ln1170">  ifp-&gt;link_params = NULL;</a>
<a name="ln1171">}</a>

</code></pre>
<div class="balloon" rel="9"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="834"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v645/" target="_blank">V645</a> The 'strncat' function call could lead to the 'logbuf' buffer overflow. The bounds should not contain the size of the buffer, but a number of characters it can hold.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
