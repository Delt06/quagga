
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>md5.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* $USAGI: md5.c,v 1.2 2000/11/02 11:59:24 yoshfuji Exp $ */</a>
<a name="ln2">/*	$KAME: md5.c,v 1.2 2000/05/27 07:07:48 jinmei Exp $	*/</a>
<a name="ln3">/*	$Id: md5.c,v 1.6 2006/01/17 23:39:04 vincent Exp $ */</a>
<a name="ln4"> </a>
<a name="ln5">/*</a>
<a name="ln6"> * Copyright (C) 2004 6WIND</a>
<a name="ln7"> *                          &lt;Vincent.Jardin@6WIND.com&gt;</a>
<a name="ln8"> * All rights reserved.</a>
<a name="ln9"> *</a>
<a name="ln10"> * This MD5 code is Big endian and Little Endian compatible.</a>
<a name="ln11"> */</a>
<a name="ln12"> </a>
<a name="ln13">/*</a>
<a name="ln14"> * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.</a>
<a name="ln15"> * All rights reserved.</a>
<a name="ln16"> *</a>
<a name="ln17"> * Redistribution and use in source and binary forms, with or without</a>
<a name="ln18"> * modification, are permitted provided that the following conditions</a>
<a name="ln19"> * are met:</a>
<a name="ln20"> * 1. Redistributions of source code must retain the above copyright</a>
<a name="ln21"> *    notice, this list of conditions and the following disclaimer.</a>
<a name="ln22"> * 2. Redistributions in binary form must reproduce the above copyright</a>
<a name="ln23"> *    notice, this list of conditions and the following disclaimer in the</a>
<a name="ln24"> *    documentation and/or other materials provided with the distribution.</a>
<a name="ln25"> * 3. Neither the name of the project nor the names of its contributors</a>
<a name="ln26"> *    may be used to endorse or promote products derived from this software</a>
<a name="ln27"> *    without specific prior written permission.</a>
<a name="ln28"> *</a>
<a name="ln29"> * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND</a>
<a name="ln30"> * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</a>
<a name="ln31"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</a>
<a name="ln32"> * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE</a>
<a name="ln33"> * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</a>
<a name="ln34"> * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS</a>
<a name="ln35"> * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)</a>
<a name="ln36"> * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT</a>
<a name="ln37"> * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY</a>
<a name="ln38"> * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</a>
<a name="ln39"> * SUCH DAMAGE.</a>
<a name="ln40"> */</a>
<a name="ln41"> </a>
<a name="ln42">#include &lt;zebra.h&gt;</a>
<a name="ln43">#include &quot;md5.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">#define SHIFT(X, s) (((X) &lt;&lt; (s)) | ((X) &gt;&gt; (32 - (s))))</a>
<a name="ln46"> </a>
<a name="ln47">#define F(X, Y, Z) (((X) &amp; (Y)) | ((~X) &amp; (Z)))</a>
<a name="ln48">#define G(X, Y, Z) (((X) &amp; (Z)) | ((Y) &amp; (~Z)))</a>
<a name="ln49">#define H(X, Y, Z) ((X) ^ (Y) ^ (Z))</a>
<a name="ln50">#define I(X, Y, Z) ((Y) ^ ((X) | (~Z)))</a>
<a name="ln51"> </a>
<a name="ln52">#define ROUND1(a, b, c, d, k, s, i) { \</a>
<a name="ln53">	(a) = (a) + F((b), (c), (d)) + X[(k)] + T[(i)]; \</a>
<a name="ln54">	(a) = SHIFT((a), (s)); \</a>
<a name="ln55">	(a) = (b) + (a); \</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">#define ROUND2(a, b, c, d, k, s, i) { \</a>
<a name="ln59">	(a) = (a) + G((b), (c), (d)) + X[(k)] + T[(i)]; \</a>
<a name="ln60">	(a) = SHIFT((a), (s)); \</a>
<a name="ln61">	(a) = (b) + (a); \</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">#define ROUND3(a, b, c, d, k, s, i) { \</a>
<a name="ln65">	(a) = (a) + H((b), (c), (d)) + X[(k)] + T[(i)]; \</a>
<a name="ln66">	(a) = SHIFT((a), (s)); \</a>
<a name="ln67">	(a) = (b) + (a); \</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70">#define ROUND4(a, b, c, d, k, s, i) { \</a>
<a name="ln71">	(a) = (a) + I((b), (c), (d)) + X[(k)] + T[(i)]; \</a>
<a name="ln72">	(a) = SHIFT((a), (s)); \</a>
<a name="ln73">	(a) = (b) + (a); \</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">#define Sa	 7</a>
<a name="ln77">#define Sb	12</a>
<a name="ln78">#define Sc	17</a>
<a name="ln79">#define Sd	22</a>
<a name="ln80"> </a>
<a name="ln81">#define Se	 5</a>
<a name="ln82">#define Sf	 9</a>
<a name="ln83">#define Sg	14</a>
<a name="ln84">#define Sh	20</a>
<a name="ln85"> </a>
<a name="ln86">#define Si	 4</a>
<a name="ln87">#define Sj	11</a>
<a name="ln88">#define Sk	16</a>
<a name="ln89">#define Sl	23</a>
<a name="ln90"> </a>
<a name="ln91">#define Sm	 6</a>
<a name="ln92">#define Sn	10</a>
<a name="ln93">#define So	15</a>
<a name="ln94">#define Sp	21</a>
<a name="ln95"> </a>
<a name="ln96">#define MD5_A0	0x67452301</a>
<a name="ln97">#define MD5_B0	0xefcdab89</a>
<a name="ln98">#define MD5_C0	0x98badcfe</a>
<a name="ln99">#define MD5_D0	0x10325476</a>
<a name="ln100"> </a>
<a name="ln101">/* Integer part of 4294967296 times abs(sin(i)), where i is in radians. */</a>
<a name="ln102">static const uint32_t T[65] = {</a>
<a name="ln103">	0,</a>
<a name="ln104">	0xd76aa478, 	0xe8c7b756,	0x242070db,	0xc1bdceee,</a>
<a name="ln105">	0xf57c0faf,	0x4787c62a, 	0xa8304613,	0xfd469501,</a>
<a name="ln106">	0x698098d8,	0x8b44f7af,	0xffff5bb1,	0x895cd7be,</a>
<a name="ln107">	0x6b901122, 	0xfd987193, 	0xa679438e,	0x49b40821,</a>
<a name="ln108"> </a>
<a name="ln109">	0xf61e2562,	0xc040b340, 	0x265e5a51, 	0xe9b6c7aa,</a>
<a name="ln110">	0xd62f105d,	0x2441453,	0xd8a1e681,	0xe7d3fbc8,</a>
<a name="ln111">	0x21e1cde6,	0xc33707d6, 	0xf4d50d87, 	0x455a14ed,</a>
<a name="ln112">	0xa9e3e905,	0xfcefa3f8, 	0x676f02d9, 	0x8d2a4c8a,</a>
<a name="ln113"> </a>
<a name="ln114">	0xfffa3942,	0x8771f681, 	0x6d9d6122, 	0xfde5380c,</a>
<a name="ln115">	0xa4beea44, 	0x4bdecfa9, 	0xf6bb4b60, 	0xbebfbc70,</a>
<a name="ln116">	0x289b7ec6, 	0xeaa127fa, 	0xd4ef3085,	0x4881d05,</a>
<a name="ln117">	0xd9d4d039, 	0xe6db99e5, 	0x1fa27cf8, 	0xc4ac5665,</a>
<a name="ln118"> </a>
<a name="ln119">	0xf4292244, 	0x432aff97, 	0xab9423a7, 	0xfc93a039,</a>
<a name="ln120">	0x655b59c3, 	0x8f0ccc92, 	0xffeff47d, 	0x85845dd1,</a>
<a name="ln121">	0x6fa87e4f, 	0xfe2ce6e0, 	0xa3014314, 	0x4e0811a1,</a>
<a name="ln122">	0xf7537e82, 	0xbd3af235, 	0x2ad7d2bb, 	0xeb86d391,</a>
<a name="ln123">};</a>
<a name="ln124"> </a>
<a name="ln125">static const uint8_t md5_paddat[MD5_BUFLEN] = {</a>
<a name="ln126">	0x80,	0,	0,	0,	0,	0,	0,	0,</a>
<a name="ln127">	0,	0,	0,	0,	0,	0,	0,	0,</a>
<a name="ln128">	0,	0,	0,	0,	0,	0,	0,	0,</a>
<a name="ln129">	0,	0,	0,	0,	0,	0,	0,	0,</a>
<a name="ln130">	0,	0,	0,	0,	0,	0,	0,	0,</a>
<a name="ln131">	0,	0,	0,	0,	0,	0,	0,	0,</a>
<a name="ln132">	0,	0,	0,	0,	0,	0,	0,	0,</a>
<a name="ln133">	0,	0,	0,	0,	0,	0,	0,	0,	</a>
<a name="ln134">};</a>
<a name="ln135"> </a>
<a name="ln136">static void md5_calc (const uint8_t *, md5_ctxt *);</a>
<a name="ln137"> </a>
<a name="ln138">void md5_init(md5_ctxt *ctxt)</a>
<a name="ln139">{</a>
<a name="ln140">	ctxt-&gt;md5_n = 0;</a>
<a name="ln141">	ctxt-&gt;md5_i = 0;</a>
<a name="ln142">	ctxt-&gt;md5_sta = MD5_A0;</a>
<a name="ln143">	ctxt-&gt;md5_stb = MD5_B0;</a>
<a name="ln144">	ctxt-&gt;md5_stc = MD5_C0;</a>
<a name="ln145">	ctxt-&gt;md5_std = MD5_D0;</a>
<a name="ln146">	memset (ctxt-&gt;md5_buf, 0, sizeof(ctxt-&gt;md5_buf));</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">void md5_loop(md5_ctxt *ctxt, const void *vinput, uint len)</a>
<a name="ln150">{</a>
<a name="ln151">	uint gap, i;</a>
<a name="ln152">	const uint8_t *input = vinput;</a>
<a name="ln153"> </a>
<a name="ln154">	ctxt-&gt;md5_n += len * 8; /* byte to bit */</a>
<a name="ln155">	gap = MD5_BUFLEN - ctxt-&gt;md5_i;</a>
<a name="ln156"> </a>
<a name="ln157">	if (len &gt;= gap) {</a>
<a name="ln158">		memcpy (ctxt-&gt;md5_buf + ctxt-&gt;md5_i, input, gap);</a>
<a name="ln159">		md5_calc(ctxt-&gt;md5_buf, ctxt);</a>
<a name="ln160"> </a>
<a name="ln161">		for (i = gap; i + MD5_BUFLEN &lt;= len; i += MD5_BUFLEN) {</a>
<a name="ln162">			md5_calc((input + i), ctxt);</a>
<a name="ln163">		}</a>
<a name="ln164">		</a>
<a name="ln165">		ctxt-&gt;md5_i = len - i;</a>
<a name="ln166">		memcpy (ctxt-&gt;md5_buf, (input + i), ctxt-&gt;md5_i);</a>
<a name="ln167">	} else {</a>
<a name="ln168">		memcpy (ctxt-&gt;md5_buf + ctxt-&gt;md5_i, input, len);</a>
<a name="ln169">		ctxt-&gt;md5_i += len;</a>
<a name="ln170">	}</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">void md5_pad(md5_ctxt *ctxt)</a>
<a name="ln174">{</a>
<a name="ln175">	uint gap;</a>
<a name="ln176"> </a>
<a name="ln177">	/* Don't count up padding. Keep md5_n. */	</a>
<a name="ln178">	gap = MD5_BUFLEN - ctxt-&gt;md5_i;</a>
<a name="ln179">	if (gap &gt; 8) {</a>
<a name="ln180">		memcpy (ctxt-&gt;md5_buf + ctxt-&gt;md5_i, md5_paddat, </a>
<a name="ln181">			gap - sizeof(ctxt-&gt;md5_n));</a>
<a name="ln182">	} else {</a>
<a name="ln183">		/* including gap == 8 */</a>
<a name="ln184">		memcpy (ctxt-&gt;md5_buf + ctxt-&gt;md5_i, md5_paddat, gap);</a>
<a name="ln185">		md5_calc (ctxt-&gt;md5_buf, ctxt);</a>
<a name="ln186">		memcpy (ctxt-&gt;md5_buf, md5_paddat + gap,</a>
<a name="ln187">			MD5_BUFLEN - sizeof(ctxt-&gt;md5_n));</a>
<a name="ln188">	}</a>
<a name="ln189"> </a>
<a name="ln190">	/* 8 byte word */	</a>
<a name="ln191">	if (BYTE_ORDER == LITTLE_ENDIAN)</a>
<a name="ln192">	  memcpy (&amp;ctxt-&gt;md5_buf[56], &amp;ctxt-&gt;md5_n8[0], 8);</a>
<a name="ln193">	else</a>
<a name="ln194">	  {</a>
<a name="ln195">	    ctxt-&gt;md5_buf[56] = ctxt-&gt;md5_n8[7];</a>
<a name="ln196">	    ctxt-&gt;md5_buf[57] = ctxt-&gt;md5_n8[6];</a>
<a name="ln197">	    ctxt-&gt;md5_buf[58] = ctxt-&gt;md5_n8[5];</a>
<a name="ln198">	    ctxt-&gt;md5_buf[59] = ctxt-&gt;md5_n8[4];</a>
<a name="ln199">	    ctxt-&gt;md5_buf[60] = ctxt-&gt;md5_n8[3];</a>
<a name="ln200">	    ctxt-&gt;md5_buf[61] = ctxt-&gt;md5_n8[2];</a>
<a name="ln201">	    ctxt-&gt;md5_buf[62] = ctxt-&gt;md5_n8[1];</a>
<a name="ln202">	    ctxt-&gt;md5_buf[63] = ctxt-&gt;md5_n8[0];</a>
<a name="ln203">	  }</a>
<a name="ln204">	md5_calc(ctxt-&gt;md5_buf, ctxt);</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">void md5_result(uint8_t *digest, md5_ctxt *ctxt)</a>
<a name="ln208">{</a>
<a name="ln209">	/* 4 byte words */</a>
<a name="ln210">	if (BYTE_ORDER == LITTLE_ENDIAN)</a>
<a name="ln211">	  memcpy (digest, &amp;ctxt-&gt;md5_st8[0], 16);</a>
<a name="ln212">	else if (BYTE_ORDER == BIG_ENDIAN)</a>
<a name="ln213">	  {</a>
<a name="ln214">	    digest[ 0] = ctxt-&gt;md5_st8[ 3]; digest[ 1] = ctxt-&gt;md5_st8[ 2];</a>
<a name="ln215">	    digest[ 2] = ctxt-&gt;md5_st8[ 1]; digest[ 3] = ctxt-&gt;md5_st8[ 0];</a>
<a name="ln216">	    digest[ 4] = ctxt-&gt;md5_st8[ 7]; digest[ 5] = ctxt-&gt;md5_st8[ 6];</a>
<a name="ln217">	    digest[ 6] = ctxt-&gt;md5_st8[ 5]; digest[ 7] = ctxt-&gt;md5_st8[ 4];</a>
<a name="ln218">	    digest[ 8] = ctxt-&gt;md5_st8[11]; digest[ 9] = ctxt-&gt;md5_st8[10];</a>
<a name="ln219">	    digest[10] = ctxt-&gt;md5_st8[ 9]; digest[11] = ctxt-&gt;md5_st8[ 8];</a>
<a name="ln220">	    digest[12] = ctxt-&gt;md5_st8[15]; digest[13] = ctxt-&gt;md5_st8[14];</a>
<a name="ln221">	    digest[14] = ctxt-&gt;md5_st8[13]; digest[15] = ctxt-&gt;md5_st8[12];</a>
<a name="ln222">	  }</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">static void md5_calc(const uint8_t *b64, md5_ctxt * ctxt)</a>
<a name="ln226">{</a>
<a name="ln227">	uint32_t A = ctxt-&gt;md5_sta;</a>
<a name="ln228">	uint32_t B = ctxt-&gt;md5_stb;</a>
<a name="ln229">	uint32_t C = ctxt-&gt;md5_stc;</a>
<a name="ln230">	uint32_t D = ctxt-&gt;md5_std;</a>
<a name="ln231">#if (BYTE_ORDER == LITTLE_ENDIAN)</a>
<a name="ln232">	const uint32_t *X = (const uint32_t *)b64;</a>
<a name="ln233">#elif (BYTE_ORDER == BIG_ENDIAN)</a>
<a name="ln234">	uint32_t X[16];</a>
<a name="ln235"> </a>
<a name="ln236">	if (BYTE_ORDER == BIG_ENDIAN)</a>
<a name="ln237">	  {</a>
<a name="ln238">	    /* 4 byte words */</a>
<a name="ln239">	    /* what a brute force but fast! */</a>
<a name="ln240">	    uint8_t *y = (uint8_t *)X;</a>
<a name="ln241">	    y[ 0] = b64[ 3]; y[ 1] = b64[ 2]; y[ 2] = b64[ 1]; y[ 3] = b64[ 0];</a>
<a name="ln242">	    y[ 4] = b64[ 7]; y[ 5] = b64[ 6]; y[ 6] = b64[ 5]; y[ 7] = b64[ 4];</a>
<a name="ln243">	    y[ 8] = b64[11]; y[ 9] = b64[10]; y[10] = b64[ 9]; y[11] = b64[ 8];</a>
<a name="ln244">	    y[12] = b64[15]; y[13] = b64[14]; y[14] = b64[13]; y[15] = b64[12];</a>
<a name="ln245">	    y[16] = b64[19]; y[17] = b64[18]; y[18] = b64[17]; y[19] = b64[16];</a>
<a name="ln246">	    y[20] = b64[23]; y[21] = b64[22]; y[22] = b64[21]; y[23] = b64[20];</a>
<a name="ln247">	    y[24] = b64[27]; y[25] = b64[26]; y[26] = b64[25]; y[27] = b64[24];</a>
<a name="ln248">	    y[28] = b64[31]; y[29] = b64[30]; y[30] = b64[29]; y[31] = b64[28];</a>
<a name="ln249">	    y[32] = b64[35]; y[33] = b64[34]; y[34] = b64[33]; y[35] = b64[32];</a>
<a name="ln250">	    y[36] = b64[39]; y[37] = b64[38]; y[38] = b64[37]; y[39] = b64[36];</a>
<a name="ln251">	    y[40] = b64[43]; y[41] = b64[42]; y[42] = b64[41]; y[43] = b64[40];</a>
<a name="ln252">	    y[44] = b64[47]; y[45] = b64[46]; y[46] = b64[45]; y[47] = b64[44];</a>
<a name="ln253">	    y[48] = b64[51]; y[49] = b64[50]; y[50] = b64[49]; y[51] = b64[48];</a>
<a name="ln254">	    y[52] = b64[55]; y[53] = b64[54]; y[54] = b64[53]; y[55] = b64[52];</a>
<a name="ln255">	    y[56] = b64[59]; y[57] = b64[58]; y[58] = b64[57]; y[59] = b64[56];</a>
<a name="ln256">	    y[60] = b64[63]; y[61] = b64[62]; y[62] = b64[61]; y[63] = b64[60];</a>
<a name="ln257">	  }</a>
<a name="ln258">#endif</a>
<a name="ln259"> </a>
<a name="ln260">	ROUND1(A, B, C, D,  0, Sa,  1); ROUND1(D, A, B, C,  1, Sb,  2);</a>
<a name="ln261">	ROUND1(C, D, A, B,  2, Sc,  3); ROUND1(B, C, D, A,  3, Sd,  4);</a>
<a name="ln262">	ROUND1(A, B, C, D,  4, Sa,  5); ROUND1(D, A, B, C,  5, Sb,  6);</a>
<a name="ln263">	ROUND1(C, D, A, B,  6, Sc,  7); ROUND1(B, C, D, A,  7, Sd,  8);</a>
<a name="ln264">	ROUND1(A, B, C, D,  8, Sa,  9); ROUND1(D, A, B, C,  9, Sb, 10);</a>
<a name="ln265">	ROUND1(C, D, A, B, 10, Sc, 11); ROUND1(B, C, D, A, 11, Sd, 12);</a>
<a name="ln266">	ROUND1(A, B, C, D, 12, Sa, 13); ROUND1(D, A, B, C, 13, Sb, 14);</a>
<a name="ln267">	ROUND1(C, D, A, B, 14, Sc, 15); ROUND1(B, C, D, A, 15, Sd, 16);</a>
<a name="ln268">	</a>
<a name="ln269">	ROUND2(A, B, C, D,  1, Se, 17); ROUND2(D, A, B, C,  6, Sf, 18);</a>
<a name="ln270">	ROUND2(C, D, A, B, 11, Sg, 19); ROUND2(B, C, D, A,  0, Sh, 20);</a>
<a name="ln271">	ROUND2(A, B, C, D,  5, Se, 21); ROUND2(D, A, B, C, 10, Sf, 22);</a>
<a name="ln272">	ROUND2(C, D, A, B, 15, Sg, 23); ROUND2(B, C, D, A,  4, Sh, 24);</a>
<a name="ln273">	ROUND2(A, B, C, D,  9, Se, 25); ROUND2(D, A, B, C, 14, Sf, 26);</a>
<a name="ln274">	ROUND2(C, D, A, B,  3, Sg, 27); ROUND2(B, C, D, A,  8, Sh, 28);</a>
<a name="ln275">	ROUND2(A, B, C, D, 13, Se, 29); ROUND2(D, A, B, C,  2, Sf, 30);</a>
<a name="ln276">	ROUND2(C, D, A, B,  7, Sg, 31); ROUND2(B, C, D, A, 12, Sh, 32);</a>
<a name="ln277"> </a>
<a name="ln278">	ROUND3(A, B, C, D,  5, Si, 33); ROUND3(D, A, B, C,  8, Sj, 34);</a>
<a name="ln279">	ROUND3(C, D, A, B, 11, Sk, 35); ROUND3(B, C, D, A, 14, Sl, 36);</a>
<a name="ln280">	ROUND3(A, B, C, D,  1, Si, 37); ROUND3(D, A, B, C,  4, Sj, 38);</a>
<a name="ln281">	ROUND3(C, D, A, B,  7, Sk, 39); ROUND3(B, C, D, A, 10, Sl, 40);</a>
<a name="ln282">	ROUND3(A, B, C, D, 13, Si, 41); ROUND3(D, A, B, C,  0, Sj, 42);</a>
<a name="ln283">	ROUND3(C, D, A, B,  3, Sk, 43); ROUND3(B, C, D, A,  6, Sl, 44);</a>
<a name="ln284">	ROUND3(A, B, C, D,  9, Si, 45); ROUND3(D, A, B, C, 12, Sj, 46);</a>
<a name="ln285">	ROUND3(C, D, A, B, 15, Sk, 47); ROUND3(B, C, D, A,  2, Sl, 48);</a>
<a name="ln286">	</a>
<a name="ln287">	ROUND4(A, B, C, D,  0, Sm, 49); ROUND4(D, A, B, C,  7, Sn, 50);	</a>
<a name="ln288">	ROUND4(C, D, A, B, 14, So, 51); ROUND4(B, C, D, A,  5, Sp, 52);	</a>
<a name="ln289">	ROUND4(A, B, C, D, 12, Sm, 53); ROUND4(D, A, B, C,  3, Sn, 54);	</a>
<a name="ln290">	ROUND4(C, D, A, B, 10, So, 55); ROUND4(B, C, D, A,  1, Sp, 56);	</a>
<a name="ln291">	ROUND4(A, B, C, D,  8, Sm, 57); ROUND4(D, A, B, C, 15, Sn, 58);	</a>
<a name="ln292">	ROUND4(C, D, A, B,  6, So, 59); ROUND4(B, C, D, A, 13, Sp, 60);	</a>
<a name="ln293">	ROUND4(A, B, C, D,  4, Sm, 61); ROUND4(D, A, B, C, 11, Sn, 62);	</a>
<a name="ln294">	ROUND4(C, D, A, B,  2, So, 63); ROUND4(B, C, D, A,  9, Sp, 64);</a>
<a name="ln295"> </a>
<a name="ln296">	ctxt-&gt;md5_sta += A;</a>
<a name="ln297">	ctxt-&gt;md5_stb += B;</a>
<a name="ln298">	ctxt-&gt;md5_stc += C;</a>
<a name="ln299">	ctxt-&gt;md5_std += D;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">/* From RFC 2104 */</a>
<a name="ln303">void</a>
<a name="ln304">hmac_md5(text, text_len, key, key_len, digest)</a>
<a name="ln305">unsigned char*  text;			/* pointer to data stream */</a>
<a name="ln306">int             text_len;		/* length of data stream */</a>
<a name="ln307">unsigned char*  key;			/* pointer to authentication key */</a>
<a name="ln308">int             key_len;		/* length of authentication key */</a>
<a name="ln309">uint8_t *       digest;			/* caller digest to be filled in */</a>
<a name="ln310"> </a>
<a name="ln311">{</a>
<a name="ln312">    MD5_CTX context;</a>
<a name="ln313">    unsigned char k_ipad[65];    /* inner padding -</a>
<a name="ln314">				 * key XORd with ipad</a>
<a name="ln315">				 */</a>
<a name="ln316">    unsigned char k_opad[65];    /* outer padding -</a>
<a name="ln317">				 * key XORd with opad</a>
<a name="ln318">				 */</a>
<a name="ln319">    unsigned char tk[16];</a>
<a name="ln320">    int i;</a>
<a name="ln321">    /* if key is longer than 64 bytes reset it to key=MD5(key) */</a>
<a name="ln322">    if (key_len &gt; 64) {</a>
<a name="ln323"> </a>
<a name="ln324">       MD5_CTX      tctx;</a>
<a name="ln325"> </a>
<a name="ln326">       MD5Init(&amp;tctx);</a>
<a name="ln327">       MD5Update(&amp;tctx, key, key_len);</a>
<a name="ln328">       MD5Final(tk, &amp;tctx);</a>
<a name="ln329"> </a>
<a name="ln330">       key = tk;</a>
<a name="ln331">       key_len = 16;</a>
<a name="ln332">    }</a>
<a name="ln333"> </a>
<a name="ln334">    /*</a>
<a name="ln335">     * the HMAC_MD5 transform looks like:</a>
<a name="ln336">     *</a>
<a name="ln337">     * MD5(K XOR opad, MD5(K XOR ipad, text))</a>
<a name="ln338">     *</a>
<a name="ln339">     * where K is an n byte key</a>
<a name="ln340">     * ipad is the byte 0x36 repeated 64 times</a>
<a name="ln341">     * opad is the byte 0x5c repeated 64 times</a>
<a name="ln342">     * and text is the data being protected</a>
<a name="ln343">     */</a>
<a name="ln344"> </a>
<a name="ln345">    /* start out by storing key in pads */</a>
<a name="ln346">    bzero( k_ipad, sizeof k_ipad);</a>
<a name="ln347">    bzero( k_opad, sizeof k_opad);</a>
<a name="ln348">    bcopy( key, k_ipad, key_len);</a>
<a name="ln349">    bcopy( key, k_opad, key_len);</a>
<a name="ln350"> </a>
<a name="ln351">    /* XOR key with ipad and opad values */</a>
<a name="ln352">    for (i=0; i&lt;64; i++) {</a>
<a name="ln353">       k_ipad[i] ^= 0x36;</a>
<a name="ln354">       k_opad[i] ^= 0x5c;</a>
<a name="ln355">    }</a>
<a name="ln356">    /*</a>
<a name="ln357">     * perform inner MD5</a>
<a name="ln358">     */</a>
<a name="ln359">    MD5Init(&amp;context);			/* init context for 1st</a>
<a name="ln360">					 * pass */</a>
<a name="ln361">    MD5Update(&amp;context, k_ipad, 64);	/* start with inner pad */</a>
<a name="ln362">    MD5Update(&amp;context, text, text_len); /* then text of datagram */</a>
<a name="ln363">    MD5Final(digest, &amp;context);	/* finish up 1st pass */</a>
<a name="ln364">    /*</a>
<a name="ln365">     * perform outer MD5</a>
<a name="ln366">     */</a>
<a name="ln367">    MD5Init(&amp;context);			/* init context for 2nd</a>
<a name="ln368">					 * pass */</a>
<a name="ln369">    MD5Update(&amp;context, k_opad, 64);	/* start with outer pad */</a>
<a name="ln370">    MD5Update(&amp;context, digest, 16);	/* then results of 1st</a>
<a name="ln371">					 * hash */</a>
<a name="ln372">    MD5Final(digest, &amp;context);	/* finish up 2nd pass */</a>
<a name="ln373">}</a>

</code></pre>
<div class="balloon" rel="186"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'ctxt->md5_buf'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
