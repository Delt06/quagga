
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>zclient.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Zebra's client library.</a>
<a name="ln2"> * Copyright (C) 1999 Kunihiro Ishiguro</a>
<a name="ln3"> * Copyright (C) 2005 Andrew J. Schorr</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln8"> * it under the terms of the GNU General Public License as published</a>
<a name="ln9"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln10"> * option) any later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston,</a>
<a name="ln20"> * MA 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;stream.h&quot;</a>
<a name="ln27">#include &quot;buffer.h&quot;</a>
<a name="ln28">#include &quot;network.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31">#include &quot;thread.h&quot;</a>
<a name="ln32">#include &quot;zclient.h&quot;</a>
<a name="ln33">#include &quot;memory.h&quot;</a>
<a name="ln34">#include &quot;table.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">/* Zebra client events. */</a>
<a name="ln37">enum event {ZCLIENT_SCHEDULE, ZCLIENT_READ, ZCLIENT_CONNECT};</a>
<a name="ln38"> </a>
<a name="ln39">/* Prototype for event manager. */</a>
<a name="ln40">static void zclient_event (enum event, struct zclient *);</a>
<a name="ln41"> </a>
<a name="ln42">const char *zclient_serv_path = NULL;</a>
<a name="ln43"> </a>
<a name="ln44">/* This file local debug flag. */</a>
<a name="ln45">int zclient_debug = 0;</a>
<a name="ln46"> </a>
<a name="ln47">/* Allocate zclient structure. */</a>
<a name="ln48">struct zclient *</a>
<a name="ln49">zclient_new (struct thread_master *master)</a>
<a name="ln50">{</a>
<a name="ln51">  struct zclient *zclient;</a>
<a name="ln52">  zclient = XCALLOC (MTYPE_ZCLIENT, sizeof (struct zclient));</a>
<a name="ln53"> </a>
<a name="ln54">  zclient-&gt;ibuf = stream_new (ZEBRA_MAX_PACKET_SIZ);</a>
<a name="ln55">  zclient-&gt;obuf = stream_new (ZEBRA_MAX_PACKET_SIZ);</a>
<a name="ln56">  zclient-&gt;wb = buffer_new(0);</a>
<a name="ln57">  zclient-&gt;master = master;</a>
<a name="ln58"> </a>
<a name="ln59">  return zclient;</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">/* This function is only called when exiting, because</a>
<a name="ln63">   many parts of the code do not check for I/O errors, so they could</a>
<a name="ln64">   reference an invalid pointer if the structure was ever freed.</a>
<a name="ln65"> </a>
<a name="ln66">   Free zclient structure. */</a>
<a name="ln67">void</a>
<a name="ln68">zclient_free (struct zclient *zclient)</a>
<a name="ln69">{</a>
<a name="ln70">  if (zclient-&gt;ibuf)</a>
<a name="ln71">    stream_free(zclient-&gt;ibuf);</a>
<a name="ln72">  if (zclient-&gt;obuf)</a>
<a name="ln73">    stream_free(zclient-&gt;obuf);</a>
<a name="ln74">  if (zclient-&gt;wb)</a>
<a name="ln75">    buffer_free(zclient-&gt;wb);</a>
<a name="ln76"> </a>
<a name="ln77">  XFREE (MTYPE_ZCLIENT, zclient);</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">/* Initialize zebra client.  Argument redist_default is unwanted</a>
<a name="ln81">   redistribute route type. */</a>
<a name="ln82">void</a>
<a name="ln83">zclient_init (struct zclient *zclient, int redist_default)</a>
<a name="ln84">{</a>
<a name="ln85">  int i;</a>
<a name="ln86">  </a>
<a name="ln87">  /* Enable zebra client connection by default. */</a>
<a name="ln88">  zclient-&gt;enable = 1;</a>
<a name="ln89"> </a>
<a name="ln90">  /* Set -1 to the default socket value. */</a>
<a name="ln91">  zclient-&gt;sock = -1;</a>
<a name="ln92"> </a>
<a name="ln93">  /* Clear redistribution flags. */</a>
<a name="ln94">  for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln95">    zclient-&gt;redist[i] = vrf_bitmap_init ();</a>
<a name="ln96"> </a>
<a name="ln97">  /* Set unwanted redistribute route.  bgpd does not need BGP route</a>
<a name="ln98">     redistribution. */</a>
<a name="ln99">  zclient-&gt;redist_default = redist_default;</a>
<a name="ln100"> </a>
<a name="ln101">  /* Set default-information redistribute to zero. */</a>
<a name="ln102">  zclient-&gt;default_information = vrf_bitmap_init ();</a>
<a name="ln103"> </a>
<a name="ln104">  /* Schedule first zclient connection. */</a>
<a name="ln105">  if (zclient_debug)</a>
<a name="ln106">    zlog_debug (&quot;zclient start scheduled&quot;);</a>
<a name="ln107"> </a>
<a name="ln108">  zclient_event (ZCLIENT_SCHEDULE, zclient);</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">/* Stop zebra client services. */</a>
<a name="ln112">void</a>
<a name="ln113">zclient_stop (struct zclient *zclient)</a>
<a name="ln114">{</a>
<a name="ln115">  int i;</a>
<a name="ln116"> </a>
<a name="ln117">  if (zclient_debug)</a>
<a name="ln118">    zlog_debug (&quot;zclient stopped&quot;);</a>
<a name="ln119"> </a>
<a name="ln120">  /* Stop threads. */</a>
<a name="ln121">  THREAD_OFF(zclient-&gt;t_read);</a>
<a name="ln122">  THREAD_OFF(zclient-&gt;t_connect);</a>
<a name="ln123">  THREAD_OFF(zclient-&gt;t_write);</a>
<a name="ln124"> </a>
<a name="ln125">  /* Reset streams. */</a>
<a name="ln126">  stream_reset(zclient-&gt;ibuf);</a>
<a name="ln127">  stream_reset(zclient-&gt;obuf);</a>
<a name="ln128"> </a>
<a name="ln129">  /* Empty the write buffer. */</a>
<a name="ln130">  buffer_reset(zclient-&gt;wb);</a>
<a name="ln131"> </a>
<a name="ln132">  /* Close socket. */</a>
<a name="ln133">  if (zclient-&gt;sock &gt;= 0)</a>
<a name="ln134">    {</a>
<a name="ln135">      close (zclient-&gt;sock);</a>
<a name="ln136">      zclient-&gt;sock = -1;</a>
<a name="ln137">    }</a>
<a name="ln138">  zclient-&gt;fail = 0;</a>
<a name="ln139"> </a>
<a name="ln140">  for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln141">    {</a>
<a name="ln142">      vrf_bitmap_free(zclient-&gt;redist[i]);</a>
<a name="ln143">      zclient-&gt;redist[i] = VRF_BITMAP_NULL;</a>
<a name="ln144">    }</a>
<a name="ln145">  vrf_bitmap_free(zclient-&gt;default_information);</a>
<a name="ln146">  zclient-&gt;default_information = VRF_BITMAP_NULL;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">void</a>
<a name="ln150">zclient_reset (struct zclient *zclient)</a>
<a name="ln151">{</a>
<a name="ln152">  zclient_stop (zclient);</a>
<a name="ln153">  zclient_init (zclient, zclient-&gt;redist_default);</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">#ifdef HAVE_TCP_ZEBRA</a>
<a name="ln157"> </a>
<a name="ln158">/* Make socket to zebra daemon. Return zebra socket. */</a>
<a name="ln159">static int</a>
<a name="ln160">zclient_socket(void)</a>
<a name="ln161">{</a>
<a name="ln162">  int sock;</a>
<a name="ln163">  int ret;</a>
<a name="ln164">  struct sockaddr_in serv;</a>
<a name="ln165"> </a>
<a name="ln166">  /* We should think about IPv6 connection. */</a>
<a name="ln167">  sock = socket (AF_INET, SOCK_STREAM, 0);</a>
<a name="ln168">  if (sock &lt; 0)</a>
<a name="ln169">    return -1;</a>
<a name="ln170">  </a>
<a name="ln171">  /* Make server socket. */ </a>
<a name="ln172">  memset (&amp;serv, 0, sizeof (struct sockaddr_in));</a>
<a name="ln173">  serv.sin_family = AF_INET;</a>
<a name="ln174">  serv.sin_port = htons (ZEBRA_PORT);</a>
<a name="ln175">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln176">  serv.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln177">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln178">  serv.sin_addr.s_addr = htonl (INADDR_LOOPBACK);</a>
<a name="ln179"> </a>
<a name="ln180">  /* Connect to zebra. */</a>
<a name="ln181">  ret = connect (sock, (struct sockaddr *) &amp;serv, sizeof (serv));</a>
<a name="ln182">  if (ret &lt; 0)</a>
<a name="ln183">    {</a>
<a name="ln184">      zlog_warn (&quot;%s connect failure: %d&quot;, __PRETTY_FUNCTION__, errno);</a>
<a name="ln185">      close (sock);</a>
<a name="ln186">      return -1;</a>
<a name="ln187">    }</a>
<a name="ln188">  return sock;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">#else</a>
<a name="ln192"> </a>
<a name="ln193">/* For sockaddr_un. */</a>
<a name="ln194">#include &lt;sys/un.h&gt;</a>
<a name="ln195"> </a>
<a name="ln196">static int</a>
<a name="ln197">zclient_socket_un (const char *path)</a>
<a name="ln198">{</a>
<a name="ln199">  int ret;</a>
<a name="ln200">  int sock, len;</a>
<a name="ln201">  struct sockaddr_un addr;</a>
<a name="ln202"> </a>
<a name="ln203">  sock = socket (AF_UNIX, SOCK_STREAM, 0);</a>
<a name="ln204">  if (sock &lt; 0)</a>
<a name="ln205">    return -1;</a>
<a name="ln206">  </a>
<a name="ln207">  /* Make server socket. */ </a>
<a name="ln208">  memset (&amp;addr, 0, sizeof (struct sockaddr_un));</a>
<a name="ln209">  addr.sun_family = AF_UNIX;</a>
<a name="ln210">  strncpy (addr.sun_path, path, strlen (path));</a>
<a name="ln211">#ifdef HAVE_STRUCT_SOCKADDR_UN_SUN_LEN</a>
<a name="ln212">  len = addr.sun_len = SUN_LEN(&amp;addr);</a>
<a name="ln213">#else</a>
<a name="ln214">  len = sizeof (addr.sun_family) + strlen (addr.sun_path);</a>
<a name="ln215">#endif /* HAVE_STRUCT_SOCKADDR_UN_SUN_LEN */</a>
<a name="ln216"> </a>
<a name="ln217">  ret = connect (sock, (struct sockaddr *) &amp;addr, len);</a>
<a name="ln218">  if (ret &lt; 0)</a>
<a name="ln219">    {</a>
<a name="ln220">      zlog_warn (&quot;%s connect failure: %d&quot;, __PRETTY_FUNCTION__, errno);</a>
<a name="ln221">      close (sock);</a>
<a name="ln222">      return -1;</a>
<a name="ln223">    }</a>
<a name="ln224">  return sock;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">#endif /* HAVE_TCP_ZEBRA */</a>
<a name="ln228"> </a>
<a name="ln229">/**</a>
<a name="ln230"> * Connect to zebra daemon.</a>
<a name="ln231"> * @param zclient a pointer to zclient structure</a>
<a name="ln232"> * @return socket fd just to make sure that connection established</a>
<a name="ln233"> * @see zclient_init</a>
<a name="ln234"> * @see zclient_new</a>
<a name="ln235"> */</a>
<a name="ln236">int</a>
<a name="ln237">zclient_socket_connect (struct zclient *zclient)</a>
<a name="ln238">{</a>
<a name="ln239">#ifdef HAVE_TCP_ZEBRA</a>
<a name="ln240">  zclient-&gt;sock = zclient_socket ();</a>
<a name="ln241">#else</a>
<a name="ln242">  zclient-&gt;sock = zclient_socket_un (zclient_serv_path_get());</a>
<a name="ln243">#endif</a>
<a name="ln244">  return zclient-&gt;sock;</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">static int</a>
<a name="ln248">zclient_failed(struct zclient *zclient)</a>
<a name="ln249">{</a>
<a name="ln250">  zclient-&gt;fail++;</a>
<a name="ln251">  zclient_stop(zclient);</a>
<a name="ln252">  zclient_event(ZCLIENT_CONNECT, zclient);</a>
<a name="ln253">  return -1;</a>
<a name="ln254">}</a>
<a name="ln255"> </a>
<a name="ln256">static int</a>
<a name="ln257">zclient_flush_data(struct thread *thread)</a>
<a name="ln258">{</a>
<a name="ln259">  struct zclient *zclient = THREAD_ARG(thread);</a>
<a name="ln260"> </a>
<a name="ln261">  zclient-&gt;t_write = NULL;</a>
<a name="ln262">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln263">    return -1;</a>
<a name="ln264">  switch (buffer_flush_available(zclient-&gt;wb, zclient-&gt;sock))</a>
<a name="ln265">    {</a>
<a name="ln266">    case BUFFER_ERROR:</a>
<a name="ln267">      zlog_warn(&quot;%s: buffer_flush_available failed on zclient fd %d, closing&quot;,</a>
<a name="ln268">      		__func__, zclient-&gt;sock);</a>
<a name="ln269">      return zclient_failed(zclient);</a>
<a name="ln270">      break;</a>
<a name="ln271">    case BUFFER_PENDING:</a>
<a name="ln272">      zclient-&gt;t_write = thread_add_write (zclient-&gt;master, zclient_flush_data,</a>
<a name="ln273">					   zclient, zclient-&gt;sock);</a>
<a name="ln274">      break;</a>
<a name="ln275">    case BUFFER_EMPTY:</a>
<a name="ln276">      break;</a>
<a name="ln277">    }</a>
<a name="ln278">  return 0;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">int</a>
<a name="ln282">zclient_send_message(struct zclient *zclient)</a>
<a name="ln283">{</a>
<a name="ln284">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln285">    return -1;</a>
<a name="ln286">  switch (buffer_write(zclient-&gt;wb, zclient-&gt;sock, STREAM_DATA(zclient-&gt;obuf),</a>
<a name="ln287">		       stream_get_endp(zclient-&gt;obuf)))</a>
<a name="ln288">    {</a>
<a name="ln289">    case BUFFER_ERROR:</a>
<a name="ln290">      zlog_warn(&quot;%s: buffer_write failed to zclient fd %d, closing&quot;,</a>
<a name="ln291">      		 __func__, zclient-&gt;sock);</a>
<a name="ln292">      return zclient_failed(zclient);</a>
<a name="ln293">      break;</a>
<a name="ln294">    case BUFFER_EMPTY:</a>
<a name="ln295">      THREAD_OFF(zclient-&gt;t_write);</a>
<a name="ln296">      break;</a>
<a name="ln297">    case BUFFER_PENDING:</a>
<a name="ln298">      THREAD_WRITE_ON (zclient-&gt;master, zclient-&gt;t_write,</a>
<a name="ln299">		       zclient_flush_data, zclient, zclient-&gt;sock);</a>
<a name="ln300">      break;</a>
<a name="ln301">    }</a>
<a name="ln302">  return 0;</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">void</a>
<a name="ln306">zclient_create_header (struct stream *s, uint16_t command, vrf_id_t vrf_id)</a>
<a name="ln307">{</a>
<a name="ln308">  /* length placeholder, caller can update */</a>
<a name="ln309">  stream_putw (s, ZEBRA_HEADER_SIZE);</a>
<a name="ln310">  stream_putc (s, ZEBRA_HEADER_MARKER);</a>
<a name="ln311">  stream_putc (s, ZSERV_VERSION);</a>
<a name="ln312">  stream_putw (s, vrf_id);</a>
<a name="ln313">  stream_putw (s, command);</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">int</a>
<a name="ln317">zclient_read_header (struct stream *s, int sock, u_int16_t *size, u_char *marker,</a>
<a name="ln318">                     u_char *version, u_int16_t *vrf_id, u_int16_t *cmd)</a>
<a name="ln319">{</a>
<a name="ln320">  if (stream_read (s, sock, ZEBRA_HEADER_SIZE) != ZEBRA_HEADER_SIZE)</a>
<a name="ln321">    return -1;</a>
<a name="ln322"> </a>
<a name="ln323">  *size = stream_getw (s) - ZEBRA_HEADER_SIZE;</a>
<a name="ln324">  *marker = stream_getc (s);</a>
<a name="ln325">  *version = stream_getc (s);</a>
<a name="ln326">  *vrf_id = stream_getw (s);</a>
<a name="ln327">  *cmd = stream_getw (s);</a>
<a name="ln328"> </a>
<a name="ln329">  if (*version != ZSERV_VERSION || *marker != ZEBRA_HEADER_MARKER)</a>
<a name="ln330">    {</a>
<a name="ln331">      zlog_err(&quot;%s: socket %d version mismatch, marker %d, version %d&quot;,</a>
<a name="ln332">               __func__, sock, *marker, *version);</a>
<a name="ln333">      return -1;</a>
<a name="ln334">    }</a>
<a name="ln335"> </a>
<a name="ln336">  if (*size &amp;&amp; stream_read (s, sock, *size) != *size)</a>
<a name="ln337">    return -1;</a>
<a name="ln338"> </a>
<a name="ln339">  return 0;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">/* Send simple Zebra message. */</a>
<a name="ln343">static int</a>
<a name="ln344">zebra_message_send (struct zclient *zclient, int command, vrf_id_t vrf_id)</a>
<a name="ln345">{</a>
<a name="ln346">  struct stream *s;</a>
<a name="ln347"> </a>
<a name="ln348">  /* Get zclient output buffer. */</a>
<a name="ln349">  s = zclient-&gt;obuf;</a>
<a name="ln350">  stream_reset (s);</a>
<a name="ln351"> </a>
<a name="ln352">  /* Send very simple command only Zebra message. */</a>
<a name="ln353">  zclient_create_header (s, command, vrf_id);</a>
<a name="ln354">  </a>
<a name="ln355">  return zclient_send_message(zclient);</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">static int</a>
<a name="ln359">zebra_hello_send (struct zclient *zclient)</a>
<a name="ln360">{</a>
<a name="ln361">  struct stream *s;</a>
<a name="ln362"> </a>
<a name="ln363">  if (zclient-&gt;redist_default)</a>
<a name="ln364">    {</a>
<a name="ln365">      s = zclient-&gt;obuf;</a>
<a name="ln366">      stream_reset (s);</a>
<a name="ln367"> </a>
<a name="ln368">      /* The VRF ID in the HELLO message is always 0. */</a>
<a name="ln369">      zclient_create_header (s, ZEBRA_HELLO, VRF_DEFAULT);</a>
<a name="ln370">      stream_putc (s, zclient-&gt;redist_default);</a>
<a name="ln371">      stream_putw_at (s, 0, stream_get_endp (s));</a>
<a name="ln372">      return zclient_send_message(zclient);</a>
<a name="ln373">    }</a>
<a name="ln374"> </a>
<a name="ln375">  return 0;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">/* Send requests to zebra daemon for the information in a VRF. */</a>
<a name="ln379">void</a>
<a name="ln380">zclient_send_requests (struct zclient *zclient, vrf_id_t vrf_id)</a>
<a name="ln381">{</a>
<a name="ln382">  int i;</a>
<a name="ln383"> </a>
<a name="ln384">  /* zclient is disabled. */</a>
<a name="ln385">  if (! zclient-&gt;enable)</a>
<a name="ln386">    return;</a>
<a name="ln387"> </a>
<a name="ln388">  /* If not connected to the zebra yet. */</a>
<a name="ln389">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln390">    return;</a>
<a name="ln391"> </a>
<a name="ln392">  if (zclient_debug)</a>
<a name="ln393">    zlog_debug (&quot;%s: send messages for VRF %u&quot;, __func__, vrf_id);</a>
<a name="ln394"> </a>
<a name="ln395">  /* We need router-id information. */</a>
<a name="ln396">  zebra_message_send (zclient, ZEBRA_ROUTER_ID_ADD, vrf_id);</a>
<a name="ln397"> </a>
<a name="ln398">  /* We need interface information. */</a>
<a name="ln399">  zebra_message_send (zclient, ZEBRA_INTERFACE_ADD, vrf_id);</a>
<a name="ln400"> </a>
<a name="ln401">  /* Set unwanted redistribute route. */</a>
<a name="ln402">  vrf_bitmap_set (zclient-&gt;redist[zclient-&gt;redist_default], vrf_id);</a>
<a name="ln403"> </a>
<a name="ln404">  /* Flush all redistribute request. */</a>
<a name="ln405">  for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln406">    if (i != zclient-&gt;redist_default &amp;&amp;</a>
<a name="ln407">        vrf_bitmap_check (zclient-&gt;redist[i], vrf_id))</a>
<a name="ln408">      zebra_redistribute_send (ZEBRA_REDISTRIBUTE_ADD, zclient, i, vrf_id);</a>
<a name="ln409"> </a>
<a name="ln410">  /* If default information is needed. */</a>
<a name="ln411">  if (vrf_bitmap_check (zclient-&gt;default_information, VRF_DEFAULT))</a>
<a name="ln412">    zebra_message_send (zclient, ZEBRA_REDISTRIBUTE_DEFAULT_ADD, vrf_id);</a>
<a name="ln413">}</a>
<a name="ln414"> </a>
<a name="ln415">/* Make connection to zebra daemon. */</a>
<a name="ln416">int</a>
<a name="ln417">zclient_start (struct zclient *zclient)</a>
<a name="ln418">{</a>
<a name="ln419">  if (zclient_debug)</a>
<a name="ln420">    zlog_debug (&quot;zclient_start is called&quot;);</a>
<a name="ln421"> </a>
<a name="ln422">  /* zclient is disabled. */</a>
<a name="ln423">  if (! zclient-&gt;enable)</a>
<a name="ln424">    return 0;</a>
<a name="ln425"> </a>
<a name="ln426">  /* If already connected to the zebra. */</a>
<a name="ln427">  if (zclient-&gt;sock &gt;= 0)</a>
<a name="ln428">    return 0;</a>
<a name="ln429"> </a>
<a name="ln430">  /* Check connect thread. */</a>
<a name="ln431">  if (zclient-&gt;t_connect)</a>
<a name="ln432">    return 0;</a>
<a name="ln433"> </a>
<a name="ln434">  /*</a>
<a name="ln435">   * If we fail to connect to the socket on initialization,</a>
<a name="ln436">   * Let's wait a second and see if we can reconnect.</a>
<a name="ln437">   * Cause if we don't connect, we never attempt to</a>
<a name="ln438">   * reconnect.  On startup if zebra is slow we</a>
<a name="ln439">   * can get into this situation.</a>
<a name="ln440">   */</a>
<a name="ln441">  while (zclient_socket_connect(zclient) &lt; 0 &amp;&amp; zclient-&gt;fail &lt; 5)</a>
<a name="ln442">    {</a>
<a name="ln443">      if (zclient_debug)</a>
<a name="ln444">	zlog_debug (&quot;zclient connection fail&quot;);</a>
<a name="ln445">      zclient-&gt;fail++;</a>
<a name="ln446">      sleep (1);</a>
<a name="ln447">    }</a>
<a name="ln448"> </a>
<a name="ln449">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln450">    {</a>
<a name="ln451">      zclient_event (ZCLIENT_CONNECT, zclient);</a>
<a name="ln452">      return -1;</a>
<a name="ln453">    }</a>
<a name="ln454"> </a>
<a name="ln455">  if (set_nonblocking(zclient-&gt;sock) &lt; 0)</a>
<a name="ln456">    zlog_warn(&quot;%s: set_nonblocking(%d) failed&quot;, __func__, zclient-&gt;sock);</a>
<a name="ln457"> </a>
<a name="ln458">  /* Clear fail count. */</a>
<a name="ln459">  zclient-&gt;fail = 0;</a>
<a name="ln460">  if (zclient_debug)</a>
<a name="ln461">    zlog_debug (&quot;zclient connect success with socket [%d]&quot;, zclient-&gt;sock);</a>
<a name="ln462">      </a>
<a name="ln463">  /* Create read thread. */</a>
<a name="ln464">  zclient_event (ZCLIENT_READ, zclient);</a>
<a name="ln465"> </a>
<a name="ln466">  zebra_hello_send (zclient);</a>
<a name="ln467"> </a>
<a name="ln468">  /* Inform the successful connection. */</a>
<a name="ln469">  if (zclient-&gt;zebra_connected)</a>
<a name="ln470">    (*zclient-&gt;zebra_connected) (zclient);</a>
<a name="ln471"> </a>
<a name="ln472">  return 0;</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">/* This function is a wrapper function for calling zclient_start from</a>
<a name="ln476">   timer or event thread. */</a>
<a name="ln477">static int</a>
<a name="ln478">zclient_connect (struct thread *t)</a>
<a name="ln479">{</a>
<a name="ln480">  struct zclient *zclient;</a>
<a name="ln481"> </a>
<a name="ln482">  zclient = THREAD_ARG (t);</a>
<a name="ln483">  zclient-&gt;t_connect = NULL;</a>
<a name="ln484"> </a>
<a name="ln485">  if (zclient_debug)</a>
<a name="ln486">    zlog_debug (&quot;zclient_connect is called&quot;);</a>
<a name="ln487"> </a>
<a name="ln488">  return zclient_start (zclient);</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491"> /* </a>
<a name="ln492">  * &quot;xdr_encode&quot;-like interface that allows daemon (client) to send</a>
<a name="ln493">  * a message to zebra server for a route that needs to be</a>
<a name="ln494">  * added/deleted to the kernel. Info about the route is specified</a>
<a name="ln495">  * by the caller in a struct zapi_ipv4. zapi_ipv4_read() then writes</a>
<a name="ln496">  * the info down the zclient socket using the stream_* functions.</a>
<a name="ln497">  * </a>
<a name="ln498">  * The corresponding read (&quot;xdr_decode&quot;) function on the server</a>
<a name="ln499">  * side is zread_ipv4_add()/zread_ipv4_delete().</a>
<a name="ln500">  *</a>
<a name="ln501">  *  0 1 2 3 4 5 6 7 8 9 A B C D E F 0 1 2 3 4 5 6 7 8 9 A B C D E F</a>
<a name="ln502">  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln503">  * |            Length (2)         |    Command    | Route Type    |</a>
<a name="ln504">  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln505">  * | ZEBRA Flags   | Message Flags | Prefix length |</a>
<a name="ln506">  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln507">  * | Destination IPv4 Prefix for route                             |</a>
<a name="ln508">  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln509">  * | Nexthop count | </a>
<a name="ln510">  * +-+-+-+-+-+-+-+-+</a>
<a name="ln511">  *</a>
<a name="ln512">  * </a>
<a name="ln513">  * A number of IPv4 nexthop(s) or nexthop interface index(es) are then </a>
<a name="ln514">  * described, as per the Nexthop count. Each nexthop described as:</a>
<a name="ln515">  *</a>
<a name="ln516">  * +-+-+-+-+-+-+-+-+</a>
<a name="ln517">  * | Nexthop Type  |  Set to one of ZEBRA_NEXTHOP_*</a>
<a name="ln518">  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln519">  * |       IPv4 Nexthop address or Interface Index number          |</a>
<a name="ln520">  * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln521">  *</a>
<a name="ln522">  * Alternatively, if the flags field has ZEBRA_FLAG_BLACKHOLE or</a>
<a name="ln523">  * ZEBRA_FLAG_REJECT is set then Nexthop count is set to 1, then _no_ </a>
<a name="ln524">  * nexthop information is provided, and the message describes a prefix</a>
<a name="ln525">  * to blackhole or reject route.</a>
<a name="ln526">  *</a>
<a name="ln527">  * If ZAPI_MESSAGE_DISTANCE is set, the distance value is written as a 1</a>
<a name="ln528">  * byte value.</a>
<a name="ln529">  * </a>
<a name="ln530">  * If ZAPI_MESSAGE_METRIC is set, the metric value is written as an 8</a>
<a name="ln531">  * byte value.</a>
<a name="ln532">  *</a>
<a name="ln533">  * If ZAPI_MESSAGE_TAG is set, the tag value is written as a 4 byte value</a>
<a name="ln534">  *</a>
<a name="ln535">  * XXX: No attention paid to alignment.</a>
<a name="ln536">  */ </a>
<a name="ln537">int</a>
<a name="ln538">zapi_ipv4_route (u_char cmd, struct zclient *zclient, struct prefix_ipv4 *p,</a>
<a name="ln539">                 struct zapi_ipv4 *api)</a>
<a name="ln540">{</a>
<a name="ln541">  int i;</a>
<a name="ln542">  int psize;</a>
<a name="ln543">  struct stream *s;</a>
<a name="ln544"> </a>
<a name="ln545">  /* Reset stream. */</a>
<a name="ln546">  s = zclient-&gt;obuf;</a>
<a name="ln547">  stream_reset (s);</a>
<a name="ln548"> </a>
<a name="ln549">  zclient_create_header (s, cmd, api-&gt;vrf_id);</a>
<a name="ln550">  </a>
<a name="ln551">  /* Put type and nexthop. */</a>
<a name="ln552">  stream_putc (s, api-&gt;type);</a>
<a name="ln553">  stream_putc (s, api-&gt;flags);</a>
<a name="ln554">  stream_putc (s, api-&gt;message);</a>
<a name="ln555">  stream_putw (s, api-&gt;safi);</a>
<a name="ln556"> </a>
<a name="ln557">  /* Put prefix information. */</a>
<a name="ln558">  psize = PSIZE (p-&gt;prefixlen);</a>
<a name="ln559">  stream_putc (s, p-&gt;prefixlen);</a>
<a name="ln560">  stream_write (s, (u_char *) &amp; p-&gt;prefix, psize);</a>
<a name="ln561"> </a>
<a name="ln562">  /* Nexthop, ifindex, distance and metric information. */</a>
<a name="ln563">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln564">    {</a>
<a name="ln565">      if (CHECK_FLAG (api-&gt;flags, ZEBRA_FLAG_BLACKHOLE))</a>
<a name="ln566">        {</a>
<a name="ln567">          stream_putc (s, 1);</a>
<a name="ln568">          stream_putc (s, ZEBRA_NEXTHOP_BLACKHOLE);</a>
<a name="ln569">          /* XXX assert(api-&gt;nexthop_num == 0); */</a>
<a name="ln570">          /* XXX assert(api-&gt;ifindex_num == 0); */</a>
<a name="ln571">        }</a>
<a name="ln572">      else</a>
<a name="ln573">        stream_putc (s, api-&gt;nexthop_num + api-&gt;ifindex_num);</a>
<a name="ln574"> </a>
<a name="ln575">      for (i = 0; i &lt; api-&gt;nexthop_num; i++)</a>
<a name="ln576">        {</a>
<a name="ln577">          stream_putc (s, ZEBRA_NEXTHOP_IPV4);</a>
<a name="ln578">          stream_put_in_addr (s, api-&gt;nexthop[i]);</a>
<a name="ln579">        }</a>
<a name="ln580">      for (i = 0; i &lt; api-&gt;ifindex_num; i++)</a>
<a name="ln581">        {</a>
<a name="ln582">          stream_putc (s, ZEBRA_NEXTHOP_IFINDEX);</a>
<a name="ln583">          stream_putl (s, api-&gt;ifindex[i]);</a>
<a name="ln584">        }</a>
<a name="ln585">    }</a>
<a name="ln586"> </a>
<a name="ln587">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln588">    stream_putc (s, api-&gt;distance);</a>
<a name="ln589">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln590">    stream_putl (s, api-&gt;metric);</a>
<a name="ln591">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_MTU))</a>
<a name="ln592">    stream_putl (s, api-&gt;mtu);</a>
<a name="ln593">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_TAG))</a>
<a name="ln594">    stream_putl (s, api-&gt;tag);</a>
<a name="ln595"> </a>
<a name="ln596">  /* Put length at the first point of the stream. */</a>
<a name="ln597">  stream_putw_at (s, 0, stream_get_endp (s));</a>
<a name="ln598"> </a>
<a name="ln599">  return zclient_send_message(zclient);</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">#ifdef HAVE_IPV6</a>
<a name="ln603">int</a>
<a name="ln604">zapi_ipv6_route (u_char cmd, struct zclient *zclient, struct prefix_ipv6 *p,</a>
<a name="ln605">	       struct zapi_ipv6 *api)</a>
<a name="ln606">{</a>
<a name="ln607">  int i;</a>
<a name="ln608">  int psize;</a>
<a name="ln609">  struct stream *s;</a>
<a name="ln610"> </a>
<a name="ln611">  /* Reset stream. */</a>
<a name="ln612">  s = zclient-&gt;obuf;</a>
<a name="ln613">  stream_reset (s);</a>
<a name="ln614"> </a>
<a name="ln615">  zclient_create_header (s, cmd, api-&gt;vrf_id);</a>
<a name="ln616"> </a>
<a name="ln617">  /* Put type and nexthop. */</a>
<a name="ln618">  stream_putc (s, api-&gt;type);</a>
<a name="ln619">  stream_putc (s, api-&gt;flags);</a>
<a name="ln620">  stream_putc (s, api-&gt;message);</a>
<a name="ln621">  stream_putw (s, api-&gt;safi);</a>
<a name="ln622">  </a>
<a name="ln623">  /* Put prefix information. */</a>
<a name="ln624">  psize = PSIZE (p-&gt;prefixlen);</a>
<a name="ln625">  stream_putc (s, p-&gt;prefixlen);</a>
<a name="ln626">  stream_write (s, (u_char *)&amp;p-&gt;prefix, psize);</a>
<a name="ln627"> </a>
<a name="ln628">  /* Nexthop, ifindex, distance and metric information. */</a>
<a name="ln629">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln630">    {</a>
<a name="ln631">      stream_putc (s, api-&gt;nexthop_num + api-&gt;ifindex_num);</a>
<a name="ln632"> </a>
<a name="ln633">      for (i = 0; i &lt; api-&gt;nexthop_num; i++)</a>
<a name="ln634">	{</a>
<a name="ln635">	  stream_putc (s, ZEBRA_NEXTHOP_IPV6);</a>
<a name="ln636">	  stream_write (s, (u_char *)api-&gt;nexthop[i], 16);</a>
<a name="ln637">	}</a>
<a name="ln638">      for (i = 0; i &lt; api-&gt;ifindex_num; i++)</a>
<a name="ln639">	{</a>
<a name="ln640">	  stream_putc (s, ZEBRA_NEXTHOP_IFINDEX);</a>
<a name="ln641">	  stream_putl (s, api-&gt;ifindex[i]);</a>
<a name="ln642">	}</a>
<a name="ln643">    }</a>
<a name="ln644"> </a>
<a name="ln645">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln646">    stream_putc (s, api-&gt;distance);</a>
<a name="ln647">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln648">    stream_putl (s, api-&gt;metric);</a>
<a name="ln649">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_MTU))</a>
<a name="ln650">    stream_putl (s, api-&gt;mtu);</a>
<a name="ln651">  if (CHECK_FLAG (api-&gt;message, ZAPI_MESSAGE_TAG))</a>
<a name="ln652">    stream_putl (s, api-&gt;tag);</a>
<a name="ln653"> </a>
<a name="ln654">  /* Put length at the first point of the stream. */</a>
<a name="ln655">  stream_putw_at (s, 0, stream_get_endp (s));</a>
<a name="ln656"> </a>
<a name="ln657">  return zclient_send_message(zclient);</a>
<a name="ln658">}</a>
<a name="ln659">#endif /* HAVE_IPV6 */</a>
<a name="ln660"> </a>
<a name="ln661">/* </a>
<a name="ln662"> * send a ZEBRA_REDISTRIBUTE_ADD or ZEBRA_REDISTRIBUTE_DELETE</a>
<a name="ln663"> * for the route type (ZEBRA_ROUTE_KERNEL etc.). The zebra server will</a>
<a name="ln664"> * then set/unset redist[type] in the client handle (a struct zserv) for the </a>
<a name="ln665"> * sending client</a>
<a name="ln666"> */</a>
<a name="ln667">int</a>
<a name="ln668">zebra_redistribute_send (int command, struct zclient *zclient, int type,</a>
<a name="ln669">    vrf_id_t vrf_id)</a>
<a name="ln670">{</a>
<a name="ln671">  struct stream *s;</a>
<a name="ln672"> </a>
<a name="ln673">  s = zclient-&gt;obuf;</a>
<a name="ln674">  stream_reset(s);</a>
<a name="ln675">  </a>
<a name="ln676">  zclient_create_header (s, command, vrf_id);</a>
<a name="ln677">  stream_putc (s, type);</a>
<a name="ln678">  </a>
<a name="ln679">  stream_putw_at (s, 0, stream_get_endp (s));</a>
<a name="ln680">  </a>
<a name="ln681">  return zclient_send_message(zclient);</a>
<a name="ln682">}</a>
<a name="ln683"> </a>
<a name="ln684">/* Get prefix in ZServ format; family should be filled in on prefix */</a>
<a name="ln685">static void</a>
<a name="ln686">zclient_stream_get_prefix (struct stream *s, struct prefix *p)</a>
<a name="ln687">{</a>
<a name="ln688">  size_t plen = prefix_blen (p);</a>
<a name="ln689">  u_char c;</a>
<a name="ln690">  p-&gt;prefixlen = 0;</a>
<a name="ln691">  </a>
<a name="ln692">  if (plen == 0)</a>
<a name="ln693">    return;</a>
<a name="ln694">  </a>
<a name="ln695">  stream_get (&amp;p-&gt;u.prefix, s, plen);</a>
<a name="ln696">  c = stream_getc(s);</a>
<a name="ln697">  p-&gt;prefixlen = MIN(plen * 8, c);</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">/* Router-id update from zebra daemon. */</a>
<a name="ln701">void</a>
<a name="ln702">zebra_router_id_update_read (struct stream *s, struct prefix *rid)</a>
<a name="ln703">{</a>
<a name="ln704">  /* Fetch interface address. */</a>
<a name="ln705">  rid-&gt;family = stream_getc (s);</a>
<a name="ln706">  </a>
<a name="ln707">  zclient_stream_get_prefix (s, rid);</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">/* Interface addition from zebra daemon. */</a>
<a name="ln711">/*  </a>
<a name="ln712"> * The format of the message sent with type ZEBRA_INTERFACE_ADD or</a>
<a name="ln713"> * ZEBRA_INTERFACE_DELETE from zebra to the client is:</a>
<a name="ln714"> *     0                   1                   2                   3</a>
<a name="ln715"> *  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1</a>
<a name="ln716"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln717"> * |  ifname                                                       |</a>
<a name="ln718"> * |                                                               |</a>
<a name="ln719"> * |                                                               |</a>
<a name="ln720"> * |                                                               |</a>
<a name="ln721"> * |                                                               |</a>
<a name="ln722"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln723"> * |  ifindex                                                      |</a>
<a name="ln724"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln725"> * |  status       |</a>
<a name="ln726"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln727"> * |  if_flags                                                     |</a>
<a name="ln728"> * |                                                               |</a>
<a name="ln729"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln730"> * |  metric                                                       |</a>
<a name="ln731"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln732"> * |  ifmtu                                                        |</a>
<a name="ln733"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln734"> * |  ifmtu6                                                       |</a>
<a name="ln735"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln736"> * |  bandwidth                                                    |</a>
<a name="ln737"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln738"> * |  Link Layer Type                                              |</a>
<a name="ln739"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln740"> * |  Harware Address Length                                       |</a>
<a name="ln741"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln742"> * |  Hardware Address      if HW lenght different from 0          |</a>
<a name="ln743"> * |   ...                  max INTERFACE_HWADDR_MAX               |</a>
<a name="ln744"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln745"> * |  Link_params? |  Whether a link-params follows: 1 or 0.       </a>
<a name="ln746"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln747"> * |  Link_params    0 or 1 INTERFACE_LINK_PARAMS_SIZE sized       |</a>
<a name="ln748"> * |   ....          (struct if_link_params).                      |</a>
<a name="ln749"> * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+</a>
<a name="ln750"> */</a>
<a name="ln751"> </a>
<a name="ln752">struct interface *</a>
<a name="ln753">zebra_interface_add_read (struct stream *s, vrf_id_t vrf_id)</a>
<a name="ln754">{</a>
<a name="ln755">  struct interface *ifp;</a>
<a name="ln756">  char ifname_tmp[INTERFACE_NAMSIZ];</a>
<a name="ln757"> </a>
<a name="ln758">  /* Read interface name. */</a>
<a name="ln759">  stream_get (ifname_tmp, s, INTERFACE_NAMSIZ);</a>
<a name="ln760"> </a>
<a name="ln761">  /* Lookup/create interface by name. */</a>
<a name="ln762">  ifp = if_get_by_name_len_vrf (ifname_tmp,</a>
<a name="ln763">                                strnlen (ifname_tmp, INTERFACE_NAMSIZ),</a>
<a name="ln764">                                vrf_id);</a>
<a name="ln765"> </a>
<a name="ln766">  zebra_interface_if_set_value (s, ifp);</a>
<a name="ln767"> </a>
<a name="ln768">  return ifp;</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">/* </a>
<a name="ln772"> * Read interface up/down msg (ZEBRA_INTERFACE_UP/ZEBRA_INTERFACE_DOWN)</a>
<a name="ln773"> * from zebra server.  The format of this message is the same as</a>
<a name="ln774"> * that sent for ZEBRA_INTERFACE_ADD/ZEBRA_INTERFACE_DELETE (see</a>
<a name="ln775"> * comments for zebra_interface_add_read), except that no sockaddr_dl</a>
<a name="ln776"> * is sent at the tail of the message.</a>
<a name="ln777"> */</a>
<a name="ln778">struct interface *</a>
<a name="ln779">zebra_interface_state_read (struct stream *s, vrf_id_t vrf_id)</a>
<a name="ln780">{</a>
<a name="ln781">  struct interface *ifp;</a>
<a name="ln782">  char ifname_tmp[INTERFACE_NAMSIZ];</a>
<a name="ln783"> </a>
<a name="ln784">  /* Read interface name. */</a>
<a name="ln785">  stream_get (ifname_tmp, s, INTERFACE_NAMSIZ);</a>
<a name="ln786"> </a>
<a name="ln787">  /* Lookup this by interface index. */</a>
<a name="ln788">  ifp = if_lookup_by_name_len_vrf (ifname_tmp,</a>
<a name="ln789">                                   strnlen (ifname_tmp, INTERFACE_NAMSIZ),</a>
<a name="ln790">                                   vrf_id);</a>
<a name="ln791"> </a>
<a name="ln792">  /* If such interface does not exist, indicate an error */</a>
<a name="ln793">  if (! ifp)</a>
<a name="ln794">     return NULL;</a>
<a name="ln795"> </a>
<a name="ln796">  zebra_interface_if_set_value (s, ifp);</a>
<a name="ln797"> </a>
<a name="ln798">  return ifp;</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801">static void</a>
<a name="ln802">link_params_set_value(struct stream *s, struct if_link_params *iflp)</a>
<a name="ln803">{</a>
<a name="ln804">  </a>
<a name="ln805">  if (iflp == NULL)</a>
<a name="ln806">    return;</a>
<a name="ln807">  </a>
<a name="ln808">  iflp-&gt;lp_status = stream_getl (s);</a>
<a name="ln809">  iflp-&gt;te_metric = stream_getl (s);</a>
<a name="ln810">  iflp-&gt;max_bw = stream_getf (s);</a>
<a name="ln811">  iflp-&gt;max_rsv_bw = stream_getf (s);</a>
<a name="ln812">  uint32_t bwclassnum = stream_getl (s);</a>
<a name="ln813">  {</a>
<a name="ln814">    unsigned int i;</a>
<a name="ln815">    for (i = 0; i &lt; bwclassnum &amp;&amp; i &lt; MAX_CLASS_TYPE; i++)</a>
<a name="ln816">      iflp-&gt;unrsv_bw[i] = stream_getf (s);</a>
<a name="ln817">    if (i &lt; bwclassnum)</a>
<a name="ln818">      zlog_err (&quot;%s: received %d &gt; %d (MAX_CLASS_TYPE) bw entries&quot;</a>
<a name="ln819">                &quot; - outdated library?&quot;,</a>
<a name="ln820">                __func__, bwclassnum, MAX_CLASS_TYPE);</a>
<a name="ln821">  }</a>
<a name="ln822">  iflp-&gt;admin_grp = stream_getl (s);</a>
<a name="ln823">  iflp-&gt;rmt_as = stream_getl (s);</a>
<a name="ln824">  iflp-&gt;rmt_ip.s_addr = stream_get_ipv4 (s);</a>
<a name="ln825">  </a>
<a name="ln826">  iflp-&gt;av_delay = stream_getl (s);</a>
<a name="ln827">  iflp-&gt;min_delay = stream_getl (s);</a>
<a name="ln828">  iflp-&gt;max_delay = stream_getl (s);</a>
<a name="ln829">  iflp-&gt;delay_var = stream_getl (s);</a>
<a name="ln830">  </a>
<a name="ln831">  iflp-&gt;pkt_loss = stream_getf (s);</a>
<a name="ln832">  iflp-&gt;res_bw = stream_getf (s);</a>
<a name="ln833">  iflp-&gt;ava_bw = stream_getf (s);</a>
<a name="ln834">  iflp-&gt;use_bw = stream_getf (s);</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">struct interface *</a>
<a name="ln838">zebra_interface_link_params_read (struct stream *s)</a>
<a name="ln839">{</a>
<a name="ln840">  struct if_link_params *iflp;</a>
<a name="ln841">  uint32_t ifindex = stream_getl (s);</a>
<a name="ln842"> </a>
<a name="ln843">  struct interface *ifp = if_lookup_by_index (ifindex);</a>
<a name="ln844"> </a>
<a name="ln845">  if (ifp == NULL || s == NULL)</a>
<a name="ln846">    {</a>
<a name="ln847">      zlog_err (&quot;%s: unknown ifindex %u, shouldn't happen&quot;,</a>
<a name="ln848">                __func__, ifindex);</a>
<a name="ln849">      return NULL;</a>
<a name="ln850">    }</a>
<a name="ln851"> </a>
<a name="ln852">  if ((iflp = if_link_params_get (ifp)) == NULL)</a>
<a name="ln853">    return NULL;</a>
<a name="ln854"> </a>
<a name="ln855">  link_params_set_value(s, iflp);</a>
<a name="ln856">  </a>
<a name="ln857">  return ifp;</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">void</a>
<a name="ln861">zebra_interface_if_set_value (struct stream *s, struct interface *ifp)</a>
<a name="ln862">{</a>
<a name="ln863">  u_char link_params_status = 0;</a>
<a name="ln864"> </a>
<a name="ln865">  /* Read interface's index. */</a>
<a name="ln866">  ifp-&gt;ifindex = stream_getl (s);</a>
<a name="ln867">  ifp-&gt;status = stream_getc (s);</a>
<a name="ln868"> </a>
<a name="ln869">  /* Read interface's value. */</a>
<a name="ln870">  ifp-&gt;flags = stream_getq (s);</a>
<a name="ln871">  ifp-&gt;metric = stream_getl (s);</a>
<a name="ln872">  ifp-&gt;mtu = stream_getl (s);</a>
<a name="ln873">  ifp-&gt;mtu6 = stream_getl (s);</a>
<a name="ln874">  ifp-&gt;bandwidth = stream_getl (s);</a>
<a name="ln875">  ifp-&gt;ll_type = stream_getl (s);</a>
<a name="ln876">  ifp-&gt;hw_addr_len = stream_getl (s);</a>
<a name="ln877">  if (ifp-&gt;hw_addr_len)</a>
<a name="ln878">    stream_get (ifp-&gt;hw_addr, s, MIN(ifp-&gt;hw_addr_len, INTERFACE_HWADDR_MAX));</a>
<a name="ln879"> </a>
<a name="ln880">  /* Read Traffic Engineering status */</a>
<a name="ln881">  link_params_status = stream_getc (s);</a>
<a name="ln882">  /* Then, Traffic Engineering parameters if any */</a>
<a name="ln883">  if (link_params_status)</a>
<a name="ln884">    {</a>
<a name="ln885">      struct if_link_params *iflp = if_link_params_get (ifp);</a>
<a name="ln886">      link_params_set_value(s, iflp);</a>
<a name="ln887">    }</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">size_t</a>
<a name="ln891">zebra_interface_link_params_write (struct stream *s, struct interface *ifp)</a>
<a name="ln892">{</a>
<a name="ln893">  size_t w;</a>
<a name="ln894">  struct if_link_params *iflp;</a>
<a name="ln895">  int i;</a>
<a name="ln896">  </a>
<a name="ln897">  if (s == NULL || ifp == NULL || ifp-&gt;link_params == NULL)</a>
<a name="ln898">    return 0;</a>
<a name="ln899">  </a>
<a name="ln900">  iflp = ifp-&gt;link_params;</a>
<a name="ln901">  w = 0;</a>
<a name="ln902">    </a>
<a name="ln903">  w += stream_putl (s, iflp-&gt;lp_status);</a>
<a name="ln904"> </a>
<a name="ln905">  w += stream_putl (s, iflp-&gt;te_metric);</a>
<a name="ln906">  w += stream_putf (s, iflp-&gt;max_bw);</a>
<a name="ln907">  w += stream_putf (s, iflp-&gt;max_rsv_bw);</a>
<a name="ln908">  </a>
<a name="ln909">  w += stream_putl (s, MAX_CLASS_TYPE);</a>
<a name="ln910">  for (i = 0; i &lt; MAX_CLASS_TYPE; i++)</a>
<a name="ln911">    w += stream_putf (s, iflp-&gt;unrsv_bw[i]);</a>
<a name="ln912">  </a>
<a name="ln913">  w += stream_putl (s, iflp-&gt;admin_grp);</a>
<a name="ln914">  w += stream_putl (s, iflp-&gt;rmt_as);</a>
<a name="ln915">  w += stream_put_in_addr (s, &amp;iflp-&gt;rmt_ip);</a>
<a name="ln916">  </a>
<a name="ln917">  w += stream_putl (s, iflp-&gt;av_delay);</a>
<a name="ln918">  w += stream_putl (s, iflp-&gt;min_delay);</a>
<a name="ln919">  w += stream_putl (s, iflp-&gt;max_delay);</a>
<a name="ln920">  w += stream_putl (s, iflp-&gt;delay_var);</a>
<a name="ln921">  </a>
<a name="ln922">  w += stream_putf (s, iflp-&gt;pkt_loss);</a>
<a name="ln923">  w += stream_putf (s, iflp-&gt;res_bw);</a>
<a name="ln924">  w += stream_putf (s, iflp-&gt;ava_bw);</a>
<a name="ln925">  w += stream_putf (s, iflp-&gt;use_bw);</a>
<a name="ln926">  </a>
<a name="ln927">  return w;</a>
<a name="ln928">}</a>
<a name="ln929"> </a>
<a name="ln930">/*</a>
<a name="ln931"> * format of message for address additon is:</a>
<a name="ln932"> *    0</a>
<a name="ln933"> *  0 1 2 3 4 5 6 7</a>
<a name="ln934"> * +-+-+-+-+-+-+-+-+</a>
<a name="ln935"> * |   type        |  ZEBRA_INTERFACE_ADDRESS_ADD or</a>
<a name="ln936"> * +-+-+-+-+-+-+-+-+  ZEBRA_INTERFACE_ADDRES_DELETE</a>
<a name="ln937"> * |               |</a>
<a name="ln938"> * +               +</a>
<a name="ln939"> * |   ifindex     |</a>
<a name="ln940"> * +               +</a>
<a name="ln941"> * |               |</a>
<a name="ln942"> * +               +</a>
<a name="ln943"> * |               |</a>
<a name="ln944"> * +-+-+-+-+-+-+-+-+</a>
<a name="ln945"> * |   ifc_flags   |  flags for connected address</a>
<a name="ln946"> * +-+-+-+-+-+-+-+-+</a>
<a name="ln947"> * |  addr_family  |</a>
<a name="ln948"> * +-+-+-+-+-+-+-+-+</a>
<a name="ln949"> * |    addr...    |</a>
<a name="ln950"> * :               :</a>
<a name="ln951"> * |               |</a>
<a name="ln952"> * +-+-+-+-+-+-+-+-+</a>
<a name="ln953"> * |    addr_len   |  len of addr. E.g., addr_len = 4 for ipv4 addrs.</a>
<a name="ln954"> * +-+-+-+-+-+-+-+-+</a>
<a name="ln955"> * |     daddr..   |</a>
<a name="ln956"> * :               :</a>
<a name="ln957"> * |               |</a>
<a name="ln958"> * +-+-+-+-+-+-+-+-+</a>
<a name="ln959"> */</a>
<a name="ln960"> </a>
<a name="ln961">static int</a>
<a name="ln962">memconstant(const void *s, int c, size_t n)</a>
<a name="ln963">{</a>
<a name="ln964">  const u_char *p = s;</a>
<a name="ln965"> </a>
<a name="ln966">  while (n-- &gt; 0)</a>
<a name="ln967">    if (*p++ != c)</a>
<a name="ln968">      return 0;</a>
<a name="ln969">  return 1;</a>
<a name="ln970">}</a>
<a name="ln971"> </a>
<a name="ln972">struct connected *</a>
<a name="ln973">zebra_interface_address_read (int type, struct stream *s, vrf_id_t vrf_id)</a>
<a name="ln974">{</a>
<a name="ln975">  ifindex_t ifindex;</a>
<a name="ln976">  struct interface *ifp;</a>
<a name="ln977">  struct connected *ifc;</a>
<a name="ln978">  struct prefix p, d, *dp;</a>
<a name="ln979">  int plen;</a>
<a name="ln980">  u_char ifc_flags;</a>
<a name="ln981"> </a>
<a name="ln982">  memset (&amp;p, 0, sizeof(p));</a>
<a name="ln983">  memset (&amp;d, 0, sizeof(d));</a>
<a name="ln984"> </a>
<a name="ln985">  /* Get interface index. */</a>
<a name="ln986">  ifindex = stream_getl (s);</a>
<a name="ln987"> </a>
<a name="ln988">  /* Lookup index. */</a>
<a name="ln989">  ifp = if_lookup_by_index_vrf (ifindex, vrf_id);</a>
<a name="ln990">  if (ifp == NULL)</a>
<a name="ln991">    {</a>
<a name="ln992">      zlog_warn (&quot;zebra_interface_address_read(%s): &quot;</a>
<a name="ln993">                 &quot;Can't find interface by ifindex: %d &quot;,</a>
<a name="ln994">                 (type == ZEBRA_INTERFACE_ADDRESS_ADD? &quot;ADD&quot; : &quot;DELETE&quot;),</a>
<a name="ln995">                 ifindex);</a>
<a name="ln996">      return NULL;</a>
<a name="ln997">    }</a>
<a name="ln998"> </a>
<a name="ln999">  /* Fetch flag. */</a>
<a name="ln1000">  ifc_flags = stream_getc (s);</a>
<a name="ln1001"> </a>
<a name="ln1002">  /* Fetch interface address. */</a>
<a name="ln1003">  d.family = p.family = stream_getc (s);</a>
<a name="ln1004">  plen = prefix_blen (&amp;d);</a>
<a name="ln1005">  </a>
<a name="ln1006">  zclient_stream_get_prefix (s, &amp;p);</a>
<a name="ln1007"> </a>
<a name="ln1008">  /* Fetch destination address. */</a>
<a name="ln1009">  stream_get (&amp;d.u.prefix, s, plen);</a>
<a name="ln1010">  </a>
<a name="ln1011">  /* N.B. NULL destination pointers are encoded as all zeroes */</a>
<a name="ln1012">  dp = memconstant(&amp;d.u.prefix,0,plen) ? NULL : &amp;d;</a>
<a name="ln1013">  </a>
<a name="ln1014">  if (type == ZEBRA_INTERFACE_ADDRESS_ADD) </a>
<a name="ln1015">    {</a>
<a name="ln1016">       /* N.B. NULL destination pointers are encoded as all zeroes */</a>
<a name="ln1017">       ifc = connected_add_by_prefix(ifp, &amp;p, dp);</a>
<a name="ln1018">       if (ifc != NULL)</a>
<a name="ln1019">	 {</a>
<a name="ln1020">	   ifc-&gt;flags = ifc_flags;</a>
<a name="ln1021">	   if (ifc-&gt;destination)</a>
<a name="ln1022">	     ifc-&gt;destination-&gt;prefixlen = ifc-&gt;address-&gt;prefixlen;</a>
<a name="ln1023">	   else if (CHECK_FLAG(ifc-&gt;flags, ZEBRA_IFA_PEER))</a>
<a name="ln1024">	     {</a>
<a name="ln1025">	       /* carp interfaces on OpenBSD with 0.0.0.0/0 as &quot;peer&quot; */</a>
<a name="ln1026">	       char buf[PREFIX_STRLEN];</a>
<a name="ln1027">	       zlog_warn(&quot;warning: interface %s address %s &quot;</a>
<a name="ln1028">		    &quot;with peer flag set, but no peer address!&quot;,</a>
<a name="ln1029">		    ifp-&gt;name,</a>
<a name="ln1030">		    prefix2str (ifc-&gt;address, buf, sizeof buf));</a>
<a name="ln1031">	       UNSET_FLAG(ifc-&gt;flags, ZEBRA_IFA_PEER);</a>
<a name="ln1032">	     }</a>
<a name="ln1033">	 }</a>
<a name="ln1034">    }</a>
<a name="ln1035">  else</a>
<a name="ln1036">    {</a>
<a name="ln1037">      assert (type == ZEBRA_INTERFACE_ADDRESS_DELETE);</a>
<a name="ln1038">      ifc = connected_delete_by_prefix(ifp, &amp;p);</a>
<a name="ln1039">    }</a>
<a name="ln1040"> </a>
<a name="ln1041">  return ifc;</a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044"> </a>
<a name="ln1045">/* Zebra client message read function. */</a>
<a name="ln1046">static int</a>
<a name="ln1047">zclient_read (struct thread *thread)</a>
<a name="ln1048">{</a>
<a name="ln1049">  size_t already;</a>
<a name="ln1050">  uint16_t length, command;</a>
<a name="ln1051">  uint8_t marker, version;</a>
<a name="ln1052">  vrf_id_t vrf_id;</a>
<a name="ln1053">  struct zclient *zclient;</a>
<a name="ln1054"> </a>
<a name="ln1055">  /* Get socket to zebra. */</a>
<a name="ln1056">  zclient = THREAD_ARG (thread);</a>
<a name="ln1057">  zclient-&gt;t_read = NULL;</a>
<a name="ln1058"> </a>
<a name="ln1059">  /* Read zebra header (if we don't have it already). */</a>
<a name="ln1060">  if ((already = stream_get_endp(zclient-&gt;ibuf)) &lt; ZEBRA_HEADER_SIZE)</a>
<a name="ln1061">    {</a>
<a name="ln1062">      ssize_t nbyte;</a>
<a name="ln1063">      if (((nbyte = stream_read_try(zclient-&gt;ibuf, zclient-&gt;sock,</a>
<a name="ln1064">				     ZEBRA_HEADER_SIZE-already)) == 0) ||</a>
<a name="ln1065">	  (nbyte == -1))</a>
<a name="ln1066">	{</a>
<a name="ln1067">	  if (zclient_debug)</a>
<a name="ln1068">	   zlog_debug (&quot;zclient connection closed socket [%d].&quot;, zclient-&gt;sock);</a>
<a name="ln1069">	  return zclient_failed(zclient);</a>
<a name="ln1070">	}</a>
<a name="ln1071">      if (nbyte != (ssize_t)(ZEBRA_HEADER_SIZE-already))</a>
<a name="ln1072">	{</a>
<a name="ln1073">	  /* Try again later. */</a>
<a name="ln1074">	  zclient_event (ZCLIENT_READ, zclient);</a>
<a name="ln1075">	  return 0;</a>
<a name="ln1076">	}</a>
<a name="ln1077">      already = ZEBRA_HEADER_SIZE;</a>
<a name="ln1078">    }</a>
<a name="ln1079"> </a>
<a name="ln1080">  /* Reset to read from the beginning of the incoming packet. */</a>
<a name="ln1081">  stream_set_getp(zclient-&gt;ibuf, 0);</a>
<a name="ln1082"> </a>
<a name="ln1083">  /* Fetch header values. */</a>
<a name="ln1084">  length = stream_getw (zclient-&gt;ibuf);</a>
<a name="ln1085">  marker = stream_getc (zclient-&gt;ibuf);</a>
<a name="ln1086">  version = stream_getc (zclient-&gt;ibuf);</a>
<a name="ln1087">  vrf_id = stream_getw (zclient-&gt;ibuf);</a>
<a name="ln1088">  command = stream_getw (zclient-&gt;ibuf);</a>
<a name="ln1089">  </a>
<a name="ln1090">  if (marker != ZEBRA_HEADER_MARKER || version != ZSERV_VERSION)</a>
<a name="ln1091">    {</a>
<a name="ln1092">      zlog_err(&quot;%s: socket %d version mismatch, marker %d, version %d&quot;,</a>
<a name="ln1093">               __func__, zclient-&gt;sock, marker, version);</a>
<a name="ln1094">      return zclient_failed(zclient);</a>
<a name="ln1095">    }</a>
<a name="ln1096">  </a>
<a name="ln1097">  if (length &lt; ZEBRA_HEADER_SIZE) </a>
<a name="ln1098">    {</a>
<a name="ln1099">      zlog_err(&quot;%s: socket %d message length %u is less than %d &quot;,</a>
<a name="ln1100">	       __func__, zclient-&gt;sock, length, ZEBRA_HEADER_SIZE);</a>
<a name="ln1101">      return zclient_failed(zclient);</a>
<a name="ln1102">    }</a>
<a name="ln1103"> </a>
<a name="ln1104">  /* Length check. */</a>
<a name="ln1105">  if (length &gt; STREAM_SIZE(zclient-&gt;ibuf))</a>
<a name="ln1106">    {</a>
<a name="ln1107">      struct stream *ns;</a>
<a name="ln1108">      zlog_warn(&quot;%s: message size %u exceeds buffer size %lu, expanding...&quot;,</a>
<a name="ln1109">	        __func__, length, (u_long)STREAM_SIZE(zclient-&gt;ibuf));</a>
<a name="ln1110">      ns = stream_new(length);</a>
<a name="ln1111">      stream_copy(ns, zclient-&gt;ibuf);</a>
<a name="ln1112">      stream_free (zclient-&gt;ibuf);</a>
<a name="ln1113">      zclient-&gt;ibuf = ns;</a>
<a name="ln1114">    }</a>
<a name="ln1115"> </a>
<a name="ln1116">  /* Read rest of zebra packet. */</a>
<a name="ln1117">  if (already &lt; length)</a>
<a name="ln1118">    {</a>
<a name="ln1119">      ssize_t nbyte;</a>
<a name="ln1120">      if (((nbyte = stream_read_try(zclient-&gt;ibuf, zclient-&gt;sock,</a>
<a name="ln1121">				     length-already)) == 0) ||</a>
<a name="ln1122">	  (nbyte == -1))</a>
<a name="ln1123">	{</a>
<a name="ln1124">	  if (zclient_debug)</a>
<a name="ln1125">	    zlog_debug(&quot;zclient connection closed socket [%d].&quot;, zclient-&gt;sock);</a>
<a name="ln1126">	  return zclient_failed(zclient);</a>
<a name="ln1127">	}</a>
<a name="ln1128">      if (nbyte != (ssize_t)(length-already))</a>
<a name="ln1129">	{</a>
<a name="ln1130">	  /* Try again later. */</a>
<a name="ln1131">	  zclient_event (ZCLIENT_READ, zclient);</a>
<a name="ln1132">	  return 0;</a>
<a name="ln1133">	}</a>
<a name="ln1134">    }</a>
<a name="ln1135"> </a>
<a name="ln1136">  length -= ZEBRA_HEADER_SIZE;</a>
<a name="ln1137"> </a>
<a name="ln1138">  if (zclient_debug)</a>
<a name="ln1139">    zlog_debug(&quot;zclient 0x%p command 0x%x VRF %u\n&quot;, (void *)zclient, command, vrf_id);</a>
<a name="ln1140"> </a>
<a name="ln1141">  switch (command)</a>
<a name="ln1142">    {</a>
<a name="ln1143">    case ZEBRA_ROUTER_ID_UPDATE:</a>
<a name="ln1144">      if (zclient-&gt;router_id_update)</a>
<a name="ln1145">	(*zclient-&gt;router_id_update) (command, zclient, length, vrf_id);</a>
<a name="ln1146">      break;</a>
<a name="ln1147">    case ZEBRA_INTERFACE_ADD:</a>
<a name="ln1148">      if (zclient-&gt;interface_add)</a>
<a name="ln1149">	(*zclient-&gt;interface_add) (command, zclient, length, vrf_id);</a>
<a name="ln1150">      break;</a>
<a name="ln1151">    case ZEBRA_INTERFACE_DELETE:</a>
<a name="ln1152">      if (zclient-&gt;interface_delete)</a>
<a name="ln1153">	(*zclient-&gt;interface_delete) (command, zclient, length, vrf_id);</a>
<a name="ln1154">      break;</a>
<a name="ln1155">    case ZEBRA_INTERFACE_ADDRESS_ADD:</a>
<a name="ln1156">      if (zclient-&gt;interface_address_add)</a>
<a name="ln1157">	(*zclient-&gt;interface_address_add) (command, zclient, length, vrf_id);</a>
<a name="ln1158">      break;</a>
<a name="ln1159">    case ZEBRA_INTERFACE_ADDRESS_DELETE:</a>
<a name="ln1160">      if (zclient-&gt;interface_address_delete)</a>
<a name="ln1161">	(*zclient-&gt;interface_address_delete) (command, zclient, length, vrf_id);</a>
<a name="ln1162">      break;</a>
<a name="ln1163">    case ZEBRA_INTERFACE_UP:</a>
<a name="ln1164">      if (zclient-&gt;interface_up)</a>
<a name="ln1165">	(*zclient-&gt;interface_up) (command, zclient, length, vrf_id);</a>
<a name="ln1166">      break;</a>
<a name="ln1167">    case ZEBRA_INTERFACE_DOWN:</a>
<a name="ln1168">      if (zclient-&gt;interface_down)</a>
<a name="ln1169">	(*zclient-&gt;interface_down) (command, zclient, length, vrf_id);</a>
<a name="ln1170">      break;</a>
<a name="ln1171">    case ZEBRA_IPV4_ROUTE_ADD:</a>
<a name="ln1172">      if (zclient-&gt;ipv4_route_add)</a>
<a name="ln1173">	(*zclient-&gt;ipv4_route_add) (command, zclient, length, vrf_id);</a>
<a name="ln1174">      break;</a>
<a name="ln1175">    case ZEBRA_IPV4_ROUTE_DELETE:</a>
<a name="ln1176">      if (zclient-&gt;ipv4_route_delete)</a>
<a name="ln1177">	(*zclient-&gt;ipv4_route_delete) (command, zclient, length, vrf_id);</a>
<a name="ln1178">      break;</a>
<a name="ln1179">    case ZEBRA_IPV6_ROUTE_ADD:</a>
<a name="ln1180">      if (zclient-&gt;ipv6_route_add)</a>
<a name="ln1181">	(*zclient-&gt;ipv6_route_add) (command, zclient, length, vrf_id);</a>
<a name="ln1182">      break;</a>
<a name="ln1183">    case ZEBRA_IPV6_ROUTE_DELETE:</a>
<a name="ln1184">      if (zclient-&gt;ipv6_route_delete)</a>
<a name="ln1185">	(*zclient-&gt;ipv6_route_delete) (command, zclient, length, vrf_id);</a>
<a name="ln1186">      break;</a>
<a name="ln1187">    case ZEBRA_INTERFACE_LINK_PARAMS:</a>
<a name="ln1188">      if (zclient-&gt;interface_link_params)</a>
<a name="ln1189">        (*zclient-&gt;interface_link_params) (command, zclient, length);</a>
<a name="ln1190">    case ZEBRA_NEXTHOP_UPDATE:</a>
<a name="ln1191">      if (zclient-&gt;nexthop_update)</a>
<a name="ln1192">	(*zclient-&gt;nexthop_update) (command, zclient, length, vrf_id);</a>
<a name="ln1193">      break;</a>
<a name="ln1194">    default:</a>
<a name="ln1195">      break;</a>
<a name="ln1196">    }</a>
<a name="ln1197"> </a>
<a name="ln1198">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln1199">    /* Connection was closed during packet processing. */</a>
<a name="ln1200">    return -1;</a>
<a name="ln1201"> </a>
<a name="ln1202">  /* Register read thread. */</a>
<a name="ln1203">  stream_reset(zclient-&gt;ibuf);</a>
<a name="ln1204">  zclient_event (ZCLIENT_READ, zclient);</a>
<a name="ln1205"> </a>
<a name="ln1206">  return 0;</a>
<a name="ln1207">}</a>
<a name="ln1208"> </a>
<a name="ln1209">void</a>
<a name="ln1210">zclient_redistribute (int command, struct zclient *zclient, int type,</a>
<a name="ln1211">    vrf_id_t vrf_id)</a>
<a name="ln1212">{</a>
<a name="ln1213"> </a>
<a name="ln1214">  if (command == ZEBRA_REDISTRIBUTE_ADD) </a>
<a name="ln1215">    {</a>
<a name="ln1216">      if (vrf_bitmap_check (zclient-&gt;redist[type], vrf_id))</a>
<a name="ln1217">         return;</a>
<a name="ln1218">      vrf_bitmap_set (zclient-&gt;redist[type], vrf_id);</a>
<a name="ln1219">    }</a>
<a name="ln1220">  else</a>
<a name="ln1221">    {</a>
<a name="ln1222">      if (!vrf_bitmap_check (zclient-&gt;redist[type], vrf_id))</a>
<a name="ln1223">         return;</a>
<a name="ln1224">      vrf_bitmap_unset (zclient-&gt;redist[type], vrf_id);</a>
<a name="ln1225">    }</a>
<a name="ln1226"> </a>
<a name="ln1227">  if (zclient-&gt;sock &gt; 0)</a>
<a name="ln1228">    zebra_redistribute_send (command, zclient, type, vrf_id);</a>
<a name="ln1229">}</a>
<a name="ln1230"> </a>
<a name="ln1231"> </a>
<a name="ln1232">void</a>
<a name="ln1233">zclient_redistribute_default (int command, struct zclient *zclient,</a>
<a name="ln1234">    vrf_id_t vrf_id)</a>
<a name="ln1235">{</a>
<a name="ln1236"> </a>
<a name="ln1237">  if (command == ZEBRA_REDISTRIBUTE_DEFAULT_ADD)</a>
<a name="ln1238">    {</a>
<a name="ln1239">      if (vrf_bitmap_check (zclient-&gt;default_information, vrf_id))</a>
<a name="ln1240">        return;</a>
<a name="ln1241">      vrf_bitmap_set (zclient-&gt;default_information, vrf_id);</a>
<a name="ln1242">    }</a>
<a name="ln1243">  else </a>
<a name="ln1244">    {</a>
<a name="ln1245">      if (!vrf_bitmap_check (zclient-&gt;default_information, vrf_id))</a>
<a name="ln1246">        return;</a>
<a name="ln1247">      vrf_bitmap_unset (zclient-&gt;default_information, vrf_id);</a>
<a name="ln1248">    }</a>
<a name="ln1249"> </a>
<a name="ln1250">  if (zclient-&gt;sock &gt; 0)</a>
<a name="ln1251">    zebra_message_send (zclient, command, vrf_id);</a>
<a name="ln1252">}</a>
<a name="ln1253"> </a>
<a name="ln1254">static void</a>
<a name="ln1255">zclient_event (enum event event, struct zclient *zclient)</a>
<a name="ln1256">{</a>
<a name="ln1257">  switch (event)</a>
<a name="ln1258">    {</a>
<a name="ln1259">    case ZCLIENT_SCHEDULE:</a>
<a name="ln1260">      if (! zclient-&gt;t_connect)</a>
<a name="ln1261">	zclient-&gt;t_connect =</a>
<a name="ln1262">	  thread_add_event (zclient-&gt;master, zclient_connect, zclient, 0);</a>
<a name="ln1263">      break;</a>
<a name="ln1264">    case ZCLIENT_CONNECT:</a>
<a name="ln1265">      if (zclient-&gt;fail &gt;= 10)</a>
<a name="ln1266">	return;</a>
<a name="ln1267">      if (zclient_debug)</a>
<a name="ln1268">	zlog_debug (&quot;zclient connect schedule interval is %d&quot;, </a>
<a name="ln1269">		   zclient-&gt;fail &lt; 3 ? 10 : 60);</a>
<a name="ln1270">      if (! zclient-&gt;t_connect)</a>
<a name="ln1271">	zclient-&gt;t_connect = </a>
<a name="ln1272">	  thread_add_timer (zclient-&gt;master, zclient_connect, zclient,</a>
<a name="ln1273">			    zclient-&gt;fail &lt; 3 ? 10 : 60);</a>
<a name="ln1274">      break;</a>
<a name="ln1275">    case ZCLIENT_READ:</a>
<a name="ln1276">      zclient-&gt;t_read = </a>
<a name="ln1277">	thread_add_read (zclient-&gt;master, zclient_read, zclient, zclient-&gt;sock);</a>
<a name="ln1278">      break;</a>
<a name="ln1279">    }</a>
<a name="ln1280">}</a>
<a name="ln1281"> </a>
<a name="ln1282">const char *zclient_serv_path_get()</a>
<a name="ln1283">{</a>
<a name="ln1284">  return zclient_serv_path ? zclient_serv_path : ZEBRA_SERV_PATH;</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">void</a>
<a name="ln1288">zclient_serv_path_set (char *path)</a>
<a name="ln1289">{</a>
<a name="ln1290">  struct stat sb;</a>
<a name="ln1291"> </a>
<a name="ln1292">  /* reset */</a>
<a name="ln1293">  zclient_serv_path = NULL;</a>
<a name="ln1294"> </a>
<a name="ln1295">  /* test if `path' is socket. don't set it otherwise. */</a>
<a name="ln1296">  if (stat(path, &amp;sb) == -1)</a>
<a name="ln1297">    {</a>
<a name="ln1298">      zlog_warn (&quot;%s: zebra socket `%s' does not exist&quot;, __func__, path);</a>
<a name="ln1299">      return;</a>
<a name="ln1300">    }</a>
<a name="ln1301"> </a>
<a name="ln1302">  if ((sb.st_mode &amp; S_IFMT) != S_IFSOCK)</a>
<a name="ln1303">    {</a>
<a name="ln1304">      zlog_warn (&quot;%s: `%s' is not unix socket, sir&quot;, __func__, path);</a>
<a name="ln1305">      return;</a>
<a name="ln1306">    }</a>
<a name="ln1307"> </a>
<a name="ln1308">  /* it seems that path is unix socket */</a>
<a name="ln1309">  zclient_serv_path = path;</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="1189"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v796/" target="_blank">V796</a> It is possible that 'break' statement is missing in switch statement.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
