
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ripng_route.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * RIPng routes function.</a>
<a name="ln3"> * Copyright (C) 1998 Kunihiro Ishiguro</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.  </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;table.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;if.h&quot;</a>
<a name="ln29">#include &quot;vty.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;ripngd/ripngd.h&quot;</a>
<a name="ln32">#include &quot;ripngd/ripng_route.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">static struct ripng_aggregate *</a>
<a name="ln35">ripng_aggregate_new ()</a>
<a name="ln36">{</a>
<a name="ln37">  struct ripng_aggregate *new;</a>
<a name="ln38"> </a>
<a name="ln39">  new = XCALLOC (MTYPE_RIPNG_AGGREGATE, sizeof (struct ripng_aggregate));</a>
<a name="ln40">  return new;</a>
<a name="ln41">}</a>
<a name="ln42"> </a>
<a name="ln43">void</a>
<a name="ln44">ripng_aggregate_free (struct ripng_aggregate *aggregate)</a>
<a name="ln45">{</a>
<a name="ln46">  XFREE (MTYPE_RIPNG_AGGREGATE, aggregate);</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49">/* Aggregate count increment check. */</a>
<a name="ln50">void</a>
<a name="ln51">ripng_aggregate_increment (struct route_node *child, struct ripng_info *rinfo)</a>
<a name="ln52">{</a>
<a name="ln53">  struct route_node *np;</a>
<a name="ln54">  struct ripng_aggregate *aggregate;</a>
<a name="ln55"> </a>
<a name="ln56">  for (np = child; np; np = np-&gt;parent)</a>
<a name="ln57">    if ((aggregate = np-&gt;aggregate) != NULL)</a>
<a name="ln58">      {</a>
<a name="ln59">	aggregate-&gt;count++;</a>
<a name="ln60">	rinfo-&gt;suppress++;</a>
<a name="ln61">      }</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">/* Aggregate count decrement check. */</a>
<a name="ln65">void</a>
<a name="ln66">ripng_aggregate_decrement (struct route_node *child, struct ripng_info *rinfo)</a>
<a name="ln67">{</a>
<a name="ln68">  struct route_node *np;</a>
<a name="ln69">  struct ripng_aggregate *aggregate;</a>
<a name="ln70"> </a>
<a name="ln71">  for (np = child; np; np = np-&gt;parent)</a>
<a name="ln72">    if ((aggregate = np-&gt;aggregate) != NULL)</a>
<a name="ln73">      {</a>
<a name="ln74">	aggregate-&gt;count--;</a>
<a name="ln75">	rinfo-&gt;suppress--;</a>
<a name="ln76">      }</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">/* Aggregate count decrement check for a list. */</a>
<a name="ln80">void</a>
<a name="ln81">ripng_aggregate_decrement_list (struct route_node *child, struct list *list)</a>
<a name="ln82">{</a>
<a name="ln83">  struct route_node *np;</a>
<a name="ln84">  struct ripng_aggregate *aggregate;</a>
<a name="ln85">  struct ripng_info *rinfo = NULL;</a>
<a name="ln86">  struct listnode *node = NULL;</a>
<a name="ln87"> </a>
<a name="ln88">  for (np = child; np; np = np-&gt;parent)</a>
<a name="ln89">    if ((aggregate = np-&gt;aggregate) != NULL)</a>
<a name="ln90">      aggregate-&gt;count -= listcount (list);</a>
<a name="ln91"> </a>
<a name="ln92">  for (ALL_LIST_ELEMENTS_RO (list, node, rinfo))</a>
<a name="ln93">    rinfo-&gt;suppress--;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">/* RIPng routes treatment. */</a>
<a name="ln97">int</a>
<a name="ln98">ripng_aggregate_add (struct prefix *p)</a>
<a name="ln99">{</a>
<a name="ln100">  struct route_node *top;</a>
<a name="ln101">  struct route_node *rp;</a>
<a name="ln102">  struct ripng_info *rinfo;</a>
<a name="ln103">  struct ripng_aggregate *aggregate;</a>
<a name="ln104">  struct ripng_aggregate *sub;</a>
<a name="ln105">  struct list *list = NULL;</a>
<a name="ln106">  struct listnode *node = NULL;</a>
<a name="ln107"> </a>
<a name="ln108">  /* Get top node for aggregation. */</a>
<a name="ln109">  top = route_node_get (ripng-&gt;table, p);</a>
<a name="ln110"> </a>
<a name="ln111">  /* Allocate new aggregate. */</a>
<a name="ln112">  aggregate = ripng_aggregate_new ();</a>
<a name="ln113">  aggregate-&gt;metric = 1;</a>
<a name="ln114"> </a>
<a name="ln115">  top-&gt;aggregate = aggregate;</a>
<a name="ln116"> </a>
<a name="ln117">  /* Suppress routes match to the aggregate. */</a>
<a name="ln118">  for (rp = route_lock_node (top); rp; rp = route_next_until (rp, top))</a>
<a name="ln119">    {</a>
<a name="ln120">      /* Suppress normal route. */</a>
<a name="ln121">      if ((list = rp-&gt;info) != NULL)</a>
<a name="ln122">        for (ALL_LIST_ELEMENTS_RO (list, node, rinfo))</a>
<a name="ln123">          {</a>
<a name="ln124">            aggregate-&gt;count++;</a>
<a name="ln125">            rinfo-&gt;suppress++;</a>
<a name="ln126">          }</a>
<a name="ln127">      /* Suppress aggregate route.  This may not need. */</a>
<a name="ln128">      if (rp != top &amp;&amp; (sub = rp-&gt;aggregate) != NULL)</a>
<a name="ln129">	{</a>
<a name="ln130">	  aggregate-&gt;count++;</a>
<a name="ln131">	  sub-&gt;suppress++;</a>
<a name="ln132">	}</a>
<a name="ln133">    }</a>
<a name="ln134"> </a>
<a name="ln135">  return 0;</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">/* Delete RIPng static route. */</a>
<a name="ln139">int</a>
<a name="ln140">ripng_aggregate_delete (struct prefix *p)</a>
<a name="ln141">{</a>
<a name="ln142">  struct route_node *top;</a>
<a name="ln143">  struct route_node *rp;</a>
<a name="ln144">  struct ripng_info *rinfo;</a>
<a name="ln145">  struct ripng_aggregate *aggregate;</a>
<a name="ln146">  struct ripng_aggregate *sub;</a>
<a name="ln147">  struct list *list = NULL;</a>
<a name="ln148">  struct listnode *node = NULL;</a>
<a name="ln149"> </a>
<a name="ln150">  /* Get top node for aggregation. */</a>
<a name="ln151">  top = route_node_get (ripng-&gt;table, p);</a>
<a name="ln152"> </a>
<a name="ln153">  /* Allocate new aggregate. */</a>
<a name="ln154">  aggregate = top-&gt;aggregate;</a>
<a name="ln155"> </a>
<a name="ln156">  /* Suppress routes match to the aggregate. */</a>
<a name="ln157">  for (rp = route_lock_node (top); rp; rp = route_next_until (rp, top))</a>
<a name="ln158">    {</a>
<a name="ln159">      /* Suppress normal route. */</a>
<a name="ln160">      if ((list = rp-&gt;info) != NULL)</a>
<a name="ln161">        for (ALL_LIST_ELEMENTS_RO (list, node, rinfo))</a>
<a name="ln162">          {</a>
<a name="ln163">            aggregate-&gt;count--;</a>
<a name="ln164">            rinfo-&gt;suppress--;</a>
<a name="ln165">          }</a>
<a name="ln166"> </a>
<a name="ln167">      if (rp != top &amp;&amp; (sub = rp-&gt;aggregate) != NULL)</a>
<a name="ln168">	{</a>
<a name="ln169">	  aggregate-&gt;count--;</a>
<a name="ln170">	  sub-&gt;suppress--;</a>
<a name="ln171">	}</a>
<a name="ln172">    }</a>
<a name="ln173"> </a>
<a name="ln174">  top-&gt;aggregate = NULL;</a>
<a name="ln175">  ripng_aggregate_free (aggregate);</a>
<a name="ln176"> </a>
<a name="ln177">  route_unlock_node (top);</a>
<a name="ln178">  route_unlock_node (top);</a>
<a name="ln179"> </a>
<a name="ln180">  return 0;</a>
<a name="ln181">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="90"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'list' pointer was utilized before it was verified against nullptr. Check lines: 90, 92.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
