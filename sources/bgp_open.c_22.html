
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_open.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP open message handling</a>
<a name="ln2">   Copyright (C) 1998, 1999 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;linklist.h&quot;</a>
<a name="ln24">#include &quot;prefix.h&quot;</a>
<a name="ln25">#include &quot;stream.h&quot;</a>
<a name="ln26">#include &quot;thread.h&quot;</a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29">#include &quot;memory.h&quot;</a>
<a name="ln30">#include &quot;filter.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln33">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln34">#include &quot;bgpd/bgp_debug.h&quot;</a>
<a name="ln35">#include &quot;bgpd/bgp_fsm.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_packet.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_open.h&quot;</a>
<a name="ln38">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln39">#include &quot;bgpd/bgp_vty.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">/* BGP-4 Multiprotocol Extentions lead us to the complex world. We can</a>
<a name="ln42">   negotiate remote peer supports extentions or not. But if</a>
<a name="ln43">   remote-peer doesn't supports negotiation process itself.  We would</a>
<a name="ln44">   like to do manual configuration.</a>
<a name="ln45"> </a>
<a name="ln46">   So there is many configurable point.  First of all we want set each</a>
<a name="ln47">   peer whether we send capability negotiation to the peer or not.</a>
<a name="ln48">   Next, if we send capability to the peer we want to set my capabilty</a>
<a name="ln49">   inforation at each peer. */</a>
<a name="ln50"> </a>
<a name="ln51">void</a>
<a name="ln52">bgp_capability_vty_out (struct vty *vty, struct peer *peer)</a>
<a name="ln53">{</a>
<a name="ln54">  char *pnt;</a>
<a name="ln55">  char *end;</a>
<a name="ln56">  struct capability_mp_data mpc;</a>
<a name="ln57">  struct capability_header *hdr;</a>
<a name="ln58"> </a>
<a name="ln59">  pnt = peer-&gt;notify.data;</a>
<a name="ln60">  end = pnt + peer-&gt;notify.length;</a>
<a name="ln61">  </a>
<a name="ln62">  while (pnt &lt; end)</a>
<a name="ln63">    {</a>
<a name="ln64">      if (pnt + sizeof (struct capability_mp_data) + 2 &gt; end)</a>
<a name="ln65">	return;</a>
<a name="ln66">      </a>
<a name="ln67">      hdr = (struct capability_header *)pnt;</a>
<a name="ln68">      if (pnt + hdr-&gt;length + 2 &gt; end)</a>
<a name="ln69">	return;</a>
<a name="ln70"> </a>
<a name="ln71">      memcpy (&amp;mpc, pnt + 2, sizeof(struct capability_mp_data));</a>
<a name="ln72"> </a>
<a name="ln73">      if (hdr-&gt;code == CAPABILITY_CODE_MP)</a>
<a name="ln74">	{</a>
<a name="ln75">	  vty_out (vty, &quot;  Capability error for: Multi protocol &quot;);</a>
<a name="ln76"> </a>
<a name="ln77">	  switch (ntohs (mpc.afi))</a>
<a name="ln78">	    {</a>
<a name="ln79">	    case AFI_IP:</a>
<a name="ln80">	      vty_out (vty, &quot;AFI IPv4, &quot;);</a>
<a name="ln81">	      break;</a>
<a name="ln82">	    case AFI_IP6:</a>
<a name="ln83">	      vty_out (vty, &quot;AFI IPv6, &quot;);</a>
<a name="ln84">	      break;</a>
<a name="ln85">	    default:</a>
<a name="ln86">	      vty_out (vty, &quot;AFI Unknown %d, &quot;, ntohs (mpc.afi));</a>
<a name="ln87">	      break;</a>
<a name="ln88">	    }</a>
<a name="ln89">	  switch (mpc.safi)</a>
<a name="ln90">	    {</a>
<a name="ln91">	    case SAFI_UNICAST:</a>
<a name="ln92">	      vty_out (vty, &quot;SAFI Unicast&quot;);</a>
<a name="ln93">	      break;</a>
<a name="ln94">	    case SAFI_MULTICAST:</a>
<a name="ln95">	      vty_out (vty, &quot;SAFI Multicast&quot;);</a>
<a name="ln96">	      break;</a>
<a name="ln97">	    case SAFI_MPLS_LABELED_VPN:</a>
<a name="ln98">	      vty_out (vty, &quot;SAFI MPLS-labeled VPN&quot;);</a>
<a name="ln99">	      break;</a>
<a name="ln100">	    case SAFI_ENCAP:</a>
<a name="ln101">	      vty_out (vty, &quot;SAFI ENCAP&quot;);</a>
<a name="ln102">	      break;</a>
<a name="ln103">	    default:</a>
<a name="ln104">	      vty_out (vty, &quot;SAFI Unknown %d &quot;, mpc.safi);</a>
<a name="ln105">	      break;</a>
<a name="ln106">	    }</a>
<a name="ln107">	  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln108">	}</a>
<a name="ln109">      else if (hdr-&gt;code &gt;= 128)</a>
<a name="ln110">	vty_out (vty, &quot;  Capability error: vendor specific capability code %d&quot;,</a>
<a name="ln111">		 hdr-&gt;code);</a>
<a name="ln112">      else</a>
<a name="ln113">	vty_out (vty, &quot;  Capability error: unknown capability code %d&quot;, </a>
<a name="ln114">		 hdr-&gt;code);</a>
<a name="ln115"> </a>
<a name="ln116">      pnt += hdr-&gt;length + 2;</a>
<a name="ln117">    }</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">static void </a>
<a name="ln121">bgp_capability_mp_data (struct stream *s, struct capability_mp_data *mpc)</a>
<a name="ln122">{</a>
<a name="ln123">  afi_t afi = stream_getw (s);</a>
<a name="ln124">  memcpy(&amp;mpc-&gt;afi, &amp;afi, sizeof(mpc-&gt;afi));</a>
<a name="ln125">  mpc-&gt;reserved = stream_getc (s);</a>
<a name="ln126">  mpc-&gt;safi = stream_getc (s);</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">int</a>
<a name="ln130">bgp_afi_safi_valid_indices (afi_t afi, safi_t *safi)</a>
<a name="ln131">{</a>
<a name="ln132">  switch (afi)</a>
<a name="ln133">    {</a>
<a name="ln134">    case AFI_IP:</a>
<a name="ln135">    case AFI_IP6:</a>
<a name="ln136">      switch (*safi)</a>
<a name="ln137">	{</a>
<a name="ln138">	  /* BGP MPLS-labeled VPN SAFI isn't contigious with others, remap */</a>
<a name="ln139">	case SAFI_MPLS_LABELED_VPN:</a>
<a name="ln140">	  *safi = SAFI_MPLS_VPN;</a>
<a name="ln141">	case SAFI_UNICAST:</a>
<a name="ln142">	case SAFI_MULTICAST:</a>
<a name="ln143">	case SAFI_MPLS_VPN:</a>
<a name="ln144">	case SAFI_ENCAP:</a>
<a name="ln145">	  return 1;</a>
<a name="ln146">	}</a>
<a name="ln147">    case AFI_ETHER:</a>
<a name="ln148">    default:</a>
<a name="ln149">      break;</a>
<a name="ln150">    }</a>
<a name="ln151"> </a>
<a name="ln152">  zlog_debug (&quot;unknown afi/safi (%u/%u)&quot;, afi, *safi);</a>
<a name="ln153"> </a>
<a name="ln154">  return 0;</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">/* Set negotiated capability value. */</a>
<a name="ln158">static int</a>
<a name="ln159">bgp_capability_mp (struct peer *peer, struct capability_header *hdr)</a>
<a name="ln160">{</a>
<a name="ln161">  struct capability_mp_data mpc;</a>
<a name="ln162">  struct stream *s = BGP_INPUT (peer);</a>
<a name="ln163">  </a>
<a name="ln164">  bgp_capability_mp_data (s, &amp;mpc);</a>
<a name="ln165">  </a>
<a name="ln166">  if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln167">    zlog_debug (&quot;%s OPEN has MP_EXT CAP for afi/safi: %u/%u&quot;,</a>
<a name="ln168">               peer-&gt;host, mpc.afi, mpc.safi);</a>
<a name="ln169">  </a>
<a name="ln170">  if (!bgp_afi_safi_valid_indices (mpc.afi, &amp;mpc.safi))</a>
<a name="ln171">    return -1;</a>
<a name="ln172">   </a>
<a name="ln173">  /* Now safi remapped, and afi/safi are valid array indices */</a>
<a name="ln174">  peer-&gt;afc_recv[mpc.afi][mpc.safi] = 1;</a>
<a name="ln175">  </a>
<a name="ln176">  if (peer-&gt;afc[mpc.afi][mpc.safi])</a>
<a name="ln177">    peer-&gt;afc_nego[mpc.afi][mpc.safi] = 1;</a>
<a name="ln178">  else </a>
<a name="ln179">    return -1;</a>
<a name="ln180"> </a>
<a name="ln181">  return 0;</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">static void</a>
<a name="ln185">bgp_capability_orf_not_support (struct peer *peer, afi_t afi, safi_t safi,</a>
<a name="ln186">				u_char type, u_char mode)</a>
<a name="ln187">{</a>
<a name="ln188">  if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln189">    zlog_debug (&quot;%s Addr-family %d/%d has ORF type/mode %d/%d not supported&quot;,</a>
<a name="ln190">	       peer-&gt;host, afi, safi, type, mode);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">static const struct message orf_type_str[] =</a>
<a name="ln194">{</a>
<a name="ln195">  { ORF_TYPE_PREFIX,		&quot;Prefixlist&quot;		},</a>
<a name="ln196">  { ORF_TYPE_PREFIX_OLD,	&quot;Prefixlist (old)&quot;	},</a>
<a name="ln197">};</a>
<a name="ln198">static const int orf_type_str_max = array_size(orf_type_str);</a>
<a name="ln199"> </a>
<a name="ln200">static const struct message orf_mode_str[] =</a>
<a name="ln201">{</a>
<a name="ln202">  { ORF_MODE_RECEIVE,	&quot;Receive&quot;	},</a>
<a name="ln203">  { ORF_MODE_SEND,	&quot;Send&quot;		},</a>
<a name="ln204">  { ORF_MODE_BOTH,	&quot;Both&quot;		},</a>
<a name="ln205">};</a>
<a name="ln206">static const int orf_mode_str_max = array_size(orf_mode_str);</a>
<a name="ln207"> </a>
<a name="ln208">static int</a>
<a name="ln209">bgp_capability_orf_entry (struct peer *peer, struct capability_header *hdr)</a>
<a name="ln210">{</a>
<a name="ln211">  struct stream *s = BGP_INPUT (peer);</a>
<a name="ln212">  struct capability_orf_entry entry;</a>
<a name="ln213">  afi_t afi;</a>
<a name="ln214">  safi_t safi;</a>
<a name="ln215">  u_char type;</a>
<a name="ln216">  u_char mode;</a>
<a name="ln217">  u_int16_t sm_cap = 0; /* capability send-mode receive */</a>
<a name="ln218">  u_int16_t rm_cap = 0; /* capability receive-mode receive */ </a>
<a name="ln219">  int i;</a>
<a name="ln220"> </a>
<a name="ln221">  /* ORF Entry header */</a>
<a name="ln222">  bgp_capability_mp_data (s, &amp;entry.mpc);</a>
<a name="ln223">  entry.num = stream_getc (s);</a>
<a name="ln224">  afi = entry.mpc.afi;</a>
<a name="ln225">  safi = entry.mpc.safi;</a>
<a name="ln226">  </a>
<a name="ln227">  if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln228">    zlog_debug (&quot;%s ORF Cap entry for afi/safi: %u/%u&quot;,</a>
<a name="ln229">	        peer-&gt;host, entry.mpc.afi, entry.mpc.safi);</a>
<a name="ln230"> </a>
<a name="ln231">  /* Check AFI and SAFI. */</a>
<a name="ln232">  if (!bgp_afi_safi_valid_indices (entry.mpc.afi, &amp;safi))</a>
<a name="ln233">    {</a>
<a name="ln234">      zlog_info (&quot;%s Addr-family %d/%d not supported.&quot;</a>
<a name="ln235">                 &quot; Ignoring the ORF capability&quot;,</a>
<a name="ln236">                 peer-&gt;host, entry.mpc.afi, entry.mpc.safi);</a>
<a name="ln237">      return 0;</a>
<a name="ln238">    }</a>
<a name="ln239">  </a>
<a name="ln240">  /* validate number field */</a>
<a name="ln241">  if (CAPABILITY_CODE_ORF_LEN + (entry.num * 2) &gt; hdr-&gt;length)</a>
<a name="ln242">    {</a>
<a name="ln243">      zlog_info (&quot;%s ORF Capability entry length error,&quot;</a>
<a name="ln244">                 &quot; Cap length %u, num %u&quot;,</a>
<a name="ln245">                 peer-&gt;host, hdr-&gt;length, entry.num);</a>
<a name="ln246">      bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR, BGP_NOTIFY_OPEN_UNSPECIFIC);</a>
<a name="ln247">      return -1;</a>
<a name="ln248">    }</a>
<a name="ln249"> </a>
<a name="ln250">  for (i = 0 ; i &lt; entry.num ; i++)</a>
<a name="ln251">    {</a>
<a name="ln252">      type = stream_getc(s);</a>
<a name="ln253">      mode = stream_getc(s);</a>
<a name="ln254">      </a>
<a name="ln255">      /* ORF Mode error check */</a>
<a name="ln256">      switch (mode)</a>
<a name="ln257">        {</a>
<a name="ln258">          case ORF_MODE_BOTH:</a>
<a name="ln259">          case ORF_MODE_SEND:</a>
<a name="ln260">          case ORF_MODE_RECEIVE:</a>
<a name="ln261">            break;</a>
<a name="ln262">          default:</a>
<a name="ln263">	    bgp_capability_orf_not_support (peer, afi, safi, type, mode);</a>
<a name="ln264">	    continue;</a>
<a name="ln265">	}</a>
<a name="ln266">      /* ORF Type and afi/safi error checks */</a>
<a name="ln267">      /* capcode versus type */</a>
<a name="ln268">      switch (hdr-&gt;code)</a>
<a name="ln269">        {</a>
<a name="ln270">          case CAPABILITY_CODE_ORF:</a>
<a name="ln271">            switch (type)</a>
<a name="ln272">              {</a>
<a name="ln273">                case ORF_TYPE_PREFIX:</a>
<a name="ln274">                  break;</a>
<a name="ln275">                default:</a>
<a name="ln276">                  bgp_capability_orf_not_support (peer, afi, safi, type, mode);</a>
<a name="ln277">                  continue;</a>
<a name="ln278">              }</a>
<a name="ln279">            break;</a>
<a name="ln280">          case CAPABILITY_CODE_ORF_OLD:</a>
<a name="ln281">            switch (type)</a>
<a name="ln282">              {</a>
<a name="ln283">                case ORF_TYPE_PREFIX_OLD:</a>
<a name="ln284">                  break;</a>
<a name="ln285">                default:</a>
<a name="ln286">                  bgp_capability_orf_not_support (peer, afi, safi, type, mode);</a>
<a name="ln287">                  continue;</a>
<a name="ln288">              }</a>
<a name="ln289">            break;</a>
<a name="ln290">          default:</a>
<a name="ln291">            bgp_capability_orf_not_support (peer, afi, safi, type, mode);</a>
<a name="ln292">            continue;</a>
<a name="ln293">        }</a>
<a name="ln294">                </a>
<a name="ln295">      /* AFI vs SAFI */</a>
<a name="ln296">      if (!((afi == AFI_IP &amp;&amp; safi == SAFI_UNICAST)</a>
<a name="ln297">            || (afi == AFI_IP &amp;&amp; safi == SAFI_MULTICAST)</a>
<a name="ln298">            || (afi == AFI_IP6 &amp;&amp; safi == SAFI_UNICAST)))</a>
<a name="ln299">        {</a>
<a name="ln300">          bgp_capability_orf_not_support (peer, afi, safi, type, mode);</a>
<a name="ln301">          continue;</a>
<a name="ln302">        }</a>
<a name="ln303">      </a>
<a name="ln304">      if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln305">        zlog_debug (&quot;%s OPEN has %s ORF capability&quot;</a>
<a name="ln306">                    &quot; as %s for afi/safi: %d/%d&quot;,</a>
<a name="ln307">                    peer-&gt;host, LOOKUP (orf_type_str, type),</a>
<a name="ln308">                    LOOKUP (orf_mode_str, mode),</a>
<a name="ln309">                    entry.mpc.afi, safi);</a>
<a name="ln310"> </a>
<a name="ln311">      if (hdr-&gt;code == CAPABILITY_CODE_ORF)</a>
<a name="ln312">	{</a>
<a name="ln313">          sm_cap = PEER_CAP_ORF_PREFIX_SM_RCV;</a>
<a name="ln314">          rm_cap = PEER_CAP_ORF_PREFIX_RM_RCV;</a>
<a name="ln315">	}</a>
<a name="ln316">      else if (hdr-&gt;code == CAPABILITY_CODE_ORF_OLD)</a>
<a name="ln317">	{</a>
<a name="ln318">          sm_cap = PEER_CAP_ORF_PREFIX_SM_OLD_RCV;</a>
<a name="ln319">          rm_cap = PEER_CAP_ORF_PREFIX_RM_OLD_RCV;</a>
<a name="ln320">	}</a>
<a name="ln321">      else</a>
<a name="ln322">	{</a>
<a name="ln323">	  bgp_capability_orf_not_support (peer, afi, safi, type, mode);</a>
<a name="ln324">	  continue;</a>
<a name="ln325">	}</a>
<a name="ln326"> </a>
<a name="ln327">      switch (mode)</a>
<a name="ln328">	{</a>
<a name="ln329">	  case ORF_MODE_BOTH:</a>
<a name="ln330">	    SET_FLAG (peer-&gt;af_cap[afi][safi], sm_cap);</a>
<a name="ln331">	    SET_FLAG (peer-&gt;af_cap[afi][safi], rm_cap);</a>
<a name="ln332">	    break;</a>
<a name="ln333">	  case ORF_MODE_SEND:</a>
<a name="ln334">	    SET_FLAG (peer-&gt;af_cap[afi][safi], sm_cap);</a>
<a name="ln335">	    break;</a>
<a name="ln336">	  case ORF_MODE_RECEIVE:</a>
<a name="ln337">	    SET_FLAG (peer-&gt;af_cap[afi][safi], rm_cap);</a>
<a name="ln338">	    break;</a>
<a name="ln339">	}</a>
<a name="ln340">    }</a>
<a name="ln341">  return 0;</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">static int</a>
<a name="ln345">bgp_capability_restart (struct peer *peer, struct capability_header *caphdr)</a>
<a name="ln346">{</a>
<a name="ln347">  struct stream *s = BGP_INPUT (peer);</a>
<a name="ln348">  u_int16_t restart_flag_time;</a>
<a name="ln349">  size_t end = stream_get_getp (s) + caphdr-&gt;length;</a>
<a name="ln350"> </a>
<a name="ln351">  SET_FLAG (peer-&gt;cap, PEER_CAP_RESTART_RCV);</a>
<a name="ln352">  restart_flag_time = stream_getw(s);</a>
<a name="ln353">  if (CHECK_FLAG (restart_flag_time, RESTART_R_BIT))</a>
<a name="ln354">    SET_FLAG (peer-&gt;cap, PEER_CAP_RESTART_BIT_RCV);</a>
<a name="ln355">  </a>
<a name="ln356">  UNSET_FLAG (restart_flag_time, 0xF000);</a>
<a name="ln357">  peer-&gt;v_gr_restart = restart_flag_time;</a>
<a name="ln358"> </a>
<a name="ln359">  if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln360">    {</a>
<a name="ln361">      zlog_debug (&quot;%s OPEN has Graceful Restart capability&quot;, peer-&gt;host);</a>
<a name="ln362">      zlog_debug (&quot;%s Peer has%srestarted. Restart Time : %d&quot;,</a>
<a name="ln363">                  peer-&gt;host,</a>
<a name="ln364">                  CHECK_FLAG (peer-&gt;cap, PEER_CAP_RESTART_BIT_RCV) ? &quot; &quot; </a>
<a name="ln365">                                                                   : &quot; not &quot;,</a>
<a name="ln366">                  peer-&gt;v_gr_restart);</a>
<a name="ln367">    }</a>
<a name="ln368"> </a>
<a name="ln369">  while (stream_get_getp (s) + 4 &lt;= end)</a>
<a name="ln370">    {</a>
<a name="ln371">      afi_t afi = stream_getw (s);</a>
<a name="ln372">      safi_t safi = stream_getc (s);</a>
<a name="ln373">      u_char flag = stream_getc (s);</a>
<a name="ln374">      </a>
<a name="ln375">      if (!bgp_afi_safi_valid_indices (afi, &amp;safi))</a>
<a name="ln376">        {</a>
<a name="ln377">          if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln378">            zlog_debug (&quot;%s Addr-family %d/%d(afi/safi) not supported.&quot;</a>
<a name="ln379">                        &quot; Ignore the Graceful Restart capability&quot;,</a>
<a name="ln380">                        peer-&gt;host, afi, safi);</a>
<a name="ln381">        }</a>
<a name="ln382">      else if (!peer-&gt;afc[afi][safi])</a>
<a name="ln383">        {</a>
<a name="ln384">          if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln385">            zlog_debug (&quot;%s Addr-family %d/%d(afi/safi) not enabled.&quot;</a>
<a name="ln386">                        &quot; Ignore the Graceful Restart capability&quot;,</a>
<a name="ln387">                        peer-&gt;host, afi, safi);</a>
<a name="ln388">        }</a>
<a name="ln389">      else</a>
<a name="ln390">        {</a>
<a name="ln391">          if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln392">            zlog_debug (&quot;%s Address family %s is%spreserved&quot;, peer-&gt;host,</a>
<a name="ln393">                        afi_safi_print (afi, safi),</a>
<a name="ln394">                        CHECK_FLAG (peer-&gt;af_cap[afi][safi],</a>
<a name="ln395">                                    PEER_CAP_RESTART_AF_PRESERVE_RCV)</a>
<a name="ln396">                        ? &quot; &quot; : &quot; not &quot;);</a>
<a name="ln397"> </a>
<a name="ln398">          SET_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_RESTART_AF_RCV);</a>
<a name="ln399">          if (CHECK_FLAG (flag, RESTART_F_BIT))</a>
<a name="ln400">            SET_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_RESTART_AF_PRESERVE_RCV);</a>
<a name="ln401">          </a>
<a name="ln402">        }</a>
<a name="ln403">    }</a>
<a name="ln404">  return 0;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">static as_t</a>
<a name="ln408">bgp_capability_as4 (struct peer *peer, struct capability_header *hdr)</a>
<a name="ln409">{</a>
<a name="ln410">  SET_FLAG (peer-&gt;cap, PEER_CAP_AS4_RCV);</a>
<a name="ln411">  </a>
<a name="ln412">  if (hdr-&gt;length != CAPABILITY_CODE_AS4_LEN)</a>
<a name="ln413">    {</a>
<a name="ln414">      zlog_err (&quot;%s AS4 capability has incorrect data length %d&quot;,</a>
<a name="ln415">                peer-&gt;host, hdr-&gt;length);</a>
<a name="ln416">      return 0;</a>
<a name="ln417">    }</a>
<a name="ln418">  </a>
<a name="ln419">  as_t as4 = stream_getl (BGP_INPUT(peer));</a>
<a name="ln420">  </a>
<a name="ln421">  if (BGP_DEBUG (as4, AS4))</a>
<a name="ln422">    zlog_debug (&quot;%s [AS4] about to set cap PEER_CAP_AS4_RCV, got as4 %u&quot;,</a>
<a name="ln423">                peer-&gt;host, as4);</a>
<a name="ln424">  return as4;</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">static const struct message capcode_str[] =</a>
<a name="ln428">{</a>
<a name="ln429">  { CAPABILITY_CODE_MP,			&quot;MultiProtocol Extensions&quot;	},</a>
<a name="ln430">  { CAPABILITY_CODE_REFRESH,		&quot;Route Refresh&quot;			},</a>
<a name="ln431">  { CAPABILITY_CODE_ORF,		&quot;Cooperative Route Filtering&quot; 	},</a>
<a name="ln432">  { CAPABILITY_CODE_RESTART,		&quot;Graceful Restart&quot;		},</a>
<a name="ln433">  { CAPABILITY_CODE_AS4,		&quot;4-octet AS number&quot;		},</a>
<a name="ln434">  { CAPABILITY_CODE_DYNAMIC,		&quot;Dynamic&quot;			},</a>
<a name="ln435">  { CAPABILITY_CODE_REFRESH_OLD,	&quot;Route Refresh (Old)&quot;		},</a>
<a name="ln436">  { CAPABILITY_CODE_ORF_OLD,		&quot;ORF (Old)&quot;			},</a>
<a name="ln437">};</a>
<a name="ln438">static const int capcode_str_max = array_size(capcode_str);</a>
<a name="ln439"> </a>
<a name="ln440">/* Minimum sizes for length field of each cap (so not inc. the header) */</a>
<a name="ln441">static const size_t cap_minsizes[] = </a>
<a name="ln442">{</a>
<a name="ln443">  [CAPABILITY_CODE_MP]		= CAPABILITY_CODE_MP_LEN,</a>
<a name="ln444">  [CAPABILITY_CODE_REFRESH]	= CAPABILITY_CODE_REFRESH_LEN,</a>
<a name="ln445">  [CAPABILITY_CODE_ORF]		= CAPABILITY_CODE_ORF_LEN,</a>
<a name="ln446">  [CAPABILITY_CODE_RESTART]	= CAPABILITY_CODE_RESTART_LEN,</a>
<a name="ln447">  [CAPABILITY_CODE_AS4]		= CAPABILITY_CODE_AS4_LEN,</a>
<a name="ln448">  [CAPABILITY_CODE_DYNAMIC]	= CAPABILITY_CODE_DYNAMIC_LEN,</a>
<a name="ln449">  [CAPABILITY_CODE_REFRESH_OLD]	= CAPABILITY_CODE_REFRESH_LEN,</a>
<a name="ln450">  [CAPABILITY_CODE_ORF_OLD]	= CAPABILITY_CODE_ORF_LEN,</a>
<a name="ln451">};</a>
<a name="ln452"> </a>
<a name="ln453">/* value the capability must be a multiple of.</a>
<a name="ln454"> * 0-data capabilities won't be checked against this.</a>
<a name="ln455"> * Other capabilities whose data doesn't fall on convenient boundaries for this</a>
<a name="ln456"> * table should be set to 1.</a>
<a name="ln457"> */</a>
<a name="ln458">static const size_t cap_modsizes[] =</a>
<a name="ln459">{</a>
<a name="ln460">  [CAPABILITY_CODE_MP]          = 4,</a>
<a name="ln461">  [CAPABILITY_CODE_REFRESH]     = 1,</a>
<a name="ln462">  [CAPABILITY_CODE_ORF]         = 1,</a>
<a name="ln463">  [CAPABILITY_CODE_RESTART]     = 1,</a>
<a name="ln464">  [CAPABILITY_CODE_AS4]         = 4,</a>
<a name="ln465">  [CAPABILITY_CODE_DYNAMIC]     = 1,</a>
<a name="ln466">  [CAPABILITY_CODE_REFRESH_OLD] = 1,</a>
<a name="ln467">  [CAPABILITY_CODE_ORF_OLD]     = 1,</a>
<a name="ln468">};</a>
<a name="ln469"> </a>
<a name="ln470">/**</a>
<a name="ln471"> * Parse given capability.</a>
<a name="ln472"> * XXX: This is reading into a stream, but not using stream API</a>
<a name="ln473"> *</a>
<a name="ln474"> * @param[out] mp_capability Set to 1 on return iff one or more Multiprotocol</a>
<a name="ln475"> *                           capabilities were encountered.</a>
<a name="ln476"> */</a>
<a name="ln477">static int</a>
<a name="ln478">bgp_capability_parse (struct peer *peer, size_t length, int *mp_capability,</a>
<a name="ln479">		      u_char **error)</a>
<a name="ln480">{</a>
<a name="ln481">  int ret;</a>
<a name="ln482">  struct stream *s = BGP_INPUT (peer);</a>
<a name="ln483">  size_t end = stream_get_getp (s) + length;</a>
<a name="ln484">  </a>
<a name="ln485">  assert (STREAM_READABLE (s) &gt;= length);</a>
<a name="ln486">  </a>
<a name="ln487">  while (stream_get_getp (s) &lt; end)</a>
<a name="ln488">    {</a>
<a name="ln489">      size_t start;</a>
<a name="ln490">      u_char *sp = stream_pnt (s);</a>
<a name="ln491">      struct capability_header caphdr;</a>
<a name="ln492">      </a>
<a name="ln493">      /* We need at least capability code and capability length. */</a>
<a name="ln494">      if (stream_get_getp(s) + 2 &gt; end)</a>
<a name="ln495">	{</a>
<a name="ln496">	  zlog_info (&quot;%s Capability length error (&lt; header)&quot;, peer-&gt;host);</a>
<a name="ln497">	  bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR, BGP_NOTIFY_OPEN_UNSPECIFIC);</a>
<a name="ln498">	  return -1;</a>
<a name="ln499">	}</a>
<a name="ln500">      </a>
<a name="ln501">      caphdr.code = stream_getc (s);</a>
<a name="ln502">      caphdr.length = stream_getc (s);</a>
<a name="ln503">      start = stream_get_getp (s);</a>
<a name="ln504">      </a>
<a name="ln505">      /* Capability length check sanity check. */</a>
<a name="ln506">      if (start + caphdr.length &gt; end)</a>
<a name="ln507">	{</a>
<a name="ln508">	  zlog_info (&quot;%s Capability length error (&lt; length)&quot;, peer-&gt;host);</a>
<a name="ln509">	  bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR, BGP_NOTIFY_OPEN_UNSPECIFIC);</a>
<a name="ln510">	  return -1;</a>
<a name="ln511">	}</a>
<a name="ln512">      </a>
<a name="ln513">      if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln514">	zlog_debug (&quot;%s OPEN has %s capability (%u), length %u&quot;,</a>
<a name="ln515">		   peer-&gt;host,</a>
<a name="ln516">		   LOOKUP (capcode_str, caphdr.code),</a>
<a name="ln517">		   caphdr.code, caphdr.length);</a>
<a name="ln518">      </a>
<a name="ln519">      /* Length sanity check, type-specific, for known capabilities */</a>
<a name="ln520">      switch (caphdr.code)</a>
<a name="ln521">        {</a>
<a name="ln522">          case CAPABILITY_CODE_MP:</a>
<a name="ln523">          case CAPABILITY_CODE_REFRESH:</a>
<a name="ln524">          case CAPABILITY_CODE_REFRESH_OLD:</a>
<a name="ln525">          case CAPABILITY_CODE_ORF:</a>
<a name="ln526">          case CAPABILITY_CODE_ORF_OLD:</a>
<a name="ln527">          case CAPABILITY_CODE_RESTART:</a>
<a name="ln528">          case CAPABILITY_CODE_AS4:</a>
<a name="ln529">          case CAPABILITY_CODE_DYNAMIC:</a>
<a name="ln530">              /* Check length. */</a>
<a name="ln531">              if (caphdr.length &lt; cap_minsizes[caphdr.code])</a>
<a name="ln532">                {</a>
<a name="ln533">                  zlog_info (&quot;%s %s Capability length error: got %u,&quot;</a>
<a name="ln534">                             &quot; expected at least %u&quot;,</a>
<a name="ln535">                             peer-&gt;host, </a>
<a name="ln536">                             LOOKUP (capcode_str, caphdr.code),</a>
<a name="ln537">                             caphdr.length, </a>
<a name="ln538">			     (unsigned) cap_minsizes[caphdr.code]);</a>
<a name="ln539">                  bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,</a>
<a name="ln540">                                  BGP_NOTIFY_OPEN_UNSPECIFIC);</a>
<a name="ln541">                  return -1;</a>
<a name="ln542">                }</a>
<a name="ln543">              if (caphdr.length</a>
<a name="ln544">                  &amp;&amp; caphdr.length % cap_modsizes[caphdr.code] != 0)</a>
<a name="ln545">                {</a>
<a name="ln546">                  zlog_info (&quot;%s %s Capability length error: got %u,&quot;</a>
<a name="ln547">                             &quot; expected a multiple of %u&quot;,</a>
<a name="ln548">                             peer-&gt;host,</a>
<a name="ln549">                             LOOKUP (capcode_str, caphdr.code),</a>
<a name="ln550">                             caphdr.length,</a>
<a name="ln551">			     (unsigned) cap_modsizes[caphdr.code]);</a>
<a name="ln552">                  bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,</a>
<a name="ln553">                                         BGP_NOTIFY_OPEN_UNSPECIFIC);</a>
<a name="ln554">                  return -1;</a>
<a name="ln555">                }</a>
<a name="ln556">          /* we deliberately ignore unknown codes, see below */</a>
<a name="ln557">          default:</a>
<a name="ln558">            break;</a>
<a name="ln559">        }</a>
<a name="ln560">      </a>
<a name="ln561">      switch (caphdr.code)</a>
<a name="ln562">        {</a>
<a name="ln563">          case CAPABILITY_CODE_MP:</a>
<a name="ln564">            {</a>
<a name="ln565">	      *mp_capability = 1;</a>
<a name="ln566"> </a>
<a name="ln567">              /* Ignore capability when override-capability is set. */</a>
<a name="ln568">              if (! CHECK_FLAG (peer-&gt;flags, PEER_FLAG_OVERRIDE_CAPABILITY))</a>
<a name="ln569">                {</a>
<a name="ln570">                  /* Set negotiated value. */</a>
<a name="ln571">                  ret = bgp_capability_mp (peer, &amp;caphdr);</a>
<a name="ln572"> </a>
<a name="ln573">                  /* Unsupported Capability. */</a>
<a name="ln574">                  if (ret &lt; 0)</a>
<a name="ln575">                    {</a>
<a name="ln576">                      /* Store return data. */</a>
<a name="ln577">                      memcpy (*error, sp, caphdr.length + 2);</a>
<a name="ln578">                      *error += caphdr.length + 2;</a>
<a name="ln579">                    }</a>
<a name="ln580">                }</a>
<a name="ln581">            }</a>
<a name="ln582">            break;</a>
<a name="ln583">          case CAPABILITY_CODE_REFRESH:</a>
<a name="ln584">          case CAPABILITY_CODE_REFRESH_OLD:</a>
<a name="ln585">            {</a>
<a name="ln586">              /* BGP refresh capability */</a>
<a name="ln587">              if (caphdr.code == CAPABILITY_CODE_REFRESH_OLD)</a>
<a name="ln588">                SET_FLAG (peer-&gt;cap, PEER_CAP_REFRESH_OLD_RCV);</a>
<a name="ln589">              else</a>
<a name="ln590">                SET_FLAG (peer-&gt;cap, PEER_CAP_REFRESH_NEW_RCV);</a>
<a name="ln591">            }</a>
<a name="ln592">            break;</a>
<a name="ln593">          case CAPABILITY_CODE_ORF:</a>
<a name="ln594">          case CAPABILITY_CODE_ORF_OLD:</a>
<a name="ln595">            if (bgp_capability_orf_entry (peer, &amp;caphdr))</a>
<a name="ln596">              return -1;</a>
<a name="ln597">            break;</a>
<a name="ln598">          case CAPABILITY_CODE_RESTART:</a>
<a name="ln599">            if (bgp_capability_restart (peer, &amp;caphdr))</a>
<a name="ln600">              return -1;</a>
<a name="ln601">            break;</a>
<a name="ln602">          case CAPABILITY_CODE_DYNAMIC:</a>
<a name="ln603">            SET_FLAG (peer-&gt;cap, PEER_CAP_DYNAMIC_RCV);</a>
<a name="ln604">            break;</a>
<a name="ln605">          case CAPABILITY_CODE_AS4:</a>
<a name="ln606">              /* Already handled as a special-case parsing of the capabilities</a>
<a name="ln607">               * at the beginning of OPEN processing. So we care not a jot</a>
<a name="ln608">               * for the value really, only error case.</a>
<a name="ln609">               */</a>
<a name="ln610">              if (!bgp_capability_as4 (peer, &amp;caphdr))</a>
<a name="ln611">                return -1;</a>
<a name="ln612">              break;            </a>
<a name="ln613">          default:</a>
<a name="ln614">            if (caphdr.code &gt; 128)</a>
<a name="ln615">              {</a>
<a name="ln616">                /* We don't send Notification for unknown vendor specific</a>
<a name="ln617">                   capabilities.  It seems reasonable for now...  */</a>
<a name="ln618">                zlog_warn (&quot;%s Vendor specific capability %d&quot;,</a>
<a name="ln619">                           peer-&gt;host, caphdr.code);</a>
<a name="ln620">              }</a>
<a name="ln621">            else</a>
<a name="ln622">              {</a>
<a name="ln623">                zlog_warn (&quot;%s unrecognized capability code: %d - ignored&quot;,</a>
<a name="ln624">                           peer-&gt;host, caphdr.code);</a>
<a name="ln625">                memcpy (*error, sp, caphdr.length + 2);</a>
<a name="ln626">                *error += caphdr.length + 2;</a>
<a name="ln627">              }</a>
<a name="ln628">          }</a>
<a name="ln629">      if (stream_get_getp(s) != (start + caphdr.length))</a>
<a name="ln630">        {</a>
<a name="ln631">          if (stream_get_getp(s) &gt; (start + caphdr.length))</a>
<a name="ln632">            zlog_warn (&quot;%s Cap-parser for %s read past cap-length, %u!&quot;,</a>
<a name="ln633">                       peer-&gt;host, LOOKUP (capcode_str, caphdr.code),</a>
<a name="ln634">                       caphdr.length);</a>
<a name="ln635">          stream_set_getp (s, start + caphdr.length);</a>
<a name="ln636">        }</a>
<a name="ln637">    }</a>
<a name="ln638">  return 0;</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">static int</a>
<a name="ln642">bgp_auth_parse (struct peer *peer, size_t length)</a>
<a name="ln643">{</a>
<a name="ln644">  bgp_notify_send (peer, </a>
<a name="ln645">		   BGP_NOTIFY_OPEN_ERR, </a>
<a name="ln646">		   BGP_NOTIFY_OPEN_AUTH_FAILURE); </a>
<a name="ln647">  return -1;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">static int</a>
<a name="ln651">strict_capability_same (struct peer *peer)</a>
<a name="ln652">{</a>
<a name="ln653">  int i, j;</a>
<a name="ln654"> </a>
<a name="ln655">  for (i = AFI_IP; i &lt; AFI_MAX; i++)</a>
<a name="ln656">    for (j = SAFI_UNICAST; j &lt; SAFI_MAX; j++)</a>
<a name="ln657">      if (peer-&gt;afc[i][j] != peer-&gt;afc_nego[i][j])</a>
<a name="ln658">	return 0;</a>
<a name="ln659">  return 1;</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">/* peek into option, stores ASN to *as4 if the AS4 capability was found.</a>
<a name="ln663"> * Returns  0 if no as4 found, as4cap value otherwise.</a>
<a name="ln664"> */</a>
<a name="ln665">as_t</a>
<a name="ln666">peek_for_as4_capability (struct peer *peer, u_char length)</a>
<a name="ln667">{</a>
<a name="ln668">  struct stream *s = BGP_INPUT (peer);</a>
<a name="ln669">  size_t orig_getp = stream_get_getp (s);</a>
<a name="ln670">  size_t end = orig_getp + length;</a>
<a name="ln671">  as_t as4 = 0;</a>
<a name="ln672">  </a>
<a name="ln673">  /* The full capability parser will better flag the error.. */</a>
<a name="ln674">  if (STREAM_READABLE(s) &lt; length)</a>
<a name="ln675">    return 0;</a>
<a name="ln676"> </a>
<a name="ln677">  if (BGP_DEBUG (as4, AS4))</a>
<a name="ln678">    zlog_info (&quot;%s [AS4] rcv OPEN w/ OPTION parameter len: %u,&quot;</a>
<a name="ln679">                &quot; peeking for as4&quot;,</a>
<a name="ln680">	        peer-&gt;host, length);</a>
<a name="ln681">  /* the error cases we DONT handle, we ONLY try to read as4 out of</a>
<a name="ln682">   * correctly formatted options.</a>
<a name="ln683">   */</a>
<a name="ln684">  while (stream_get_getp(s) &lt; end) </a>
<a name="ln685">    {</a>
<a name="ln686">      u_char opt_type;</a>
<a name="ln687">      u_char opt_length;</a>
<a name="ln688">      </a>
<a name="ln689">      /* Check the length. */</a>
<a name="ln690">      if (stream_get_getp (s) + 2 &gt; end)</a>
<a name="ln691">        goto end;</a>
<a name="ln692">      </a>
<a name="ln693">      /* Fetch option type and length. */</a>
<a name="ln694">      opt_type = stream_getc (s);</a>
<a name="ln695">      opt_length = stream_getc (s);</a>
<a name="ln696">      </a>
<a name="ln697">      /* Option length check. */</a>
<a name="ln698">      if (stream_get_getp (s) + opt_length &gt; end)</a>
<a name="ln699">        goto end;</a>
<a name="ln700">      </a>
<a name="ln701">      if (opt_type == BGP_OPEN_OPT_CAP)</a>
<a name="ln702">        {</a>
<a name="ln703">          unsigned long capd_start = stream_get_getp (s);</a>
<a name="ln704">          unsigned long capd_end = capd_start + opt_length;</a>
<a name="ln705">          </a>
<a name="ln706">          assert (capd_end &lt;= end);</a>
<a name="ln707">          </a>
<a name="ln708">	  while (stream_get_getp (s) &lt; capd_end)</a>
<a name="ln709">	    {</a>
<a name="ln710">	      struct capability_header hdr;</a>
<a name="ln711">	      </a>
<a name="ln712">	      if (stream_get_getp (s) + 2 &gt; capd_end)</a>
<a name="ln713">                goto end;</a>
<a name="ln714">              </a>
<a name="ln715">              hdr.code = stream_getc (s);</a>
<a name="ln716">              hdr.length = stream_getc (s);</a>
<a name="ln717">              </a>
<a name="ln718">	      if ((stream_get_getp(s) +  hdr.length) &gt; capd_end)</a>
<a name="ln719">		goto end;</a>
<a name="ln720"> </a>
<a name="ln721">	      if (hdr.code == CAPABILITY_CODE_AS4)</a>
<a name="ln722">	        {</a>
<a name="ln723">	          if (BGP_DEBUG (as4, AS4))</a>
<a name="ln724">	            zlog_info (&quot;[AS4] found AS4 capability, about to parse&quot;);</a>
<a name="ln725">	          as4 = bgp_capability_as4 (peer, &amp;hdr);</a>
<a name="ln726">	          </a>
<a name="ln727">	          goto end;</a>
<a name="ln728">                }</a>
<a name="ln729">              stream_forward_getp (s, hdr.length);</a>
<a name="ln730">	    }</a>
<a name="ln731">	}</a>
<a name="ln732">    }</a>
<a name="ln733"> </a>
<a name="ln734">end:</a>
<a name="ln735">  stream_set_getp (s, orig_getp);</a>
<a name="ln736">  return as4;</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">/**</a>
<a name="ln740"> * Parse open option.</a>
<a name="ln741"> *</a>
<a name="ln742"> * @param[out] mp_capability @see bgp_capability_parse() for semantics.</a>
<a name="ln743"> */</a>
<a name="ln744">int</a>
<a name="ln745">bgp_open_option_parse (struct peer *peer, u_char length, int *mp_capability)</a>
<a name="ln746">{</a>
<a name="ln747">  int ret;</a>
<a name="ln748">  u_char *error;</a>
<a name="ln749">  u_char error_data[BGP_MAX_PACKET_SIZE];</a>
<a name="ln750">  struct stream *s = BGP_INPUT(peer);</a>
<a name="ln751">  size_t end = stream_get_getp (s) + length;</a>
<a name="ln752"> </a>
<a name="ln753">  ret = 0;</a>
<a name="ln754">  error = error_data;</a>
<a name="ln755"> </a>
<a name="ln756">  if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln757">    zlog_debug (&quot;%s rcv OPEN w/ OPTION parameter len: %u&quot;,</a>
<a name="ln758">	       peer-&gt;host, length);</a>
<a name="ln759">  </a>
<a name="ln760">  while (stream_get_getp(s) &lt; end)</a>
<a name="ln761">    {</a>
<a name="ln762">      u_char opt_type;</a>
<a name="ln763">      u_char opt_length;</a>
<a name="ln764">      </a>
<a name="ln765">      /* Must have at least an OPEN option header */</a>
<a name="ln766">      if (STREAM_READABLE(s) &lt; 2)</a>
<a name="ln767">	{</a>
<a name="ln768">	  zlog_info (&quot;%s Option length error&quot;, peer-&gt;host);</a>
<a name="ln769">	  bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,</a>
<a name="ln770">	                         BGP_NOTIFY_OPEN_UNSPECIFIC);</a>
<a name="ln771">	  return -1;</a>
<a name="ln772">	}</a>
<a name="ln773"> </a>
<a name="ln774">      /* Fetch option type and length. */</a>
<a name="ln775">      opt_type = stream_getc (s);</a>
<a name="ln776">      opt_length = stream_getc (s);</a>
<a name="ln777">      </a>
<a name="ln778">      /* Option length check. */</a>
<a name="ln779">      if (STREAM_READABLE (s) &lt; opt_length)</a>
<a name="ln780">	{</a>
<a name="ln781">	  zlog_info (&quot;%s Option length error&quot;, peer-&gt;host);</a>
<a name="ln782">	  bgp_notify_send (peer, BGP_NOTIFY_OPEN_ERR,</a>
<a name="ln783">	                         BGP_NOTIFY_OPEN_UNSPECIFIC);</a>
<a name="ln784">	  return -1;</a>
<a name="ln785">	}</a>
<a name="ln786"> </a>
<a name="ln787">      if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln788">	zlog_debug (&quot;%s rcvd OPEN w/ optional parameter type %u (%s) len %u&quot;,</a>
<a name="ln789">		   peer-&gt;host, opt_type,</a>
<a name="ln790">		   opt_type == BGP_OPEN_OPT_AUTH ? &quot;Authentication&quot; :</a>
<a name="ln791">		   opt_type == BGP_OPEN_OPT_CAP ? &quot;Capability&quot; : &quot;Unknown&quot;,</a>
<a name="ln792">		   opt_length);</a>
<a name="ln793">  </a>
<a name="ln794">      switch (opt_type)</a>
<a name="ln795">	{</a>
<a name="ln796">	case BGP_OPEN_OPT_AUTH:</a>
<a name="ln797">	  ret = bgp_auth_parse (peer, opt_length);</a>
<a name="ln798">	  break;</a>
<a name="ln799">	case BGP_OPEN_OPT_CAP:</a>
<a name="ln800">	  ret = bgp_capability_parse (peer, opt_length, mp_capability, &amp;error);</a>
<a name="ln801">	  break;</a>
<a name="ln802">	default:</a>
<a name="ln803">	  bgp_notify_send (peer, </a>
<a name="ln804">			   BGP_NOTIFY_OPEN_ERR, </a>
<a name="ln805">			   BGP_NOTIFY_OPEN_UNSUP_PARAM); </a>
<a name="ln806">	  ret = -1;</a>
<a name="ln807">	  break;</a>
<a name="ln808">	}</a>
<a name="ln809"> </a>
<a name="ln810">      /* Parse error.  To accumulate all unsupported capability codes,</a>
<a name="ln811">         bgp_capability_parse does not return -1 when encounter</a>
<a name="ln812">         unsupported capability code.  To detect that, please check</a>
<a name="ln813">         error and erro_data pointer, like below.  */</a>
<a name="ln814">      if (ret &lt; 0)</a>
<a name="ln815">	return -1;</a>
<a name="ln816">    }</a>
<a name="ln817"> </a>
<a name="ln818">  /* All OPEN option is parsed.  Check capability when strict compare</a>
<a name="ln819">     flag is enabled.*/</a>
<a name="ln820">  if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_STRICT_CAP_MATCH))</a>
<a name="ln821">    {</a>
<a name="ln822">      /* If Unsupported Capability exists. */</a>
<a name="ln823">      if (error != error_data)</a>
<a name="ln824">	{</a>
<a name="ln825">	  bgp_notify_send_with_data (peer, </a>
<a name="ln826">				     BGP_NOTIFY_OPEN_ERR, </a>
<a name="ln827">				     BGP_NOTIFY_OPEN_UNSUP_CAPBL, </a>
<a name="ln828">				     error_data, error - error_data);</a>
<a name="ln829">	  return -1;</a>
<a name="ln830">	}</a>
<a name="ln831"> </a>
<a name="ln832">      /* Check local capability does not negotiated with remote</a>
<a name="ln833">         peer. */</a>
<a name="ln834">      if (! strict_capability_same (peer))</a>
<a name="ln835">	{</a>
<a name="ln836">	  bgp_notify_send (peer, </a>
<a name="ln837">			   BGP_NOTIFY_OPEN_ERR, </a>
<a name="ln838">			   BGP_NOTIFY_OPEN_UNSUP_CAPBL);</a>
<a name="ln839">	  return -1;</a>
<a name="ln840">	}</a>
<a name="ln841">    }</a>
<a name="ln842"> </a>
<a name="ln843">  /* Check there are no common AFI/SAFIs and send Unsupported Capability</a>
<a name="ln844">     error. */</a>
<a name="ln845">  if (*mp_capability &amp;&amp;</a>
<a name="ln846">      ! CHECK_FLAG (peer-&gt;flags, PEER_FLAG_OVERRIDE_CAPABILITY))</a>
<a name="ln847">    {</a>
<a name="ln848">      if (! peer-&gt;afc_nego[AFI_IP][SAFI_UNICAST] </a>
<a name="ln849">	  &amp;&amp; ! peer-&gt;afc_nego[AFI_IP][SAFI_MULTICAST]</a>
<a name="ln850">	  &amp;&amp; ! peer-&gt;afc_nego[AFI_IP][SAFI_MPLS_VPN]</a>
<a name="ln851">	  &amp;&amp; ! peer-&gt;afc_nego[AFI_IP][SAFI_ENCAP]</a>
<a name="ln852">	  &amp;&amp; ! peer-&gt;afc_nego[AFI_IP6][SAFI_UNICAST]</a>
<a name="ln853">	  &amp;&amp; ! peer-&gt;afc_nego[AFI_IP6][SAFI_MULTICAST]</a>
<a name="ln854">	  &amp;&amp; ! peer-&gt;afc_nego[AFI_IP6][SAFI_MPLS_VPN]</a>
<a name="ln855">	  &amp;&amp; ! peer-&gt;afc_nego[AFI_IP6][SAFI_ENCAP])</a>
<a name="ln856">	{</a>
<a name="ln857">	  plog_err (peer-&gt;log, &quot;%s [Error] Configured AFI/SAFIs do not &quot;</a>
<a name="ln858">		    &quot;overlap with received MP capabilities&quot;,</a>
<a name="ln859">		    peer-&gt;host);</a>
<a name="ln860"> </a>
<a name="ln861">	  if (error != error_data)</a>
<a name="ln862"> </a>
<a name="ln863">	    bgp_notify_send_with_data (peer, </a>
<a name="ln864">				       BGP_NOTIFY_OPEN_ERR, </a>
<a name="ln865">				       BGP_NOTIFY_OPEN_UNSUP_CAPBL, </a>
<a name="ln866">				       error_data, error - error_data);</a>
<a name="ln867">	  else</a>
<a name="ln868">	    bgp_notify_send (peer, </a>
<a name="ln869">			     BGP_NOTIFY_OPEN_ERR, </a>
<a name="ln870">			     BGP_NOTIFY_OPEN_UNSUP_CAPBL);</a>
<a name="ln871">	  return -1;</a>
<a name="ln872">	}</a>
<a name="ln873">    }</a>
<a name="ln874">  return 0;</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">static void</a>
<a name="ln878">bgp_open_capability_orf (struct stream *s, struct peer *peer,</a>
<a name="ln879">                         afi_t afi, safi_t safi, u_char code)</a>
<a name="ln880">{</a>
<a name="ln881">  u_char cap_len;</a>
<a name="ln882">  u_char orf_len;</a>
<a name="ln883">  unsigned long capp;</a>
<a name="ln884">  unsigned long orfp;</a>
<a name="ln885">  unsigned long numberp;</a>
<a name="ln886">  int number_of_orfs = 0;</a>
<a name="ln887"> </a>
<a name="ln888">  if (safi == SAFI_MPLS_VPN)</a>
<a name="ln889">    safi = SAFI_MPLS_LABELED_VPN;</a>
<a name="ln890"> </a>
<a name="ln891">  stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln892">  capp = stream_get_endp (s);           /* Set Capability Len Pointer */</a>
<a name="ln893">  stream_putc (s, 0);                   /* Capability Length */</a>
<a name="ln894">  stream_putc (s, code);                /* Capability Code */</a>
<a name="ln895">  orfp = stream_get_endp (s);           /* Set ORF Len Pointer */</a>
<a name="ln896">  stream_putc (s, 0);                   /* ORF Length */</a>
<a name="ln897">  stream_putw (s, afi);</a>
<a name="ln898">  stream_putc (s, 0);</a>
<a name="ln899">  stream_putc (s, safi);</a>
<a name="ln900">  numberp = stream_get_endp (s);        /* Set Number Pointer */</a>
<a name="ln901">  stream_putc (s, 0);                   /* Number of ORFs */</a>
<a name="ln902"> </a>
<a name="ln903">  /* Address Prefix ORF */</a>
<a name="ln904">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)</a>
<a name="ln905">      || CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))</a>
<a name="ln906">    {</a>
<a name="ln907">      stream_putc (s, (code == CAPABILITY_CODE_ORF ?</a>
<a name="ln908">		   ORF_TYPE_PREFIX : ORF_TYPE_PREFIX_OLD));</a>
<a name="ln909"> </a>
<a name="ln910">      if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)</a>
<a name="ln911">	  &amp;&amp; CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))</a>
<a name="ln912">	{</a>
<a name="ln913">	  SET_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV);</a>
<a name="ln914">	  SET_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV);</a>
<a name="ln915">	  stream_putc (s, ORF_MODE_BOTH);</a>
<a name="ln916">	}</a>
<a name="ln917">      else if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM))</a>
<a name="ln918">	{</a>
<a name="ln919">	  SET_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_ORF_PREFIX_SM_ADV);</a>
<a name="ln920">	  stream_putc (s, ORF_MODE_SEND);</a>
<a name="ln921">	}</a>
<a name="ln922">      else</a>
<a name="ln923">	{</a>
<a name="ln924">	  SET_FLAG (peer-&gt;af_cap[afi][safi], PEER_CAP_ORF_PREFIX_RM_ADV);</a>
<a name="ln925">	  stream_putc (s, ORF_MODE_RECEIVE);</a>
<a name="ln926">	}</a>
<a name="ln927">      number_of_orfs++;</a>
<a name="ln928">    }</a>
<a name="ln929"> </a>
<a name="ln930">  /* Total Number of ORFs. */</a>
<a name="ln931">  stream_putc_at (s, numberp, number_of_orfs);</a>
<a name="ln932"> </a>
<a name="ln933">  /* Total ORF Len. */</a>
<a name="ln934">  orf_len = stream_get_endp (s) - orfp - 1;</a>
<a name="ln935">  stream_putc_at (s, orfp, orf_len);</a>
<a name="ln936"> </a>
<a name="ln937">  /* Total Capability Len. */</a>
<a name="ln938">  cap_len = stream_get_endp (s) - capp - 1;</a>
<a name="ln939">  stream_putc_at (s, capp, cap_len);</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">/* Fill in capability open option to the packet. */</a>
<a name="ln943">void</a>
<a name="ln944">bgp_open_capability (struct stream *s, struct peer *peer)</a>
<a name="ln945">{</a>
<a name="ln946">  u_char len;</a>
<a name="ln947">  unsigned long cp, capp, rcapp;</a>
<a name="ln948">  afi_t afi;</a>
<a name="ln949">  safi_t safi;</a>
<a name="ln950">  as_t local_as;</a>
<a name="ln951">  u_int32_t restart_time;</a>
<a name="ln952"> </a>
<a name="ln953">  /* Remember current pointer for Opt Parm Len. */</a>
<a name="ln954">  cp = stream_get_endp (s);</a>
<a name="ln955"> </a>
<a name="ln956">  /* Opt Parm Len. */</a>
<a name="ln957">  stream_putc (s, 0);</a>
<a name="ln958"> </a>
<a name="ln959">  /* Do not send capability. */</a>
<a name="ln960">  if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_CAPABILITY_OPEN) </a>
<a name="ln961">      || CHECK_FLAG (peer-&gt;flags, PEER_FLAG_DONT_CAPABILITY))</a>
<a name="ln962">    return;</a>
<a name="ln963"> </a>
<a name="ln964">  /* IPv4 unicast. */</a>
<a name="ln965">  if (peer-&gt;afc[AFI_IP][SAFI_UNICAST])</a>
<a name="ln966">    {</a>
<a name="ln967">      peer-&gt;afc_adv[AFI_IP][SAFI_UNICAST] = 1;</a>
<a name="ln968">      stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln969">      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);</a>
<a name="ln970">      stream_putc (s, CAPABILITY_CODE_MP);</a>
<a name="ln971">      stream_putc (s, CAPABILITY_CODE_MP_LEN);</a>
<a name="ln972">      stream_putw (s, AFI_IP);</a>
<a name="ln973">      stream_putc (s, 0);</a>
<a name="ln974">      stream_putc (s, SAFI_UNICAST);</a>
<a name="ln975">    }</a>
<a name="ln976">  /* IPv4 multicast. */</a>
<a name="ln977">  if (peer-&gt;afc[AFI_IP][SAFI_MULTICAST])</a>
<a name="ln978">    {</a>
<a name="ln979">      peer-&gt;afc_adv[AFI_IP][SAFI_MULTICAST] = 1;</a>
<a name="ln980">      stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln981">      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);</a>
<a name="ln982">      stream_putc (s, CAPABILITY_CODE_MP);</a>
<a name="ln983">      stream_putc (s, CAPABILITY_CODE_MP_LEN);</a>
<a name="ln984">      stream_putw (s, AFI_IP);</a>
<a name="ln985">      stream_putc (s, 0);</a>
<a name="ln986">      stream_putc (s, SAFI_MULTICAST);</a>
<a name="ln987">    }</a>
<a name="ln988">  /* IPv4 VPN */</a>
<a name="ln989">  if (peer-&gt;afc[AFI_IP][SAFI_MPLS_VPN])</a>
<a name="ln990">    {</a>
<a name="ln991">      peer-&gt;afc_adv[AFI_IP][SAFI_MPLS_VPN] = 1;</a>
<a name="ln992">      stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln993">      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);</a>
<a name="ln994">      stream_putc (s, CAPABILITY_CODE_MP);</a>
<a name="ln995">      stream_putc (s, CAPABILITY_CODE_MP_LEN);</a>
<a name="ln996">      stream_putw (s, AFI_IP);</a>
<a name="ln997">      stream_putc (s, 0);</a>
<a name="ln998">      stream_putc (s, SAFI_MPLS_LABELED_VPN);</a>
<a name="ln999">    }</a>
<a name="ln1000">  /* ENCAP */</a>
<a name="ln1001">  if (peer-&gt;afc[AFI_IP][SAFI_ENCAP])</a>
<a name="ln1002">    {</a>
<a name="ln1003">      peer-&gt;afc_adv[AFI_IP][SAFI_ENCAP] = 1;</a>
<a name="ln1004">      stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1005">      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);</a>
<a name="ln1006">      stream_putc (s, CAPABILITY_CODE_MP);</a>
<a name="ln1007">      stream_putc (s, CAPABILITY_CODE_MP_LEN);</a>
<a name="ln1008">      stream_putw (s, AFI_IP);</a>
<a name="ln1009">      stream_putc (s, 0);</a>
<a name="ln1010">      stream_putc (s, SAFI_ENCAP);</a>
<a name="ln1011">    }</a>
<a name="ln1012">  /* IPv6 unicast. */</a>
<a name="ln1013">  if (peer-&gt;afc[AFI_IP6][SAFI_UNICAST])</a>
<a name="ln1014">    {</a>
<a name="ln1015">      peer-&gt;afc_adv[AFI_IP6][SAFI_UNICAST] = 1;</a>
<a name="ln1016">      stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1017">      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);</a>
<a name="ln1018">      stream_putc (s, CAPABILITY_CODE_MP);</a>
<a name="ln1019">      stream_putc (s, CAPABILITY_CODE_MP_LEN);</a>
<a name="ln1020">      stream_putw (s, AFI_IP6);</a>
<a name="ln1021">      stream_putc (s, 0);</a>
<a name="ln1022">      stream_putc (s, SAFI_UNICAST);</a>
<a name="ln1023">    }</a>
<a name="ln1024">  /* IPv6 multicast. */</a>
<a name="ln1025">  if (peer-&gt;afc[AFI_IP6][SAFI_MULTICAST])</a>
<a name="ln1026">    {</a>
<a name="ln1027">      peer-&gt;afc_adv[AFI_IP6][SAFI_MULTICAST] = 1;</a>
<a name="ln1028">      stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1029">      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);</a>
<a name="ln1030">      stream_putc (s, CAPABILITY_CODE_MP);</a>
<a name="ln1031">      stream_putc (s, CAPABILITY_CODE_MP_LEN);</a>
<a name="ln1032">      stream_putw (s, AFI_IP6);</a>
<a name="ln1033">      stream_putc (s, 0);</a>
<a name="ln1034">      stream_putc (s, SAFI_MULTICAST);</a>
<a name="ln1035">    }</a>
<a name="ln1036">  /* IPv6 VPN. */</a>
<a name="ln1037">  if (peer-&gt;afc[AFI_IP6][SAFI_MPLS_VPN])</a>
<a name="ln1038">    {</a>
<a name="ln1039">      peer-&gt;afc_adv[AFI_IP6][SAFI_MPLS_VPN] = 1;</a>
<a name="ln1040">      stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1041">      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);</a>
<a name="ln1042">      stream_putc (s, CAPABILITY_CODE_MP);</a>
<a name="ln1043">      stream_putc (s, CAPABILITY_CODE_MP_LEN);</a>
<a name="ln1044">      stream_putw (s, AFI_IP6);</a>
<a name="ln1045">      stream_putc (s, 0);</a>
<a name="ln1046">      stream_putc (s, SAFI_MPLS_LABELED_VPN);</a>
<a name="ln1047">    }</a>
<a name="ln1048">  /* IPv6 ENCAP. */</a>
<a name="ln1049">  if (peer-&gt;afc[AFI_IP6][SAFI_ENCAP])</a>
<a name="ln1050">    {</a>
<a name="ln1051">      peer-&gt;afc_adv[AFI_IP6][SAFI_ENCAP] = 1;</a>
<a name="ln1052">      stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1053">      stream_putc (s, CAPABILITY_CODE_MP_LEN + 2);</a>
<a name="ln1054">      stream_putc (s, CAPABILITY_CODE_MP);</a>
<a name="ln1055">      stream_putc (s, CAPABILITY_CODE_MP_LEN);</a>
<a name="ln1056">      stream_putw (s, AFI_IP6);</a>
<a name="ln1057">      stream_putc (s, 0);</a>
<a name="ln1058">      stream_putc (s, SAFI_ENCAP);</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061">  /* Route refresh. */</a>
<a name="ln1062">  SET_FLAG (peer-&gt;cap, PEER_CAP_REFRESH_ADV);</a>
<a name="ln1063">  stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1064">  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN + 2);</a>
<a name="ln1065">  stream_putc (s, CAPABILITY_CODE_REFRESH_OLD);</a>
<a name="ln1066">  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN);</a>
<a name="ln1067">  stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1068">  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN + 2);</a>
<a name="ln1069">  stream_putc (s, CAPABILITY_CODE_REFRESH);</a>
<a name="ln1070">  stream_putc (s, CAPABILITY_CODE_REFRESH_LEN);</a>
<a name="ln1071"> </a>
<a name="ln1072">  /* AS4 */</a>
<a name="ln1073">  SET_FLAG (peer-&gt;cap, PEER_CAP_AS4_ADV);</a>
<a name="ln1074">  stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1075">  stream_putc (s, CAPABILITY_CODE_AS4_LEN + 2);</a>
<a name="ln1076">  stream_putc (s, CAPABILITY_CODE_AS4);</a>
<a name="ln1077">  stream_putc (s, CAPABILITY_CODE_AS4_LEN);</a>
<a name="ln1078">  if ( peer-&gt;change_local_as )</a>
<a name="ln1079">    local_as = peer-&gt;change_local_as;</a>
<a name="ln1080">  else</a>
<a name="ln1081">    local_as = peer-&gt;local_as;</a>
<a name="ln1082">  stream_putl (s, local_as );</a>
<a name="ln1083"> </a>
<a name="ln1084">  /* ORF capability. */</a>
<a name="ln1085">  for (afi = AFI_IP ; afi &lt; AFI_MAX ; afi++)</a>
<a name="ln1086">    for (safi = SAFI_UNICAST ; safi &lt; SAFI_MAX ; safi++)</a>
<a name="ln1087">      if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_SM)</a>
<a name="ln1088">	  || CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_ORF_PREFIX_RM))</a>
<a name="ln1089">	{</a>
<a name="ln1090">	  bgp_open_capability_orf (s, peer, afi, safi, CAPABILITY_CODE_ORF_OLD);</a>
<a name="ln1091">	  bgp_open_capability_orf (s, peer, afi, safi, CAPABILITY_CODE_ORF);</a>
<a name="ln1092">	}</a>
<a name="ln1093"> </a>
<a name="ln1094">  /* Dynamic capability. */</a>
<a name="ln1095">  if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_DYNAMIC_CAPABILITY))</a>
<a name="ln1096">    {</a>
<a name="ln1097">      SET_FLAG (peer-&gt;cap, PEER_CAP_DYNAMIC_ADV);</a>
<a name="ln1098">      stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1099">      stream_putc (s, CAPABILITY_CODE_DYNAMIC_LEN + 2);</a>
<a name="ln1100">      stream_putc (s, CAPABILITY_CODE_DYNAMIC);</a>
<a name="ln1101">      stream_putc (s, CAPABILITY_CODE_DYNAMIC_LEN);</a>
<a name="ln1102">    }</a>
<a name="ln1103"> </a>
<a name="ln1104">  /* Sending base graceful-restart capability irrespective of the config */</a>
<a name="ln1105">  SET_FLAG (peer-&gt;cap, PEER_CAP_RESTART_ADV);</a>
<a name="ln1106">  stream_putc (s, BGP_OPEN_OPT_CAP);</a>
<a name="ln1107">  capp = stream_get_endp (s);           /* Set Capability Len Pointer */</a>
<a name="ln1108">  stream_putc (s, 0);                   /* Capability Length */</a>
<a name="ln1109">  stream_putc (s, CAPABILITY_CODE_RESTART);</a>
<a name="ln1110">  rcapp = stream_get_endp (s);          /* Set Restart Capability Len Pointer */</a>
<a name="ln1111">  stream_putc (s, 0);</a>
<a name="ln1112">  restart_time = peer-&gt;bgp-&gt;restart_time;</a>
<a name="ln1113">  if (peer-&gt;bgp-&gt;t_startup)</a>
<a name="ln1114">    {</a>
<a name="ln1115">      SET_FLAG (restart_time, RESTART_R_BIT);</a>
<a name="ln1116">      SET_FLAG (peer-&gt;cap, PEER_CAP_RESTART_BIT_ADV);</a>
<a name="ln1117">    }</a>
<a name="ln1118">  stream_putw (s, restart_time);</a>
<a name="ln1119"> </a>
<a name="ln1120">  /* Send address-family specific graceful-restart capability only when GR config</a>
<a name="ln1121">     is present */</a>
<a name="ln1122">  if (bgp_flag_check (peer-&gt;bgp, BGP_FLAG_GRACEFUL_RESTART))</a>
<a name="ln1123">    {</a>
<a name="ln1124">      for (afi = AFI_IP ; afi &lt; AFI_MAX ; afi++)</a>
<a name="ln1125">        for (safi = SAFI_UNICAST ; safi &lt; SAFI_MAX ; safi++)</a>
<a name="ln1126">          if (peer-&gt;afc[afi][safi])</a>
<a name="ln1127">            {</a>
<a name="ln1128">              stream_putw (s, afi);</a>
<a name="ln1129">              stream_putc (s, safi);</a>
<a name="ln1130">              stream_putc (s, 0); //Forwarding is not retained as of now.</a>
<a name="ln1131">            }</a>
<a name="ln1132">    }</a>
<a name="ln1133"> </a>
<a name="ln1134">  /* Total Graceful restart capability Len. */</a>
<a name="ln1135">  len = stream_get_endp (s) - rcapp - 1;</a>
<a name="ln1136">  stream_putc_at (s, rcapp, len);</a>
<a name="ln1137"> </a>
<a name="ln1138">  /* Total Capability Len. */</a>
<a name="ln1139">  len = stream_get_endp (s) - capp - 1;</a>
<a name="ln1140">  stream_putc_at (s, capp, len);</a>
<a name="ln1141"> </a>
<a name="ln1142">  /* Total Opt Parm Len. */</a>
<a name="ln1143">  len = stream_get_endp (s) - cp - 1;</a>
<a name="ln1144">  stream_putc_at (s, cp, len);</a>
<a name="ln1145">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="316"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'hdr->code == 130' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
