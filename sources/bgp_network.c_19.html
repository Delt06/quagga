
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_network.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP network related fucntions</a>
<a name="ln2">   Copyright (C) 1999 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;thread.h&quot;</a>
<a name="ln24">#include &quot;sockunion.h&quot;</a>
<a name="ln25">#include &quot;sockopt.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &quot;if.h&quot;</a>
<a name="ln29">#include &quot;prefix.h&quot;</a>
<a name="ln30">#include &quot;command.h&quot;</a>
<a name="ln31">#include &quot;privs.h&quot;</a>
<a name="ln32">#include &quot;linklist.h&quot;</a>
<a name="ln33">#include &quot;network.h&quot;</a>
<a name="ln34">#include &quot;filter.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_fsm.h&quot;</a>
<a name="ln38">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln39">#include &quot;bgpd/bgp_debug.h&quot;</a>
<a name="ln40">#include &quot;bgpd/bgp_network.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">extern struct zebra_privs_t bgpd_privs;</a>
<a name="ln43"> </a>
<a name="ln44">/* BGP listening socket. */</a>
<a name="ln45">struct bgp_listener</a>
<a name="ln46">{</a>
<a name="ln47">  int fd;</a>
<a name="ln48">  union sockunion su;</a>
<a name="ln49">  struct thread *thread;</a>
<a name="ln50">};</a>
<a name="ln51"> </a>
<a name="ln52">/*</a>
<a name="ln53"> * Set MD5 key for the socket, for the given IPv4 peer address.</a>
<a name="ln54"> * If the password is NULL or zero-length, the option will be disabled.</a>
<a name="ln55"> */</a>
<a name="ln56">static int</a>
<a name="ln57">bgp_md5_set_socket (int socket, union sockunion *su, const char *password)</a>
<a name="ln58">{</a>
<a name="ln59">  int ret = -1;</a>
<a name="ln60">  int en = ENOSYS;</a>
<a name="ln61">  </a>
<a name="ln62">  assert (socket &gt;= 0);</a>
<a name="ln63">  </a>
<a name="ln64">#if HAVE_DECL_TCP_MD5SIG  </a>
<a name="ln65">  ret = sockopt_tcp_signature (socket, su, password);</a>
<a name="ln66">  en  = errno;</a>
<a name="ln67">#endif /* HAVE_TCP_MD5SIG */</a>
<a name="ln68">  </a>
<a name="ln69">  if (ret &lt; 0)</a>
<a name="ln70">    zlog (NULL, LOG_WARNING, &quot;can't set TCP_MD5SIG option on socket %d: %s&quot;,</a>
<a name="ln71">          socket, safe_strerror (en));</a>
<a name="ln72"> </a>
<a name="ln73">  return ret;</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">/* Helper for bgp_connect */</a>
<a name="ln77">static int</a>
<a name="ln78">bgp_md5_set_connect (int socket, union sockunion *su, const char *password)</a>
<a name="ln79">{</a>
<a name="ln80">  int ret = -1;</a>
<a name="ln81"> </a>
<a name="ln82">#if HAVE_DECL_TCP_MD5SIG  </a>
<a name="ln83">  if ( bgpd_privs.change (ZPRIVS_RAISE) )</a>
<a name="ln84">    {</a>
<a name="ln85">      zlog_err (&quot;%s: could not raise privs&quot;, __func__);</a>
<a name="ln86">      return ret;</a>
<a name="ln87">    }</a>
<a name="ln88">  </a>
<a name="ln89">  ret = bgp_md5_set_socket (socket, su, password);</a>
<a name="ln90"> </a>
<a name="ln91">  if (bgpd_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln92">    zlog_err (&quot;%s: could not lower privs&quot;, __func__);</a>
<a name="ln93">#endif /* HAVE_TCP_MD5SIG */</a>
<a name="ln94">  </a>
<a name="ln95">  return ret;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">int</a>
<a name="ln99">bgp_md5_set (struct peer *peer)</a>
<a name="ln100">{</a>
<a name="ln101">  struct listnode *node;</a>
<a name="ln102">  int ret = 0;</a>
<a name="ln103">  struct bgp_listener *listener;</a>
<a name="ln104"> </a>
<a name="ln105">  if ( bgpd_privs.change (ZPRIVS_RAISE) )</a>
<a name="ln106">    {</a>
<a name="ln107">      zlog_err (&quot;%s: could not raise privs&quot;, __func__);</a>
<a name="ln108">      return -1;</a>
<a name="ln109">    }</a>
<a name="ln110">  </a>
<a name="ln111">  /* Just set the password on the listen socket(s). Outbound connections</a>
<a name="ln112">   * are taken care of in bgp_connect() below.</a>
<a name="ln113">   */</a>
<a name="ln114">  for (ALL_LIST_ELEMENTS_RO(bm-&gt;listen_sockets, node, listener))</a>
<a name="ln115">    if (listener-&gt;su.sa.sa_family == peer-&gt;su.sa.sa_family)</a>
<a name="ln116">      {</a>
<a name="ln117">	ret = bgp_md5_set_socket (listener-&gt;fd, &amp;peer-&gt;su, peer-&gt;password);</a>
<a name="ln118">	break;</a>
<a name="ln119">      }</a>
<a name="ln120"> </a>
<a name="ln121">  if (bgpd_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln122">    zlog_err (&quot;%s: could not lower privs&quot;, __func__);</a>
<a name="ln123">  </a>
<a name="ln124">  return ret;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">/* Update BGP socket send buffer size */</a>
<a name="ln128">static void</a>
<a name="ln129">bgp_update_sock_send_buffer_size (int fd)</a>
<a name="ln130">{</a>
<a name="ln131">  int size = BGP_SOCKET_SNDBUF_SIZE;</a>
<a name="ln132">  int optval;</a>
<a name="ln133">  socklen_t optlen = sizeof(optval);</a>
<a name="ln134"> </a>
<a name="ln135">  if (getsockopt(fd, SOL_SOCKET, SO_SNDBUF, &amp;optval, &amp;optlen) &lt; 0)</a>
<a name="ln136">    {</a>
<a name="ln137">      zlog_err(&quot;getsockopt of SO_SNDBUF failed %s\n&quot;, safe_strerror(errno));</a>
<a name="ln138">      return;</a>
<a name="ln139">    }</a>
<a name="ln140">  if (optval &lt; size)</a>
<a name="ln141">    {</a>
<a name="ln142">      if (setsockopt(fd, SOL_SOCKET, SO_SNDBUF, &amp;size, sizeof(size)) &lt; 0)</a>
<a name="ln143">        {</a>
<a name="ln144">          zlog_err(&quot;Couldn't increase send buffer: %s\n&quot;, safe_strerror(errno));</a>
<a name="ln145">        }</a>
<a name="ln146">    }</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">void</a>
<a name="ln150">bgp_set_socket_ttl (struct peer *peer, int bgp_sock)</a>
<a name="ln151">{</a>
<a name="ln152">  char buf[INET_ADDRSTRLEN];</a>
<a name="ln153">  int ret, ttl, minttl;</a>
<a name="ln154"> </a>
<a name="ln155">  if (bgp_sock &lt; 0)</a>
<a name="ln156">    return;</a>
<a name="ln157"> </a>
<a name="ln158">  if (peer-&gt;gtsm_hops)</a>
<a name="ln159">    {</a>
<a name="ln160">      ttl = 255;</a>
<a name="ln161">      minttl = 256 - peer-&gt;gtsm_hops;</a>
<a name="ln162">    }</a>
<a name="ln163">  else</a>
<a name="ln164">    {</a>
<a name="ln165">      ttl = peer_ttl (peer);</a>
<a name="ln166">      minttl = 0;</a>
<a name="ln167">    }</a>
<a name="ln168"> </a>
<a name="ln169">  ret = sockopt_ttl (peer-&gt;su.sa.sa_family, bgp_sock, ttl);</a>
<a name="ln170">  if (ret)</a>
<a name="ln171">    zlog_err (&quot;%s: Can't set TxTTL on peer (rtrid %s) socket, err = %d&quot;,</a>
<a name="ln172">              __func__,</a>
<a name="ln173">              inet_ntop (AF_INET, &amp;peer-&gt;remote_id, buf, sizeof(buf)),</a>
<a name="ln174">              errno);</a>
<a name="ln175"> </a>
<a name="ln176">  ret = sockopt_minttl (peer-&gt;su.sa.sa_family, bgp_sock, minttl);</a>
<a name="ln177">  if (ret &amp;&amp; (errno != ENOTSUP || minttl))</a>
<a name="ln178">    zlog_err (&quot;%s: Can't set MinTTL on peer (rtrid %s) socket, err = %d&quot;,</a>
<a name="ln179">              __func__,</a>
<a name="ln180">              inet_ntop (AF_INET, &amp;peer-&gt;remote_id, buf, sizeof(buf)),</a>
<a name="ln181">              errno);</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">/* Accept bgp connection. */</a>
<a name="ln185">static int</a>
<a name="ln186">bgp_accept (struct thread *thread)</a>
<a name="ln187">{</a>
<a name="ln188">  int bgp_sock;</a>
<a name="ln189">  int accept_sock;</a>
<a name="ln190">  union sockunion su;</a>
<a name="ln191">  struct bgp_listener *listener = THREAD_ARG(thread);</a>
<a name="ln192">  struct peer *peer;</a>
<a name="ln193">  struct peer *peer1;</a>
<a name="ln194">  char buf[SU_ADDRSTRLEN];</a>
<a name="ln195"> </a>
<a name="ln196">  /* Register accept thread. */</a>
<a name="ln197">  accept_sock = THREAD_FD (thread);</a>
<a name="ln198">  if (accept_sock &lt; 0)</a>
<a name="ln199">    {</a>
<a name="ln200">      zlog_err (&quot;accept_sock is nevative value %d&quot;, accept_sock);</a>
<a name="ln201">      return -1;</a>
<a name="ln202">    }</a>
<a name="ln203">  listener-&gt;thread = thread_add_read (bm-&gt;master, bgp_accept, listener, accept_sock);</a>
<a name="ln204"> </a>
<a name="ln205">  /* Accept client connection. */</a>
<a name="ln206">  bgp_sock = sockunion_accept (accept_sock, &amp;su);</a>
<a name="ln207">  if (bgp_sock &lt; 0)</a>
<a name="ln208">    {</a>
<a name="ln209">      zlog_err (&quot;[Error] BGP socket accept failed (%s)&quot;, safe_strerror (errno));</a>
<a name="ln210">      return -1;</a>
<a name="ln211">    }</a>
<a name="ln212">  set_nonblocking (bgp_sock);</a>
<a name="ln213"> </a>
<a name="ln214">  /* Set socket send buffer size */</a>
<a name="ln215">  bgp_update_sock_send_buffer_size(bgp_sock);</a>
<a name="ln216"> </a>
<a name="ln217">  if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln218">    zlog_debug (&quot;[Event] BGP connection from host %s:%d&quot;, </a>
<a name="ln219">                inet_sutop (&amp;su, buf), sockunion_get_port (&amp;su));</a>
<a name="ln220">  </a>
<a name="ln221">  /* Check remote IP address */</a>
<a name="ln222">  peer1 = peer_lookup (NULL, &amp;su);</a>
<a name="ln223">  /* We could perhaps just drop new connections from already Established</a>
<a name="ln224">   * peers here.</a>
<a name="ln225">   */</a>
<a name="ln226">  if (! peer1 || peer1-&gt;status == Idle || peer1-&gt;status &gt; Established)</a>
<a name="ln227">    {</a>
<a name="ln228">      if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln229">	{</a>
<a name="ln230">	  if (! peer1)</a>
<a name="ln231">	    zlog_debug (&quot;[Event] BGP connection IP address %s is not configured&quot;,</a>
<a name="ln232">		       inet_sutop (&amp;su, buf));</a>
<a name="ln233">	  else</a>
<a name="ln234">	    zlog_debug (&quot;[Event] BGP connection IP address %s is %s state&quot;,</a>
<a name="ln235">		       inet_sutop (&amp;su, buf),</a>
<a name="ln236">		       LOOKUP (bgp_status_msg, peer1-&gt;status));</a>
<a name="ln237">	}</a>
<a name="ln238">      close (bgp_sock);</a>
<a name="ln239">      return -1;</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">  bgp_set_socket_ttl (peer1, bgp_sock);</a>
<a name="ln243"> </a>
<a name="ln244">  /* Make dummy peer until read Open packet. */</a>
<a name="ln245">  if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln246">    zlog_debug (&quot;[Event] Make dummy peer structure until read Open packet&quot;);</a>
<a name="ln247"> </a>
<a name="ln248">  {</a>
<a name="ln249">    char buf[SU_ADDRSTRLEN];</a>
<a name="ln250"> </a>
<a name="ln251">    peer = peer_create_accept (peer1-&gt;bgp);</a>
<a name="ln252">    peer-&gt;su = su;</a>
<a name="ln253">    peer-&gt;fd = bgp_sock;</a>
<a name="ln254">    peer-&gt;status = Active;</a>
<a name="ln255"> </a>
<a name="ln256">    /* Config state that should affect OPEN packet must be copied over */</a>
<a name="ln257">    peer-&gt;local_id = peer1-&gt;local_id;</a>
<a name="ln258">    peer-&gt;v_holdtime = peer1-&gt;v_holdtime;</a>
<a name="ln259">    peer-&gt;v_keepalive = peer1-&gt;v_keepalive;</a>
<a name="ln260">    peer-&gt;local_as = peer1-&gt;local_as;</a>
<a name="ln261">    peer-&gt;change_local_as = peer1-&gt;change_local_as;</a>
<a name="ln262">    peer-&gt;flags = peer1-&gt;flags;</a>
<a name="ln263">    peer-&gt;sflags = peer1-&gt;sflags;</a>
<a name="ln264">  #define PEER_ARRAY_COPY(D,S,A) \</a>
<a name="ln265">    memcpy ((D)-&gt;A, (S)-&gt;A, sizeof (((D)-&gt;A)[0][0])*AFI_MAX*SAFI_MAX);</a>
<a name="ln266">    PEER_ARRAY_COPY(peer, peer1, afc);</a>
<a name="ln267">    PEER_ARRAY_COPY(peer, peer1, af_flags);</a>
<a name="ln268">  #undef PEER_ARRAY_COPY</a>
<a name="ln269">  </a>
<a name="ln270">    /* Make peer's address string. */</a>
<a name="ln271">    sockunion2str (&amp;su, buf, SU_ADDRSTRLEN);</a>
<a name="ln272">    peer-&gt;host = XSTRDUP (MTYPE_BGP_PEER_HOST, buf);</a>
<a name="ln273">    </a>
<a name="ln274">    SET_FLAG (peer-&gt;sflags, PEER_STATUS_ACCEPT_PEER);</a>
<a name="ln275">  }</a>
<a name="ln276"> </a>
<a name="ln277">  BGP_EVENT_ADD (peer, TCP_connection_open);</a>
<a name="ln278"> </a>
<a name="ln279">  return 0;</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">/* BGP socket bind. */</a>
<a name="ln283">static int</a>
<a name="ln284">bgp_bind (struct peer *peer)</a>
<a name="ln285">{</a>
<a name="ln286">#ifdef SO_BINDTODEVICE</a>
<a name="ln287">  int ret;</a>
<a name="ln288">  struct ifreq ifreq;</a>
<a name="ln289">  int myerrno;</a>
<a name="ln290"> </a>
<a name="ln291">  if (! peer-&gt;ifname)</a>
<a name="ln292">    return 0;</a>
<a name="ln293"> </a>
<a name="ln294">  strncpy ((char *)&amp;ifreq.ifr_name, peer-&gt;ifname, sizeof (ifreq.ifr_name));</a>
<a name="ln295"> </a>
<a name="ln296">  if ( bgpd_privs.change (ZPRIVS_RAISE) )</a>
<a name="ln297">  	zlog_err (&quot;bgp_bind: could not raise privs&quot;);</a>
<a name="ln298">  </a>
<a name="ln299">  ret = setsockopt (peer-&gt;fd, SOL_SOCKET, SO_BINDTODEVICE, </a>
<a name="ln300">		    &amp;ifreq, sizeof (ifreq));</a>
<a name="ln301">  myerrno = errno;</a>
<a name="ln302">  </a>
<a name="ln303">  if (bgpd_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln304">    zlog_err (&quot;bgp_bind: could not lower privs&quot;);</a>
<a name="ln305"> </a>
<a name="ln306">  if (ret &lt; 0)</a>
<a name="ln307">    {</a>
<a name="ln308">      zlog (peer-&gt;log, LOG_INFO, &quot;bind to interface %s failed, errno=%d&quot;,</a>
<a name="ln309">            peer-&gt;ifname, myerrno);</a>
<a name="ln310">      return ret;</a>
<a name="ln311">    }</a>
<a name="ln312">#endif /* SO_BINDTODEVICE */</a>
<a name="ln313">  return 0;</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">static int</a>
<a name="ln317">bgp_update_address (struct interface *ifp, const union sockunion *dst,</a>
<a name="ln318">		    union sockunion *addr)</a>
<a name="ln319">{</a>
<a name="ln320">  struct prefix *p, *sel, d;</a>
<a name="ln321">  struct connected *connected;</a>
<a name="ln322">  struct listnode *node;</a>
<a name="ln323">  int common;</a>
<a name="ln324"> </a>
<a name="ln325">  sockunion2hostprefix (dst, &amp;d);</a>
<a name="ln326">  sel = NULL;</a>
<a name="ln327">  common = -1;</a>
<a name="ln328"> </a>
<a name="ln329">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, node, connected))</a>
<a name="ln330">    {</a>
<a name="ln331">      p = connected-&gt;address;</a>
<a name="ln332">      if (p-&gt;family != d.family)</a>
<a name="ln333">	continue;</a>
<a name="ln334">      if (prefix_common_bits (p, &amp;d) &gt; common)</a>
<a name="ln335">	{</a>
<a name="ln336">	  sel = p;</a>
<a name="ln337">	  common = prefix_common_bits (sel, &amp;d);</a>
<a name="ln338">	}</a>
<a name="ln339">    }</a>
<a name="ln340"> </a>
<a name="ln341">  if (!sel)</a>
<a name="ln342">    return 1;</a>
<a name="ln343"> </a>
<a name="ln344">  prefix2sockunion (sel, addr);</a>
<a name="ln345">  return 0;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">/* Update source selection.  */</a>
<a name="ln349">static void</a>
<a name="ln350">bgp_update_source (struct peer *peer)</a>
<a name="ln351">{</a>
<a name="ln352">  struct interface *ifp;</a>
<a name="ln353">  union sockunion addr;</a>
<a name="ln354"> </a>
<a name="ln355">  /* Source is specified with interface name.  */</a>
<a name="ln356">  if (peer-&gt;update_if)</a>
<a name="ln357">    {</a>
<a name="ln358">      ifp = if_lookup_by_name (peer-&gt;update_if);</a>
<a name="ln359">      if (! ifp)</a>
<a name="ln360">	return;</a>
<a name="ln361"> </a>
<a name="ln362">      if (bgp_update_address (ifp, &amp;peer-&gt;su, &amp;addr))</a>
<a name="ln363">	return;</a>
<a name="ln364"> </a>
<a name="ln365">      sockunion_bind (peer-&gt;fd, &amp;addr, 0, &amp;addr);</a>
<a name="ln366">    }</a>
<a name="ln367"> </a>
<a name="ln368">  /* Source is specified with IP address.  */</a>
<a name="ln369">  if (peer-&gt;update_source)</a>
<a name="ln370">    sockunion_bind (peer-&gt;fd, peer-&gt;update_source, 0, peer-&gt;update_source);</a>
<a name="ln371">}</a>
<a name="ln372"> </a>
<a name="ln373">/* BGP try to connect to the peer.  */</a>
<a name="ln374">int</a>
<a name="ln375">bgp_connect (struct peer *peer)</a>
<a name="ln376">{</a>
<a name="ln377">  ifindex_t ifindex = 0;</a>
<a name="ln378"> </a>
<a name="ln379">  /* Make socket for the peer. */</a>
<a name="ln380">  peer-&gt;fd = sockunion_socket (&amp;peer-&gt;su);</a>
<a name="ln381">  if (peer-&gt;fd &lt; 0)</a>
<a name="ln382">    return -1;</a>
<a name="ln383"> </a>
<a name="ln384">  set_nonblocking (peer-&gt;fd);</a>
<a name="ln385"> </a>
<a name="ln386">  /* Set socket send buffer size */</a>
<a name="ln387">  bgp_update_sock_send_buffer_size(peer-&gt;fd);</a>
<a name="ln388"> </a>
<a name="ln389">  bgp_set_socket_ttl (peer, peer-&gt;fd);</a>
<a name="ln390"> </a>
<a name="ln391">  sockopt_reuseaddr (peer-&gt;fd);</a>
<a name="ln392">  sockopt_reuseport (peer-&gt;fd);</a>
<a name="ln393">  </a>
<a name="ln394">#ifdef IPTOS_PREC_INTERNETCONTROL</a>
<a name="ln395">  if (bgpd_privs.change (ZPRIVS_RAISE))</a>
<a name="ln396">    zlog_err (&quot;%s: could not raise privs&quot;, __func__);</a>
<a name="ln397">  if (sockunion_family (&amp;peer-&gt;su) == AF_INET)</a>
<a name="ln398">    setsockopt_ipv4_tos (peer-&gt;fd, IPTOS_PREC_INTERNETCONTROL);</a>
<a name="ln399">  else if (sockunion_family (&amp;peer-&gt;su) == AF_INET6)</a>
<a name="ln400">    setsockopt_ipv6_tclass (peer-&gt;fd, IPTOS_PREC_INTERNETCONTROL);</a>
<a name="ln401">  if (bgpd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln402">    zlog_err (&quot;%s: could not lower privs&quot;, __func__);</a>
<a name="ln403">#endif</a>
<a name="ln404"> </a>
<a name="ln405">  if (peer-&gt;password)</a>
<a name="ln406">    bgp_md5_set_connect (peer-&gt;fd, &amp;peer-&gt;su, peer-&gt;password);</a>
<a name="ln407"> </a>
<a name="ln408">  /* Bind socket. */</a>
<a name="ln409">  bgp_bind (peer);</a>
<a name="ln410"> </a>
<a name="ln411">  /* Update source bind. */</a>
<a name="ln412">  bgp_update_source (peer);</a>
<a name="ln413"> </a>
<a name="ln414">  if (peer-&gt;ifname)</a>
<a name="ln415">    ifindex = ifname2ifindex (peer-&gt;ifname);</a>
<a name="ln416"> </a>
<a name="ln417">  if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln418">    plog_debug (peer-&gt;log, &quot;%s [Event] Connect start to %s fd %d&quot;,</a>
<a name="ln419">	       peer-&gt;host, peer-&gt;host, peer-&gt;fd);</a>
<a name="ln420"> </a>
<a name="ln421">  /* Connect to the remote peer. */</a>
<a name="ln422">  return sockunion_connect (peer-&gt;fd, &amp;peer-&gt;su, htons (peer-&gt;port), ifindex);</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">/* After TCP connection is established.  Get local address and port. */</a>
<a name="ln426">void</a>
<a name="ln427">bgp_getsockname (struct peer *peer)</a>
<a name="ln428">{</a>
<a name="ln429">  if (peer-&gt;su_local)</a>
<a name="ln430">    {</a>
<a name="ln431">      sockunion_free (peer-&gt;su_local);</a>
<a name="ln432">      peer-&gt;su_local = NULL;</a>
<a name="ln433">    }</a>
<a name="ln434"> </a>
<a name="ln435">  if (peer-&gt;su_remote)</a>
<a name="ln436">    {</a>
<a name="ln437">      sockunion_free (peer-&gt;su_remote);</a>
<a name="ln438">      peer-&gt;su_remote = NULL;</a>
<a name="ln439">    }</a>
<a name="ln440"> </a>
<a name="ln441">  peer-&gt;su_local = sockunion_getsockname (peer-&gt;fd);</a>
<a name="ln442">  peer-&gt;su_remote = sockunion_getpeername (peer-&gt;fd);</a>
<a name="ln443"> </a>
<a name="ln444">  bgp_nexthop_set (peer-&gt;su_local, peer-&gt;su_remote, &amp;peer-&gt;nexthop, peer);</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">static int</a>
<a name="ln449">bgp_listener (int sock, struct sockaddr *sa, socklen_t salen)</a>
<a name="ln450">{</a>
<a name="ln451">  struct bgp_listener *listener;</a>
<a name="ln452">  int ret, en;</a>
<a name="ln453"> </a>
<a name="ln454">  sockopt_reuseaddr (sock);</a>
<a name="ln455">  sockopt_reuseport (sock);</a>
<a name="ln456"> </a>
<a name="ln457">  if (bgpd_privs.change (ZPRIVS_RAISE))</a>
<a name="ln458">    zlog_err (&quot;%s: could not raise privs&quot;, __func__);</a>
<a name="ln459"> </a>
<a name="ln460">#ifdef IPTOS_PREC_INTERNETCONTROL</a>
<a name="ln461">  if (sa-&gt;sa_family == AF_INET)</a>
<a name="ln462">    setsockopt_ipv4_tos (sock, IPTOS_PREC_INTERNETCONTROL);</a>
<a name="ln463">  else if (sa-&gt;sa_family == AF_INET6)</a>
<a name="ln464">    setsockopt_ipv6_tclass (sock, IPTOS_PREC_INTERNETCONTROL);</a>
<a name="ln465">#endif</a>
<a name="ln466"> </a>
<a name="ln467">  sockopt_v6only (sa-&gt;sa_family, sock);</a>
<a name="ln468"> </a>
<a name="ln469">  ret = bind (sock, sa, salen);</a>
<a name="ln470">  en = errno;</a>
<a name="ln471">  if (bgpd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln472">    zlog_err (&quot;%s: could not lower privs&quot;, __func__);</a>
<a name="ln473"> </a>
<a name="ln474">  if (ret &lt; 0)</a>
<a name="ln475">    {</a>
<a name="ln476">      zlog_err (&quot;bind: %s&quot;, safe_strerror (en));</a>
<a name="ln477">      return ret;</a>
<a name="ln478">    }</a>
<a name="ln479"> </a>
<a name="ln480">  ret = listen (sock, 3);</a>
<a name="ln481">  if (ret &lt; 0)</a>
<a name="ln482">    {</a>
<a name="ln483">      zlog_err (&quot;listen: %s&quot;, safe_strerror (errno));</a>
<a name="ln484">      return ret;</a>
<a name="ln485">    }</a>
<a name="ln486"> </a>
<a name="ln487">  listener = XMALLOC (MTYPE_BGP_LISTENER, sizeof(*listener));</a>
<a name="ln488">  listener-&gt;fd = sock;</a>
<a name="ln489">  memcpy(&amp;listener-&gt;su, sa, salen);</a>
<a name="ln490">  listener-&gt;thread = thread_add_read (bm-&gt;master, bgp_accept, listener, sock);</a>
<a name="ln491">  listnode_add (bm-&gt;listen_sockets, listener);</a>
<a name="ln492"> </a>
<a name="ln493">  return 0;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">/* IPv6 supported version of BGP server socket setup.  */</a>
<a name="ln497">int</a>
<a name="ln498">bgp_socket (unsigned short port, const char *address)</a>
<a name="ln499">{</a>
<a name="ln500">  struct addrinfo *ainfo;</a>
<a name="ln501">  struct addrinfo *ainfo_save;</a>
<a name="ln502">  static const struct addrinfo req = {</a>
<a name="ln503">    .ai_family = AF_UNSPEC,</a>
<a name="ln504">    .ai_flags = AI_PASSIVE,</a>
<a name="ln505">    .ai_socktype = SOCK_STREAM,</a>
<a name="ln506">  };</a>
<a name="ln507">  int ret, count;</a>
<a name="ln508">  char port_str[BUFSIZ];</a>
<a name="ln509"> </a>
<a name="ln510">  snprintf (port_str, sizeof(port_str), &quot;%d&quot;, port);</a>
<a name="ln511">  port_str[sizeof (port_str) - 1] = '\0';</a>
<a name="ln512"> </a>
<a name="ln513">  ret = getaddrinfo (address, port_str, &amp;req, &amp;ainfo_save);</a>
<a name="ln514">  if (ret != 0)</a>
<a name="ln515">    {</a>
<a name="ln516">      zlog_err (&quot;getaddrinfo: %s&quot;, gai_strerror (ret));</a>
<a name="ln517">      return -1;</a>
<a name="ln518">    }</a>
<a name="ln519"> </a>
<a name="ln520">  count = 0;</a>
<a name="ln521">  for (ainfo = ainfo_save; ainfo; ainfo = ainfo-&gt;ai_next)</a>
<a name="ln522">    {</a>
<a name="ln523">      int sock;</a>
<a name="ln524"> </a>
<a name="ln525">      if (ainfo-&gt;ai_family != AF_INET &amp;&amp; ainfo-&gt;ai_family != AF_INET6)</a>
<a name="ln526">	continue;</a>
<a name="ln527">     </a>
<a name="ln528">      sock = socket (ainfo-&gt;ai_family, ainfo-&gt;ai_socktype, ainfo-&gt;ai_protocol);</a>
<a name="ln529">      if (sock &lt; 0)</a>
<a name="ln530">	{</a>
<a name="ln531">	  zlog_err (&quot;socket: %s&quot;, safe_strerror (errno));</a>
<a name="ln532">	  continue;</a>
<a name="ln533">	}</a>
<a name="ln534">	</a>
<a name="ln535">      /* if we intend to implement ttl-security, this socket needs ttl=255 */</a>
<a name="ln536">      sockopt_ttl (ainfo-&gt;ai_family, sock, MAXTTL);</a>
<a name="ln537">      </a>
<a name="ln538">      ret = bgp_listener (sock, ainfo-&gt;ai_addr, ainfo-&gt;ai_addrlen);</a>
<a name="ln539">      if (ret == 0)</a>
<a name="ln540">	++count;</a>
<a name="ln541">      else</a>
<a name="ln542">	close(sock);</a>
<a name="ln543">    }</a>
<a name="ln544">  freeaddrinfo (ainfo_save);</a>
<a name="ln545">  if (count == 0)</a>
<a name="ln546">    {</a>
<a name="ln547">      zlog_err (&quot;%s: no usable addresses&quot;, __func__);</a>
<a name="ln548">      return -1;</a>
<a name="ln549">    }</a>
<a name="ln550"> </a>
<a name="ln551">  return 0;</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">void</a>
<a name="ln555">bgp_close (void)</a>
<a name="ln556">{</a>
<a name="ln557">  struct listnode *node, *next;</a>
<a name="ln558">  struct bgp_listener *listener;</a>
<a name="ln559"> </a>
<a name="ln560">  for (ALL_LIST_ELEMENTS (bm-&gt;listen_sockets, node, next, listener))</a>
<a name="ln561">    {</a>
<a name="ln562">      thread_cancel (listener-&gt;thread);</a>
<a name="ln563">      close (listener-&gt;fd);</a>
<a name="ln564">      listnode_delete (bm-&gt;listen_sockets, listener);</a>
<a name="ln565">      XFREE (MTYPE_BGP_LISTENER, listener);</a>
<a name="ln566">    }</a>
<a name="ln567">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
