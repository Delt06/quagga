
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>linklist.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Generic linked list routine.</a>
<a name="ln2"> * Copyright (C) 1997, 2000 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.</a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;linklist.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">/* Allocate new list. */</a>
<a name="ln28">struct list *</a>
<a name="ln29">list_new (void)</a>
<a name="ln30">{</a>
<a name="ln31">  return XCALLOC (MTYPE_LINK_LIST, sizeof (struct list));</a>
<a name="ln32">}</a>
<a name="ln33"> </a>
<a name="ln34">/* Free list. */</a>
<a name="ln35">void</a>
<a name="ln36">list_free (struct list *l)</a>
<a name="ln37">{</a>
<a name="ln38">  XFREE (MTYPE_LINK_LIST, l);</a>
<a name="ln39">}</a>
<a name="ln40"> </a>
<a name="ln41">/* Allocate new listnode.  Internal use only. */</a>
<a name="ln42">static struct listnode *</a>
<a name="ln43">listnode_new (void)</a>
<a name="ln44">{</a>
<a name="ln45">  return XCALLOC (MTYPE_LINK_NODE, sizeof (struct listnode));</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">/* Free listnode. */</a>
<a name="ln49">static void</a>
<a name="ln50">listnode_free (struct listnode *node)</a>
<a name="ln51">{</a>
<a name="ln52">  XFREE (MTYPE_LINK_NODE, node);</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">/* Add new data to the list. */</a>
<a name="ln56">void</a>
<a name="ln57">listnode_add (struct list *list, void *val)</a>
<a name="ln58">{</a>
<a name="ln59">  struct listnode *node;</a>
<a name="ln60">  </a>
<a name="ln61">  assert (val != NULL);</a>
<a name="ln62">  </a>
<a name="ln63">  node = listnode_new ();</a>
<a name="ln64"> </a>
<a name="ln65">  node-&gt;prev = list-&gt;tail;</a>
<a name="ln66">  node-&gt;data = val;</a>
<a name="ln67"> </a>
<a name="ln68">  if (list-&gt;head == NULL)</a>
<a name="ln69">    list-&gt;head = node;</a>
<a name="ln70">  else</a>
<a name="ln71">    list-&gt;tail-&gt;next = node;</a>
<a name="ln72">  list-&gt;tail = node;</a>
<a name="ln73"> </a>
<a name="ln74">  list-&gt;count++;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">/*</a>
<a name="ln78"> * Add a node to the list.  If the list was sorted according to the</a>
<a name="ln79"> * cmp function, insert a new node with the given val such that the</a>
<a name="ln80"> * list remains sorted.  The new node is always inserted; there is no</a>
<a name="ln81"> * notion of omitting duplicates.</a>
<a name="ln82"> */</a>
<a name="ln83">void</a>
<a name="ln84">listnode_add_sort (struct list *list, void *val)</a>
<a name="ln85">{</a>
<a name="ln86">  struct listnode *n;</a>
<a name="ln87">  struct listnode *new;</a>
<a name="ln88">  </a>
<a name="ln89">  assert (val != NULL);</a>
<a name="ln90">  </a>
<a name="ln91">  new = listnode_new ();</a>
<a name="ln92">  new-&gt;data = val;</a>
<a name="ln93"> </a>
<a name="ln94">  if (list-&gt;cmp)</a>
<a name="ln95">    {</a>
<a name="ln96">      for (n = list-&gt;head; n; n = n-&gt;next)</a>
<a name="ln97">	{</a>
<a name="ln98">	  if ((*list-&gt;cmp) (val, n-&gt;data) &lt; 0)</a>
<a name="ln99">	    {	    </a>
<a name="ln100">	      new-&gt;next = n;</a>
<a name="ln101">	      new-&gt;prev = n-&gt;prev;</a>
<a name="ln102"> </a>
<a name="ln103">	      if (n-&gt;prev)</a>
<a name="ln104">		n-&gt;prev-&gt;next = new;</a>
<a name="ln105">	      else</a>
<a name="ln106">		list-&gt;head = new;</a>
<a name="ln107">	      n-&gt;prev = new;</a>
<a name="ln108">	      list-&gt;count++;</a>
<a name="ln109">	      return;</a>
<a name="ln110">	    }</a>
<a name="ln111">	}</a>
<a name="ln112">    }</a>
<a name="ln113"> </a>
<a name="ln114">  new-&gt;prev = list-&gt;tail;</a>
<a name="ln115"> </a>
<a name="ln116">  if (list-&gt;tail)</a>
<a name="ln117">    list-&gt;tail-&gt;next = new;</a>
<a name="ln118">  else</a>
<a name="ln119">    list-&gt;head = new;</a>
<a name="ln120"> </a>
<a name="ln121">  list-&gt;tail = new;</a>
<a name="ln122">  list-&gt;count++;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">void</a>
<a name="ln126">listnode_add_after (struct list *list, struct listnode *pp, void *val)</a>
<a name="ln127">{</a>
<a name="ln128">  struct listnode *nn;</a>
<a name="ln129">  </a>
<a name="ln130">  assert (val != NULL);</a>
<a name="ln131">  </a>
<a name="ln132">  nn = listnode_new ();</a>
<a name="ln133">  nn-&gt;data = val;</a>
<a name="ln134"> </a>
<a name="ln135">  if (pp == NULL)</a>
<a name="ln136">    {</a>
<a name="ln137">      if (list-&gt;head)</a>
<a name="ln138">	list-&gt;head-&gt;prev = nn;</a>
<a name="ln139">      else</a>
<a name="ln140">	list-&gt;tail = nn;</a>
<a name="ln141"> </a>
<a name="ln142">      nn-&gt;next = list-&gt;head;</a>
<a name="ln143">      nn-&gt;prev = pp;</a>
<a name="ln144"> </a>
<a name="ln145">      list-&gt;head = nn;</a>
<a name="ln146">    }</a>
<a name="ln147">  else</a>
<a name="ln148">    {</a>
<a name="ln149">      if (pp-&gt;next)</a>
<a name="ln150">	pp-&gt;next-&gt;prev = nn;</a>
<a name="ln151">      else</a>
<a name="ln152">	list-&gt;tail = nn;</a>
<a name="ln153"> </a>
<a name="ln154">      nn-&gt;next = pp-&gt;next;</a>
<a name="ln155">      nn-&gt;prev = pp;</a>
<a name="ln156"> </a>
<a name="ln157">      pp-&gt;next = nn;</a>
<a name="ln158">    }</a>
<a name="ln159">  list-&gt;count++;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">struct listnode *</a>
<a name="ln163">listnode_add_before (struct list *list, struct listnode *pp, void *val)</a>
<a name="ln164">{</a>
<a name="ln165">  struct listnode *nn;</a>
<a name="ln166"> </a>
<a name="ln167">  assert (val != NULL);</a>
<a name="ln168"> </a>
<a name="ln169">  nn = listnode_new ();</a>
<a name="ln170">  nn-&gt;data = val;</a>
<a name="ln171"> </a>
<a name="ln172">  if (pp == NULL)</a>
<a name="ln173">    {</a>
<a name="ln174">      if (list-&gt;tail)</a>
<a name="ln175">        list-&gt;tail-&gt;next = nn;</a>
<a name="ln176">      else</a>
<a name="ln177">        list-&gt;head = nn;</a>
<a name="ln178"> </a>
<a name="ln179">      nn-&gt;prev = list-&gt;tail;</a>
<a name="ln180">      nn-&gt;next = pp;</a>
<a name="ln181"> </a>
<a name="ln182">      list-&gt;tail = nn;</a>
<a name="ln183">    }</a>
<a name="ln184">  else</a>
<a name="ln185">    {</a>
<a name="ln186">      if (pp-&gt;prev)</a>
<a name="ln187">	pp-&gt;prev-&gt;next = nn;</a>
<a name="ln188">      else</a>
<a name="ln189">	list-&gt;head = nn;</a>
<a name="ln190"> </a>
<a name="ln191">      nn-&gt;prev = pp-&gt;prev;</a>
<a name="ln192">      nn-&gt;next = pp;</a>
<a name="ln193"> </a>
<a name="ln194">      pp-&gt;prev = nn;</a>
<a name="ln195">    }</a>
<a name="ln196">  list-&gt;count++;</a>
<a name="ln197">  return nn;</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">/* Move given listnode to tail of the list */</a>
<a name="ln201">void</a>
<a name="ln202">listnode_move_to_tail (struct list *l, struct listnode *n)</a>
<a name="ln203">{</a>
<a name="ln204">  LISTNODE_DETACH(l,n);</a>
<a name="ln205">  LISTNODE_ATTACH(l,n);</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">/* Delete specific date pointer from the list. */</a>
<a name="ln209">void</a>
<a name="ln210">listnode_delete (struct list *list, void *val)</a>
<a name="ln211">{</a>
<a name="ln212">  struct listnode *node;</a>
<a name="ln213"> </a>
<a name="ln214">  assert(list);</a>
<a name="ln215">  for (node = list-&gt;head; node; node = node-&gt;next)</a>
<a name="ln216">    {</a>
<a name="ln217">      if (node-&gt;data == val)</a>
<a name="ln218">	{</a>
<a name="ln219">	  if (node-&gt;prev)</a>
<a name="ln220">	    node-&gt;prev-&gt;next = node-&gt;next;</a>
<a name="ln221">	  else</a>
<a name="ln222">	    list-&gt;head = node-&gt;next;</a>
<a name="ln223"> </a>
<a name="ln224">	  if (node-&gt;next)</a>
<a name="ln225">	    node-&gt;next-&gt;prev = node-&gt;prev;</a>
<a name="ln226">	  else</a>
<a name="ln227">	    list-&gt;tail = node-&gt;prev;</a>
<a name="ln228"> </a>
<a name="ln229">	  list-&gt;count--;</a>
<a name="ln230">	  listnode_free (node);</a>
<a name="ln231">	  return;</a>
<a name="ln232">	}</a>
<a name="ln233">    }</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">/* Return first node's data if it is there.  */</a>
<a name="ln237">void *</a>
<a name="ln238">listnode_head (struct list *list)</a>
<a name="ln239">{</a>
<a name="ln240">  struct listnode *node;</a>
<a name="ln241"> </a>
<a name="ln242">  assert(list);</a>
<a name="ln243">  node = list-&gt;head;</a>
<a name="ln244"> </a>
<a name="ln245">  if (node)</a>
<a name="ln246">    return node-&gt;data;</a>
<a name="ln247">  return NULL;</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">/* Delete all listnode from the list. */</a>
<a name="ln251">void</a>
<a name="ln252">list_delete_all_node (struct list *list)</a>
<a name="ln253">{</a>
<a name="ln254">  struct listnode *node;</a>
<a name="ln255">  struct listnode *next;</a>
<a name="ln256"> </a>
<a name="ln257">  assert(list);</a>
<a name="ln258">  for (node = list-&gt;head; node; node = next)</a>
<a name="ln259">    {</a>
<a name="ln260">      next = node-&gt;next;</a>
<a name="ln261">      if (list-&gt;del)</a>
<a name="ln262">	(*list-&gt;del) (node-&gt;data);</a>
<a name="ln263">      listnode_free (node);</a>
<a name="ln264">    }</a>
<a name="ln265">  list-&gt;head = list-&gt;tail = NULL;</a>
<a name="ln266">  list-&gt;count = 0;</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">/* Delete all listnode then free list itself. */</a>
<a name="ln270">void</a>
<a name="ln271">list_delete (struct list *list)</a>
<a name="ln272">{</a>
<a name="ln273">  assert(list);</a>
<a name="ln274">  list_delete_all_node (list);</a>
<a name="ln275">  list_free (list);</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">/* Lookup the node which has given data. */</a>
<a name="ln279">struct listnode *</a>
<a name="ln280">listnode_lookup (struct list *list, void *data)</a>
<a name="ln281">{</a>
<a name="ln282">  struct listnode *node;</a>
<a name="ln283"> </a>
<a name="ln284">  assert(list);</a>
<a name="ln285">  for (node = listhead(list); node; node = listnextnode (node))</a>
<a name="ln286">    if (data == listgetdata (node))</a>
<a name="ln287">      return node;</a>
<a name="ln288">  return NULL;</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">/* Delete the node from list.  For ospfd and ospf6d. */</a>
<a name="ln292">void</a>
<a name="ln293">list_delete_node (struct list *list, struct listnode *node)</a>
<a name="ln294">{</a>
<a name="ln295">  if (node-&gt;prev)</a>
<a name="ln296">    node-&gt;prev-&gt;next = node-&gt;next;</a>
<a name="ln297">  else</a>
<a name="ln298">    list-&gt;head = node-&gt;next;</a>
<a name="ln299">  if (node-&gt;next)</a>
<a name="ln300">    node-&gt;next-&gt;prev = node-&gt;prev;</a>
<a name="ln301">  else</a>
<a name="ln302">    list-&gt;tail = node-&gt;prev;</a>
<a name="ln303">  list-&gt;count--;</a>
<a name="ln304">  listnode_free (node);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">/* ospf_spf.c */</a>
<a name="ln308">void</a>
<a name="ln309">list_add_node_prev (struct list *list, struct listnode *current, void *val)</a>
<a name="ln310">{</a>
<a name="ln311">  struct listnode *node;</a>
<a name="ln312">  </a>
<a name="ln313">  assert (val != NULL);</a>
<a name="ln314">  </a>
<a name="ln315">  node = listnode_new ();</a>
<a name="ln316">  node-&gt;next = current;</a>
<a name="ln317">  node-&gt;data = val;</a>
<a name="ln318"> </a>
<a name="ln319">  if (current-&gt;prev == NULL)</a>
<a name="ln320">    list-&gt;head = node;</a>
<a name="ln321">  else</a>
<a name="ln322">    current-&gt;prev-&gt;next = node;</a>
<a name="ln323"> </a>
<a name="ln324">  node-&gt;prev = current-&gt;prev;</a>
<a name="ln325">  current-&gt;prev = node;</a>
<a name="ln326"> </a>
<a name="ln327">  list-&gt;count++;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">/* ospf_spf.c */</a>
<a name="ln331">void</a>
<a name="ln332">list_add_node_next (struct list *list, struct listnode *current, void *val)</a>
<a name="ln333">{</a>
<a name="ln334">  struct listnode *node;</a>
<a name="ln335">  </a>
<a name="ln336">  assert (val != NULL);</a>
<a name="ln337">  </a>
<a name="ln338">  node = listnode_new ();</a>
<a name="ln339">  node-&gt;prev = current;</a>
<a name="ln340">  node-&gt;data = val;</a>
<a name="ln341"> </a>
<a name="ln342">  if (current-&gt;next == NULL)</a>
<a name="ln343">    list-&gt;tail = node;</a>
<a name="ln344">  else</a>
<a name="ln345">    current-&gt;next-&gt;prev = node;</a>
<a name="ln346"> </a>
<a name="ln347">  node-&gt;next = current-&gt;next;</a>
<a name="ln348">  current-&gt;next = node;</a>
<a name="ln349"> </a>
<a name="ln350">  list-&gt;count++;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">/* ospf_spf.c */</a>
<a name="ln354">void</a>
<a name="ln355">list_add_list (struct list *l, struct list *m)</a>
<a name="ln356">{</a>
<a name="ln357">  struct listnode *n;</a>
<a name="ln358"> </a>
<a name="ln359">  for (n = listhead (m); n; n = listnextnode (n))</a>
<a name="ln360">    listnode_add (l, n-&gt;data);</a>
<a name="ln361">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
