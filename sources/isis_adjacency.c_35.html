
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_adjacency.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol - isis_adjacency.c   </a>
<a name="ln3"> *                             handling of IS-IS adjacencies</a>
<a name="ln4"> *</a>
<a name="ln5"> * Copyright (C) 2001,2002   Sampo Saaristo</a>
<a name="ln6"> *                           Tampere University of Technology      </a>
<a name="ln7"> *                           Institute of Communications Engineering</a>
<a name="ln8"> *</a>
<a name="ln9"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln10"> * under the terms of the GNU General Public Licenseas published by the Free </a>
<a name="ln11"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln12"> * any later version.</a>
<a name="ln13"> *</a>
<a name="ln14"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln15"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln16"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln17"> * more details.</a>
<a name="ln18"> </a>
<a name="ln19"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln20"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln21"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;log.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;hash.h&quot;</a>
<a name="ln29">#include &quot;vty.h&quot;</a>
<a name="ln30">#include &quot;linklist.h&quot;</a>
<a name="ln31">#include &quot;thread.h&quot;</a>
<a name="ln32">#include &quot;if.h&quot;</a>
<a name="ln33">#include &quot;stream.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;isisd/dict.h&quot;</a>
<a name="ln36">#include &quot;isisd/include-netbsd/iso.h&quot;</a>
<a name="ln37">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln38">#include &quot;isisd/isis_common.h&quot;</a>
<a name="ln39">#include &quot;isisd/isis_flags.h&quot;</a>
<a name="ln40">#include &quot;isisd/isisd.h&quot;</a>
<a name="ln41">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln42">#include &quot;isisd/isis_adjacency.h&quot;</a>
<a name="ln43">#include &quot;isisd/isis_misc.h&quot;</a>
<a name="ln44">#include &quot;isisd/isis_dr.h&quot;</a>
<a name="ln45">#include &quot;isisd/isis_dynhn.h&quot;</a>
<a name="ln46">#include &quot;isisd/isis_pdu.h&quot;</a>
<a name="ln47">#include &quot;isisd/isis_tlv.h&quot;</a>
<a name="ln48">#include &quot;isisd/isis_lsp.h&quot;</a>
<a name="ln49">#include &quot;isisd/isis_spf.h&quot;</a>
<a name="ln50">#include &quot;isisd/isis_events.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">extern struct isis *isis;</a>
<a name="ln53"> </a>
<a name="ln54">static struct isis_adjacency *</a>
<a name="ln55">adj_alloc (const u_char *id)</a>
<a name="ln56">{</a>
<a name="ln57">  struct isis_adjacency *adj;</a>
<a name="ln58"> </a>
<a name="ln59">  adj = XCALLOC (MTYPE_ISIS_ADJACENCY, sizeof (struct isis_adjacency));</a>
<a name="ln60">  memcpy (adj-&gt;sysid, id, ISIS_SYS_ID_LEN);</a>
<a name="ln61"> </a>
<a name="ln62">  return adj;</a>
<a name="ln63">}</a>
<a name="ln64"> </a>
<a name="ln65">struct isis_adjacency *</a>
<a name="ln66">isis_new_adj (const u_char * id, const u_char * snpa, int level,</a>
<a name="ln67">	      struct isis_circuit *circuit)</a>
<a name="ln68">{</a>
<a name="ln69">  struct isis_adjacency *adj;</a>
<a name="ln70">  int i;</a>
<a name="ln71"> </a>
<a name="ln72">  adj = adj_alloc (id);		/* P2P kludge */</a>
<a name="ln73"> </a>
<a name="ln74">  if (adj == NULL)</a>
<a name="ln75">    {</a>
<a name="ln76">      zlog_err (&quot;Out of memory!&quot;);</a>
<a name="ln77">      return NULL;</a>
<a name="ln78">    }</a>
<a name="ln79"> </a>
<a name="ln80">  if (snpa) {</a>
<a name="ln81">    memcpy (adj-&gt;snpa, snpa, ETH_ALEN);</a>
<a name="ln82">  } else {</a>
<a name="ln83">    memset (adj-&gt;snpa, ' ', ETH_ALEN);</a>
<a name="ln84">  }</a>
<a name="ln85"> </a>
<a name="ln86">  adj-&gt;circuit = circuit;</a>
<a name="ln87">  adj-&gt;level = level;</a>
<a name="ln88">  adj-&gt;flaps = 0;</a>
<a name="ln89">  adj-&gt;last_flap = time (NULL);</a>
<a name="ln90">  if (circuit-&gt;circ_type == CIRCUIT_T_BROADCAST)</a>
<a name="ln91">    {</a>
<a name="ln92">      listnode_add (circuit-&gt;u.bc.adjdb[level - 1], adj);</a>
<a name="ln93">      adj-&gt;dischanges[level - 1] = 0;</a>
<a name="ln94">      for (i = 0; i &lt; DIS_RECORDS; i++)	/* clear N DIS state change records */</a>
<a name="ln95">	{</a>
<a name="ln96">	  adj-&gt;dis_record[(i * ISIS_LEVELS) + level - 1].dis</a>
<a name="ln97">	    = ISIS_UNKNOWN_DIS;</a>
<a name="ln98">	  adj-&gt;dis_record[(i * ISIS_LEVELS) + level - 1].last_dis_change</a>
<a name="ln99">	    = time (NULL);</a>
<a name="ln100">	}</a>
<a name="ln101">    }</a>
<a name="ln102"> </a>
<a name="ln103">  return adj;</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">struct isis_adjacency *</a>
<a name="ln107">isis_adj_lookup (const u_char * sysid, struct list *adjdb)</a>
<a name="ln108">{</a>
<a name="ln109">  struct isis_adjacency *adj;</a>
<a name="ln110">  struct listnode *node;</a>
<a name="ln111"> </a>
<a name="ln112">  for (ALL_LIST_ELEMENTS_RO (adjdb, node, adj))</a>
<a name="ln113">    if (memcmp (adj-&gt;sysid, sysid, ISIS_SYS_ID_LEN) == 0)</a>
<a name="ln114">      return adj;</a>
<a name="ln115"> </a>
<a name="ln116">  return NULL;</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">struct isis_adjacency *</a>
<a name="ln120">isis_adj_lookup_snpa (const u_char * ssnpa, struct list *adjdb)</a>
<a name="ln121">{</a>
<a name="ln122">  struct listnode *node;</a>
<a name="ln123">  struct isis_adjacency *adj;</a>
<a name="ln124"> </a>
<a name="ln125">  for (ALL_LIST_ELEMENTS_RO (adjdb, node, adj))</a>
<a name="ln126">    if (memcmp (adj-&gt;snpa, ssnpa, ETH_ALEN) == 0)</a>
<a name="ln127">      return adj;</a>
<a name="ln128"> </a>
<a name="ln129">  return NULL;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">void</a>
<a name="ln133">isis_delete_adj (void *arg)</a>
<a name="ln134">{</a>
<a name="ln135">  struct isis_adjacency *adj = arg;</a>
<a name="ln136"> </a>
<a name="ln137">  if (!adj)</a>
<a name="ln138">    return;</a>
<a name="ln139"> </a>
<a name="ln140">  THREAD_TIMER_OFF (adj-&gt;t_expire);</a>
<a name="ln141"> </a>
<a name="ln142">  /* remove from SPF trees */</a>
<a name="ln143">  spftree_area_adj_del (adj-&gt;circuit-&gt;area, adj);</a>
<a name="ln144"> </a>
<a name="ln145">  if (adj-&gt;area_addrs)</a>
<a name="ln146">    list_delete (adj-&gt;area_addrs);</a>
<a name="ln147">  if (adj-&gt;ipv4_addrs)</a>
<a name="ln148">    list_delete (adj-&gt;ipv4_addrs);</a>
<a name="ln149">#ifdef HAVE_IPV6</a>
<a name="ln150">  if (adj-&gt;ipv6_addrs)</a>
<a name="ln151">    list_delete (adj-&gt;ipv6_addrs);</a>
<a name="ln152">#endif</a>
<a name="ln153"> </a>
<a name="ln154">  XFREE (MTYPE_ISIS_ADJACENCY, adj);</a>
<a name="ln155">  return;</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">static const char *</a>
<a name="ln159">adj_state2string (int state)</a>
<a name="ln160">{</a>
<a name="ln161"> </a>
<a name="ln162">  switch (state)</a>
<a name="ln163">    {</a>
<a name="ln164">    case ISIS_ADJ_INITIALIZING:</a>
<a name="ln165">      return &quot;Initializing&quot;;</a>
<a name="ln166">    case ISIS_ADJ_UP:</a>
<a name="ln167">      return &quot;Up&quot;;</a>
<a name="ln168">    case ISIS_ADJ_DOWN:</a>
<a name="ln169">      return &quot;Down&quot;;</a>
<a name="ln170">    default:</a>
<a name="ln171">      return &quot;Unknown&quot;;</a>
<a name="ln172">    }</a>
<a name="ln173"> </a>
<a name="ln174">  return NULL;			/* not reached */</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">void</a>
<a name="ln178">isis_adj_state_change (struct isis_adjacency *adj, enum isis_adj_state new_state,</a>
<a name="ln179">		       const char *reason)</a>
<a name="ln180">{</a>
<a name="ln181">  int old_state;</a>
<a name="ln182">  int level;</a>
<a name="ln183">  struct isis_circuit *circuit;</a>
<a name="ln184"> </a>
<a name="ln185">  old_state = adj-&gt;adj_state;</a>
<a name="ln186">  adj-&gt;adj_state = new_state;</a>
<a name="ln187"> </a>
<a name="ln188">  circuit = adj-&gt;circuit;</a>
<a name="ln189"> </a>
<a name="ln190">  if (isis-&gt;debugs &amp; DEBUG_ADJ_PACKETS)</a>
<a name="ln191">    {</a>
<a name="ln192">      zlog_debug (&quot;ISIS-Adj (%s): Adjacency state change %d-&gt;%d: %s&quot;,</a>
<a name="ln193">		 circuit-&gt;area-&gt;area_tag,</a>
<a name="ln194">		 old_state, new_state, reason ? reason : &quot;unspecified&quot;);</a>
<a name="ln195">    }</a>
<a name="ln196"> </a>
<a name="ln197">  if (circuit-&gt;area-&gt;log_adj_changes)</a>
<a name="ln198">    {</a>
<a name="ln199">      const char *adj_name;</a>
<a name="ln200">      struct isis_dynhn *dyn;</a>
<a name="ln201"> </a>
<a name="ln202">      dyn = dynhn_find_by_id (adj-&gt;sysid);</a>
<a name="ln203">      if (dyn)</a>
<a name="ln204">	adj_name = (const char *)dyn-&gt;name.name;</a>
<a name="ln205">      else</a>
<a name="ln206">	adj_name = sysid_print (adj-&gt;sysid);</a>
<a name="ln207"> </a>
<a name="ln208">      zlog_info (&quot;%%ADJCHANGE: Adjacency to %s (%s) changed from %s to %s, %s&quot;,</a>
<a name="ln209">		 adj_name,</a>
<a name="ln210">		 adj-&gt;circuit-&gt;interface-&gt;name,</a>
<a name="ln211">		 adj_state2string (old_state),</a>
<a name="ln212">		 adj_state2string (new_state),</a>
<a name="ln213">		 reason ? reason : &quot;unspecified&quot;);</a>
<a name="ln214">    }</a>
<a name="ln215"> </a>
<a name="ln216">  if (circuit-&gt;circ_type == CIRCUIT_T_BROADCAST)</a>
<a name="ln217">    {</a>
<a name="ln218">      for (level = IS_LEVEL_1; level &lt;= IS_LEVEL_2; level++)</a>
<a name="ln219">      {</a>
<a name="ln220">        if ((adj-&gt;level &amp; level) == 0)</a>
<a name="ln221">          continue;</a>
<a name="ln222">        if (new_state == ISIS_ADJ_UP)</a>
<a name="ln223">        {</a>
<a name="ln224">          circuit-&gt;upadjcount[level - 1]++;</a>
<a name="ln225">          isis_event_adjacency_state_change (adj, new_state);</a>
<a name="ln226">          /* update counter &amp; timers for debugging purposes */</a>
<a name="ln227">          adj-&gt;last_flap = time (NULL);</a>
<a name="ln228">          adj-&gt;flaps++;</a>
<a name="ln229">        }</a>
<a name="ln230">        else if (new_state == ISIS_ADJ_DOWN)</a>
<a name="ln231">        {</a>
<a name="ln232">          listnode_delete (circuit-&gt;u.bc.adjdb[level - 1], adj);</a>
<a name="ln233">          circuit-&gt;upadjcount[level - 1]--;</a>
<a name="ln234">          if (circuit-&gt;upadjcount[level - 1] == 0)</a>
<a name="ln235">            {</a>
<a name="ln236">              /* Clean lsp_queue when no adj is up. */</a>
<a name="ln237">              if (circuit-&gt;lsp_queue)</a>
<a name="ln238">                list_delete_all_node (circuit-&gt;lsp_queue);</a>
<a name="ln239">            }</a>
<a name="ln240">          isis_event_adjacency_state_change (adj, new_state);</a>
<a name="ln241">          isis_delete_adj (adj);</a>
<a name="ln242">        }</a>
<a name="ln243"> </a>
<a name="ln244">        if (circuit-&gt;u.bc.lan_neighs[level - 1])</a>
<a name="ln245">          {</a>
<a name="ln246">            list_delete_all_node (circuit-&gt;u.bc.lan_neighs[level - 1]);</a>
<a name="ln247">            isis_adj_build_neigh_list (circuit-&gt;u.bc.adjdb[level - 1],</a>
<a name="ln248">                                       circuit-&gt;u.bc.lan_neighs[level - 1]);</a>
<a name="ln249">          }</a>
<a name="ln250"> </a>
<a name="ln251">        /* On adjacency state change send new pseudo LSP if we are the DR */</a>
<a name="ln252">        if (circuit-&gt;u.bc.is_dr[level - 1])</a>
<a name="ln253">          lsp_regenerate_schedule_pseudo (circuit, level);</a>
<a name="ln254">      }</a>
<a name="ln255">    }</a>
<a name="ln256">  else if (circuit-&gt;circ_type == CIRCUIT_T_P2P)</a>
<a name="ln257">    {</a>
<a name="ln258">      for (level = IS_LEVEL_1; level &lt;= IS_LEVEL_2; level++)</a>
<a name="ln259">      {</a>
<a name="ln260">        if ((adj-&gt;level &amp; level) == 0)</a>
<a name="ln261">          continue;</a>
<a name="ln262">        if (new_state == ISIS_ADJ_UP)</a>
<a name="ln263">        {</a>
<a name="ln264">          circuit-&gt;upadjcount[level - 1]++;</a>
<a name="ln265">          isis_event_adjacency_state_change (adj, new_state);</a>
<a name="ln266"> </a>
<a name="ln267">          if (adj-&gt;sys_type == ISIS_SYSTYPE_UNKNOWN)</a>
<a name="ln268">            send_hello (circuit, level);</a>
<a name="ln269"> </a>
<a name="ln270">          /* update counter &amp; timers for debugging purposes */</a>
<a name="ln271">          adj-&gt;last_flap = time (NULL);</a>
<a name="ln272">          adj-&gt;flaps++;</a>
<a name="ln273"> </a>
<a name="ln274">          /* 7.3.17 - going up on P2P -&gt; send CSNP */</a>
<a name="ln275">          /* FIXME: yup, I know its wrong... but i will do it! (for now) */</a>
<a name="ln276">          send_csnp (circuit, level);</a>
<a name="ln277">        }</a>
<a name="ln278">        else if (new_state == ISIS_ADJ_DOWN)</a>
<a name="ln279">        {</a>
<a name="ln280">          if (adj-&gt;circuit-&gt;u.p2p.neighbor == adj)</a>
<a name="ln281">            adj-&gt;circuit-&gt;u.p2p.neighbor = NULL;</a>
<a name="ln282">          circuit-&gt;upadjcount[level - 1]--;</a>
<a name="ln283">          if (circuit-&gt;upadjcount[level - 1] == 0)</a>
<a name="ln284">            {</a>
<a name="ln285">              /* Clean lsp_queue when no adj is up. */</a>
<a name="ln286">              if (circuit-&gt;lsp_queue)</a>
<a name="ln287">                list_delete_all_node (circuit-&gt;lsp_queue);</a>
<a name="ln288">            }</a>
<a name="ln289">          isis_event_adjacency_state_change (adj, new_state);</a>
<a name="ln290">          isis_delete_adj (adj);</a>
<a name="ln291">        }</a>
<a name="ln292">      }</a>
<a name="ln293">    }</a>
<a name="ln294"> </a>
<a name="ln295">  return;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298"> </a>
<a name="ln299">void</a>
<a name="ln300">isis_adj_print (struct isis_adjacency *adj)</a>
<a name="ln301">{</a>
<a name="ln302">  struct isis_dynhn *dyn;</a>
<a name="ln303">  struct listnode *node;</a>
<a name="ln304">  struct in_addr *ipv4_addr;</a>
<a name="ln305">#ifdef HAVE_IPV6</a>
<a name="ln306">  struct in6_addr *ipv6_addr;</a>
<a name="ln307">  u_char ip6[INET6_ADDRSTRLEN];</a>
<a name="ln308">#endif /* HAVE_IPV6 */</a>
<a name="ln309"> </a>
<a name="ln310">  if (!adj)</a>
<a name="ln311">    return;</a>
<a name="ln312">  dyn = dynhn_find_by_id (adj-&gt;sysid);</a>
<a name="ln313">  if (dyn)</a>
<a name="ln314">    zlog_debug (&quot;%s&quot;, dyn-&gt;name.name);</a>
<a name="ln315"> </a>
<a name="ln316">  zlog_debug (&quot;SystemId %20s SNPA %s, level %d\nHolding Time %d&quot;,</a>
<a name="ln317">              sysid_print (adj-&gt;sysid), snpa_print (adj-&gt;snpa),</a>
<a name="ln318">              adj-&gt;level, adj-&gt;hold_time);</a>
<a name="ln319">  if (adj-&gt;ipv4_addrs &amp;&amp; listcount (adj-&gt;ipv4_addrs) &gt; 0)</a>
<a name="ln320">    {</a>
<a name="ln321">      zlog_debug (&quot;IPv4 Address(es):&quot;);</a>
<a name="ln322"> </a>
<a name="ln323">      for (ALL_LIST_ELEMENTS_RO (adj-&gt;ipv4_addrs, node, ipv4_addr))</a>
<a name="ln324">        zlog_debug (&quot;%s&quot;, inet_ntoa (*ipv4_addr));</a>
<a name="ln325">    }</a>
<a name="ln326"> </a>
<a name="ln327">#ifdef HAVE_IPV6</a>
<a name="ln328">  if (adj-&gt;ipv6_addrs &amp;&amp; listcount (adj-&gt;ipv6_addrs) &gt; 0)</a>
<a name="ln329">    {</a>
<a name="ln330">      zlog_debug (&quot;IPv6 Address(es):&quot;);</a>
<a name="ln331">      for (ALL_LIST_ELEMENTS_RO (adj-&gt;ipv6_addrs, node, ipv6_addr))</a>
<a name="ln332">	{</a>
<a name="ln333">	  inet_ntop (AF_INET6, ipv6_addr, (char *)ip6, INET6_ADDRSTRLEN);</a>
<a name="ln334">	  zlog_debug (&quot;%s&quot;, ip6);</a>
<a name="ln335">	}</a>
<a name="ln336">    }</a>
<a name="ln337">#endif /* HAVE_IPV6 */</a>
<a name="ln338">  zlog_debug (&quot;Speaks: %s&quot;, nlpid2string (&amp;adj-&gt;nlpids));</a>
<a name="ln339"> </a>
<a name="ln340">  return;</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">int</a>
<a name="ln344">isis_adj_expire (struct thread *thread)</a>
<a name="ln345">{</a>
<a name="ln346">  struct isis_adjacency *adj;</a>
<a name="ln347"> </a>
<a name="ln348">  /*</a>
<a name="ln349">   * Get the adjacency</a>
<a name="ln350">   */</a>
<a name="ln351">  adj = THREAD_ARG (thread);</a>
<a name="ln352">  assert (adj);</a>
<a name="ln353">  adj-&gt;t_expire = NULL;</a>
<a name="ln354"> </a>
<a name="ln355">  /* trigger the adj expire event */</a>
<a name="ln356">  isis_adj_state_change (adj, ISIS_ADJ_DOWN, &quot;holding time expired&quot;);</a>
<a name="ln357"> </a>
<a name="ln358">  return 0;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">/*</a>
<a name="ln362"> * show isis neighbor [detail]</a>
<a name="ln363"> */</a>
<a name="ln364">void</a>
<a name="ln365">isis_adj_print_vty (struct isis_adjacency *adj, struct vty *vty, char detail)</a>
<a name="ln366">{</a>
<a name="ln367">#ifdef HAVE_IPV6</a>
<a name="ln368">  struct in6_addr *ipv6_addr;</a>
<a name="ln369">  u_char ip6[INET6_ADDRSTRLEN];</a>
<a name="ln370">#endif /* HAVE_IPV6 */</a>
<a name="ln371">  struct in_addr *ip_addr;</a>
<a name="ln372">  time_t now;</a>
<a name="ln373">  struct isis_dynhn *dyn;</a>
<a name="ln374">  int level;</a>
<a name="ln375">  struct listnode *node;</a>
<a name="ln376"> </a>
<a name="ln377">  dyn = dynhn_find_by_id (adj-&gt;sysid);</a>
<a name="ln378">  if (dyn)</a>
<a name="ln379">    vty_out (vty, &quot;  %-20s&quot;, dyn-&gt;name.name);</a>
<a name="ln380">  else</a>
<a name="ln381">    vty_out (vty, &quot;  %-20s&quot;, sysid_print (adj-&gt;sysid));</a>
<a name="ln382"> </a>
<a name="ln383">  if (detail == ISIS_UI_LEVEL_BRIEF)</a>
<a name="ln384">    {</a>
<a name="ln385">      if (adj-&gt;circuit)</a>
<a name="ln386">	vty_out (vty, &quot;%-12s&quot;, adj-&gt;circuit-&gt;interface-&gt;name);</a>
<a name="ln387">      else</a>
<a name="ln388">	vty_out (vty, &quot;NULL circuit!&quot;);</a>
<a name="ln389">      vty_out (vty, &quot;%-3u&quot;, adj-&gt;level);	/* level */</a>
<a name="ln390">      vty_out (vty, &quot;%-13s&quot;, adj_state2string (adj-&gt;adj_state));</a>
<a name="ln391">      now = time (NULL);</a>
<a name="ln392">      if (adj-&gt;last_upd)</a>
<a name="ln393">        vty_out (vty, &quot;%-9llu&quot;,</a>
<a name="ln394">                 (unsigned long long)adj-&gt;last_upd + adj-&gt;hold_time - now);</a>
<a name="ln395">      else</a>
<a name="ln396">	vty_out (vty, &quot;-        &quot;);</a>
<a name="ln397">      vty_out (vty, &quot;%-10s&quot;, snpa_print (adj-&gt;snpa));</a>
<a name="ln398">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln399">    }</a>
<a name="ln400"> </a>
<a name="ln401">  if (detail == ISIS_UI_LEVEL_DETAIL)</a>
<a name="ln402">    {</a>
<a name="ln403">      level = adj-&gt;level;</a>
<a name="ln404">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln405">      if (adj-&gt;circuit)</a>
<a name="ln406">	vty_out (vty, &quot;    Interface: %s&quot;, adj-&gt;circuit-&gt;interface-&gt;name);</a>
<a name="ln407">      else</a>
<a name="ln408">	vty_out (vty, &quot;    Interface: NULL circuit&quot;);</a>
<a name="ln409">      vty_out (vty, &quot;, Level: %u&quot;, adj-&gt;level);	/* level */</a>
<a name="ln410">      vty_out (vty, &quot;, State: %s&quot;, adj_state2string (adj-&gt;adj_state));</a>
<a name="ln411">      now = time (NULL);</a>
<a name="ln412">      if (adj-&gt;last_upd)</a>
<a name="ln413">	vty_out (vty, &quot;, Expires in %s&quot;,</a>
<a name="ln414">		 time2string (adj-&gt;last_upd + adj-&gt;hold_time - now));</a>
<a name="ln415">      else</a>
<a name="ln416">	vty_out (vty, &quot;, Expires in %s&quot;, time2string (adj-&gt;hold_time));</a>
<a name="ln417">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln418">      vty_out (vty, &quot;    Adjacency flaps: %u&quot;, adj-&gt;flaps);</a>
<a name="ln419">      vty_out (vty, &quot;, Last: %s ago&quot;, time2string (now - adj-&gt;last_flap));</a>
<a name="ln420">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln421">      vty_out (vty, &quot;    Circuit type: %s&quot;, circuit_t2string (adj-&gt;circuit_t));</a>
<a name="ln422">      vty_out (vty, &quot;, Speaks: %s&quot;, nlpid2string (&amp;adj-&gt;nlpids));</a>
<a name="ln423">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln424">      vty_out (vty, &quot;    SNPA: %s&quot;, snpa_print (adj-&gt;snpa));</a>
<a name="ln425">      if (adj-&gt;circuit &amp;&amp; (adj-&gt;circuit-&gt;circ_type == CIRCUIT_T_BROADCAST))</a>
<a name="ln426">      {</a>
<a name="ln427">        dyn = dynhn_find_by_id (adj-&gt;lanid);</a>
<a name="ln428">        if (dyn)</a>
<a name="ln429">          vty_out (vty, &quot;, LAN id: %s.%02x&quot;,</a>
<a name="ln430">              dyn-&gt;name.name, adj-&gt;lanid[ISIS_SYS_ID_LEN]);</a>
<a name="ln431">        else</a>
<a name="ln432">          vty_out (vty, &quot;, LAN id: %s.%02x&quot;,</a>
<a name="ln433">              sysid_print (adj-&gt;lanid), adj-&gt;lanid[ISIS_SYS_ID_LEN]);</a>
<a name="ln434"> </a>
<a name="ln435">        vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln436">        vty_out (vty, &quot;    LAN Priority: %u&quot;, adj-&gt;prio[adj-&gt;level - 1]);</a>
<a name="ln437"> </a>
<a name="ln438">        vty_out (vty, &quot;, %s, DIS flaps: %u, Last: %s ago&quot;,</a>
<a name="ln439">            isis_disflag2string (adj-&gt;dis_record[ISIS_LEVELS + level - 1].</a>
<a name="ln440">              dis), adj-&gt;dischanges[level - 1],</a>
<a name="ln441">            time2string (now -</a>
<a name="ln442">              (adj-&gt;dis_record[ISIS_LEVELS + level - 1].</a>
<a name="ln443">               last_dis_change)));</a>
<a name="ln444">      }</a>
<a name="ln445">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln446"> </a>
<a name="ln447">      if (adj-&gt;area_addrs &amp;&amp; listcount (adj-&gt;area_addrs) &gt; 0)</a>
<a name="ln448">        {</a>
<a name="ln449">          struct area_addr *area_addr;</a>
<a name="ln450">          vty_out (vty, &quot;    Area Address(es):%s&quot;, VTY_NEWLINE);</a>
<a name="ln451">          for (ALL_LIST_ELEMENTS_RO (adj-&gt;area_addrs, node, area_addr))</a>
<a name="ln452">            vty_out (vty, &quot;      %s%s&quot;, isonet_print (area_addr-&gt;area_addr,</a>
<a name="ln453">                     area_addr-&gt;addr_len), VTY_NEWLINE);</a>
<a name="ln454">        }</a>
<a name="ln455">      if (adj-&gt;ipv4_addrs &amp;&amp; listcount (adj-&gt;ipv4_addrs) &gt; 0)</a>
<a name="ln456">	{</a>
<a name="ln457">	  vty_out (vty, &quot;    IPv4 Address(es):%s&quot;, VTY_NEWLINE);</a>
<a name="ln458">	  for (ALL_LIST_ELEMENTS_RO (adj-&gt;ipv4_addrs, node, ip_addr))</a>
<a name="ln459">            vty_out (vty, &quot;      %s%s&quot;, inet_ntoa (*ip_addr), VTY_NEWLINE);</a>
<a name="ln460">	}</a>
<a name="ln461">#ifdef HAVE_IPV6</a>
<a name="ln462">      if (adj-&gt;ipv6_addrs &amp;&amp; listcount (adj-&gt;ipv6_addrs) &gt; 0)</a>
<a name="ln463">	{</a>
<a name="ln464">	  vty_out (vty, &quot;    IPv6 Address(es):%s&quot;, VTY_NEWLINE);</a>
<a name="ln465">	  for (ALL_LIST_ELEMENTS_RO (adj-&gt;ipv6_addrs, node, ipv6_addr))</a>
<a name="ln466">	    {</a>
<a name="ln467">	      inet_ntop (AF_INET6, ipv6_addr, (char *)ip6, INET6_ADDRSTRLEN);</a>
<a name="ln468">	      vty_out (vty, &quot;      %s%s&quot;, ip6, VTY_NEWLINE);</a>
<a name="ln469">	    }</a>
<a name="ln470">	}</a>
<a name="ln471">#endif /* HAVE_IPV6 */</a>
<a name="ln472">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln473">    }</a>
<a name="ln474">  return;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">void</a>
<a name="ln478">isis_adj_build_neigh_list (struct list *adjdb, struct list *list)</a>
<a name="ln479">{</a>
<a name="ln480">  struct isis_adjacency *adj;</a>
<a name="ln481">  struct listnode *node;</a>
<a name="ln482"> </a>
<a name="ln483">  if (!list)</a>
<a name="ln484">    {</a>
<a name="ln485">      zlog_warn (&quot;isis_adj_build_neigh_list(): NULL list&quot;);</a>
<a name="ln486">      return;</a>
<a name="ln487">    }</a>
<a name="ln488"> </a>
<a name="ln489">  for (ALL_LIST_ELEMENTS_RO (adjdb, node, adj))</a>
<a name="ln490">    {</a>
<a name="ln491">      if (!adj)</a>
<a name="ln492">	{</a>
<a name="ln493">	  zlog_warn (&quot;isis_adj_build_neigh_list(): NULL adj&quot;);</a>
<a name="ln494">	  return;</a>
<a name="ln495">	}</a>
<a name="ln496"> </a>
<a name="ln497">      if ((adj-&gt;adj_state == ISIS_ADJ_UP ||</a>
<a name="ln498">	   adj-&gt;adj_state == ISIS_ADJ_INITIALIZING))</a>
<a name="ln499">	listnode_add (list, adj-&gt;snpa);</a>
<a name="ln500">    }</a>
<a name="ln501">  return;</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">void</a>
<a name="ln505">isis_adj_build_up_list (struct list *adjdb, struct list *list)</a>
<a name="ln506">{</a>
<a name="ln507">  struct isis_adjacency *adj;</a>
<a name="ln508">  struct listnode *node;</a>
<a name="ln509"> </a>
<a name="ln510">  if (adjdb == NULL) {</a>
<a name="ln511">    zlog_warn (&quot;isis_adj_build_up_list(): adjacency DB is empty&quot;);</a>
<a name="ln512">    return;</a>
<a name="ln513">  }</a>
<a name="ln514"> </a>
<a name="ln515">  if (!list)</a>
<a name="ln516">    {</a>
<a name="ln517">      zlog_warn (&quot;isis_adj_build_up_list(): NULL list&quot;);</a>
<a name="ln518">      return;</a>
<a name="ln519">    }</a>
<a name="ln520"> </a>
<a name="ln521">  for (ALL_LIST_ELEMENTS_RO (adjdb, node, adj))</a>
<a name="ln522">    {</a>
<a name="ln523">      if (!adj)</a>
<a name="ln524">	{</a>
<a name="ln525">	  zlog_warn (&quot;isis_adj_build_up_list(): NULL adj&quot;);</a>
<a name="ln526">	  return;</a>
<a name="ln527">	}</a>
<a name="ln528"> </a>
<a name="ln529">      if (adj-&gt;adj_state == ISIS_ADJ_UP)</a>
<a name="ln530">	listnode_add (list, adj);</a>
<a name="ln531">    }</a>
<a name="ln532"> </a>
<a name="ln533">  return;</a>
<a name="ln534">}</a>

</code></pre>
<div class="balloon" rel="16"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
