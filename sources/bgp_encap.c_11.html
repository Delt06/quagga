
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_encap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1"> </a>
<a name="ln2">/*</a>
<a name="ln3"> * This file created by LabN Consulting, L.L.C.</a>
<a name="ln4"> *</a>
<a name="ln5"> *</a>
<a name="ln6"> * This file is based on bgp_mplsvpn.c which is Copyright (C) 2000</a>
<a name="ln7"> * Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln8"> *</a>
<a name="ln9"> */</a>
<a name="ln10"> </a>
<a name="ln11">/* </a>
<a name="ln12"> </a>
<a name="ln13">This file is part of GNU Zebra.</a>
<a name="ln14"> </a>
<a name="ln15">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln16">under the terms of the GNU General Public License as published by the</a>
<a name="ln17">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln18">later version.</a>
<a name="ln19"> </a>
<a name="ln20">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln21">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln22">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln23">General Public License for more details.</a>
<a name="ln24"> </a>
<a name="ln25">You should have received a copy of the GNU General Public License</a>
<a name="ln26">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln27">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln28">02111-1307, USA.  */</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;zebra.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;command.h&quot;</a>
<a name="ln33">#include &quot;prefix.h&quot;</a>
<a name="ln34">#include &quot;log.h&quot;</a>
<a name="ln35">#include &quot;memory.h&quot;</a>
<a name="ln36">#include &quot;stream.h&quot;</a>
<a name="ln37">#include &quot;filter.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln40">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln41">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln42">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln43">#include &quot;bgpd/bgp_ecommunity.h&quot;</a>
<a name="ln44">#include &quot;bgpd/bgp_mplsvpn.h&quot;</a>
<a name="ln45">#include &quot;bgpd/bgp_vty.h&quot;</a>
<a name="ln46">#include &quot;bgpd/bgp_encap.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">static u_int16_t</a>
<a name="ln49">decode_rd_type (u_char *pnt)</a>
<a name="ln50">{</a>
<a name="ln51">  u_int16_t v;</a>
<a name="ln52">  </a>
<a name="ln53">  v = ((u_int16_t) *pnt++ &lt;&lt; 8);</a>
<a name="ln54">  v |= (u_int16_t) *pnt;</a>
<a name="ln55">  return v;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58"> </a>
<a name="ln59">static void</a>
<a name="ln60">decode_rd_as (u_char *pnt, struct rd_as *rd_as)</a>
<a name="ln61">{</a>
<a name="ln62">  rd_as-&gt;as  = (u_int16_t) *pnt++ &lt;&lt; 8;</a>
<a name="ln63">  rd_as-&gt;as |= (u_int16_t) *pnt++;</a>
<a name="ln64">  </a>
<a name="ln65">  rd_as-&gt;val  = ((u_int32_t) *pnt++) &lt;&lt; 24;</a>
<a name="ln66">  rd_as-&gt;val |= ((u_int32_t) *pnt++) &lt;&lt; 16;</a>
<a name="ln67">  rd_as-&gt;val |= ((u_int32_t) *pnt++) &lt;&lt; 8;</a>
<a name="ln68">  rd_as-&gt;val |= (u_int32_t) *pnt;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">static void</a>
<a name="ln72">decode_rd_as4 (u_char *pnt, struct rd_as *rd_as)</a>
<a name="ln73">{</a>
<a name="ln74">  rd_as-&gt;as  = (u_int32_t) *pnt++ &lt;&lt; 24;</a>
<a name="ln75">  rd_as-&gt;as |= (u_int32_t) *pnt++ &lt;&lt; 16;</a>
<a name="ln76">  rd_as-&gt;as |= (u_int32_t) *pnt++ &lt;&lt; 8;</a>
<a name="ln77">  rd_as-&gt;as |= (u_int32_t) *pnt++;</a>
<a name="ln78">  </a>
<a name="ln79">  rd_as-&gt;val  = ((u_int32_t) *pnt++ &lt;&lt; 8);</a>
<a name="ln80">  rd_as-&gt;val |= (u_int32_t) *pnt;</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">static void</a>
<a name="ln84">decode_rd_ip (u_char *pnt, struct rd_ip *rd_ip)</a>
<a name="ln85">{</a>
<a name="ln86">  memcpy (&amp;rd_ip-&gt;ip, pnt, 4);</a>
<a name="ln87">  pnt += 4;</a>
<a name="ln88">  </a>
<a name="ln89">  rd_ip-&gt;val = ((u_int16_t) *pnt++ &lt;&lt; 8);</a>
<a name="ln90">  rd_ip-&gt;val |= (u_int16_t) *pnt;</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">static void</a>
<a name="ln94">ecom2prd(struct ecommunity *ecom, struct prefix_rd *prd)</a>
<a name="ln95">{</a>
<a name="ln96">    int	i;</a>
<a name="ln97"> </a>
<a name="ln98">    memset(prd, 0, sizeof(struct prefix_rd));</a>
<a name="ln99">    prd-&gt;family = AF_UNSPEC;</a>
<a name="ln100">    prd-&gt;prefixlen = 64;</a>
<a name="ln101"> </a>
<a name="ln102">    if (!ecom)</a>
<a name="ln103">	return;</a>
<a name="ln104"> </a>
<a name="ln105">    for (i = 0; i &lt; (ecom-&gt;size * ECOMMUNITY_SIZE); i += ECOMMUNITY_SIZE) {</a>
<a name="ln106"> </a>
<a name="ln107">	uint8_t *ep;</a>
<a name="ln108"> </a>
<a name="ln109">	ep = ecom-&gt;val + i;</a>
<a name="ln110"> </a>
<a name="ln111">	switch (ep[0]) {</a>
<a name="ln112">	    default:</a>
<a name="ln113">		continue;</a>
<a name="ln114"> </a>
<a name="ln115">	    case 0x80:</a>
<a name="ln116">	    case 0x81:</a>
<a name="ln117">	    case 0x82:</a>
<a name="ln118">		if (ep[1] == 0x0) {</a>
<a name="ln119">		    prd-&gt;val[1] = ep[0] &amp; 0x03;</a>
<a name="ln120">		    memcpy(prd-&gt;val + 2, ep + 2, 6);</a>
<a name="ln121">		    return;</a>
<a name="ln122">		}</a>
<a name="ln123">	}</a>
<a name="ln124">    }</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">int</a>
<a name="ln128">bgp_nlri_parse_encap(</a>
<a name="ln129">    struct peer		*peer,</a>
<a name="ln130">    struct attr		*attr, 		/* Need even for withdraw */</a>
<a name="ln131">    struct bgp_nlri	*packet)</a>
<a name="ln132">{</a>
<a name="ln133">  u_char *pnt;</a>
<a name="ln134">  u_char *lim;</a>
<a name="ln135">  afi_t afi = packet-&gt;afi;</a>
<a name="ln136">  struct prefix p;</a>
<a name="ln137">  int psize = 0;</a>
<a name="ln138">  int prefixlen;</a>
<a name="ln139">  struct rd_as rd_as;</a>
<a name="ln140">  struct rd_ip rd_ip;</a>
<a name="ln141">  struct prefix_rd prd;</a>
<a name="ln142">  struct ecommunity *pEcom = NULL;</a>
<a name="ln143">  u_int16_t rdtype = 0xffff;</a>
<a name="ln144">  char buf[BUFSIZ];</a>
<a name="ln145"> </a>
<a name="ln146">  /* Check peer status. */</a>
<a name="ln147">  if (peer-&gt;status != Established)</a>
<a name="ln148">    return 0;</a>
<a name="ln149">  </a>
<a name="ln150">  /* Make prefix_rd */</a>
<a name="ln151">  if (attr &amp;&amp; attr-&gt;extra &amp;&amp; attr-&gt;extra-&gt;ecommunity)</a>
<a name="ln152">      pEcom = attr-&gt;extra-&gt;ecommunity;</a>
<a name="ln153"> </a>
<a name="ln154">  ecom2prd(pEcom, &amp;prd);</a>
<a name="ln155">  memset(&amp;rd_as, 0, sizeof(rd_as));</a>
<a name="ln156">  memset(&amp;rd_ip, 0, sizeof(rd_ip));</a>
<a name="ln157"> </a>
<a name="ln158">  if (pEcom) {</a>
<a name="ln159"> </a>
<a name="ln160">      rdtype = (prd.val[0] &lt;&lt; 8) | prd.val[1];</a>
<a name="ln161"> </a>
<a name="ln162">      /* Decode RD value. */</a>
<a name="ln163">      if (rdtype == RD_TYPE_AS)</a>
<a name="ln164">	decode_rd_as (prd.val + 2, &amp;rd_as);</a>
<a name="ln165">      else if (rdtype == RD_TYPE_IP)</a>
<a name="ln166">	decode_rd_ip (prd.val + 2, &amp;rd_ip);</a>
<a name="ln167">      else if (rdtype == RD_TYPE_AS4)</a>
<a name="ln168">	decode_rd_as4 (prd.val + 2, &amp;rd_as);</a>
<a name="ln169">      else</a>
<a name="ln170">	{</a>
<a name="ln171">	  zlog_err (&quot;Invalid RD type %d&quot;, rdtype);</a>
<a name="ln172">	}</a>
<a name="ln173"> </a>
<a name="ln174">  }</a>
<a name="ln175"> </a>
<a name="ln176">  /*</a>
<a name="ln177">   * NB: this code was based on the MPLS VPN code, which supported RDs.</a>
<a name="ln178">   * For the moment we are retaining the underlying RIB structure that</a>
<a name="ln179">   * keeps a per-RD radix tree, but since the RDs are not carried over</a>
<a name="ln180">   * the wire, we set the RD internally to 0.</a>
<a name="ln181">   */</a>
<a name="ln182">  prd.family = AF_UNSPEC;</a>
<a name="ln183">  prd.prefixlen = 64;</a>
<a name="ln184">  memset(prd.val, 0, sizeof(prd.val));</a>
<a name="ln185"> </a>
<a name="ln186">  pnt = packet-&gt;nlri;</a>
<a name="ln187">  lim = pnt + packet-&gt;length;</a>
<a name="ln188"> </a>
<a name="ln189">  for (; pnt &lt; lim; pnt += psize)</a>
<a name="ln190">    {</a>
<a name="ln191">      /* Clear prefix structure. */</a>
<a name="ln192">      memset (&amp;p, 0, sizeof (struct prefix));</a>
<a name="ln193"> </a>
<a name="ln194">      /* Fetch prefix length. */</a>
<a name="ln195">      prefixlen = *pnt++;</a>
<a name="ln196">      p.family = afi2family(afi);</a>
<a name="ln197">      if (p.family == 0) {</a>
<a name="ln198">	/* bad afi, shouldn't happen */</a>
<a name="ln199">	zlog_warn(&quot;%s: bad afi %d, dropping incoming route&quot;, __func__, afi);</a>
<a name="ln200">	continue;</a>
<a name="ln201">      }</a>
<a name="ln202">      psize = PSIZE (prefixlen);</a>
<a name="ln203"> </a>
<a name="ln204">      p.prefixlen = prefixlen;</a>
<a name="ln205">      memcpy (&amp;p.u.prefix, pnt, psize);</a>
<a name="ln206"> </a>
<a name="ln207">      if (pnt + psize &gt; lim)</a>
<a name="ln208">	return -1;</a>
<a name="ln209"> </a>
<a name="ln210"> </a>
<a name="ln211">      if (rdtype == RD_TYPE_AS)</a>
<a name="ln212">	zlog_info (&quot;rd-as %u:%u prefix %s/%d&quot;, rd_as.as, rd_as.val,</a>
<a name="ln213">		   inet_ntop (p.family, &amp;p.u.prefix, buf, BUFSIZ),</a>
<a name="ln214">		   p.prefixlen);</a>
<a name="ln215">      else if (rdtype == RD_TYPE_IP)</a>
<a name="ln216">	zlog_info (&quot;rd-ip %s:%u prefix %s/%d&quot;, inet_ntoa (rd_ip.ip),</a>
<a name="ln217">		   rd_ip.val,</a>
<a name="ln218">		   inet_ntop (p.family, &amp;p.u.prefix, buf, BUFSIZ),</a>
<a name="ln219">		   p.prefixlen);</a>
<a name="ln220">      else if (rdtype == RD_TYPE_AS4)</a>
<a name="ln221">	zlog_info (&quot;rd-as4 %u:%u prefix %s/%d&quot;, rd_as.as, rd_as.val,</a>
<a name="ln222">		   inet_ntop (p.family, &amp;p.u.prefix, buf, BUFSIZ),</a>
<a name="ln223">		   p.prefixlen);</a>
<a name="ln224">      else</a>
<a name="ln225">	zlog_info (&quot;rd unknown, default to 0:0 prefix %s/%d&quot;,</a>
<a name="ln226">	    inet_ntop (p.family, &amp;p.u.prefix, buf, BUFSIZ),</a>
<a name="ln227">	    p.prefixlen);</a>
<a name="ln228"> </a>
<a name="ln229">      if (attr) {</a>
<a name="ln230">	bgp_update (peer, &amp;p, attr, afi, SAFI_ENCAP,</a>
<a name="ln231">		    ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &amp;prd, NULL, 0);</a>
<a name="ln232">      } else {</a>
<a name="ln233">	bgp_withdraw (peer, &amp;p, attr, afi, SAFI_ENCAP,</a>
<a name="ln234">		      ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &amp;prd, NULL);</a>
<a name="ln235">      }</a>
<a name="ln236">    }</a>
<a name="ln237"> </a>
<a name="ln238">  /* Packet length consistency check. */</a>
<a name="ln239">  if (pnt != lim)</a>
<a name="ln240">    return -1;</a>
<a name="ln241"> </a>
<a name="ln242">  return 0;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">/* TBD: these routes should probably all be host routes */</a>
<a name="ln247"> </a>
<a name="ln248">/* For testing purpose, static route of ENCAP. */</a>
<a name="ln249">DEFUN (encap_network,</a>
<a name="ln250">       encap_network_cmd,</a>
<a name="ln251">       &quot;network A.B.C.D/M rd ASN:nn_or_IP-address:nn tag WORD&quot;,</a>
<a name="ln252">       &quot;Specify a network to announce via BGP\n&quot;</a>
<a name="ln253">       &quot;IP prefix &lt;network&gt;/&lt;length&gt;, e.g., 35.0.0.0/8\n&quot;</a>
<a name="ln254">       &quot;Specify Route Distinguisher\n&quot;</a>
<a name="ln255">       &quot;ENCAP Route Distinguisher\n&quot;</a>
<a name="ln256">       &quot;BGP tag\n&quot;</a>
<a name="ln257">       &quot;tag value\n&quot;)</a>
<a name="ln258">{</a>
<a name="ln259">  return bgp_static_set_safi (SAFI_ENCAP, vty, argv[0], argv[1], argv[2], NULL);</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">/* For testing purpose, static route of ENCAP. */</a>
<a name="ln263">DEFUN (no_encap_network,</a>
<a name="ln264">       no_encap_network_cmd,</a>
<a name="ln265">       &quot;no network A.B.C.D/M rd ASN:nn_or_IP-address:nn tag WORD&quot;,</a>
<a name="ln266">       NO_STR</a>
<a name="ln267">       &quot;Specify a network to announce via BGP\n&quot;</a>
<a name="ln268">       &quot;IP prefix &lt;network&gt;/&lt;length&gt;, e.g., 35.0.0.0/8\n&quot;</a>
<a name="ln269">       &quot;Specify Route Distinguisher\n&quot;</a>
<a name="ln270">       &quot;ENCAP Route Distinguisher\n&quot;</a>
<a name="ln271">       &quot;BGP tag\n&quot;</a>
<a name="ln272">       &quot;tag value\n&quot;)</a>
<a name="ln273">{</a>
<a name="ln274">  return bgp_static_unset_safi (SAFI_ENCAP, vty, argv[0], argv[1], argv[2]);</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">static int</a>
<a name="ln278">show_adj_route_encap (struct vty *vty, struct peer *peer, struct prefix_rd *prd)</a>
<a name="ln279">{</a>
<a name="ln280">  struct bgp *bgp;</a>
<a name="ln281">  struct bgp_table *table;</a>
<a name="ln282">  struct bgp_node *rn;</a>
<a name="ln283">  struct bgp_node *rm;</a>
<a name="ln284">  struct attr *attr;</a>
<a name="ln285">  int rd_header;</a>
<a name="ln286">  int header = 1;</a>
<a name="ln287">  char v4_header[] = &quot;   Network          Next Hop            Metric LocPrf Weight Path%s&quot;;</a>
<a name="ln288"> </a>
<a name="ln289">  bgp = bgp_get_default ();</a>
<a name="ln290">  if (bgp == NULL)</a>
<a name="ln291">    {</a>
<a name="ln292">      vty_out (vty, &quot;No BGP process is configured%s&quot;, VTY_NEWLINE);</a>
<a name="ln293">      return CMD_WARNING;</a>
<a name="ln294">    }</a>
<a name="ln295"> </a>
<a name="ln296">  for (rn = bgp_table_top (bgp-&gt;rib[AFI_IP][SAFI_ENCAP]); rn;</a>
<a name="ln297">       rn = bgp_route_next (rn))</a>
<a name="ln298">    {</a>
<a name="ln299">      if (prd &amp;&amp; memcmp (rn-&gt;p.u.val, prd-&gt;val, 8) != 0)</a>
<a name="ln300">        continue;</a>
<a name="ln301"> </a>
<a name="ln302">      if ((table = rn-&gt;info) != NULL)</a>
<a name="ln303">        {</a>
<a name="ln304">          rd_header = 1;</a>
<a name="ln305"> </a>
<a name="ln306">          for (rm = bgp_table_top (table); rm; rm = bgp_route_next (rm))</a>
<a name="ln307">            if ((attr = rm-&gt;info) != NULL)</a>
<a name="ln308">              {</a>
<a name="ln309">                if (header)</a>
<a name="ln310">                  {</a>
<a name="ln311">                    vty_out (vty, &quot;BGP table version is 0, local router ID is %s%s&quot;,</a>
<a name="ln312">                             inet_ntoa (bgp-&gt;router_id), VTY_NEWLINE);</a>
<a name="ln313">                    vty_out (vty, &quot;Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal%s&quot;,</a>
<a name="ln314">                             VTY_NEWLINE);</a>
<a name="ln315">                    vty_out (vty, &quot;Origin codes: i - IGP, e - EGP, ? - incomplete%s%s&quot;,</a>
<a name="ln316">                             VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln317">                    vty_out (vty, v4_header, VTY_NEWLINE);</a>
<a name="ln318">                    header = 0;</a>
<a name="ln319">                  }</a>
<a name="ln320"> </a>
<a name="ln321">                if (rd_header)</a>
<a name="ln322">                  {</a>
<a name="ln323">                    u_int16_t type;</a>
<a name="ln324">                    struct rd_as rd_as;</a>
<a name="ln325">                    struct rd_ip rd_ip;</a>
<a name="ln326">                    u_char *pnt;</a>
<a name="ln327"> </a>
<a name="ln328">                    pnt = rn-&gt;p.u.val;</a>
<a name="ln329"> </a>
<a name="ln330">                    vty_out (vty, &quot;Route Distinguisher: &quot;);</a>
<a name="ln331"> </a>
<a name="ln332">                    /* Decode RD type. */</a>
<a name="ln333">                    type = decode_rd_type (pnt);</a>
<a name="ln334"> </a>
<a name="ln335">		    switch (type) {</a>
<a name="ln336"> </a>
<a name="ln337">		    case RD_TYPE_AS:</a>
<a name="ln338">                      decode_rd_as (pnt + 2, &amp;rd_as);</a>
<a name="ln339">                      vty_out (vty, &quot;%u:%d&quot;, rd_as.as, rd_as.val);</a>
<a name="ln340">		      break;</a>
<a name="ln341"> </a>
<a name="ln342">		    case RD_TYPE_IP:</a>
<a name="ln343">                      decode_rd_ip (pnt + 2, &amp;rd_ip);</a>
<a name="ln344">                      vty_out (vty, &quot;%s:%d&quot;, inet_ntoa (rd_ip.ip), rd_ip.val);</a>
<a name="ln345">		      break;</a>
<a name="ln346"> </a>
<a name="ln347">		    default:</a>
<a name="ln348">                      vty_out (vty, &quot;unknown RD type&quot;);</a>
<a name="ln349">		    }</a>
<a name="ln350"> </a>
<a name="ln351"> </a>
<a name="ln352">                    vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln353">                    rd_header = 0;</a>
<a name="ln354">                  }</a>
<a name="ln355">                route_vty_out_tmp (vty, &amp;rm-&gt;p, attr, SAFI_ENCAP);</a>
<a name="ln356">              }</a>
<a name="ln357">        }</a>
<a name="ln358">    }</a>
<a name="ln359">  return CMD_SUCCESS;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">enum bgp_show_type</a>
<a name="ln363">{</a>
<a name="ln364">  bgp_show_type_normal,</a>
<a name="ln365">  bgp_show_type_regexp,</a>
<a name="ln366">  bgp_show_type_prefix_list,</a>
<a name="ln367">  bgp_show_type_filter_list,</a>
<a name="ln368">  bgp_show_type_neighbor,</a>
<a name="ln369">  bgp_show_type_cidr_only,</a>
<a name="ln370">  bgp_show_type_prefix_longer,</a>
<a name="ln371">  bgp_show_type_community_all,</a>
<a name="ln372">  bgp_show_type_community,</a>
<a name="ln373">  bgp_show_type_community_exact,</a>
<a name="ln374">  bgp_show_type_community_list,</a>
<a name="ln375">  bgp_show_type_community_list_exact</a>
<a name="ln376">};</a>
<a name="ln377"> </a>
<a name="ln378">static int</a>
<a name="ln379">bgp_show_encap (</a>
<a name="ln380">    struct vty *vty,</a>
<a name="ln381">    afi_t afi,</a>
<a name="ln382">    struct prefix_rd *prd,</a>
<a name="ln383">    enum bgp_show_type type,</a>
<a name="ln384">    void *output_arg,</a>
<a name="ln385">    int tags)</a>
<a name="ln386">{</a>
<a name="ln387">  struct bgp *bgp;</a>
<a name="ln388">  struct bgp_table *table;</a>
<a name="ln389">  struct bgp_node *rn;</a>
<a name="ln390">  struct bgp_node *rm;</a>
<a name="ln391">  struct bgp_info *ri;</a>
<a name="ln392">  int rd_header;</a>
<a name="ln393">  int header = 1;</a>
<a name="ln394">  char v4_header[] = &quot;   Network          Next Hop            Metric LocPrf Weight Path%s&quot;;</a>
<a name="ln395">  char v4_header_tag[] = &quot;   Network          Next Hop      In tag/Out tag%s&quot;;</a>
<a name="ln396"> </a>
<a name="ln397">  unsigned long output_count = 0;</a>
<a name="ln398">  unsigned long total_count  = 0;</a>
<a name="ln399"> </a>
<a name="ln400">  bgp = bgp_get_default ();</a>
<a name="ln401">  if (bgp == NULL)</a>
<a name="ln402">    {</a>
<a name="ln403">      vty_out (vty, &quot;No BGP process is configured%s&quot;, VTY_NEWLINE);</a>
<a name="ln404">      return CMD_WARNING;</a>
<a name="ln405">    }</a>
<a name="ln406"> </a>
<a name="ln407">  if ((afi != AFI_IP) &amp;&amp; (afi != AFI_IP6)) {</a>
<a name="ln408">      vty_out (vty, &quot;Afi %d not supported%s&quot;, afi, VTY_NEWLINE);</a>
<a name="ln409">      return CMD_WARNING;</a>
<a name="ln410">  }</a>
<a name="ln411">  </a>
<a name="ln412">  for (rn = bgp_table_top (bgp-&gt;rib[afi][SAFI_ENCAP]); rn; rn = bgp_route_next (rn))</a>
<a name="ln413">    {</a>
<a name="ln414">      if (prd &amp;&amp; memcmp (rn-&gt;p.u.val, prd-&gt;val, 8) != 0)</a>
<a name="ln415">	continue;</a>
<a name="ln416"> </a>
<a name="ln417">      if ((table = rn-&gt;info) != NULL)</a>
<a name="ln418">	{</a>
<a name="ln419">	  rd_header = 1;</a>
<a name="ln420"> </a>
<a name="ln421">	  for (rm = bgp_table_top (table); rm; rm = bgp_route_next (rm))</a>
<a name="ln422">	    for (ri = rm-&gt;info; ri; ri = ri-&gt;next)</a>
<a name="ln423">	      {</a>
<a name="ln424">                total_count++;</a>
<a name="ln425">		if (type == bgp_show_type_neighbor)</a>
<a name="ln426">		  {</a>
<a name="ln427">		    union sockunion *su = output_arg;</a>
<a name="ln428"> </a>
<a name="ln429">		    if (ri-&gt;peer-&gt;su_remote == NULL || ! sockunion_same(ri-&gt;peer-&gt;su_remote, su))</a>
<a name="ln430">		      continue;</a>
<a name="ln431">		  }</a>
<a name="ln432">		if (header)</a>
<a name="ln433">		  {</a>
<a name="ln434">		    if (tags)</a>
<a name="ln435">		      vty_out (vty, v4_header_tag, VTY_NEWLINE);</a>
<a name="ln436">		    else</a>
<a name="ln437">		      {</a>
<a name="ln438">			vty_out (vty, &quot;BGP table version is 0, local router ID is %s%s&quot;,</a>
<a name="ln439">				 inet_ntoa (bgp-&gt;router_id), VTY_NEWLINE);</a>
<a name="ln440">			vty_out (vty, &quot;Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal%s&quot;,</a>
<a name="ln441">				 VTY_NEWLINE);</a>
<a name="ln442">			vty_out (vty, &quot;Origin codes: i - IGP, e - EGP, ? - incomplete%s%s&quot;,</a>
<a name="ln443">				 VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln444">			vty_out (vty, v4_header, VTY_NEWLINE);</a>
<a name="ln445">		      }</a>
<a name="ln446">		    header = 0;</a>
<a name="ln447">		  }</a>
<a name="ln448"> </a>
<a name="ln449">		if (rd_header)</a>
<a name="ln450">		  {</a>
<a name="ln451">		    u_int16_t type;</a>
<a name="ln452">		    struct rd_as rd_as;</a>
<a name="ln453">		    struct rd_ip rd_ip;</a>
<a name="ln454">		    u_char *pnt;</a>
<a name="ln455"> </a>
<a name="ln456">		    pnt = rn-&gt;p.u.val;</a>
<a name="ln457"> </a>
<a name="ln458">		    /* Decode RD type. */</a>
<a name="ln459">		    type = decode_rd_type (pnt);</a>
<a name="ln460"> </a>
<a name="ln461">		    vty_out (vty, &quot;Route Distinguisher: &quot;);</a>
<a name="ln462"> </a>
<a name="ln463">		    switch (type) {</a>
<a name="ln464"> </a>
<a name="ln465">		    case RD_TYPE_AS:</a>
<a name="ln466">		      decode_rd_as (pnt + 2, &amp;rd_as);</a>
<a name="ln467">		      vty_out (vty, &quot;%u:%d&quot;, rd_as.as, rd_as.val);</a>
<a name="ln468">		      break;</a>
<a name="ln469"> </a>
<a name="ln470">		    case RD_TYPE_IP:</a>
<a name="ln471">		      decode_rd_ip (pnt + 2, &amp;rd_ip);</a>
<a name="ln472">		      vty_out (vty, &quot;%s:%d&quot;, inet_ntoa (rd_ip.ip), rd_ip.val);</a>
<a name="ln473">		      break;</a>
<a name="ln474"> </a>
<a name="ln475">		    default:</a>
<a name="ln476">		      vty_out (vty, &quot;Unknown RD type&quot;);</a>
<a name="ln477">		      break;</a>
<a name="ln478">		    }</a>
<a name="ln479"> </a>
<a name="ln480">		    vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);		  </a>
<a name="ln481">		    rd_header = 0;</a>
<a name="ln482">		  }</a>
<a name="ln483">	        if (tags)</a>
<a name="ln484">		  route_vty_out_tag (vty, &amp;rm-&gt;p, ri, 0, SAFI_ENCAP);</a>
<a name="ln485">	        else</a>
<a name="ln486">		  route_vty_out (vty, &amp;rm-&gt;p, ri, 0, SAFI_ENCAP);</a>
<a name="ln487">                output_count++;</a>
<a name="ln488">	      }</a>
<a name="ln489">        }</a>
<a name="ln490">    }</a>
<a name="ln491"> </a>
<a name="ln492">  if (output_count == 0)</a>
<a name="ln493">    {</a>
<a name="ln494">        vty_out (vty, &quot;No prefixes displayed, %ld exist%s&quot;, total_count, VTY_NEWLINE);</a>
<a name="ln495">    }</a>
<a name="ln496">  else</a>
<a name="ln497">    vty_out (vty, &quot;%sDisplayed %ld out of %ld total prefixes%s&quot;,</a>
<a name="ln498">	     VTY_NEWLINE, output_count, total_count, VTY_NEWLINE);</a>
<a name="ln499"> </a>
<a name="ln500">  return CMD_SUCCESS;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">DEFUN (show_bgp_ipv4_encap,</a>
<a name="ln504">       show_bgp_ipv4_encap_cmd,</a>
<a name="ln505">       &quot;show bgp ipv4 encap&quot;,</a>
<a name="ln506">       SHOW_STR</a>
<a name="ln507">       BGP_STR</a>
<a name="ln508">       &quot;Address Family\n&quot;</a>
<a name="ln509">       &quot;Display ENCAP NLRI specific information\n&quot;)</a>
<a name="ln510">{</a>
<a name="ln511">  return bgp_show_encap (vty, AFI_IP, NULL, bgp_show_type_normal, NULL, 0);</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">DEFUN (show_bgp_ipv6_encap,</a>
<a name="ln515">       show_bgp_ipv6_encap_cmd,</a>
<a name="ln516">       &quot;show bgp ipv6 encap&quot;,</a>
<a name="ln517">       SHOW_STR</a>
<a name="ln518">       BGP_STR</a>
<a name="ln519">       &quot;Address Family\n&quot;</a>
<a name="ln520">       &quot;Display ENCAP NLRI specific information\n&quot;)</a>
<a name="ln521">{</a>
<a name="ln522">  return bgp_show_encap (vty, AFI_IP6, NULL, bgp_show_type_normal, NULL, 0);</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">DEFUN (show_bgp_ipv4_encap_rd,</a>
<a name="ln526">       show_bgp_ipv4_encap_rd_cmd,</a>
<a name="ln527">       &quot;show bgp ipv4 encap rd ASN:nn_or_IP-address:nn&quot;,</a>
<a name="ln528">       SHOW_STR</a>
<a name="ln529">       BGP_STR</a>
<a name="ln530">       &quot;Address Family\n&quot;</a>
<a name="ln531">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln532">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln533">       &quot;ENCAP Route Distinguisher\n&quot;)</a>
<a name="ln534">{</a>
<a name="ln535">  int ret;</a>
<a name="ln536">  struct prefix_rd prd;</a>
<a name="ln537"> </a>
<a name="ln538">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln539">  if (! ret)</a>
<a name="ln540">    {</a>
<a name="ln541">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln542">      return CMD_WARNING;</a>
<a name="ln543">    }</a>
<a name="ln544">  return bgp_show_encap (vty, AFI_IP, &amp;prd, bgp_show_type_normal, NULL, 0);</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">DEFUN (show_bgp_ipv6_encap_rd,</a>
<a name="ln548">       show_bgp_ipv6_encap_rd_cmd,</a>
<a name="ln549">       &quot;show bgp ipv6 encap rd ASN:nn_or_IP-address:nn&quot;,</a>
<a name="ln550">       SHOW_STR</a>
<a name="ln551">       BGP_STR</a>
<a name="ln552">       &quot;Address Family\n&quot;</a>
<a name="ln553">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln554">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln555">       &quot;ENCAP Route Distinguisher\n&quot;</a>
<a name="ln556">       &quot;Display BGP tags for prefixes\n&quot;)</a>
<a name="ln557">{</a>
<a name="ln558">  int ret;</a>
<a name="ln559">  struct prefix_rd prd;</a>
<a name="ln560"> </a>
<a name="ln561">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln562">  if (! ret)</a>
<a name="ln563">    {</a>
<a name="ln564">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln565">      return CMD_WARNING;</a>
<a name="ln566">    }</a>
<a name="ln567">  return bgp_show_encap (vty, AFI_IP6, &amp;prd, bgp_show_type_normal, NULL, 0);</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">DEFUN (show_bgp_ipv4_encap_tags,</a>
<a name="ln571">       show_bgp_ipv4_encap_tags_cmd,</a>
<a name="ln572">       &quot;show bgp ipv4 encap tags&quot;,</a>
<a name="ln573">       SHOW_STR</a>
<a name="ln574">       BGP_STR</a>
<a name="ln575">       &quot;Address Family\n&quot;</a>
<a name="ln576">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln577">       &quot;Display BGP tags for prefixes\n&quot;)</a>
<a name="ln578">{</a>
<a name="ln579">  return bgp_show_encap (vty, AFI_IP, NULL, bgp_show_type_normal, NULL,  1);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">DEFUN (show_bgp_ipv6_encap_tags,</a>
<a name="ln583">       show_bgp_ipv6_encap_tags_cmd,</a>
<a name="ln584">       &quot;show bgp ipv6 encap tags&quot;,</a>
<a name="ln585">       SHOW_STR</a>
<a name="ln586">       BGP_STR</a>
<a name="ln587">       &quot;Address Family\n&quot;</a>
<a name="ln588">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln589">       &quot;Display BGP tags for prefixes\n&quot;)</a>
<a name="ln590">{</a>
<a name="ln591">  return bgp_show_encap (vty, AFI_IP6, NULL, bgp_show_type_normal, NULL,  1);</a>
<a name="ln592">}</a>
<a name="ln593"> </a>
<a name="ln594"> </a>
<a name="ln595">DEFUN (show_bgp_ipv4_encap_rd_tags,</a>
<a name="ln596">       show_bgp_ipv4_encap_rd_tags_cmd,</a>
<a name="ln597">       &quot;show bgp ipv4 encap rd ASN:nn_or_IP-address:nn tags&quot;,</a>
<a name="ln598">       SHOW_STR</a>
<a name="ln599">       BGP_STR</a>
<a name="ln600">       &quot;Address Family\n&quot;</a>
<a name="ln601">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln602">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln603">       &quot;ENCAP Route Distinguisher\n&quot;</a>
<a name="ln604">       &quot;Display BGP tags for prefixes\n&quot;)</a>
<a name="ln605">{</a>
<a name="ln606">  int ret;</a>
<a name="ln607">  struct prefix_rd prd;</a>
<a name="ln608"> </a>
<a name="ln609">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln610">  if (! ret)</a>
<a name="ln611">    {</a>
<a name="ln612">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln613">      return CMD_WARNING;</a>
<a name="ln614">    }</a>
<a name="ln615">  return bgp_show_encap (vty, AFI_IP, &amp;prd, bgp_show_type_normal, NULL, 1);</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">DEFUN (show_bgp_ipv6_encap_rd_tags,</a>
<a name="ln619">       show_bgp_ipv6_encap_rd_tags_cmd,</a>
<a name="ln620">       &quot;show bgp ipv6 encap rd ASN:nn_or_IP-address:nn tags&quot;,</a>
<a name="ln621">       SHOW_STR</a>
<a name="ln622">       BGP_STR</a>
<a name="ln623">       &quot;Address Family\n&quot;</a>
<a name="ln624">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln625">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln626">       &quot;ENCAP Route Distinguisher\n&quot;</a>
<a name="ln627">       &quot;Display BGP tags for prefixes\n&quot;)</a>
<a name="ln628">{</a>
<a name="ln629">  int ret;</a>
<a name="ln630">  struct prefix_rd prd;</a>
<a name="ln631"> </a>
<a name="ln632">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln633">  if (! ret)</a>
<a name="ln634">    {</a>
<a name="ln635">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln636">      return CMD_WARNING;</a>
<a name="ln637">    }</a>
<a name="ln638">  return bgp_show_encap (vty, AFI_IP6, &amp;prd, bgp_show_type_normal, NULL, 1);</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">DEFUN (show_bgp_ipv4_encap_neighbor_routes,</a>
<a name="ln642">       show_bgp_ipv4_encap_neighbor_routes_cmd,</a>
<a name="ln643">       &quot;show bgp ipv4 encap neighbors A.B.C.D routes&quot;,</a>
<a name="ln644">       SHOW_STR</a>
<a name="ln645">       BGP_STR</a>
<a name="ln646">       &quot;Address Family\n&quot;</a>
<a name="ln647">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln648">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln649">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln650">       &quot;Display routes learned from neighbor\n&quot;)</a>
<a name="ln651">{</a>
<a name="ln652">  union sockunion su;</a>
<a name="ln653">  struct peer *peer;</a>
<a name="ln654"> </a>
<a name="ln655">  if (str2sockunion(argv[0], &amp;su))</a>
<a name="ln656">    {</a>
<a name="ln657">      vty_out (vty, &quot;Malformed address: %s%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln658">               return CMD_WARNING;</a>
<a name="ln659">    }</a>
<a name="ln660"> </a>
<a name="ln661">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln662">  if (! peer || ! peer-&gt;afc[AFI_IP][SAFI_ENCAP])</a>
<a name="ln663">    {</a>
<a name="ln664">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln665">      return CMD_WARNING;</a>
<a name="ln666">    }</a>
<a name="ln667"> </a>
<a name="ln668">  return bgp_show_encap (vty, AFI_IP, NULL, bgp_show_type_neighbor, &amp;su, 0);</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">DEFUN (show_bgp_ipv6_encap_neighbor_routes,</a>
<a name="ln672">       show_bgp_ipv6_encap_neighbor_routes_cmd,</a>
<a name="ln673">       &quot;show bgp ipv6 encap neighbors A.B.C.D routes&quot;,</a>
<a name="ln674">       SHOW_STR</a>
<a name="ln675">       BGP_STR</a>
<a name="ln676">       &quot;Address Family\n&quot;</a>
<a name="ln677">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln678">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln679">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln680">       &quot;Display routes learned from neighbor\n&quot;)</a>
<a name="ln681">{</a>
<a name="ln682">  union sockunion su;</a>
<a name="ln683">  struct peer *peer;</a>
<a name="ln684">  </a>
<a name="ln685">  if (str2sockunion(argv[0], &amp;su))</a>
<a name="ln686">    {</a>
<a name="ln687">      vty_out (vty, &quot;Malformed address: %s%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln688">               return CMD_WARNING;</a>
<a name="ln689">    }</a>
<a name="ln690"> </a>
<a name="ln691">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln692">  if (! peer || ! peer-&gt;afc[AFI_IP6][SAFI_ENCAP])</a>
<a name="ln693">    {</a>
<a name="ln694">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln695">      return CMD_WARNING;</a>
<a name="ln696">    }</a>
<a name="ln697"> </a>
<a name="ln698">  return bgp_show_encap (vty, AFI_IP6, NULL, bgp_show_type_neighbor, &amp;su, 0);</a>
<a name="ln699">}</a>
<a name="ln700"> </a>
<a name="ln701">DEFUN (show_bgp_ipv4_encap_rd_neighbor_routes,</a>
<a name="ln702">       show_bgp_ipv4_encap_rd_neighbor_routes_cmd,</a>
<a name="ln703">       &quot;show bgp ipv4 encap rd ASN:nn_or_IP-address:nn neighbors (A.B.C.D|X:X::X:X) routes&quot;,</a>
<a name="ln704">       SHOW_STR</a>
<a name="ln705">       BGP_STR</a>
<a name="ln706">       &quot;Address Family\n&quot;</a>
<a name="ln707">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln708">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln709">       &quot;ENCAP Route Distinguisher\n&quot;</a>
<a name="ln710">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln711">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln712">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln713">       &quot;Display routes learned from neighbor\n&quot;)</a>
<a name="ln714">{</a>
<a name="ln715">  int ret;</a>
<a name="ln716">  union sockunion su;</a>
<a name="ln717">  struct peer *peer;</a>
<a name="ln718">  struct prefix_rd prd;</a>
<a name="ln719"> </a>
<a name="ln720">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln721">  if (! ret)</a>
<a name="ln722">    {</a>
<a name="ln723">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln724">      return CMD_WARNING;</a>
<a name="ln725">    }</a>
<a name="ln726"> </a>
<a name="ln727">  if (str2sockunion(argv[1], &amp;su))</a>
<a name="ln728">    {</a>
<a name="ln729">      vty_out (vty, &quot;Malformed address: %s%s&quot;, argv[1], VTY_NEWLINE);</a>
<a name="ln730">               return CMD_WARNING;</a>
<a name="ln731">    }</a>
<a name="ln732"> </a>
<a name="ln733">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln734">  if (! peer || ! peer-&gt;afc[AFI_IP][SAFI_ENCAP])</a>
<a name="ln735">    {</a>
<a name="ln736">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln737">      return CMD_WARNING;</a>
<a name="ln738">    }</a>
<a name="ln739"> </a>
<a name="ln740">  return bgp_show_encap (vty, AFI_IP, &amp;prd, bgp_show_type_neighbor, &amp;su, 0);</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">DEFUN (show_bgp_ipv6_encap_rd_neighbor_routes,</a>
<a name="ln744">       show_bgp_ipv6_encap_rd_neighbor_routes_cmd,</a>
<a name="ln745">       &quot;show bgp ipv6 encap rd ASN:nn_or_IP-address:nn neighbors (A.B.C.D|X:X::X:X) routes&quot;,</a>
<a name="ln746">       SHOW_STR</a>
<a name="ln747">       BGP_STR</a>
<a name="ln748">       &quot;Address Family\n&quot;</a>
<a name="ln749">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln750">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln751">       &quot;ENCAP Route Distinguisher\n&quot;</a>
<a name="ln752">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln753">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln754">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln755">       &quot;Display routes learned from neighbor\n&quot;)</a>
<a name="ln756">{</a>
<a name="ln757">  int ret;</a>
<a name="ln758">  union sockunion su;</a>
<a name="ln759">  struct peer *peer;</a>
<a name="ln760">  struct prefix_rd prd;</a>
<a name="ln761"> </a>
<a name="ln762">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln763">  if (! ret)</a>
<a name="ln764">    {</a>
<a name="ln765">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln766">      return CMD_WARNING;</a>
<a name="ln767">    }</a>
<a name="ln768"> </a>
<a name="ln769">  if (str2sockunion(argv[1], &amp;su))</a>
<a name="ln770">    {</a>
<a name="ln771">      vty_out (vty, &quot;Malformed address: %s%s&quot;, argv[1], VTY_NEWLINE);</a>
<a name="ln772">               return CMD_WARNING;</a>
<a name="ln773">    }</a>
<a name="ln774"> </a>
<a name="ln775">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln776">  if (! peer || ! peer-&gt;afc[AFI_IP6][SAFI_ENCAP])</a>
<a name="ln777">    {</a>
<a name="ln778">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln779">      return CMD_WARNING;</a>
<a name="ln780">    }</a>
<a name="ln781"> </a>
<a name="ln782">  return bgp_show_encap (vty, AFI_IP6, &amp;prd, bgp_show_type_neighbor, &amp;su, 0);</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">DEFUN (show_bgp_ipv4_encap_neighbor_advertised_routes,</a>
<a name="ln786">       show_bgp_ipv4_encap_neighbor_advertised_routes_cmd,</a>
<a name="ln787">       &quot;show bgp ipv4 encap neighbors A.B.C.D advertised-routes&quot;,</a>
<a name="ln788">       SHOW_STR</a>
<a name="ln789">       BGP_STR</a>
<a name="ln790">       &quot;Address Family\n&quot;</a>
<a name="ln791">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln792">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln793">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln794">       &quot;Display the routes advertised to a BGP neighbor\n&quot;)</a>
<a name="ln795">{</a>
<a name="ln796">  int ret;</a>
<a name="ln797">  struct peer *peer;</a>
<a name="ln798">  union sockunion su;</a>
<a name="ln799"> </a>
<a name="ln800">  ret = str2sockunion (argv[0], &amp;su);</a>
<a name="ln801">  if (ret &lt; 0)</a>
<a name="ln802">    {</a>
<a name="ln803">      vty_out (vty, &quot;%% Malformed address: %s%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln804">      return CMD_WARNING;</a>
<a name="ln805">    }</a>
<a name="ln806">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln807">  if (! peer || ! peer-&gt;afc[AFI_IP][SAFI_ENCAP])</a>
<a name="ln808">    {</a>
<a name="ln809">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln810">      return CMD_WARNING;</a>
<a name="ln811">    }</a>
<a name="ln812"> </a>
<a name="ln813">  return show_adj_route_encap (vty, peer, NULL);</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">DEFUN (show_bgp_ipv6_encap_neighbor_advertised_routes,</a>
<a name="ln817">       show_bgp_ipv6_encap_neighbor_advertised_routes_cmd,</a>
<a name="ln818">       &quot;show bgp ipv6 encap neighbors A.B.C.D advertised-routes&quot;,</a>
<a name="ln819">       SHOW_STR</a>
<a name="ln820">       BGP_STR</a>
<a name="ln821">       &quot;Address Family\n&quot;</a>
<a name="ln822">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln823">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln824">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln825">       &quot;Display the routes advertised to a BGP neighbor\n&quot;)</a>
<a name="ln826">{</a>
<a name="ln827">  int ret;</a>
<a name="ln828">  struct peer *peer;</a>
<a name="ln829">  union sockunion su;</a>
<a name="ln830"> </a>
<a name="ln831">  ret = str2sockunion (argv[0], &amp;su);</a>
<a name="ln832">  if (ret &lt; 0)</a>
<a name="ln833">    {</a>
<a name="ln834">      vty_out (vty, &quot;%% Malformed address: %s%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln835">      return CMD_WARNING;</a>
<a name="ln836">    }</a>
<a name="ln837">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln838">  if (! peer || ! peer-&gt;afc[AFI_IP6][SAFI_ENCAP])</a>
<a name="ln839">    {</a>
<a name="ln840">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln841">      return CMD_WARNING;</a>
<a name="ln842">    }</a>
<a name="ln843"> </a>
<a name="ln844">  return show_adj_route_encap (vty, peer, NULL);</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">DEFUN (show_bgp_ipv4_encap_rd_neighbor_advertised_routes,</a>
<a name="ln848">       show_bgp_ipv4_encap_rd_neighbor_advertised_routes_cmd,</a>
<a name="ln849">       &quot;show bgp ipv4 encap rd ASN:nn_or_IP-address:nn neighbors (A.B.C.D|X:X::X:X) advertised-routes&quot;,</a>
<a name="ln850">       SHOW_STR</a>
<a name="ln851">       BGP_STR</a>
<a name="ln852">       &quot;Address Family\n&quot;</a>
<a name="ln853">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln854">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln855">       &quot;ENCAP Route Distinguisher\n&quot;</a>
<a name="ln856">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln857">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln858">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln859">       &quot;Display the routes advertised to a BGP neighbor\n&quot;)</a>
<a name="ln860">{</a>
<a name="ln861">  int ret;</a>
<a name="ln862">  struct peer *peer;</a>
<a name="ln863">  struct prefix_rd prd;</a>
<a name="ln864">  union sockunion su;</a>
<a name="ln865"> </a>
<a name="ln866">  ret = str2sockunion (argv[1], &amp;su);</a>
<a name="ln867">  if (ret &lt; 0)</a>
<a name="ln868">    {</a>
<a name="ln869">      vty_out (vty, &quot;%% Malformed address: %s%s&quot;, argv[1], VTY_NEWLINE);</a>
<a name="ln870">      return CMD_WARNING;</a>
<a name="ln871">    }</a>
<a name="ln872">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln873">  if (! peer || ! peer-&gt;afc[AFI_IP][SAFI_ENCAP])</a>
<a name="ln874">    {</a>
<a name="ln875">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln876">      return CMD_WARNING;</a>
<a name="ln877">    }</a>
<a name="ln878"> </a>
<a name="ln879">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln880">  if (! ret)</a>
<a name="ln881">    {</a>
<a name="ln882">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln883">      return CMD_WARNING;</a>
<a name="ln884">    }</a>
<a name="ln885"> </a>
<a name="ln886">  return show_adj_route_encap (vty, peer, &amp;prd);</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">DEFUN (show_bgp_ipv6_encap_rd_neighbor_advertised_routes,</a>
<a name="ln890">       show_bgp_ipv6_encap_rd_neighbor_advertised_routes_cmd,</a>
<a name="ln891">       &quot;show bgp ipv6 encap rd ASN:nn_or_IP-address:nn neighbors (A.B.C.D|X:X::X:X) advertised-routes&quot;,</a>
<a name="ln892">       SHOW_STR</a>
<a name="ln893">       BGP_STR</a>
<a name="ln894">       &quot;Address Family\n&quot;</a>
<a name="ln895">       &quot;Display ENCAP NLRI specific information\n&quot;</a>
<a name="ln896">       &quot;Display information for a route distinguisher\n&quot;</a>
<a name="ln897">       &quot;ENCAP Route Distinguisher\n&quot;</a>
<a name="ln898">       &quot;Detailed information on TCP and BGP neighbor connections\n&quot;</a>
<a name="ln899">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln900">       &quot;Neighbor to display information about\n&quot;</a>
<a name="ln901">       &quot;Display the routes advertised to a BGP neighbor\n&quot;)</a>
<a name="ln902">{</a>
<a name="ln903">  int ret;</a>
<a name="ln904">  struct peer *peer;</a>
<a name="ln905">  struct prefix_rd prd;</a>
<a name="ln906">  union sockunion su;</a>
<a name="ln907"> </a>
<a name="ln908">  ret = str2sockunion (argv[1], &amp;su);</a>
<a name="ln909">  if (ret &lt; 0)</a>
<a name="ln910">    {</a>
<a name="ln911">      vty_out (vty, &quot;%% Malformed address: %s%s&quot;, argv[1], VTY_NEWLINE);</a>
<a name="ln912">      return CMD_WARNING;</a>
<a name="ln913">    }</a>
<a name="ln914">  peer = peer_lookup (NULL, &amp;su);</a>
<a name="ln915">  if (! peer || ! peer-&gt;afc[AFI_IP6][SAFI_ENCAP])</a>
<a name="ln916">    {</a>
<a name="ln917">      vty_out (vty, &quot;%% No such neighbor or address family%s&quot;, VTY_NEWLINE);</a>
<a name="ln918">      return CMD_WARNING;</a>
<a name="ln919">    }</a>
<a name="ln920"> </a>
<a name="ln921">  ret = str2prefix_rd (argv[0], &amp;prd);</a>
<a name="ln922">  if (! ret)</a>
<a name="ln923">    {</a>
<a name="ln924">      vty_out (vty, &quot;%% Malformed Route Distinguisher%s&quot;, VTY_NEWLINE);</a>
<a name="ln925">      return CMD_WARNING;</a>
<a name="ln926">    }</a>
<a name="ln927"> </a>
<a name="ln928">  return show_adj_route_encap (vty, peer, &amp;prd);</a>
<a name="ln929">}</a>
<a name="ln930"> </a>
<a name="ln931">void</a>
<a name="ln932">bgp_encap_init (void)</a>
<a name="ln933">{</a>
<a name="ln934">  install_element (BGP_ENCAP_NODE, &amp;encap_network_cmd);</a>
<a name="ln935">  install_element (BGP_ENCAP_NODE, &amp;no_encap_network_cmd);</a>
<a name="ln936"> </a>
<a name="ln937">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_encap_cmd);</a>
<a name="ln938">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_encap_rd_cmd);</a>
<a name="ln939">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_encap_tags_cmd);</a>
<a name="ln940">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_encap_rd_tags_cmd);</a>
<a name="ln941">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_encap_neighbor_routes_cmd);</a>
<a name="ln942">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_encap_rd_neighbor_routes_cmd);</a>
<a name="ln943">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_encap_neighbor_advertised_routes_cmd);</a>
<a name="ln944">  install_element (VIEW_NODE, &amp;show_bgp_ipv4_encap_rd_neighbor_advertised_routes_cmd);</a>
<a name="ln945"> </a>
<a name="ln946">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_encap_cmd);</a>
<a name="ln947">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_encap_rd_cmd);</a>
<a name="ln948">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_encap_tags_cmd);</a>
<a name="ln949">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_encap_rd_tags_cmd);</a>
<a name="ln950">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_encap_neighbor_routes_cmd);</a>
<a name="ln951">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_encap_rd_neighbor_routes_cmd);</a>
<a name="ln952">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_encap_neighbor_advertised_routes_cmd);</a>
<a name="ln953">  install_element (VIEW_NODE, &amp;show_bgp_ipv6_encap_rd_neighbor_advertised_routes_cmd);</a>
<a name="ln954">}</a>

</code></pre>
<div class="balloon" rel="16"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
