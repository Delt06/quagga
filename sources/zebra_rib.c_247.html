
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>zebra_rib.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Routing Information Base.</a>
<a name="ln2"> * Copyright (C) 1997, 98, 99, 2001 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;prefix.h&quot;</a>
<a name="ln25">#include &quot;table.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;str.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31">#include &quot;sockunion.h&quot;</a>
<a name="ln32">#include &quot;linklist.h&quot;</a>
<a name="ln33">#include &quot;thread.h&quot;</a>
<a name="ln34">#include &quot;workqueue.h&quot;</a>
<a name="ln35">#include &quot;prefix.h&quot;</a>
<a name="ln36">#include &quot;routemap.h&quot;</a>
<a name="ln37">#include &quot;vrf.h&quot;</a>
<a name="ln38">#include &quot;nexthop.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;zebra/rib.h&quot;</a>
<a name="ln41">#include &quot;zebra/rt.h&quot;</a>
<a name="ln42">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln43">#include &quot;zebra/redistribute.h&quot;</a>
<a name="ln44">#include &quot;zebra/debug.h&quot;</a>
<a name="ln45">#include &quot;zebra/zebra_fpm.h&quot;</a>
<a name="ln46">#include &quot;zebra/zebra_rnh.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">/* Default rtm_table for all clients */</a>
<a name="ln49">extern struct zebra_t zebrad;</a>
<a name="ln50"> </a>
<a name="ln51">/* Hold time for RIB process, should be very minimal.</a>
<a name="ln52"> * it is useful to able to set it otherwise for testing, hence exported</a>
<a name="ln53"> * as global here for test-rig code.</a>
<a name="ln54"> */</a>
<a name="ln55">int rib_process_hold_time = 10;</a>
<a name="ln56"> </a>
<a name="ln57">/* Each route type's string and default distance value. */</a>
<a name="ln58">static const struct</a>
<a name="ln59">{  </a>
<a name="ln60">  int key;</a>
<a name="ln61">  int distance;</a>
<a name="ln62">} route_info[ZEBRA_ROUTE_MAX] =</a>
<a name="ln63">{</a>
<a name="ln64">  [ZEBRA_ROUTE_SYSTEM]  = {ZEBRA_ROUTE_SYSTEM,    0},</a>
<a name="ln65">  [ZEBRA_ROUTE_KERNEL]  = {ZEBRA_ROUTE_KERNEL,    0},</a>
<a name="ln66">  [ZEBRA_ROUTE_CONNECT] = {ZEBRA_ROUTE_CONNECT,   0},</a>
<a name="ln67">  [ZEBRA_ROUTE_STATIC]  = {ZEBRA_ROUTE_STATIC,    1},</a>
<a name="ln68">  [ZEBRA_ROUTE_RIP]     = {ZEBRA_ROUTE_RIP,     120},</a>
<a name="ln69">  [ZEBRA_ROUTE_RIPNG]   = {ZEBRA_ROUTE_RIPNG,   120},</a>
<a name="ln70">  [ZEBRA_ROUTE_OSPF]    = {ZEBRA_ROUTE_OSPF,    110},</a>
<a name="ln71">  [ZEBRA_ROUTE_OSPF6]   = {ZEBRA_ROUTE_OSPF6,   110},</a>
<a name="ln72">  [ZEBRA_ROUTE_ISIS]    = {ZEBRA_ROUTE_ISIS,    115},</a>
<a name="ln73">  [ZEBRA_ROUTE_BGP]     = {ZEBRA_ROUTE_BGP,      20  /* IBGP is 200. */},</a>
<a name="ln74">  [ZEBRA_ROUTE_BABEL]   = {ZEBRA_ROUTE_BABEL,    95},</a>
<a name="ln75">  [ZEBRA_ROUTE_NHRP]    = {ZEBRA_ROUTE_NHRP,     10},</a>
<a name="ln76">  /* no entry/default: 150 */</a>
<a name="ln77">};</a>
<a name="ln78"> </a>
<a name="ln79">/* RPF lookup behaviour */</a>
<a name="ln80">static enum multicast_mode ipv4_multicast_mode = MCAST_NO_CONFIG;</a>
<a name="ln81"> </a>
<a name="ln82">static void __attribute__((format (printf, 4, 5)))</a>
<a name="ln83">_rnode_zlog(const char *_func, struct route_node *rn, int priority,</a>
<a name="ln84">	    const char *msgfmt, ...)</a>
<a name="ln85">{</a>
<a name="ln86">  char prefix[PREFIX_STRLEN], buf[256];</a>
<a name="ln87">  char msgbuf[512];</a>
<a name="ln88">  va_list ap;</a>
<a name="ln89"> </a>
<a name="ln90">  va_start(ap, msgfmt);</a>
<a name="ln91">  vsnprintf(msgbuf, sizeof(msgbuf), msgfmt, ap);</a>
<a name="ln92">  va_end(ap);</a>
<a name="ln93"> </a>
<a name="ln94">  if (rn)</a>
<a name="ln95">    {</a>
<a name="ln96">      rib_table_info_t *info = rn-&gt;table-&gt;info;</a>
<a name="ln97"> </a>
<a name="ln98">      snprintf(buf, sizeof(buf), &quot;%s%s vrf %u&quot;,</a>
<a name="ln99">               prefix2str(&amp;rn-&gt;p, prefix, sizeof(prefix)),</a>
<a name="ln100">               info-&gt;safi == SAFI_MULTICAST ? &quot; (MRIB)&quot; : &quot;&quot;,</a>
<a name="ln101">               info-&gt;zvrf-&gt;vrf_id);</a>
<a name="ln102">    }</a>
<a name="ln103">  else</a>
<a name="ln104">    {</a>
<a name="ln105">      snprintf(buf, sizeof(buf), &quot;{(route_node *) NULL}&quot;);</a>
<a name="ln106">    }</a>
<a name="ln107"> </a>
<a name="ln108">  zlog (NULL, priority, &quot;%s: %s: %s&quot;, _func, buf, msgbuf);</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">#define rnode_debug(node, ...) \</a>
<a name="ln112">	_rnode_zlog(__func__, node, LOG_DEBUG, __VA_ARGS__)</a>
<a name="ln113">#define rnode_info(node, ...) \</a>
<a name="ln114">	_rnode_zlog(__func__, node, LOG_INFO, __VA_ARGS__)</a>
<a name="ln115"> </a>
<a name="ln116">/* Add nexthop to the end of a rib node's nexthop list */</a>
<a name="ln117">void</a>
<a name="ln118">rib_nexthop_add (struct rib *rib, struct nexthop *nexthop)</a>
<a name="ln119">{</a>
<a name="ln120">  nexthop_add(&amp;rib-&gt;nexthop, nexthop);</a>
<a name="ln121">  rib-&gt;nexthop_num++;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">/* Delete specified nexthop from the list. */</a>
<a name="ln125">static void</a>
<a name="ln126">rib_nexthop_delete (struct rib *rib, struct nexthop *nexthop)</a>
<a name="ln127">{</a>
<a name="ln128">  if (nexthop-&gt;next)</a>
<a name="ln129">    nexthop-&gt;next-&gt;prev = nexthop-&gt;prev;</a>
<a name="ln130">  if (nexthop-&gt;prev)</a>
<a name="ln131">    nexthop-&gt;prev-&gt;next = nexthop-&gt;next;</a>
<a name="ln132">  else</a>
<a name="ln133">    rib-&gt;nexthop = nexthop-&gt;next;</a>
<a name="ln134">  rib-&gt;nexthop_num--;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">struct nexthop *</a>
<a name="ln138">rib_nexthop_ifindex_add (struct rib *rib, ifindex_t ifindex)</a>
<a name="ln139">{</a>
<a name="ln140">  struct nexthop *nexthop;</a>
<a name="ln141"> </a>
<a name="ln142">  nexthop = nexthop_new ();</a>
<a name="ln143">  nexthop-&gt;type = NEXTHOP_TYPE_IFINDEX;</a>
<a name="ln144">  nexthop-&gt;ifindex = ifindex;</a>
<a name="ln145"> </a>
<a name="ln146">  rib_nexthop_add (rib, nexthop);</a>
<a name="ln147"> </a>
<a name="ln148">  return nexthop;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">struct nexthop *</a>
<a name="ln152">rib_nexthop_ifname_add (struct rib *rib, char *ifname)</a>
<a name="ln153">{</a>
<a name="ln154">  struct nexthop *nexthop;</a>
<a name="ln155"> </a>
<a name="ln156">  nexthop = nexthop_new ();</a>
<a name="ln157">  nexthop-&gt;type = NEXTHOP_TYPE_IFNAME;</a>
<a name="ln158">  nexthop-&gt;ifname = XSTRDUP (MTYPE_TMP, ifname);</a>
<a name="ln159"> </a>
<a name="ln160">  rib_nexthop_add (rib, nexthop);</a>
<a name="ln161"> </a>
<a name="ln162">  return nexthop;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">struct nexthop *</a>
<a name="ln166">rib_nexthop_ipv4_add (struct rib *rib, struct in_addr *ipv4, struct in_addr *src)</a>
<a name="ln167">{</a>
<a name="ln168">  struct nexthop *nexthop;</a>
<a name="ln169"> </a>
<a name="ln170">  nexthop = nexthop_new ();</a>
<a name="ln171">  nexthop-&gt;type = NEXTHOP_TYPE_IPV4;</a>
<a name="ln172">  nexthop-&gt;gate.ipv4 = *ipv4;</a>
<a name="ln173">  if (src)</a>
<a name="ln174">    nexthop-&gt;src.ipv4 = *src;</a>
<a name="ln175"> </a>
<a name="ln176">  rib_nexthop_add (rib, nexthop);</a>
<a name="ln177"> </a>
<a name="ln178">  return nexthop;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">struct nexthop *</a>
<a name="ln182">rib_nexthop_ipv4_ifindex_add (struct rib *rib, struct in_addr *ipv4, </a>
<a name="ln183">			      struct in_addr *src, ifindex_t ifindex)</a>
<a name="ln184">{</a>
<a name="ln185">  struct nexthop *nexthop;</a>
<a name="ln186"> </a>
<a name="ln187">  nexthop = nexthop_new ();</a>
<a name="ln188">  nexthop-&gt;type = NEXTHOP_TYPE_IPV4_IFINDEX;</a>
<a name="ln189">  nexthop-&gt;gate.ipv4 = *ipv4;</a>
<a name="ln190">  if (src)</a>
<a name="ln191">    nexthop-&gt;src.ipv4 = *src;</a>
<a name="ln192">  nexthop-&gt;ifindex = ifindex;</a>
<a name="ln193"> </a>
<a name="ln194">  rib_nexthop_add (rib, nexthop);</a>
<a name="ln195"> </a>
<a name="ln196">  return nexthop;</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">struct nexthop *</a>
<a name="ln200">rib_nexthop_ipv6_add (struct rib *rib, struct in6_addr *ipv6)</a>
<a name="ln201">{</a>
<a name="ln202">  struct nexthop *nexthop;</a>
<a name="ln203"> </a>
<a name="ln204">  nexthop = nexthop_new ();</a>
<a name="ln205">  nexthop-&gt;type = NEXTHOP_TYPE_IPV6;</a>
<a name="ln206">  nexthop-&gt;gate.ipv6 = *ipv6;</a>
<a name="ln207"> </a>
<a name="ln208">  rib_nexthop_add (rib, nexthop);</a>
<a name="ln209"> </a>
<a name="ln210">  return nexthop;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static struct nexthop *</a>
<a name="ln214">rib_nexthop_ipv6_ifname_add (struct rib *rib, struct in6_addr *ipv6,</a>
<a name="ln215">			     char *ifname)</a>
<a name="ln216">{</a>
<a name="ln217">  struct nexthop *nexthop;</a>
<a name="ln218"> </a>
<a name="ln219">  nexthop = nexthop_new ();</a>
<a name="ln220">  nexthop-&gt;type = NEXTHOP_TYPE_IPV6_IFNAME;</a>
<a name="ln221">  nexthop-&gt;gate.ipv6 = *ipv6;</a>
<a name="ln222">  nexthop-&gt;ifname = XSTRDUP (MTYPE_TMP, ifname);</a>
<a name="ln223"> </a>
<a name="ln224">  rib_nexthop_add (rib, nexthop);</a>
<a name="ln225"> </a>
<a name="ln226">  return nexthop;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">struct nexthop *</a>
<a name="ln230">rib_nexthop_ipv6_ifindex_add (struct rib *rib, struct in6_addr *ipv6,</a>
<a name="ln231">			      ifindex_t ifindex)</a>
<a name="ln232">{</a>
<a name="ln233">  struct nexthop *nexthop;</a>
<a name="ln234"> </a>
<a name="ln235">  nexthop = nexthop_new ();</a>
<a name="ln236">  nexthop-&gt;type = NEXTHOP_TYPE_IPV6_IFINDEX;</a>
<a name="ln237">  nexthop-&gt;gate.ipv6 = *ipv6;</a>
<a name="ln238">  nexthop-&gt;ifindex = ifindex;</a>
<a name="ln239"> </a>
<a name="ln240">  rib_nexthop_add (rib, nexthop);</a>
<a name="ln241"> </a>
<a name="ln242">  return nexthop;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">struct nexthop *</a>
<a name="ln246">rib_nexthop_blackhole_add (struct rib *rib)</a>
<a name="ln247">{</a>
<a name="ln248">  struct nexthop *nexthop;</a>
<a name="ln249"> </a>
<a name="ln250">  nexthop = nexthop_new ();</a>
<a name="ln251">  nexthop-&gt;type = NEXTHOP_TYPE_BLACKHOLE;</a>
<a name="ln252">  SET_FLAG (rib-&gt;flags, ZEBRA_FLAG_BLACKHOLE);</a>
<a name="ln253"> </a>
<a name="ln254">  rib_nexthop_add (rib, nexthop);</a>
<a name="ln255"> </a>
<a name="ln256">  return nexthop;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">/* This method checks whether a recursive nexthop has at</a>
<a name="ln260"> * least one resolved nexthop in the fib.</a>
<a name="ln261"> */</a>
<a name="ln262">int</a>
<a name="ln263">nexthop_has_fib_child(struct nexthop *nexthop)</a>
<a name="ln264">{</a>
<a name="ln265">  struct nexthop *nh;</a>
<a name="ln266"> </a>
<a name="ln267">  if (! CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE))</a>
<a name="ln268">    return 0;</a>
<a name="ln269"> </a>
<a name="ln270">  for (nh = nexthop-&gt;resolved; nh; nh = nh-&gt;next)</a>
<a name="ln271">    if (CHECK_FLAG (nh-&gt;flags, NEXTHOP_FLAG_FIB))</a>
<a name="ln272">      return 1;</a>
<a name="ln273"> </a>
<a name="ln274">  return 0;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">/* If force flag is not set, do not modify falgs at all for uninstall</a>
<a name="ln278">   the route from FIB. */</a>
<a name="ln279">static int</a>
<a name="ln280">nexthop_active_ipv4 (struct rib *rib, struct nexthop *nexthop, int set,</a>
<a name="ln281">		     struct route_node *top)</a>
<a name="ln282">{</a>
<a name="ln283">  struct prefix_ipv4 p;</a>
<a name="ln284">  struct route_table *table;</a>
<a name="ln285">  struct route_node *rn;</a>
<a name="ln286">  struct rib *match;</a>
<a name="ln287">  int resolved;</a>
<a name="ln288">  struct nexthop *newhop;</a>
<a name="ln289">  struct nexthop *resolved_hop;</a>
<a name="ln290"> </a>
<a name="ln291">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV4)</a>
<a name="ln292">    nexthop-&gt;ifindex = 0;</a>
<a name="ln293"> </a>
<a name="ln294">  if (set)</a>
<a name="ln295">    {</a>
<a name="ln296">      UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE);</a>
<a name="ln297">      nexthops_free(nexthop-&gt;resolved);</a>
<a name="ln298">      nexthop-&gt;resolved = NULL;</a>
<a name="ln299">      rib-&gt;nexthop_mtu = 0;</a>
<a name="ln300">    }</a>
<a name="ln301"> </a>
<a name="ln302">  /* Make lookup prefix. */</a>
<a name="ln303">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln304">  p.family = AF_INET;</a>
<a name="ln305">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln306">  p.prefix = nexthop-&gt;gate.ipv4;</a>
<a name="ln307"> </a>
<a name="ln308">  /* Lookup table.  */</a>
<a name="ln309">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, rib-&gt;vrf_id);</a>
<a name="ln310">  if (! table)</a>
<a name="ln311">    return 0;</a>
<a name="ln312"> </a>
<a name="ln313">  rn = route_node_match (table, (struct prefix *) &amp;p);</a>
<a name="ln314">  while (rn)</a>
<a name="ln315">    {</a>
<a name="ln316">      route_unlock_node (rn);</a>
<a name="ln317">      </a>
<a name="ln318">      /* If lookup self prefix return immediately. */</a>
<a name="ln319">      if (rn == top)</a>
<a name="ln320">	return 0;</a>
<a name="ln321"> </a>
<a name="ln322">      /* Pick up selected route. */</a>
<a name="ln323">      RNODE_FOREACH_RIB (rn, match)</a>
<a name="ln324">	{</a>
<a name="ln325">	  if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln326">	    continue;</a>
<a name="ln327">	  if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln328">	    break;</a>
<a name="ln329">	}</a>
<a name="ln330"> </a>
<a name="ln331">      /* If there is no selected route or matched route is EGP, go up</a>
<a name="ln332">         tree. */</a>
<a name="ln333">      if (! match </a>
<a name="ln334">	  || match-&gt;type == ZEBRA_ROUTE_BGP)</a>
<a name="ln335">	{</a>
<a name="ln336">	  do {</a>
<a name="ln337">	    rn = rn-&gt;parent;</a>
<a name="ln338">	  } while (rn &amp;&amp; rn-&gt;info == NULL);</a>
<a name="ln339">	  if (rn)</a>
<a name="ln340">	    route_lock_node (rn);</a>
<a name="ln341">	}</a>
<a name="ln342">      else</a>
<a name="ln343">	{</a>
<a name="ln344">	  /* If the longest prefix match for the nexthop yields</a>
<a name="ln345">	   * a blackhole, mark it as inactive. */</a>
<a name="ln346">	  if (CHECK_FLAG (match-&gt;flags, ZEBRA_FLAG_BLACKHOLE)</a>
<a name="ln347">	      || CHECK_FLAG (match-&gt;flags, ZEBRA_FLAG_REJECT))</a>
<a name="ln348">	    return 0;</a>
<a name="ln349"> </a>
<a name="ln350">	  if (match-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln351">	    {</a>
<a name="ln352">	      /* Directly point connected route. */</a>
<a name="ln353">	      newhop = match-&gt;nexthop;</a>
<a name="ln354">	      if (newhop &amp;&amp; nexthop-&gt;type == NEXTHOP_TYPE_IPV4)</a>
<a name="ln355">		nexthop-&gt;ifindex = newhop-&gt;ifindex;</a>
<a name="ln356">	      </a>
<a name="ln357">	      return 1;</a>
<a name="ln358">	    }</a>
<a name="ln359">	  else if (CHECK_FLAG (rib-&gt;flags, ZEBRA_FLAG_INTERNAL))</a>
<a name="ln360">	    {</a>
<a name="ln361">	      resolved = 0;</a>
<a name="ln362">	      for (newhop = match-&gt;nexthop; newhop; newhop = newhop-&gt;next)</a>
<a name="ln363">		if (CHECK_FLAG (newhop-&gt;flags, NEXTHOP_FLAG_FIB)</a>
<a name="ln364">		    &amp;&amp; ! CHECK_FLAG (newhop-&gt;flags, NEXTHOP_FLAG_RECURSIVE))</a>
<a name="ln365">		  {</a>
<a name="ln366">		    if (set)</a>
<a name="ln367">		      {</a>
<a name="ln368">			SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE);</a>
<a name="ln369"> </a>
<a name="ln370">			resolved_hop = XCALLOC(MTYPE_NEXTHOP, sizeof (struct nexthop));</a>
<a name="ln371">			SET_FLAG (resolved_hop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln372">			/* If the resolving route specifies a gateway, use it */</a>
<a name="ln373">			if (newhop-&gt;type == NEXTHOP_TYPE_IPV4</a>
<a name="ln374">			    || newhop-&gt;type == NEXTHOP_TYPE_IPV4_IFINDEX</a>
<a name="ln375">			    || newhop-&gt;type == NEXTHOP_TYPE_IPV4_IFNAME)</a>
<a name="ln376">			  {</a>
<a name="ln377">			    resolved_hop-&gt;type = newhop-&gt;type;</a>
<a name="ln378">			    resolved_hop-&gt;gate.ipv4 = newhop-&gt;gate.ipv4;</a>
<a name="ln379">			    resolved_hop-&gt;ifindex = newhop-&gt;ifindex;</a>
<a name="ln380">			  }</a>
<a name="ln381"> </a>
<a name="ln382">			/* If the resolving route is an interface route, it</a>
<a name="ln383">			 * means the gateway we are looking up is connected</a>
<a name="ln384">			 * to that interface. Therefore, the resolved route</a>
<a name="ln385">			 * should have the original gateway as nexthop as it</a>
<a name="ln386">			 * is directly connected. */</a>
<a name="ln387">			if (newhop-&gt;type == NEXTHOP_TYPE_IFINDEX</a>
<a name="ln388">			    || newhop-&gt;type == NEXTHOP_TYPE_IFNAME)</a>
<a name="ln389">			  {</a>
<a name="ln390">			    resolved_hop-&gt;type = NEXTHOP_TYPE_IPV4_IFINDEX;</a>
<a name="ln391">			    resolved_hop-&gt;gate.ipv4 = nexthop-&gt;gate.ipv4;</a>
<a name="ln392">			    resolved_hop-&gt;ifindex = newhop-&gt;ifindex;</a>
<a name="ln393">			  }</a>
<a name="ln394"> </a>
<a name="ln395">			nexthop_add(&amp;nexthop-&gt;resolved, resolved_hop);</a>
<a name="ln396">		      }</a>
<a name="ln397">		    resolved = 1;</a>
<a name="ln398">		  }</a>
<a name="ln399">              if (resolved &amp;&amp; set)</a>
<a name="ln400">                rib-&gt;nexthop_mtu = match-&gt;mtu;</a>
<a name="ln401">	      return resolved;</a>
<a name="ln402">	    }</a>
<a name="ln403">	  else</a>
<a name="ln404">	    {</a>
<a name="ln405">	      return 0;</a>
<a name="ln406">	    }</a>
<a name="ln407">	}</a>
<a name="ln408">    }</a>
<a name="ln409">  return 0;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">/* If force flag is not set, do not modify falgs at all for uninstall</a>
<a name="ln413">   the route from FIB. */</a>
<a name="ln414">static int</a>
<a name="ln415">nexthop_active_ipv6 (struct rib *rib, struct nexthop *nexthop, int set,</a>
<a name="ln416">		     struct route_node *top)</a>
<a name="ln417">{</a>
<a name="ln418">  struct prefix_ipv6 p;</a>
<a name="ln419">  struct route_table *table;</a>
<a name="ln420">  struct route_node *rn;</a>
<a name="ln421">  struct rib *match;</a>
<a name="ln422">  int resolved;</a>
<a name="ln423">  struct nexthop *newhop;</a>
<a name="ln424">  struct nexthop *resolved_hop;</a>
<a name="ln425"> </a>
<a name="ln426">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV6)</a>
<a name="ln427">    nexthop-&gt;ifindex = 0;</a>
<a name="ln428"> </a>
<a name="ln429">  if (set)</a>
<a name="ln430">    {</a>
<a name="ln431">      UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE);</a>
<a name="ln432">      nexthops_free(nexthop-&gt;resolved);</a>
<a name="ln433">      nexthop-&gt;resolved = NULL;</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">  /* Make lookup prefix. */</a>
<a name="ln437">  memset (&amp;p, 0, sizeof (struct prefix_ipv6));</a>
<a name="ln438">  p.family = AF_INET6;</a>
<a name="ln439">  p.prefixlen = IPV6_MAX_PREFIXLEN;</a>
<a name="ln440">  p.prefix = nexthop-&gt;gate.ipv6;</a>
<a name="ln441"> </a>
<a name="ln442">  /* Lookup table.  */</a>
<a name="ln443">  table = zebra_vrf_table (AFI_IP6, SAFI_UNICAST, rib-&gt;vrf_id);</a>
<a name="ln444">  if (! table)</a>
<a name="ln445">    return 0;</a>
<a name="ln446"> </a>
<a name="ln447">  rn = route_node_match (table, (struct prefix *) &amp;p);</a>
<a name="ln448">  while (rn)</a>
<a name="ln449">    {</a>
<a name="ln450">      route_unlock_node (rn);</a>
<a name="ln451">      </a>
<a name="ln452">      /* If lookup self prefix return immediately. */</a>
<a name="ln453">      if (rn == top)</a>
<a name="ln454">	return 0;</a>
<a name="ln455"> </a>
<a name="ln456">      /* Pick up selected route. */</a>
<a name="ln457">      RNODE_FOREACH_RIB (rn, match)</a>
<a name="ln458">	{</a>
<a name="ln459">	  if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln460">	    continue;</a>
<a name="ln461">	  if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln462">	    break;</a>
<a name="ln463">	}</a>
<a name="ln464"> </a>
<a name="ln465">      /* If there is no selected route or matched route is EGP, go up</a>
<a name="ln466">         tree. */</a>
<a name="ln467">      if (! match</a>
<a name="ln468">	  || match-&gt;type == ZEBRA_ROUTE_BGP)</a>
<a name="ln469">	{</a>
<a name="ln470">	  do {</a>
<a name="ln471">	    rn = rn-&gt;parent;</a>
<a name="ln472">	  } while (rn &amp;&amp; rn-&gt;info == NULL);</a>
<a name="ln473">	  if (rn)</a>
<a name="ln474">	    route_lock_node (rn);</a>
<a name="ln475">	}</a>
<a name="ln476">      else</a>
<a name="ln477">	{</a>
<a name="ln478">	  /* If the longest prefix match for the nexthop yields</a>
<a name="ln479">	   * a blackhole, mark it as inactive. */</a>
<a name="ln480">	  if (CHECK_FLAG (match-&gt;flags, ZEBRA_FLAG_BLACKHOLE)</a>
<a name="ln481">	      || CHECK_FLAG (match-&gt;flags, ZEBRA_FLAG_REJECT))</a>
<a name="ln482">	    return 0;</a>
<a name="ln483"> </a>
<a name="ln484">	  if (match-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln485">	    {</a>
<a name="ln486">	      /* Directly point connected route. */</a>
<a name="ln487">	      newhop = match-&gt;nexthop;</a>
<a name="ln488"> </a>
<a name="ln489">	      if (newhop &amp;&amp; nexthop-&gt;type == NEXTHOP_TYPE_IPV6)</a>
<a name="ln490">		nexthop-&gt;ifindex = newhop-&gt;ifindex;</a>
<a name="ln491">	      </a>
<a name="ln492">	      return 1;</a>
<a name="ln493">	    }</a>
<a name="ln494">	  else if (CHECK_FLAG (rib-&gt;flags, ZEBRA_FLAG_INTERNAL))</a>
<a name="ln495">	    {</a>
<a name="ln496">	      resolved = 0;</a>
<a name="ln497">	      for (newhop = match-&gt;nexthop; newhop; newhop = newhop-&gt;next)</a>
<a name="ln498">		if (CHECK_FLAG (newhop-&gt;flags, NEXTHOP_FLAG_FIB)</a>
<a name="ln499">		    &amp;&amp; ! CHECK_FLAG (newhop-&gt;flags, NEXTHOP_FLAG_RECURSIVE))</a>
<a name="ln500">		  {</a>
<a name="ln501">		    if (set)</a>
<a name="ln502">		      {</a>
<a name="ln503">			SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE);</a>
<a name="ln504"> </a>
<a name="ln505">			resolved_hop = XCALLOC(MTYPE_NEXTHOP, sizeof (struct nexthop));</a>
<a name="ln506">			SET_FLAG (resolved_hop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln507">			/* See nexthop_active_ipv4 for a description how the</a>
<a name="ln508">			 * resolved nexthop is constructed. */</a>
<a name="ln509">			if (newhop-&gt;type == NEXTHOP_TYPE_IPV6</a>
<a name="ln510">			    || newhop-&gt;type == NEXTHOP_TYPE_IPV6_IFINDEX</a>
<a name="ln511">			    || newhop-&gt;type == NEXTHOP_TYPE_IPV6_IFNAME)</a>
<a name="ln512">			  {</a>
<a name="ln513">			    resolved_hop-&gt;type = newhop-&gt;type;</a>
<a name="ln514">			    resolved_hop-&gt;gate.ipv6 = newhop-&gt;gate.ipv6;</a>
<a name="ln515"> </a>
<a name="ln516">			    if (newhop-&gt;ifindex)</a>
<a name="ln517">			      {</a>
<a name="ln518">				resolved_hop-&gt;type = NEXTHOP_TYPE_IPV6_IFINDEX;</a>
<a name="ln519">				resolved_hop-&gt;ifindex = newhop-&gt;ifindex;</a>
<a name="ln520">			      }</a>
<a name="ln521">			  }</a>
<a name="ln522"> </a>
<a name="ln523">			if (newhop-&gt;type == NEXTHOP_TYPE_IFINDEX</a>
<a name="ln524">			    || newhop-&gt;type == NEXTHOP_TYPE_IFNAME)</a>
<a name="ln525">			  {</a>
<a name="ln526">				resolved_hop-&gt;flags |= NEXTHOP_FLAG_ONLINK;</a>
<a name="ln527">				resolved_hop-&gt;type = NEXTHOP_TYPE_IPV6_IFINDEX;</a>
<a name="ln528">				resolved_hop-&gt;gate.ipv6 = nexthop-&gt;gate.ipv6;</a>
<a name="ln529">				resolved_hop-&gt;ifindex = newhop-&gt;ifindex;</a>
<a name="ln530">			  }</a>
<a name="ln531"> </a>
<a name="ln532">			nexthop_add(&amp;nexthop-&gt;resolved, resolved_hop);</a>
<a name="ln533">		      }</a>
<a name="ln534">		    resolved = 1;</a>
<a name="ln535">		  }</a>
<a name="ln536">	      return resolved;</a>
<a name="ln537">	    }</a>
<a name="ln538">	  else</a>
<a name="ln539">	    {</a>
<a name="ln540">	      return 0;</a>
<a name="ln541">	    }</a>
<a name="ln542">	}</a>
<a name="ln543">    }</a>
<a name="ln544">  return 0;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">struct rib *</a>
<a name="ln548">rib_match_ipv4_safi (struct in_addr addr, safi_t safi, int skip_bgp,</a>
<a name="ln549">		     struct route_node **rn_out, vrf_id_t vrf_id)</a>
<a name="ln550">{</a>
<a name="ln551">  struct route_table *table;</a>
<a name="ln552">  struct route_node *rn;</a>
<a name="ln553">  struct rib *match;</a>
<a name="ln554">  struct nexthop *newhop, *tnewhop;</a>
<a name="ln555">  int recursing;</a>
<a name="ln556"> </a>
<a name="ln557">  /* Lookup table.  */</a>
<a name="ln558">  table = zebra_vrf_table (AFI_IP, safi, vrf_id);</a>
<a name="ln559">  if (! table)</a>
<a name="ln560">    return 0;</a>
<a name="ln561"> </a>
<a name="ln562">  rn = route_node_match_ipv4 (table, &amp;addr);</a>
<a name="ln563"> </a>
<a name="ln564">  while (rn)</a>
<a name="ln565">    {</a>
<a name="ln566">      route_unlock_node (rn);</a>
<a name="ln567"> </a>
<a name="ln568">      /* Pick up selected route. */</a>
<a name="ln569">      RNODE_FOREACH_RIB (rn, match)</a>
<a name="ln570">	{</a>
<a name="ln571">	  if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln572">	    continue;</a>
<a name="ln573">	  if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln574">	    break;</a>
<a name="ln575">	}</a>
<a name="ln576"> </a>
<a name="ln577">      /* If there is no selected route or matched route is EGP, go up</a>
<a name="ln578">         tree. */</a>
<a name="ln579">      if (!match || (skip_bgp &amp;&amp; (match-&gt;type == ZEBRA_ROUTE_BGP)))</a>
<a name="ln580">	{</a>
<a name="ln581">	  do {</a>
<a name="ln582">	    rn = rn-&gt;parent;</a>
<a name="ln583">	  } while (rn &amp;&amp; rn-&gt;info == NULL);</a>
<a name="ln584">	  if (rn)</a>
<a name="ln585">	    route_lock_node (rn);</a>
<a name="ln586">	}</a>
<a name="ln587">      else</a>
<a name="ln588">	{</a>
<a name="ln589">	  if (match-&gt;type != ZEBRA_ROUTE_CONNECT)</a>
<a name="ln590">	    {</a>
<a name="ln591">	      int found = 0;</a>
<a name="ln592">	      for (ALL_NEXTHOPS_RO(match-&gt;nexthop, newhop, tnewhop, recursing))</a>
<a name="ln593">		if (CHECK_FLAG (newhop-&gt;flags, NEXTHOP_FLAG_FIB))</a>
<a name="ln594">		  {</a>
<a name="ln595">		    found = 1;</a>
<a name="ln596">		    break;</a>
<a name="ln597">		  }</a>
<a name="ln598">	      if (!found)</a>
<a name="ln599">		return NULL;</a>
<a name="ln600">	    }</a>
<a name="ln601"> </a>
<a name="ln602">	  if (rn_out)</a>
<a name="ln603">	    *rn_out = rn;</a>
<a name="ln604">	  return match;</a>
<a name="ln605">	}</a>
<a name="ln606">    }</a>
<a name="ln607">  return NULL;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">struct rib *</a>
<a name="ln611">rib_match_ipv4_multicast (struct in_addr addr, struct route_node **rn_out,</a>
<a name="ln612">    vrf_id_t vrf_id)</a>
<a name="ln613">{</a>
<a name="ln614">  struct rib *rib = NULL, *mrib = NULL, *urib = NULL;</a>
<a name="ln615">  struct route_node *m_rn = NULL, *u_rn = NULL;</a>
<a name="ln616">  int skip_bgp = 0; /* bool */</a>
<a name="ln617"> </a>
<a name="ln618">  switch (ipv4_multicast_mode)</a>
<a name="ln619">    {</a>
<a name="ln620">    case MCAST_MRIB_ONLY:</a>
<a name="ln621">      return rib_match_ipv4_safi (addr, SAFI_MULTICAST, skip_bgp, rn_out,</a>
<a name="ln622">                                  vrf_id);</a>
<a name="ln623">    case MCAST_URIB_ONLY:</a>
<a name="ln624">      return rib_match_ipv4_safi (addr, SAFI_UNICAST, skip_bgp, rn_out,</a>
<a name="ln625">                                  vrf_id);</a>
<a name="ln626">    case MCAST_NO_CONFIG:</a>
<a name="ln627">    case MCAST_MIX_MRIB_FIRST:</a>
<a name="ln628">      rib = mrib = rib_match_ipv4_safi (addr, SAFI_MULTICAST, skip_bgp, &amp;m_rn,</a>
<a name="ln629">                                        vrf_id);</a>
<a name="ln630">      if (!mrib)</a>
<a name="ln631">        rib = urib = rib_match_ipv4_safi (addr, SAFI_UNICAST, skip_bgp, &amp;u_rn,</a>
<a name="ln632">                                          vrf_id);</a>
<a name="ln633">      break;</a>
<a name="ln634">    case MCAST_MIX_DISTANCE:</a>
<a name="ln635">      mrib = rib_match_ipv4_safi (addr, SAFI_MULTICAST, skip_bgp, &amp;m_rn,</a>
<a name="ln636">                                  vrf_id);</a>
<a name="ln637">      urib = rib_match_ipv4_safi (addr, SAFI_UNICAST, skip_bgp, &amp;u_rn,</a>
<a name="ln638">                                  vrf_id);</a>
<a name="ln639">      if (mrib &amp;&amp; urib)</a>
<a name="ln640">	rib = urib-&gt;distance &lt; mrib-&gt;distance ? urib : mrib;</a>
<a name="ln641">      else if (mrib)</a>
<a name="ln642">	rib = mrib;</a>
<a name="ln643">      else if (urib)</a>
<a name="ln644">	rib = urib;</a>
<a name="ln645">      break;</a>
<a name="ln646">    case MCAST_MIX_PFXLEN:</a>
<a name="ln647">      mrib = rib_match_ipv4_safi (addr, SAFI_MULTICAST, skip_bgp, &amp;m_rn,</a>
<a name="ln648">                                  vrf_id);</a>
<a name="ln649">      urib = rib_match_ipv4_safi (addr, SAFI_UNICAST, skip_bgp, &amp;u_rn,</a>
<a name="ln650">                                  vrf_id);</a>
<a name="ln651">      if (mrib &amp;&amp; urib)</a>
<a name="ln652">	rib = u_rn-&gt;p.prefixlen &gt; m_rn-&gt;p.prefixlen ? urib : mrib;</a>
<a name="ln653">      else if (mrib)</a>
<a name="ln654">	rib = mrib;</a>
<a name="ln655">      else if (urib)</a>
<a name="ln656">	rib = urib;</a>
<a name="ln657">      break;</a>
<a name="ln658">  }</a>
<a name="ln659"> </a>
<a name="ln660">  if (rn_out)</a>
<a name="ln661">    *rn_out = (rib == mrib) ? m_rn : u_rn;</a>
<a name="ln662"> </a>
<a name="ln663">  if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln664">    {</a>
<a name="ln665">      char buf[BUFSIZ];</a>
<a name="ln666">      inet_ntop (AF_INET, &amp;addr, buf, BUFSIZ);</a>
<a name="ln667"> </a>
<a name="ln668">      zlog_debug(&quot;%s: %s vrf %u: found %s, using %s&quot;,</a>
<a name="ln669">		 __func__, buf, vrf_id,</a>
<a name="ln670">                 mrib ? (urib ? &quot;MRIB+URIB&quot; : &quot;MRIB&quot;) :</a>
<a name="ln671">                         urib ? &quot;URIB&quot; : &quot;nothing&quot;,</a>
<a name="ln672">		 rib == urib ? &quot;URIB&quot; : rib == mrib ? &quot;MRIB&quot; : &quot;none&quot;);</a>
<a name="ln673">    }</a>
<a name="ln674">  return rib;</a>
<a name="ln675">}</a>
<a name="ln676"> </a>
<a name="ln677">void</a>
<a name="ln678">multicast_mode_ipv4_set (enum multicast_mode mode)</a>
<a name="ln679">{</a>
<a name="ln680">  if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln681">    zlog_debug(&quot;%s: multicast lookup mode set (%d)&quot;, __func__, mode);</a>
<a name="ln682">  ipv4_multicast_mode = mode;</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">enum multicast_mode</a>
<a name="ln686">multicast_mode_ipv4_get (void)</a>
<a name="ln687">{</a>
<a name="ln688">  return ipv4_multicast_mode;</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">struct rib *</a>
<a name="ln692">rib_lookup_ipv4 (struct prefix_ipv4 *p, vrf_id_t vrf_id)</a>
<a name="ln693">{</a>
<a name="ln694">  struct route_table *table;</a>
<a name="ln695">  struct route_node *rn;</a>
<a name="ln696">  struct rib *match;</a>
<a name="ln697">  struct nexthop *nexthop, *tnexthop;</a>
<a name="ln698">  int recursing;</a>
<a name="ln699"> </a>
<a name="ln700">  /* Lookup table.  */</a>
<a name="ln701">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, vrf_id);</a>
<a name="ln702">  if (! table)</a>
<a name="ln703">    return 0;</a>
<a name="ln704"> </a>
<a name="ln705">  rn = route_node_lookup (table, (struct prefix *) p);</a>
<a name="ln706"> </a>
<a name="ln707">  /* No route for this prefix. */</a>
<a name="ln708">  if (! rn)</a>
<a name="ln709">    return NULL;</a>
<a name="ln710"> </a>
<a name="ln711">  /* Unlock node. */</a>
<a name="ln712">  route_unlock_node (rn);</a>
<a name="ln713"> </a>
<a name="ln714">  RNODE_FOREACH_RIB (rn, match)</a>
<a name="ln715">    {</a>
<a name="ln716">      if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln717">	continue;</a>
<a name="ln718">      if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln719">	break;</a>
<a name="ln720">    }</a>
<a name="ln721"> </a>
<a name="ln722">  if (! match || match-&gt;type == ZEBRA_ROUTE_BGP)</a>
<a name="ln723">    return NULL;</a>
<a name="ln724"> </a>
<a name="ln725">  if (match-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln726">    return match;</a>
<a name="ln727">  </a>
<a name="ln728">  for (ALL_NEXTHOPS_RO(match-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln729">    if (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB))</a>
<a name="ln730">      return match;</a>
<a name="ln731"> </a>
<a name="ln732">  return NULL;</a>
<a name="ln733">}</a>
<a name="ln734"> </a>
<a name="ln735">/*</a>
<a name="ln736"> * This clone function, unlike its original rib_lookup_ipv4(), checks</a>
<a name="ln737"> * if specified IPv4 route record (prefix/mask -&gt; gate) exists in</a>
<a name="ln738"> * the whole RIB and has ZEBRA_FLAG_SELECTED set.</a>
<a name="ln739"> *</a>
<a name="ln740"> * Return values:</a>
<a name="ln741"> * -1: error</a>
<a name="ln742"> * 0: exact match found</a>
<a name="ln743"> * 1: a match was found with a different gate</a>
<a name="ln744"> * 2: connected route found</a>
<a name="ln745"> * 3: no matches found</a>
<a name="ln746"> */</a>
<a name="ln747">int</a>
<a name="ln748">rib_lookup_ipv4_route (struct prefix_ipv4 *p, union sockunion * qgate,</a>
<a name="ln749">    vrf_id_t vrf_id)</a>
<a name="ln750">{</a>
<a name="ln751">  struct route_table *table;</a>
<a name="ln752">  struct route_node *rn;</a>
<a name="ln753">  struct rib *match;</a>
<a name="ln754">  struct nexthop *nexthop, *tnexthop;</a>
<a name="ln755">  int recursing;</a>
<a name="ln756">  int nexthops_active;</a>
<a name="ln757"> </a>
<a name="ln758">  /* Lookup table.  */</a>
<a name="ln759">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, vrf_id);</a>
<a name="ln760">  if (! table)</a>
<a name="ln761">    return ZEBRA_RIB_LOOKUP_ERROR;</a>
<a name="ln762"> </a>
<a name="ln763">  /* Scan the RIB table for exactly matching RIB entry. */</a>
<a name="ln764">  rn = route_node_lookup (table, (struct prefix *) p);</a>
<a name="ln765"> </a>
<a name="ln766">  /* No route for this prefix. */</a>
<a name="ln767">  if (! rn)</a>
<a name="ln768">    return ZEBRA_RIB_NOTFOUND;</a>
<a name="ln769"> </a>
<a name="ln770">  /* Unlock node. */</a>
<a name="ln771">  route_unlock_node (rn);</a>
<a name="ln772"> </a>
<a name="ln773">  /* Find out if a &quot;selected&quot; RR for the discovered RIB entry exists ever. */</a>
<a name="ln774">  RNODE_FOREACH_RIB (rn, match)</a>
<a name="ln775">    {</a>
<a name="ln776">      if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln777">	continue;</a>
<a name="ln778">      if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln779">	break;</a>
<a name="ln780">    }</a>
<a name="ln781"> </a>
<a name="ln782">  /* None such found :( */</a>
<a name="ln783">  if (!match)</a>
<a name="ln784">    return ZEBRA_RIB_NOTFOUND;</a>
<a name="ln785"> </a>
<a name="ln786">  if (match-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln787">    return ZEBRA_RIB_FOUND_CONNECTED;</a>
<a name="ln788">  </a>
<a name="ln789">  /* Ok, we have a cood candidate, let's check it's nexthop list... */</a>
<a name="ln790">  nexthops_active = 0;</a>
<a name="ln791">  for (ALL_NEXTHOPS_RO(match-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln792">    if (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB))</a>
<a name="ln793">      {</a>
<a name="ln794">        nexthops_active = 1;</a>
<a name="ln795">        if (nexthop-&gt;gate.ipv4.s_addr == sockunion2ip (qgate))</a>
<a name="ln796">          return ZEBRA_RIB_FOUND_EXACT;</a>
<a name="ln797">        if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln798">          {</a>
<a name="ln799">            char gate_buf[INET_ADDRSTRLEN], qgate_buf[INET_ADDRSTRLEN];</a>
<a name="ln800">            inet_ntop (AF_INET, &amp;nexthop-&gt;gate.ipv4.s_addr, gate_buf, INET_ADDRSTRLEN);</a>
<a name="ln801">            inet_ntop (AF_INET, &amp;sockunion2ip(qgate), qgate_buf, INET_ADDRSTRLEN);</a>
<a name="ln802">            zlog_debug (&quot;%s: qgate == %s, %s == %s&quot;, __func__,</a>
<a name="ln803">                        qgate_buf, recursing ? &quot;rgate&quot; : &quot;gate&quot;, gate_buf);</a>
<a name="ln804">          }</a>
<a name="ln805">      }</a>
<a name="ln806"> </a>
<a name="ln807">  if (nexthops_active)</a>
<a name="ln808">    return ZEBRA_RIB_FOUND_NOGATE;</a>
<a name="ln809"> </a>
<a name="ln810">  return ZEBRA_RIB_NOTFOUND;</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">struct rib *</a>
<a name="ln814">rib_match_ipv6 (struct in6_addr *addr, vrf_id_t vrf_id)</a>
<a name="ln815">{</a>
<a name="ln816">  struct prefix_ipv6 p;</a>
<a name="ln817">  struct route_table *table;</a>
<a name="ln818">  struct route_node *rn;</a>
<a name="ln819">  struct rib *match;</a>
<a name="ln820">  struct nexthop *newhop, *tnewhop;</a>
<a name="ln821">  int recursing;</a>
<a name="ln822"> </a>
<a name="ln823">  /* Lookup table.  */</a>
<a name="ln824">  table = zebra_vrf_table (AFI_IP6, SAFI_UNICAST, vrf_id);</a>
<a name="ln825">  if (! table)</a>
<a name="ln826">    return 0;</a>
<a name="ln827"> </a>
<a name="ln828">  memset (&amp;p, 0, sizeof (struct prefix_ipv6));</a>
<a name="ln829">  p.family = AF_INET6;</a>
<a name="ln830">  p.prefixlen = IPV6_MAX_PREFIXLEN;</a>
<a name="ln831">  IPV6_ADDR_COPY (&amp;p.prefix, addr);</a>
<a name="ln832"> </a>
<a name="ln833">  rn = route_node_match (table, (struct prefix *) &amp;p);</a>
<a name="ln834"> </a>
<a name="ln835">  while (rn)</a>
<a name="ln836">    {</a>
<a name="ln837">      route_unlock_node (rn);</a>
<a name="ln838">      </a>
<a name="ln839">      /* Pick up selected route. */</a>
<a name="ln840">      RNODE_FOREACH_RIB (rn, match)</a>
<a name="ln841">	{</a>
<a name="ln842">	  if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln843">	    continue;</a>
<a name="ln844">	  if (CHECK_FLAG (match-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln845">	    break;</a>
<a name="ln846">	}</a>
<a name="ln847"> </a>
<a name="ln848">      /* If there is no selected route or matched route is EGP, go up</a>
<a name="ln849">         tree. */</a>
<a name="ln850">      if (! match </a>
<a name="ln851">	  || match-&gt;type == ZEBRA_ROUTE_BGP)</a>
<a name="ln852">	{</a>
<a name="ln853">	  do {</a>
<a name="ln854">	    rn = rn-&gt;parent;</a>
<a name="ln855">	  } while (rn &amp;&amp; rn-&gt;info == NULL);</a>
<a name="ln856">	  if (rn)</a>
<a name="ln857">	    route_lock_node (rn);</a>
<a name="ln858">	}</a>
<a name="ln859">      else</a>
<a name="ln860">	{</a>
<a name="ln861">	  if (match-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln862">	    /* Directly point connected route. */</a>
<a name="ln863">	    return match;</a>
<a name="ln864">	  else</a>
<a name="ln865">	    {</a>
<a name="ln866">	      for (ALL_NEXTHOPS_RO(match-&gt;nexthop, newhop, tnewhop, recursing))</a>
<a name="ln867">		if (CHECK_FLAG (newhop-&gt;flags, NEXTHOP_FLAG_FIB))</a>
<a name="ln868">		  return match;</a>
<a name="ln869">	      return NULL;</a>
<a name="ln870">	    }</a>
<a name="ln871">	}</a>
<a name="ln872">    }</a>
<a name="ln873">  return NULL;</a>
<a name="ln874">}</a>
<a name="ln875"> </a>
<a name="ln876">#define RIB_SYSTEM_ROUTE(R) \</a>
<a name="ln877">        ((R)-&gt;type == ZEBRA_ROUTE_KERNEL || (R)-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln878"> </a>
<a name="ln879">/* This function verifies reachability of one given nexthop, which can be</a>
<a name="ln880"> * numbered or unnumbered, IPv4 or IPv6. The result is unconditionally stored</a>
<a name="ln881"> * in nexthop-&gt;flags field. If the 4th parameter, 'set', is non-zero,</a>
<a name="ln882"> * nexthop-&gt;ifindex will be updated appropriately as well.</a>
<a name="ln883"> * An existing route map can turn (otherwise active) nexthop into inactive, but</a>
<a name="ln884"> * not vice versa.</a>
<a name="ln885"> *</a>
<a name="ln886"> * The return value is the final value of 'ACTIVE' flag.</a>
<a name="ln887"> */</a>
<a name="ln888"> </a>
<a name="ln889">static unsigned</a>
<a name="ln890">nexthop_active_check (struct route_node *rn, struct rib *rib,</a>
<a name="ln891">		      struct nexthop *nexthop, int set)</a>
<a name="ln892">{</a>
<a name="ln893">  rib_table_info_t *info = rn-&gt;table-&gt;info;</a>
<a name="ln894">  struct interface *ifp;</a>
<a name="ln895">  route_map_result_t ret = RMAP_MATCH;</a>
<a name="ln896">  extern char *proto_rm[AFI_MAX][ZEBRA_ROUTE_MAX+1];</a>
<a name="ln897">  struct route_map *rmap;</a>
<a name="ln898">  int family;</a>
<a name="ln899"> </a>
<a name="ln900">  family = 0;</a>
<a name="ln901">  switch (nexthop-&gt;type)</a>
<a name="ln902">    {</a>
<a name="ln903">    case NEXTHOP_TYPE_IFINDEX:</a>
<a name="ln904">      ifp = if_lookup_by_index_vrf (nexthop-&gt;ifindex, rib-&gt;vrf_id);</a>
<a name="ln905">      if (ifp &amp;&amp; if_is_operative(ifp))</a>
<a name="ln906">	SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln907">      else</a>
<a name="ln908">	UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln909">      break;</a>
<a name="ln910">    case NEXTHOP_TYPE_IPV6_IFNAME:</a>
<a name="ln911">      family = AFI_IP6;</a>
<a name="ln912">    case NEXTHOP_TYPE_IFNAME:</a>
<a name="ln913">      ifp = if_lookup_by_name_vrf (nexthop-&gt;ifname, rib-&gt;vrf_id);</a>
<a name="ln914">      if (ifp &amp;&amp; if_is_operative(ifp))</a>
<a name="ln915">	{</a>
<a name="ln916">	  if (set)</a>
<a name="ln917">	    nexthop-&gt;ifindex = ifp-&gt;ifindex;</a>
<a name="ln918">	  SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln919">	}</a>
<a name="ln920">      else</a>
<a name="ln921">	{</a>
<a name="ln922">	  if (set)</a>
<a name="ln923">	    nexthop-&gt;ifindex = 0;</a>
<a name="ln924">	  UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln925">	}</a>
<a name="ln926">      break;</a>
<a name="ln927">    case NEXTHOP_TYPE_IPV4:</a>
<a name="ln928">    case NEXTHOP_TYPE_IPV4_IFINDEX:</a>
<a name="ln929">      family = AFI_IP;</a>
<a name="ln930">      if (nexthop_active_ipv4 (rib, nexthop, set, rn))</a>
<a name="ln931">	SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln932">      else</a>
<a name="ln933">	UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln934">      break;</a>
<a name="ln935">    case NEXTHOP_TYPE_IPV6:</a>
<a name="ln936">      family = AFI_IP6;</a>
<a name="ln937">      if (nexthop_active_ipv6 (rib, nexthop, set, rn))</a>
<a name="ln938">	SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln939">      else</a>
<a name="ln940">	UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln941">      break;</a>
<a name="ln942">    case NEXTHOP_TYPE_IPV6_IFINDEX:</a>
<a name="ln943">      family = AFI_IP6;</a>
<a name="ln944">      if (IN6_IS_ADDR_LINKLOCAL (&amp;nexthop-&gt;gate.ipv6))</a>
<a name="ln945">	{</a>
<a name="ln946">	  ifp = if_lookup_by_index_vrf (nexthop-&gt;ifindex, rib-&gt;vrf_id);</a>
<a name="ln947">	  if (ifp &amp;&amp; if_is_operative(ifp))</a>
<a name="ln948">	    SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln949">	  else</a>
<a name="ln950">	    UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln951">	}</a>
<a name="ln952">      else</a>
<a name="ln953">	{</a>
<a name="ln954">	  if (nexthop_active_ipv6 (rib, nexthop, set, rn))</a>
<a name="ln955">	    SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln956">	  else</a>
<a name="ln957">	    UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln958">	}</a>
<a name="ln959">      break;</a>
<a name="ln960">    case NEXTHOP_TYPE_BLACKHOLE:</a>
<a name="ln961">      SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln962">      break;</a>
<a name="ln963">    default:</a>
<a name="ln964">      break;</a>
<a name="ln965">    }</a>
<a name="ln966">  if (! CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE))</a>
<a name="ln967">    return 0;</a>
<a name="ln968"> </a>
<a name="ln969">  /* XXX: What exactly do those checks do? Do we support</a>
<a name="ln970">   * e.g. IPv4 routes with IPv6 nexthops or vice versa? */</a>
<a name="ln971">  if (RIB_SYSTEM_ROUTE(rib) ||</a>
<a name="ln972">      (family == AFI_IP &amp;&amp; rn-&gt;p.family != AF_INET) ||</a>
<a name="ln973">      (family == AFI_IP6 &amp;&amp; rn-&gt;p.family != AF_INET6))</a>
<a name="ln974">    return CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln975"> </a>
<a name="ln976">  /* The original code didn't determine the family correctly</a>
<a name="ln977">   * e.g. for NEXTHOP_TYPE_IFINDEX. Retrieve the correct afi</a>
<a name="ln978">   * from the rib_table_info in those cases.</a>
<a name="ln979">   * Possibly it may be better to use only the rib_table_info</a>
<a name="ln980">   * in every case.</a>
<a name="ln981">   */</a>
<a name="ln982">  if (!family)</a>
<a name="ln983">    family = info-&gt;afi;</a>
<a name="ln984"> </a>
<a name="ln985">  rmap = 0;</a>
<a name="ln986">  if (rib-&gt;type &gt;= 0 &amp;&amp; rib-&gt;type &lt; ZEBRA_ROUTE_MAX &amp;&amp;</a>
<a name="ln987">        	proto_rm[family][rib-&gt;type])</a>
<a name="ln988">    rmap = route_map_lookup_by_name (proto_rm[family][rib-&gt;type]);</a>
<a name="ln989">  if (!rmap &amp;&amp; proto_rm[family][ZEBRA_ROUTE_MAX])</a>
<a name="ln990">    rmap = route_map_lookup_by_name (proto_rm[family][ZEBRA_ROUTE_MAX]);</a>
<a name="ln991">  if (rmap) {</a>
<a name="ln992">      struct nexthop_vrfid nh_vrf = {nexthop, rib-&gt;vrf_id};</a>
<a name="ln993">      ret = route_map_apply(rmap, &amp;rn-&gt;p, RMAP_ZEBRA, &amp;nh_vrf);</a>
<a name="ln994">  }</a>
<a name="ln995"> </a>
<a name="ln996">  if (ret == RMAP_DENYMATCH)</a>
<a name="ln997">    UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln998">  return CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001">/* Iterate over all nexthops of the given RIB entry and refresh their</a>
<a name="ln1002"> * ACTIVE flag. rib-&gt;nexthop_active_num is updated accordingly. If any</a>
<a name="ln1003"> * nexthop is found to toggle the ACTIVE flag, the whole rib structure</a>
<a name="ln1004"> * is flagged with RIB_ENTRY_CHANGED. The 4th 'set' argument is</a>
<a name="ln1005"> * transparently passed to nexthop_active_check().</a>
<a name="ln1006"> *</a>
<a name="ln1007"> * Return value is the new number of active nexthops.</a>
<a name="ln1008"> */</a>
<a name="ln1009"> </a>
<a name="ln1010">static int</a>
<a name="ln1011">nexthop_active_update (struct route_node *rn, struct rib *rib, int set)</a>
<a name="ln1012">{</a>
<a name="ln1013">  struct nexthop *nexthop;</a>
<a name="ln1014">  unsigned int prev_active, new_active;</a>
<a name="ln1015">  ifindex_t prev_index;</a>
<a name="ln1016">  </a>
<a name="ln1017">  rib-&gt;nexthop_active_num = 0;</a>
<a name="ln1018"> </a>
<a name="ln1019">  for (nexthop = rib-&gt;nexthop; nexthop; nexthop = nexthop-&gt;next)</a>
<a name="ln1020">  {</a>
<a name="ln1021">    prev_active = CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE);</a>
<a name="ln1022">    prev_index = nexthop-&gt;ifindex;</a>
<a name="ln1023">    if ((new_active = nexthop_active_check (rn, rib, nexthop, set)))</a>
<a name="ln1024">      rib-&gt;nexthop_active_num++;</a>
<a name="ln1025">    if (prev_active != new_active ||</a>
<a name="ln1026">	prev_index != nexthop-&gt;ifindex)</a>
<a name="ln1027">      SET_FLAG (rib-&gt;status, RIB_ENTRY_CHANGED);</a>
<a name="ln1028">  }</a>
<a name="ln1029">  return rib-&gt;nexthop_active_num;</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032"> </a>
<a name="ln1033"> </a>
<a name="ln1034">static int</a>
<a name="ln1035">rib_update_kernel (struct route_node *rn, struct rib *old, struct rib *new)</a>
<a name="ln1036">{</a>
<a name="ln1037">  int ret = 0;</a>
<a name="ln1038">  struct nexthop *nexthop, *tnexthop;</a>
<a name="ln1039">  rib_table_info_t *info = rn-&gt;table-&gt;info;</a>
<a name="ln1040">  int recursing;</a>
<a name="ln1041"> </a>
<a name="ln1042">  if (info-&gt;safi != SAFI_UNICAST)</a>
<a name="ln1043">    {</a>
<a name="ln1044">      if (new)</a>
<a name="ln1045">        for (ALL_NEXTHOPS_RO(new-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1046">          SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln1047">      if (old)</a>
<a name="ln1048">        for (ALL_NEXTHOPS_RO(old-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1049">          UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln1050">      return 0;</a>
<a name="ln1051">    }</a>
<a name="ln1052"> </a>
<a name="ln1053">  /*</a>
<a name="ln1054">   * Make sure we update the FPM any time we send new information to</a>
<a name="ln1055">   * the kernel.</a>
<a name="ln1056">   */</a>
<a name="ln1057">  zfpm_trigger_update (rn, &quot;updating in kernel&quot;);</a>
<a name="ln1058"> </a>
<a name="ln1059">  ret = kernel_route_rib (&amp;rn-&gt;p, old, new);</a>
<a name="ln1060"> </a>
<a name="ln1061">  /* This condition is never met, if we are using rt_socket.c */</a>
<a name="ln1062">  if (ret &lt; 0 &amp;&amp; new)</a>
<a name="ln1063">    {</a>
<a name="ln1064">      for (ALL_NEXTHOPS_RO(new-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1065">        UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln1066">    }</a>
<a name="ln1067">  else if (old &amp;&amp; old != new)</a>
<a name="ln1068">    {</a>
<a name="ln1069">      for (ALL_NEXTHOPS_RO(old-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1070">        UNSET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln1071">    }</a>
<a name="ln1072"> </a>
<a name="ln1073">  return ret;</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076">/* Uninstall the route from kernel. */</a>
<a name="ln1077">static void</a>
<a name="ln1078">rib_uninstall (struct route_node *rn, struct rib *rib)</a>
<a name="ln1079">{</a>
<a name="ln1080">  rib_table_info_t *info = rn-&gt;table-&gt;info;</a>
<a name="ln1081"> </a>
<a name="ln1082">  if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln1083">    {</a>
<a name="ln1084">      if (info-&gt;safi == SAFI_UNICAST)</a>
<a name="ln1085">        zfpm_trigger_update (rn, &quot;rib_uninstall&quot;);</a>
<a name="ln1086"> </a>
<a name="ln1087">      redistribute_delete (&amp;rn-&gt;p, rib);</a>
<a name="ln1088">      if (! RIB_SYSTEM_ROUTE (rib))</a>
<a name="ln1089">	rib_update_kernel (rn, rib, NULL);</a>
<a name="ln1090">      UNSET_FLAG (rib-&gt;flags, ZEBRA_FLAG_SELECTED);</a>
<a name="ln1091">    }</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">static void rib_unlink (struct route_node *, struct rib *);</a>
<a name="ln1095"> </a>
<a name="ln1096">/*</a>
<a name="ln1097"> * rib_can_delete_dest</a>
<a name="ln1098"> *</a>
<a name="ln1099"> * Returns TRUE if the given dest can be deleted from the table.</a>
<a name="ln1100"> */</a>
<a name="ln1101">static int</a>
<a name="ln1102">rib_can_delete_dest (rib_dest_t *dest)</a>
<a name="ln1103">{</a>
<a name="ln1104">  if (dest-&gt;routes)</a>
<a name="ln1105">    {</a>
<a name="ln1106">      return 0;</a>
<a name="ln1107">    }</a>
<a name="ln1108"> </a>
<a name="ln1109">  /*</a>
<a name="ln1110">   * Don't delete the dest if we have to update the FPM about this</a>
<a name="ln1111">   * prefix.</a>
<a name="ln1112">   */</a>
<a name="ln1113">  if (CHECK_FLAG (dest-&gt;flags, RIB_DEST_UPDATE_FPM) ||</a>
<a name="ln1114">      CHECK_FLAG (dest-&gt;flags, RIB_DEST_SENT_TO_FPM))</a>
<a name="ln1115">    return 0;</a>
<a name="ln1116"> </a>
<a name="ln1117">  return 1;</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">/*</a>
<a name="ln1121"> * rib_gc_dest</a>
<a name="ln1122"> *</a>
<a name="ln1123"> * Garbage collect the rib dest corresponding to the given route node</a>
<a name="ln1124"> * if appropriate.</a>
<a name="ln1125"> *</a>
<a name="ln1126"> * Returns TRUE if the dest was deleted, FALSE otherwise.</a>
<a name="ln1127"> */</a>
<a name="ln1128">int</a>
<a name="ln1129">rib_gc_dest (struct route_node *rn)</a>
<a name="ln1130">{</a>
<a name="ln1131">  rib_dest_t *dest;</a>
<a name="ln1132"> </a>
<a name="ln1133">  dest = rib_dest_from_rnode (rn);</a>
<a name="ln1134">  if (!dest)</a>
<a name="ln1135">    return 0;</a>
<a name="ln1136"> </a>
<a name="ln1137">  if (!rib_can_delete_dest (dest))</a>
<a name="ln1138">    return 0;</a>
<a name="ln1139"> </a>
<a name="ln1140">  if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1141">    rnode_debug (rn, &quot;removing dest from table&quot;);</a>
<a name="ln1142"> </a>
<a name="ln1143">  dest-&gt;rnode = NULL;</a>
<a name="ln1144">  XFREE (MTYPE_RIB_DEST, dest);</a>
<a name="ln1145">  rn-&gt;info = NULL;</a>
<a name="ln1146"> </a>
<a name="ln1147">  /*</a>
<a name="ln1148">   * Release the one reference that we keep on the route node.</a>
<a name="ln1149">   */</a>
<a name="ln1150">  route_unlock_node (rn);</a>
<a name="ln1151">  return 1;</a>
<a name="ln1152">}</a>
<a name="ln1153"> </a>
<a name="ln1154">/* Check if 'alternate' RIB entry is better than 'current'. */</a>
<a name="ln1155">static struct rib *</a>
<a name="ln1156">rib_choose_best (struct rib *current, struct rib *alternate)</a>
<a name="ln1157">{</a>
<a name="ln1158">  if (current == NULL)</a>
<a name="ln1159">    return alternate;</a>
<a name="ln1160"> </a>
<a name="ln1161">  /* filter route selection in following order:</a>
<a name="ln1162">   * - connected beats other types</a>
<a name="ln1163">   * - lower distance beats higher</a>
<a name="ln1164">   * - lower metric beats higher for equal distance</a>
<a name="ln1165">   * - last, hence oldest, route wins tie break.</a>
<a name="ln1166">   */</a>
<a name="ln1167"> </a>
<a name="ln1168">  /* Connected routes. Pick the last connected</a>
<a name="ln1169">   * route of the set of lowest metric connected routes.</a>
<a name="ln1170">   */</a>
<a name="ln1171">  if (alternate-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln1172">    {</a>
<a name="ln1173">      if (current-&gt;type != ZEBRA_ROUTE_CONNECT</a>
<a name="ln1174">          || alternate-&gt;metric &lt;= current-&gt;metric)</a>
<a name="ln1175">        return alternate;</a>
<a name="ln1176"> </a>
<a name="ln1177">      return current;</a>
<a name="ln1178">    }</a>
<a name="ln1179"> </a>
<a name="ln1180">  if (current-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln1181">    return current;</a>
<a name="ln1182"> </a>
<a name="ln1183">  /* higher distance loses */</a>
<a name="ln1184">  if (alternate-&gt;distance &lt; current-&gt;distance)</a>
<a name="ln1185">    return alternate;</a>
<a name="ln1186">  if (current-&gt;distance &lt; alternate-&gt;distance)</a>
<a name="ln1187">    return current;</a>
<a name="ln1188"> </a>
<a name="ln1189">  /* metric tie-breaks equal distance */</a>
<a name="ln1190">  if (alternate-&gt;metric &lt;= current-&gt;metric)</a>
<a name="ln1191">    return alternate;</a>
<a name="ln1192"> </a>
<a name="ln1193">  return current;</a>
<a name="ln1194">}</a>
<a name="ln1195"> </a>
<a name="ln1196">/* Core function for processing routing information base. */</a>
<a name="ln1197">static void</a>
<a name="ln1198">rib_process (struct route_node *rn)</a>
<a name="ln1199">{</a>
<a name="ln1200">  struct rib *rib;</a>
<a name="ln1201">  struct rib *next;</a>
<a name="ln1202">  struct rib *old_selected = NULL;</a>
<a name="ln1203">  struct rib *new_selected = NULL;</a>
<a name="ln1204">  struct rib *old_fib = NULL;</a>
<a name="ln1205">  struct rib *new_fib = NULL;</a>
<a name="ln1206">  int installed = 0;</a>
<a name="ln1207">  struct nexthop *nexthop = NULL, *tnexthop;</a>
<a name="ln1208">  int recursing;</a>
<a name="ln1209">  rib_table_info_t *info;</a>
<a name="ln1210"> </a>
<a name="ln1211">  assert (rn);</a>
<a name="ln1212"> </a>
<a name="ln1213">  info = rn-&gt;table-&gt;info;</a>
<a name="ln1214"> </a>
<a name="ln1215">  RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln1216">    {</a>
<a name="ln1217">      UNSET_FLAG (rib-&gt;status, RIB_ENTRY_CHANGED);</a>
<a name="ln1218"> </a>
<a name="ln1219">      /* Currently installed rib. */</a>
<a name="ln1220">      if (CHECK_FLAG (rib-&gt;flags, ZEBRA_FLAG_SELECTED))</a>
<a name="ln1221">        {</a>
<a name="ln1222">          assert (old_selected == NULL);</a>
<a name="ln1223">          old_selected = rib;</a>
<a name="ln1224">        }</a>
<a name="ln1225">      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln1226">        {</a>
<a name="ln1227">          assert (old_fib == NULL);</a>
<a name="ln1228">          old_fib = rib;</a>
<a name="ln1229">        }</a>
<a name="ln1230"> </a>
<a name="ln1231">      /* Skip deleted entries from selection */</a>
<a name="ln1232">      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln1233">        continue;</a>
<a name="ln1234">      </a>
<a name="ln1235">      /* Skip unreachable nexthop. */</a>
<a name="ln1236">      if (! nexthop_active_update (rn, rib, 0))</a>
<a name="ln1237">        continue;</a>
<a name="ln1238"> </a>
<a name="ln1239">      /* Infinit distance. */</a>
<a name="ln1240">      if (rib-&gt;distance == DISTANCE_INFINITY)</a>
<a name="ln1241">        continue;</a>
<a name="ln1242"> </a>
<a name="ln1243">      if (CHECK_FLAG (rib-&gt;flags, ZEBRA_FLAG_FIB_OVERRIDE))</a>
<a name="ln1244">        new_fib = rib_choose_best(new_fib, rib);</a>
<a name="ln1245">      else</a>
<a name="ln1246">        new_selected = rib_choose_best(new_selected, rib);</a>
<a name="ln1247">    } /* RNODE_FOREACH_RIB_SAFE */</a>
<a name="ln1248"> </a>
<a name="ln1249">  /* If no FIB override route, use the selected route also for FIB */</a>
<a name="ln1250">  if (new_fib == NULL)</a>
<a name="ln1251">    new_fib = new_selected;</a>
<a name="ln1252"> </a>
<a name="ln1253">  /* After the cycle is finished, the following pointers will be set:</a>
<a name="ln1254">   * old_selected --- RIB entry currently having SELECTED</a>
<a name="ln1255">   * new_selected --- RIB entry that is newly SELECTED</a>
<a name="ln1256">   * old_fib      --- RIB entry currently in kernel FIB</a>
<a name="ln1257">   * new_fib      --- RIB entry that is newly to be in kernel FIB</a>
<a name="ln1258">   *</a>
<a name="ln1259">   * new_selected will get SELECTED flag, and is going to be redistributed</a>
<a name="ln1260">   * the zclients. new_fib (which can be new_selected) will be installed in kernel.</a>
<a name="ln1261">   */</a>
<a name="ln1262"> </a>
<a name="ln1263">  /* Set real nexthops. */</a>
<a name="ln1264">  if (new_fib)</a>
<a name="ln1265">    nexthop_active_update (rn, new_fib, 1);</a>
<a name="ln1266">  if (new_selected &amp;&amp; new_selected != new_fib)</a>
<a name="ln1267">    nexthop_active_update (rn, new_selected, 1);</a>
<a name="ln1268"> </a>
<a name="ln1269">  /* Update kernel if FIB entry has changed */</a>
<a name="ln1270">  if (old_fib != new_fib</a>
<a name="ln1271">      || (new_fib &amp;&amp; CHECK_FLAG (new_fib-&gt;status, RIB_ENTRY_CHANGED)))</a>
<a name="ln1272">    {</a>
<a name="ln1273">        if (old_fib &amp;&amp; old_fib != new_fib)</a>
<a name="ln1274">          {</a>
<a name="ln1275">            if (! RIB_SYSTEM_ROUTE (old_fib) &amp;&amp; (! new_fib || RIB_SYSTEM_ROUTE (new_fib)))</a>
<a name="ln1276">              rib_update_kernel (rn, old_fib, NULL);</a>
<a name="ln1277">            UNSET_FLAG (old_fib-&gt;status, RIB_ENTRY_SELECTED_FIB);</a>
<a name="ln1278">          }</a>
<a name="ln1279"> </a>
<a name="ln1280">        if (new_fib)</a>
<a name="ln1281">          {</a>
<a name="ln1282">            /* Install new or replace existing FIB entry */</a>
<a name="ln1283">            SET_FLAG (new_fib-&gt;status, RIB_ENTRY_SELECTED_FIB);</a>
<a name="ln1284">            if (! RIB_SYSTEM_ROUTE (new_fib))</a>
<a name="ln1285">              rib_update_kernel (rn, old_fib, new_fib);</a>
<a name="ln1286">          }</a>
<a name="ln1287"> </a>
<a name="ln1288">        if (info-&gt;safi == SAFI_UNICAST)</a>
<a name="ln1289">          zfpm_trigger_update (rn, &quot;updating existing route&quot;);</a>
<a name="ln1290">    }</a>
<a name="ln1291">  else if (old_fib == new_fib &amp;&amp; new_fib &amp;&amp; ! RIB_SYSTEM_ROUTE (new_fib))</a>
<a name="ln1292">    {</a>
<a name="ln1293">      /* Housekeeping code to deal with race conditions in kernel with</a>
<a name="ln1294">       * linux netlink reporting interface up before IPv4 or IPv6 protocol</a>
<a name="ln1295">       * is ready to add routes. This makes sure routes are IN the kernel.</a>
<a name="ln1296">       */</a>
<a name="ln1297">      for (ALL_NEXTHOPS_RO(new_fib-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1298">        if (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB))</a>
<a name="ln1299">          {</a>
<a name="ln1300">            installed = 1;</a>
<a name="ln1301">            break;</a>
<a name="ln1302">          }</a>
<a name="ln1303">      if (! installed)</a>
<a name="ln1304">        rib_update_kernel (rn, NULL, new_fib);</a>
<a name="ln1305">    }</a>
<a name="ln1306"> </a>
<a name="ln1307">  /* Redistribute SELECTED entry */</a>
<a name="ln1308">  if (old_selected != new_selected</a>
<a name="ln1309">      || (new_selected &amp;&amp; CHECK_FLAG (new_selected-&gt;status, RIB_ENTRY_CHANGED)))</a>
<a name="ln1310">    {</a>
<a name="ln1311">      if (old_selected)</a>
<a name="ln1312">        {</a>
<a name="ln1313">          if (! new_selected)</a>
<a name="ln1314">            redistribute_delete (&amp;rn-&gt;p, old_selected);</a>
<a name="ln1315">          if (old_selected != new_selected)</a>
<a name="ln1316">            UNSET_FLAG (old_selected-&gt;flags, ZEBRA_FLAG_SELECTED);</a>
<a name="ln1317">        }</a>
<a name="ln1318"> </a>
<a name="ln1319">      if (new_selected)</a>
<a name="ln1320">        {</a>
<a name="ln1321">          /* Install new or replace existing redistributed entry */</a>
<a name="ln1322">          SET_FLAG (new_selected-&gt;flags, ZEBRA_FLAG_SELECTED);</a>
<a name="ln1323">          redistribute_add (&amp;rn-&gt;p, new_selected, old_selected);</a>
<a name="ln1324">        }</a>
<a name="ln1325">     }</a>
<a name="ln1326"> </a>
<a name="ln1327">  /* Remove all RIB entries queued for removal */</a>
<a name="ln1328">  RNODE_FOREACH_RIB_SAFE (rn, rib, next)</a>
<a name="ln1329">    {</a>
<a name="ln1330">      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln1331">        {</a>
<a name="ln1332">          if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1333">            rnode_debug (rn, &quot;rn %p, removing rib %p&quot;,</a>
<a name="ln1334">                        (void *)rn, (void *)rib);</a>
<a name="ln1335">          rib_unlink (rn, rib);</a>
<a name="ln1336">        }</a>
<a name="ln1337">    }</a>
<a name="ln1338"> </a>
<a name="ln1339">  if (IS_ZEBRA_DEBUG_RIB_Q)</a>
<a name="ln1340">    rnode_debug (rn, &quot;rn %p dequeued&quot;, (void *)rn);</a>
<a name="ln1341"> </a>
<a name="ln1342">  /*</a>
<a name="ln1343">   * Check if the dest can be deleted now.</a>
<a name="ln1344">   */</a>
<a name="ln1345">  rib_gc_dest (rn);</a>
<a name="ln1346">}</a>
<a name="ln1347"> </a>
<a name="ln1348">/* Take a list of route_node structs and return 1, if there was a record</a>
<a name="ln1349"> * picked from it and processed by rib_process(). Don't process more, </a>
<a name="ln1350"> * than one RN record; operate only in the specified sub-queue.</a>
<a name="ln1351"> */</a>
<a name="ln1352">static unsigned int</a>
<a name="ln1353">process_subq (struct list * subq, u_char qindex)</a>
<a name="ln1354">{</a>
<a name="ln1355">  struct listnode *lnode  = listhead (subq);</a>
<a name="ln1356">  struct route_node *rnode;</a>
<a name="ln1357"> </a>
<a name="ln1358">  if (!lnode)</a>
<a name="ln1359">    return 0;</a>
<a name="ln1360"> </a>
<a name="ln1361">  rnode = listgetdata (lnode);</a>
<a name="ln1362">  rib_process (rnode);</a>
<a name="ln1363"> </a>
<a name="ln1364">  if (rnode-&gt;info)</a>
<a name="ln1365">    UNSET_FLAG (rib_dest_from_rnode (rnode)-&gt;flags, RIB_ROUTE_QUEUED (qindex));</a>
<a name="ln1366"> </a>
<a name="ln1367">#if 0</a>
<a name="ln1368">  else</a>
<a name="ln1369">    {</a>
<a name="ln1370">      zlog_debug (&quot;%s: called for route_node (%p, %d) with no ribs&quot;,</a>
<a name="ln1371">                  __func__, rnode, rnode-&gt;lock);</a>
<a name="ln1372">      zlog_backtrace(LOG_DEBUG);</a>
<a name="ln1373">    }</a>
<a name="ln1374">#endif</a>
<a name="ln1375">  route_unlock_node (rnode);</a>
<a name="ln1376">  list_delete_node (subq, lnode);</a>
<a name="ln1377">  return 1;</a>
<a name="ln1378">}</a>
<a name="ln1379"> </a>
<a name="ln1380">/*</a>
<a name="ln1381"> * All meta queues have been processed. Trigger next-hop evaluation.</a>
<a name="ln1382"> */</a>
<a name="ln1383">static void</a>
<a name="ln1384">meta_queue_process_complete (struct work_queue *dummy)</a>
<a name="ln1385">{</a>
<a name="ln1386">  zebra_evaluate_rnh_table(0, AF_INET);</a>
<a name="ln1387">#ifdef HAVE_IPV6</a>
<a name="ln1388">  zebra_evaluate_rnh_table(0, AF_INET6);</a>
<a name="ln1389">#endif /* HAVE_IPV6 */</a>
<a name="ln1390">}</a>
<a name="ln1391"> </a>
<a name="ln1392">/* Dispatch the meta queue by picking, processing and unlocking the next RN from</a>
<a name="ln1393"> * a non-empty sub-queue with lowest priority. wq is equal to zebra-&gt;ribq and data</a>
<a name="ln1394"> * is pointed to the meta queue structure.</a>
<a name="ln1395"> */</a>
<a name="ln1396">static wq_item_status</a>
<a name="ln1397">meta_queue_process (struct work_queue *dummy, void *data)</a>
<a name="ln1398">{</a>
<a name="ln1399">  struct meta_queue * mq = data;</a>
<a name="ln1400">  unsigned i;</a>
<a name="ln1401"> </a>
<a name="ln1402">  for (i = 0; i &lt; MQ_SIZE; i++)</a>
<a name="ln1403">    if (process_subq (mq-&gt;subq[i], i))</a>
<a name="ln1404">      {</a>
<a name="ln1405">	mq-&gt;size--;</a>
<a name="ln1406">	break;</a>
<a name="ln1407">      }</a>
<a name="ln1408">  return mq-&gt;size ? WQ_REQUEUE : WQ_SUCCESS;</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">/*</a>
<a name="ln1412"> * Map from rib types to queue type (priority) in meta queue</a>
<a name="ln1413"> */</a>
<a name="ln1414">static const u_char meta_queue_map[ZEBRA_ROUTE_MAX] = {</a>
<a name="ln1415">  [ZEBRA_ROUTE_SYSTEM]  = 4,</a>
<a name="ln1416">  [ZEBRA_ROUTE_KERNEL]  = 0,</a>
<a name="ln1417">  [ZEBRA_ROUTE_CONNECT] = 0,</a>
<a name="ln1418">  [ZEBRA_ROUTE_STATIC]  = 1,</a>
<a name="ln1419">  [ZEBRA_ROUTE_RIP]     = 2,</a>
<a name="ln1420">  [ZEBRA_ROUTE_RIPNG]   = 2,</a>
<a name="ln1421">  [ZEBRA_ROUTE_OSPF]    = 2,</a>
<a name="ln1422">  [ZEBRA_ROUTE_OSPF6]   = 2,</a>
<a name="ln1423">  [ZEBRA_ROUTE_ISIS]    = 2,</a>
<a name="ln1424">  [ZEBRA_ROUTE_BGP]     = 3,</a>
<a name="ln1425">  [ZEBRA_ROUTE_HSLS]    = 4,</a>
<a name="ln1426">  [ZEBRA_ROUTE_BABEL]   = 2,</a>
<a name="ln1427">  [ZEBRA_ROUTE_NHRP]    = 2,</a>
<a name="ln1428">};</a>
<a name="ln1429"> </a>
<a name="ln1430">/* Look into the RN and queue it into one or more priority queues,</a>
<a name="ln1431"> * increasing the size for each data push done.</a>
<a name="ln1432"> */</a>
<a name="ln1433">static void</a>
<a name="ln1434">rib_meta_queue_add (struct meta_queue *mq, struct route_node *rn)</a>
<a name="ln1435">{</a>
<a name="ln1436">  struct rib *rib;</a>
<a name="ln1437"> </a>
<a name="ln1438">  RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln1439">    {</a>
<a name="ln1440">      u_char qindex = meta_queue_map[rib-&gt;type];</a>
<a name="ln1441"> </a>
<a name="ln1442">      /* Invariant: at this point we always have rn-&gt;info set. */</a>
<a name="ln1443">      if (CHECK_FLAG (rib_dest_from_rnode (rn)-&gt;flags,</a>
<a name="ln1444">		      RIB_ROUTE_QUEUED (qindex)))</a>
<a name="ln1445">	{</a>
<a name="ln1446">	  if (IS_ZEBRA_DEBUG_RIB_Q)</a>
<a name="ln1447">	    rnode_debug (rn, &quot;rn %p is already queued in sub-queue %u&quot;,</a>
<a name="ln1448">			 (void *)rn, qindex);</a>
<a name="ln1449">	  continue;</a>
<a name="ln1450">	}</a>
<a name="ln1451"> </a>
<a name="ln1452">      SET_FLAG (rib_dest_from_rnode (rn)-&gt;flags, RIB_ROUTE_QUEUED (qindex));</a>
<a name="ln1453">      listnode_add (mq-&gt;subq[qindex], rn);</a>
<a name="ln1454">      route_lock_node (rn);</a>
<a name="ln1455">      mq-&gt;size++;</a>
<a name="ln1456"> </a>
<a name="ln1457">      if (IS_ZEBRA_DEBUG_RIB_Q)</a>
<a name="ln1458">	rnode_debug (rn, &quot;queued rn %p into sub-queue %u&quot;,</a>
<a name="ln1459">                     (void *)rn, qindex);</a>
<a name="ln1460">    }</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463">/* Add route_node to work queue and schedule processing */</a>
<a name="ln1464">static void</a>
<a name="ln1465">rib_queue_add (struct zebra_t *zebra, struct route_node *rn)</a>
<a name="ln1466">{</a>
<a name="ln1467">  assert (zebra &amp;&amp; rn);</a>
<a name="ln1468"> </a>
<a name="ln1469">  /* Pointless to queue a route_node with no RIB entries to add or remove */</a>
<a name="ln1470">  if (!rnode_to_ribs (rn))</a>
<a name="ln1471">    {</a>
<a name="ln1472">      zlog_debug (&quot;%s: called for route_node (%p, %d) with no ribs&quot;,</a>
<a name="ln1473">                  __func__, (void *)rn, rn-&gt;lock);</a>
<a name="ln1474">      zlog_backtrace(LOG_DEBUG);</a>
<a name="ln1475">      return;</a>
<a name="ln1476">    }</a>
<a name="ln1477"> </a>
<a name="ln1478">  if (IS_ZEBRA_DEBUG_RIB_Q)</a>
<a name="ln1479">    rnode_info (rn, &quot;work queue added&quot;);</a>
<a name="ln1480"> </a>
<a name="ln1481">  assert (zebra);</a>
<a name="ln1482"> </a>
<a name="ln1483">  if (zebra-&gt;ribq == NULL)</a>
<a name="ln1484">    {</a>
<a name="ln1485">      zlog_err (&quot;%s: work_queue does not exist!&quot;, __func__);</a>
<a name="ln1486">      return;</a>
<a name="ln1487">    }</a>
<a name="ln1488"> </a>
<a name="ln1489">  /*</a>
<a name="ln1490">   * The RIB queue should normally be either empty or holding the only</a>
<a name="ln1491">   * work_queue_item element. In the latter case this element would</a>
<a name="ln1492">   * hold a pointer to the meta queue structure, which must be used to</a>
<a name="ln1493">   * actually queue the route nodes to process. So create the MQ</a>
<a name="ln1494">   * holder, if necessary, then push the work into it in any case.</a>
<a name="ln1495">   * This semantics was introduced after 0.99.9 release.</a>
<a name="ln1496">   */</a>
<a name="ln1497">  if (!zebra-&gt;ribq-&gt;items-&gt;count)</a>
<a name="ln1498">    work_queue_add (zebra-&gt;ribq, zebra-&gt;mq);</a>
<a name="ln1499"> </a>
<a name="ln1500">  rib_meta_queue_add (zebra-&gt;mq, rn);</a>
<a name="ln1501"> </a>
<a name="ln1502">  if (IS_ZEBRA_DEBUG_RIB_Q)</a>
<a name="ln1503">    rnode_debug (rn, &quot;rn %p queued&quot;, (void *)rn);</a>
<a name="ln1504"> </a>
<a name="ln1505">  return;</a>
<a name="ln1506">}</a>
<a name="ln1507"> </a>
<a name="ln1508">/* Create new meta queue.</a>
<a name="ln1509">   A destructor function doesn't seem to be necessary here.</a>
<a name="ln1510"> */</a>
<a name="ln1511">static struct meta_queue *</a>
<a name="ln1512">meta_queue_new (void)</a>
<a name="ln1513">{</a>
<a name="ln1514">  struct meta_queue *new;</a>
<a name="ln1515">  unsigned i;</a>
<a name="ln1516"> </a>
<a name="ln1517">  new = XCALLOC (MTYPE_WORK_QUEUE, sizeof (struct meta_queue));</a>
<a name="ln1518">  assert(new);</a>
<a name="ln1519"> </a>
<a name="ln1520">  for (i = 0; i &lt; MQ_SIZE; i++)</a>
<a name="ln1521">    {</a>
<a name="ln1522">      new-&gt;subq[i] = list_new ();</a>
<a name="ln1523">      assert(new-&gt;subq[i]);</a>
<a name="ln1524">    }</a>
<a name="ln1525"> </a>
<a name="ln1526">  return new;</a>
<a name="ln1527">}</a>
<a name="ln1528"> </a>
<a name="ln1529">/* initialise zebra rib work queue */</a>
<a name="ln1530">static void</a>
<a name="ln1531">rib_queue_init (struct zebra_t *zebra)</a>
<a name="ln1532">{</a>
<a name="ln1533">  assert (zebra);</a>
<a name="ln1534">  </a>
<a name="ln1535">  if (! (zebra-&gt;ribq = work_queue_new (zebra-&gt;master, </a>
<a name="ln1536">                                       &quot;route_node processing&quot;)))</a>
<a name="ln1537">    {</a>
<a name="ln1538">      zlog_err (&quot;%s: could not initialise work queue!&quot;, __func__);</a>
<a name="ln1539">      return;</a>
<a name="ln1540">    }</a>
<a name="ln1541"> </a>
<a name="ln1542">  /* fill in the work queue spec */</a>
<a name="ln1543">  zebra-&gt;ribq-&gt;spec.workfunc = &amp;meta_queue_process;</a>
<a name="ln1544">  zebra-&gt;ribq-&gt;spec.errorfunc = NULL;</a>
<a name="ln1545">  zebra-&gt;ribq-&gt;spec.completion_func = &amp;meta_queue_process_complete;</a>
<a name="ln1546">  /* XXX: TODO: These should be runtime configurable via vty */</a>
<a name="ln1547">  zebra-&gt;ribq-&gt;spec.max_retries = 3;</a>
<a name="ln1548">  zebra-&gt;ribq-&gt;spec.hold = rib_process_hold_time;</a>
<a name="ln1549">  </a>
<a name="ln1550">  if (!(zebra-&gt;mq = meta_queue_new ()))</a>
<a name="ln1551">  {</a>
<a name="ln1552">    zlog_err (&quot;%s: could not initialise meta queue!&quot;, __func__);</a>
<a name="ln1553">    return;</a>
<a name="ln1554">  }</a>
<a name="ln1555">  return;</a>
<a name="ln1556">}</a>
<a name="ln1557"> </a>
<a name="ln1558">/* RIB updates are processed via a queue of pointers to route_nodes.</a>
<a name="ln1559"> *</a>
<a name="ln1560"> * The queue length is bounded by the maximal size of the routing table,</a>
<a name="ln1561"> * as a route_node will not be requeued, if already queued.</a>
<a name="ln1562"> *</a>
<a name="ln1563"> * RIBs are submitted via rib_addnode or rib_delnode which set minimal</a>
<a name="ln1564"> * state, or static_install_route (when an existing RIB is updated)</a>
<a name="ln1565"> * and then submit route_node to queue for best-path selection later.</a>
<a name="ln1566"> * Order of add/delete state changes are preserved for any given RIB.</a>
<a name="ln1567"> *</a>
<a name="ln1568"> * Deleted RIBs are reaped during best-path selection.</a>
<a name="ln1569"> *</a>
<a name="ln1570"> * rib_addnode</a>
<a name="ln1571"> * |-&gt; rib_link or unset RIB_ENTRY_REMOVE        |-&gt;Update kernel with</a>
<a name="ln1572"> *       |--------&gt;|                             |  best RIB, if required</a>
<a name="ln1573"> *                 |                             |</a>
<a name="ln1574"> * static_install-&gt;|-&gt;rib_addqueue...... -&gt; rib_process</a>
<a name="ln1575"> *                 |                             |</a>
<a name="ln1576"> *       |--------&gt;|                             |-&gt; rib_unlink</a>
<a name="ln1577"> * |-&gt; set RIB_ENTRY_REMOVE                           |</a>
<a name="ln1578"> * rib_delnode                                  (RIB freed)</a>
<a name="ln1579"> *</a>
<a name="ln1580"> * The 'info' pointer of a route_node points to a rib_dest_t</a>
<a name="ln1581"> * ('dest'). Queueing state for a route_node is kept on the dest. The</a>
<a name="ln1582"> * dest is created on-demand by rib_link() and is kept around at least</a>
<a name="ln1583"> * as long as there are ribs hanging off it (@see rib_gc_dest()).</a>
<a name="ln1584"> * </a>
<a name="ln1585"> * Refcounting (aka &quot;locking&quot; throughout the GNU Zebra and Quagga code):</a>
<a name="ln1586"> *</a>
<a name="ln1587"> * - route_nodes: refcounted by:</a>
<a name="ln1588"> *   - dest attached to route_node:</a>
<a name="ln1589"> *     - managed by: rib_link/rib_gc_dest</a>
<a name="ln1590"> *   - route_node processing queue</a>
<a name="ln1591"> *     - managed by: rib_addqueue, rib_process.</a>
<a name="ln1592"> *</a>
<a name="ln1593"> */</a>
<a name="ln1594"> </a>
<a name="ln1595">/* Add RIB to head of the route node. */</a>
<a name="ln1596">static void</a>
<a name="ln1597">rib_link (struct route_node *rn, struct rib *rib)</a>
<a name="ln1598">{</a>
<a name="ln1599">  struct rib *head;</a>
<a name="ln1600">  rib_dest_t *dest;</a>
<a name="ln1601"> </a>
<a name="ln1602">  assert (rib &amp;&amp; rn);</a>
<a name="ln1603">  </a>
<a name="ln1604">  if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1605">    rnode_debug (rn, &quot;rn %p, rib %p&quot;, (void *)rn, (void *)rib);</a>
<a name="ln1606"> </a>
<a name="ln1607">  dest = rib_dest_from_rnode (rn);</a>
<a name="ln1608">  if (!dest)</a>
<a name="ln1609">    {</a>
<a name="ln1610">      if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1611">	rnode_debug (rn, &quot;adding dest to table&quot;);</a>
<a name="ln1612"> </a>
<a name="ln1613">      dest = XCALLOC (MTYPE_RIB_DEST, sizeof (rib_dest_t));</a>
<a name="ln1614">      route_lock_node (rn); /* rn route table reference */</a>
<a name="ln1615">      rn-&gt;info = dest;</a>
<a name="ln1616">      dest-&gt;rnode = rn;</a>
<a name="ln1617">    }</a>
<a name="ln1618"> </a>
<a name="ln1619">  head = dest-&gt;routes;</a>
<a name="ln1620">  if (head)</a>
<a name="ln1621">    {</a>
<a name="ln1622">      head-&gt;prev = rib;</a>
<a name="ln1623">    }</a>
<a name="ln1624">  rib-&gt;next = head;</a>
<a name="ln1625">  dest-&gt;routes = rib;</a>
<a name="ln1626">  rib_queue_add (&amp;zebrad, rn);</a>
<a name="ln1627">}</a>
<a name="ln1628"> </a>
<a name="ln1629">static void</a>
<a name="ln1630">rib_addnode (struct route_node *rn, struct rib *rib)</a>
<a name="ln1631">{</a>
<a name="ln1632">  /* RIB node has been un-removed before route-node is processed. </a>
<a name="ln1633">   * route_node must hence already be on the queue for processing.. </a>
<a name="ln1634">   */</a>
<a name="ln1635">  if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln1636">    {</a>
<a name="ln1637">      if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1638">        rnode_debug (rn, &quot;rn %p, un-removed rib %p&quot;, (void *)rn, (void *)rib);</a>
<a name="ln1639"> </a>
<a name="ln1640">      UNSET_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED);</a>
<a name="ln1641">      return;</a>
<a name="ln1642">    }</a>
<a name="ln1643">  rib_link (rn, rib);</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646">/*</a>
<a name="ln1647"> * rib_unlink</a>
<a name="ln1648"> *</a>
<a name="ln1649"> * Detach a rib structure from a route_node.</a>
<a name="ln1650"> *</a>
<a name="ln1651"> * Note that a call to rib_unlink() should be followed by a call to</a>
<a name="ln1652"> * rib_gc_dest() at some point. This allows a rib_dest_t that is no</a>
<a name="ln1653"> * longer required to be deleted.</a>
<a name="ln1654"> */</a>
<a name="ln1655">static void</a>
<a name="ln1656">rib_unlink (struct route_node *rn, struct rib *rib)</a>
<a name="ln1657">{</a>
<a name="ln1658">  rib_dest_t *dest;</a>
<a name="ln1659"> </a>
<a name="ln1660">  assert (rn &amp;&amp; rib);</a>
<a name="ln1661"> </a>
<a name="ln1662">  if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1663">    rnode_debug (rn, &quot;rn %p, rib %p&quot;, (void *)rn, (void *)rib);</a>
<a name="ln1664"> </a>
<a name="ln1665">  dest = rib_dest_from_rnode (rn);</a>
<a name="ln1666"> </a>
<a name="ln1667">  if (rib-&gt;next)</a>
<a name="ln1668">    rib-&gt;next-&gt;prev = rib-&gt;prev;</a>
<a name="ln1669"> </a>
<a name="ln1670">  if (rib-&gt;prev)</a>
<a name="ln1671">    rib-&gt;prev-&gt;next = rib-&gt;next;</a>
<a name="ln1672">  else</a>
<a name="ln1673">    {</a>
<a name="ln1674">      dest-&gt;routes = rib-&gt;next;</a>
<a name="ln1675">    }</a>
<a name="ln1676"> </a>
<a name="ln1677">  /* free RIB and nexthops */</a>
<a name="ln1678">  nexthops_free(rib-&gt;nexthop);</a>
<a name="ln1679">  XFREE (MTYPE_RIB, rib);</a>
<a name="ln1680"> </a>
<a name="ln1681">}</a>
<a name="ln1682"> </a>
<a name="ln1683">static void</a>
<a name="ln1684">rib_delnode (struct route_node *rn, struct rib *rib)</a>
<a name="ln1685">{</a>
<a name="ln1686">  if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1687">    rnode_debug (rn, &quot;rn %p, rib %p, removing&quot;, (void *)rn, (void *)rib);</a>
<a name="ln1688">  SET_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED);</a>
<a name="ln1689">  rib_queue_add (&amp;zebrad, rn);</a>
<a name="ln1690">}</a>
<a name="ln1691"> </a>
<a name="ln1692">int</a>
<a name="ln1693">rib_add_ipv4 (int type, int flags, struct prefix_ipv4 *p, </a>
<a name="ln1694">	      struct in_addr *gate, struct in_addr *src,</a>
<a name="ln1695">	      ifindex_t ifindex, vrf_id_t vrf_id, int table_id,</a>
<a name="ln1696">	      u_int32_t metric, u_int32_t mtu, u_char distance, safi_t safi)</a>
<a name="ln1697">{</a>
<a name="ln1698">  struct rib *rib;</a>
<a name="ln1699">  struct rib *same = NULL;</a>
<a name="ln1700">  struct route_table *table;</a>
<a name="ln1701">  struct route_node *rn;</a>
<a name="ln1702">  struct nexthop *nexthop;</a>
<a name="ln1703"> </a>
<a name="ln1704">  /* Lookup table.  */</a>
<a name="ln1705">  table = zebra_vrf_table (AFI_IP, safi, vrf_id);</a>
<a name="ln1706">  if (! table)</a>
<a name="ln1707">    return 0;</a>
<a name="ln1708"> </a>
<a name="ln1709">  /* Make it sure prefixlen is applied to the prefix. */</a>
<a name="ln1710">  apply_mask_ipv4 (p);</a>
<a name="ln1711"> </a>
<a name="ln1712">  /* Set default distance by route type. */</a>
<a name="ln1713">  if (distance == 0)</a>
<a name="ln1714">    {</a>
<a name="ln1715">      if ((unsigned)type &gt;= array_size(route_info))</a>
<a name="ln1716">	distance = 150;</a>
<a name="ln1717">      else</a>
<a name="ln1718">        distance = route_info[type].distance;</a>
<a name="ln1719"> </a>
<a name="ln1720">      /* iBGP distance is 200. */</a>
<a name="ln1721">      if (type == ZEBRA_ROUTE_BGP &amp;&amp; CHECK_FLAG (flags, ZEBRA_FLAG_IBGP))</a>
<a name="ln1722">	distance = 200;</a>
<a name="ln1723">    }</a>
<a name="ln1724"> </a>
<a name="ln1725">  /* Lookup route node.*/</a>
<a name="ln1726">  rn = route_node_get (table, (struct prefix *) p);</a>
<a name="ln1727"> </a>
<a name="ln1728">  /* If same type of route are installed, treat it as a implicit</a>
<a name="ln1729">     withdraw. */</a>
<a name="ln1730">  RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln1731">    {</a>
<a name="ln1732">      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln1733">        continue;</a>
<a name="ln1734">      </a>
<a name="ln1735">      if (rib-&gt;type != type)</a>
<a name="ln1736">	continue;</a>
<a name="ln1737">      if (rib-&gt;type != ZEBRA_ROUTE_CONNECT)</a>
<a name="ln1738">        {</a>
<a name="ln1739">          same = rib;</a>
<a name="ln1740">          break;</a>
<a name="ln1741">        }</a>
<a name="ln1742">      /* Duplicate connected route comes in. */</a>
<a name="ln1743">      else if ((nexthop = rib-&gt;nexthop) &amp;&amp;</a>
<a name="ln1744">	       nexthop-&gt;type == NEXTHOP_TYPE_IFINDEX &amp;&amp;</a>
<a name="ln1745">	       nexthop-&gt;ifindex == ifindex &amp;&amp;</a>
<a name="ln1746">	       !CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln1747">	{</a>
<a name="ln1748">	  rib-&gt;refcnt++;</a>
<a name="ln1749">	  return 0 ;</a>
<a name="ln1750">	}</a>
<a name="ln1751">    }</a>
<a name="ln1752"> </a>
<a name="ln1753">  /* Allocate new rib structure. */</a>
<a name="ln1754">  rib = XCALLOC (MTYPE_RIB, sizeof (struct rib));</a>
<a name="ln1755">  rib-&gt;type = type;</a>
<a name="ln1756">  rib-&gt;distance = distance;</a>
<a name="ln1757">  rib-&gt;flags = flags;</a>
<a name="ln1758">  rib-&gt;metric = metric;</a>
<a name="ln1759">  rib-&gt;mtu = mtu;</a>
<a name="ln1760">  rib-&gt;vrf_id = vrf_id;</a>
<a name="ln1761">  rib-&gt;table = table_id;</a>
<a name="ln1762">  rib-&gt;nexthop_num = 0;</a>
<a name="ln1763">  rib-&gt;uptime = time (NULL);</a>
<a name="ln1764"> </a>
<a name="ln1765">  /* Nexthop settings. */</a>
<a name="ln1766">  if (gate)</a>
<a name="ln1767">    {</a>
<a name="ln1768">      if (ifindex)</a>
<a name="ln1769">	rib_nexthop_ipv4_ifindex_add (rib, gate, src, ifindex);</a>
<a name="ln1770">      else</a>
<a name="ln1771">	rib_nexthop_ipv4_add (rib, gate, src);</a>
<a name="ln1772">    }</a>
<a name="ln1773">  else</a>
<a name="ln1774">    rib_nexthop_ifindex_add (rib, ifindex);</a>
<a name="ln1775"> </a>
<a name="ln1776">  /* If this route is kernel route, set FIB flag to the route. */</a>
<a name="ln1777">  if (type == ZEBRA_ROUTE_KERNEL || type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln1778">    for (nexthop = rib-&gt;nexthop; nexthop; nexthop = nexthop-&gt;next)</a>
<a name="ln1779">      SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln1780"> </a>
<a name="ln1781">  /* Link new rib to node.*/</a>
<a name="ln1782">  if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1783">    zlog_debug (&quot;%s: calling rib_addnode (%p, %p)&quot;,</a>
<a name="ln1784">               __func__, (void *)rn, (void *)rib);</a>
<a name="ln1785">  rib_addnode (rn, rib);</a>
<a name="ln1786">  </a>
<a name="ln1787">  /* Free implicit route.*/</a>
<a name="ln1788">  if (same)</a>
<a name="ln1789">  {</a>
<a name="ln1790">    if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1791">      zlog_debug (&quot;%s: calling rib_delnode (%p, %p)&quot;,</a>
<a name="ln1792">                 __func__, (void *)rn, (void *)rib);</a>
<a name="ln1793">    rib_delnode (rn, same);</a>
<a name="ln1794">  }</a>
<a name="ln1795">  </a>
<a name="ln1796">  route_unlock_node (rn);</a>
<a name="ln1797">  return 0;</a>
<a name="ln1798">}</a>
<a name="ln1799"> </a>
<a name="ln1800">/* This function dumps the contents of a given RIB entry into</a>
<a name="ln1801"> * standard debug log. Calling function name and IP prefix in</a>
<a name="ln1802"> * question are passed as 1st and 2nd arguments.</a>
<a name="ln1803"> */</a>
<a name="ln1804"> </a>
<a name="ln1805">void _rib_dump (const char * func,</a>
<a name="ln1806">		union prefix46constptr pp, const struct rib * rib)</a>
<a name="ln1807">{</a>
<a name="ln1808">  const struct prefix *p = pp.p;</a>
<a name="ln1809">  char straddr[PREFIX_STRLEN];</a>
<a name="ln1810">  struct nexthop *nexthop, *tnexthop;</a>
<a name="ln1811">  int recursing;</a>
<a name="ln1812"> </a>
<a name="ln1813">  zlog_debug (&quot;%s: dumping RIB entry %p for %s vrf %u&quot;, func, (void *)rib,</a>
<a name="ln1814">              prefix2str(p, straddr, sizeof(straddr)), rib-&gt;vrf_id);</a>
<a name="ln1815">  zlog_debug</a>
<a name="ln1816">  (</a>
<a name="ln1817">    &quot;%s: refcnt == %lu, uptime == %lu, type == %u, table == %d&quot;,</a>
<a name="ln1818">    func,</a>
<a name="ln1819">    rib-&gt;refcnt,</a>
<a name="ln1820">    (unsigned long) rib-&gt;uptime,</a>
<a name="ln1821">    rib-&gt;type,</a>
<a name="ln1822">    rib-&gt;table</a>
<a name="ln1823">  );</a>
<a name="ln1824">  zlog_debug</a>
<a name="ln1825">  (</a>
<a name="ln1826">    &quot;%s: metric == %u, distance == %u, flags == %u, status == %u&quot;,</a>
<a name="ln1827">    func,</a>
<a name="ln1828">    rib-&gt;metric,</a>
<a name="ln1829">    rib-&gt;distance,</a>
<a name="ln1830">    rib-&gt;flags,</a>
<a name="ln1831">    rib-&gt;status</a>
<a name="ln1832">  );</a>
<a name="ln1833">  zlog_debug</a>
<a name="ln1834">  (</a>
<a name="ln1835">    &quot;%s: nexthop_num == %u, nexthop_active_num == %u, nexthop_fib_num == %u&quot;,</a>
<a name="ln1836">    func,</a>
<a name="ln1837">    rib-&gt;nexthop_num,</a>
<a name="ln1838">    rib-&gt;nexthop_active_num,</a>
<a name="ln1839">    rib-&gt;nexthop_fib_num</a>
<a name="ln1840">  );</a>
<a name="ln1841"> </a>
<a name="ln1842">  for (ALL_NEXTHOPS_RO(rib-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1843">    {</a>
<a name="ln1844">      inet_ntop (p-&gt;family, &amp;nexthop-&gt;gate, straddr, INET6_ADDRSTRLEN);</a>
<a name="ln1845">      zlog_debug</a>
<a name="ln1846">      (</a>
<a name="ln1847">        &quot;%s: %s %s with flags %s%s%s&quot;,</a>
<a name="ln1848">        func,</a>
<a name="ln1849">        (recursing ? &quot;  NH&quot; : &quot;NH&quot;),</a>
<a name="ln1850">        straddr,</a>
<a name="ln1851">        (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE) ? &quot;ACTIVE &quot; : &quot;&quot;),</a>
<a name="ln1852">        (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB) ? &quot;FIB &quot; : &quot;&quot;),</a>
<a name="ln1853">        (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE) ? &quot;RECURSIVE&quot; : &quot;&quot;)</a>
<a name="ln1854">      );</a>
<a name="ln1855">    }</a>
<a name="ln1856">  zlog_debug (&quot;%s: dump complete&quot;, func);</a>
<a name="ln1857">}</a>
<a name="ln1858"> </a>
<a name="ln1859">/* This is an exported helper to rtm_read() to dump the strange</a>
<a name="ln1860"> * RIB entry found by rib_lookup_ipv4_route()</a>
<a name="ln1861"> */</a>
<a name="ln1862"> </a>
<a name="ln1863">void rib_lookup_and_dump (struct prefix_ipv4 * p)</a>
<a name="ln1864">{</a>
<a name="ln1865">  struct route_table *table;</a>
<a name="ln1866">  struct route_node *rn;</a>
<a name="ln1867">  struct rib *rib;</a>
<a name="ln1868">  char prefix_buf[INET_ADDRSTRLEN];</a>
<a name="ln1869"> </a>
<a name="ln1870">  /* Lookup table.  */</a>
<a name="ln1871">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, VRF_DEFAULT);</a>
<a name="ln1872">  if (! table)</a>
<a name="ln1873">  {</a>
<a name="ln1874">    zlog_err (&quot;%s: zebra_vrf_table() returned NULL&quot;, __func__);</a>
<a name="ln1875">    return;</a>
<a name="ln1876">  }</a>
<a name="ln1877"> </a>
<a name="ln1878">  /* Scan the RIB table for exactly matching RIB entry. */</a>
<a name="ln1879">  rn = route_node_lookup (table, (struct prefix *) p);</a>
<a name="ln1880"> </a>
<a name="ln1881">  /* No route for this prefix. */</a>
<a name="ln1882">  if (! rn)</a>
<a name="ln1883">  {</a>
<a name="ln1884">    zlog_debug (&quot;%s: lookup failed for %s&quot;, __func__,</a>
<a name="ln1885">                prefix2str((struct prefix*) p, prefix_buf, sizeof(prefix_buf)));</a>
<a name="ln1886">    return;</a>
<a name="ln1887">  }</a>
<a name="ln1888"> </a>
<a name="ln1889">  /* Unlock node. */</a>
<a name="ln1890">  route_unlock_node (rn);</a>
<a name="ln1891"> </a>
<a name="ln1892">  /* let's go */</a>
<a name="ln1893">  RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln1894">  {</a>
<a name="ln1895">    zlog_debug</a>
<a name="ln1896">    (</a>
<a name="ln1897">      &quot;%s: rn %p, rib %p: %s, %s&quot;,</a>
<a name="ln1898">      __func__,</a>
<a name="ln1899">      (void *)rn,</a>
<a name="ln1900">      (void *)rib,</a>
<a name="ln1901">      (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED) ? &quot;removed&quot; : &quot;NOT removed&quot;),</a>
<a name="ln1902">      (CHECK_FLAG (rib-&gt;flags, ZEBRA_FLAG_SELECTED) ? &quot;selected&quot; : &quot;NOT selected&quot;)</a>
<a name="ln1903">    );</a>
<a name="ln1904">    rib_dump (p, rib);</a>
<a name="ln1905">  }</a>
<a name="ln1906">}</a>
<a name="ln1907"> </a>
<a name="ln1908">int</a>
<a name="ln1909">rib_add_ipv4_multipath (struct prefix_ipv4 *p, struct rib *rib, safi_t safi)</a>
<a name="ln1910">{</a>
<a name="ln1911">  struct route_table *table;</a>
<a name="ln1912">  struct route_node *rn;</a>
<a name="ln1913">  struct rib *same;</a>
<a name="ln1914">  struct nexthop *nexthop;</a>
<a name="ln1915">  int ret = 0;</a>
<a name="ln1916">  </a>
<a name="ln1917">  /* Lookup table.  */</a>
<a name="ln1918">  table = zebra_vrf_table (AFI_IP, safi, rib-&gt;vrf_id);</a>
<a name="ln1919">  if (! table)</a>
<a name="ln1920">    return 0;</a>
<a name="ln1921"> </a>
<a name="ln1922">  /* Make it sure prefixlen is applied to the prefix. */</a>
<a name="ln1923">  apply_mask_ipv4 (p);</a>
<a name="ln1924"> </a>
<a name="ln1925">  /* Set default distance by route type. */</a>
<a name="ln1926">  if (rib-&gt;distance == 0)</a>
<a name="ln1927">    {</a>
<a name="ln1928">      rib-&gt;distance = route_info[rib-&gt;type].distance;</a>
<a name="ln1929"> </a>
<a name="ln1930">      /* iBGP distance is 200. */</a>
<a name="ln1931">      if (rib-&gt;type == ZEBRA_ROUTE_BGP </a>
<a name="ln1932">	  &amp;&amp; CHECK_FLAG (rib-&gt;flags, ZEBRA_FLAG_IBGP))</a>
<a name="ln1933">	rib-&gt;distance = 200;</a>
<a name="ln1934">    }</a>
<a name="ln1935"> </a>
<a name="ln1936">  /* Lookup route node.*/</a>
<a name="ln1937">  rn = route_node_get (table, (struct prefix *) p);</a>
<a name="ln1938"> </a>
<a name="ln1939">  /* If same type of route are installed, treat it as a implicit</a>
<a name="ln1940">     withdraw. */</a>
<a name="ln1941">  RNODE_FOREACH_RIB (rn, same)</a>
<a name="ln1942">    {</a>
<a name="ln1943">      if (CHECK_FLAG (same-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln1944">        continue;</a>
<a name="ln1945">      </a>
<a name="ln1946">      if (same-&gt;type == rib-&gt;type &amp;&amp; same-&gt;table == rib-&gt;table</a>
<a name="ln1947">	  &amp;&amp; same-&gt;type != ZEBRA_ROUTE_CONNECT)</a>
<a name="ln1948">        break;</a>
<a name="ln1949">    }</a>
<a name="ln1950">  </a>
<a name="ln1951">  /* If this route is kernel route, set FIB flag to the route. */</a>
<a name="ln1952">  if (rib-&gt;type == ZEBRA_ROUTE_KERNEL || rib-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln1953">    for (nexthop = rib-&gt;nexthop; nexthop; nexthop = nexthop-&gt;next)</a>
<a name="ln1954">      SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln1955"> </a>
<a name="ln1956">  /* Link new rib to node.*/</a>
<a name="ln1957">  rib_addnode (rn, rib);</a>
<a name="ln1958">  ret = 1;</a>
<a name="ln1959">  if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1960">  {</a>
<a name="ln1961">    zlog_debug (&quot;%s: called rib_addnode (%p, %p) on new RIB entry&quot;,</a>
<a name="ln1962">                __func__, (void *)rn, (void *)rib);</a>
<a name="ln1963">    rib_dump (p, rib);</a>
<a name="ln1964">  }</a>
<a name="ln1965"> </a>
<a name="ln1966">  /* Free implicit route.*/</a>
<a name="ln1967">  if (same)</a>
<a name="ln1968">  {</a>
<a name="ln1969">    if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln1970">    {</a>
<a name="ln1971">      zlog_debug (&quot;%s: calling rib_delnode (%p, %p) on existing RIB entry&quot;,</a>
<a name="ln1972">                  __func__, (void *)rn, (void *)same);</a>
<a name="ln1973">      rib_dump (p, same);</a>
<a name="ln1974">    }</a>
<a name="ln1975">    rib_delnode (rn, same);</a>
<a name="ln1976">    ret = -1;</a>
<a name="ln1977">  }</a>
<a name="ln1978">  </a>
<a name="ln1979">  route_unlock_node (rn);</a>
<a name="ln1980">  return ret;</a>
<a name="ln1981">}</a>
<a name="ln1982"> </a>
<a name="ln1983">/* XXX factor with rib_delete_ipv6 */</a>
<a name="ln1984">int</a>
<a name="ln1985">rib_delete_ipv4 (int type, int flags, struct prefix_ipv4 *p,</a>
<a name="ln1986">		 struct in_addr *gate, ifindex_t ifindex, </a>
<a name="ln1987">		 vrf_id_t vrf_id, safi_t safi)</a>
<a name="ln1988">{</a>
<a name="ln1989">  struct route_table *table;</a>
<a name="ln1990">  struct route_node *rn;</a>
<a name="ln1991">  struct rib *rib;</a>
<a name="ln1992">  struct rib *fib = NULL;</a>
<a name="ln1993">  struct rib *same = NULL;</a>
<a name="ln1994">  struct nexthop *nexthop, *tnexthop;</a>
<a name="ln1995">  int recursing;</a>
<a name="ln1996">  char buf1[PREFIX_STRLEN];</a>
<a name="ln1997">  char buf2[INET_ADDRSTRLEN];</a>
<a name="ln1998"> </a>
<a name="ln1999">  /* Lookup table.  */</a>
<a name="ln2000">  table = zebra_vrf_table (AFI_IP, safi, vrf_id);</a>
<a name="ln2001">  if (! table)</a>
<a name="ln2002">    return 0;</a>
<a name="ln2003"> </a>
<a name="ln2004">  /* Apply mask. */</a>
<a name="ln2005">  apply_mask_ipv4 (p);</a>
<a name="ln2006"> </a>
<a name="ln2007">  if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln2008">    {</a>
<a name="ln2009">      if (gate)</a>
<a name="ln2010">	zlog_debug (&quot;rib_delete_ipv4(): route delete %s vrf %u via %s ifindex %d&quot;,</a>
<a name="ln2011">		    prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2012">		    inet_ntoa (*gate),</a>
<a name="ln2013">		    ifindex);</a>
<a name="ln2014">      else</a>
<a name="ln2015">	zlog_debug (&quot;rib_delete_ipv4(): route delete %s vrf %u ifindex %d&quot;,</a>
<a name="ln2016">		    prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2017">		    ifindex);</a>
<a name="ln2018">    }</a>
<a name="ln2019"> </a>
<a name="ln2020">  /* Lookup route node. */</a>
<a name="ln2021">  rn = route_node_lookup (table, (struct prefix *) p);</a>
<a name="ln2022">  if (! rn)</a>
<a name="ln2023">    {</a>
<a name="ln2024">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln2025">	{</a>
<a name="ln2026">	  if (gate)</a>
<a name="ln2027">	    zlog_debug (&quot;route %s vrf %u via %s ifindex %d doesn't exist in rib&quot;,</a>
<a name="ln2028">		       prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2029">		       inet_ntop (AF_INET, gate, buf2, INET_ADDRSTRLEN),</a>
<a name="ln2030">		       ifindex);</a>
<a name="ln2031">	  else</a>
<a name="ln2032">	    zlog_debug (&quot;route %s vrf %u ifindex %d doesn't exist in rib&quot;,</a>
<a name="ln2033">		       prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2034">		       ifindex);</a>
<a name="ln2035">	}</a>
<a name="ln2036">      return ZEBRA_ERR_RTNOEXIST;</a>
<a name="ln2037">    }</a>
<a name="ln2038"> </a>
<a name="ln2039">  /* Lookup same type route. */</a>
<a name="ln2040">  RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln2041">    {</a>
<a name="ln2042">      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln2043">        continue;</a>
<a name="ln2044"> </a>
<a name="ln2045">      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln2046">	fib = rib;</a>
<a name="ln2047"> </a>
<a name="ln2048">      if (rib-&gt;type != type)</a>
<a name="ln2049">	continue;</a>
<a name="ln2050">      if (rib-&gt;type == ZEBRA_ROUTE_CONNECT &amp;&amp; (nexthop = rib-&gt;nexthop) &amp;&amp;</a>
<a name="ln2051">	  nexthop-&gt;type == NEXTHOP_TYPE_IFINDEX)</a>
<a name="ln2052">	{</a>
<a name="ln2053">	  if (nexthop-&gt;ifindex != ifindex)</a>
<a name="ln2054">	    continue;</a>
<a name="ln2055">	  if (rib-&gt;refcnt)</a>
<a name="ln2056">	    {</a>
<a name="ln2057">	      rib-&gt;refcnt--;</a>
<a name="ln2058">	      route_unlock_node (rn);</a>
<a name="ln2059">	      route_unlock_node (rn);</a>
<a name="ln2060">	      return 0;</a>
<a name="ln2061">	    }</a>
<a name="ln2062">	  same = rib;</a>
<a name="ln2063">	  break;</a>
<a name="ln2064">	}</a>
<a name="ln2065">      /* Make sure that the route found has the same gateway. */</a>
<a name="ln2066">      else</a>
<a name="ln2067">        {</a>
<a name="ln2068">          if (gate == NULL)</a>
<a name="ln2069">            {</a>
<a name="ln2070">              same = rib;</a>
<a name="ln2071">              break;</a>
<a name="ln2072">            }</a>
<a name="ln2073">          for (ALL_NEXTHOPS_RO(rib-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln2074">            if (IPV4_ADDR_SAME (&amp;nexthop-&gt;gate.ipv4, gate))</a>
<a name="ln2075">              {</a>
<a name="ln2076">                same = rib;</a>
<a name="ln2077">                break;</a>
<a name="ln2078">              }</a>
<a name="ln2079">          if (same)</a>
<a name="ln2080">            break;</a>
<a name="ln2081">        }</a>
<a name="ln2082">    }</a>
<a name="ln2083">  /* If same type of route can't be found and this message is from</a>
<a name="ln2084">     kernel. */</a>
<a name="ln2085">  if (! same)</a>
<a name="ln2086">    {</a>
<a name="ln2087">      if (fib &amp;&amp; type == ZEBRA_ROUTE_KERNEL &amp;&amp;</a>
<a name="ln2088">          CHECK_FLAG(flags, ZEBRA_FLAG_SELFROUTE))</a>
<a name="ln2089">        {</a>
<a name="ln2090">          if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln2091">            {</a>
<a name="ln2092">              zlog_debug (&quot;Zebra route %s/%d was deleted by others from kernel&quot;,</a>
<a name="ln2093">                         inet_ntop (AF_INET, &amp;p-&gt;prefix, buf1, INET_ADDRSTRLEN),</a>
<a name="ln2094">                         p-&gt;prefixlen);</a>
<a name="ln2095">            }</a>
<a name="ln2096">          /* This means someone else, other than Zebra, has deleted</a>
<a name="ln2097">           * a Zebra router from the kernel. We will add it back */</a>
<a name="ln2098">           rib_update_kernel(rn, NULL, fib);</a>
<a name="ln2099">        }</a>
<a name="ln2100">      else</a>
<a name="ln2101">	{</a>
<a name="ln2102">	  if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln2103">	    {</a>
<a name="ln2104">	      if (gate)</a>
<a name="ln2105">		zlog_debug (&quot;route %s vrf %u via %s ifindex %d type %d &quot;</a>
<a name="ln2106">			   &quot;doesn't exist in rib&quot;,</a>
<a name="ln2107">			   prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2108">			   inet_ntop (AF_INET, gate, buf2, INET_ADDRSTRLEN),</a>
<a name="ln2109">			   ifindex,</a>
<a name="ln2110">			   type);</a>
<a name="ln2111">	      else</a>
<a name="ln2112">		zlog_debug (&quot;route %s vrf %u ifindex %d type %d doesn't exist in rib&quot;,</a>
<a name="ln2113">			   prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2114">			   ifindex,</a>
<a name="ln2115">			   type);</a>
<a name="ln2116">	    }</a>
<a name="ln2117">	  route_unlock_node (rn);</a>
<a name="ln2118">	  return ZEBRA_ERR_RTNOEXIST;</a>
<a name="ln2119">	}</a>
<a name="ln2120">    }</a>
<a name="ln2121">  </a>
<a name="ln2122">  if (same)</a>
<a name="ln2123">    rib_delnode (rn, same);</a>
<a name="ln2124">  </a>
<a name="ln2125">  route_unlock_node (rn);</a>
<a name="ln2126">  return 0;</a>
<a name="ln2127">}</a>
<a name="ln2128"> </a>
<a name="ln2129">/* Install static route into rib. */</a>
<a name="ln2130">static void</a>
<a name="ln2131">static_install_route (afi_t afi, safi_t safi, struct prefix *p, struct static_route *si)</a>
<a name="ln2132">{</a>
<a name="ln2133">  struct rib *rib;</a>
<a name="ln2134">  struct route_node *rn;</a>
<a name="ln2135">  struct route_table *table;</a>
<a name="ln2136"> </a>
<a name="ln2137">  /* Lookup table.  */</a>
<a name="ln2138">  table = zebra_vrf_table (afi, safi, si-&gt;vrf_id);</a>
<a name="ln2139">  if (! table)</a>
<a name="ln2140">    return;</a>
<a name="ln2141"> </a>
<a name="ln2142">  /* Lookup existing route */</a>
<a name="ln2143">  rn = route_node_get (table, p);</a>
<a name="ln2144">  RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln2145">    {</a>
<a name="ln2146">       if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln2147">         continue;</a>
<a name="ln2148">        </a>
<a name="ln2149">       if (rib-&gt;type == ZEBRA_ROUTE_STATIC &amp;&amp; rib-&gt;distance == si-&gt;distance)</a>
<a name="ln2150">         break;</a>
<a name="ln2151">    }</a>
<a name="ln2152"> </a>
<a name="ln2153">  if (rib)</a>
<a name="ln2154">    {</a>
<a name="ln2155">      /* if tag value changed , update old value in RIB */</a>
<a name="ln2156">      if (rib-&gt;tag != si-&gt;tag)</a>
<a name="ln2157">	rib-&gt;tag = si-&gt;tag;</a>
<a name="ln2158"> </a>
<a name="ln2159">      /* Same distance static route is there.  Update it with new</a>
<a name="ln2160">         nexthop. */</a>
<a name="ln2161">      route_unlock_node (rn);</a>
<a name="ln2162">      switch (si-&gt;type)</a>
<a name="ln2163">        {</a>
<a name="ln2164">	case STATIC_IPV4_GATEWAY:</a>
<a name="ln2165">	  rib_nexthop_ipv4_add (rib, &amp;si-&gt;addr.ipv4, NULL);</a>
<a name="ln2166">	  break;</a>
<a name="ln2167">	case STATIC_IPV4_IFNAME:</a>
<a name="ln2168">	  rib_nexthop_ifname_add (rib, si-&gt;ifname);</a>
<a name="ln2169">	  break;</a>
<a name="ln2170">	case STATIC_IPV4_BLACKHOLE:</a>
<a name="ln2171">	  rib_nexthop_blackhole_add (rib);</a>
<a name="ln2172">	  break;</a>
<a name="ln2173">	case STATIC_IPV6_GATEWAY:</a>
<a name="ln2174">	  rib_nexthop_ipv6_add (rib, &amp;si-&gt;addr.ipv6);</a>
<a name="ln2175">	  break;</a>
<a name="ln2176">	case STATIC_IPV6_IFNAME:</a>
<a name="ln2177">	  rib_nexthop_ifname_add (rib, si-&gt;ifname);</a>
<a name="ln2178">	  break;</a>
<a name="ln2179">	case STATIC_IPV6_GATEWAY_IFNAME:</a>
<a name="ln2180">	  rib_nexthop_ipv6_ifname_add (rib, &amp;si-&gt;addr.ipv6, si-&gt;ifname);</a>
<a name="ln2181">	  break;</a>
<a name="ln2182">        }</a>
<a name="ln2183">      rib_queue_add (&amp;zebrad, rn);</a>
<a name="ln2184">    }</a>
<a name="ln2185">  else</a>
<a name="ln2186">    {</a>
<a name="ln2187">      /* This is new static route. */</a>
<a name="ln2188">      rib = XCALLOC (MTYPE_RIB, sizeof (struct rib));</a>
<a name="ln2189">      </a>
<a name="ln2190">      rib-&gt;type = ZEBRA_ROUTE_STATIC;</a>
<a name="ln2191">      rib-&gt;distance = si-&gt;distance;</a>
<a name="ln2192">      rib-&gt;metric = 0;</a>
<a name="ln2193">      rib-&gt;vrf_id = si-&gt;vrf_id;</a>
<a name="ln2194">      rib-&gt;table = zebrad.rtm_table_default;</a>
<a name="ln2195">      rib-&gt;nexthop_num = 0;</a>
<a name="ln2196">      rib-&gt;tag = si-&gt;tag;</a>
<a name="ln2197"> </a>
<a name="ln2198">      switch (si-&gt;type)</a>
<a name="ln2199">        {</a>
<a name="ln2200">	case STATIC_IPV4_GATEWAY:</a>
<a name="ln2201">	  rib_nexthop_ipv4_add (rib, &amp;si-&gt;addr.ipv4, NULL);</a>
<a name="ln2202">	  break;</a>
<a name="ln2203">	case STATIC_IPV4_IFNAME:</a>
<a name="ln2204">	  rib_nexthop_ifname_add (rib, si-&gt;ifname);</a>
<a name="ln2205">	  break;</a>
<a name="ln2206">	case STATIC_IPV4_BLACKHOLE:</a>
<a name="ln2207">	  rib_nexthop_blackhole_add (rib);</a>
<a name="ln2208">	  break;</a>
<a name="ln2209">	case STATIC_IPV6_GATEWAY:</a>
<a name="ln2210">	  rib_nexthop_ipv6_add (rib, &amp;si-&gt;addr.ipv6);</a>
<a name="ln2211">	  break;</a>
<a name="ln2212">	case STATIC_IPV6_IFNAME:</a>
<a name="ln2213">	  rib_nexthop_ifname_add (rib, si-&gt;ifname);</a>
<a name="ln2214">	  break;</a>
<a name="ln2215">	case STATIC_IPV6_GATEWAY_IFNAME:</a>
<a name="ln2216">	  rib_nexthop_ipv6_ifname_add (rib, &amp;si-&gt;addr.ipv6, si-&gt;ifname);</a>
<a name="ln2217">	  break;</a>
<a name="ln2218">        }</a>
<a name="ln2219"> </a>
<a name="ln2220">      /* Save the flags of this static routes (reject, blackhole) */</a>
<a name="ln2221">      rib-&gt;flags = si-&gt;flags;</a>
<a name="ln2222"> </a>
<a name="ln2223">      /* Link this rib to the tree. */</a>
<a name="ln2224">      rib_addnode (rn, rib);</a>
<a name="ln2225">    }</a>
<a name="ln2226">}</a>
<a name="ln2227"> </a>
<a name="ln2228">static int</a>
<a name="ln2229">static_nexthop_same (struct nexthop *nexthop, struct static_route *si)</a>
<a name="ln2230">{</a>
<a name="ln2231">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV4</a>
<a name="ln2232">      &amp;&amp; si-&gt;type == STATIC_IPV4_GATEWAY</a>
<a name="ln2233">      &amp;&amp; IPV4_ADDR_SAME (&amp;nexthop-&gt;gate.ipv4, &amp;si-&gt;addr.ipv4))</a>
<a name="ln2234">    return 1;</a>
<a name="ln2235">  if (nexthop-&gt;type == NEXTHOP_TYPE_IFNAME</a>
<a name="ln2236">      &amp;&amp; si-&gt;type == STATIC_IPV4_IFNAME</a>
<a name="ln2237">      &amp;&amp; strcmp (nexthop-&gt;ifname, si-&gt;ifname) == 0)</a>
<a name="ln2238">    return 1;</a>
<a name="ln2239">  if (nexthop-&gt;type == NEXTHOP_TYPE_BLACKHOLE</a>
<a name="ln2240">      &amp;&amp; si-&gt;type == STATIC_IPV4_BLACKHOLE)</a>
<a name="ln2241">    return 1;</a>
<a name="ln2242">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV6</a>
<a name="ln2243">      &amp;&amp; si-&gt;type == STATIC_IPV6_GATEWAY</a>
<a name="ln2244">      &amp;&amp; IPV6_ADDR_SAME (&amp;nexthop-&gt;gate.ipv6, &amp;si-&gt;addr.ipv6))</a>
<a name="ln2245">    return 1;</a>
<a name="ln2246">  if (nexthop-&gt;type == NEXTHOP_TYPE_IFNAME</a>
<a name="ln2247">      &amp;&amp; si-&gt;type == STATIC_IPV6_IFNAME</a>
<a name="ln2248">      &amp;&amp; strcmp (nexthop-&gt;ifname, si-&gt;ifname) == 0)</a>
<a name="ln2249">    return 1;</a>
<a name="ln2250">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFNAME</a>
<a name="ln2251">      &amp;&amp; si-&gt;type == STATIC_IPV6_GATEWAY_IFNAME</a>
<a name="ln2252">      &amp;&amp; IPV6_ADDR_SAME (&amp;nexthop-&gt;gate.ipv6, &amp;si-&gt;addr.ipv6)</a>
<a name="ln2253">      &amp;&amp; strcmp (nexthop-&gt;ifname, si-&gt;ifname) == 0)</a>
<a name="ln2254">    return 1;</a>
<a name="ln2255">  return 0;</a>
<a name="ln2256">}</a>
<a name="ln2257"> </a>
<a name="ln2258">/* Uninstall static route from RIB. */</a>
<a name="ln2259">static void</a>
<a name="ln2260">static_uninstall_route (afi_t afi, safi_t safi, struct prefix *p, struct static_route *si)</a>
<a name="ln2261">{</a>
<a name="ln2262">  struct route_node *rn;</a>
<a name="ln2263">  struct rib *rib;</a>
<a name="ln2264">  struct nexthop *nexthop;</a>
<a name="ln2265">  struct route_table *table;</a>
<a name="ln2266"> </a>
<a name="ln2267">  /* Lookup table.  */</a>
<a name="ln2268">  table = zebra_vrf_table (afi, safi, si-&gt;vrf_id);</a>
<a name="ln2269">  if (! table)</a>
<a name="ln2270">    return;</a>
<a name="ln2271">  </a>
<a name="ln2272">  /* Lookup existing route with type and distance. */</a>
<a name="ln2273">  rn = route_node_lookup (table, p);</a>
<a name="ln2274">  if (! rn)</a>
<a name="ln2275">    return;</a>
<a name="ln2276"> </a>
<a name="ln2277">  RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln2278">    {</a>
<a name="ln2279">      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln2280">        continue;</a>
<a name="ln2281"> </a>
<a name="ln2282">      if (rib-&gt;type == ZEBRA_ROUTE_STATIC &amp;&amp; rib-&gt;distance == si-&gt;distance &amp;&amp;</a>
<a name="ln2283">	  rib-&gt;tag == si-&gt;tag)</a>
<a name="ln2284">        break;</a>
<a name="ln2285">    }</a>
<a name="ln2286"> </a>
<a name="ln2287">  if (! rib)</a>
<a name="ln2288">    {</a>
<a name="ln2289">      route_unlock_node (rn);</a>
<a name="ln2290">      return;</a>
<a name="ln2291">    }</a>
<a name="ln2292"> </a>
<a name="ln2293">  /* Lookup nexthop. */</a>
<a name="ln2294">  for (nexthop = rib-&gt;nexthop; nexthop; nexthop = nexthop-&gt;next)</a>
<a name="ln2295">    if (static_nexthop_same (nexthop, si))</a>
<a name="ln2296">      break;</a>
<a name="ln2297"> </a>
<a name="ln2298">  /* Can't find nexthop. */</a>
<a name="ln2299">  if (! nexthop)</a>
<a name="ln2300">    {</a>
<a name="ln2301">      route_unlock_node (rn);</a>
<a name="ln2302">      return;</a>
<a name="ln2303">    }</a>
<a name="ln2304">  </a>
<a name="ln2305">  /* Check nexthop. */</a>
<a name="ln2306">  if (rib-&gt;nexthop_num == 1)</a>
<a name="ln2307">    rib_delnode (rn, rib);</a>
<a name="ln2308">  else</a>
<a name="ln2309">    {</a>
<a name="ln2310">      if (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB))</a>
<a name="ln2311">        rib_uninstall (rn, rib);</a>
<a name="ln2312">      rib_nexthop_delete (rib, nexthop);</a>
<a name="ln2313">      nexthop_free (nexthop);</a>
<a name="ln2314">      rib_queue_add (&amp;zebrad, rn);</a>
<a name="ln2315">    }</a>
<a name="ln2316">  /* Unlock node. */</a>
<a name="ln2317">  route_unlock_node (rn);</a>
<a name="ln2318">}</a>
<a name="ln2319"> </a>
<a name="ln2320">int</a>
<a name="ln2321">static_add_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,</a>
<a name="ln2322">		      const char *ifname, u_char flags, route_tag_t tag,</a>
<a name="ln2323">		      u_char distance, vrf_id_t vrf_id)</a>
<a name="ln2324">{</a>
<a name="ln2325">  u_char type = 0;</a>
<a name="ln2326">  struct route_node *rn;</a>
<a name="ln2327">  struct static_route *si;</a>
<a name="ln2328">  struct static_route *pp;</a>
<a name="ln2329">  struct static_route *cp;</a>
<a name="ln2330">  struct static_route *update = NULL;</a>
<a name="ln2331">  struct zebra_vrf *zvrf = vrf_info_get (vrf_id);</a>
<a name="ln2332">  struct route_table *stable = zvrf-&gt;stable[AFI_IP][safi];</a>
<a name="ln2333"> </a>
<a name="ln2334">  if (! stable)</a>
<a name="ln2335">    return -1;</a>
<a name="ln2336">  </a>
<a name="ln2337">  /* Lookup static route prefix. */</a>
<a name="ln2338">  rn = route_node_get (stable, p);</a>
<a name="ln2339"> </a>
<a name="ln2340">  /* Make flags. */</a>
<a name="ln2341">  if (gate)</a>
<a name="ln2342">    type = STATIC_IPV4_GATEWAY;</a>
<a name="ln2343">  else if (ifname)</a>
<a name="ln2344">    type = STATIC_IPV4_IFNAME;</a>
<a name="ln2345">  else</a>
<a name="ln2346">    type = STATIC_IPV4_BLACKHOLE;</a>
<a name="ln2347"> </a>
<a name="ln2348">  /* Do nothing if there is a same static route.  */</a>
<a name="ln2349">  for (si = rn-&gt;info; si; si = si-&gt;next)</a>
<a name="ln2350">    {</a>
<a name="ln2351">      if (type == si-&gt;type</a>
<a name="ln2352">	  &amp;&amp; (! gate || IPV4_ADDR_SAME (gate, &amp;si-&gt;addr.ipv4))</a>
<a name="ln2353">	  &amp;&amp; (! ifname || strcmp (ifname, si-&gt;ifname) == 0))</a>
<a name="ln2354">	{</a>
<a name="ln2355">	  if (distance == si-&gt;distance &amp;&amp;</a>
<a name="ln2356">	      tag == si-&gt;tag)</a>
<a name="ln2357">	    {</a>
<a name="ln2358">	      route_unlock_node (rn);</a>
<a name="ln2359">	      return 0;</a>
<a name="ln2360">	    }</a>
<a name="ln2361">	  else</a>
<a name="ln2362">	    update = si;</a>
<a name="ln2363">	}</a>
<a name="ln2364">    }</a>
<a name="ln2365"> </a>
<a name="ln2366">  /* Distance or tag changed. */</a>
<a name="ln2367">  if (update)</a>
<a name="ln2368">    static_delete_ipv4_safi (safi, p, gate, ifname, update-&gt;tag, update-&gt;distance, vrf_id);</a>
<a name="ln2369"> </a>
<a name="ln2370">  /* Make new static route structure. */</a>
<a name="ln2371">  si = XCALLOC (MTYPE_STATIC_ROUTE, sizeof (struct static_route));</a>
<a name="ln2372"> </a>
<a name="ln2373">  si-&gt;type = type;</a>
<a name="ln2374">  si-&gt;distance = distance;</a>
<a name="ln2375">  si-&gt;tag = tag;</a>
<a name="ln2376">  si-&gt;flags = flags;</a>
<a name="ln2377">  si-&gt;vrf_id = vrf_id;</a>
<a name="ln2378"> </a>
<a name="ln2379">  if (gate)</a>
<a name="ln2380">    si-&gt;addr.ipv4 = *gate;</a>
<a name="ln2381">  if (ifname)</a>
<a name="ln2382">    si-&gt;ifname = XSTRDUP (MTYPE_TMP, ifname);</a>
<a name="ln2383"> </a>
<a name="ln2384">  /* Add new static route information to the tree with sort by</a>
<a name="ln2385">     distance value and gateway address. */</a>
<a name="ln2386">  for (pp = NULL, cp = rn-&gt;info; cp; pp = cp, cp = cp-&gt;next)</a>
<a name="ln2387">    {</a>
<a name="ln2388">      if (si-&gt;distance &lt; cp-&gt;distance)</a>
<a name="ln2389">	break;</a>
<a name="ln2390">      if (si-&gt;distance &gt; cp-&gt;distance)</a>
<a name="ln2391">	continue;</a>
<a name="ln2392">      if (si-&gt;type == STATIC_IPV4_GATEWAY &amp;&amp; cp-&gt;type == STATIC_IPV4_GATEWAY)</a>
<a name="ln2393">	{</a>
<a name="ln2394">	  if (ntohl (si-&gt;addr.ipv4.s_addr) &lt; ntohl (cp-&gt;addr.ipv4.s_addr))</a>
<a name="ln2395">	    break;</a>
<a name="ln2396">	  if (ntohl (si-&gt;addr.ipv4.s_addr) &gt; ntohl (cp-&gt;addr.ipv4.s_addr))</a>
<a name="ln2397">	    continue;</a>
<a name="ln2398">	}</a>
<a name="ln2399">    }</a>
<a name="ln2400"> </a>
<a name="ln2401">  /* Make linked list. */</a>
<a name="ln2402">  if (pp)</a>
<a name="ln2403">    pp-&gt;next = si;</a>
<a name="ln2404">  else</a>
<a name="ln2405">    rn-&gt;info = si;</a>
<a name="ln2406">  if (cp)</a>
<a name="ln2407">    cp-&gt;prev = si;</a>
<a name="ln2408">  si-&gt;prev = pp;</a>
<a name="ln2409">  si-&gt;next = cp;</a>
<a name="ln2410"> </a>
<a name="ln2411">  /* Install into rib. */</a>
<a name="ln2412">  static_install_route (AFI_IP, safi, p, si);</a>
<a name="ln2413"> </a>
<a name="ln2414">  return 1;</a>
<a name="ln2415">}</a>
<a name="ln2416"> </a>
<a name="ln2417">int</a>
<a name="ln2418">static_delete_ipv4_safi (safi_t safi, struct prefix *p, struct in_addr *gate,</a>
<a name="ln2419">			 const char *ifname, route_tag_t tag, u_char distance,</a>
<a name="ln2420">			 vrf_id_t vrf_id)</a>
<a name="ln2421">{</a>
<a name="ln2422">  u_char type = 0;</a>
<a name="ln2423">  struct route_node *rn;</a>
<a name="ln2424">  struct static_route *si;</a>
<a name="ln2425">  struct route_table *stable;</a>
<a name="ln2426"> </a>
<a name="ln2427">  /* Lookup table.  */</a>
<a name="ln2428">  stable = zebra_vrf_static_table (AFI_IP, safi, vrf_id);</a>
<a name="ln2429">  if (! stable)</a>
<a name="ln2430">    return -1;</a>
<a name="ln2431"> </a>
<a name="ln2432">  /* Lookup static route prefix. */</a>
<a name="ln2433">  rn = route_node_lookup (stable, p);</a>
<a name="ln2434">  if (! rn)</a>
<a name="ln2435">    return 0;</a>
<a name="ln2436"> </a>
<a name="ln2437">  /* Make flags. */</a>
<a name="ln2438">  if (gate)</a>
<a name="ln2439">    type = STATIC_IPV4_GATEWAY;</a>
<a name="ln2440">  else if (ifname)</a>
<a name="ln2441">    type = STATIC_IPV4_IFNAME;</a>
<a name="ln2442">  else</a>
<a name="ln2443">    type = STATIC_IPV4_BLACKHOLE;</a>
<a name="ln2444"> </a>
<a name="ln2445">  /* Find same static route is the tree */</a>
<a name="ln2446">  for (si = rn-&gt;info; si; si = si-&gt;next)</a>
<a name="ln2447">    if (type == si-&gt;type</a>
<a name="ln2448">	&amp;&amp; (! gate || IPV4_ADDR_SAME (gate, &amp;si-&gt;addr.ipv4))</a>
<a name="ln2449">	&amp;&amp; (! ifname || strcmp (ifname, si-&gt;ifname) == 0)</a>
<a name="ln2450">	&amp;&amp; (! tag || (tag == si-&gt;tag)))</a>
<a name="ln2451">      break;</a>
<a name="ln2452"> </a>
<a name="ln2453">  /* Can't find static route. */</a>
<a name="ln2454">  if (! si)</a>
<a name="ln2455">    {</a>
<a name="ln2456">      route_unlock_node (rn);</a>
<a name="ln2457">      return 0;</a>
<a name="ln2458">    }</a>
<a name="ln2459"> </a>
<a name="ln2460">  /* Install into rib. */</a>
<a name="ln2461">  static_uninstall_route (AFI_IP, safi, p, si);</a>
<a name="ln2462"> </a>
<a name="ln2463">  /* Unlink static route from linked list. */</a>
<a name="ln2464">  if (si-&gt;prev)</a>
<a name="ln2465">    si-&gt;prev-&gt;next = si-&gt;next;</a>
<a name="ln2466">  else</a>
<a name="ln2467">    rn-&gt;info = si-&gt;next;</a>
<a name="ln2468">  if (si-&gt;next)</a>
<a name="ln2469">    si-&gt;next-&gt;prev = si-&gt;prev;</a>
<a name="ln2470">  route_unlock_node (rn);</a>
<a name="ln2471">  </a>
<a name="ln2472">  /* Free static route configuration. */</a>
<a name="ln2473">  if (ifname)</a>
<a name="ln2474">    XFREE (0, si-&gt;ifname);</a>
<a name="ln2475">  XFREE (MTYPE_STATIC_ROUTE, si);</a>
<a name="ln2476"> </a>
<a name="ln2477">  route_unlock_node (rn);</a>
<a name="ln2478"> </a>
<a name="ln2479">  return 1;</a>
<a name="ln2480">}</a>
<a name="ln2481"> </a>
<a name="ln2482">int</a>
<a name="ln2483">rib_add_ipv6 (int type, int flags, struct prefix_ipv6 *p,</a>
<a name="ln2484">	      struct in6_addr *gate, ifindex_t ifindex,</a>
<a name="ln2485">	      vrf_id_t vrf_id, int table_id,</a>
<a name="ln2486">	      u_int32_t metric, u_int32_t mtu, u_char distance, safi_t safi)</a>
<a name="ln2487">{</a>
<a name="ln2488">  struct rib *rib;</a>
<a name="ln2489">  struct rib *same = NULL;</a>
<a name="ln2490">  struct route_table *table;</a>
<a name="ln2491">  struct route_node *rn;</a>
<a name="ln2492">  struct nexthop *nexthop;</a>
<a name="ln2493"> </a>
<a name="ln2494">  /* Lookup table.  */</a>
<a name="ln2495">  table = zebra_vrf_table (AFI_IP6, safi, vrf_id);</a>
<a name="ln2496">  if (! table)</a>
<a name="ln2497">    return 0;</a>
<a name="ln2498"> </a>
<a name="ln2499">  /* Make sure mask is applied. */</a>
<a name="ln2500">  apply_mask_ipv6 (p);</a>
<a name="ln2501"> </a>
<a name="ln2502">  /* Set default distance by route type. */</a>
<a name="ln2503">  if (!distance)</a>
<a name="ln2504">    distance = route_info[type].distance;</a>
<a name="ln2505">  </a>
<a name="ln2506">  if (type == ZEBRA_ROUTE_BGP &amp;&amp; CHECK_FLAG (flags, ZEBRA_FLAG_IBGP))</a>
<a name="ln2507">    distance = 200;</a>
<a name="ln2508"> </a>
<a name="ln2509">  /* Lookup route node.*/</a>
<a name="ln2510">  rn = route_node_get (table, (struct prefix *) p);</a>
<a name="ln2511"> </a>
<a name="ln2512">  /* If same type of route are installed, treat it as a implicit</a>
<a name="ln2513">     withdraw. */</a>
<a name="ln2514">  RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln2515">    {</a>
<a name="ln2516">      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln2517">        continue;</a>
<a name="ln2518"> </a>
<a name="ln2519">      if (rib-&gt;type != type)</a>
<a name="ln2520">	continue;</a>
<a name="ln2521">      if (rib-&gt;type != ZEBRA_ROUTE_CONNECT)</a>
<a name="ln2522">	{</a>
<a name="ln2523">	  same = rib;</a>
<a name="ln2524">	  break;</a>
<a name="ln2525">	}</a>
<a name="ln2526">      else if ((nexthop = rib-&gt;nexthop) &amp;&amp;</a>
<a name="ln2527">	       nexthop-&gt;type == NEXTHOP_TYPE_IFINDEX &amp;&amp;</a>
<a name="ln2528">	       nexthop-&gt;ifindex == ifindex)</a>
<a name="ln2529">	{</a>
<a name="ln2530">	  rib-&gt;refcnt++;</a>
<a name="ln2531">	  return 0;</a>
<a name="ln2532">	}</a>
<a name="ln2533">    }</a>
<a name="ln2534"> </a>
<a name="ln2535">  /* Allocate new rib structure. */</a>
<a name="ln2536">  rib = XCALLOC (MTYPE_RIB, sizeof (struct rib));</a>
<a name="ln2537">  </a>
<a name="ln2538">  rib-&gt;type = type;</a>
<a name="ln2539">  rib-&gt;distance = distance;</a>
<a name="ln2540">  rib-&gt;flags = flags;</a>
<a name="ln2541">  rib-&gt;metric = metric;</a>
<a name="ln2542">  rib-&gt;mtu = mtu;</a>
<a name="ln2543">  rib-&gt;vrf_id = vrf_id;</a>
<a name="ln2544">  rib-&gt;table = table_id;</a>
<a name="ln2545">  rib-&gt;nexthop_num = 0;</a>
<a name="ln2546">  rib-&gt;uptime = time (NULL);</a>
<a name="ln2547"> </a>
<a name="ln2548">  /* Nexthop settings. */</a>
<a name="ln2549">  if (gate)</a>
<a name="ln2550">    {</a>
<a name="ln2551">      if (ifindex)</a>
<a name="ln2552">	rib_nexthop_ipv6_ifindex_add (rib, gate, ifindex);</a>
<a name="ln2553">      else</a>
<a name="ln2554">	rib_nexthop_ipv6_add (rib, gate);</a>
<a name="ln2555">    }</a>
<a name="ln2556">  else</a>
<a name="ln2557">    rib_nexthop_ifindex_add (rib, ifindex);</a>
<a name="ln2558"> </a>
<a name="ln2559">  /* If this route is kernel route, set FIB flag to the route. */</a>
<a name="ln2560">  if (type == ZEBRA_ROUTE_KERNEL || type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln2561">    for (nexthop = rib-&gt;nexthop; nexthop; nexthop = nexthop-&gt;next)</a>
<a name="ln2562">      SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln2563"> </a>
<a name="ln2564">  /* Link new rib to node.*/</a>
<a name="ln2565">  rib_addnode (rn, rib);</a>
<a name="ln2566">  if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln2567">  {</a>
<a name="ln2568">    zlog_debug (&quot;%s: called rib_addnode (%p, %p) on new RIB entry&quot;,</a>
<a name="ln2569">      __func__, (void *)rn, (void *)rib);</a>
<a name="ln2570">    rib_dump (p, rib);</a>
<a name="ln2571">  }</a>
<a name="ln2572"> </a>
<a name="ln2573">  /* Free implicit route.*/</a>
<a name="ln2574">  if (same)</a>
<a name="ln2575">  {</a>
<a name="ln2576">    if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln2577">    {</a>
<a name="ln2578">      zlog_debug (&quot;%s: calling rib_delnode (%p, %p) on existing RIB entry&quot;,</a>
<a name="ln2579">        __func__, (void *)rn, (void *)same);</a>
<a name="ln2580">      rib_dump (p, same);</a>
<a name="ln2581">    }</a>
<a name="ln2582">    rib_delnode (rn, same);</a>
<a name="ln2583">  }</a>
<a name="ln2584">  </a>
<a name="ln2585">  route_unlock_node (rn);</a>
<a name="ln2586">  return 0;</a>
<a name="ln2587">}</a>
<a name="ln2588"> </a>
<a name="ln2589">int</a>
<a name="ln2590">rib_add_ipv6_multipath (struct prefix_ipv6 *p, struct rib *rib, safi_t safi)</a>
<a name="ln2591">{</a>
<a name="ln2592">  struct route_table *table;</a>
<a name="ln2593">  struct route_node *rn;</a>
<a name="ln2594">  struct rib *same = NULL;</a>
<a name="ln2595">  struct nexthop *nexthop;</a>
<a name="ln2596">  int ret = 0;</a>
<a name="ln2597"> </a>
<a name="ln2598">  if (!rib)</a>
<a name="ln2599">    return 0;			/* why are we getting called with NULL rib */</a>
<a name="ln2600"> </a>
<a name="ln2601">  /* Lookup table.  */</a>
<a name="ln2602">  table = zebra_vrf_table (AFI_IP6, safi, rib-&gt;vrf_id);</a>
<a name="ln2603"> </a>
<a name="ln2604">  if (! table)</a>
<a name="ln2605">    return 0;</a>
<a name="ln2606"> </a>
<a name="ln2607">  /* Make sure mask is applied. */</a>
<a name="ln2608">  apply_mask_ipv6 (p);</a>
<a name="ln2609"> </a>
<a name="ln2610">  /* Set default distance by route type. */</a>
<a name="ln2611">  if (rib-&gt;distance == 0)</a>
<a name="ln2612">    {</a>
<a name="ln2613">      rib-&gt;distance = route_info[rib-&gt;type].distance;</a>
<a name="ln2614"> </a>
<a name="ln2615">      /* iBGP distance is 200. */</a>
<a name="ln2616">      if (rib-&gt;type == ZEBRA_ROUTE_BGP</a>
<a name="ln2617">	  &amp;&amp; CHECK_FLAG (rib-&gt;flags, ZEBRA_FLAG_IBGP))</a>
<a name="ln2618">	rib-&gt;distance = 200;</a>
<a name="ln2619">    }</a>
<a name="ln2620"> </a>
<a name="ln2621">  /* Lookup route node.*/</a>
<a name="ln2622">  rn = route_node_get (table, (struct prefix *) p);</a>
<a name="ln2623"> </a>
<a name="ln2624">  /* If same type of route are installed, treat it as a implicit</a>
<a name="ln2625">     withdraw. */</a>
<a name="ln2626">  RNODE_FOREACH_RIB (rn, same) {</a>
<a name="ln2627">     if (CHECK_FLAG (same-&gt;status, RIB_ENTRY_REMOVED)) {</a>
<a name="ln2628">       continue;</a>
<a name="ln2629">     }</a>
<a name="ln2630">     if (same-&gt;type != rib-&gt;type) {</a>
<a name="ln2631">       continue;</a>
<a name="ln2632">     }</a>
<a name="ln2633"> </a>
<a name="ln2634">     if (same-&gt;table != rib-&gt;table) {</a>
<a name="ln2635">       continue;</a>
<a name="ln2636">     }</a>
<a name="ln2637">     if (same-&gt;type != ZEBRA_ROUTE_CONNECT) {</a>
<a name="ln2638">       break;</a>
<a name="ln2639">     }</a>
<a name="ln2640">  }</a>
<a name="ln2641"> </a>
<a name="ln2642">  /* If this route is kernel route, set FIB flag to the route. */</a>
<a name="ln2643">  if (rib-&gt;type == ZEBRA_ROUTE_KERNEL || rib-&gt;type == ZEBRA_ROUTE_CONNECT) {</a>
<a name="ln2644">    for (nexthop = rib-&gt;nexthop; nexthop; nexthop = nexthop-&gt;next) {</a>
<a name="ln2645">      SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln2646">    }</a>
<a name="ln2647">  }</a>
<a name="ln2648"> </a>
<a name="ln2649">  /* Link new rib to node.*/</a>
<a name="ln2650">  rib_addnode (rn, rib);</a>
<a name="ln2651">  ret = 1;</a>
<a name="ln2652">  /* Free implicit route.*/</a>
<a name="ln2653">  if (same)</a>
<a name="ln2654">  {</a>
<a name="ln2655">    if (IS_ZEBRA_DEBUG_RIB)</a>
<a name="ln2656">    {</a>
<a name="ln2657">      zlog_debug (&quot;%s: calling rib_delnode (%p, %p) on existing RIB entry&quot;,</a>
<a name="ln2658">        __func__, rn, same);</a>
<a name="ln2659">      rib_dump ((struct prefix *)p, same);</a>
<a name="ln2660">    }</a>
<a name="ln2661">    rib_delnode (rn, same);</a>
<a name="ln2662">    ret = -1;</a>
<a name="ln2663">  }</a>
<a name="ln2664"> </a>
<a name="ln2665">  route_unlock_node (rn);</a>
<a name="ln2666">  return ret;</a>
<a name="ln2667">}</a>
<a name="ln2668"> </a>
<a name="ln2669">/* XXX factor with rib_delete_ipv6 */</a>
<a name="ln2670">int</a>
<a name="ln2671">rib_delete_ipv6 (int type, int flags, struct prefix_ipv6 *p,</a>
<a name="ln2672">		 struct in6_addr *gate, ifindex_t ifindex,</a>
<a name="ln2673">		 vrf_id_t vrf_id, safi_t safi)</a>
<a name="ln2674">{</a>
<a name="ln2675">  struct route_table *table;</a>
<a name="ln2676">  struct route_node *rn;</a>
<a name="ln2677">  struct rib *rib;</a>
<a name="ln2678">  struct rib *fib = NULL;</a>
<a name="ln2679">  struct rib *same = NULL;</a>
<a name="ln2680">  struct nexthop *nexthop, *tnexthop;</a>
<a name="ln2681">  int recursing;</a>
<a name="ln2682">  char buf1[PREFIX_STRLEN];</a>
<a name="ln2683">  char buf2[INET6_ADDRSTRLEN];</a>
<a name="ln2684"> </a>
<a name="ln2685">  /* Apply mask. */</a>
<a name="ln2686">  apply_mask_ipv6 (p);</a>
<a name="ln2687"> </a>
<a name="ln2688">  /* Lookup table.  */</a>
<a name="ln2689">  table = zebra_vrf_table (AFI_IP6, safi, vrf_id);</a>
<a name="ln2690">  if (! table)</a>
<a name="ln2691">    return 0;</a>
<a name="ln2692">  </a>
<a name="ln2693">  /* Lookup route node. */</a>
<a name="ln2694">  rn = route_node_lookup (table, (struct prefix *) p);</a>
<a name="ln2695">  if (! rn)</a>
<a name="ln2696">    {</a>
<a name="ln2697">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln2698">	{</a>
<a name="ln2699">	  if (gate)</a>
<a name="ln2700">	    zlog_debug (&quot;route %s vrf %u via %s ifindex %d doesn't exist in rib&quot;,</a>
<a name="ln2701">		       prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2702">		       inet_ntop (AF_INET6, gate, buf2, INET6_ADDRSTRLEN),</a>
<a name="ln2703">		       ifindex);</a>
<a name="ln2704">	  else</a>
<a name="ln2705">	    zlog_debug (&quot;route %s vrf %u ifindex %d doesn't exist in rib&quot;,</a>
<a name="ln2706">		       prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2707">		       ifindex);</a>
<a name="ln2708">	}</a>
<a name="ln2709">      return ZEBRA_ERR_RTNOEXIST;</a>
<a name="ln2710">    }</a>
<a name="ln2711"> </a>
<a name="ln2712">  /* Lookup same type route. */</a>
<a name="ln2713">  RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln2714">    {</a>
<a name="ln2715">      if (CHECK_FLAG(rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln2716">        continue;</a>
<a name="ln2717"> </a>
<a name="ln2718">      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln2719">	fib = rib;</a>
<a name="ln2720"> </a>
<a name="ln2721">      if (rib-&gt;type != type)</a>
<a name="ln2722">        continue;</a>
<a name="ln2723">      if (rib-&gt;type == ZEBRA_ROUTE_CONNECT &amp;&amp; (nexthop = rib-&gt;nexthop) &amp;&amp;</a>
<a name="ln2724">	  nexthop-&gt;type == NEXTHOP_TYPE_IFINDEX)</a>
<a name="ln2725">	{</a>
<a name="ln2726">	  if (nexthop-&gt;ifindex != ifindex)</a>
<a name="ln2727">	    continue;</a>
<a name="ln2728">	  if (rib-&gt;refcnt)</a>
<a name="ln2729">	    {</a>
<a name="ln2730">	      rib-&gt;refcnt--;</a>
<a name="ln2731">	      route_unlock_node (rn);</a>
<a name="ln2732">	      route_unlock_node (rn);</a>
<a name="ln2733">	      return 0;</a>
<a name="ln2734">	    }</a>
<a name="ln2735">	  same = rib;</a>
<a name="ln2736">	  break;</a>
<a name="ln2737">	}</a>
<a name="ln2738">      /* Make sure that the route found has the same gateway. */</a>
<a name="ln2739">      else</a>
<a name="ln2740">        {</a>
<a name="ln2741">          if (gate == NULL)</a>
<a name="ln2742">            {</a>
<a name="ln2743">              same = rib;</a>
<a name="ln2744">              break;</a>
<a name="ln2745">            }</a>
<a name="ln2746">          for (ALL_NEXTHOPS_RO(rib-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln2747">            if (IPV6_ADDR_SAME (&amp;nexthop-&gt;gate.ipv6, gate))</a>
<a name="ln2748">              {</a>
<a name="ln2749">                same = rib;</a>
<a name="ln2750">                break;</a>
<a name="ln2751">              }</a>
<a name="ln2752">          if (same)</a>
<a name="ln2753">            break;</a>
<a name="ln2754">        }</a>
<a name="ln2755">    }</a>
<a name="ln2756"> </a>
<a name="ln2757">  /* If same type of route can't be found and this message is from</a>
<a name="ln2758">     kernel. */</a>
<a name="ln2759">  if (! same)</a>
<a name="ln2760">    {</a>
<a name="ln2761">      if (fib &amp;&amp; type == ZEBRA_ROUTE_KERNEL &amp;&amp;</a>
<a name="ln2762">          CHECK_FLAG(flags, ZEBRA_FLAG_SELFROUTE))</a>
<a name="ln2763">        {</a>
<a name="ln2764">          if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln2765">            {</a>
<a name="ln2766">              zlog_debug (&quot;Zebra route %s/%d was deleted by others from kernel&quot;,</a>
<a name="ln2767">                         inet_ntop (AF_INET, &amp;p-&gt;prefix, buf1, INET_ADDRSTRLEN),</a>
<a name="ln2768">                         p-&gt;prefixlen);</a>
<a name="ln2769">            }</a>
<a name="ln2770">          /* This means someone else, other than Zebra, has deleted a Zebra</a>
<a name="ln2771">           * route from the kernel. We will add it back */</a>
<a name="ln2772">          rib_update_kernel(rn, NULL, fib);</a>
<a name="ln2773">        }</a>
<a name="ln2774">      else</a>
<a name="ln2775">	{</a>
<a name="ln2776">	  if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln2777">	    {</a>
<a name="ln2778">	      if (gate)</a>
<a name="ln2779">		zlog_debug (&quot;route %s vrf %u via %s ifindex %d type %d &quot;</a>
<a name="ln2780">			   &quot;doesn't exist in rib&quot;,</a>
<a name="ln2781">			   prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2782">			   inet_ntop (AF_INET6, gate, buf2, INET6_ADDRSTRLEN),</a>
<a name="ln2783">			   ifindex,</a>
<a name="ln2784">			   type);</a>
<a name="ln2785">	      else</a>
<a name="ln2786">		zlog_debug (&quot;route %s vrf %u ifindex %d type %d doesn't exist in rib&quot;,</a>
<a name="ln2787">			   prefix2str (p, buf1, sizeof(buf1)), vrf_id,</a>
<a name="ln2788">			   ifindex,</a>
<a name="ln2789">			   type);</a>
<a name="ln2790">	    }</a>
<a name="ln2791">	  route_unlock_node (rn);</a>
<a name="ln2792">	  return ZEBRA_ERR_RTNOEXIST;</a>
<a name="ln2793">	}</a>
<a name="ln2794">    }</a>
<a name="ln2795"> </a>
<a name="ln2796">  if (same)</a>
<a name="ln2797">    rib_delnode (rn, same);</a>
<a name="ln2798">  </a>
<a name="ln2799">  route_unlock_node (rn);</a>
<a name="ln2800">  return 0;</a>
<a name="ln2801">}</a>
<a name="ln2802"> </a>
<a name="ln2803">/* Add static route into static route configuration. */</a>
<a name="ln2804">int</a>
<a name="ln2805">static_add_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,</a>
<a name="ln2806">		 const char *ifname, u_char flags, route_tag_t tag,</a>
<a name="ln2807">		 u_char distance, vrf_id_t vrf_id)</a>
<a name="ln2808">{</a>
<a name="ln2809">  struct route_node *rn;</a>
<a name="ln2810">  struct static_route *si;</a>
<a name="ln2811">  struct static_route *pp;</a>
<a name="ln2812">  struct static_route *cp;</a>
<a name="ln2813">  struct static_route *update = NULL;</a>
<a name="ln2814">  struct zebra_vrf *zvrf = vrf_info_get (vrf_id);</a>
<a name="ln2815">  struct route_table *stable = zvrf-&gt;stable[AFI_IP6][SAFI_UNICAST];</a>
<a name="ln2816"> </a>
<a name="ln2817">  if (! stable)</a>
<a name="ln2818">    return -1;</a>
<a name="ln2819">    </a>
<a name="ln2820">  if (!gate &amp;&amp;</a>
<a name="ln2821">      (type == STATIC_IPV6_GATEWAY || type == STATIC_IPV6_GATEWAY_IFNAME))</a>
<a name="ln2822">    return -1;</a>
<a name="ln2823">  </a>
<a name="ln2824">  if (!ifname &amp;&amp; </a>
<a name="ln2825">      (type == STATIC_IPV6_GATEWAY_IFNAME || type == STATIC_IPV6_IFNAME))</a>
<a name="ln2826">    return -1;</a>
<a name="ln2827"> </a>
<a name="ln2828">  /* Lookup static route prefix. */</a>
<a name="ln2829">  rn = route_node_get (stable, p);</a>
<a name="ln2830"> </a>
<a name="ln2831">  /* Do nothing if there is a same static route.  */</a>
<a name="ln2832">  for (si = rn-&gt;info; si; si = si-&gt;next)</a>
<a name="ln2833">    {</a>
<a name="ln2834">      if (type == si-&gt;type</a>
<a name="ln2835">	  &amp;&amp; tag == si-&gt;tag</a>
<a name="ln2836">	  &amp;&amp; (! gate || IPV6_ADDR_SAME (gate, &amp;si-&gt;addr.ipv6))</a>
<a name="ln2837">	  &amp;&amp; (! ifname || strcmp (ifname, si-&gt;ifname) == 0))</a>
<a name="ln2838">	{</a>
<a name="ln2839">	  if (distance == si-&gt;distance)</a>
<a name="ln2840">	    {</a>
<a name="ln2841">	      route_unlock_node (rn);</a>
<a name="ln2842">	      return 0;</a>
<a name="ln2843">	    }</a>
<a name="ln2844">	  else</a>
<a name="ln2845">	    update = si;</a>
<a name="ln2846">	}</a>
<a name="ln2847">    }</a>
<a name="ln2848"> </a>
<a name="ln2849">  if (update)</a>
<a name="ln2850">    static_delete_ipv6(p, type, gate, ifname, tag, update-&gt;distance, vrf_id);</a>
<a name="ln2851"> </a>
<a name="ln2852">  /* Make new static route structure. */</a>
<a name="ln2853">  si = XCALLOC (MTYPE_STATIC_ROUTE, sizeof (struct static_route));</a>
<a name="ln2854"> </a>
<a name="ln2855">  si-&gt;type = type;</a>
<a name="ln2856">  si-&gt;distance = distance;</a>
<a name="ln2857">  si-&gt;tag = tag;</a>
<a name="ln2858">  si-&gt;flags = flags;</a>
<a name="ln2859">  si-&gt;vrf_id = vrf_id;</a>
<a name="ln2860"> </a>
<a name="ln2861">  switch (type)</a>
<a name="ln2862">    {</a>
<a name="ln2863">    case STATIC_IPV6_GATEWAY:</a>
<a name="ln2864">      si-&gt;addr.ipv6 = *gate;</a>
<a name="ln2865">      break;</a>
<a name="ln2866">    case STATIC_IPV6_IFNAME:</a>
<a name="ln2867">      si-&gt;ifname = XSTRDUP (MTYPE_TMP, ifname);</a>
<a name="ln2868">      break;</a>
<a name="ln2869">    case STATIC_IPV6_GATEWAY_IFNAME:</a>
<a name="ln2870">      si-&gt;addr.ipv6 = *gate;</a>
<a name="ln2871">      si-&gt;ifname = XSTRDUP (MTYPE_TMP, ifname);</a>
<a name="ln2872">      break;</a>
<a name="ln2873">    }</a>
<a name="ln2874"> </a>
<a name="ln2875">  /* Add new static route information to the tree with sort by</a>
<a name="ln2876">     distance value and gateway address. */</a>
<a name="ln2877">  for (pp = NULL, cp = rn-&gt;info; cp; pp = cp, cp = cp-&gt;next)</a>
<a name="ln2878">    {</a>
<a name="ln2879">      if (si-&gt;distance &lt; cp-&gt;distance)</a>
<a name="ln2880">	break;</a>
<a name="ln2881">      if (si-&gt;distance &gt; cp-&gt;distance)</a>
<a name="ln2882">	continue;</a>
<a name="ln2883">    }</a>
<a name="ln2884"> </a>
<a name="ln2885">  /* Make linked list. */</a>
<a name="ln2886">  if (pp)</a>
<a name="ln2887">    pp-&gt;next = si;</a>
<a name="ln2888">  else</a>
<a name="ln2889">    rn-&gt;info = si;</a>
<a name="ln2890">  if (cp)</a>
<a name="ln2891">    cp-&gt;prev = si;</a>
<a name="ln2892">  si-&gt;prev = pp;</a>
<a name="ln2893">  si-&gt;next = cp;</a>
<a name="ln2894"> </a>
<a name="ln2895">  /* Install into rib. */</a>
<a name="ln2896">  static_install_route (AFI_IP6, SAFI_UNICAST, p, si);</a>
<a name="ln2897"> </a>
<a name="ln2898">  return 1;</a>
<a name="ln2899">}</a>
<a name="ln2900"> </a>
<a name="ln2901">/* Delete static route from static route configuration. */</a>
<a name="ln2902">int</a>
<a name="ln2903">static_delete_ipv6 (struct prefix *p, u_char type, struct in6_addr *gate,</a>
<a name="ln2904">		    const char *ifname, route_tag_t tag, u_char distance,</a>
<a name="ln2905">		    vrf_id_t vrf_id)</a>
<a name="ln2906">{</a>
<a name="ln2907">  struct route_node *rn;</a>
<a name="ln2908">  struct static_route *si;</a>
<a name="ln2909">  struct route_table *stable;</a>
<a name="ln2910"> </a>
<a name="ln2911">  /* Lookup table.  */</a>
<a name="ln2912">  stable = zebra_vrf_static_table (AFI_IP6, SAFI_UNICAST, vrf_id);</a>
<a name="ln2913">  if (! stable)</a>
<a name="ln2914">    return -1;</a>
<a name="ln2915"> </a>
<a name="ln2916">  /* Lookup static route prefix. */</a>
<a name="ln2917">  rn = route_node_lookup (stable, p);</a>
<a name="ln2918">  if (! rn)</a>
<a name="ln2919">    return 0;</a>
<a name="ln2920"> </a>
<a name="ln2921">  /* Find same static route is the tree */</a>
<a name="ln2922">  for (si = rn-&gt;info; si; si = si-&gt;next)</a>
<a name="ln2923">    if (distance == si-&gt;distance </a>
<a name="ln2924">	&amp;&amp; type == si-&gt;type</a>
<a name="ln2925">	&amp;&amp; (! gate || IPV6_ADDR_SAME (gate, &amp;si-&gt;addr.ipv6))</a>
<a name="ln2926">	&amp;&amp; (! ifname || strcmp (ifname, si-&gt;ifname) == 0)</a>
<a name="ln2927">	&amp;&amp; (! tag || (tag == si-&gt;tag)))</a>
<a name="ln2928">      break;</a>
<a name="ln2929"> </a>
<a name="ln2930">  /* Can't find static route. */</a>
<a name="ln2931">  if (! si)</a>
<a name="ln2932">    {</a>
<a name="ln2933">      route_unlock_node (rn);</a>
<a name="ln2934">      return 0;</a>
<a name="ln2935">    }</a>
<a name="ln2936"> </a>
<a name="ln2937">  /* Install into rib. */</a>
<a name="ln2938">  static_uninstall_route (AFI_IP6, SAFI_UNICAST, p, si);</a>
<a name="ln2939"> </a>
<a name="ln2940">  /* Unlink static route from linked list. */</a>
<a name="ln2941">  if (si-&gt;prev)</a>
<a name="ln2942">    si-&gt;prev-&gt;next = si-&gt;next;</a>
<a name="ln2943">  else</a>
<a name="ln2944">    rn-&gt;info = si-&gt;next;</a>
<a name="ln2945">  if (si-&gt;next)</a>
<a name="ln2946">    si-&gt;next-&gt;prev = si-&gt;prev;</a>
<a name="ln2947">  </a>
<a name="ln2948">  /* Free static route configuration. */</a>
<a name="ln2949">  if (ifname)</a>
<a name="ln2950">    XFREE (0, si-&gt;ifname);</a>
<a name="ln2951">  XFREE (MTYPE_STATIC_ROUTE, si);</a>
<a name="ln2952"> </a>
<a name="ln2953">  return 1;</a>
<a name="ln2954">}</a>
<a name="ln2955"> </a>
<a name="ln2956">/* RIB update function. */</a>
<a name="ln2957">void</a>
<a name="ln2958">rib_update (vrf_id_t vrf_id)</a>
<a name="ln2959">{</a>
<a name="ln2960">  struct route_node *rn;</a>
<a name="ln2961">  struct route_table *table;</a>
<a name="ln2962">  </a>
<a name="ln2963">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, vrf_id);</a>
<a name="ln2964">  if (table)</a>
<a name="ln2965">    for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln2966">      if (rnode_to_ribs (rn))</a>
<a name="ln2967">        rib_queue_add (&amp;zebrad, rn);</a>
<a name="ln2968"> </a>
<a name="ln2969">  table = zebra_vrf_table (AFI_IP6, SAFI_UNICAST, vrf_id);</a>
<a name="ln2970">  if (table)</a>
<a name="ln2971">    for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln2972">      if (rnode_to_ribs (rn))</a>
<a name="ln2973">        rib_queue_add (&amp;zebrad, rn);</a>
<a name="ln2974">}</a>
<a name="ln2975"> </a>
<a name="ln2976"> </a>
<a name="ln2977">/* Remove all routes which comes from non main table.  */</a>
<a name="ln2978">static void</a>
<a name="ln2979">rib_weed_table (struct route_table *table)</a>
<a name="ln2980">{</a>
<a name="ln2981">  struct route_node *rn;</a>
<a name="ln2982">  struct rib *rib;</a>
<a name="ln2983">  struct rib *next;</a>
<a name="ln2984"> </a>
<a name="ln2985">  if (table)</a>
<a name="ln2986">    for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln2987">      RNODE_FOREACH_RIB_SAFE (rn, rib, next)</a>
<a name="ln2988">	{</a>
<a name="ln2989">	  if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln2990">	    continue;</a>
<a name="ln2991"> </a>
<a name="ln2992">	  if (rib-&gt;table != zebrad.rtm_table_default &amp;&amp;</a>
<a name="ln2993">	      rib-&gt;table != RT_TABLE_MAIN)</a>
<a name="ln2994">            rib_delnode (rn, rib);</a>
<a name="ln2995">	}</a>
<a name="ln2996">}</a>
<a name="ln2997"> </a>
<a name="ln2998">/* Delete all routes from non main table. */</a>
<a name="ln2999">void</a>
<a name="ln3000">rib_weed_tables (void)</a>
<a name="ln3001">{</a>
<a name="ln3002">  vrf_iter_t iter;</a>
<a name="ln3003">  struct zebra_vrf *zvrf;</a>
<a name="ln3004"> </a>
<a name="ln3005">  for (iter = vrf_first (); iter != VRF_ITER_INVALID; iter = vrf_next (iter))</a>
<a name="ln3006">    if ((zvrf = vrf_iter2info (iter)) != NULL)</a>
<a name="ln3007">      {</a>
<a name="ln3008">        rib_weed_table (zvrf-&gt;table[AFI_IP][SAFI_UNICAST]);</a>
<a name="ln3009">        rib_weed_table (zvrf-&gt;table[AFI_IP6][SAFI_UNICAST]);</a>
<a name="ln3010">      }</a>
<a name="ln3011">}</a>
<a name="ln3012"> </a>
<a name="ln3013">#if 0</a>
<a name="ln3014">/* Delete self installed routes after zebra is relaunched.  */</a>
<a name="ln3015">static void</a>
<a name="ln3016">rib_sweep_table (struct route_table *table)</a>
<a name="ln3017">{</a>
<a name="ln3018">  struct route_node *rn;</a>
<a name="ln3019">  struct rib *rib;</a>
<a name="ln3020">  struct rib *next;</a>
<a name="ln3021">  int ret = 0;</a>
<a name="ln3022"> </a>
<a name="ln3023">  if (table)</a>
<a name="ln3024">    for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln3025">      RNODE_FOREACH_RIB_SAFE (rn, rib, next)</a>
<a name="ln3026">	{</a>
<a name="ln3027">	  if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln3028">	    continue;</a>
<a name="ln3029"> </a>
<a name="ln3030">	  if (rib-&gt;type == ZEBRA_ROUTE_KERNEL &amp;&amp; </a>
<a name="ln3031">	      CHECK_FLAG (rib-&gt;flags, ZEBRA_FLAG_SELFROUTE))</a>
<a name="ln3032">	    {</a>
<a name="ln3033">	      ret = rib_update_kernel (rn, rib, NULL);</a>
<a name="ln3034">	      if (! ret)</a>
<a name="ln3035">                rib_delnode (rn, rib);</a>
<a name="ln3036">	    }</a>
<a name="ln3037">	}</a>
<a name="ln3038">}</a>
<a name="ln3039">#endif</a>
<a name="ln3040"> </a>
<a name="ln3041">/* Sweep all RIB tables.  */</a>
<a name="ln3042">void</a>
<a name="ln3043">rib_sweep_route (void)</a>
<a name="ln3044">{</a>
<a name="ln3045">  vrf_iter_t iter;</a>
<a name="ln3046">  struct zebra_vrf *zvrf;</a>
<a name="ln3047"> </a>
<a name="ln3048">  for (iter = vrf_first (); iter != VRF_ITER_INVALID; iter = vrf_next (iter))</a>
<a name="ln3049">    if ((zvrf = vrf_iter2info (iter)) != NULL)</a>
<a name="ln3050">      {</a>
<a name="ln3051">        rib_weed_table (zvrf-&gt;table[AFI_IP][SAFI_UNICAST]);</a>
<a name="ln3052">        rib_weed_table (zvrf-&gt;table[AFI_IP6][SAFI_UNICAST]);</a>
<a name="ln3053">      }</a>
<a name="ln3054">}</a>
<a name="ln3055"> </a>
<a name="ln3056">/* Remove specific by protocol routes from 'table'. */</a>
<a name="ln3057">static unsigned long</a>
<a name="ln3058">rib_score_proto_table (u_char proto, struct route_table *table)</a>
<a name="ln3059">{</a>
<a name="ln3060">  struct route_node *rn;</a>
<a name="ln3061">  struct rib *rib;</a>
<a name="ln3062">  struct rib *next;</a>
<a name="ln3063">  unsigned long n = 0;</a>
<a name="ln3064"> </a>
<a name="ln3065">  if (table)</a>
<a name="ln3066">    for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln3067">      RNODE_FOREACH_RIB_SAFE (rn, rib, next)</a>
<a name="ln3068">        {</a>
<a name="ln3069">          if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln3070">            continue;</a>
<a name="ln3071">          if (rib-&gt;type == proto)</a>
<a name="ln3072">            {</a>
<a name="ln3073">              rib_delnode (rn, rib);</a>
<a name="ln3074">              n++;</a>
<a name="ln3075">            }</a>
<a name="ln3076">        }</a>
<a name="ln3077"> </a>
<a name="ln3078">  return n;</a>
<a name="ln3079">}</a>
<a name="ln3080"> </a>
<a name="ln3081">/* Remove specific by protocol routes. */</a>
<a name="ln3082">unsigned long</a>
<a name="ln3083">rib_score_proto (u_char proto)</a>
<a name="ln3084">{</a>
<a name="ln3085">  vrf_iter_t iter;</a>
<a name="ln3086">  struct zebra_vrf *zvrf;</a>
<a name="ln3087">  unsigned long cnt = 0;</a>
<a name="ln3088"> </a>
<a name="ln3089">  for (iter = vrf_first (); iter != VRF_ITER_INVALID; iter = vrf_next (iter))</a>
<a name="ln3090">    if ((zvrf = vrf_iter2info (iter)) != NULL)</a>
<a name="ln3091">      cnt += rib_score_proto_table (proto, zvrf-&gt;table[AFI_IP][SAFI_UNICAST])</a>
<a name="ln3092">            +rib_score_proto_table (proto, zvrf-&gt;table[AFI_IP6][SAFI_UNICAST]);</a>
<a name="ln3093"> </a>
<a name="ln3094">  return cnt;</a>
<a name="ln3095">}</a>
<a name="ln3096"> </a>
<a name="ln3097">/* Close RIB and clean up kernel routes. */</a>
<a name="ln3098">void</a>
<a name="ln3099">rib_close_table (struct route_table *table)</a>
<a name="ln3100">{</a>
<a name="ln3101">  struct route_node *rn;</a>
<a name="ln3102">  rib_table_info_t *info = table-&gt;info;</a>
<a name="ln3103">  struct rib *rib;</a>
<a name="ln3104"> </a>
<a name="ln3105">  if (table)</a>
<a name="ln3106">    for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln3107">      RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln3108">        {</a>
<a name="ln3109">          if (!CHECK_FLAG (rib-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln3110">	    continue;</a>
<a name="ln3111"> </a>
<a name="ln3112">          if (info-&gt;safi == SAFI_UNICAST)</a>
<a name="ln3113">            zfpm_trigger_update (rn, NULL);</a>
<a name="ln3114"> </a>
<a name="ln3115">	  if (! RIB_SYSTEM_ROUTE (rib))</a>
<a name="ln3116">	    rib_update_kernel (rn, rib, NULL);</a>
<a name="ln3117">        }</a>
<a name="ln3118">}</a>
<a name="ln3119"> </a>
<a name="ln3120">/* Close all RIB tables.  */</a>
<a name="ln3121">void</a>
<a name="ln3122">rib_close (void)</a>
<a name="ln3123">{</a>
<a name="ln3124">  vrf_iter_t iter;</a>
<a name="ln3125">  struct zebra_vrf *zvrf;</a>
<a name="ln3126"> </a>
<a name="ln3127">  for (iter = vrf_first (); iter != VRF_ITER_INVALID; iter = vrf_next (iter))</a>
<a name="ln3128">    if ((zvrf = vrf_iter2info (iter)) != NULL)</a>
<a name="ln3129">      {</a>
<a name="ln3130">        rib_close_table (zvrf-&gt;table[AFI_IP][SAFI_UNICAST]);</a>
<a name="ln3131">        rib_close_table (zvrf-&gt;table[AFI_IP6][SAFI_UNICAST]);</a>
<a name="ln3132">      }</a>
<a name="ln3133">}</a>
<a name="ln3134"> </a>
<a name="ln3135">/* Routing information base initialize. */</a>
<a name="ln3136">void</a>
<a name="ln3137">rib_init (void)</a>
<a name="ln3138">{</a>
<a name="ln3139">  rib_queue_init (&amp;zebrad);</a>
<a name="ln3140">}</a>
<a name="ln3141"> </a>
<a name="ln3142">/*</a>
<a name="ln3143"> * vrf_id_get_next</a>
<a name="ln3144"> *</a>
<a name="ln3145"> * Get the first vrf id that is greater than the given vrf id if any.</a>
<a name="ln3146"> *</a>
<a name="ln3147"> * Returns TRUE if a vrf id was found, FALSE otherwise.</a>
<a name="ln3148"> */</a>
<a name="ln3149">static inline int</a>
<a name="ln3150">vrf_id_get_next (vrf_id_t vrf_id, vrf_id_t *next_id_p)</a>
<a name="ln3151">{</a>
<a name="ln3152">  vrf_iter_t iter = vrf_iterator (vrf_id);</a>
<a name="ln3153">  struct zebra_vrf *zvrf = vrf_iter2info (iter);</a>
<a name="ln3154"> </a>
<a name="ln3155">  /* The same one ? Then find out the next. */</a>
<a name="ln3156">  if (zvrf &amp;&amp; (zvrf-&gt;vrf_id == vrf_id))</a>
<a name="ln3157">    zvrf = vrf_iter2info (vrf_next (iter));</a>
<a name="ln3158"> </a>
<a name="ln3159">  if (zvrf)</a>
<a name="ln3160">    {</a>
<a name="ln3161">      *next_id_p = zvrf-&gt;vrf_id;</a>
<a name="ln3162">      return 1;</a>
<a name="ln3163">    }</a>
<a name="ln3164"> </a>
<a name="ln3165">  return 0;</a>
<a name="ln3166">}</a>
<a name="ln3167"> </a>
<a name="ln3168">/*</a>
<a name="ln3169"> * rib_tables_iter_next</a>
<a name="ln3170"> *</a>
<a name="ln3171"> * Returns the next table in the iteration.</a>
<a name="ln3172"> */</a>
<a name="ln3173">struct route_table *</a>
<a name="ln3174">rib_tables_iter_next (rib_tables_iter_t *iter)</a>
<a name="ln3175">{</a>
<a name="ln3176">  struct route_table *table;</a>
<a name="ln3177"> </a>
<a name="ln3178">  /*</a>
<a name="ln3179">   * Array that helps us go over all AFI/SAFI combinations via one</a>
<a name="ln3180">   * index.</a>
<a name="ln3181">   */</a>
<a name="ln3182">  static struct {</a>
<a name="ln3183">    afi_t afi;</a>
<a name="ln3184">    safi_t safi;</a>
<a name="ln3185">  } afi_safis[] = {</a>
<a name="ln3186">    { AFI_IP, SAFI_UNICAST },</a>
<a name="ln3187">    { AFI_IP, SAFI_MULTICAST },</a>
<a name="ln3188">    { AFI_IP6, SAFI_UNICAST },</a>
<a name="ln3189">    { AFI_IP6, SAFI_MULTICAST },</a>
<a name="ln3190">  };</a>
<a name="ln3191"> </a>
<a name="ln3192">  table = NULL;</a>
<a name="ln3193"> </a>
<a name="ln3194">  switch (iter-&gt;state)</a>
<a name="ln3195">    {</a>
<a name="ln3196"> </a>
<a name="ln3197">    case RIB_TABLES_ITER_S_INIT:</a>
<a name="ln3198">      iter-&gt;vrf_id = VRF_DEFAULT;</a>
<a name="ln3199">      iter-&gt;afi_safi_ix = -1;</a>
<a name="ln3200"> </a>
<a name="ln3201">      /* Fall through */</a>
<a name="ln3202"> </a>
<a name="ln3203">    case RIB_TABLES_ITER_S_ITERATING:</a>
<a name="ln3204">      iter-&gt;afi_safi_ix++;</a>
<a name="ln3205">      while (1)</a>
<a name="ln3206">	{</a>
<a name="ln3207"> </a>
<a name="ln3208">	  while (iter-&gt;afi_safi_ix &lt; (int) ZEBRA_NUM_OF (afi_safis))</a>
<a name="ln3209">	    {</a>
<a name="ln3210">	      table = zebra_vrf_table (afi_safis[iter-&gt;afi_safi_ix].afi,</a>
<a name="ln3211">				 afi_safis[iter-&gt;afi_safi_ix].safi,</a>
<a name="ln3212">				 iter-&gt;vrf_id);</a>
<a name="ln3213">	      if (table)</a>
<a name="ln3214">		break;</a>
<a name="ln3215"> </a>
<a name="ln3216">	      iter-&gt;afi_safi_ix++;</a>
<a name="ln3217">	    }</a>
<a name="ln3218"> </a>
<a name="ln3219">	  /*</a>
<a name="ln3220">	   * Found another table in this vrf.</a>
<a name="ln3221">	   */</a>
<a name="ln3222">	  if (table)</a>
<a name="ln3223">	    break;</a>
<a name="ln3224"> </a>
<a name="ln3225">	  /*</a>
<a name="ln3226">	   * Done with all tables in the current vrf, go to the next</a>
<a name="ln3227">	   * one.</a>
<a name="ln3228">	   */</a>
<a name="ln3229">	  if (!vrf_id_get_next (iter-&gt;vrf_id, &amp;iter-&gt;vrf_id))</a>
<a name="ln3230">	    break;</a>
<a name="ln3231"> </a>
<a name="ln3232">	  iter-&gt;afi_safi_ix = 0;</a>
<a name="ln3233">	}</a>
<a name="ln3234"> </a>
<a name="ln3235">      break;</a>
<a name="ln3236"> </a>
<a name="ln3237">    case RIB_TABLES_ITER_S_DONE:</a>
<a name="ln3238">      return NULL;</a>
<a name="ln3239">    }</a>
<a name="ln3240"> </a>
<a name="ln3241">  if (table)</a>
<a name="ln3242">    iter-&gt;state = RIB_TABLES_ITER_S_ITERATING;</a>
<a name="ln3243">  else</a>
<a name="ln3244">    iter-&gt;state = RIB_TABLES_ITER_S_DONE;</a>
<a name="ln3245"> </a>
<a name="ln3246">  return table;</a>
<a name="ln3247">}</a>
<a name="ln3248"> </a>
<a name="ln3249">/* Lookup VRF by identifier.  */</a>
<a name="ln3250">struct zebra_vrf *</a>
<a name="ln3251">zebra_vrf_lookup (vrf_id_t vrf_id)</a>
<a name="ln3252">{</a>
<a name="ln3253">  return vrf_info_lookup (vrf_id);</a>
<a name="ln3254">}</a>
<a name="ln3255"> </a>
<a name="ln3256">/*</a>
<a name="ln3257"> * Create a routing table for the specific AFI/SAFI in the given VRF.</a>
<a name="ln3258"> */</a>
<a name="ln3259">static void</a>
<a name="ln3260">zebra_vrf_table_create (struct zebra_vrf *zvrf, afi_t afi, safi_t safi)</a>
<a name="ln3261">{</a>
<a name="ln3262">  rib_table_info_t *info;</a>
<a name="ln3263">  struct route_table *table;</a>
<a name="ln3264"> </a>
<a name="ln3265">  assert (!zvrf-&gt;table[afi][safi]);</a>
<a name="ln3266"> </a>
<a name="ln3267">  table = route_table_init ();</a>
<a name="ln3268">  zvrf-&gt;table[afi][safi] = table;</a>
<a name="ln3269"> </a>
<a name="ln3270">  info = XCALLOC (MTYPE_RIB_TABLE_INFO, sizeof (*info));</a>
<a name="ln3271">  info-&gt;zvrf = zvrf;</a>
<a name="ln3272">  info-&gt;afi = afi;</a>
<a name="ln3273">  info-&gt;safi = safi;</a>
<a name="ln3274">  table-&gt;info = info;</a>
<a name="ln3275">}</a>
<a name="ln3276"> </a>
<a name="ln3277">/* Allocate new zebra VRF. */</a>
<a name="ln3278">struct zebra_vrf *</a>
<a name="ln3279">zebra_vrf_alloc (vrf_id_t vrf_id)</a>
<a name="ln3280">{</a>
<a name="ln3281">  struct zebra_vrf *zvrf;</a>
<a name="ln3282">#ifdef HAVE_NETLINK</a>
<a name="ln3283">  char nl_name[64];</a>
<a name="ln3284">#endif</a>
<a name="ln3285"> </a>
<a name="ln3286">  zvrf = XCALLOC (MTYPE_ZEBRA_VRF, sizeof (struct zebra_vrf));</a>
<a name="ln3287"> </a>
<a name="ln3288">  /* Allocate routing table and static table.  */</a>
<a name="ln3289">  zebra_vrf_table_create (zvrf, AFI_IP, SAFI_UNICAST);</a>
<a name="ln3290">  zebra_vrf_table_create (zvrf, AFI_IP6, SAFI_UNICAST);</a>
<a name="ln3291">  zvrf-&gt;stable[AFI_IP][SAFI_UNICAST] = route_table_init ();</a>
<a name="ln3292">  zvrf-&gt;stable[AFI_IP6][SAFI_UNICAST] = route_table_init ();</a>
<a name="ln3293">  zebra_vrf_table_create (zvrf, AFI_IP, SAFI_MULTICAST);</a>
<a name="ln3294">  zebra_vrf_table_create (zvrf, AFI_IP6, SAFI_MULTICAST);</a>
<a name="ln3295">  zvrf-&gt;stable[AFI_IP][SAFI_MULTICAST] = route_table_init ();</a>
<a name="ln3296">  zvrf-&gt;stable[AFI_IP6][SAFI_MULTICAST] = route_table_init ();</a>
<a name="ln3297"> </a>
<a name="ln3298">  zvrf-&gt;rnh_table[AFI_IP] = route_table_init();</a>
<a name="ln3299">  zvrf-&gt;rnh_table[AFI_IP6] = route_table_init();</a>
<a name="ln3300"> </a>
<a name="ln3301">  /* Set VRF ID */</a>
<a name="ln3302">  zvrf-&gt;vrf_id = vrf_id;</a>
<a name="ln3303"> </a>
<a name="ln3304">#ifdef HAVE_NETLINK</a>
<a name="ln3305">  /* Initialize netlink sockets */</a>
<a name="ln3306">  snprintf (nl_name, 64, &quot;netlink-listen (vrf %u)&quot;, vrf_id);</a>
<a name="ln3307">  zvrf-&gt;netlink.sock = -1;</a>
<a name="ln3308">  zvrf-&gt;netlink.name = XSTRDUP (MTYPE_NETLINK_NAME, nl_name);</a>
<a name="ln3309"> </a>
<a name="ln3310">  snprintf (nl_name, 64, &quot;netlink-cmd (vrf %u)&quot;, vrf_id);</a>
<a name="ln3311">  zvrf-&gt;netlink_cmd.sock = -1;</a>
<a name="ln3312">  zvrf-&gt;netlink_cmd.name = XSTRDUP (MTYPE_NETLINK_NAME, nl_name);</a>
<a name="ln3313">#endif</a>
<a name="ln3314"> </a>
<a name="ln3315">  return zvrf;</a>
<a name="ln3316">}</a>
<a name="ln3317"> </a>
<a name="ln3318">/* Lookup the routing table in an enabled VRF. */</a>
<a name="ln3319">struct route_table *</a>
<a name="ln3320">zebra_vrf_table (afi_t afi, safi_t safi, vrf_id_t vrf_id)</a>
<a name="ln3321">{</a>
<a name="ln3322">  struct zebra_vrf *zvrf = vrf_info_lookup (vrf_id);</a>
<a name="ln3323"> </a>
<a name="ln3324">  if (!zvrf)</a>
<a name="ln3325">    return NULL;</a>
<a name="ln3326"> </a>
<a name="ln3327">  if (afi &gt;= AFI_MAX || safi &gt;= SAFI_MAX)</a>
<a name="ln3328">    return NULL;</a>
<a name="ln3329"> </a>
<a name="ln3330">  return zvrf-&gt;table[afi][safi];</a>
<a name="ln3331">}</a>
<a name="ln3332"> </a>
<a name="ln3333">/* Lookup the static routing table in a VRF. */</a>
<a name="ln3334">struct route_table *</a>
<a name="ln3335">zebra_vrf_static_table (afi_t afi, safi_t safi, vrf_id_t vrf_id)</a>
<a name="ln3336">{</a>
<a name="ln3337">  struct zebra_vrf *zvrf = vrf_info_lookup (vrf_id);</a>
<a name="ln3338"> </a>
<a name="ln3339">  if (!zvrf)</a>
<a name="ln3340">    return NULL;</a>
<a name="ln3341"> </a>
<a name="ln3342">  if (afi &gt;= AFI_MAX || safi &gt;= SAFI_MAX)</a>
<a name="ln3343">    return NULL;</a>
<a name="ln3344"> </a>
<a name="ln3345">  return zvrf-&gt;stable[afi][safi];</a>
<a name="ln3346">}</a>
<a name="ln3347"> </a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="409"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'route_unlock_node' function. Check lines: 409, 340.</p></div>
<div class="balloon" rel="544"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'route_unlock_node' function. Check lines: 544, 474.</p></div>
<div class="balloon" rel="607"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'route_unlock_node' function. Check lines: 607, 585.</p></div>
<div class="balloon" rel="873"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'route_unlock_node' function. Check lines: 873, 857.</p></div>
<div class="balloon" rel="1550"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!(zebra->mq = meta_queue_new())' is always false.</p></div>
<div class="balloon" rel="1550"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v559/" target="_blank">V559</a> Suspicious assignment inside the conditional expression of 'if' statement: zebra->mq = meta_queue_new().</p></div>
<div class="balloon" rel="2168"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 2168, 2177</p></div>
<div class="balloon" rel="2204"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 2204, 2213</p></div>
<div class="balloon" rel="3102"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'table' pointer was utilized before it was verified against nullptr. Check lines: 3102, 3105.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
