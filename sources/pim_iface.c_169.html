
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_iface.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln5">  it under the terms of the GNU General Public License as published by</a>
<a name="ln6">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln7">  (at your option) any later version.</a>
<a name="ln8"> </a>
<a name="ln9">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln10">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln11">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln12">  General Public License for more details.</a>
<a name="ln13">  </a>
<a name="ln14">  You should have received a copy of the GNU General Public License</a>
<a name="ln15">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln16">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln17">  MA 02110-1301 USA</a>
<a name="ln18">  </a>
<a name="ln19">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln20">*/</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;if.h&quot;</a>
<a name="ln25">#include &quot;log.h&quot;</a>
<a name="ln26">#include &quot;vty.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;pimd.h&quot;</a>
<a name="ln31">#include &quot;pim_iface.h&quot;</a>
<a name="ln32">#include &quot;pim_igmp.h&quot;</a>
<a name="ln33">#include &quot;pim_mroute.h&quot;</a>
<a name="ln34">#include &quot;pim_oil.h&quot;</a>
<a name="ln35">#include &quot;pim_str.h&quot;</a>
<a name="ln36">#include &quot;pim_pim.h&quot;</a>
<a name="ln37">#include &quot;pim_neighbor.h&quot;</a>
<a name="ln38">#include &quot;pim_ifchannel.h&quot;</a>
<a name="ln39">#include &quot;pim_sock.h&quot;</a>
<a name="ln40">#include &quot;pim_time.h&quot;</a>
<a name="ln41">#include &quot;pim_ssmpingd.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">static void pim_if_igmp_join_del_all(struct interface *ifp);</a>
<a name="ln44"> </a>
<a name="ln45">static void *if_list_clean(struct pim_interface *pim_ifp)</a>
<a name="ln46">{</a>
<a name="ln47">  if (pim_ifp-&gt;igmp_join_list) {</a>
<a name="ln48">    list_delete(pim_ifp-&gt;igmp_join_list);</a>
<a name="ln49">  }</a>
<a name="ln50"> </a>
<a name="ln51">  if (pim_ifp-&gt;igmp_socket_list) {</a>
<a name="ln52">    list_delete(pim_ifp-&gt;igmp_socket_list);</a>
<a name="ln53">  }</a>
<a name="ln54"> </a>
<a name="ln55">  if (pim_ifp-&gt;pim_neighbor_list) {</a>
<a name="ln56">    list_delete(pim_ifp-&gt;pim_neighbor_list);</a>
<a name="ln57">  }</a>
<a name="ln58"> </a>
<a name="ln59">  if (pim_ifp-&gt;pim_ifchannel_list) {</a>
<a name="ln60">    list_delete(pim_ifp-&gt;pim_ifchannel_list);</a>
<a name="ln61">  }</a>
<a name="ln62"> </a>
<a name="ln63">  XFREE(MTYPE_PIM_INTERFACE, pim_ifp);</a>
<a name="ln64"> </a>
<a name="ln65">  return 0;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">struct pim_interface *pim_if_new(struct interface *ifp, int igmp, int pim)</a>
<a name="ln69">{</a>
<a name="ln70">  struct pim_interface *pim_ifp;</a>
<a name="ln71"> </a>
<a name="ln72">  zassert(ifp);</a>
<a name="ln73">  zassert(!ifp-&gt;info);</a>
<a name="ln74"> </a>
<a name="ln75">  pim_ifp = XMALLOC(MTYPE_PIM_INTERFACE, sizeof(*pim_ifp));</a>
<a name="ln76">  if (!pim_ifp) {</a>
<a name="ln77">    zlog_err(&quot;PIM XMALLOC(%zu) failure&quot;, sizeof(*pim_ifp));</a>
<a name="ln78">    return 0;</a>
<a name="ln79">  }</a>
<a name="ln80"> </a>
<a name="ln81">  pim_ifp-&gt;options                           = 0;</a>
<a name="ln82">  pim_ifp-&gt;mroute_vif_index                  = -1;</a>
<a name="ln83"> </a>
<a name="ln84">  pim_ifp-&gt;igmp_default_robustness_variable           = IGMP_DEFAULT_ROBUSTNESS_VARIABLE;</a>
<a name="ln85">  pim_ifp-&gt;igmp_default_query_interval                = IGMP_GENERAL_QUERY_INTERVAL;</a>
<a name="ln86">  pim_ifp-&gt;igmp_query_max_response_time_dsec          = IGMP_QUERY_MAX_RESPONSE_TIME_DSEC;</a>
<a name="ln87">  pim_ifp-&gt;igmp_specific_query_max_response_time_dsec = IGMP_SPECIFIC_QUERY_MAX_RESPONSE_TIME_DSEC;</a>
<a name="ln88"> </a>
<a name="ln89">  /*</a>
<a name="ln90">    RFC 3376: 8.3. Query Response Interval</a>
<a name="ln91">    The number of seconds represented by the [Query Response Interval]</a>
<a name="ln92">    must be less than the [Query Interval].</a>
<a name="ln93">   */</a>
<a name="ln94">  zassert(pim_ifp-&gt;igmp_query_max_response_time_dsec &lt; pim_ifp-&gt;igmp_default_query_interval);</a>
<a name="ln95"> </a>
<a name="ln96">  if (pim)</a>
<a name="ln97">    PIM_IF_DO_PIM(pim_ifp-&gt;options);</a>
<a name="ln98">  if (igmp)</a>
<a name="ln99">    PIM_IF_DO_IGMP(pim_ifp-&gt;options);</a>
<a name="ln100"> </a>
<a name="ln101">#if 0</a>
<a name="ln102">  /* FIXME: Should join? */</a>
<a name="ln103">  PIM_IF_DO_IGMP_LISTEN_ALLROUTERS(pim_ifp-&gt;options);</a>
<a name="ln104">#endif</a>
<a name="ln105"> </a>
<a name="ln106">  pim_ifp-&gt;igmp_join_list = 0;</a>
<a name="ln107">  pim_ifp-&gt;igmp_socket_list = 0;</a>
<a name="ln108">  pim_ifp-&gt;pim_neighbor_list = 0;</a>
<a name="ln109">  pim_ifp-&gt;pim_ifchannel_list = 0;</a>
<a name="ln110">  pim_ifp-&gt;pim_generation_id = 0;</a>
<a name="ln111"> </a>
<a name="ln112">  /* list of struct igmp_sock */</a>
<a name="ln113">  pim_ifp-&gt;igmp_socket_list = list_new();</a>
<a name="ln114">  if (!pim_ifp-&gt;igmp_socket_list) {</a>
<a name="ln115">    zlog_err(&quot;%s %s: failure: igmp_socket_list=list_new()&quot;,</a>
<a name="ln116">	     __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln117">    return if_list_clean(pim_ifp);</a>
<a name="ln118">  }</a>
<a name="ln119">  pim_ifp-&gt;igmp_socket_list-&gt;del = (void (*)(void *)) igmp_sock_free;</a>
<a name="ln120"> </a>
<a name="ln121">  /* list of struct pim_neighbor */</a>
<a name="ln122">  pim_ifp-&gt;pim_neighbor_list = list_new();</a>
<a name="ln123">  if (!pim_ifp-&gt;pim_neighbor_list) {</a>
<a name="ln124">    zlog_err(&quot;%s %s: failure: pim_neighbor_list=list_new()&quot;,</a>
<a name="ln125">	     __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln126">    return if_list_clean(pim_ifp);</a>
<a name="ln127">  }</a>
<a name="ln128">  pim_ifp-&gt;pim_neighbor_list-&gt;del = (void (*)(void *)) pim_neighbor_free;</a>
<a name="ln129"> </a>
<a name="ln130">  /* list of struct pim_ifchannel */</a>
<a name="ln131">  pim_ifp-&gt;pim_ifchannel_list = list_new();</a>
<a name="ln132">  if (!pim_ifp-&gt;pim_ifchannel_list) {</a>
<a name="ln133">    zlog_err(&quot;%s %s: failure: pim_ifchannel_list=list_new()&quot;,</a>
<a name="ln134">	     __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln135">    return if_list_clean(pim_ifp);</a>
<a name="ln136">  }</a>
<a name="ln137">  pim_ifp-&gt;pim_ifchannel_list-&gt;del = (void (*)(void *)) pim_ifchannel_free;</a>
<a name="ln138"> </a>
<a name="ln139">  ifp-&gt;info = pim_ifp;</a>
<a name="ln140"> </a>
<a name="ln141">  pim_sock_reset(ifp);</a>
<a name="ln142"> </a>
<a name="ln143">  zassert(PIM_IF_TEST_PIM(pim_ifp-&gt;options) || PIM_IF_TEST_IGMP(pim_ifp-&gt;options));</a>
<a name="ln144"> </a>
<a name="ln145">  if (PIM_MROUTE_IS_ENABLED) {</a>
<a name="ln146">    pim_if_add_vif(ifp);</a>
<a name="ln147">  }</a>
<a name="ln148"> </a>
<a name="ln149">  return pim_ifp;</a>
<a name="ln150">}</a>
<a name="ln151"> </a>
<a name="ln152">void pim_if_delete(struct interface *ifp)</a>
<a name="ln153">{</a>
<a name="ln154">  struct pim_interface *pim_ifp;</a>
<a name="ln155"> </a>
<a name="ln156">  zassert(ifp);</a>
<a name="ln157">  pim_ifp = ifp-&gt;info;</a>
<a name="ln158">  zassert(pim_ifp);</a>
<a name="ln159"> </a>
<a name="ln160">  if (pim_ifp-&gt;igmp_join_list) {</a>
<a name="ln161">    pim_if_igmp_join_del_all(ifp);</a>
<a name="ln162">  }</a>
<a name="ln163">  zassert(!pim_ifp-&gt;igmp_join_list);</a>
<a name="ln164"> </a>
<a name="ln165">  zassert(pim_ifp-&gt;igmp_socket_list);</a>
<a name="ln166">  zassert(!listcount(pim_ifp-&gt;igmp_socket_list));</a>
<a name="ln167"> </a>
<a name="ln168">  zassert(pim_ifp-&gt;pim_neighbor_list);</a>
<a name="ln169">  zassert(!listcount(pim_ifp-&gt;pim_neighbor_list));</a>
<a name="ln170"> </a>
<a name="ln171">  zassert(pim_ifp-&gt;pim_ifchannel_list);</a>
<a name="ln172">  zassert(!listcount(pim_ifp-&gt;pim_ifchannel_list));</a>
<a name="ln173"> </a>
<a name="ln174">  if (PIM_MROUTE_IS_ENABLED) {</a>
<a name="ln175">    pim_if_del_vif(ifp);</a>
<a name="ln176">  }</a>
<a name="ln177"> </a>
<a name="ln178">  list_delete(pim_ifp-&gt;igmp_socket_list);</a>
<a name="ln179">  list_delete(pim_ifp-&gt;pim_neighbor_list);</a>
<a name="ln180">  list_delete(pim_ifp-&gt;pim_ifchannel_list);</a>
<a name="ln181"> </a>
<a name="ln182">  XFREE(MTYPE_PIM_INTERFACE, pim_ifp);</a>
<a name="ln183"> </a>
<a name="ln184">  ifp-&gt;info = 0;</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">void pim_if_update_could_assert(struct interface *ifp)</a>
<a name="ln188">{</a>
<a name="ln189">  struct pim_interface *pim_ifp;</a>
<a name="ln190">  struct listnode      *node;</a>
<a name="ln191">  struct listnode      *next_node;</a>
<a name="ln192">  struct pim_ifchannel *ch;</a>
<a name="ln193"> </a>
<a name="ln194">  pim_ifp = ifp-&gt;info;</a>
<a name="ln195">  zassert(pim_ifp);</a>
<a name="ln196"> </a>
<a name="ln197">  for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, node, next_node, ch)) {</a>
<a name="ln198">    pim_ifchannel_update_could_assert(ch);</a>
<a name="ln199">  }</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">static void pim_if_update_my_assert_metric(struct interface *ifp)</a>
<a name="ln203">{</a>
<a name="ln204">  struct pim_interface *pim_ifp;</a>
<a name="ln205">  struct listnode      *node;</a>
<a name="ln206">  struct listnode      *next_node;</a>
<a name="ln207">  struct pim_ifchannel *ch;</a>
<a name="ln208"> </a>
<a name="ln209">  pim_ifp = ifp-&gt;info;</a>
<a name="ln210">  zassert(pim_ifp);</a>
<a name="ln211"> </a>
<a name="ln212">  for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, node, next_node, ch)) {</a>
<a name="ln213">    pim_ifchannel_update_my_assert_metric(ch);</a>
<a name="ln214">  }</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">static void pim_addr_change(struct interface *ifp)</a>
<a name="ln218">{</a>
<a name="ln219">  struct pim_interface *pim_ifp;</a>
<a name="ln220"> </a>
<a name="ln221">  pim_ifp = ifp-&gt;info;</a>
<a name="ln222">  zassert(pim_ifp);</a>
<a name="ln223"> </a>
<a name="ln224">  pim_if_dr_election(ifp); /* router's own DR Priority (addr) changes -- Done TODO T30 */</a>
<a name="ln225">  pim_if_update_join_desired(pim_ifp); /* depends on DR */</a>
<a name="ln226">  pim_if_update_could_assert(ifp); /* depends on DR */</a>
<a name="ln227">  pim_if_update_my_assert_metric(ifp); /* depends on could_assert */</a>
<a name="ln228">  pim_if_update_assert_tracking_desired(ifp); /* depends on DR, join_desired */</a>
<a name="ln229"> </a>
<a name="ln230">  /*</a>
<a name="ln231">    RFC 4601: 4.3.1.  Sending Hello Messages</a>
<a name="ln232"> </a>
<a name="ln233">    1) Before an interface goes down or changes primary IP address, a</a>
<a name="ln234">    Hello message with a zero HoldTime should be sent immediately</a>
<a name="ln235">    (with the old IP address if the IP address changed).</a>
<a name="ln236">    -- FIXME See CAVEAT C13</a>
<a name="ln237"> </a>
<a name="ln238">    2) After an interface has changed its IP address, it MUST send a</a>
<a name="ln239">    Hello message with its new IP address.</a>
<a name="ln240">    -- DONE below</a>
<a name="ln241"> </a>
<a name="ln242">    3) If an interface changes one of its secondary IP addresses, a</a>
<a name="ln243">    Hello message with an updated Address_List option and a non-zero</a>
<a name="ln244">    HoldTime should be sent immediately.</a>
<a name="ln245">    -- FIXME See TODO T31</a>
<a name="ln246">   */</a>
<a name="ln247">  pim_ifp-&gt;pim_ifstat_hello_sent = 0; /* reset hello counter */</a>
<a name="ln248">  if (pim_ifp-&gt;pim_sock_fd &lt; 0)</a>
<a name="ln249">    return;</a>
<a name="ln250">  pim_hello_restart_now(ifp);         /* send hello and restart timer */</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">static int detect_primary_address_change(struct interface *ifp,</a>
<a name="ln254">					 int force_prim_as_any,</a>
<a name="ln255">					 const char *caller)</a>
<a name="ln256">{</a>
<a name="ln257">  struct pim_interface *pim_ifp;</a>
<a name="ln258">  struct in_addr new_prim_addr;</a>
<a name="ln259">  int changed;</a>
<a name="ln260"> </a>
<a name="ln261">  pim_ifp = ifp-&gt;info;</a>
<a name="ln262">  if (!pim_ifp)</a>
<a name="ln263">    return 0;</a>
<a name="ln264"> </a>
<a name="ln265">  if (force_prim_as_any)</a>
<a name="ln266">    new_prim_addr = qpim_inaddr_any;</a>
<a name="ln267">  else</a>
<a name="ln268">    new_prim_addr = pim_find_primary_addr(ifp);</a>
<a name="ln269"> </a>
<a name="ln270">  changed = new_prim_addr.s_addr != pim_ifp-&gt;primary_address.s_addr;</a>
<a name="ln271"> </a>
<a name="ln272">  if (PIM_DEBUG_ZEBRA) {</a>
<a name="ln273">    char new_prim_str[100];</a>
<a name="ln274">    char old_prim_str[100];</a>
<a name="ln275">    pim_inet4_dump(&quot;&lt;new?&gt;&quot;, new_prim_addr, new_prim_str, sizeof(new_prim_str));</a>
<a name="ln276">    pim_inet4_dump(&quot;&lt;old?&gt;&quot;, pim_ifp-&gt;primary_address, old_prim_str, sizeof(old_prim_str));</a>
<a name="ln277">    zlog_debug(&quot;%s: old=%s new=%s on interface %s: %s&quot;,</a>
<a name="ln278">	       __PRETTY_FUNCTION__, </a>
<a name="ln279">	       old_prim_str, new_prim_str, ifp-&gt;name,</a>
<a name="ln280">	       changed ? &quot;changed&quot; : &quot;unchanged&quot;);</a>
<a name="ln281">  }</a>
<a name="ln282"> </a>
<a name="ln283">  if (changed) {</a>
<a name="ln284">    pim_ifp-&gt;primary_address = new_prim_addr;</a>
<a name="ln285"> </a>
<a name="ln286">    if (!PIM_IF_TEST_PIM(pim_ifp-&gt;options)) {</a>
<a name="ln287">      return changed;</a>
<a name="ln288">    }</a>
<a name="ln289"> </a>
<a name="ln290">    pim_addr_change(ifp);</a>
<a name="ln291">  }</a>
<a name="ln292"> </a>
<a name="ln293">  return changed;</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">static void detect_secondary_address_change(struct interface *ifp,</a>
<a name="ln297">					    const char *caller)</a>
<a name="ln298">{</a>
<a name="ln299">  struct pim_interface *pim_ifp;</a>
<a name="ln300">  int changed;</a>
<a name="ln301"> </a>
<a name="ln302">  pim_ifp = ifp-&gt;info;</a>
<a name="ln303">  if (!pim_ifp)</a>
<a name="ln304">    return;</a>
<a name="ln305"> </a>
<a name="ln306">  changed = 1; /* true */</a>
<a name="ln307">  if (PIM_DEBUG_ZEBRA)</a>
<a name="ln308">    zlog_debug(&quot;FIXME T31 C15 %s: on interface %s: acting on any addr change&quot;,</a>
<a name="ln309">	      __PRETTY_FUNCTION__, ifp-&gt;name);</a>
<a name="ln310"> </a>
<a name="ln311">  if (!changed) {</a>
<a name="ln312">    return;</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  if (!PIM_IF_TEST_PIM(pim_ifp-&gt;options)) {</a>
<a name="ln316">    return;</a>
<a name="ln317">  }</a>
<a name="ln318"> </a>
<a name="ln319">  pim_addr_change(ifp);</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">static void detect_address_change(struct interface *ifp,</a>
<a name="ln323">				 int force_prim_as_any,</a>
<a name="ln324">				 const char *caller)</a>
<a name="ln325">{</a>
<a name="ln326">  int prim_changed;</a>
<a name="ln327"> </a>
<a name="ln328">  prim_changed = detect_primary_address_change(ifp, force_prim_as_any, caller);</a>
<a name="ln329">  if (prim_changed) {</a>
<a name="ln330">    /* no need to detect secondary change because</a>
<a name="ln331">       the reaction would be the same */</a>
<a name="ln332">    return;</a>
<a name="ln333">  }</a>
<a name="ln334"> </a>
<a name="ln335">  detect_secondary_address_change(ifp, caller);</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">void pim_if_addr_add(struct connected *ifc)</a>
<a name="ln339">{</a>
<a name="ln340">  struct pim_interface *pim_ifp;</a>
<a name="ln341">  struct interface *ifp;</a>
<a name="ln342">  struct in_addr ifaddr;</a>
<a name="ln343"> </a>
<a name="ln344">  zassert(ifc);</a>
<a name="ln345"> </a>
<a name="ln346">  ifp = ifc-&gt;ifp;</a>
<a name="ln347">  zassert(ifp);</a>
<a name="ln348">  pim_ifp = ifp-&gt;info;</a>
<a name="ln349">  if (!pim_ifp)</a>
<a name="ln350">    return;</a>
<a name="ln351"> </a>
<a name="ln352">  if (!if_is_operative(ifp))</a>
<a name="ln353">    return;</a>
<a name="ln354"> </a>
<a name="ln355">  if (PIM_DEBUG_ZEBRA) {</a>
<a name="ln356">    char buf[BUFSIZ];</a>
<a name="ln357">    prefix2str(ifc-&gt;address, buf, BUFSIZ);</a>
<a name="ln358">    zlog_debug(&quot;%s: %s ifindex=%d connected IP address %s %s&quot;,</a>
<a name="ln359">	       __PRETTY_FUNCTION__,</a>
<a name="ln360">	       ifp-&gt;name, ifp-&gt;ifindex, buf,</a>
<a name="ln361">	       CHECK_FLAG(ifc-&gt;flags, ZEBRA_IFA_SECONDARY) ?</a>
<a name="ln362">	       &quot;secondary&quot; : &quot;primary&quot;);</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365">  ifaddr = ifc-&gt;address-&gt;u.prefix4;</a>
<a name="ln366"> </a>
<a name="ln367">  detect_address_change(ifp, 0, __PRETTY_FUNCTION__);</a>
<a name="ln368"> </a>
<a name="ln369">  if (PIM_IF_TEST_IGMP(pim_ifp-&gt;options)) {</a>
<a name="ln370">    struct igmp_sock *igmp;</a>
<a name="ln371"> </a>
<a name="ln372">    /* lookup IGMP socket */</a>
<a name="ln373">    igmp = pim_igmp_sock_lookup_ifaddr(pim_ifp-&gt;igmp_socket_list,</a>
<a name="ln374">				       ifaddr);</a>
<a name="ln375">    if (!igmp) {</a>
<a name="ln376">      /* if addr new, add IGMP socket */</a>
<a name="ln377">      pim_igmp_sock_add(pim_ifp-&gt;igmp_socket_list, ifaddr, ifp);</a>
<a name="ln378">    }</a>
<a name="ln379">  } /* igmp */</a>
<a name="ln380"> </a>
<a name="ln381">  if (PIM_IF_TEST_PIM(pim_ifp-&gt;options)) {</a>
<a name="ln382"> </a>
<a name="ln383">    /* Interface has a valid primary address ? */</a>
<a name="ln384">    if (PIM_INADDR_ISNOT_ANY(pim_ifp-&gt;primary_address)) {</a>
<a name="ln385"> </a>
<a name="ln386">      /* Interface has a valid socket ? */</a>
<a name="ln387">      if (pim_ifp-&gt;pim_sock_fd &lt; 0) {</a>
<a name="ln388">	if (pim_sock_add(ifp)) {</a>
<a name="ln389">	  zlog_warn(&quot;Failure creating PIM socket for interface %s&quot;,</a>
<a name="ln390">		    ifp-&gt;name);</a>
<a name="ln391">	}</a>
<a name="ln392">      }</a>
<a name="ln393"> </a>
<a name="ln394">    }</a>
<a name="ln395">  } /* pim */</a>
<a name="ln396"> </a>
<a name="ln397">  if (PIM_MROUTE_IS_ENABLED) {</a>
<a name="ln398">    /*</a>
<a name="ln399">      PIM or IGMP is enabled on interface, and there is at least one</a>
<a name="ln400">      address assigned, then try to create a vif_index.</a>
<a name="ln401">    */</a>
<a name="ln402">    if (pim_ifp-&gt;mroute_vif_index &lt; 0) {</a>
<a name="ln403">      pim_if_add_vif(ifp);</a>
<a name="ln404">    }</a>
<a name="ln405">  }</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">static void pim_if_addr_del_igmp(struct connected *ifc)</a>
<a name="ln409">{</a>
<a name="ln410">  struct pim_interface *pim_ifp = ifc-&gt;ifp-&gt;info;</a>
<a name="ln411">  struct igmp_sock *igmp;</a>
<a name="ln412">  struct in_addr ifaddr;</a>
<a name="ln413"> </a>
<a name="ln414">  if (ifc-&gt;address-&gt;family != AF_INET) {</a>
<a name="ln415">    /* non-IPv4 address */</a>
<a name="ln416">    return;</a>
<a name="ln417">  }</a>
<a name="ln418"> </a>
<a name="ln419">  if (!pim_ifp) {</a>
<a name="ln420">    /* IGMP not enabled on interface */</a>
<a name="ln421">    return;</a>
<a name="ln422">  }</a>
<a name="ln423"> </a>
<a name="ln424">  ifaddr = ifc-&gt;address-&gt;u.prefix4;</a>
<a name="ln425"> </a>
<a name="ln426">  /* lookup IGMP socket */</a>
<a name="ln427">  igmp = pim_igmp_sock_lookup_ifaddr(pim_ifp-&gt;igmp_socket_list,</a>
<a name="ln428">				     ifaddr);</a>
<a name="ln429">  if (igmp) {</a>
<a name="ln430">    /* if addr found, del IGMP socket */</a>
<a name="ln431">    igmp_sock_delete(igmp);</a>
<a name="ln432">  }</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">static void pim_if_addr_del_pim(struct connected *ifc)</a>
<a name="ln436">{</a>
<a name="ln437">  struct pim_interface *pim_ifp = ifc-&gt;ifp-&gt;info;</a>
<a name="ln438"> </a>
<a name="ln439">  if (ifc-&gt;address-&gt;family != AF_INET) {</a>
<a name="ln440">    /* non-IPv4 address */</a>
<a name="ln441">    return;</a>
<a name="ln442">  }</a>
<a name="ln443"> </a>
<a name="ln444">  if (!pim_ifp) {</a>
<a name="ln445">    /* PIM not enabled on interface */</a>
<a name="ln446">    return;</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449">  if (PIM_INADDR_ISNOT_ANY(pim_ifp-&gt;primary_address)) {</a>
<a name="ln450">    /* Interface keeps a valid primary address */</a>
<a name="ln451">    return;</a>
<a name="ln452">  }</a>
<a name="ln453"> </a>
<a name="ln454">  if (pim_ifp-&gt;pim_sock_fd &lt; 0) {</a>
<a name="ln455">    /* Interface does not hold a valid socket any longer */</a>
<a name="ln456">    return;</a>
<a name="ln457">  }</a>
<a name="ln458"> </a>
<a name="ln459">  /*</a>
<a name="ln460">    pim_sock_delete() closes the socket, stops read and timer threads,</a>
<a name="ln461">    and kills all neighbors.</a>
<a name="ln462">   */</a>
<a name="ln463">  pim_sock_delete(ifc-&gt;ifp, &quot;last address has been removed from interface&quot;);</a>
<a name="ln464">}</a>
<a name="ln465"> </a>
<a name="ln466">void pim_if_addr_del(struct connected *ifc, int force_prim_as_any)</a>
<a name="ln467">{</a>
<a name="ln468">  struct interface *ifp;</a>
<a name="ln469"> </a>
<a name="ln470">  zassert(ifc);</a>
<a name="ln471">  ifp = ifc-&gt;ifp;</a>
<a name="ln472">  zassert(ifp);</a>
<a name="ln473"> </a>
<a name="ln474">  if (PIM_DEBUG_ZEBRA) {</a>
<a name="ln475">    char buf[BUFSIZ];</a>
<a name="ln476">    prefix2str(ifc-&gt;address, buf, BUFSIZ);</a>
<a name="ln477">    zlog_debug(&quot;%s: %s ifindex=%d disconnected IP address %s %s&quot;,</a>
<a name="ln478">	       __PRETTY_FUNCTION__,</a>
<a name="ln479">	       ifp-&gt;name, ifp-&gt;ifindex, buf,</a>
<a name="ln480">	       CHECK_FLAG(ifc-&gt;flags, ZEBRA_IFA_SECONDARY) ?</a>
<a name="ln481">	       &quot;secondary&quot; : &quot;primary&quot;);</a>
<a name="ln482">  }</a>
<a name="ln483"> </a>
<a name="ln484">  detect_address_change(ifp, force_prim_as_any, __PRETTY_FUNCTION__);</a>
<a name="ln485"> </a>
<a name="ln486">  pim_if_addr_del_igmp(ifc);</a>
<a name="ln487">  pim_if_addr_del_pim(ifc);</a>
<a name="ln488">}</a>
<a name="ln489"> </a>
<a name="ln490">void pim_if_addr_add_all(struct interface *ifp)</a>
<a name="ln491">{</a>
<a name="ln492">  struct connected *ifc;</a>
<a name="ln493">  struct listnode *node;</a>
<a name="ln494">  struct listnode *nextnode;</a>
<a name="ln495"> </a>
<a name="ln496">  /* PIM/IGMP enabled ? */</a>
<a name="ln497">  if (!ifp-&gt;info)</a>
<a name="ln498">    return;</a>
<a name="ln499"> </a>
<a name="ln500">  for (ALL_LIST_ELEMENTS(ifp-&gt;connected, node, nextnode, ifc)) {</a>
<a name="ln501">    struct prefix *p = ifc-&gt;address;</a>
<a name="ln502">    </a>
<a name="ln503">    if (p-&gt;family != AF_INET)</a>
<a name="ln504">      continue;</a>
<a name="ln505"> </a>
<a name="ln506">    pim_if_addr_add(ifc);</a>
<a name="ln507">  }</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">void pim_if_addr_del_all(struct interface *ifp)</a>
<a name="ln511">{</a>
<a name="ln512">  struct connected *ifc;</a>
<a name="ln513">  struct listnode *node;</a>
<a name="ln514">  struct listnode *nextnode;</a>
<a name="ln515"> </a>
<a name="ln516">  /* PIM/IGMP enabled ? */</a>
<a name="ln517">  if (!ifp-&gt;info)</a>
<a name="ln518">    return;</a>
<a name="ln519"> </a>
<a name="ln520">  for (ALL_LIST_ELEMENTS(ifp-&gt;connected, node, nextnode, ifc)) {</a>
<a name="ln521">    struct prefix *p = ifc-&gt;address;</a>
<a name="ln522">    </a>
<a name="ln523">    if (p-&gt;family != AF_INET)</a>
<a name="ln524">      continue;</a>
<a name="ln525"> </a>
<a name="ln526">    pim_if_addr_del(ifc, 1 /* force_prim_as_any=true */);</a>
<a name="ln527">  }</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">void pim_if_addr_del_all_igmp(struct interface *ifp)</a>
<a name="ln531">{</a>
<a name="ln532">  struct connected *ifc;</a>
<a name="ln533">  struct listnode *node;</a>
<a name="ln534">  struct listnode *nextnode;</a>
<a name="ln535"> </a>
<a name="ln536">  /* PIM/IGMP enabled ? */</a>
<a name="ln537">  if (!ifp-&gt;info)</a>
<a name="ln538">    return;</a>
<a name="ln539"> </a>
<a name="ln540">  for (ALL_LIST_ELEMENTS(ifp-&gt;connected, node, nextnode, ifc)) {</a>
<a name="ln541">    struct prefix *p = ifc-&gt;address;</a>
<a name="ln542">    </a>
<a name="ln543">    if (p-&gt;family != AF_INET)</a>
<a name="ln544">      continue;</a>
<a name="ln545"> </a>
<a name="ln546">    pim_if_addr_del_igmp(ifc);</a>
<a name="ln547">  }</a>
<a name="ln548">}</a>
<a name="ln549"> </a>
<a name="ln550">void pim_if_addr_del_all_pim(struct interface *ifp)</a>
<a name="ln551">{</a>
<a name="ln552">  struct connected *ifc;</a>
<a name="ln553">  struct listnode *node;</a>
<a name="ln554">  struct listnode *nextnode;</a>
<a name="ln555"> </a>
<a name="ln556">  /* PIM/IGMP enabled ? */</a>
<a name="ln557">  if (!ifp-&gt;info)</a>
<a name="ln558">    return;</a>
<a name="ln559"> </a>
<a name="ln560">  for (ALL_LIST_ELEMENTS(ifp-&gt;connected, node, nextnode, ifc)) {</a>
<a name="ln561">    struct prefix *p = ifc-&gt;address;</a>
<a name="ln562">    </a>
<a name="ln563">    if (p-&gt;family != AF_INET)</a>
<a name="ln564">      continue;</a>
<a name="ln565"> </a>
<a name="ln566">    pim_if_addr_del_pim(ifc);</a>
<a name="ln567">  }</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570">static struct in_addr find_first_nonsec_addr(struct interface *ifp)</a>
<a name="ln571">{</a>
<a name="ln572">  struct connected *ifc;</a>
<a name="ln573">  struct listnode *node;</a>
<a name="ln574">  struct in_addr addr;</a>
<a name="ln575"> </a>
<a name="ln576">  for (ALL_LIST_ELEMENTS_RO(ifp-&gt;connected, node, ifc)) {</a>
<a name="ln577">    struct prefix *p = ifc-&gt;address;</a>
<a name="ln578">    </a>
<a name="ln579">    if (p-&gt;family != AF_INET)</a>
<a name="ln580">      continue;</a>
<a name="ln581"> </a>
<a name="ln582">    if (PIM_INADDR_IS_ANY(p-&gt;u.prefix4)) {</a>
<a name="ln583">      zlog_warn(&quot;%s: null IPv4 address connected to interface %s&quot;,</a>
<a name="ln584">		__PRETTY_FUNCTION__, ifp-&gt;name);</a>
<a name="ln585">      continue;</a>
<a name="ln586">    }</a>
<a name="ln587"> </a>
<a name="ln588">    if (CHECK_FLAG(ifc-&gt;flags, ZEBRA_IFA_SECONDARY))</a>
<a name="ln589">      continue;</a>
<a name="ln590"> </a>
<a name="ln591">    return p-&gt;u.prefix4;</a>
<a name="ln592">  }</a>
<a name="ln593"> </a>
<a name="ln594">  addr.s_addr = PIM_NET_INADDR_ANY;</a>
<a name="ln595"> </a>
<a name="ln596">  return addr;</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">struct in_addr pim_find_primary_addr(struct interface *ifp)</a>
<a name="ln600">{</a>
<a name="ln601">  return find_first_nonsec_addr(ifp);</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">/*</a>
<a name="ln605">  pim_if_add_vif() uses ifindex as vif_index</a>
<a name="ln606"> </a>
<a name="ln607">  see also pim_if_find_vifindex_by_ifindex()</a>
<a name="ln608"> */</a>
<a name="ln609">int pim_if_add_vif(struct interface *ifp)</a>
<a name="ln610">{</a>
<a name="ln611">  struct pim_interface *pim_ifp = ifp-&gt;info;</a>
<a name="ln612">  struct in_addr ifaddr;</a>
<a name="ln613"> </a>
<a name="ln614">  zassert(pim_ifp);</a>
<a name="ln615"> </a>
<a name="ln616">  if (pim_ifp-&gt;mroute_vif_index &gt; 0) {</a>
<a name="ln617">    zlog_warn(&quot;%s: vif_index=%d &gt; 0 on interface %s ifindex=%d&quot;,</a>
<a name="ln618">	      __PRETTY_FUNCTION__,</a>
<a name="ln619">	      pim_ifp-&gt;mroute_vif_index, ifp-&gt;name, ifp-&gt;ifindex);</a>
<a name="ln620">    return -1;</a>
<a name="ln621">  }</a>
<a name="ln622"> </a>
<a name="ln623">  if (ifp-&gt;ifindex &lt; 1) {</a>
<a name="ln624">    zlog_warn(&quot;%s: ifindex=%d &lt; 1 on interface %s&quot;,</a>
<a name="ln625">	      __PRETTY_FUNCTION__,</a>
<a name="ln626">	      ifp-&gt;ifindex, ifp-&gt;name);</a>
<a name="ln627">    return -2;</a>
<a name="ln628">  }</a>
<a name="ln629"> </a>
<a name="ln630">  if (ifp-&gt;ifindex &gt;= MAXVIFS) {</a>
<a name="ln631">    zlog_warn(&quot;%s: ifindex=%d &gt;= MAXVIFS=%d on interface %s&quot;,</a>
<a name="ln632">	      __PRETTY_FUNCTION__,</a>
<a name="ln633">	      ifp-&gt;ifindex, MAXVIFS, ifp-&gt;name);</a>
<a name="ln634">    return -3;</a>
<a name="ln635">  }</a>
<a name="ln636"> </a>
<a name="ln637">  ifaddr = pim_ifp-&gt;primary_address;</a>
<a name="ln638">  if (PIM_INADDR_IS_ANY(ifaddr)) {</a>
<a name="ln639">    zlog_warn(&quot;%s: could not get address for interface %s ifindex=%d&quot;,</a>
<a name="ln640">	      __PRETTY_FUNCTION__,</a>
<a name="ln641">	      ifp-&gt;name, ifp-&gt;ifindex);</a>
<a name="ln642">    return -4;</a>
<a name="ln643">  }</a>
<a name="ln644"> </a>
<a name="ln645">  if (pim_mroute_add_vif(ifp-&gt;ifindex, ifaddr)) {</a>
<a name="ln646">    /* pim_mroute_add_vif reported error */</a>
<a name="ln647">    return -5;</a>
<a name="ln648">  }</a>
<a name="ln649"> </a>
<a name="ln650">  pim_ifp-&gt;mroute_vif_index = ifp-&gt;ifindex;</a>
<a name="ln651"> </a>
<a name="ln652">  /*</a>
<a name="ln653">    Update highest vif_index</a>
<a name="ln654">   */</a>
<a name="ln655">  if (pim_ifp-&gt;mroute_vif_index &gt; qpim_mroute_oif_highest_vif_index) {</a>
<a name="ln656">    qpim_mroute_oif_highest_vif_index = pim_ifp-&gt;mroute_vif_index;</a>
<a name="ln657">  }</a>
<a name="ln658"> </a>
<a name="ln659">  return 0;</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">static int iflist_find_highest_vif_index()</a>
<a name="ln663">{</a>
<a name="ln664">  struct listnode      *ifnode;</a>
<a name="ln665">  struct interface     *ifp;</a>
<a name="ln666">  struct pim_interface *pim_ifp;</a>
<a name="ln667">  int                   highest_vif_index = -1;</a>
<a name="ln668"> </a>
<a name="ln669">  for (ALL_LIST_ELEMENTS_RO(iflist, ifnode, ifp)) {</a>
<a name="ln670">    pim_ifp = ifp-&gt;info;</a>
<a name="ln671">    if (!pim_ifp)</a>
<a name="ln672">      continue;</a>
<a name="ln673"> </a>
<a name="ln674">    if (pim_ifp-&gt;mroute_vif_index &gt; highest_vif_index) {</a>
<a name="ln675">      highest_vif_index = pim_ifp-&gt;mroute_vif_index;</a>
<a name="ln676">    }</a>
<a name="ln677">  }</a>
<a name="ln678"> </a>
<a name="ln679">  return highest_vif_index;</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">int pim_if_del_vif(struct interface *ifp)</a>
<a name="ln683">{</a>
<a name="ln684">  struct pim_interface *pim_ifp = ifp-&gt;info;</a>
<a name="ln685">  int old_vif_index;</a>
<a name="ln686"> </a>
<a name="ln687">  if (pim_ifp-&gt;mroute_vif_index &lt; 1) {</a>
<a name="ln688">    zlog_warn(&quot;%s: vif_index=%d &lt; 1 on interface %s ifindex=%d&quot;,</a>
<a name="ln689">	      __PRETTY_FUNCTION__,</a>
<a name="ln690">	      pim_ifp-&gt;mroute_vif_index, ifp-&gt;name, ifp-&gt;ifindex);</a>
<a name="ln691">    return -1;</a>
<a name="ln692">  }</a>
<a name="ln693"> </a>
<a name="ln694">  if (pim_mroute_del_vif(pim_ifp-&gt;mroute_vif_index)) {</a>
<a name="ln695">    /* pim_mroute_del_vif reported error */</a>
<a name="ln696">    return -2;</a>
<a name="ln697">  }</a>
<a name="ln698"> </a>
<a name="ln699">  /*</a>
<a name="ln700">    Update highest vif_index</a>
<a name="ln701">   */</a>
<a name="ln702"> </a>
<a name="ln703">  /* save old vif_index in order to compare with highest below */</a>
<a name="ln704">  old_vif_index = pim_ifp-&gt;mroute_vif_index;</a>
<a name="ln705"> </a>
<a name="ln706">  pim_ifp-&gt;mroute_vif_index = -1;</a>
<a name="ln707"> </a>
<a name="ln708">  if (old_vif_index == qpim_mroute_oif_highest_vif_index) {</a>
<a name="ln709">    qpim_mroute_oif_highest_vif_index = iflist_find_highest_vif_index();</a>
<a name="ln710">  }</a>
<a name="ln711"> </a>
<a name="ln712">  return 0;</a>
<a name="ln713">}</a>
<a name="ln714"> </a>
<a name="ln715">void pim_if_add_vif_all()</a>
<a name="ln716">{</a>
<a name="ln717">  struct listnode  *ifnode;</a>
<a name="ln718">  struct listnode  *ifnextnode;</a>
<a name="ln719">  struct interface *ifp;</a>
<a name="ln720"> </a>
<a name="ln721">  for (ALL_LIST_ELEMENTS(iflist, ifnode, ifnextnode, ifp)) {</a>
<a name="ln722">    if (!ifp-&gt;info)</a>
<a name="ln723">      continue;</a>
<a name="ln724"> </a>
<a name="ln725">    pim_if_add_vif(ifp);</a>
<a name="ln726">  }</a>
<a name="ln727">}</a>
<a name="ln728"> </a>
<a name="ln729">void pim_if_del_vif_all()</a>
<a name="ln730">{</a>
<a name="ln731">  struct listnode  *ifnode;</a>
<a name="ln732">  struct listnode  *ifnextnode;</a>
<a name="ln733">  struct interface *ifp;</a>
<a name="ln734"> </a>
<a name="ln735">  for (ALL_LIST_ELEMENTS(iflist, ifnode, ifnextnode, ifp)) {</a>
<a name="ln736">    if (!ifp-&gt;info)</a>
<a name="ln737">      continue;</a>
<a name="ln738"> </a>
<a name="ln739">    pim_if_del_vif(ifp);</a>
<a name="ln740">  }</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">struct interface *pim_if_find_by_vif_index(int vif_index)</a>
<a name="ln744">{</a>
<a name="ln745">  struct listnode  *ifnode;</a>
<a name="ln746">  struct interface *ifp;</a>
<a name="ln747"> </a>
<a name="ln748">  for (ALL_LIST_ELEMENTS_RO(iflist, ifnode, ifp)) {</a>
<a name="ln749">    if (ifp-&gt;info) {</a>
<a name="ln750">      struct pim_interface *pim_ifp;</a>
<a name="ln751">      pim_ifp = ifp-&gt;info;</a>
<a name="ln752">      if (vif_index == pim_ifp-&gt;mroute_vif_index)</a>
<a name="ln753">	return ifp;</a>
<a name="ln754">    }</a>
<a name="ln755">  }</a>
<a name="ln756"> </a>
<a name="ln757">  return 0;</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">/*</a>
<a name="ln761">  pim_if_add_vif() uses ifindex as vif_index</a>
<a name="ln762"> */</a>
<a name="ln763">int pim_if_find_vifindex_by_ifindex(ifindex_t ifindex)</a>
<a name="ln764">{</a>
<a name="ln765">  return ifindex;</a>
<a name="ln766">}</a>
<a name="ln767"> </a>
<a name="ln768">int pim_if_lan_delay_enabled(struct interface *ifp)</a>
<a name="ln769">{</a>
<a name="ln770">  struct pim_interface *pim_ifp;</a>
<a name="ln771"> </a>
<a name="ln772">  pim_ifp = ifp-&gt;info;</a>
<a name="ln773">  zassert(pim_ifp);</a>
<a name="ln774">  zassert(pim_ifp-&gt;pim_number_of_nonlandelay_neighbors &gt;= 0);</a>
<a name="ln775"> </a>
<a name="ln776">  return pim_ifp-&gt;pim_number_of_nonlandelay_neighbors == 0;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">uint16_t pim_if_effective_propagation_delay_msec(struct interface *ifp)</a>
<a name="ln780">{</a>
<a name="ln781">  if (pim_if_lan_delay_enabled(ifp)) {</a>
<a name="ln782">    struct pim_interface *pim_ifp;</a>
<a name="ln783">    pim_ifp = ifp-&gt;info;</a>
<a name="ln784">    return pim_ifp-&gt;pim_neighbors_highest_propagation_delay_msec;</a>
<a name="ln785">  }</a>
<a name="ln786">  else {</a>
<a name="ln787">    return PIM_DEFAULT_PROPAGATION_DELAY_MSEC;</a>
<a name="ln788">  }</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">uint16_t pim_if_effective_override_interval_msec(struct interface *ifp)</a>
<a name="ln792">{</a>
<a name="ln793">  if (pim_if_lan_delay_enabled(ifp)) {</a>
<a name="ln794">    struct pim_interface *pim_ifp;</a>
<a name="ln795">    pim_ifp = ifp-&gt;info;</a>
<a name="ln796">    return pim_ifp-&gt;pim_neighbors_highest_override_interval_msec;</a>
<a name="ln797">  }</a>
<a name="ln798">  else {</a>
<a name="ln799">    return PIM_DEFAULT_OVERRIDE_INTERVAL_MSEC;</a>
<a name="ln800">  }</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">int pim_if_t_override_msec(struct interface *ifp)</a>
<a name="ln804">{</a>
<a name="ln805">  int effective_override_interval_msec;</a>
<a name="ln806">  int t_override_msec;</a>
<a name="ln807"> </a>
<a name="ln808">  effective_override_interval_msec =</a>
<a name="ln809">    pim_if_effective_override_interval_msec(ifp);</a>
<a name="ln810"> </a>
<a name="ln811">  t_override_msec = random() % (effective_override_interval_msec + 1);</a>
<a name="ln812"> </a>
<a name="ln813">  return t_override_msec;</a>
<a name="ln814">}</a>
<a name="ln815"> </a>
<a name="ln816">uint16_t pim_if_jp_override_interval_msec(struct interface *ifp)</a>
<a name="ln817">{</a>
<a name="ln818">  return pim_if_effective_propagation_delay_msec(ifp) +</a>
<a name="ln819">    pim_if_effective_override_interval_msec(ifp);</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">/*</a>
<a name="ln823">  RFC 4601: 4.1.6.  State Summarization Macros</a>
<a name="ln824"> </a>
<a name="ln825">  The function NBR( I, A ) uses information gathered through PIM Hello</a>
<a name="ln826">  messages to map the IP address A of a directly connected PIM</a>
<a name="ln827">  neighbor router on interface I to the primary IP address of the same</a>
<a name="ln828">  router (Section 4.3.4).  The primary IP address of a neighbor is the</a>
<a name="ln829">  address that it uses as the source of its PIM Hello messages.</a>
<a name="ln830">*/</a>
<a name="ln831">struct pim_neighbor *pim_if_find_neighbor(struct interface *ifp,</a>
<a name="ln832">					  struct in_addr addr)</a>
<a name="ln833">{</a>
<a name="ln834">  struct listnode *neighnode;</a>
<a name="ln835">  struct pim_neighbor *neigh;</a>
<a name="ln836">  struct pim_interface *pim_ifp;</a>
<a name="ln837"> </a>
<a name="ln838">  zassert(ifp);</a>
<a name="ln839"> </a>
<a name="ln840">  pim_ifp = ifp-&gt;info;</a>
<a name="ln841">  if (!pim_ifp) {</a>
<a name="ln842">    zlog_warn(&quot;%s: multicast not enabled on interface %s&quot;,</a>
<a name="ln843">	      __PRETTY_FUNCTION__,</a>
<a name="ln844">	      ifp-&gt;name);</a>
<a name="ln845">    return 0;</a>
<a name="ln846">  }</a>
<a name="ln847"> </a>
<a name="ln848">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_neighbor_list, neighnode, neigh)) {</a>
<a name="ln849"> </a>
<a name="ln850">    /* primary address ? */</a>
<a name="ln851">    if (neigh-&gt;source_addr.s_addr == addr.s_addr)</a>
<a name="ln852">      return neigh;</a>
<a name="ln853"> </a>
<a name="ln854">    /* secondary address ? */</a>
<a name="ln855">    if (pim_neighbor_find_secondary(neigh, addr))</a>
<a name="ln856">	return neigh;</a>
<a name="ln857">  }</a>
<a name="ln858"> </a>
<a name="ln859">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln860">    char addr_str[100];</a>
<a name="ln861">    pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln862">    zlog_debug(&quot;%s: neighbor not found for address %s on interface %s&quot;,</a>
<a name="ln863">	       __PRETTY_FUNCTION__, </a>
<a name="ln864">	       addr_str, ifp-&gt;name);</a>
<a name="ln865">  }</a>
<a name="ln866"> </a>
<a name="ln867">  return 0;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">long pim_if_t_suppressed_msec(struct interface *ifp)</a>
<a name="ln871">{</a>
<a name="ln872">  struct pim_interface *pim_ifp;</a>
<a name="ln873">  long t_suppressed_msec;</a>
<a name="ln874">  uint32_t ramount = 0;</a>
<a name="ln875"> </a>
<a name="ln876">  pim_ifp = ifp-&gt;info;</a>
<a name="ln877">  zassert(pim_ifp);</a>
<a name="ln878"> </a>
<a name="ln879">  /* join suppression disabled ? */</a>
<a name="ln880">  if (PIM_IF_TEST_PIM_CAN_DISABLE_JOIN_SUPRESSION(pim_ifp-&gt;options))</a>
<a name="ln881">    return 0;</a>
<a name="ln882"> </a>
<a name="ln883">  /* t_suppressed = t_periodic * rand(1.1, 1.4) */</a>
<a name="ln884">  ramount = 1100 + (random() % (1400 - 1100 + 1));</a>
<a name="ln885">  t_suppressed_msec = qpim_t_periodic * ramount;</a>
<a name="ln886"> </a>
<a name="ln887">  return t_suppressed_msec;</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">static void igmp_join_free(struct igmp_join *ij)</a>
<a name="ln891">{</a>
<a name="ln892">  XFREE(MTYPE_PIM_IGMP_JOIN, ij);</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">static struct igmp_join *igmp_join_find(struct list *join_list,</a>
<a name="ln896">					struct in_addr group_addr,</a>
<a name="ln897">					struct in_addr source_addr)</a>
<a name="ln898">{</a>
<a name="ln899">  struct listnode *node;</a>
<a name="ln900">  struct igmp_join *ij;</a>
<a name="ln901"> </a>
<a name="ln902">  zassert(join_list);</a>
<a name="ln903"> </a>
<a name="ln904">  for (ALL_LIST_ELEMENTS_RO(join_list, node, ij)) {</a>
<a name="ln905">    if ((group_addr.s_addr == ij-&gt;group_addr.s_addr) &amp;&amp;</a>
<a name="ln906">	(source_addr.s_addr == ij-&gt;source_addr.s_addr))</a>
<a name="ln907">      return ij;</a>
<a name="ln908">  }</a>
<a name="ln909"> </a>
<a name="ln910">  return 0;</a>
<a name="ln911">}</a>
<a name="ln912"> </a>
<a name="ln913">static int igmp_join_sock(const char *ifname,</a>
<a name="ln914">			  ifindex_t ifindex,</a>
<a name="ln915">			  struct in_addr group_addr,</a>
<a name="ln916">			  struct in_addr source_addr)</a>
<a name="ln917">{</a>
<a name="ln918">  int join_fd;</a>
<a name="ln919"> </a>
<a name="ln920">  join_fd = pim_socket_raw(IPPROTO_IGMP);</a>
<a name="ln921">  if (join_fd &lt; 0) {</a>
<a name="ln922">    return -1;</a>
<a name="ln923">  }</a>
<a name="ln924"> </a>
<a name="ln925">  if (pim_socket_join_source(join_fd, ifindex, group_addr, source_addr, ifname)) {</a>
<a name="ln926">    close(join_fd);</a>
<a name="ln927">    return -2;</a>
<a name="ln928">  }</a>
<a name="ln929"> </a>
<a name="ln930">  return join_fd;</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">static struct igmp_join *igmp_join_new(struct interface *ifp,</a>
<a name="ln934">				       struct in_addr group_addr,</a>
<a name="ln935">				       struct in_addr source_addr)</a>
<a name="ln936">{</a>
<a name="ln937">  struct pim_interface *pim_ifp;</a>
<a name="ln938">  struct igmp_join *ij;</a>
<a name="ln939">  int join_fd;</a>
<a name="ln940"> </a>
<a name="ln941">  pim_ifp = ifp-&gt;info;</a>
<a name="ln942">  zassert(pim_ifp);</a>
<a name="ln943"> </a>
<a name="ln944">  join_fd = igmp_join_sock(ifp-&gt;name, ifp-&gt;ifindex, group_addr, source_addr);</a>
<a name="ln945">  if (join_fd &lt; 0) {</a>
<a name="ln946">    char group_str[100];</a>
<a name="ln947">    char source_str[100];</a>
<a name="ln948">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln949">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln950">    zlog_warn(&quot;%s: igmp_join_sock() failure for IGMP group %s source %s on interface %s&quot;,</a>
<a name="ln951">	      __PRETTY_FUNCTION__,</a>
<a name="ln952">	      group_str, source_str, ifp-&gt;name);</a>
<a name="ln953">    return 0;</a>
<a name="ln954">  }</a>
<a name="ln955"> </a>
<a name="ln956">  ij = XMALLOC(MTYPE_PIM_IGMP_JOIN, sizeof(*ij));</a>
<a name="ln957">  if (!ij) {</a>
<a name="ln958">    char group_str[100];</a>
<a name="ln959">    char source_str[100];</a>
<a name="ln960">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln961">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln962">    zlog_err(&quot;%s: XMALLOC(%zu) failure for IGMP group %s source %s on interface %s&quot;,</a>
<a name="ln963">	     __PRETTY_FUNCTION__,</a>
<a name="ln964">	     sizeof(*ij), group_str, source_str, ifp-&gt;name);</a>
<a name="ln965">    close(join_fd);</a>
<a name="ln966">    return 0;</a>
<a name="ln967">  }</a>
<a name="ln968"> </a>
<a name="ln969">  ij-&gt;sock_fd       = join_fd;</a>
<a name="ln970">  ij-&gt;group_addr    = group_addr;</a>
<a name="ln971">  ij-&gt;source_addr   = source_addr;</a>
<a name="ln972">  ij-&gt;sock_creation = pim_time_monotonic_sec();</a>
<a name="ln973"> </a>
<a name="ln974">  listnode_add(pim_ifp-&gt;igmp_join_list, ij);</a>
<a name="ln975"> </a>
<a name="ln976">  return ij;</a>
<a name="ln977">}</a>
<a name="ln978"> </a>
<a name="ln979">int pim_if_igmp_join_add(struct interface *ifp,</a>
<a name="ln980">			 struct in_addr group_addr,</a>
<a name="ln981">			 struct in_addr source_addr)</a>
<a name="ln982">{</a>
<a name="ln983">  struct pim_interface *pim_ifp;</a>
<a name="ln984">  struct igmp_join *ij;</a>
<a name="ln985"> </a>
<a name="ln986">  pim_ifp = ifp-&gt;info;</a>
<a name="ln987">  if (!pim_ifp) {</a>
<a name="ln988">    zlog_warn(&quot;%s: multicast not enabled on interface %s&quot;,</a>
<a name="ln989">	      __PRETTY_FUNCTION__, </a>
<a name="ln990">	      ifp-&gt;name);</a>
<a name="ln991">    return -1;</a>
<a name="ln992">  }</a>
<a name="ln993"> </a>
<a name="ln994">  if (!pim_ifp-&gt;igmp_join_list) {</a>
<a name="ln995">    pim_ifp-&gt;igmp_join_list = list_new();</a>
<a name="ln996">    if (!pim_ifp-&gt;igmp_join_list) {</a>
<a name="ln997">      zlog_err(&quot;%s %s: failure: igmp_join_list=list_new()&quot;,</a>
<a name="ln998">	       __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln999">      return -2;</a>
<a name="ln1000">    }</a>
<a name="ln1001">    pim_ifp-&gt;igmp_join_list-&gt;del = (void (*)(void *)) igmp_join_free;</a>
<a name="ln1002">  }</a>
<a name="ln1003"> </a>
<a name="ln1004">  ij = igmp_join_find(pim_ifp-&gt;igmp_join_list, group_addr, source_addr);</a>
<a name="ln1005">  if (ij) {</a>
<a name="ln1006">    char group_str[100];</a>
<a name="ln1007">    char source_str[100];</a>
<a name="ln1008">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln1009">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln1010">    zlog_warn(&quot;%s: can't re-join existing IGMP group %s source %s on interface %s&quot;,</a>
<a name="ln1011">	      __PRETTY_FUNCTION__,</a>
<a name="ln1012">	      group_str, source_str, ifp-&gt;name);</a>
<a name="ln1013">    return -3;</a>
<a name="ln1014">  }</a>
<a name="ln1015"> </a>
<a name="ln1016">  ij = igmp_join_new(ifp, group_addr, source_addr);</a>
<a name="ln1017">  if (!ij) {</a>
<a name="ln1018">    char group_str[100];</a>
<a name="ln1019">    char source_str[100];</a>
<a name="ln1020">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln1021">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln1022">    zlog_warn(&quot;%s: igmp_join_new() failure for IGMP group %s source %s on interface %s&quot;,</a>
<a name="ln1023">	      __PRETTY_FUNCTION__,</a>
<a name="ln1024">	      group_str, source_str, ifp-&gt;name);</a>
<a name="ln1025">    return -4;</a>
<a name="ln1026">  }</a>
<a name="ln1027"> </a>
<a name="ln1028">  if (PIM_DEBUG_IGMP_EVENTS) {</a>
<a name="ln1029">    char group_str[100];</a>
<a name="ln1030">    char source_str[100];</a>
<a name="ln1031">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln1032">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln1033">    zlog_debug(&quot;%s: issued static igmp join for channel (S,G)=(%s,%s) on interface %s&quot;,</a>
<a name="ln1034">	      __PRETTY_FUNCTION__,</a>
<a name="ln1035">	      source_str, group_str, ifp-&gt;name);</a>
<a name="ln1036">  }</a>
<a name="ln1037"> </a>
<a name="ln1038">  return 0;</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041"> </a>
<a name="ln1042"> </a>
<a name="ln1043">int pim_if_igmp_join_del(struct interface *ifp,</a>
<a name="ln1044">			 struct in_addr group_addr,</a>
<a name="ln1045">			 struct in_addr source_addr)</a>
<a name="ln1046">{</a>
<a name="ln1047">  struct pim_interface *pim_ifp;</a>
<a name="ln1048">  struct igmp_join *ij;</a>
<a name="ln1049"> </a>
<a name="ln1050">  pim_ifp = ifp-&gt;info;</a>
<a name="ln1051">  if (!pim_ifp) {</a>
<a name="ln1052">    zlog_warn(&quot;%s: multicast not enabled on interface %s&quot;,</a>
<a name="ln1053">	      __PRETTY_FUNCTION__, </a>
<a name="ln1054">	      ifp-&gt;name);</a>
<a name="ln1055">    return -1;</a>
<a name="ln1056">  }</a>
<a name="ln1057"> </a>
<a name="ln1058">  if (!pim_ifp-&gt;igmp_join_list) {</a>
<a name="ln1059">    zlog_warn(&quot;%s: no IGMP join on interface %s&quot;,</a>
<a name="ln1060">	      __PRETTY_FUNCTION__, </a>
<a name="ln1061">	      ifp-&gt;name);</a>
<a name="ln1062">    return -2;</a>
<a name="ln1063">  }</a>
<a name="ln1064"> </a>
<a name="ln1065">  ij = igmp_join_find(pim_ifp-&gt;igmp_join_list, group_addr, source_addr);</a>
<a name="ln1066">  if (!ij) {</a>
<a name="ln1067">    char group_str[100];</a>
<a name="ln1068">    char source_str[100];</a>
<a name="ln1069">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln1070">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln1071">    zlog_warn(&quot;%s: could not find IGMP group %s source %s on interface %s&quot;,</a>
<a name="ln1072">	      __PRETTY_FUNCTION__,</a>
<a name="ln1073">	      group_str, source_str, ifp-&gt;name);</a>
<a name="ln1074">    return -3;</a>
<a name="ln1075">  }</a>
<a name="ln1076"> </a>
<a name="ln1077">  if (close(ij-&gt;sock_fd)) {</a>
<a name="ln1078">    int e = errno;</a>
<a name="ln1079">    char group_str[100];</a>
<a name="ln1080">    char source_str[100];</a>
<a name="ln1081">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln1082">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln1083">    zlog_warn(&quot;%s: failure closing sock_fd=%d for IGMP group %s source %s on interface %s: errno=%d: %s&quot;,</a>
<a name="ln1084">	      __PRETTY_FUNCTION__,</a>
<a name="ln1085">	      ij-&gt;sock_fd, group_str, source_str, ifp-&gt;name, e, safe_strerror(e));</a>
<a name="ln1086">    /* warning only */</a>
<a name="ln1087">  }</a>
<a name="ln1088">  listnode_delete(pim_ifp-&gt;igmp_join_list, ij);</a>
<a name="ln1089">  igmp_join_free(ij);</a>
<a name="ln1090">  if (listcount(pim_ifp-&gt;igmp_join_list) &lt; 1) {</a>
<a name="ln1091">    list_delete(pim_ifp-&gt;igmp_join_list);</a>
<a name="ln1092">    pim_ifp-&gt;igmp_join_list = 0;</a>
<a name="ln1093">  }</a>
<a name="ln1094"> </a>
<a name="ln1095">  return 0;</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">static void pim_if_igmp_join_del_all(struct interface *ifp)</a>
<a name="ln1099">{</a>
<a name="ln1100">  struct pim_interface *pim_ifp;</a>
<a name="ln1101">  struct listnode *node;</a>
<a name="ln1102">  struct listnode *nextnode;</a>
<a name="ln1103">  struct igmp_join *ij;</a>
<a name="ln1104"> </a>
<a name="ln1105">  pim_ifp = ifp-&gt;info;</a>
<a name="ln1106">  if (!pim_ifp) {</a>
<a name="ln1107">    zlog_warn(&quot;%s: multicast not enabled on interface %s&quot;,</a>
<a name="ln1108">	      __PRETTY_FUNCTION__, </a>
<a name="ln1109">	      ifp-&gt;name);</a>
<a name="ln1110">    return;</a>
<a name="ln1111">  }</a>
<a name="ln1112"> </a>
<a name="ln1113">  if (!pim_ifp-&gt;igmp_join_list)</a>
<a name="ln1114">    return;</a>
<a name="ln1115"> </a>
<a name="ln1116">  for (ALL_LIST_ELEMENTS(pim_ifp-&gt;igmp_join_list, node, nextnode, ij))</a>
<a name="ln1117">    pim_if_igmp_join_del(ifp, ij-&gt;group_addr, ij-&gt;source_addr);</a>
<a name="ln1118">}</a>
<a name="ln1119"> </a>
<a name="ln1120">/*</a>
<a name="ln1121">  RFC 4601</a>
<a name="ln1122"> </a>
<a name="ln1123">  Transitions from &quot;I am Assert Loser&quot; State</a>
<a name="ln1124"> </a>
<a name="ln1125">  Current Winner's GenID Changes or NLT Expires</a>
<a name="ln1126"> </a>
<a name="ln1127">  The Neighbor Liveness Timer associated with the current winner</a>
<a name="ln1128">  expires or we receive a Hello message from the current winner</a>
<a name="ln1129">  reporting a different GenID from the one it previously reported.</a>
<a name="ln1130">  This indicates that the current winner's interface or router has</a>
<a name="ln1131">  gone down (and may have come back up), and so we must assume it no</a>
<a name="ln1132">  longer knows it was the winner.</a>
<a name="ln1133"> */</a>
<a name="ln1134">void pim_if_assert_on_neighbor_down(struct interface *ifp,</a>
<a name="ln1135">				    struct in_addr neigh_addr)</a>
<a name="ln1136">{</a>
<a name="ln1137">  struct pim_interface *pim_ifp;</a>
<a name="ln1138">  struct listnode      *node;</a>
<a name="ln1139">  struct listnode      *next_node;</a>
<a name="ln1140">  struct pim_ifchannel *ch;</a>
<a name="ln1141"> </a>
<a name="ln1142">  pim_ifp = ifp-&gt;info;</a>
<a name="ln1143">  zassert(pim_ifp);</a>
<a name="ln1144"> </a>
<a name="ln1145">  for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, node, next_node, ch)) {</a>
<a name="ln1146">    /* Is (S,G,I) assert loser ? */</a>
<a name="ln1147">    if (ch-&gt;ifassert_state != PIM_IFASSERT_I_AM_LOSER)</a>
<a name="ln1148">      continue;</a>
<a name="ln1149">    /* Dead neighbor was winner ? */</a>
<a name="ln1150">    if (ch-&gt;ifassert_winner.s_addr != neigh_addr.s_addr)</a>
<a name="ln1151">      continue;</a>
<a name="ln1152">    </a>
<a name="ln1153">    assert_action_a5(ch);</a>
<a name="ln1154">  }</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">void pim_if_update_join_desired(struct pim_interface *pim_ifp)</a>
<a name="ln1158">{</a>
<a name="ln1159">  struct listnode      *ch_node;</a>
<a name="ln1160">  struct pim_ifchannel *ch;</a>
<a name="ln1161"> </a>
<a name="ln1162">  /* clear off flag from interface's upstreams */</a>
<a name="ln1163">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_ifchannel_list, ch_node, ch)) {</a>
<a name="ln1164">    PIM_UPSTREAM_FLAG_UNSET_DR_JOIN_DESIRED_UPDATED(ch-&gt;upstream-&gt;flags);</a>
<a name="ln1165">  }</a>
<a name="ln1166"> </a>
<a name="ln1167">  /* scan per-interface (S,G,I) state on this I interface */</a>
<a name="ln1168">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_ifchannel_list, ch_node, ch)) {</a>
<a name="ln1169">    struct pim_upstream *up = ch-&gt;upstream;</a>
<a name="ln1170"> </a>
<a name="ln1171">    if (PIM_UPSTREAM_FLAG_TEST_DR_JOIN_DESIRED_UPDATED(up-&gt;flags))</a>
<a name="ln1172">      continue;</a>
<a name="ln1173"> </a>
<a name="ln1174">    /* update join_desired for the global (S,G) state */</a>
<a name="ln1175">    pim_upstream_update_join_desired(up);</a>
<a name="ln1176">    PIM_UPSTREAM_FLAG_SET_DR_JOIN_DESIRED_UPDATED(up-&gt;flags);</a>
<a name="ln1177">  }</a>
<a name="ln1178">}</a>
<a name="ln1179"> </a>
<a name="ln1180">void pim_if_update_assert_tracking_desired(struct interface *ifp)</a>
<a name="ln1181">{</a>
<a name="ln1182">  struct pim_interface *pim_ifp;</a>
<a name="ln1183">  struct listnode      *node;</a>
<a name="ln1184">  struct listnode      *next_node;</a>
<a name="ln1185">  struct pim_ifchannel *ch;</a>
<a name="ln1186"> </a>
<a name="ln1187">  pim_ifp = ifp-&gt;info;</a>
<a name="ln1188">  if (!pim_ifp)</a>
<a name="ln1189">    return;</a>
<a name="ln1190"> </a>
<a name="ln1191">  for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, node, next_node, ch)) {</a>
<a name="ln1192">    pim_ifchannel_update_assert_tracking_desired(ch);</a>
<a name="ln1193">  }</a>
<a name="ln1194">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="311"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!changed' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
