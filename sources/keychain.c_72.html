
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>keychain.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* key-chain for authentication.</a>
<a name="ln2">   Copyright (C) 2000 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln7">it under the terms of the GNU General Public License as published</a>
<a name="ln8">by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln9">option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln18">Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln19">Boston, MA 02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;command.h&quot;</a>
<a name="ln24">#include &quot;memory.h&quot;</a>
<a name="ln25">#include &quot;linklist.h&quot;</a>
<a name="ln26">#include &quot;keychain.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">/* Master list of key chain. */</a>
<a name="ln29">struct list *keychain_list;</a>
<a name="ln30"> </a>
<a name="ln31">static struct keychain *</a>
<a name="ln32">keychain_new (void)</a>
<a name="ln33">{</a>
<a name="ln34">  return XCALLOC (MTYPE_KEYCHAIN, sizeof (struct keychain));</a>
<a name="ln35">}</a>
<a name="ln36"> </a>
<a name="ln37">static void</a>
<a name="ln38">keychain_free (struct keychain *keychain)</a>
<a name="ln39">{</a>
<a name="ln40">  XFREE (MTYPE_KEYCHAIN, keychain);</a>
<a name="ln41">}</a>
<a name="ln42"> </a>
<a name="ln43">static struct key *</a>
<a name="ln44">key_new (void)</a>
<a name="ln45">{</a>
<a name="ln46">  return XCALLOC (MTYPE_KEY, sizeof (struct key));</a>
<a name="ln47">}</a>
<a name="ln48"> </a>
<a name="ln49">static void</a>
<a name="ln50">key_free (struct key *key)</a>
<a name="ln51">{</a>
<a name="ln52">  XFREE (MTYPE_KEY, key);</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">struct keychain *</a>
<a name="ln56">keychain_lookup (const char *name)</a>
<a name="ln57">{</a>
<a name="ln58">  struct listnode *node;</a>
<a name="ln59">  struct keychain *keychain;</a>
<a name="ln60"> </a>
<a name="ln61">  if (name == NULL)</a>
<a name="ln62">    return NULL;</a>
<a name="ln63"> </a>
<a name="ln64">  for (ALL_LIST_ELEMENTS_RO (keychain_list, node, keychain))</a>
<a name="ln65">    {</a>
<a name="ln66">      if (strcmp (keychain-&gt;name, name) == 0)</a>
<a name="ln67">	return keychain;</a>
<a name="ln68">    }</a>
<a name="ln69">  return NULL;</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">static int</a>
<a name="ln73">key_cmp_func (void *arg1, void *arg2)</a>
<a name="ln74">{</a>
<a name="ln75">  const struct key *k1 = arg1;</a>
<a name="ln76">  const struct key *k2 = arg2;</a>
<a name="ln77">  </a>
<a name="ln78">  if (k1-&gt;index &gt; k2-&gt;index)</a>
<a name="ln79">    return 1;</a>
<a name="ln80">  if (k1-&gt;index &lt; k2-&gt;index)</a>
<a name="ln81">    return -1;</a>
<a name="ln82">  return 0;</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">static void</a>
<a name="ln86">key_delete_func (struct key *key)</a>
<a name="ln87">{</a>
<a name="ln88">  if (key-&gt;string)</a>
<a name="ln89">    free (key-&gt;string);</a>
<a name="ln90">  key_free (key);</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">static struct keychain *</a>
<a name="ln94">keychain_get (const char *name)</a>
<a name="ln95">{</a>
<a name="ln96">  struct keychain *keychain;</a>
<a name="ln97"> </a>
<a name="ln98">  keychain = keychain_lookup (name);</a>
<a name="ln99"> </a>
<a name="ln100">  if (keychain)</a>
<a name="ln101">    return keychain;</a>
<a name="ln102"> </a>
<a name="ln103">  keychain = keychain_new ();</a>
<a name="ln104">  keychain-&gt;name = strdup (name);</a>
<a name="ln105">  keychain-&gt;key = list_new ();</a>
<a name="ln106">  keychain-&gt;key-&gt;cmp = (int (*)(void *, void *)) key_cmp_func;</a>
<a name="ln107">  keychain-&gt;key-&gt;del = (void (*)(void *)) key_delete_func;</a>
<a name="ln108">  listnode_add (keychain_list, keychain);</a>
<a name="ln109"> </a>
<a name="ln110">  return keychain;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">static void</a>
<a name="ln114">keychain_delete (struct keychain *keychain)</a>
<a name="ln115">{</a>
<a name="ln116">  if (keychain-&gt;name)</a>
<a name="ln117">    free (keychain-&gt;name);</a>
<a name="ln118"> </a>
<a name="ln119">  list_delete (keychain-&gt;key);</a>
<a name="ln120">  listnode_delete (keychain_list, keychain);</a>
<a name="ln121">  keychain_free (keychain);</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">static struct key *</a>
<a name="ln125">key_lookup (const struct keychain *keychain, u_int32_t index)</a>
<a name="ln126">{</a>
<a name="ln127">  struct listnode *node;</a>
<a name="ln128">  struct key *key;</a>
<a name="ln129"> </a>
<a name="ln130">  for (ALL_LIST_ELEMENTS_RO (keychain-&gt;key, node, key))</a>
<a name="ln131">    {</a>
<a name="ln132">      if (key-&gt;index == index)</a>
<a name="ln133">	return key;</a>
<a name="ln134">    }</a>
<a name="ln135">  return NULL;</a>
<a name="ln136">}</a>
<a name="ln137"> </a>
<a name="ln138">struct key *</a>
<a name="ln139">key_lookup_for_accept (const struct keychain *keychain, u_int32_t index)</a>
<a name="ln140">{</a>
<a name="ln141">  struct listnode *node;</a>
<a name="ln142">  struct key *key;</a>
<a name="ln143">  time_t now;</a>
<a name="ln144"> </a>
<a name="ln145">  now = time (NULL);</a>
<a name="ln146"> </a>
<a name="ln147">  for (ALL_LIST_ELEMENTS_RO (keychain-&gt;key, node, key))</a>
<a name="ln148">    {</a>
<a name="ln149">      if (key-&gt;index &gt;= index)</a>
<a name="ln150">	{</a>
<a name="ln151">	  if (key-&gt;accept.start == 0)</a>
<a name="ln152">	    return key;</a>
<a name="ln153"> </a>
<a name="ln154">	  if (key-&gt;accept.start &lt;= now)</a>
<a name="ln155">	    if (key-&gt;accept.end &gt;= now || key-&gt;accept.end == -1)</a>
<a name="ln156">	      return key;</a>
<a name="ln157">	}</a>
<a name="ln158">    }</a>
<a name="ln159">  return NULL;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">struct key *</a>
<a name="ln163">key_match_for_accept (const struct keychain *keychain, const char *auth_str)</a>
<a name="ln164">{</a>
<a name="ln165">  struct listnode *node;</a>
<a name="ln166">  struct key *key;</a>
<a name="ln167">  time_t now;</a>
<a name="ln168"> </a>
<a name="ln169">  now = time (NULL);</a>
<a name="ln170"> </a>
<a name="ln171">  for (ALL_LIST_ELEMENTS_RO (keychain-&gt;key, node, key))</a>
<a name="ln172">    {</a>
<a name="ln173">      if (key-&gt;accept.start == 0 ||</a>
<a name="ln174">	  (key-&gt;accept.start &lt;= now &amp;&amp;</a>
<a name="ln175">	   (key-&gt;accept.end &gt;= now || key-&gt;accept.end == -1)))</a>
<a name="ln176">	if (strncmp (key-&gt;string, auth_str, 16) == 0)</a>
<a name="ln177">	  return key;</a>
<a name="ln178">    }</a>
<a name="ln179">  return NULL;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">struct key *</a>
<a name="ln183">key_lookup_for_send (const struct keychain *keychain)</a>
<a name="ln184">{</a>
<a name="ln185">  struct listnode *node;</a>
<a name="ln186">  struct key *key;</a>
<a name="ln187">  time_t now;</a>
<a name="ln188"> </a>
<a name="ln189">  now = time (NULL);</a>
<a name="ln190"> </a>
<a name="ln191">  for (ALL_LIST_ELEMENTS_RO (keychain-&gt;key, node, key))</a>
<a name="ln192">    {</a>
<a name="ln193">      if (key-&gt;send.start == 0)</a>
<a name="ln194">	return key;</a>
<a name="ln195"> </a>
<a name="ln196">      if (key-&gt;send.start &lt;= now)</a>
<a name="ln197">	if (key-&gt;send.end &gt;= now || key-&gt;send.end == -1)</a>
<a name="ln198">	  return key;</a>
<a name="ln199">    }</a>
<a name="ln200">  return NULL;</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">static struct key *</a>
<a name="ln204">key_get (const struct keychain *keychain, u_int32_t index)</a>
<a name="ln205">{</a>
<a name="ln206">  struct key *key;</a>
<a name="ln207"> </a>
<a name="ln208">  key = key_lookup (keychain, index);</a>
<a name="ln209"> </a>
<a name="ln210">  if (key)</a>
<a name="ln211">    return key;</a>
<a name="ln212"> </a>
<a name="ln213">  key = key_new ();</a>
<a name="ln214">  key-&gt;index = index;</a>
<a name="ln215">  listnode_add_sort (keychain-&gt;key, key);</a>
<a name="ln216"> </a>
<a name="ln217">  return key;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">static void</a>
<a name="ln221">key_delete (struct keychain *keychain, struct key *key)</a>
<a name="ln222">{</a>
<a name="ln223">  listnode_delete (keychain-&gt;key, key);</a>
<a name="ln224"> </a>
<a name="ln225">  if (key-&gt;string)</a>
<a name="ln226">    free (key-&gt;string);</a>
<a name="ln227">  key_free (key);</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">DEFUN (key_chain,</a>
<a name="ln231">       key_chain_cmd,</a>
<a name="ln232">       &quot;key chain WORD&quot;,</a>
<a name="ln233">       &quot;Authentication key management\n&quot;</a>
<a name="ln234">       &quot;Key-chain management\n&quot;</a>
<a name="ln235">       &quot;Key-chain name\n&quot;)</a>
<a name="ln236">{</a>
<a name="ln237">  struct keychain *keychain;</a>
<a name="ln238"> </a>
<a name="ln239">  keychain = keychain_get (argv[0]);</a>
<a name="ln240">  vty-&gt;index = keychain;</a>
<a name="ln241">  vty-&gt;node = KEYCHAIN_NODE;</a>
<a name="ln242"> </a>
<a name="ln243">  return CMD_SUCCESS;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">DEFUN (no_key_chain,</a>
<a name="ln247">       no_key_chain_cmd,</a>
<a name="ln248">       &quot;no key chain WORD&quot;,</a>
<a name="ln249">       NO_STR</a>
<a name="ln250">       &quot;Authentication key management\n&quot;</a>
<a name="ln251">       &quot;Key-chain management\n&quot;</a>
<a name="ln252">       &quot;Key-chain name\n&quot;)</a>
<a name="ln253">{</a>
<a name="ln254">  struct keychain *keychain;</a>
<a name="ln255"> </a>
<a name="ln256">  keychain = keychain_lookup (argv[0]);</a>
<a name="ln257"> </a>
<a name="ln258">  if (! keychain)</a>
<a name="ln259">    {</a>
<a name="ln260">      vty_out (vty, &quot;Can't find keychain %s%s&quot;, argv[0], VTY_NEWLINE);</a>
<a name="ln261">      return CMD_WARNING;</a>
<a name="ln262">    }</a>
<a name="ln263"> </a>
<a name="ln264">  keychain_delete (keychain);</a>
<a name="ln265"> </a>
<a name="ln266">  return CMD_SUCCESS;</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">DEFUN (key,</a>
<a name="ln270">       key_cmd,</a>
<a name="ln271">       &quot;key &lt;0-2147483647&gt;&quot;,</a>
<a name="ln272">       &quot;Configure a key\n&quot;</a>
<a name="ln273">       &quot;Key identifier number\n&quot;)</a>
<a name="ln274">{</a>
<a name="ln275">  struct keychain *keychain;</a>
<a name="ln276">  struct key *key;</a>
<a name="ln277">  u_int32_t index;</a>
<a name="ln278"> </a>
<a name="ln279">  keychain = vty-&gt;index;</a>
<a name="ln280"> </a>
<a name="ln281">  VTY_GET_INTEGER (&quot;key identifier&quot;, index, argv[0]);</a>
<a name="ln282">  key = key_get (keychain, index);</a>
<a name="ln283">  vty-&gt;index_sub = key;</a>
<a name="ln284">  vty-&gt;node = KEYCHAIN_KEY_NODE;</a>
<a name="ln285">  </a>
<a name="ln286">  return CMD_SUCCESS;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">DEFUN (no_key,</a>
<a name="ln290">       no_key_cmd,</a>
<a name="ln291">       &quot;no key &lt;0-2147483647&gt;&quot;,</a>
<a name="ln292">       NO_STR</a>
<a name="ln293">       &quot;Delete a key\n&quot;</a>
<a name="ln294">       &quot;Key identifier number\n&quot;)</a>
<a name="ln295">{</a>
<a name="ln296">  struct keychain *keychain;</a>
<a name="ln297">  struct key *key;</a>
<a name="ln298">  u_int32_t index;</a>
<a name="ln299">  </a>
<a name="ln300">  keychain = vty-&gt;index;</a>
<a name="ln301"> </a>
<a name="ln302">  VTY_GET_INTEGER (&quot;key identifier&quot;, index, argv[0]);</a>
<a name="ln303">  key = key_lookup (keychain, index);</a>
<a name="ln304">  if (! key)</a>
<a name="ln305">    {</a>
<a name="ln306">      vty_out (vty, &quot;Can't find key %d%s&quot;, index, VTY_NEWLINE);</a>
<a name="ln307">      return CMD_WARNING;</a>
<a name="ln308">    }</a>
<a name="ln309"> </a>
<a name="ln310">  key_delete (keychain, key);</a>
<a name="ln311"> </a>
<a name="ln312">  vty-&gt;node = KEYCHAIN_NODE;</a>
<a name="ln313"> </a>
<a name="ln314">  return CMD_SUCCESS;</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">DEFUN (key_string,</a>
<a name="ln318">       key_string_cmd,</a>
<a name="ln319">       &quot;key-string LINE&quot;,</a>
<a name="ln320">       &quot;Set key string\n&quot;</a>
<a name="ln321">       &quot;The key\n&quot;)</a>
<a name="ln322">{</a>
<a name="ln323">  struct key *key;</a>
<a name="ln324"> </a>
<a name="ln325">  key = vty-&gt;index_sub;</a>
<a name="ln326"> </a>
<a name="ln327">  if (key-&gt;string)</a>
<a name="ln328">    free (key-&gt;string);</a>
<a name="ln329">  key-&gt;string = strdup (argv[0]);</a>
<a name="ln330"> </a>
<a name="ln331">  return CMD_SUCCESS;</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">DEFUN (no_key_string,</a>
<a name="ln335">       no_key_string_cmd,</a>
<a name="ln336">       &quot;no key-string [LINE]&quot;,</a>
<a name="ln337">       NO_STR</a>
<a name="ln338">       &quot;Unset key string\n&quot;</a>
<a name="ln339">       &quot;The key\n&quot;)</a>
<a name="ln340">{</a>
<a name="ln341">  struct key *key;</a>
<a name="ln342"> </a>
<a name="ln343">  key = vty-&gt;index_sub;</a>
<a name="ln344"> </a>
<a name="ln345">  if (key-&gt;string)</a>
<a name="ln346">    {</a>
<a name="ln347">      free (key-&gt;string);</a>
<a name="ln348">      key-&gt;string = NULL;</a>
<a name="ln349">    }</a>
<a name="ln350"> </a>
<a name="ln351">  return CMD_SUCCESS;</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">/* Convert HH:MM:SS MON DAY YEAR to time_t value.  -1 is returned when</a>
<a name="ln355">   given string is malformed. */</a>
<a name="ln356">static time_t </a>
<a name="ln357">key_str2time (const char *time_str, const char *day_str, const char *month_str,</a>
<a name="ln358">	      const char *year_str)</a>
<a name="ln359">{</a>
<a name="ln360">  int i = 0;</a>
<a name="ln361">  char *colon;</a>
<a name="ln362">  struct tm tm;</a>
<a name="ln363">  time_t time;</a>
<a name="ln364">  unsigned int sec, min, hour;</a>
<a name="ln365">  unsigned int day, month, year;</a>
<a name="ln366"> </a>
<a name="ln367">  const char *month_name[] = </a>
<a name="ln368">  {</a>
<a name="ln369">    &quot;January&quot;,</a>
<a name="ln370">    &quot;February&quot;,</a>
<a name="ln371">    &quot;March&quot;,</a>
<a name="ln372">    &quot;April&quot;,</a>
<a name="ln373">    &quot;May&quot;,</a>
<a name="ln374">    &quot;June&quot;,</a>
<a name="ln375">    &quot;July&quot;,</a>
<a name="ln376">    &quot;August&quot;,</a>
<a name="ln377">    &quot;September&quot;,</a>
<a name="ln378">    &quot;October&quot;,</a>
<a name="ln379">    &quot;November&quot;,</a>
<a name="ln380">    &quot;December&quot;,</a>
<a name="ln381">    NULL</a>
<a name="ln382">  };</a>
<a name="ln383"> </a>
<a name="ln384">#define _GET_LONG_RANGE(V,STR,MMCOND) \</a>
<a name="ln385">{ \</a>
<a name="ln386">  unsigned long tmpl; \</a>
<a name="ln387">  char *endptr = NULL; \</a>
<a name="ln388">  tmpl = strtoul ((STR), &amp;endptr, 10); \</a>
<a name="ln389">  if (*endptr != '\0' || tmpl == ULONG_MAX) \</a>
<a name="ln390">    return -1; \</a>
<a name="ln391">  if (MMCOND) \</a>
<a name="ln392">    return -1; \</a>
<a name="ln393">  (V) = tmpl; \</a>
<a name="ln394">}</a>
<a name="ln395">#define GET_LONG_RANGE(V,STR,MIN,MAX) \</a>
<a name="ln396">        _GET_LONG_RANGE(V,STR,tmpl &lt; (MIN) || tmpl &gt; (MAX))</a>
<a name="ln397">#define GET_LONG_RANGE0(V,STR,MAX) \</a>
<a name="ln398">        _GET_LONG_RANGE(V,STR,tmpl &gt; (MAX))</a>
<a name="ln399"> </a>
<a name="ln400">  /* Check hour field of time_str. */</a>
<a name="ln401">  colon = strchr (time_str, ':');</a>
<a name="ln402">  if (colon == NULL)</a>
<a name="ln403">    return -1;</a>
<a name="ln404">  *colon = '\0';</a>
<a name="ln405"> </a>
<a name="ln406">  /* Hour must be between 0 and 23. */</a>
<a name="ln407">  GET_LONG_RANGE0 (hour, time_str, 23);</a>
<a name="ln408"> </a>
<a name="ln409">  /* Check min field of time_str. */</a>
<a name="ln410">  time_str = colon + 1;</a>
<a name="ln411">  colon = strchr (time_str, ':');</a>
<a name="ln412">  if (*time_str == '\0' || colon == NULL)</a>
<a name="ln413">    return -1;</a>
<a name="ln414">  *colon = '\0';</a>
<a name="ln415"> </a>
<a name="ln416">  /* Min must be between 0 and 59. */</a>
<a name="ln417">  GET_LONG_RANGE0 (min, time_str, 59);</a>
<a name="ln418"> </a>
<a name="ln419">  /* Check sec field of time_str. */</a>
<a name="ln420">  time_str = colon + 1;</a>
<a name="ln421">  if (*time_str == '\0')</a>
<a name="ln422">    return -1;</a>
<a name="ln423">  </a>
<a name="ln424">  /* Sec must be between 0 and 59. */</a>
<a name="ln425">  GET_LONG_RANGE0 (sec, time_str, 59);</a>
<a name="ln426">  </a>
<a name="ln427">  /* Check day_str.  Day must be &lt;1-31&gt;. */</a>
<a name="ln428">  GET_LONG_RANGE (day, day_str, 1, 31);</a>
<a name="ln429"> </a>
<a name="ln430">  /* Check month_str.  Month must match month_name. */</a>
<a name="ln431">  month = 0;</a>
<a name="ln432">  if (strlen (month_str) &gt;= 3)</a>
<a name="ln433">    for (i = 0; month_name[i]; i++)</a>
<a name="ln434">      if (strncmp (month_str, month_name[i], strlen (month_str)) == 0)</a>
<a name="ln435">	{</a>
<a name="ln436">	  month = i;</a>
<a name="ln437">	  break;</a>
<a name="ln438">	}</a>
<a name="ln439">  if (! month_name[i])</a>
<a name="ln440">    return -1;</a>
<a name="ln441"> </a>
<a name="ln442">  /* Check year_str.  Year must be &lt;1993-2035&gt;. */</a>
<a name="ln443">  GET_LONG_RANGE (year, year_str, 1993, 2035);</a>
<a name="ln444">  </a>
<a name="ln445">  memset (&amp;tm, 0, sizeof (struct tm));</a>
<a name="ln446">  tm.tm_sec = sec;</a>
<a name="ln447">  tm.tm_min = min;</a>
<a name="ln448">  tm.tm_hour = hour;</a>
<a name="ln449">  tm.tm_mon = month;</a>
<a name="ln450">  tm.tm_mday = day;</a>
<a name="ln451">  tm.tm_year = year - 1900;</a>
<a name="ln452">    </a>
<a name="ln453">  time = mktime (&amp;tm);</a>
<a name="ln454">  </a>
<a name="ln455">  return time;</a>
<a name="ln456">#undef GET_LONG_RANGE</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">static int</a>
<a name="ln460">key_lifetime_set (struct vty *vty, struct key_range *krange,</a>
<a name="ln461">		  const char *stime_str, const char *sday_str,</a>
<a name="ln462">		  const char *smonth_str, const char *syear_str,</a>
<a name="ln463">		  const char *etime_str, const char *eday_str,</a>
<a name="ln464">		  const char *emonth_str, const char *eyear_str)</a>
<a name="ln465">{</a>
<a name="ln466">  time_t time_start;</a>
<a name="ln467">  time_t time_end;</a>
<a name="ln468">  </a>
<a name="ln469">  time_start = key_str2time (stime_str, sday_str, smonth_str, syear_str);</a>
<a name="ln470">  if (time_start &lt; 0)</a>
<a name="ln471">    {</a>
<a name="ln472">      vty_out (vty, &quot;Malformed time value%s&quot;, VTY_NEWLINE);</a>
<a name="ln473">      return CMD_WARNING;</a>
<a name="ln474">    }</a>
<a name="ln475">  time_end = key_str2time (etime_str, eday_str, emonth_str, eyear_str);</a>
<a name="ln476"> </a>
<a name="ln477">  if (time_end &lt; 0)</a>
<a name="ln478">    {</a>
<a name="ln479">      vty_out (vty, &quot;Malformed time value%s&quot;, VTY_NEWLINE);</a>
<a name="ln480">      return CMD_WARNING;</a>
<a name="ln481">    }</a>
<a name="ln482"> </a>
<a name="ln483">  if (time_end &lt;= time_start)</a>
<a name="ln484">    {</a>
<a name="ln485">      vty_out (vty, &quot;Expire time is not later than start time%s&quot;, VTY_NEWLINE);</a>
<a name="ln486">      return CMD_WARNING;</a>
<a name="ln487">    }</a>
<a name="ln488"> </a>
<a name="ln489">  krange-&gt;start = time_start;</a>
<a name="ln490">  krange-&gt;end = time_end;</a>
<a name="ln491"> </a>
<a name="ln492">  return CMD_SUCCESS;</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">static int</a>
<a name="ln496">key_lifetime_duration_set (struct vty *vty, struct key_range *krange,</a>
<a name="ln497">			   const char *stime_str, const char *sday_str,</a>
<a name="ln498">			   const char *smonth_str, const char *syear_str,</a>
<a name="ln499">			   const char *duration_str)</a>
<a name="ln500">{</a>
<a name="ln501">  time_t time_start;</a>
<a name="ln502">  u_int32_t duration;</a>
<a name="ln503">    </a>
<a name="ln504">  time_start = key_str2time (stime_str, sday_str, smonth_str, syear_str);</a>
<a name="ln505">  if (time_start &lt; 0)</a>
<a name="ln506">    {</a>
<a name="ln507">      vty_out (vty, &quot;Malformed time value%s&quot;, VTY_NEWLINE);</a>
<a name="ln508">      return CMD_WARNING;</a>
<a name="ln509">    }</a>
<a name="ln510">  krange-&gt;start = time_start;</a>
<a name="ln511"> </a>
<a name="ln512">  VTY_GET_INTEGER (&quot;duration&quot;, duration, duration_str);</a>
<a name="ln513">  krange-&gt;duration = 1;</a>
<a name="ln514">  krange-&gt;end = time_start + duration;</a>
<a name="ln515"> </a>
<a name="ln516">  return CMD_SUCCESS;</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">static int</a>
<a name="ln520">key_lifetime_infinite_set (struct vty *vty, struct key_range *krange,</a>
<a name="ln521">			   const char *stime_str, const char *sday_str,</a>
<a name="ln522">			   const char *smonth_str, const char *syear_str)</a>
<a name="ln523">{</a>
<a name="ln524">  time_t time_start;</a>
<a name="ln525">    </a>
<a name="ln526">  time_start = key_str2time (stime_str, sday_str, smonth_str, syear_str);</a>
<a name="ln527">  if (time_start &lt; 0)</a>
<a name="ln528">    {</a>
<a name="ln529">      vty_out (vty, &quot;Malformed time value%s&quot;, VTY_NEWLINE);</a>
<a name="ln530">      return CMD_WARNING;</a>
<a name="ln531">    }</a>
<a name="ln532">  krange-&gt;start = time_start;</a>
<a name="ln533"> </a>
<a name="ln534">  krange-&gt;end = -1;</a>
<a name="ln535"> </a>
<a name="ln536">  return CMD_SUCCESS;</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">DEFUN (accept_lifetime_day_month_day_month,</a>
<a name="ln540">       accept_lifetime_day_month_day_month_cmd,</a>
<a name="ln541">       &quot;accept-lifetime HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt; HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt;&quot;,</a>
<a name="ln542">       &quot;Set accept lifetime of the key\n&quot;</a>
<a name="ln543">       &quot;Time to start\n&quot;</a>
<a name="ln544">       &quot;Day of th month to start\n&quot;</a>
<a name="ln545">       &quot;Month of the year to start\n&quot;</a>
<a name="ln546">       &quot;Year to start\n&quot;</a>
<a name="ln547">       &quot;Time to expire\n&quot;</a>
<a name="ln548">       &quot;Day of th month to expire\n&quot;</a>
<a name="ln549">       &quot;Month of the year to expire\n&quot;</a>
<a name="ln550">       &quot;Year to expire\n&quot;)</a>
<a name="ln551">{</a>
<a name="ln552">  struct key *key;</a>
<a name="ln553"> </a>
<a name="ln554">  key = vty-&gt;index_sub;</a>
<a name="ln555"> </a>
<a name="ln556">  return key_lifetime_set (vty, &amp;key-&gt;accept, argv[0], argv[1], argv[2],</a>
<a name="ln557">			   argv[3], argv[4], argv[5], argv[6], argv[7]);</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">DEFUN (accept_lifetime_day_month_month_day,</a>
<a name="ln561">       accept_lifetime_day_month_month_day_cmd,</a>
<a name="ln562">       &quot;accept-lifetime HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt; HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt;&quot;,</a>
<a name="ln563">       &quot;Set accept lifetime of the key\n&quot;</a>
<a name="ln564">       &quot;Time to start\n&quot;</a>
<a name="ln565">       &quot;Day of th month to start\n&quot;</a>
<a name="ln566">       &quot;Month of the year to start\n&quot;</a>
<a name="ln567">       &quot;Year to start\n&quot;</a>
<a name="ln568">       &quot;Time to expire\n&quot;</a>
<a name="ln569">       &quot;Month of the year to expire\n&quot;</a>
<a name="ln570">       &quot;Day of th month to expire\n&quot;</a>
<a name="ln571">       &quot;Year to expire\n&quot;)</a>
<a name="ln572">{</a>
<a name="ln573">  struct key *key;</a>
<a name="ln574"> </a>
<a name="ln575">  key = vty-&gt;index_sub;</a>
<a name="ln576"> </a>
<a name="ln577">  return key_lifetime_set (vty, &amp;key-&gt;accept, argv[0], argv[1], argv[2],</a>
<a name="ln578">			   argv[3], argv[4], argv[6], argv[5], argv[7]);</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">DEFUN (accept_lifetime_month_day_day_month,</a>
<a name="ln582">       accept_lifetime_month_day_day_month_cmd,</a>
<a name="ln583">       &quot;accept-lifetime HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt; HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt;&quot;,</a>
<a name="ln584">       &quot;Set accept lifetime of the key\n&quot;</a>
<a name="ln585">       &quot;Time to start\n&quot;</a>
<a name="ln586">       &quot;Month of the year to start\n&quot;</a>
<a name="ln587">       &quot;Day of th month to start\n&quot;</a>
<a name="ln588">       &quot;Year to start\n&quot;</a>
<a name="ln589">       &quot;Time to expire\n&quot;</a>
<a name="ln590">       &quot;Day of th month to expire\n&quot;</a>
<a name="ln591">       &quot;Month of the year to expire\n&quot;</a>
<a name="ln592">       &quot;Year to expire\n&quot;)</a>
<a name="ln593">{</a>
<a name="ln594">  struct key *key;</a>
<a name="ln595"> </a>
<a name="ln596">  key = vty-&gt;index_sub;</a>
<a name="ln597"> </a>
<a name="ln598">  return key_lifetime_set (vty, &amp;key-&gt;accept, argv[0], argv[2], argv[1],</a>
<a name="ln599">			   argv[3], argv[4], argv[5], argv[6], argv[7]);</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">DEFUN (accept_lifetime_month_day_month_day,</a>
<a name="ln603">       accept_lifetime_month_day_month_day_cmd,</a>
<a name="ln604">       &quot;accept-lifetime HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt; HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt;&quot;,</a>
<a name="ln605">       &quot;Set accept lifetime of the key\n&quot;</a>
<a name="ln606">       &quot;Time to start\n&quot;</a>
<a name="ln607">       &quot;Month of the year to start\n&quot;</a>
<a name="ln608">       &quot;Day of th month to start\n&quot;</a>
<a name="ln609">       &quot;Year to start\n&quot;</a>
<a name="ln610">       &quot;Time to expire\n&quot;</a>
<a name="ln611">       &quot;Month of the year to expire\n&quot;</a>
<a name="ln612">       &quot;Day of th month to expire\n&quot;</a>
<a name="ln613">       &quot;Year to expire\n&quot;)</a>
<a name="ln614">{</a>
<a name="ln615">  struct key *key;</a>
<a name="ln616"> </a>
<a name="ln617">  key = vty-&gt;index_sub;</a>
<a name="ln618"> </a>
<a name="ln619">  return key_lifetime_set (vty, &amp;key-&gt;accept, argv[0], argv[2], argv[1],</a>
<a name="ln620">			   argv[3], argv[4], argv[6], argv[5], argv[7]);</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">DEFUN (accept_lifetime_infinite_day_month,</a>
<a name="ln624">       accept_lifetime_infinite_day_month_cmd,</a>
<a name="ln625">       &quot;accept-lifetime HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt; infinite&quot;,</a>
<a name="ln626">       &quot;Set accept lifetime of the key\n&quot;</a>
<a name="ln627">       &quot;Time to start\n&quot;</a>
<a name="ln628">       &quot;Day of th month to start\n&quot;</a>
<a name="ln629">       &quot;Month of the year to start\n&quot;</a>
<a name="ln630">       &quot;Year to start\n&quot;</a>
<a name="ln631">       &quot;Never expires&quot;)</a>
<a name="ln632">{</a>
<a name="ln633">  struct key *key;</a>
<a name="ln634"> </a>
<a name="ln635">  key = vty-&gt;index_sub;</a>
<a name="ln636"> </a>
<a name="ln637">  return key_lifetime_infinite_set (vty, &amp;key-&gt;accept, argv[0], argv[1],</a>
<a name="ln638">				    argv[2], argv[3]);</a>
<a name="ln639">}</a>
<a name="ln640"> </a>
<a name="ln641">DEFUN (accept_lifetime_infinite_month_day,</a>
<a name="ln642">       accept_lifetime_infinite_month_day_cmd,</a>
<a name="ln643">       &quot;accept-lifetime HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt; infinite&quot;,</a>
<a name="ln644">       &quot;Set accept lifetime of the key\n&quot;</a>
<a name="ln645">       &quot;Time to start\n&quot;</a>
<a name="ln646">       &quot;Month of the year to start\n&quot;</a>
<a name="ln647">       &quot;Day of th month to start\n&quot;</a>
<a name="ln648">       &quot;Year to start\n&quot;</a>
<a name="ln649">       &quot;Never expires&quot;)</a>
<a name="ln650">{</a>
<a name="ln651">  struct key *key;</a>
<a name="ln652"> </a>
<a name="ln653">  key = vty-&gt;index_sub;</a>
<a name="ln654"> </a>
<a name="ln655">  return key_lifetime_infinite_set (vty, &amp;key-&gt;accept, argv[0], argv[2],</a>
<a name="ln656">				    argv[1], argv[3]);</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">DEFUN (accept_lifetime_duration_day_month,</a>
<a name="ln660">       accept_lifetime_duration_day_month_cmd,</a>
<a name="ln661">       &quot;accept-lifetime HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt; duration &lt;1-2147483646&gt;&quot;,</a>
<a name="ln662">       &quot;Set accept lifetime of the key\n&quot;</a>
<a name="ln663">       &quot;Time to start\n&quot;</a>
<a name="ln664">       &quot;Day of th month to start\n&quot;</a>
<a name="ln665">       &quot;Month of the year to start\n&quot;</a>
<a name="ln666">       &quot;Year to start\n&quot;</a>
<a name="ln667">       &quot;Duration of the key\n&quot;</a>
<a name="ln668">       &quot;Duration seconds\n&quot;)</a>
<a name="ln669">{</a>
<a name="ln670">  struct key *key;</a>
<a name="ln671"> </a>
<a name="ln672">  key = vty-&gt;index_sub;</a>
<a name="ln673"> </a>
<a name="ln674">  return key_lifetime_duration_set (vty, &amp;key-&gt;accept, argv[0], argv[1],</a>
<a name="ln675">				    argv[2], argv[3], argv[4]);</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">DEFUN (accept_lifetime_duration_month_day,</a>
<a name="ln679">       accept_lifetime_duration_month_day_cmd,</a>
<a name="ln680">       &quot;accept-lifetime HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt; duration &lt;1-2147483646&gt;&quot;,</a>
<a name="ln681">       &quot;Set accept lifetime of the key\n&quot;</a>
<a name="ln682">       &quot;Time to start\n&quot;</a>
<a name="ln683">       &quot;Month of the year to start\n&quot;</a>
<a name="ln684">       &quot;Day of th month to start\n&quot;</a>
<a name="ln685">       &quot;Year to start\n&quot;</a>
<a name="ln686">       &quot;Duration of the key\n&quot;</a>
<a name="ln687">       &quot;Duration seconds\n&quot;)</a>
<a name="ln688">{</a>
<a name="ln689">  struct key *key;</a>
<a name="ln690"> </a>
<a name="ln691">  key = vty-&gt;index_sub;</a>
<a name="ln692"> </a>
<a name="ln693">  return key_lifetime_duration_set (vty, &amp;key-&gt;accept, argv[0], argv[2],</a>
<a name="ln694">				    argv[1], argv[3], argv[4]);</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">DEFUN (send_lifetime_day_month_day_month,</a>
<a name="ln698">       send_lifetime_day_month_day_month_cmd,</a>
<a name="ln699">       &quot;send-lifetime HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt; HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt;&quot;,</a>
<a name="ln700">       &quot;Set send lifetime of the key\n&quot;</a>
<a name="ln701">       &quot;Time to start\n&quot;</a>
<a name="ln702">       &quot;Day of th month to start\n&quot;</a>
<a name="ln703">       &quot;Month of the year to start\n&quot;</a>
<a name="ln704">       &quot;Year to start\n&quot;</a>
<a name="ln705">       &quot;Time to expire\n&quot;</a>
<a name="ln706">       &quot;Day of th month to expire\n&quot;</a>
<a name="ln707">       &quot;Month of the year to expire\n&quot;</a>
<a name="ln708">       &quot;Year to expire\n&quot;)</a>
<a name="ln709">{</a>
<a name="ln710">  struct key *key;</a>
<a name="ln711"> </a>
<a name="ln712">  key = vty-&gt;index_sub;</a>
<a name="ln713"> </a>
<a name="ln714">  return key_lifetime_set (vty, &amp;key-&gt;send, argv[0], argv[1], argv[2], argv[3],</a>
<a name="ln715">			   argv[4], argv[5], argv[6], argv[7]);</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">DEFUN (send_lifetime_day_month_month_day,</a>
<a name="ln719">       send_lifetime_day_month_month_day_cmd,</a>
<a name="ln720">       &quot;send-lifetime HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt; HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt;&quot;,</a>
<a name="ln721">       &quot;Set send lifetime of the key\n&quot;</a>
<a name="ln722">       &quot;Time to start\n&quot;</a>
<a name="ln723">       &quot;Day of th month to start\n&quot;</a>
<a name="ln724">       &quot;Month of the year to start\n&quot;</a>
<a name="ln725">       &quot;Year to start\n&quot;</a>
<a name="ln726">       &quot;Time to expire\n&quot;</a>
<a name="ln727">       &quot;Month of the year to expire\n&quot;</a>
<a name="ln728">       &quot;Day of th month to expire\n&quot;</a>
<a name="ln729">       &quot;Year to expire\n&quot;)</a>
<a name="ln730">{</a>
<a name="ln731">  struct key *key;</a>
<a name="ln732"> </a>
<a name="ln733">  key = vty-&gt;index_sub;</a>
<a name="ln734"> </a>
<a name="ln735">  return key_lifetime_set (vty, &amp;key-&gt;send, argv[0], argv[1], argv[2], argv[3],</a>
<a name="ln736">			   argv[4], argv[6], argv[5], argv[7]);</a>
<a name="ln737">}</a>
<a name="ln738"> </a>
<a name="ln739">DEFUN (send_lifetime_month_day_day_month,</a>
<a name="ln740">       send_lifetime_month_day_day_month_cmd,</a>
<a name="ln741">       &quot;send-lifetime HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt; HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt;&quot;,</a>
<a name="ln742">       &quot;Set send lifetime of the key\n&quot;</a>
<a name="ln743">       &quot;Time to start\n&quot;</a>
<a name="ln744">       &quot;Month of the year to start\n&quot;</a>
<a name="ln745">       &quot;Day of th month to start\n&quot;</a>
<a name="ln746">       &quot;Year to start\n&quot;</a>
<a name="ln747">       &quot;Time to expire\n&quot;</a>
<a name="ln748">       &quot;Day of th month to expire\n&quot;</a>
<a name="ln749">       &quot;Month of the year to expire\n&quot;</a>
<a name="ln750">       &quot;Year to expire\n&quot;)</a>
<a name="ln751">{</a>
<a name="ln752">  struct key *key;</a>
<a name="ln753"> </a>
<a name="ln754">  key = vty-&gt;index_sub;</a>
<a name="ln755"> </a>
<a name="ln756">  return key_lifetime_set (vty, &amp;key-&gt;send, argv[0], argv[2], argv[1], argv[3],</a>
<a name="ln757">			   argv[4], argv[5], argv[6], argv[7]);</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">DEFUN (send_lifetime_month_day_month_day,</a>
<a name="ln761">       send_lifetime_month_day_month_day_cmd,</a>
<a name="ln762">       &quot;send-lifetime HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt; HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt;&quot;,</a>
<a name="ln763">       &quot;Set send lifetime of the key\n&quot;</a>
<a name="ln764">       &quot;Time to start\n&quot;</a>
<a name="ln765">       &quot;Month of the year to start\n&quot;</a>
<a name="ln766">       &quot;Day of th month to start\n&quot;</a>
<a name="ln767">       &quot;Year to start\n&quot;</a>
<a name="ln768">       &quot;Time to expire\n&quot;</a>
<a name="ln769">       &quot;Month of the year to expire\n&quot;</a>
<a name="ln770">       &quot;Day of th month to expire\n&quot;</a>
<a name="ln771">       &quot;Year to expire\n&quot;)</a>
<a name="ln772">{</a>
<a name="ln773">  struct key *key;</a>
<a name="ln774"> </a>
<a name="ln775">  key = vty-&gt;index_sub;</a>
<a name="ln776"> </a>
<a name="ln777">  return key_lifetime_set (vty, &amp;key-&gt;send, argv[0], argv[2], argv[1], argv[3],</a>
<a name="ln778">			   argv[4], argv[6], argv[5], argv[7]);</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">DEFUN (send_lifetime_infinite_day_month,</a>
<a name="ln782">       send_lifetime_infinite_day_month_cmd,</a>
<a name="ln783">       &quot;send-lifetime HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt; infinite&quot;,</a>
<a name="ln784">       &quot;Set send lifetime of the key\n&quot;</a>
<a name="ln785">       &quot;Time to start\n&quot;</a>
<a name="ln786">       &quot;Day of th month to start\n&quot;</a>
<a name="ln787">       &quot;Month of the year to start\n&quot;</a>
<a name="ln788">       &quot;Year to start\n&quot;</a>
<a name="ln789">       &quot;Never expires&quot;)</a>
<a name="ln790">{</a>
<a name="ln791">  struct key *key;</a>
<a name="ln792"> </a>
<a name="ln793">  key = vty-&gt;index_sub;</a>
<a name="ln794"> </a>
<a name="ln795">  return key_lifetime_infinite_set (vty, &amp;key-&gt;send, argv[0], argv[1], argv[2],</a>
<a name="ln796">				    argv[3]);</a>
<a name="ln797">}</a>
<a name="ln798"> </a>
<a name="ln799">DEFUN (send_lifetime_infinite_month_day,</a>
<a name="ln800">       send_lifetime_infinite_month_day_cmd,</a>
<a name="ln801">       &quot;send-lifetime HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt; infinite&quot;,</a>
<a name="ln802">       &quot;Set send lifetime of the key\n&quot;</a>
<a name="ln803">       &quot;Time to start\n&quot;</a>
<a name="ln804">       &quot;Month of the year to start\n&quot;</a>
<a name="ln805">       &quot;Day of th month to start\n&quot;</a>
<a name="ln806">       &quot;Year to start\n&quot;</a>
<a name="ln807">       &quot;Never expires&quot;)</a>
<a name="ln808">{</a>
<a name="ln809">  struct key *key;</a>
<a name="ln810"> </a>
<a name="ln811">  key = vty-&gt;index_sub;</a>
<a name="ln812"> </a>
<a name="ln813">  return key_lifetime_infinite_set (vty, &amp;key-&gt;send, argv[0], argv[2], argv[1],</a>
<a name="ln814">				    argv[3]);</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">DEFUN (send_lifetime_duration_day_month,</a>
<a name="ln818">       send_lifetime_duration_day_month_cmd,</a>
<a name="ln819">       &quot;send-lifetime HH:MM:SS &lt;1-31&gt; MONTH &lt;1993-2035&gt; duration &lt;1-2147483646&gt;&quot;,</a>
<a name="ln820">       &quot;Set send lifetime of the key\n&quot;</a>
<a name="ln821">       &quot;Time to start\n&quot;</a>
<a name="ln822">       &quot;Day of th month to start\n&quot;</a>
<a name="ln823">       &quot;Month of the year to start\n&quot;</a>
<a name="ln824">       &quot;Year to start\n&quot;</a>
<a name="ln825">       &quot;Duration of the key\n&quot;</a>
<a name="ln826">       &quot;Duration seconds\n&quot;)</a>
<a name="ln827">{</a>
<a name="ln828">  struct key *key;</a>
<a name="ln829"> </a>
<a name="ln830">  key = vty-&gt;index_sub;</a>
<a name="ln831"> </a>
<a name="ln832">  return key_lifetime_duration_set (vty, &amp;key-&gt;send, argv[0], argv[1], argv[2],</a>
<a name="ln833">				    argv[3], argv[4]);</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">DEFUN (send_lifetime_duration_month_day,</a>
<a name="ln837">       send_lifetime_duration_month_day_cmd,</a>
<a name="ln838">       &quot;send-lifetime HH:MM:SS MONTH &lt;1-31&gt; &lt;1993-2035&gt; duration &lt;1-2147483646&gt;&quot;,</a>
<a name="ln839">       &quot;Set send lifetime of the key\n&quot;</a>
<a name="ln840">       &quot;Time to start\n&quot;</a>
<a name="ln841">       &quot;Month of the year to start\n&quot;</a>
<a name="ln842">       &quot;Day of th month to start\n&quot;</a>
<a name="ln843">       &quot;Year to start\n&quot;</a>
<a name="ln844">       &quot;Duration of the key\n&quot;</a>
<a name="ln845">       &quot;Duration seconds\n&quot;)</a>
<a name="ln846">{</a>
<a name="ln847">  struct key *key;</a>
<a name="ln848"> </a>
<a name="ln849">  key = vty-&gt;index_sub;</a>
<a name="ln850"> </a>
<a name="ln851">  return key_lifetime_duration_set (vty, &amp;key-&gt;send, argv[0], argv[2], argv[1],</a>
<a name="ln852">				    argv[3], argv[4]);</a>
<a name="ln853">}</a>
<a name="ln854"> </a>
<a name="ln855">static struct cmd_node keychain_node =</a>
<a name="ln856">{</a>
<a name="ln857">  KEYCHAIN_NODE,</a>
<a name="ln858">  &quot;%s(config-keychain)# &quot;,</a>
<a name="ln859">  1</a>
<a name="ln860">};</a>
<a name="ln861"> </a>
<a name="ln862">static struct cmd_node keychain_key_node =</a>
<a name="ln863">{</a>
<a name="ln864">  KEYCHAIN_KEY_NODE,</a>
<a name="ln865">  &quot;%s(config-keychain-key)# &quot;,</a>
<a name="ln866">  1</a>
<a name="ln867">};</a>
<a name="ln868"> </a>
<a name="ln869">static int</a>
<a name="ln870">keychain_strftime (char *buf, int bufsiz, time_t *time)</a>
<a name="ln871">{</a>
<a name="ln872">  struct tm *tm;</a>
<a name="ln873">  size_t len;</a>
<a name="ln874"> </a>
<a name="ln875">  tm = localtime (time);</a>
<a name="ln876"> </a>
<a name="ln877">  len = strftime (buf, bufsiz, &quot;%T %b %d %Y&quot;, tm);</a>
<a name="ln878"> </a>
<a name="ln879">  return len;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">static int</a>
<a name="ln883">keychain_config_write (struct vty *vty)</a>
<a name="ln884">{</a>
<a name="ln885">  struct keychain *keychain;</a>
<a name="ln886">  struct key *key;</a>
<a name="ln887">  struct listnode *node;</a>
<a name="ln888">  struct listnode *knode;</a>
<a name="ln889">  char buf[BUFSIZ];</a>
<a name="ln890"> </a>
<a name="ln891">  for (ALL_LIST_ELEMENTS_RO (keychain_list, node, keychain))</a>
<a name="ln892">    {</a>
<a name="ln893">      vty_out (vty, &quot;key chain %s%s&quot;, keychain-&gt;name, VTY_NEWLINE);</a>
<a name="ln894">      </a>
<a name="ln895">      for (ALL_LIST_ELEMENTS_RO (keychain-&gt;key, knode, key))</a>
<a name="ln896">	{</a>
<a name="ln897">	  vty_out (vty, &quot; key %d%s&quot;, key-&gt;index, VTY_NEWLINE);</a>
<a name="ln898"> </a>
<a name="ln899">	  if (key-&gt;string)</a>
<a name="ln900">	    vty_out (vty, &quot;  key-string %s%s&quot;, key-&gt;string, VTY_NEWLINE);</a>
<a name="ln901"> </a>
<a name="ln902">	  if (key-&gt;accept.start)</a>
<a name="ln903">	    {</a>
<a name="ln904">	      keychain_strftime (buf, BUFSIZ, &amp;key-&gt;accept.start);</a>
<a name="ln905">	      vty_out (vty, &quot;  accept-lifetime %s&quot;, buf);</a>
<a name="ln906"> </a>
<a name="ln907">	      if (key-&gt;accept.end == -1)</a>
<a name="ln908">		vty_out (vty, &quot; infinite&quot;);</a>
<a name="ln909">	      else if (key-&gt;accept.duration)</a>
<a name="ln910">		vty_out (vty, &quot; duration %ld&quot;,</a>
<a name="ln911">			 (long)(key-&gt;accept.end - key-&gt;accept.start));</a>
<a name="ln912">	      else</a>
<a name="ln913">		{</a>
<a name="ln914">		  keychain_strftime (buf, BUFSIZ, &amp;key-&gt;accept.end);</a>
<a name="ln915">		  vty_out (vty, &quot; %s&quot;, buf);</a>
<a name="ln916">		}</a>
<a name="ln917">	      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln918">	    }</a>
<a name="ln919"> </a>
<a name="ln920">	  if (key-&gt;send.start)</a>
<a name="ln921">	    {</a>
<a name="ln922">	      keychain_strftime (buf, BUFSIZ, &amp;key-&gt;send.start);</a>
<a name="ln923">	      vty_out (vty, &quot;  send-lifetime %s&quot;, buf);</a>
<a name="ln924"> </a>
<a name="ln925">	      if (key-&gt;send.end == -1)</a>
<a name="ln926">		vty_out (vty, &quot; infinite&quot;);</a>
<a name="ln927">	      else if (key-&gt;send.duration)</a>
<a name="ln928">		vty_out (vty, &quot; duration %ld&quot;, (long)(key-&gt;send.end - key-&gt;send.start));</a>
<a name="ln929">	      else</a>
<a name="ln930">		{</a>
<a name="ln931">		  keychain_strftime (buf, BUFSIZ, &amp;key-&gt;send.end);</a>
<a name="ln932">		  vty_out (vty, &quot; %s&quot;, buf);</a>
<a name="ln933">		}</a>
<a name="ln934">	      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln935">	    }</a>
<a name="ln936">	}</a>
<a name="ln937">      vty_out (vty, &quot;!%s&quot;, VTY_NEWLINE);</a>
<a name="ln938">    }</a>
<a name="ln939"> </a>
<a name="ln940">  return 0;</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">void</a>
<a name="ln944">keychain_init ()</a>
<a name="ln945">{</a>
<a name="ln946">  keychain_list = list_new ();</a>
<a name="ln947"> </a>
<a name="ln948">  install_node (&amp;keychain_node, keychain_config_write);</a>
<a name="ln949">  install_node (&amp;keychain_key_node, NULL);</a>
<a name="ln950"> </a>
<a name="ln951">  install_default (KEYCHAIN_NODE);</a>
<a name="ln952">  install_default (KEYCHAIN_KEY_NODE);</a>
<a name="ln953"> </a>
<a name="ln954">  install_element (CONFIG_NODE, &amp;key_chain_cmd);</a>
<a name="ln955">  install_element (CONFIG_NODE, &amp;no_key_chain_cmd);</a>
<a name="ln956">  install_element (KEYCHAIN_NODE, &amp;key_cmd);</a>
<a name="ln957">  install_element (KEYCHAIN_NODE, &amp;no_key_cmd);</a>
<a name="ln958"> </a>
<a name="ln959">  install_element (KEYCHAIN_NODE, &amp;key_chain_cmd);</a>
<a name="ln960">  install_element (KEYCHAIN_NODE, &amp;no_key_chain_cmd);</a>
<a name="ln961"> </a>
<a name="ln962">  install_element (KEYCHAIN_KEY_NODE, &amp;key_string_cmd);</a>
<a name="ln963">  install_element (KEYCHAIN_KEY_NODE, &amp;no_key_string_cmd);</a>
<a name="ln964"> </a>
<a name="ln965">  install_element (KEYCHAIN_KEY_NODE, &amp;key_chain_cmd);</a>
<a name="ln966">  install_element (KEYCHAIN_KEY_NODE, &amp;no_key_chain_cmd);</a>
<a name="ln967"> </a>
<a name="ln968">  install_element (KEYCHAIN_KEY_NODE, &amp;key_cmd);</a>
<a name="ln969">  install_element (KEYCHAIN_KEY_NODE, &amp;no_key_cmd);</a>
<a name="ln970"> </a>
<a name="ln971">  install_element (KEYCHAIN_KEY_NODE, &amp;accept_lifetime_day_month_day_month_cmd);</a>
<a name="ln972">  install_element (KEYCHAIN_KEY_NODE, &amp;accept_lifetime_day_month_month_day_cmd);</a>
<a name="ln973">  install_element (KEYCHAIN_KEY_NODE, &amp;accept_lifetime_month_day_day_month_cmd);</a>
<a name="ln974">  install_element (KEYCHAIN_KEY_NODE, &amp;accept_lifetime_month_day_month_day_cmd);</a>
<a name="ln975">  install_element (KEYCHAIN_KEY_NODE, &amp;accept_lifetime_infinite_day_month_cmd);</a>
<a name="ln976">  install_element (KEYCHAIN_KEY_NODE, &amp;accept_lifetime_infinite_month_day_cmd);</a>
<a name="ln977">  install_element (KEYCHAIN_KEY_NODE, &amp;accept_lifetime_duration_day_month_cmd);</a>
<a name="ln978">  install_element (KEYCHAIN_KEY_NODE, &amp;accept_lifetime_duration_month_day_cmd);</a>
<a name="ln979"> </a>
<a name="ln980">  install_element (KEYCHAIN_KEY_NODE, &amp;send_lifetime_day_month_day_month_cmd);</a>
<a name="ln981">  install_element (KEYCHAIN_KEY_NODE, &amp;send_lifetime_day_month_month_day_cmd);</a>
<a name="ln982">  install_element (KEYCHAIN_KEY_NODE, &amp;send_lifetime_month_day_day_month_cmd);</a>
<a name="ln983">  install_element (KEYCHAIN_KEY_NODE, &amp;send_lifetime_month_day_month_day_cmd);</a>
<a name="ln984">  install_element (KEYCHAIN_KEY_NODE, &amp;send_lifetime_infinite_day_month_cmd);</a>
<a name="ln985">  install_element (KEYCHAIN_KEY_NODE, &amp;send_lifetime_infinite_month_day_cmd);</a>
<a name="ln986">  install_element (KEYCHAIN_KEY_NODE, &amp;send_lifetime_duration_day_month_cmd);</a>
<a name="ln987">  install_element (KEYCHAIN_KEY_NODE, &amp;send_lifetime_duration_month_day_cmd);</a>
<a name="ln988">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
