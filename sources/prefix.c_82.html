
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>prefix.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Prefix related functions.</a>
<a name="ln3"> * Copyright (C) 1997, 98, 99 Kunihiro Ishiguro</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.  </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;vty.h&quot;</a>
<a name="ln27">#include &quot;sockunion.h&quot;</a>
<a name="ln28">#include &quot;memory.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">/* Maskbit. */</a>
<a name="ln32">static const u_char maskbit[] = {0x00, 0x80, 0xc0, 0xe0, 0xf0,</a>
<a name="ln33">			         0xf8, 0xfc, 0xfe, 0xff};</a>
<a name="ln34"> </a>
<a name="ln35">static const struct in6_addr maskbytes6[] =</a>
<a name="ln36">{</a>
<a name="ln37">  /* /0   */ { { { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln38">  /* /1   */ { { { 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln39">  /* /2   */ { { { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln40">  /* /3   */ { { { 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln41">  /* /4   */ { { { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln42">  /* /5   */ { { { 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln43">  /* /6   */ { { { 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln44">  /* /7   */ { { { 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln45">  /* /8   */ { { { 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln46">  /* /9   */ { { { 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln47">  /* /10  */ { { { 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln48">  /* /11  */ { { { 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln49">  /* /12  */ { { { 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln50">  /* /13  */ { { { 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln51">  /* /14  */ { { { 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln52">  /* /15  */ { { { 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln53">  /* /16  */ { { { 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln54">  /* /17  */ { { { 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln55">  /* /18  */ { { { 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln56">  /* /19  */ { { { 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln57">  /* /20  */ { { { 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln58">  /* /21  */ { { { 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln59">  /* /22  */ { { { 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln60">  /* /23  */ { { { 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln61">  /* /24  */ { { { 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln62">  /* /25  */ { { { 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln63">  /* /26  */ { { { 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln64">  /* /27  */ { { { 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln65">  /* /28  */ { { { 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln66">  /* /29  */ { { { 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln67">  /* /30  */ { { { 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln68">  /* /31  */ { { { 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln69">  /* /32  */ { { { 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln70">  /* /33  */ { { { 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln71">  /* /34  */ { { { 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln72">  /* /35  */ { { { 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln73">  /* /36  */ { { { 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln74">  /* /37  */ { { { 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln75">  /* /38  */ { { { 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln76">  /* /39  */ { { { 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln77">  /* /40  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln78">  /* /41  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln79">  /* /42  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln80">  /* /43  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln81">  /* /44  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln82">  /* /45  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln83">  /* /46  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln84">  /* /47  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln85">  /* /48  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln86">  /* /49  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln87">  /* /50  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln88">  /* /51  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln89">  /* /52  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln90">  /* /53  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln91">  /* /54  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln92">  /* /55  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln93">  /* /56  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln94">  /* /57  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln95">  /* /58  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln96">  /* /59  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln97">  /* /60  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln98">  /* /61  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln99">  /* /62  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln100">  /* /63  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln101">  /* /64  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln102">  /* /65  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln103">  /* /66  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln104">  /* /67  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln105">  /* /68  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln106">  /* /69  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln107">  /* /70  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln108">  /* /71  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln109">  /* /72  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln110">  /* /73  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln111">  /* /74  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln112">  /* /75  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln113">  /* /76  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln114">  /* /77  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln115">  /* /78  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln116">  /* /79  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln117">  /* /80  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln118">  /* /81  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln119">  /* /82  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln120">  /* /83  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln121">  /* /84  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln122">  /* /85  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln123">  /* /86  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln124">  /* /87  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln125">  /* /88  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln126">  /* /89  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln127">  /* /90  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln128">  /* /91  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln129">  /* /92  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln130">  /* /93  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln131">  /* /94  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln132">  /* /95  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln133">  /* /96  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00 } } },</a>
<a name="ln134">  /* /97  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00, 0x00 } } },</a>
<a name="ln135">  /* /98  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00, 0x00 } } },</a>
<a name="ln136">  /* /99  */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00, 0x00 } } },</a>
<a name="ln137">  /* /100 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00, 0x00 } } },</a>
<a name="ln138">  /* /101 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00, 0x00 } } },</a>
<a name="ln139">  /* /102 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00, 0x00 } } },</a>
<a name="ln140">  /* /103 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00, 0x00 } } },</a>
<a name="ln141">  /* /104 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00 } } },</a>
<a name="ln142">  /* /105 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00, 0x00 } } },</a>
<a name="ln143">  /* /106 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00, 0x00 } } },</a>
<a name="ln144">  /* /107 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00, 0x00 } } },</a>
<a name="ln145">  /* /108 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00, 0x00 } } },</a>
<a name="ln146">  /* /109 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00, 0x00 } } },</a>
<a name="ln147">  /* /110 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00, 0x00 } } },</a>
<a name="ln148">  /* /111 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00, 0x00 } } },</a>
<a name="ln149">  /* /112 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00 } } },</a>
<a name="ln150">  /* /113 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80, 0x00 } } },</a>
<a name="ln151">  /* /114 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 0x00 } } },</a>
<a name="ln152">  /* /115 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 0x00 } } },</a>
<a name="ln153">  /* /116 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0, 0x00 } } },</a>
<a name="ln154">  /* /117 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8, 0x00 } } },</a>
<a name="ln155">  /* /118 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc, 0x00 } } },</a>
<a name="ln156">  /* /119 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe, 0x00 } } },</a>
<a name="ln157">  /* /120 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00 } } },</a>
<a name="ln158">  /* /121 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x80 } } },</a>
<a name="ln159">  /* /122 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0 } } },</a>
<a name="ln160">  /* /123 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0 } } },</a>
<a name="ln161">  /* /124 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf0 } } },</a>
<a name="ln162">  /* /125 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf8 } } },</a>
<a name="ln163">  /* /126 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfc } } },</a>
<a name="ln164">  /* /127 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xfe } } },</a>
<a name="ln165">  /* /128 */ { { { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff } } }</a>
<a name="ln166">};</a>
<a name="ln167"> </a>
<a name="ln168">/* Number of bits in prefix type. */</a>
<a name="ln169">#ifndef PNBBY</a>
<a name="ln170">#define PNBBY 8</a>
<a name="ln171">#endif /* PNBBY */</a>
<a name="ln172"> </a>
<a name="ln173">#define MASKBIT(offset)  ((0xff &lt;&lt; (PNBBY - (offset))) &amp; 0xff)</a>
<a name="ln174"> </a>
<a name="ln175">unsigned int</a>
<a name="ln176">prefix_bit (const u_char *prefix, const u_char prefixlen)</a>
<a name="ln177">{</a>
<a name="ln178">  unsigned int offset = prefixlen / 8;</a>
<a name="ln179">  unsigned int shift  = 7 - (prefixlen % 8);</a>
<a name="ln180">  </a>
<a name="ln181">  return (prefix[offset] &gt;&gt; shift) &amp; 1;</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">unsigned int</a>
<a name="ln185">prefix6_bit (const struct in6_addr *prefix, const u_char prefixlen)</a>
<a name="ln186">{</a>
<a name="ln187">  return prefix_bit((const u_char *) &amp;prefix-&gt;s6_addr, prefixlen);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">int</a>
<a name="ln191">str2family(const char *string)</a>
<a name="ln192">{</a>
<a name="ln193">  if (!strcmp(&quot;ipv4&quot;, string))</a>
<a name="ln194">    return AF_INET;</a>
<a name="ln195">  else if (!strcmp(&quot;ipv6&quot;, string))</a>
<a name="ln196">    return AF_INET6;</a>
<a name="ln197">  else if (!strcmp(&quot;ethernet&quot;, string))</a>
<a name="ln198">    return AF_ETHERNET;</a>
<a name="ln199">  return -1;</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">/* Address Famiy Identifier to Address Family converter. */</a>
<a name="ln203">int</a>
<a name="ln204">afi2family (afi_t afi)</a>
<a name="ln205">{</a>
<a name="ln206">  if (afi == AFI_IP)</a>
<a name="ln207">    return AF_INET;</a>
<a name="ln208">#ifdef HAVE_IPV6</a>
<a name="ln209">  else if (afi == AFI_IP6)</a>
<a name="ln210">    return AF_INET6;</a>
<a name="ln211">#endif /* HAVE_IPV6 */</a>
<a name="ln212">  else if (afi == AFI_ETHER)</a>
<a name="ln213">    return AF_ETHERNET;</a>
<a name="ln214">  return 0;</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">afi_t</a>
<a name="ln218">family2afi (int family)</a>
<a name="ln219">{</a>
<a name="ln220">  if (family == AF_INET)</a>
<a name="ln221">    return AFI_IP;</a>
<a name="ln222">#ifdef HAVE_IPV6</a>
<a name="ln223">  else if (family == AF_INET6)</a>
<a name="ln224">    return AFI_IP6;</a>
<a name="ln225">#endif /* HAVE_IPV6 */</a>
<a name="ln226">  else if (family == AF_ETHERNET)</a>
<a name="ln227">    return AFI_ETHER;</a>
<a name="ln228">  return 0;</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">const char *</a>
<a name="ln232">afi2str(afi_t afi)</a>
<a name="ln233">{</a>
<a name="ln234">  switch (afi) {</a>
<a name="ln235">    case AFI_IP:</a>
<a name="ln236">	return &quot;IPv4&quot;;</a>
<a name="ln237">    case AFI_IP6:</a>
<a name="ln238">	return &quot;IPv6&quot;;</a>
<a name="ln239">    case AFI_ETHER:</a>
<a name="ln240">	return &quot;ethernet&quot;;</a>
<a name="ln241">  }</a>
<a name="ln242">  return NULL;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">const char *</a>
<a name="ln246">safi2str(safi_t safi)</a>
<a name="ln247">{</a>
<a name="ln248">  switch (safi) {</a>
<a name="ln249">    case SAFI_UNICAST:</a>
<a name="ln250">	return &quot;unicast&quot;;</a>
<a name="ln251">    case SAFI_MULTICAST:</a>
<a name="ln252">	return &quot;multicast&quot;;</a>
<a name="ln253">    case SAFI_ENCAP:</a>
<a name="ln254">	return &quot;encap&quot;;</a>
<a name="ln255">    case SAFI_MPLS_VPN:</a>
<a name="ln256">	return &quot;vpn&quot;;</a>
<a name="ln257">  }</a>
<a name="ln258">  return NULL;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">/* If n includes p prefix then return 1 else return 0. */</a>
<a name="ln262">int</a>
<a name="ln263">prefix_match (const struct prefix *n, const struct prefix *p)</a>
<a name="ln264">{</a>
<a name="ln265">  int offset;</a>
<a name="ln266">  int shift;</a>
<a name="ln267">  const u_char *np, *pp;</a>
<a name="ln268"> </a>
<a name="ln269">  /* If n's prefix is longer than p's one return 0. */</a>
<a name="ln270">  if (n-&gt;prefixlen &gt; p-&gt;prefixlen)</a>
<a name="ln271">    return 0;</a>
<a name="ln272"> </a>
<a name="ln273">  /* Set both prefix's head pointer. */</a>
<a name="ln274">  np = (const u_char *)&amp;n-&gt;u.prefix;</a>
<a name="ln275">  pp = (const u_char *)&amp;p-&gt;u.prefix;</a>
<a name="ln276">  </a>
<a name="ln277">  offset = n-&gt;prefixlen / PNBBY;</a>
<a name="ln278">  shift =  n-&gt;prefixlen % PNBBY;</a>
<a name="ln279"> </a>
<a name="ln280">  if (shift)</a>
<a name="ln281">    if (maskbit[shift] &amp; (np[offset] ^ pp[offset]))</a>
<a name="ln282">      return 0;</a>
<a name="ln283">  </a>
<a name="ln284">  while (offset--)</a>
<a name="ln285">    if (np[offset] != pp[offset])</a>
<a name="ln286">      return 0;</a>
<a name="ln287">  return 1;</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">/* Copy prefix from src to dest. */</a>
<a name="ln291">void</a>
<a name="ln292">prefix_copy (struct prefix *dest, const struct prefix *src)</a>
<a name="ln293">{</a>
<a name="ln294">  dest-&gt;family = src-&gt;family;</a>
<a name="ln295">  dest-&gt;prefixlen = src-&gt;prefixlen;</a>
<a name="ln296"> </a>
<a name="ln297">  if (src-&gt;family == AF_INET)</a>
<a name="ln298">    dest-&gt;u.prefix4 = src-&gt;u.prefix4;</a>
<a name="ln299">#ifdef HAVE_IPV6</a>
<a name="ln300">  else if (src-&gt;family == AF_INET6)</a>
<a name="ln301">    dest-&gt;u.prefix6 = src-&gt;u.prefix6;</a>
<a name="ln302">#endif /* HAVE_IPV6 */</a>
<a name="ln303">  else if (src-&gt;family == AF_UNSPEC)</a>
<a name="ln304">    {</a>
<a name="ln305">      dest-&gt;u.lp.id = src-&gt;u.lp.id;</a>
<a name="ln306">      dest-&gt;u.lp.adv_router = src-&gt;u.lp.adv_router;</a>
<a name="ln307">    }</a>
<a name="ln308">  else if (src-&gt;family == AF_ETHERNET)</a>
<a name="ln309">    {</a>
<a name="ln310">      dest-&gt;u.prefix_eth = src-&gt;u.prefix_eth;</a>
<a name="ln311">    }</a>
<a name="ln312">  else</a>
<a name="ln313">    {</a>
<a name="ln314">      zlog (NULL, LOG_ERR, &quot;prefix_copy(): Unknown address family %d&quot;,</a>
<a name="ln315">	      src-&gt;family);</a>
<a name="ln316">      assert (0);</a>
<a name="ln317">    }</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">/* </a>
<a name="ln321"> * Return 1 if the address/netmask contained in the prefix structure</a>
<a name="ln322"> * is the same, and else return 0.  For this routine, 'same' requires</a>
<a name="ln323"> * that not only the prefix length and the network part be the same,</a>
<a name="ln324"> * but also the host part.  Thus, 10.0.0.1/8 and 10.0.0.2/8 are not</a>
<a name="ln325"> * the same.  Note that this routine has the same return value sense</a>
<a name="ln326"> * as '==' (which is different from prefix_cmp).</a>
<a name="ln327"> */</a>
<a name="ln328">int</a>
<a name="ln329">prefix_same (const struct prefix *p1, const struct prefix *p2)</a>
<a name="ln330">{</a>
<a name="ln331">  if (p1-&gt;family == p2-&gt;family &amp;&amp; p1-&gt;prefixlen == p2-&gt;prefixlen)</a>
<a name="ln332">    {</a>
<a name="ln333">      if (p1-&gt;family == AF_INET)</a>
<a name="ln334">	if (IPV4_ADDR_SAME (&amp;p1-&gt;u.prefix4.s_addr, &amp;p2-&gt;u.prefix4.s_addr))</a>
<a name="ln335">	  return 1;</a>
<a name="ln336">#ifdef HAVE_IPV6</a>
<a name="ln337">      if (p1-&gt;family == AF_INET6 )</a>
<a name="ln338">	if (IPV6_ADDR_SAME (&amp;p1-&gt;u.prefix6.s6_addr, &amp;p2-&gt;u.prefix6.s6_addr))</a>
<a name="ln339">	  return 1;</a>
<a name="ln340">#endif /* HAVE_IPV6 */</a>
<a name="ln341">      if (p1-&gt;family == AF_ETHERNET) {</a>
<a name="ln342">	if (!memcmp(p1-&gt;u.prefix_eth.octet, p2-&gt;u.prefix_eth.octet, ETHER_ADDR_LEN))</a>
<a name="ln343">	    return 1;</a>
<a name="ln344">      }</a>
<a name="ln345">    }</a>
<a name="ln346">  return 0;</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">/*</a>
<a name="ln350"> * Return 0 if the network prefixes represented by the struct prefix</a>
<a name="ln351"> * arguments are the same prefix, and 1 otherwise.  Network prefixes</a>
<a name="ln352"> * are considered the same if the prefix lengths are equal and the</a>
<a name="ln353"> * network parts are the same.  Host bits (which are considered masked</a>
<a name="ln354"> * by the prefix length) are not significant.  Thus, 10.0.0.1/8 and</a>
<a name="ln355"> * 10.0.0.2/8 are considered equivalent by this routine.  Note that</a>
<a name="ln356"> * this routine has the same return sense as strcmp (which is different</a>
<a name="ln357"> * from prefix_same).</a>
<a name="ln358"> */</a>
<a name="ln359">int</a>
<a name="ln360">prefix_cmp (const struct prefix *p1, const struct prefix *p2)</a>
<a name="ln361">{</a>
<a name="ln362">  int offset;</a>
<a name="ln363">  int shift;</a>
<a name="ln364"> </a>
<a name="ln365">  /* Set both prefix's head pointer. */</a>
<a name="ln366">  const u_char *pp1 = (const u_char *)&amp;p1-&gt;u.prefix;</a>
<a name="ln367">  const u_char *pp2 = (const u_char *)&amp;p2-&gt;u.prefix;</a>
<a name="ln368"> </a>
<a name="ln369">  if (p1-&gt;family != p2-&gt;family || p1-&gt;prefixlen != p2-&gt;prefixlen)</a>
<a name="ln370">    return 1;</a>
<a name="ln371"> </a>
<a name="ln372">  offset = p1-&gt;prefixlen / PNBBY;</a>
<a name="ln373">  shift = p1-&gt;prefixlen % PNBBY;</a>
<a name="ln374"> </a>
<a name="ln375">  if (shift)</a>
<a name="ln376">    if (maskbit[shift] &amp; (pp1[offset] ^ pp2[offset]))</a>
<a name="ln377">      return 1;</a>
<a name="ln378"> </a>
<a name="ln379">  while (offset--)</a>
<a name="ln380">    if (pp1[offset] != pp2[offset])</a>
<a name="ln381">      return 1;</a>
<a name="ln382"> </a>
<a name="ln383">  return 0;</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">/*</a>
<a name="ln387"> * Count the number of common bits in 2 prefixes. The prefix length is</a>
<a name="ln388"> * ignored for this function; the whole prefix is compared. If the prefix</a>
<a name="ln389"> * address families don't match, return -1; otherwise the return value is</a>
<a name="ln390"> * in range 0 ... maximum prefix length for the address family.</a>
<a name="ln391"> */</a>
<a name="ln392">int</a>
<a name="ln393">prefix_common_bits (const struct prefix *p1, const struct prefix *p2)</a>
<a name="ln394">{</a>
<a name="ln395">  int pos, bit;</a>
<a name="ln396">  int length = 0;</a>
<a name="ln397">  u_char xor;</a>
<a name="ln398"> </a>
<a name="ln399">  /* Set both prefix's head pointer. */</a>
<a name="ln400">  const u_char *pp1 = (const u_char *)&amp;p1-&gt;u.prefix;</a>
<a name="ln401">  const u_char *pp2 = (const u_char *)&amp;p2-&gt;u.prefix;</a>
<a name="ln402"> </a>
<a name="ln403">  if (p1-&gt;family == AF_INET)</a>
<a name="ln404">    length = IPV4_MAX_BYTELEN;</a>
<a name="ln405">#ifdef HAVE_IPV6</a>
<a name="ln406">  if (p1-&gt;family == AF_INET6)</a>
<a name="ln407">    length = IPV6_MAX_BYTELEN;</a>
<a name="ln408">#endif</a>
<a name="ln409">  if (p1-&gt;family != p2-&gt;family || !length)</a>
<a name="ln410">    return -1;</a>
<a name="ln411"> </a>
<a name="ln412">  for (pos = 0; pos &lt; length; pos++)</a>
<a name="ln413">    if (pp1[pos] != pp2[pos])</a>
<a name="ln414">      break;</a>
<a name="ln415">  if (pos == length)</a>
<a name="ln416">    return pos * 8;</a>
<a name="ln417"> </a>
<a name="ln418">  xor = pp1[pos] ^ pp2[pos];</a>
<a name="ln419">  for (bit = 0; bit &lt; 8; bit++)</a>
<a name="ln420">    if (xor &amp; (1 &lt;&lt; (7 - bit)))</a>
<a name="ln421">      break;</a>
<a name="ln422"> </a>
<a name="ln423">  return pos * 8 + bit;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">/* Return prefix family type string. */</a>
<a name="ln427">const char *</a>
<a name="ln428">prefix_family_str (const struct prefix *p)</a>
<a name="ln429">{</a>
<a name="ln430">  if (p-&gt;family == AF_INET)</a>
<a name="ln431">    return &quot;inet&quot;;</a>
<a name="ln432">#ifdef HAVE_IPV6</a>
<a name="ln433">  if (p-&gt;family == AF_INET6)</a>
<a name="ln434">    return &quot;inet6&quot;;</a>
<a name="ln435">#endif /* HAVE_IPV6 */</a>
<a name="ln436">  if (p-&gt;family == AF_ETHERNET)</a>
<a name="ln437">    return &quot;ether&quot;;</a>
<a name="ln438">  return &quot;unspec&quot;;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">/* Allocate new prefix_ipv4 structure. */</a>
<a name="ln442">struct prefix_ipv4 *</a>
<a name="ln443">prefix_ipv4_new ()</a>
<a name="ln444">{</a>
<a name="ln445">  struct prefix_ipv4 *p;</a>
<a name="ln446"> </a>
<a name="ln447">  /* Call prefix_new to allocate a full-size struct prefix to avoid problems</a>
<a name="ln448">     where the struct prefix_ipv4 is cast to struct prefix and unallocated</a>
<a name="ln449">     bytes were being referenced (e.g. in structure assignments). */</a>
<a name="ln450">  p = (struct prefix_ipv4 *)prefix_new();</a>
<a name="ln451">  p-&gt;family = AF_INET;</a>
<a name="ln452">  return p;</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">/* Free prefix_ipv4 structure. */</a>
<a name="ln456">void</a>
<a name="ln457">prefix_ipv4_free (struct prefix_ipv4 *p)</a>
<a name="ln458">{</a>
<a name="ln459">  prefix_free((struct prefix *)p);</a>
<a name="ln460">}</a>
<a name="ln461"> </a>
<a name="ln462">/* When string format is invalid return 0. */</a>
<a name="ln463">int</a>
<a name="ln464">str2prefix_ipv4 (const char *str, struct prefix_ipv4 *p)</a>
<a name="ln465">{</a>
<a name="ln466">  int ret;</a>
<a name="ln467">  int plen;</a>
<a name="ln468">  char *pnt;</a>
<a name="ln469">  char *cp;</a>
<a name="ln470"> </a>
<a name="ln471">  /* Find slash inside string. */</a>
<a name="ln472">  pnt = strchr (str, '/');</a>
<a name="ln473"> </a>
<a name="ln474">  /* String doesn't contail slash. */</a>
<a name="ln475">  if (pnt == NULL) </a>
<a name="ln476">    {</a>
<a name="ln477">      /* Convert string to prefix. */</a>
<a name="ln478">      ret = inet_aton (str, &amp;p-&gt;prefix);</a>
<a name="ln479">      if (ret == 0)</a>
<a name="ln480">	return 0;</a>
<a name="ln481"> </a>
<a name="ln482">      /* If address doesn't contain slash we assume it host address. */</a>
<a name="ln483">      p-&gt;family = AF_INET;</a>
<a name="ln484">      p-&gt;prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln485"> </a>
<a name="ln486">      return ret;</a>
<a name="ln487">    }</a>
<a name="ln488">  else</a>
<a name="ln489">    {</a>
<a name="ln490">      cp = XMALLOC (MTYPE_TMP, (pnt - str) + 1);</a>
<a name="ln491">      strncpy (cp, str, pnt - str);</a>
<a name="ln492">      *(cp + (pnt - str)) = '\0';</a>
<a name="ln493">      ret = inet_aton (cp, &amp;p-&gt;prefix);</a>
<a name="ln494">      XFREE (MTYPE_TMP, cp);</a>
<a name="ln495"> </a>
<a name="ln496">      /* Get prefix length. */</a>
<a name="ln497">      plen = (u_char) atoi (++pnt);</a>
<a name="ln498">      if (plen &gt; IPV4_MAX_PREFIXLEN)</a>
<a name="ln499">	return 0;</a>
<a name="ln500"> </a>
<a name="ln501">      p-&gt;family = AF_INET;</a>
<a name="ln502">      p-&gt;prefixlen = plen;</a>
<a name="ln503">    }</a>
<a name="ln504"> </a>
<a name="ln505">  return ret;</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">/* When string format is invalid return 0. */</a>
<a name="ln509">int</a>
<a name="ln510">str2prefix_eth (const char *str, struct prefix_eth *p)</a>
<a name="ln511">{</a>
<a name="ln512">  int		ret = 0;</a>
<a name="ln513">  int		plen = 48;</a>
<a name="ln514">  char		*pnt;</a>
<a name="ln515">  char		*cp = NULL;</a>
<a name="ln516">  const char	*str_addr = str;</a>
<a name="ln517">  unsigned int	a[6];</a>
<a name="ln518">  int		i;</a>
<a name="ln519"> </a>
<a name="ln520">  /* Find slash inside string. */</a>
<a name="ln521">  pnt = strchr (str, '/');</a>
<a name="ln522"> </a>
<a name="ln523">  if (pnt)</a>
<a name="ln524">    {</a>
<a name="ln525">      /* Get prefix length. */</a>
<a name="ln526">      plen = (u_char) atoi (++pnt);</a>
<a name="ln527">      if (plen &gt; 48)</a>
<a name="ln528">	{</a>
<a name="ln529">	  ret = 0;</a>
<a name="ln530">	  goto done;</a>
<a name="ln531">	}</a>
<a name="ln532"> </a>
<a name="ln533">      cp = XMALLOC (MTYPE_TMP, (pnt - str) + 1);</a>
<a name="ln534">      strncpy (cp, str, pnt - str);</a>
<a name="ln535">      *(cp + (pnt - str)) = '\0';</a>
<a name="ln536"> </a>
<a name="ln537">      str_addr = cp;</a>
<a name="ln538">    }</a>
<a name="ln539"> </a>
<a name="ln540">  /* Convert string to prefix. */</a>
<a name="ln541">  if (sscanf(str_addr, &quot;%2x:%2x:%2x:%2x:%2x:%2x&quot;,</a>
<a name="ln542">    a+0, a+1, a+2, a+3, a+4, a+5) != 6)</a>
<a name="ln543">    {</a>
<a name="ln544">      ret = 0;</a>
<a name="ln545">      goto done;</a>
<a name="ln546">    }</a>
<a name="ln547">  for (i = 0; i &lt; 6; ++i)</a>
<a name="ln548">    {</a>
<a name="ln549">      p-&gt;eth_addr.octet[i] = a[i] &amp; 0xff;</a>
<a name="ln550">    }</a>
<a name="ln551">  p-&gt;prefixlen = plen;</a>
<a name="ln552">  p-&gt;family = AF_ETHERNET;</a>
<a name="ln553">  ret = 1;</a>
<a name="ln554"> </a>
<a name="ln555">done:</a>
<a name="ln556">  if (cp)</a>
<a name="ln557">    XFREE (MTYPE_TMP, cp);</a>
<a name="ln558"> </a>
<a name="ln559">  return ret;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">/* Convert masklen into IP address's netmask (network byte order). */</a>
<a name="ln563">void</a>
<a name="ln564">masklen2ip (const int masklen, struct in_addr *netmask)</a>
<a name="ln565">{</a>
<a name="ln566">  assert (masklen &gt;= 0 &amp;&amp; masklen &lt;= IPV4_MAX_BITLEN);</a>
<a name="ln567"> </a>
<a name="ln568">  /* left shift is only defined for less than the size of the type.</a>
<a name="ln569">   * we unconditionally use long long in case the target platform</a>
<a name="ln570">   * has defined behaviour for &lt;&lt; 32 (or has a 64-bit left shift) */</a>
<a name="ln571"> </a>
<a name="ln572">  if (sizeof(unsigned long long) &gt; 4)</a>
<a name="ln573">    netmask-&gt;s_addr = htonl(0xffffffffULL &lt;&lt; (32 - masklen));</a>
<a name="ln574">  else</a>
<a name="ln575">    netmask-&gt;s_addr = htonl(masklen ? 0xffffffffU &lt;&lt; (32 - masklen) : 0);</a>
<a name="ln576">}</a>
<a name="ln577"> </a>
<a name="ln578">/* Convert IP address's netmask into integer. We assume netmask is</a>
<a name="ln579">   sequential one. Argument netmask should be network byte order. */</a>
<a name="ln580">u_char</a>
<a name="ln581">ip_masklen (struct in_addr netmask)</a>
<a name="ln582">{</a>
<a name="ln583">  uint32_t tmp = ~ntohl(netmask.s_addr);</a>
<a name="ln584">  if (tmp)</a>
<a name="ln585">    /* clz: count leading zeroes. sadly, the behaviour of this builtin</a>
<a name="ln586">     * is undefined for a 0 argument, even though most CPUs give 32 */</a>
<a name="ln587">    return __builtin_clz(tmp);</a>
<a name="ln588">  else</a>
<a name="ln589">    return 32;</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">/* Apply mask to IPv4 prefix (network byte order). */</a>
<a name="ln593">void</a>
<a name="ln594">apply_mask_ipv4 (struct prefix_ipv4 *p)</a>
<a name="ln595">{</a>
<a name="ln596">  struct in_addr mask;</a>
<a name="ln597">  masklen2ip(p-&gt;prefixlen, &amp;mask);</a>
<a name="ln598">  p-&gt;prefix.s_addr &amp;= mask.s_addr;</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">/* If prefix is 0.0.0.0/0 then return 1 else return 0. */</a>
<a name="ln602">int</a>
<a name="ln603">prefix_ipv4_any (const struct prefix_ipv4 *p)</a>
<a name="ln604">{</a>
<a name="ln605">  return (p-&gt;prefix.s_addr == 0 &amp;&amp; p-&gt;prefixlen == 0);</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">#ifdef HAVE_IPV6</a>
<a name="ln609"> </a>
<a name="ln610">/* Allocate a new ip version 6 route */</a>
<a name="ln611">struct prefix_ipv6 *</a>
<a name="ln612">prefix_ipv6_new (void)</a>
<a name="ln613">{</a>
<a name="ln614">  struct prefix_ipv6 *p;</a>
<a name="ln615"> </a>
<a name="ln616">  /* Allocate a full-size struct prefix to avoid problems with structure</a>
<a name="ln617">     size mismatches. */</a>
<a name="ln618">  p = (struct prefix_ipv6 *)prefix_new();</a>
<a name="ln619">  p-&gt;family = AF_INET6;</a>
<a name="ln620">  return p;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">/* Free prefix for IPv6. */</a>
<a name="ln624">void</a>
<a name="ln625">prefix_ipv6_free (struct prefix_ipv6 *p)</a>
<a name="ln626">{</a>
<a name="ln627">  prefix_free((struct prefix *)p);</a>
<a name="ln628">}</a>
<a name="ln629"> </a>
<a name="ln630">/* If given string is valid return pin6 else return NULL */</a>
<a name="ln631">int</a>
<a name="ln632">str2prefix_ipv6 (const char *str, struct prefix_ipv6 *p)</a>
<a name="ln633">{</a>
<a name="ln634">  char *pnt;</a>
<a name="ln635">  char *cp;</a>
<a name="ln636">  int ret;</a>
<a name="ln637"> </a>
<a name="ln638">  pnt = strchr (str, '/');</a>
<a name="ln639"> </a>
<a name="ln640">  /* If string doesn't contain `/' treat it as host route. */</a>
<a name="ln641">  if (pnt == NULL) </a>
<a name="ln642">    {</a>
<a name="ln643">      ret = inet_pton (AF_INET6, str, &amp;p-&gt;prefix);</a>
<a name="ln644">      if (ret == 0)</a>
<a name="ln645">	return 0;</a>
<a name="ln646">      p-&gt;prefixlen = IPV6_MAX_BITLEN;</a>
<a name="ln647">    }</a>
<a name="ln648">  else </a>
<a name="ln649">    {</a>
<a name="ln650">      int plen;</a>
<a name="ln651"> </a>
<a name="ln652">      cp = XMALLOC (MTYPE_TMP, (pnt - str) + 1);</a>
<a name="ln653">      strncpy (cp, str, pnt - str);</a>
<a name="ln654">      *(cp + (pnt - str)) = '\0';</a>
<a name="ln655">      ret = inet_pton (AF_INET6, cp, &amp;p-&gt;prefix);</a>
<a name="ln656">      free (cp);</a>
<a name="ln657">      if (ret == 0)</a>
<a name="ln658">	return 0;</a>
<a name="ln659">      plen = (u_char) atoi (++pnt);</a>
<a name="ln660">      if (plen &gt; IPV6_MAX_BITLEN)</a>
<a name="ln661">	return 0;</a>
<a name="ln662">      p-&gt;prefixlen = plen;</a>
<a name="ln663">    }</a>
<a name="ln664">  p-&gt;family = AF_INET6;</a>
<a name="ln665"> </a>
<a name="ln666">  return ret;</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">/* Convert struct in6_addr netmask into integer.</a>
<a name="ln670"> * FIXME return u_char as ip_maskleni() does. */</a>
<a name="ln671">int</a>
<a name="ln672">ip6_masklen (struct in6_addr netmask)</a>
<a name="ln673">{</a>
<a name="ln674">  int len = 0;</a>
<a name="ln675">  unsigned char val;</a>
<a name="ln676">  unsigned char *pnt;</a>
<a name="ln677">  </a>
<a name="ln678">  pnt = (unsigned char *) &amp; netmask;</a>
<a name="ln679"> </a>
<a name="ln680">  while ((*pnt == 0xff) &amp;&amp; len &lt; IPV6_MAX_BITLEN)</a>
<a name="ln681">    {</a>
<a name="ln682">      len += 8;</a>
<a name="ln683">      pnt++;</a>
<a name="ln684">    } </a>
<a name="ln685">  </a>
<a name="ln686">  if (len &lt; IPV6_MAX_BITLEN)</a>
<a name="ln687">    {</a>
<a name="ln688">      val = *pnt;</a>
<a name="ln689">      while (val) </a>
<a name="ln690">	{</a>
<a name="ln691">	  len++;</a>
<a name="ln692">	  val &lt;&lt;= 1;</a>
<a name="ln693">	}</a>
<a name="ln694">    }</a>
<a name="ln695">  return len;</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">void</a>
<a name="ln699">masklen2ip6 (const int masklen, struct in6_addr *netmask)</a>
<a name="ln700">{</a>
<a name="ln701">  assert (masklen &gt;= 0 &amp;&amp; masklen &lt;= IPV6_MAX_BITLEN);</a>
<a name="ln702">  memcpy (netmask, maskbytes6 + masklen, sizeof (struct in6_addr));</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">void</a>
<a name="ln706">apply_mask_ipv6 (struct prefix_ipv6 *p)</a>
<a name="ln707">{</a>
<a name="ln708">  u_char *pnt;</a>
<a name="ln709">  int index;</a>
<a name="ln710">  int offset;</a>
<a name="ln711"> </a>
<a name="ln712">  index = p-&gt;prefixlen / 8;</a>
<a name="ln713"> </a>
<a name="ln714">  if (index &lt; 16)</a>
<a name="ln715">    {</a>
<a name="ln716">      pnt = (u_char *) &amp;p-&gt;prefix;</a>
<a name="ln717">      offset = p-&gt;prefixlen % 8;</a>
<a name="ln718"> </a>
<a name="ln719">      pnt[index] &amp;= maskbit[offset];</a>
<a name="ln720">      index++;</a>
<a name="ln721"> </a>
<a name="ln722">      while (index &lt; 16)</a>
<a name="ln723">	pnt[index++] = 0;</a>
<a name="ln724">    }</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">void</a>
<a name="ln728">str2in6_addr (const char *str, struct in6_addr *addr)</a>
<a name="ln729">{</a>
<a name="ln730">  int i;</a>
<a name="ln731">  unsigned int x;</a>
<a name="ln732"> </a>
<a name="ln733">  /* %x must point to unsinged int */</a>
<a name="ln734">  for (i = 0; i &lt; 16; i++)</a>
<a name="ln735">    {</a>
<a name="ln736">      sscanf (str + (i * 2), &quot;%02x&quot;, &amp;x);</a>
<a name="ln737">      addr-&gt;s6_addr[i] = x &amp; 0xff;</a>
<a name="ln738">    }</a>
<a name="ln739">}</a>
<a name="ln740">#endif /* HAVE_IPV6 */</a>
<a name="ln741"> </a>
<a name="ln742">void</a>
<a name="ln743">apply_mask (struct prefix *p)</a>
<a name="ln744">{</a>
<a name="ln745">  switch (p-&gt;family)</a>
<a name="ln746">    {</a>
<a name="ln747">      case AF_INET:</a>
<a name="ln748">        apply_mask_ipv4 ((struct prefix_ipv4 *)p);</a>
<a name="ln749">        break;</a>
<a name="ln750">#ifdef HAVE_IPV6</a>
<a name="ln751">      case AF_INET6:</a>
<a name="ln752">        apply_mask_ipv6 ((struct prefix_ipv6 *)p);</a>
<a name="ln753">        break;</a>
<a name="ln754">#endif /* HAVE_IPV6 */</a>
<a name="ln755">      default:</a>
<a name="ln756">        break;</a>
<a name="ln757">    }</a>
<a name="ln758">  return;</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">/* Utility function of convert between struct prefix &lt;=&gt; union sockunion.</a>
<a name="ln762"> * FIXME This function isn't used anywhere. */</a>
<a name="ln763">struct prefix *</a>
<a name="ln764">sockunion2prefix (const union sockunion *dest,</a>
<a name="ln765">		  const union sockunion *mask)</a>
<a name="ln766">{</a>
<a name="ln767">  if (dest-&gt;sa.sa_family == AF_INET)</a>
<a name="ln768">    {</a>
<a name="ln769">      struct prefix_ipv4 *p;</a>
<a name="ln770"> </a>
<a name="ln771">      p = prefix_ipv4_new ();</a>
<a name="ln772">      p-&gt;family = AF_INET;</a>
<a name="ln773">      p-&gt;prefix = dest-&gt;sin.sin_addr;</a>
<a name="ln774">      p-&gt;prefixlen = ip_masklen (mask-&gt;sin.sin_addr);</a>
<a name="ln775">      return (struct prefix *) p;</a>
<a name="ln776">    }</a>
<a name="ln777">#ifdef HAVE_IPV6</a>
<a name="ln778">  if (dest-&gt;sa.sa_family == AF_INET6)</a>
<a name="ln779">    {</a>
<a name="ln780">      struct prefix_ipv6 *p;</a>
<a name="ln781"> </a>
<a name="ln782">      p = prefix_ipv6_new ();</a>
<a name="ln783">      p-&gt;family = AF_INET6;</a>
<a name="ln784">      p-&gt;prefixlen = ip6_masklen (mask-&gt;sin6.sin6_addr);</a>
<a name="ln785">      memcpy (&amp;p-&gt;prefix, &amp;dest-&gt;sin6.sin6_addr, sizeof (struct in6_addr));</a>
<a name="ln786">      return (struct prefix *) p;</a>
<a name="ln787">    }</a>
<a name="ln788">#endif /* HAVE_IPV6 */</a>
<a name="ln789">  return NULL;</a>
<a name="ln790">}</a>
<a name="ln791"> </a>
<a name="ln792">/* Utility function of convert between struct prefix &lt;=&gt; union sockunion. */</a>
<a name="ln793">struct prefix *</a>
<a name="ln794">sockunion2hostprefix (const union sockunion *su, struct prefix *prefix)</a>
<a name="ln795">{</a>
<a name="ln796">  if (su-&gt;sa.sa_family == AF_INET)</a>
<a name="ln797">    {</a>
<a name="ln798">      struct prefix_ipv4 *p;</a>
<a name="ln799"> </a>
<a name="ln800">      p = prefix ? (struct prefix_ipv4 *) prefix : prefix_ipv4_new ();</a>
<a name="ln801">      p-&gt;family = AF_INET;</a>
<a name="ln802">      p-&gt;prefix = su-&gt;sin.sin_addr;</a>
<a name="ln803">      p-&gt;prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln804">      return (struct prefix *) p;</a>
<a name="ln805">    }</a>
<a name="ln806">#ifdef HAVE_IPV6</a>
<a name="ln807">  if (su-&gt;sa.sa_family == AF_INET6)</a>
<a name="ln808">    {</a>
<a name="ln809">      struct prefix_ipv6 *p;</a>
<a name="ln810"> </a>
<a name="ln811">      p = prefix ? (struct prefix_ipv6 *) prefix : prefix_ipv6_new ();</a>
<a name="ln812">      p-&gt;family = AF_INET6;</a>
<a name="ln813">      p-&gt;prefixlen = IPV6_MAX_BITLEN;</a>
<a name="ln814">      memcpy (&amp;p-&gt;prefix, &amp;su-&gt;sin6.sin6_addr, sizeof (struct in6_addr));</a>
<a name="ln815">      return (struct prefix *) p;</a>
<a name="ln816">    }</a>
<a name="ln817">#endif /* HAVE_IPV6 */</a>
<a name="ln818">  return NULL;</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">void</a>
<a name="ln822">prefix2sockunion (const struct prefix *p, union sockunion *su)</a>
<a name="ln823">{</a>
<a name="ln824">  memset (su, 0, sizeof (*su));</a>
<a name="ln825"> </a>
<a name="ln826">  su-&gt;sa.sa_family = p-&gt;family;</a>
<a name="ln827">  if (p-&gt;family == AF_INET)</a>
<a name="ln828">    su-&gt;sin.sin_addr = p-&gt;u.prefix4;</a>
<a name="ln829">#ifdef HAVE_IPV6</a>
<a name="ln830">  if (p-&gt;family == AF_INET6)</a>
<a name="ln831">    memcpy (&amp;su-&gt;sin6.sin6_addr, &amp;p-&gt;u.prefix6, sizeof (struct in6_addr));</a>
<a name="ln832">#endif /* HAVE_IPV6 */</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">int</a>
<a name="ln836">prefix_blen (const struct prefix *p)</a>
<a name="ln837">{</a>
<a name="ln838">  switch (p-&gt;family) </a>
<a name="ln839">    {</a>
<a name="ln840">    case AF_INET:</a>
<a name="ln841">      return IPV4_MAX_BYTELEN;</a>
<a name="ln842">      break;</a>
<a name="ln843">#ifdef HAVE_IPV6</a>
<a name="ln844">    case AF_INET6:</a>
<a name="ln845">      return IPV6_MAX_BYTELEN;</a>
<a name="ln846">      break;</a>
<a name="ln847">#endif /* HAVE_IPV6 */</a>
<a name="ln848">    case AF_ETHERNET:</a>
<a name="ln849">      return ETHER_ADDR_LEN;</a>
<a name="ln850">    }</a>
<a name="ln851">  return 0;</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">/* Generic function for conversion string to struct prefix. */</a>
<a name="ln855">int</a>
<a name="ln856">str2prefix (const char *str, struct prefix *p)</a>
<a name="ln857">{</a>
<a name="ln858">  int ret;</a>
<a name="ln859"> </a>
<a name="ln860">  /* First we try to convert string to struct prefix_ipv4. */</a>
<a name="ln861">  ret = str2prefix_ipv4 (str, (struct prefix_ipv4 *) p);</a>
<a name="ln862">  if (ret)</a>
<a name="ln863">    return ret;</a>
<a name="ln864"> </a>
<a name="ln865">#ifdef HAVE_IPV6</a>
<a name="ln866">  /* Next we try to convert string to struct prefix_ipv6. */</a>
<a name="ln867">  ret = str2prefix_ipv6 (str, (struct prefix_ipv6 *) p);</a>
<a name="ln868">  if (ret)</a>
<a name="ln869">    return ret;</a>
<a name="ln870">#endif /* HAVE_IPV6 */</a>
<a name="ln871"> </a>
<a name="ln872">  /* Next we try to convert string to struct prefix_eth. */</a>
<a name="ln873">  ret = str2prefix_eth (str, (struct prefix_eth *) p);</a>
<a name="ln874">  if (ret)</a>
<a name="ln875">    return ret;</a>
<a name="ln876"> </a>
<a name="ln877">  return 0;</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">const char *</a>
<a name="ln881">prefix2str (union prefix46constptr pu, char *str, int size)</a>
<a name="ln882">{</a>
<a name="ln883">  const struct prefix *p = pu.p;</a>
<a name="ln884">  char buf[BUFSIZ];</a>
<a name="ln885"> </a>
<a name="ln886">  if (p-&gt;family == AF_ETHERNET) {</a>
<a name="ln887">    int		i;</a>
<a name="ln888">    char	*s = str;</a>
<a name="ln889"> </a>
<a name="ln890">    assert(size &gt; (3*ETHER_ADDR_LEN) + 1 /* slash */ + 3 /* plen */ );</a>
<a name="ln891">    for (i = 0; i &lt; ETHER_ADDR_LEN; ++i) {</a>
<a name="ln892">	sprintf(s, &quot;%02x&quot;, p-&gt;u.prefix_eth.octet[i]);</a>
<a name="ln893">	if (i &lt; (ETHER_ADDR_LEN - 1)) {</a>
<a name="ln894">	    *(s+2) = ':';</a>
<a name="ln895">	    s += 3;</a>
<a name="ln896">	} else {</a>
<a name="ln897">	    s += 2;</a>
<a name="ln898">	}</a>
<a name="ln899">    }</a>
<a name="ln900">    sprintf(s, &quot;/%d&quot;, p-&gt;prefixlen);</a>
<a name="ln901">    return 0;</a>
<a name="ln902">  }</a>
<a name="ln903"> </a>
<a name="ln904">  inet_ntop (p-&gt;family, &amp;p-&gt;u.prefix, buf, BUFSIZ);</a>
<a name="ln905">  snprintf (str, size, &quot;%s/%d&quot;, buf, p-&gt;prefixlen);</a>
<a name="ln906">  return str;</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">struct prefix *</a>
<a name="ln910">prefix_new ()</a>
<a name="ln911">{</a>
<a name="ln912">  struct prefix *p;</a>
<a name="ln913"> </a>
<a name="ln914">  p = XCALLOC (MTYPE_PREFIX, sizeof *p);</a>
<a name="ln915">  return p;</a>
<a name="ln916">}</a>
<a name="ln917"> </a>
<a name="ln918">/* Free prefix structure. */</a>
<a name="ln919">void</a>
<a name="ln920">prefix_free (struct prefix *p)</a>
<a name="ln921">{</a>
<a name="ln922">  XFREE (MTYPE_PREFIX, p);</a>
<a name="ln923">}</a>
<a name="ln924"> </a>
<a name="ln925">/* Utility function.  Check the string only contains digit</a>
<a name="ln926"> * character.</a>
<a name="ln927"> * FIXME str.[c|h] would be better place for this function. */</a>
<a name="ln928">int</a>
<a name="ln929">all_digit (const char *str)</a>
<a name="ln930">{</a>
<a name="ln931">  for (; *str != '\0'; str++)</a>
<a name="ln932">    if (!isdigit ((int) *str))</a>
<a name="ln933">      return 0;</a>
<a name="ln934">  return 1;</a>
<a name="ln935">}</a>
<a name="ln936"> </a>
<a name="ln937">/* Utility function to convert ipv4 prefixes to Classful prefixes */</a>
<a name="ln938">void apply_classful_mask_ipv4 (struct prefix_ipv4 *p)</a>
<a name="ln939">{</a>
<a name="ln940"> </a>
<a name="ln941">  u_int32_t destination;</a>
<a name="ln942">  </a>
<a name="ln943">  destination = ntohl (p-&gt;prefix.s_addr);</a>
<a name="ln944">  </a>
<a name="ln945">  if (p-&gt;prefixlen == IPV4_MAX_PREFIXLEN);</a>
<a name="ln946">  /* do nothing for host routes */</a>
<a name="ln947">  else if (IN_CLASSC (destination)) </a>
<a name="ln948">    {</a>
<a name="ln949">      p-&gt;prefixlen=24;</a>
<a name="ln950">      apply_mask_ipv4(p);</a>
<a name="ln951">    }</a>
<a name="ln952">  else if (IN_CLASSB(destination)) </a>
<a name="ln953">    {</a>
<a name="ln954">      p-&gt;prefixlen=16;</a>
<a name="ln955">      apply_mask_ipv4(p);</a>
<a name="ln956">    }</a>
<a name="ln957">  else </a>
<a name="ln958">    {</a>
<a name="ln959">      p-&gt;prefixlen=8;</a>
<a name="ln960">      apply_mask_ipv4(p);</a>
<a name="ln961">    }</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">in_addr_t</a>
<a name="ln965">ipv4_network_addr (in_addr_t hostaddr, int masklen)</a>
<a name="ln966">{</a>
<a name="ln967">  struct in_addr mask;</a>
<a name="ln968"> </a>
<a name="ln969">  masklen2ip (masklen, &amp;mask);</a>
<a name="ln970">  return hostaddr &amp; mask.s_addr;</a>
<a name="ln971">}</a>
<a name="ln972"> </a>
<a name="ln973">in_addr_t</a>
<a name="ln974">ipv4_broadcast_addr (in_addr_t hostaddr, int masklen)</a>
<a name="ln975">{</a>
<a name="ln976">  struct in_addr mask;</a>
<a name="ln977"> </a>
<a name="ln978">  masklen2ip (masklen, &amp;mask);</a>
<a name="ln979">  return (masklen != IPV4_MAX_PREFIXLEN-1) ?</a>
<a name="ln980">	 /* normal case */</a>
<a name="ln981">         (hostaddr | ~mask.s_addr) :</a>
<a name="ln982">	 /* special case for /31 */</a>
<a name="ln983">         (hostaddr ^ ~mask.s_addr);</a>
<a name="ln984">}</a>
<a name="ln985"> </a>
<a name="ln986">/* Utility function to convert ipv4 netmask to prefixes </a>
<a name="ln987">   ex.) &quot;1.1.0.0&quot; &quot;255.255.0.0&quot; =&gt; &quot;1.1.0.0/16&quot;</a>
<a name="ln988">   ex.) &quot;1.0.0.0&quot; NULL =&gt; &quot;1.0.0.0/8&quot;                   */</a>
<a name="ln989">int</a>
<a name="ln990">netmask_str2prefix_str (const char *net_str, const char *mask_str,</a>
<a name="ln991">			char *prefix_str)</a>
<a name="ln992">{</a>
<a name="ln993">  struct in_addr network;</a>
<a name="ln994">  struct in_addr mask;</a>
<a name="ln995">  u_char prefixlen;</a>
<a name="ln996">  u_int32_t destination;</a>
<a name="ln997">  int ret;</a>
<a name="ln998"> </a>
<a name="ln999">  ret = inet_aton (net_str, &amp;network);</a>
<a name="ln1000">  if (! ret)</a>
<a name="ln1001">    return 0;</a>
<a name="ln1002"> </a>
<a name="ln1003">  if (mask_str)</a>
<a name="ln1004">    {</a>
<a name="ln1005">      ret = inet_aton (mask_str, &amp;mask);</a>
<a name="ln1006">      if (! ret)</a>
<a name="ln1007">        return 0;</a>
<a name="ln1008"> </a>
<a name="ln1009">      prefixlen = ip_masklen (mask);</a>
<a name="ln1010">    }</a>
<a name="ln1011">  else </a>
<a name="ln1012">    {</a>
<a name="ln1013">      destination = ntohl (network.s_addr);</a>
<a name="ln1014"> </a>
<a name="ln1015">      if (network.s_addr == 0)</a>
<a name="ln1016">	prefixlen = 0;</a>
<a name="ln1017">      else if (IN_CLASSC (destination))</a>
<a name="ln1018">	prefixlen = 24;</a>
<a name="ln1019">      else if (IN_CLASSB (destination))</a>
<a name="ln1020">	prefixlen = 16;</a>
<a name="ln1021">      else if (IN_CLASSA (destination))</a>
<a name="ln1022">	prefixlen = 8;</a>
<a name="ln1023">      else</a>
<a name="ln1024">	return 0;</a>
<a name="ln1025">    }</a>
<a name="ln1026"> </a>
<a name="ln1027">  sprintf (prefix_str, &quot;%s/%d&quot;, net_str, prefixlen);</a>
<a name="ln1028"> </a>
<a name="ln1029">  return 1;</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">#ifdef HAVE_IPV6</a>
<a name="ln1033">/* Utility function for making IPv6 address string. */</a>
<a name="ln1034">const char *</a>
<a name="ln1035">inet6_ntoa (struct in6_addr addr)</a>
<a name="ln1036">{</a>
<a name="ln1037">  static char buf[INET6_ADDRSTRLEN];</a>
<a name="ln1038"> </a>
<a name="ln1039">  inet_ntop (AF_INET6, &amp;addr, buf, INET6_ADDRSTRLEN);</a>
<a name="ln1040">  return buf;</a>
<a name="ln1041">}</a>
<a name="ln1042">#endif /* HAVE_IPV6 */</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
