
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_asbr.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF AS Boundary Router functions.</a>
<a name="ln3"> * Copyright (C) 1999, 2000 Kunihiro Ishiguro, Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;table.h&quot;</a>
<a name="ln31">#include &quot;vty.h&quot;</a>
<a name="ln32">#include &quot;filter.h&quot;</a>
<a name="ln33">#include &quot;log.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln36">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">/* Remove external route. */</a>
<a name="ln49">void</a>
<a name="ln50">ospf_external_route_remove (struct ospf *ospf, struct prefix_ipv4 *p)</a>
<a name="ln51">{</a>
<a name="ln52">  struct route_node *rn;</a>
<a name="ln53">  struct ospf_route *or;</a>
<a name="ln54"> </a>
<a name="ln55">  rn = route_node_lookup (ospf-&gt;old_external_route, (struct prefix *) p);</a>
<a name="ln56">  if (rn)</a>
<a name="ln57">    if ((or = rn-&gt;info))</a>
<a name="ln58">      {</a>
<a name="ln59">	zlog_info (&quot;Route[%s/%d]: external path deleted&quot;,</a>
<a name="ln60">		   inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln61"> </a>
<a name="ln62">	/* Remove route from zebra. */</a>
<a name="ln63">        if (or-&gt;type == OSPF_DESTINATION_NETWORK)</a>
<a name="ln64">	  ospf_zebra_delete ((struct prefix_ipv4 *) &amp;rn-&gt;p, or);</a>
<a name="ln65"> </a>
<a name="ln66">	ospf_route_free (or);</a>
<a name="ln67">	rn-&gt;info = NULL;</a>
<a name="ln68"> </a>
<a name="ln69">	route_unlock_node (rn);</a>
<a name="ln70">	route_unlock_node (rn);</a>
<a name="ln71">	return;</a>
<a name="ln72">      }</a>
<a name="ln73"> </a>
<a name="ln74">  zlog_info (&quot;Route[%s/%d]: no such external path&quot;,</a>
<a name="ln75">	     inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">/* Lookup external route. */</a>
<a name="ln79">struct ospf_route *</a>
<a name="ln80">ospf_external_route_lookup (struct ospf *ospf,</a>
<a name="ln81">			    struct prefix_ipv4 *p)</a>
<a name="ln82">{</a>
<a name="ln83">  struct route_node *rn;</a>
<a name="ln84"> </a>
<a name="ln85">  rn = route_node_lookup (ospf-&gt;old_external_route, (struct prefix *) p);</a>
<a name="ln86">  if (rn)</a>
<a name="ln87">    {</a>
<a name="ln88">      route_unlock_node (rn);</a>
<a name="ln89">      if (rn-&gt;info)</a>
<a name="ln90">	return rn-&gt;info;</a>
<a name="ln91">    }</a>
<a name="ln92"> </a>
<a name="ln93">  zlog_warn (&quot;Route[%s/%d]: lookup, no such prefix&quot;,</a>
<a name="ln94">	     inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln95"> </a>
<a name="ln96">  return NULL;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99"> </a>
<a name="ln100">/* Add an External info for AS-external-LSA. */</a>
<a name="ln101">struct external_info *</a>
<a name="ln102">ospf_external_info_new (u_char type)</a>
<a name="ln103">{</a>
<a name="ln104">  struct external_info *new;</a>
<a name="ln105"> </a>
<a name="ln106">  new = (struct external_info *)</a>
<a name="ln107">    XCALLOC (MTYPE_OSPF_EXTERNAL_INFO, sizeof (struct external_info));</a>
<a name="ln108">  new-&gt;type = type;</a>
<a name="ln109"> </a>
<a name="ln110">  ospf_reset_route_map_set_values (&amp;new-&gt;route_map_set);</a>
<a name="ln111">  return new;</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">static void</a>
<a name="ln115">ospf_external_info_free (struct external_info *ei)</a>
<a name="ln116">{</a>
<a name="ln117">  XFREE (MTYPE_OSPF_EXTERNAL_INFO, ei);</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">void</a>
<a name="ln121">ospf_reset_route_map_set_values (struct route_map_set_values *values)</a>
<a name="ln122">{</a>
<a name="ln123">  values-&gt;metric = -1;</a>
<a name="ln124">  values-&gt;metric_type = -1;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">int</a>
<a name="ln128">ospf_route_map_set_compare (struct route_map_set_values *values1,</a>
<a name="ln129">			    struct route_map_set_values *values2)</a>
<a name="ln130">{</a>
<a name="ln131">  return values1-&gt;metric == values2-&gt;metric &amp;&amp;</a>
<a name="ln132">    values1-&gt;metric_type == values2-&gt;metric_type;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">/* Add an External info for AS-external-LSA. */</a>
<a name="ln136">struct external_info *</a>
<a name="ln137">ospf_external_info_add (u_char type, struct prefix_ipv4 p,</a>
<a name="ln138">			ifindex_t ifindex, struct in_addr nexthop,</a>
<a name="ln139">                        route_tag_t tag)</a>
<a name="ln140">{</a>
<a name="ln141">  struct external_info *new;</a>
<a name="ln142">  struct route_node *rn;</a>
<a name="ln143"> </a>
<a name="ln144">  /* Initialize route table. */</a>
<a name="ln145">  if (EXTERNAL_INFO (type) == NULL)</a>
<a name="ln146">    EXTERNAL_INFO (type) = route_table_init ();</a>
<a name="ln147"> </a>
<a name="ln148">  rn = route_node_get (EXTERNAL_INFO (type), (struct prefix *) &amp;p);</a>
<a name="ln149">  /* If old info exists, -- discard new one or overwrite with new one? */</a>
<a name="ln150">  if (rn)</a>
<a name="ln151">    if (rn-&gt;info)</a>
<a name="ln152">      {</a>
<a name="ln153">	route_unlock_node (rn);</a>
<a name="ln154">	zlog_warn (&quot;Redistribute[%s]: %s/%d already exists, discard.&quot;,</a>
<a name="ln155">		   ospf_redist_string(type),</a>
<a name="ln156">		   inet_ntoa (p.prefix), p.prefixlen);</a>
<a name="ln157">	/* XFREE (MTYPE_OSPF_TMP, rn-&gt;info); */</a>
<a name="ln158">	return rn-&gt;info;</a>
<a name="ln159">      }</a>
<a name="ln160"> </a>
<a name="ln161">  /* Create new External info instance. */</a>
<a name="ln162">  new = ospf_external_info_new (type);</a>
<a name="ln163">  new-&gt;p = p;</a>
<a name="ln164">  new-&gt;ifindex = ifindex;</a>
<a name="ln165">  new-&gt;nexthop = nexthop;</a>
<a name="ln166">  new-&gt;tag = tag;</a>
<a name="ln167"> </a>
<a name="ln168">  if (rn)</a>
<a name="ln169">    rn-&gt;info = new;</a>
<a name="ln170"> </a>
<a name="ln171">  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))</a>
<a name="ln172">    zlog_debug (&quot;Redistribute[%s]: %s/%d external info created.&quot;,</a>
<a name="ln173">	       ospf_redist_string(type),</a>
<a name="ln174">	       inet_ntoa (p.prefix), p.prefixlen);</a>
<a name="ln175">  return new;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">void</a>
<a name="ln179">ospf_external_info_delete (u_char type, struct prefix_ipv4 p)</a>
<a name="ln180">{</a>
<a name="ln181">  struct route_node *rn;</a>
<a name="ln182"> </a>
<a name="ln183">  rn = route_node_lookup (EXTERNAL_INFO (type), (struct prefix *) &amp;p);</a>
<a name="ln184">  if (rn)</a>
<a name="ln185">    {</a>
<a name="ln186">      ospf_external_info_free (rn-&gt;info);</a>
<a name="ln187">      rn-&gt;info = NULL;</a>
<a name="ln188">      route_unlock_node (rn);</a>
<a name="ln189">      route_unlock_node (rn);</a>
<a name="ln190">    }</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">struct external_info *</a>
<a name="ln194">ospf_external_info_lookup (u_char type, struct prefix_ipv4 *p)</a>
<a name="ln195">{</a>
<a name="ln196">  struct route_node *rn;</a>
<a name="ln197">  rn = route_node_lookup (EXTERNAL_INFO (type), (struct prefix *) p);</a>
<a name="ln198">  if (rn)</a>
<a name="ln199">    {</a>
<a name="ln200">      route_unlock_node (rn);</a>
<a name="ln201">      if (rn-&gt;info)</a>
<a name="ln202">	return rn-&gt;info;</a>
<a name="ln203">    }</a>
<a name="ln204"> </a>
<a name="ln205">  return NULL;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">struct ospf_lsa *</a>
<a name="ln209">ospf_external_info_find_lsa (struct ospf *ospf,</a>
<a name="ln210">			     struct prefix_ipv4 *p)</a>
<a name="ln211">{</a>
<a name="ln212">  struct ospf_lsa *lsa;</a>
<a name="ln213">  struct as_external_lsa *al;</a>
<a name="ln214">  struct in_addr mask, id;</a>
<a name="ln215"> </a>
<a name="ln216">  lsa = ospf_lsdb_lookup_by_id (ospf-&gt;lsdb, OSPF_AS_EXTERNAL_LSA,</a>
<a name="ln217">				p-&gt;prefix, ospf-&gt;router_id);</a>
<a name="ln218"> </a>
<a name="ln219">  if (!lsa)</a>
<a name="ln220">    return NULL;</a>
<a name="ln221"> </a>
<a name="ln222">  al = (struct as_external_lsa *) lsa-&gt;data;</a>
<a name="ln223"> </a>
<a name="ln224">  masklen2ip (p-&gt;prefixlen, &amp;mask);</a>
<a name="ln225"> </a>
<a name="ln226">  if (mask.s_addr != al-&gt;mask.s_addr)</a>
<a name="ln227">    {</a>
<a name="ln228">      id.s_addr = p-&gt;prefix.s_addr | (~mask.s_addr);</a>
<a name="ln229">      lsa = ospf_lsdb_lookup_by_id (ospf-&gt;lsdb, OSPF_AS_EXTERNAL_LSA,</a>
<a name="ln230">				   id, ospf-&gt;router_id);</a>
<a name="ln231">      if (!lsa)</a>
<a name="ln232">	return NULL;</a>
<a name="ln233">    }</a>
<a name="ln234"> </a>
<a name="ln235">  return lsa;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238"> </a>
<a name="ln239">/* Update ASBR status. */</a>
<a name="ln240">void</a>
<a name="ln241">ospf_asbr_status_update (struct ospf *ospf, u_char status)</a>
<a name="ln242">{</a>
<a name="ln243">  zlog_info (&quot;ASBR[Status:%d]: Update&quot;, status);</a>
<a name="ln244"> </a>
<a name="ln245">  /* ASBR on. */</a>
<a name="ln246">  if (status)</a>
<a name="ln247">    {</a>
<a name="ln248">      /* Already ASBR. */</a>
<a name="ln249">      if (IS_OSPF_ASBR (ospf))</a>
<a name="ln250">	{</a>
<a name="ln251">	  zlog_info (&quot;ASBR[Status:%d]: Already ASBR&quot;, status);</a>
<a name="ln252">	  return;</a>
<a name="ln253">	}</a>
<a name="ln254">      SET_FLAG (ospf-&gt;flags, OSPF_FLAG_ASBR);</a>
<a name="ln255">    }</a>
<a name="ln256">  else</a>
<a name="ln257">    {</a>
<a name="ln258">      /* Already non ASBR. */</a>
<a name="ln259">      if (! IS_OSPF_ASBR (ospf))</a>
<a name="ln260">	{</a>
<a name="ln261">	  zlog_info (&quot;ASBR[Status:%d]: Already non ASBR&quot;, status);</a>
<a name="ln262">	  return;</a>
<a name="ln263">	}</a>
<a name="ln264">      UNSET_FLAG (ospf-&gt;flags, OSPF_FLAG_ASBR);</a>
<a name="ln265">    }</a>
<a name="ln266"> </a>
<a name="ln267">  /* Transition from/to status ASBR, schedule timer. */</a>
<a name="ln268">  ospf_spf_calculate_schedule (ospf, SPF_FLAG_ASBR_STATUS_CHANGE);</a>
<a name="ln269">  ospf_router_lsa_update (ospf);</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">void</a>
<a name="ln273">ospf_redistribute_withdraw (struct ospf *ospf, u_char type)</a>
<a name="ln274">{</a>
<a name="ln275">  struct route_node *rn;</a>
<a name="ln276">  struct external_info *ei;</a>
<a name="ln277"> </a>
<a name="ln278">  /* Delete external info for specified type. */</a>
<a name="ln279">  if (EXTERNAL_INFO (type))</a>
<a name="ln280">    for (rn = route_top (EXTERNAL_INFO (type)); rn; rn = route_next (rn))</a>
<a name="ln281">      if ((ei = rn-&gt;info))</a>
<a name="ln282">	if (ospf_external_info_find_lsa (ospf, &amp;ei-&gt;p))</a>
<a name="ln283">	  {</a>
<a name="ln284">	    if (is_prefix_default (&amp;ei-&gt;p) &amp;&amp;</a>
<a name="ln285">		ospf-&gt;default_originate != DEFAULT_ORIGINATE_NONE)</a>
<a name="ln286">	      continue;</a>
<a name="ln287">	    ospf_external_lsa_flush (ospf, type, &amp;ei-&gt;p,</a>
<a name="ln288">				     ei-&gt;ifindex /*, ei-&gt;nexthop */);</a>
<a name="ln289"> </a>
<a name="ln290">	    ospf_external_info_free (ei);</a>
<a name="ln291">	    route_unlock_node (rn);</a>
<a name="ln292">	    rn-&gt;info = NULL;</a>
<a name="ln293">	  }</a>
<a name="ln294">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
