
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_zlookup.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24">#include &quot;zebra/rib.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;log.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;zclient.h&quot;</a>
<a name="ln29">#include &quot;stream.h&quot;</a>
<a name="ln30">#include &quot;network.h&quot;</a>
<a name="ln31">#include &quot;thread.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;pimd.h&quot;</a>
<a name="ln34">#include &quot;pim_pim.h&quot;</a>
<a name="ln35">#include &quot;pim_str.h&quot;</a>
<a name="ln36">#include &quot;pim_zlookup.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">extern int zclient_debug;</a>
<a name="ln39"> </a>
<a name="ln40">static void zclient_lookup_sched(struct zclient *zlookup, int delay);</a>
<a name="ln41"> </a>
<a name="ln42">/* Connect to zebra for nexthop lookup. */</a>
<a name="ln43">static int zclient_lookup_connect(struct thread *t)</a>
<a name="ln44">{</a>
<a name="ln45">  struct zclient *zlookup;</a>
<a name="ln46"> </a>
<a name="ln47">  zlookup = THREAD_ARG(t);</a>
<a name="ln48">  zlookup-&gt;t_connect = NULL;</a>
<a name="ln49"> </a>
<a name="ln50">  if (zlookup-&gt;sock &gt;= 0) {</a>
<a name="ln51">    return 0;</a>
<a name="ln52">  }</a>
<a name="ln53"> </a>
<a name="ln54">  if (zclient_socket_connect(zlookup) &lt; 0) {</a>
<a name="ln55">    ++zlookup-&gt;fail;</a>
<a name="ln56">    zlog_warn(&quot;%s: failure connecting zclient socket: failures=%d&quot;,</a>
<a name="ln57">	      __PRETTY_FUNCTION__, zlookup-&gt;fail);</a>
<a name="ln58">  }</a>
<a name="ln59">  else {</a>
<a name="ln60">    zlookup-&gt;fail = 0; /* reset counter on connection */</a>
<a name="ln61">  }</a>
<a name="ln62"> </a>
<a name="ln63">  zassert(!zlookup-&gt;t_connect);</a>
<a name="ln64">  if (zlookup-&gt;sock &lt; 0) {</a>
<a name="ln65">    /* Since last connect failed, retry within 10 secs */</a>
<a name="ln66">    zclient_lookup_sched(zlookup, 10);</a>
<a name="ln67">    return -1;</a>
<a name="ln68">  }</a>
<a name="ln69"> </a>
<a name="ln70">  return 0;</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">/* Schedule connection with delay. */</a>
<a name="ln74">static void zclient_lookup_sched(struct zclient *zlookup, int delay)</a>
<a name="ln75">{</a>
<a name="ln76">  zassert(!zlookup-&gt;t_connect);</a>
<a name="ln77"> </a>
<a name="ln78">  THREAD_TIMER_ON(master, zlookup-&gt;t_connect,</a>
<a name="ln79">		  zclient_lookup_connect,</a>
<a name="ln80">		  zlookup, delay);</a>
<a name="ln81"> </a>
<a name="ln82">  zlog_notice(&quot;%s: zclient lookup connection scheduled for %d seconds&quot;,</a>
<a name="ln83">	      __PRETTY_FUNCTION__, delay);</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">/* Schedule connection for now. */</a>
<a name="ln87">static void zclient_lookup_sched_now(struct zclient *zlookup)</a>
<a name="ln88">{</a>
<a name="ln89">  zassert(!zlookup-&gt;t_connect);</a>
<a name="ln90"> </a>
<a name="ln91">  zlookup-&gt;t_connect = thread_add_event(master, zclient_lookup_connect,</a>
<a name="ln92">					zlookup, 0);</a>
<a name="ln93"> </a>
<a name="ln94">  zlog_notice(&quot;%s: zclient lookup immediate connection scheduled&quot;,</a>
<a name="ln95">	      __PRETTY_FUNCTION__);</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">/* Schedule reconnection, if needed. */</a>
<a name="ln99">static void zclient_lookup_reconnect(struct zclient *zlookup)</a>
<a name="ln100">{</a>
<a name="ln101">  if (zlookup-&gt;t_connect) {</a>
<a name="ln102">    return;</a>
<a name="ln103">  }</a>
<a name="ln104"> </a>
<a name="ln105">  zclient_lookup_sched_now(zlookup);</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">static void zclient_lookup_failed(struct zclient *zlookup)</a>
<a name="ln109">{</a>
<a name="ln110">  if (zlookup-&gt;sock &gt;= 0) {</a>
<a name="ln111">    if (close(zlookup-&gt;sock)) {</a>
<a name="ln112">      zlog_warn(&quot;%s: closing fd=%d: errno=%d %s&quot;, __func__, zlookup-&gt;sock,</a>
<a name="ln113">		errno, safe_strerror(errno));</a>
<a name="ln114">    }</a>
<a name="ln115">    zlookup-&gt;sock = -1;</a>
<a name="ln116">  }</a>
<a name="ln117"> </a>
<a name="ln118">  zclient_lookup_reconnect(zlookup);</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">struct zclient *zclient_lookup_new()</a>
<a name="ln122">{</a>
<a name="ln123">  struct zclient *zlookup;</a>
<a name="ln124"> </a>
<a name="ln125">  zlookup = zclient_new (master);</a>
<a name="ln126">  if (!zlookup) {</a>
<a name="ln127">    zlog_err(&quot;%s: zclient_new() failure&quot;,</a>
<a name="ln128">	     __PRETTY_FUNCTION__);</a>
<a name="ln129">    return 0;</a>
<a name="ln130">  }</a>
<a name="ln131"> </a>
<a name="ln132">  zlookup-&gt;sock = -1;</a>
<a name="ln133">  zlookup-&gt;ibuf = stream_new(ZEBRA_MAX_PACKET_SIZ);</a>
<a name="ln134">  zlookup-&gt;obuf = stream_new(ZEBRA_MAX_PACKET_SIZ);</a>
<a name="ln135">  zlookup-&gt;t_connect = 0;</a>
<a name="ln136"> </a>
<a name="ln137">  zclient_lookup_sched_now(zlookup);</a>
<a name="ln138"> </a>
<a name="ln139">  zlog_notice(&quot;%s: zclient lookup socket initialized&quot;,</a>
<a name="ln140">	      __PRETTY_FUNCTION__);</a>
<a name="ln141"> </a>
<a name="ln142">  return zlookup;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">static int zclient_read_nexthop(struct zclient *zlookup,</a>
<a name="ln146">				struct pim_zlookup_nexthop nexthop_tab[],</a>
<a name="ln147">				const int tab_size,</a>
<a name="ln148">				struct in_addr addr)</a>
<a name="ln149">{</a>
<a name="ln150">  int num_ifindex = 0;</a>
<a name="ln151">  struct stream *s;</a>
<a name="ln152">  const uint16_t MIN_LEN = 10; /* getipv4=4 getc=1 getl=4 getc=1 */</a>
<a name="ln153">  uint16_t length;</a>
<a name="ln154">  u_char marker;</a>
<a name="ln155">  u_char version;</a>
<a name="ln156">  uint16_t vrf_id;</a>
<a name="ln157">  uint16_t command;</a>
<a name="ln158">  struct in_addr raddr;</a>
<a name="ln159">  uint8_t distance;</a>
<a name="ln160">  uint32_t metric;</a>
<a name="ln161">  int nexthop_num;</a>
<a name="ln162">  int i, err;</a>
<a name="ln163"> </a>
<a name="ln164">  if (PIM_DEBUG_ZEBRA) {</a>
<a name="ln165">    char addr_str[100];</a>
<a name="ln166">    pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln167">    zlog_debug(&quot;%s: addr=%s&quot;, </a>
<a name="ln168">	       __PRETTY_FUNCTION__,</a>
<a name="ln169">	       addr_str);</a>
<a name="ln170">  }</a>
<a name="ln171"> </a>
<a name="ln172">  s = zlookup-&gt;ibuf;</a>
<a name="ln173">  stream_reset(s);</a>
<a name="ln174"> </a>
<a name="ln175">  err = zclient_read_header (s, zlookup-&gt;sock, &amp;length, &amp;marker, &amp;version,</a>
<a name="ln176">                             &amp;vrf_id, &amp;command);</a>
<a name="ln177">  if (err &lt; 0) {</a>
<a name="ln178">    zlog_err(&quot;%s %s: zclient_read_header() failed&quot;,</a>
<a name="ln179">	     __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln180">    zclient_lookup_failed(zlookup);</a>
<a name="ln181">    return -1;</a>
<a name="ln182">  }</a>
<a name="ln183"> </a>
<a name="ln184">  if (length &lt; MIN_LEN) {</a>
<a name="ln185">    zlog_err(&quot;%s %s: failure reading zclient lookup socket: len=%d &lt; MIN_LEN=%d&quot;,</a>
<a name="ln186">	     __FILE__, __PRETTY_FUNCTION__, length, MIN_LEN);</a>
<a name="ln187">    zclient_lookup_failed(zlookup);</a>
<a name="ln188">    return -2;</a>
<a name="ln189">  }</a>
<a name="ln190">  </a>
<a name="ln191">  if (command != ZEBRA_IPV4_NEXTHOP_LOOKUP_MRIB) {</a>
<a name="ln192">    zlog_err(&quot;%s: socket %d command mismatch: %d&quot;,</a>
<a name="ln193">            __func__, zlookup-&gt;sock, command);</a>
<a name="ln194">    return -5;</a>
<a name="ln195">  }</a>
<a name="ln196"> </a>
<a name="ln197">  raddr.s_addr = stream_get_ipv4(s);</a>
<a name="ln198"> </a>
<a name="ln199">  if (raddr.s_addr != addr.s_addr) {</a>
<a name="ln200">    char addr_str[100];</a>
<a name="ln201">    char raddr_str[100];</a>
<a name="ln202">    pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln203">    pim_inet4_dump(&quot;&lt;raddr?&gt;&quot;, raddr, raddr_str, sizeof(raddr_str));</a>
<a name="ln204">    zlog_warn(&quot;%s: address mismatch: addr=%s raddr=%s&quot;, </a>
<a name="ln205">	       __PRETTY_FUNCTION__,</a>
<a name="ln206">	       addr_str, raddr_str);</a>
<a name="ln207">    /* warning only */</a>
<a name="ln208">  }</a>
<a name="ln209"> </a>
<a name="ln210">  distance = stream_getc(s);</a>
<a name="ln211">  metric = stream_getl(s);</a>
<a name="ln212">  nexthop_num = stream_getc(s);</a>
<a name="ln213"> </a>
<a name="ln214">  if (nexthop_num &lt; 1) {</a>
<a name="ln215">    zlog_err(&quot;%s: socket %d bad nexthop_num=%d&quot;,</a>
<a name="ln216">            __func__, zlookup-&gt;sock, nexthop_num);</a>
<a name="ln217">    return -6;</a>
<a name="ln218">  }</a>
<a name="ln219"> </a>
<a name="ln220">  length -= MIN_LEN;</a>
<a name="ln221"> </a>
<a name="ln222">  for (i = 0; i &lt; nexthop_num; ++i) {</a>
<a name="ln223">    enum nexthop_types_t nexthop_type;</a>
<a name="ln224"> </a>
<a name="ln225">    if (length &lt; 1) {</a>
<a name="ln226">      zlog_err(&quot;%s: socket %d empty input expecting nexthop_type: len=%d&quot;,</a>
<a name="ln227">	       __func__, zlookup-&gt;sock, length);</a>
<a name="ln228">      return -7;</a>
<a name="ln229">    }</a>
<a name="ln230">    </a>
<a name="ln231">    nexthop_type = stream_getc(s);</a>
<a name="ln232">    --length;</a>
<a name="ln233"> </a>
<a name="ln234">    switch (nexthop_type) {</a>
<a name="ln235">    case ZEBRA_NEXTHOP_IFINDEX:</a>
<a name="ln236">    case ZEBRA_NEXTHOP_IFNAME:</a>
<a name="ln237">    case ZEBRA_NEXTHOP_IPV4_IFINDEX:</a>
<a name="ln238">      if (num_ifindex &gt;= tab_size) {</a>
<a name="ln239">	char addr_str[100];</a>
<a name="ln240">	pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln241">	zlog_warn(&quot;%s %s: found too many nexthop ifindexes (%d &gt; %d) for address %s&quot;,</a>
<a name="ln242">		 __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln243">		 (num_ifindex + 1), tab_size, addr_str);</a>
<a name="ln244">	return num_ifindex;</a>
<a name="ln245">      }</a>
<a name="ln246">      if (nexthop_type == ZEBRA_NEXTHOP_IPV4_IFINDEX) {</a>
<a name="ln247">	if (length &lt; 4) {</a>
<a name="ln248">	  zlog_err(&quot;%s: socket %d short input expecting nexthop IPv4-addr: len=%d&quot;,</a>
<a name="ln249">		   __func__, zlookup-&gt;sock, length);</a>
<a name="ln250">	  return -8;</a>
<a name="ln251">	}</a>
<a name="ln252">	nexthop_tab[num_ifindex].nexthop_addr.s_addr = stream_get_ipv4(s);</a>
<a name="ln253">	length -= 4;</a>
<a name="ln254">      }</a>
<a name="ln255">      else {</a>
<a name="ln256">	nexthop_tab[num_ifindex].nexthop_addr.s_addr = PIM_NET_INADDR_ANY;</a>
<a name="ln257">      }</a>
<a name="ln258">      nexthop_tab[num_ifindex].ifindex           = stream_getl(s);</a>
<a name="ln259">      nexthop_tab[num_ifindex].protocol_distance = distance;</a>
<a name="ln260">      nexthop_tab[num_ifindex].route_metric      = metric;</a>
<a name="ln261">      ++num_ifindex;</a>
<a name="ln262">      break;</a>
<a name="ln263">    case ZEBRA_NEXTHOP_IPV4:</a>
<a name="ln264">      if (num_ifindex &gt;= tab_size) {</a>
<a name="ln265">	char addr_str[100];</a>
<a name="ln266">	pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln267">	zlog_warn(&quot;%s %s: found too many nexthop ifindexes (%d &gt; %d) for address %s&quot;,</a>
<a name="ln268">		 __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln269">		 (num_ifindex + 1), tab_size, addr_str);</a>
<a name="ln270">	return num_ifindex;</a>
<a name="ln271">      }</a>
<a name="ln272">      nexthop_tab[num_ifindex].nexthop_addr.s_addr = stream_get_ipv4(s);</a>
<a name="ln273">      length -= 4;</a>
<a name="ln274">      nexthop_tab[num_ifindex].ifindex             = 0;</a>
<a name="ln275">      nexthop_tab[num_ifindex].protocol_distance   = distance;</a>
<a name="ln276">      nexthop_tab[num_ifindex].route_metric        = metric;</a>
<a name="ln277">      if (PIM_DEBUG_ZEBRA) {</a>
<a name="ln278">	char addr_str[100];</a>
<a name="ln279">	char nexthop_str[100];</a>
<a name="ln280">	pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln281">	pim_inet4_dump(&quot;&lt;nexthop?&gt;&quot;, nexthop_tab[num_ifindex].nexthop_addr, nexthop_str, sizeof(nexthop_str));</a>
<a name="ln282">	zlog_debug(&quot;%s %s: zebra returned recursive nexthop %s for address %s&quot;,</a>
<a name="ln283">		   __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln284">		   nexthop_str, addr_str);</a>
<a name="ln285">      }</a>
<a name="ln286">      ++num_ifindex;</a>
<a name="ln287">      break;</a>
<a name="ln288">    default:</a>
<a name="ln289">      /* do nothing */</a>
<a name="ln290">      {</a>
<a name="ln291">	char addr_str[100];</a>
<a name="ln292">	pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln293">	zlog_warn(&quot;%s %s: found non-ifindex nexthop type=%d for address %s&quot;,</a>
<a name="ln294">		 __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln295">		  nexthop_type, addr_str);</a>
<a name="ln296">      }</a>
<a name="ln297">      break;</a>
<a name="ln298">    }</a>
<a name="ln299">  }</a>
<a name="ln300"> </a>
<a name="ln301">  return num_ifindex;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">static int zclient_lookup_nexthop_once(struct zclient *zlookup,</a>
<a name="ln305">				       struct pim_zlookup_nexthop nexthop_tab[],</a>
<a name="ln306">				       const int tab_size,</a>
<a name="ln307">				       struct in_addr addr)</a>
<a name="ln308">{</a>
<a name="ln309">  struct stream *s;</a>
<a name="ln310">  int ret;</a>
<a name="ln311"> </a>
<a name="ln312">  if (PIM_DEBUG_ZEBRA) {</a>
<a name="ln313">    char addr_str[100];</a>
<a name="ln314">    pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln315">    zlog_debug(&quot;%s: addr=%s&quot;, </a>
<a name="ln316">	       __PRETTY_FUNCTION__,</a>
<a name="ln317">	       addr_str);</a>
<a name="ln318">  }</a>
<a name="ln319"> </a>
<a name="ln320">  /* Check socket. */</a>
<a name="ln321">  if (zlookup-&gt;sock &lt; 0) {</a>
<a name="ln322">    zlog_err(&quot;%s %s: zclient lookup socket is not connected&quot;,</a>
<a name="ln323">	     __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln324">    zclient_lookup_failed(zlookup);</a>
<a name="ln325">    return -1;</a>
<a name="ln326">  }</a>
<a name="ln327">  </a>
<a name="ln328">  s = zlookup-&gt;obuf;</a>
<a name="ln329">  stream_reset(s);</a>
<a name="ln330">  zclient_create_header(s, ZEBRA_IPV4_NEXTHOP_LOOKUP_MRIB, VRF_DEFAULT);</a>
<a name="ln331">  stream_put_in_addr(s, &amp;addr);</a>
<a name="ln332">  stream_putw_at(s, 0, stream_get_endp(s));</a>
<a name="ln333">  </a>
<a name="ln334">  ret = writen(zlookup-&gt;sock, s-&gt;data, stream_get_endp(s));</a>
<a name="ln335">  if (ret &lt; 0) {</a>
<a name="ln336">    zlog_err(&quot;%s %s: writen() failure writing to zclient lookup socket&quot;,</a>
<a name="ln337">	     __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln338">    zclient_lookup_failed(zlookup);</a>
<a name="ln339">    return -2;</a>
<a name="ln340">  }</a>
<a name="ln341">  if (ret == 0) {</a>
<a name="ln342">    zlog_err(&quot;%s %s: connection closed on zclient lookup socket&quot;,</a>
<a name="ln343">	     __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln344">    zclient_lookup_failed(zlookup);</a>
<a name="ln345">    return -3;</a>
<a name="ln346">  }</a>
<a name="ln347">  </a>
<a name="ln348">  return zclient_read_nexthop(zlookup, nexthop_tab,</a>
<a name="ln349">			      tab_size, addr);</a>
<a name="ln350">}</a>
<a name="ln351"> </a>
<a name="ln352">int zclient_lookup_nexthop(struct zclient *zlookup,</a>
<a name="ln353">			   struct pim_zlookup_nexthop nexthop_tab[],</a>
<a name="ln354">			   const int tab_size,</a>
<a name="ln355">			   struct in_addr addr,</a>
<a name="ln356">			   int max_lookup)</a>
<a name="ln357">{</a>
<a name="ln358">  int lookup;</a>
<a name="ln359">  uint32_t route_metric = 0xFFFFFFFF;</a>
<a name="ln360">  uint8_t  protocol_distance = 0xFF;</a>
<a name="ln361"> </a>
<a name="ln362">  for (lookup = 0; lookup &lt; max_lookup; ++lookup) {</a>
<a name="ln363">    int num_ifindex;</a>
<a name="ln364">    int first_ifindex;</a>
<a name="ln365">    struct in_addr nexthop_addr;</a>
<a name="ln366"> </a>
<a name="ln367">    num_ifindex = zclient_lookup_nexthop_once(qpim_zclient_lookup, nexthop_tab,</a>
<a name="ln368">					      PIM_NEXTHOP_IFINDEX_TAB_SIZE, addr);</a>
<a name="ln369">    if ((num_ifindex &lt; 1) &amp;&amp; PIM_DEBUG_ZEBRA) {</a>
<a name="ln370">      char addr_str[100];</a>
<a name="ln371">      pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln372">      zlog_warn(&quot;%s %s: lookup=%d/%d: could not find nexthop ifindex for address %s&quot;,</a>
<a name="ln373">		__FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln374">		lookup, max_lookup, addr_str);</a>
<a name="ln375">      return -1;</a>
<a name="ln376">    }</a>
<a name="ln377"> </a>
<a name="ln378">    if (lookup &lt; 1) {</a>
<a name="ln379">      /* this is the non-recursive lookup - save original metric/distance */</a>
<a name="ln380">      route_metric = nexthop_tab[0].route_metric;</a>
<a name="ln381">      protocol_distance = nexthop_tab[0].protocol_distance;</a>
<a name="ln382">    }</a>
<a name="ln383">    </a>
<a name="ln384">    /*</a>
<a name="ln385">      FIXME: Non-recursive nexthop ensured only for first ifindex.</a>
<a name="ln386">      However, recursive route lookup should really be fixed in zebra daemon.</a>
<a name="ln387">      See also TODO T24.</a>
<a name="ln388">     */</a>
<a name="ln389">    first_ifindex = nexthop_tab[0].ifindex;</a>
<a name="ln390">    nexthop_addr = nexthop_tab[0].nexthop_addr;</a>
<a name="ln391">    if (first_ifindex &gt; 0) {</a>
<a name="ln392">      /* found: first ifindex is non-recursive nexthop */</a>
<a name="ln393"> </a>
<a name="ln394">      if ((lookup &gt; 0) &amp;&amp; PIM_DEBUG_ZEBRA) {</a>
<a name="ln395">	/* Report non-recursive success after first lookup */</a>
<a name="ln396">	char addr_str[100];</a>
<a name="ln397">	pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln398">	zlog_debug(&quot;%s %s: lookup=%d/%d: found non-recursive ifindex=%d for address %s dist=%d met=%d&quot;,</a>
<a name="ln399">		   __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln400">		   lookup, max_lookup, first_ifindex, addr_str,</a>
<a name="ln401">		   nexthop_tab[0].protocol_distance,</a>
<a name="ln402">		   nexthop_tab[0].route_metric);</a>
<a name="ln403"> </a>
<a name="ln404">	/* use last address as nexthop address */</a>
<a name="ln405">	nexthop_tab[0].nexthop_addr = addr;</a>
<a name="ln406"> </a>
<a name="ln407">	/* report original route metric/distance */</a>
<a name="ln408">	nexthop_tab[0].route_metric = route_metric;</a>
<a name="ln409">	nexthop_tab[0].protocol_distance = protocol_distance;</a>
<a name="ln410">      }</a>
<a name="ln411"> </a>
<a name="ln412">      return num_ifindex;</a>
<a name="ln413">    }</a>
<a name="ln414"> </a>
<a name="ln415">    if (PIM_DEBUG_ZEBRA) {</a>
<a name="ln416">      char addr_str[100];</a>
<a name="ln417">      char nexthop_str[100];</a>
<a name="ln418">      pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln419">      pim_inet4_dump(&quot;&lt;nexthop?&gt;&quot;, nexthop_addr, nexthop_str, sizeof(nexthop_str));</a>
<a name="ln420">      zlog_debug(&quot;%s %s: lookup=%d/%d: zebra returned recursive nexthop %s for address %s dist=%d met=%d&quot;,</a>
<a name="ln421">		__FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln422">		lookup, max_lookup, nexthop_str, addr_str,</a>
<a name="ln423">		nexthop_tab[0].protocol_distance,</a>
<a name="ln424">		nexthop_tab[0].route_metric);</a>
<a name="ln425">    }</a>
<a name="ln426"> </a>
<a name="ln427">    addr = nexthop_addr; /* use nexthop addr for recursive lookup */</a>
<a name="ln428"> </a>
<a name="ln429">  } /* for (max_lookup) */</a>
<a name="ln430"> </a>
<a name="ln431">  if (PIM_DEBUG_ZEBRA) {</a>
<a name="ln432">    char addr_str[100];</a>
<a name="ln433">    pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln434">    zlog_warn(&quot;%s %s: lookup=%d/%d: failure searching recursive nexthop ifindex for address %s&quot;,</a>
<a name="ln435">	      __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln436">	      lookup, max_lookup, addr_str);</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  return -2;</a>
<a name="ln440">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
