
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>command.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">   Command interpreter routine for virtual terminal [aka TeletYpe]</a>
<a name="ln3">   Copyright (C) 1997, 98, 99 Kunihiro Ishiguro</a>
<a name="ln4">   Copyright (C) 2013 by Open Source Routing.</a>
<a name="ln5">   Copyright (C) 2013 by Internet Systems Consortium, Inc. (&quot;ISC&quot;)</a>
<a name="ln6"> </a>
<a name="ln7">This file is part of GNU Zebra.</a>
<a name="ln8"> </a>
<a name="ln9">GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln10">it under the terms of the GNU General Public License as published</a>
<a name="ln11">by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln12">option) any later version.</a>
<a name="ln13"> </a>
<a name="ln14">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln15">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln16">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln17">General Public License for more details.</a>
<a name="ln18"> </a>
<a name="ln19">You should have received a copy of the GNU General Public License</a>
<a name="ln20">along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln21">Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln22">Boston, MA 02111-1307, USA.  */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;log.h&quot;</a>
<a name="ln29">#include &lt;lib/version.h&gt;</a>
<a name="ln30">#include &quot;thread.h&quot;</a>
<a name="ln31">#include &quot;vector.h&quot;</a>
<a name="ln32">#include &quot;vty.h&quot;</a>
<a name="ln33">#include &quot;command.h&quot;</a>
<a name="ln34">#include &quot;workqueue.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">/* Command vector which includes some level of command lists. Normally</a>
<a name="ln37">   each daemon maintains each own cmdvec. */</a>
<a name="ln38">vector cmdvec = NULL;</a>
<a name="ln39"> </a>
<a name="ln40">struct cmd_token token_cr;</a>
<a name="ln41">char *command_cr = NULL;</a>
<a name="ln42"> </a>
<a name="ln43">enum filter_type</a>
<a name="ln44">{</a>
<a name="ln45">  FILTER_RELAXED,</a>
<a name="ln46">  FILTER_STRICT</a>
<a name="ln47">};</a>
<a name="ln48"> </a>
<a name="ln49">enum matcher_rv</a>
<a name="ln50">{</a>
<a name="ln51">  MATCHER_OK,</a>
<a name="ln52">  MATCHER_COMPLETE,</a>
<a name="ln53">  MATCHER_INCOMPLETE,</a>
<a name="ln54">  MATCHER_NO_MATCH,</a>
<a name="ln55">  MATCHER_AMBIGUOUS,</a>
<a name="ln56">  MATCHER_EXCEED_ARGC_MAX</a>
<a name="ln57">};</a>
<a name="ln58"> </a>
<a name="ln59">#define MATCHER_ERROR(matcher_rv) \</a>
<a name="ln60">  (   (matcher_rv) == MATCHER_INCOMPLETE \</a>
<a name="ln61">   || (matcher_rv) == MATCHER_NO_MATCH \</a>
<a name="ln62">   || (matcher_rv) == MATCHER_AMBIGUOUS \</a>
<a name="ln63">   || (matcher_rv) == MATCHER_EXCEED_ARGC_MAX \</a>
<a name="ln64">  )</a>
<a name="ln65"> </a>
<a name="ln66">/* Host information structure. */</a>
<a name="ln67">struct host host;</a>
<a name="ln68"> </a>
<a name="ln69">/* Standard command node structures. */</a>
<a name="ln70">static struct cmd_node auth_node =</a>
<a name="ln71">{</a>
<a name="ln72">  AUTH_NODE,</a>
<a name="ln73">  &quot;Password: &quot;,</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">static struct cmd_node view_node =</a>
<a name="ln77">{</a>
<a name="ln78">  VIEW_NODE,</a>
<a name="ln79">  &quot;%s&gt; &quot;,</a>
<a name="ln80">};</a>
<a name="ln81"> </a>
<a name="ln82">static struct cmd_node restricted_node =</a>
<a name="ln83">{</a>
<a name="ln84">  RESTRICTED_NODE,</a>
<a name="ln85">  &quot;%s$ &quot;,</a>
<a name="ln86">};</a>
<a name="ln87"> </a>
<a name="ln88">static struct cmd_node auth_enable_node =</a>
<a name="ln89">{</a>
<a name="ln90">  AUTH_ENABLE_NODE,</a>
<a name="ln91">  &quot;Password: &quot;,</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94">static struct cmd_node enable_node =</a>
<a name="ln95">{</a>
<a name="ln96">  ENABLE_NODE,</a>
<a name="ln97">  &quot;%s# &quot;,</a>
<a name="ln98">};</a>
<a name="ln99"> </a>
<a name="ln100">static struct cmd_node config_node =</a>
<a name="ln101">{</a>
<a name="ln102">  CONFIG_NODE,</a>
<a name="ln103">  &quot;%s(config)# &quot;,</a>
<a name="ln104">  1</a>
<a name="ln105">};</a>
<a name="ln106"> </a>
<a name="ln107">/* Default motd string. */</a>
<a name="ln108">static const char *default_motd =</a>
<a name="ln109">&quot;\r\n\</a>
<a name="ln110">Hello, this is &quot; QUAGGA_PROGNAME &quot; (version &quot; QUAGGA_VERSION &quot;).\r\n\</a>
<a name="ln111">&quot; QUAGGA_COPYRIGHT &quot;\r\n\</a>
<a name="ln112">&quot; GIT_INFO &quot;\r\n&quot;;</a>
<a name="ln113"> </a>
<a name="ln114"> </a>
<a name="ln115">static const struct facility_map {</a>
<a name="ln116">  int facility;</a>
<a name="ln117">  const char *name;</a>
<a name="ln118">  size_t match;</a>
<a name="ln119">} syslog_facilities[] = </a>
<a name="ln120">  {</a>
<a name="ln121">    { LOG_KERN, &quot;kern&quot;, 1 },</a>
<a name="ln122">    { LOG_USER, &quot;user&quot;, 2 },</a>
<a name="ln123">    { LOG_MAIL, &quot;mail&quot;, 1 },</a>
<a name="ln124">    { LOG_DAEMON, &quot;daemon&quot;, 1 },</a>
<a name="ln125">    { LOG_AUTH, &quot;auth&quot;, 1 },</a>
<a name="ln126">    { LOG_SYSLOG, &quot;syslog&quot;, 1 },</a>
<a name="ln127">    { LOG_LPR, &quot;lpr&quot;, 2 },</a>
<a name="ln128">    { LOG_NEWS, &quot;news&quot;, 1 },</a>
<a name="ln129">    { LOG_UUCP, &quot;uucp&quot;, 2 },</a>
<a name="ln130">    { LOG_CRON, &quot;cron&quot;, 1 },</a>
<a name="ln131">#ifdef LOG_FTP</a>
<a name="ln132">    { LOG_FTP, &quot;ftp&quot;, 1 },</a>
<a name="ln133">#endif</a>
<a name="ln134">    { LOG_LOCAL0, &quot;local0&quot;, 6 },</a>
<a name="ln135">    { LOG_LOCAL1, &quot;local1&quot;, 6 },</a>
<a name="ln136">    { LOG_LOCAL2, &quot;local2&quot;, 6 },</a>
<a name="ln137">    { LOG_LOCAL3, &quot;local3&quot;, 6 },</a>
<a name="ln138">    { LOG_LOCAL4, &quot;local4&quot;, 6 },</a>
<a name="ln139">    { LOG_LOCAL5, &quot;local5&quot;, 6 },</a>
<a name="ln140">    { LOG_LOCAL6, &quot;local6&quot;, 6 },</a>
<a name="ln141">    { LOG_LOCAL7, &quot;local7&quot;, 6 },</a>
<a name="ln142">    { 0, NULL, 0 },</a>
<a name="ln143">  };</a>
<a name="ln144"> </a>
<a name="ln145">static const char *</a>
<a name="ln146">facility_name(int facility)</a>
<a name="ln147">{</a>
<a name="ln148">  const struct facility_map *fm;</a>
<a name="ln149"> </a>
<a name="ln150">  for (fm = syslog_facilities; fm-&gt;name; fm++)</a>
<a name="ln151">    if (fm-&gt;facility == facility)</a>
<a name="ln152">      return fm-&gt;name;</a>
<a name="ln153">  return &quot;&quot;;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">static int</a>
<a name="ln157">facility_match(const char *str)</a>
<a name="ln158">{</a>
<a name="ln159">  const struct facility_map *fm;</a>
<a name="ln160"> </a>
<a name="ln161">  for (fm = syslog_facilities; fm-&gt;name; fm++)</a>
<a name="ln162">    if (!strncmp(str,fm-&gt;name,fm-&gt;match))</a>
<a name="ln163">      return fm-&gt;facility;</a>
<a name="ln164">  return -1;</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">static int</a>
<a name="ln168">level_match(const char *s)</a>
<a name="ln169">{</a>
<a name="ln170">  int level ;</a>
<a name="ln171">  </a>
<a name="ln172">  for ( level = 0 ; zlog_priority [level] != NULL ; level ++ )</a>
<a name="ln173">    if (!strncmp (s, zlog_priority[level], 2))</a>
<a name="ln174">      return level;</a>
<a name="ln175">  return ZLOG_DISABLED;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">/* This is called from main when a daemon is invoked with -v or --version. */</a>
<a name="ln179">void</a>
<a name="ln180">print_version (const char *progname)</a>
<a name="ln181">{</a>
<a name="ln182">  printf (&quot;%s version %s\n&quot;, progname, QUAGGA_VERSION);</a>
<a name="ln183">  printf (&quot;%s\n&quot;, QUAGGA_COPYRIGHT);</a>
<a name="ln184">  printf (&quot;configured with:\n\t%s\n&quot;, QUAGGA_CONFIG_ARGS);</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187"> </a>
<a name="ln188">/* Utility function to concatenate argv argument into a single string</a>
<a name="ln189">   with inserting ' ' character between each argument.  */</a>
<a name="ln190">char *</a>
<a name="ln191">argv_concat (const char **argv, int argc, int shift)</a>
<a name="ln192">{</a>
<a name="ln193">  int i;</a>
<a name="ln194">  size_t len;</a>
<a name="ln195">  char *str;</a>
<a name="ln196">  char *p;</a>
<a name="ln197"> </a>
<a name="ln198">  len = 0;</a>
<a name="ln199">  for (i = shift; i &lt; argc; i++)</a>
<a name="ln200">    len += strlen(argv[i])+1;</a>
<a name="ln201">  if (!len)</a>
<a name="ln202">    return NULL;</a>
<a name="ln203">  p = str = XMALLOC(MTYPE_TMP, len);</a>
<a name="ln204">  for (i = shift; i &lt; argc; i++)</a>
<a name="ln205">    {</a>
<a name="ln206">      size_t arglen;</a>
<a name="ln207">      memcpy(p, argv[i], (arglen = strlen(argv[i])));</a>
<a name="ln208">      p += arglen;</a>
<a name="ln209">      *p++ = ' ';</a>
<a name="ln210">    }</a>
<a name="ln211">  *(p-1) = '\0';</a>
<a name="ln212">  return str;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">static unsigned int</a>
<a name="ln216">cmd_hash_key (void *p)</a>
<a name="ln217">{</a>
<a name="ln218">  return (uintptr_t) p;</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">static int</a>
<a name="ln222">cmd_hash_cmp (const void *a, const void *b)</a>
<a name="ln223">{</a>
<a name="ln224">  return a == b;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">/* Install top node of command vector. */</a>
<a name="ln228">void</a>
<a name="ln229">install_node (struct cmd_node *node, </a>
<a name="ln230">	      int (*func) (struct vty *))</a>
<a name="ln231">{</a>
<a name="ln232">  vector_set_index (cmdvec, node-&gt;node, node);</a>
<a name="ln233">  node-&gt;func = func;</a>
<a name="ln234">  node-&gt;cmd_vector = vector_init (VECTOR_MIN_SIZE);</a>
<a name="ln235">  node-&gt;cmd_hash = hash_create (cmd_hash_key, cmd_hash_cmp);</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">/* Breaking up string into each command piece. I assume given</a>
<a name="ln239">   character is separated by a space character. Return value is a</a>
<a name="ln240">   vector which includes char ** data element. */</a>
<a name="ln241">vector</a>
<a name="ln242">cmd_make_strvec (const char *string)</a>
<a name="ln243">{</a>
<a name="ln244">  const char *cp, *start;</a>
<a name="ln245">  char *token;</a>
<a name="ln246">  int strlen;</a>
<a name="ln247">  vector strvec;</a>
<a name="ln248">  </a>
<a name="ln249">  if (string == NULL)</a>
<a name="ln250">    return NULL;</a>
<a name="ln251">  </a>
<a name="ln252">  cp = string;</a>
<a name="ln253"> </a>
<a name="ln254">  /* Skip white spaces. */</a>
<a name="ln255">  while (isspace ((int) *cp) &amp;&amp; *cp != '\0')</a>
<a name="ln256">    cp++;</a>
<a name="ln257"> </a>
<a name="ln258">  /* Return if there is only white spaces */</a>
<a name="ln259">  if (*cp == '\0')</a>
<a name="ln260">    return NULL;</a>
<a name="ln261"> </a>
<a name="ln262">  if (*cp == '!' || *cp == '#')</a>
<a name="ln263">    return NULL;</a>
<a name="ln264"> </a>
<a name="ln265">  /* Prepare return vector. */</a>
<a name="ln266">  strvec = vector_init (VECTOR_MIN_SIZE);</a>
<a name="ln267"> </a>
<a name="ln268">  /* Copy each command piece and set into vector. */</a>
<a name="ln269">  while (1) </a>
<a name="ln270">    {</a>
<a name="ln271">      start = cp;</a>
<a name="ln272">      while (!(isspace ((int) *cp) || *cp == '\r' || *cp == '\n') &amp;&amp;</a>
<a name="ln273">	     *cp != '\0')</a>
<a name="ln274">	cp++;</a>
<a name="ln275">      strlen = cp - start;</a>
<a name="ln276">      token = XMALLOC (MTYPE_STRVEC, strlen + 1);</a>
<a name="ln277">      memcpy (token, start, strlen);</a>
<a name="ln278">      *(token + strlen) = '\0';</a>
<a name="ln279">      vector_set (strvec, token);</a>
<a name="ln280"> </a>
<a name="ln281">      while ((isspace ((int) *cp) || *cp == '\n' || *cp == '\r') &amp;&amp;</a>
<a name="ln282">	     *cp != '\0')</a>
<a name="ln283">	cp++;</a>
<a name="ln284"> </a>
<a name="ln285">      if (*cp == '\0')</a>
<a name="ln286">	return strvec;</a>
<a name="ln287">    }</a>
<a name="ln288">}</a>
<a name="ln289"> </a>
<a name="ln290">/* Free allocated string vector. */</a>
<a name="ln291">void</a>
<a name="ln292">cmd_free_strvec (vector v)</a>
<a name="ln293">{</a>
<a name="ln294">  unsigned int i;</a>
<a name="ln295">  char *cp;</a>
<a name="ln296"> </a>
<a name="ln297">  if (!v)</a>
<a name="ln298">    return;</a>
<a name="ln299"> </a>
<a name="ln300">  for (i = 0; i &lt; vector_active (v); i++)</a>
<a name="ln301">    if ((cp = vector_slot (v, i)) != NULL)</a>
<a name="ln302">      XFREE (MTYPE_STRVEC, cp);</a>
<a name="ln303"> </a>
<a name="ln304">  vector_free (v);</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">struct format_parser_state</a>
<a name="ln308">{</a>
<a name="ln309">  vector topvect; /* Top level vector */</a>
<a name="ln310">  vector intvect; /* Intermediate level vector, used when there's</a>
<a name="ln311">                   * a multiple in a keyword. */</a>
<a name="ln312">  vector curvect; /* current vector where read tokens should be</a>
<a name="ln313">                     appended. */</a>
<a name="ln314"> </a>
<a name="ln315">  const char *string; /* pointer to command string, not modified */</a>
<a name="ln316">  const char *cp; /* pointer in command string, moved along while</a>
<a name="ln317">                     parsing */</a>
<a name="ln318">  const char *dp;  /* pointer in description string, moved along while</a>
<a name="ln319">                     parsing */</a>
<a name="ln320"> </a>
<a name="ln321">  int in_keyword; /* flag to remember if we are in a keyword group */</a>
<a name="ln322">  int in_multiple; /* flag to remember if we are in a multiple group */</a>
<a name="ln323">  int just_read_word; /* flag to remember if the last thing we red was a</a>
<a name="ln324">                       * real word and not some abstract token */</a>
<a name="ln325">};</a>
<a name="ln326"> </a>
<a name="ln327">static void</a>
<a name="ln328">format_parser_error(struct format_parser_state *state, const char *message)</a>
<a name="ln329">{</a>
<a name="ln330">  int offset = state-&gt;cp - state-&gt;string + 1;</a>
<a name="ln331"> </a>
<a name="ln332">  fprintf(stderr, &quot;\nError parsing command: \&quot;%s\&quot;\n&quot;, state-&gt;string);</a>
<a name="ln333">  fprintf(stderr, &quot;                        %*c\n&quot;, offset, '^');</a>
<a name="ln334">  fprintf(stderr, &quot;%s at offset %d.\n&quot;, message, offset);</a>
<a name="ln335">  fprintf(stderr, &quot;This is a programming error. Check your DEFUNs etc.\n&quot;);</a>
<a name="ln336">  exit(1);</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">static char *</a>
<a name="ln340">format_parser_desc_str(struct format_parser_state *state)</a>
<a name="ln341">{</a>
<a name="ln342">  const char *cp, *start;</a>
<a name="ln343">  char *token;</a>
<a name="ln344">  int strlen;</a>
<a name="ln345"> </a>
<a name="ln346">  cp = state-&gt;dp;</a>
<a name="ln347"> </a>
<a name="ln348">  if (cp == NULL)</a>
<a name="ln349">    return NULL;</a>
<a name="ln350"> </a>
<a name="ln351">  /* Skip white spaces. */</a>
<a name="ln352">  while (isspace ((int) *cp) &amp;&amp; *cp != '\0')</a>
<a name="ln353">    cp++;</a>
<a name="ln354"> </a>
<a name="ln355">  /* Return if there is only white spaces */</a>
<a name="ln356">  if (*cp == '\0')</a>
<a name="ln357">    return NULL;</a>
<a name="ln358"> </a>
<a name="ln359">  start = cp;</a>
<a name="ln360"> </a>
<a name="ln361">  while (!(*cp == '\r' || *cp == '\n') &amp;&amp; *cp != '\0')</a>
<a name="ln362">    cp++;</a>
<a name="ln363"> </a>
<a name="ln364">  strlen = cp - start;</a>
<a name="ln365">  token = XMALLOC (MTYPE_CMD_TOKENS, strlen + 1);</a>
<a name="ln366">  memcpy (token, start, strlen);</a>
<a name="ln367">  *(token + strlen) = '\0';</a>
<a name="ln368"> </a>
<a name="ln369">  state-&gt;dp = cp;</a>
<a name="ln370"> </a>
<a name="ln371">  return token;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">static void</a>
<a name="ln375">format_parser_begin_keyword(struct format_parser_state *state)</a>
<a name="ln376">{</a>
<a name="ln377">  struct cmd_token *token;</a>
<a name="ln378">  vector keyword_vect;</a>
<a name="ln379"> </a>
<a name="ln380">  if (state-&gt;in_keyword</a>
<a name="ln381">      || state-&gt;in_multiple)</a>
<a name="ln382">    format_parser_error(state, &quot;Unexpected '{'&quot;);</a>
<a name="ln383"> </a>
<a name="ln384">  state-&gt;cp++;</a>
<a name="ln385">  state-&gt;in_keyword = 1;</a>
<a name="ln386"> </a>
<a name="ln387">  token = XCALLOC(MTYPE_CMD_TOKENS, sizeof(*token));</a>
<a name="ln388">  token-&gt;type = TOKEN_KEYWORD;</a>
<a name="ln389">  token-&gt;keyword = vector_init(VECTOR_MIN_SIZE);</a>
<a name="ln390"> </a>
<a name="ln391">  keyword_vect = vector_init(VECTOR_MIN_SIZE);</a>
<a name="ln392">  vector_set(token-&gt;keyword, keyword_vect);</a>
<a name="ln393"> </a>
<a name="ln394">  vector_set(state-&gt;curvect, token);</a>
<a name="ln395">  state-&gt;curvect = keyword_vect;</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">static void</a>
<a name="ln399">format_parser_begin_multiple(struct format_parser_state *state)</a>
<a name="ln400">{</a>
<a name="ln401">  struct cmd_token *token;</a>
<a name="ln402"> </a>
<a name="ln403">  if (state-&gt;in_keyword == 1)</a>
<a name="ln404">    format_parser_error(state, &quot;Keyword starting with '('&quot;);</a>
<a name="ln405"> </a>
<a name="ln406">  if (state-&gt;in_multiple)</a>
<a name="ln407">    format_parser_error(state, &quot;Nested group&quot;);</a>
<a name="ln408"> </a>
<a name="ln409">  state-&gt;cp++;</a>
<a name="ln410">  state-&gt;in_multiple = 1;</a>
<a name="ln411">  state-&gt;just_read_word = 0;</a>
<a name="ln412"> </a>
<a name="ln413">  token = XCALLOC(MTYPE_CMD_TOKENS, sizeof(*token));</a>
<a name="ln414">  token-&gt;type = TOKEN_MULTIPLE;</a>
<a name="ln415">  token-&gt;multiple = vector_init(VECTOR_MIN_SIZE);</a>
<a name="ln416"> </a>
<a name="ln417">  vector_set(state-&gt;curvect, token);</a>
<a name="ln418">  if (state-&gt;curvect != state-&gt;topvect)</a>
<a name="ln419">    state-&gt;intvect = state-&gt;curvect;</a>
<a name="ln420">  state-&gt;curvect = token-&gt;multiple;</a>
<a name="ln421">}</a>
<a name="ln422"> </a>
<a name="ln423">static void</a>
<a name="ln424">format_parser_end_keyword(struct format_parser_state *state)</a>
<a name="ln425">{</a>
<a name="ln426">  if (state-&gt;in_multiple</a>
<a name="ln427">      || !state-&gt;in_keyword)</a>
<a name="ln428">    format_parser_error(state, &quot;Unexpected '}'&quot;);</a>
<a name="ln429"> </a>
<a name="ln430">  if (state-&gt;in_keyword == 1)</a>
<a name="ln431">    format_parser_error(state, &quot;Empty keyword group&quot;);</a>
<a name="ln432"> </a>
<a name="ln433">  state-&gt;cp++;</a>
<a name="ln434">  state-&gt;in_keyword = 0;</a>
<a name="ln435">  state-&gt;curvect = state-&gt;topvect;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">static void</a>
<a name="ln439">format_parser_end_multiple(struct format_parser_state *state)</a>
<a name="ln440">{</a>
<a name="ln441">  char *dummy;</a>
<a name="ln442"> </a>
<a name="ln443">  if (!state-&gt;in_multiple)</a>
<a name="ln444">    format_parser_error(state, &quot;Unexpected ')'&quot;);</a>
<a name="ln445"> </a>
<a name="ln446">  if (vector_active(state-&gt;curvect) == 0)</a>
<a name="ln447">    format_parser_error(state, &quot;Empty multiple section&quot;);</a>
<a name="ln448"> </a>
<a name="ln449">  if (!state-&gt;just_read_word)</a>
<a name="ln450">    {</a>
<a name="ln451">      /* There are constructions like</a>
<a name="ln452">       * 'show ip ospf database ... (self-originate|)'</a>
<a name="ln453">       * in use.</a>
<a name="ln454">       * The old parser reads a description string for the</a>
<a name="ln455">       * word '' between |) which will never match.</a>
<a name="ln456">       * Simulate this behvaior by dropping the next desc</a>
<a name="ln457">       * string in such a case. */</a>
<a name="ln458"> </a>
<a name="ln459">      dummy = format_parser_desc_str(state);</a>
<a name="ln460">      XFREE(MTYPE_CMD_TOKENS, dummy);</a>
<a name="ln461">    }</a>
<a name="ln462"> </a>
<a name="ln463">  state-&gt;cp++;</a>
<a name="ln464">  state-&gt;in_multiple = 0;</a>
<a name="ln465"> </a>
<a name="ln466">  if (state-&gt;intvect)</a>
<a name="ln467">    state-&gt;curvect = state-&gt;intvect;</a>
<a name="ln468">  else</a>
<a name="ln469">    state-&gt;curvect = state-&gt;topvect;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">static void</a>
<a name="ln473">format_parser_handle_pipe(struct format_parser_state *state)</a>
<a name="ln474">{</a>
<a name="ln475">  struct cmd_token *keyword_token;</a>
<a name="ln476">  vector keyword_vect;</a>
<a name="ln477"> </a>
<a name="ln478">  if (state-&gt;in_multiple)</a>
<a name="ln479">    {</a>
<a name="ln480">      state-&gt;just_read_word = 0;</a>
<a name="ln481">      state-&gt;cp++;</a>
<a name="ln482">    }</a>
<a name="ln483">  else if (state-&gt;in_keyword)</a>
<a name="ln484">    {</a>
<a name="ln485">      state-&gt;in_keyword = 1;</a>
<a name="ln486">      state-&gt;cp++;</a>
<a name="ln487"> </a>
<a name="ln488">      keyword_token = vector_slot(state-&gt;topvect,</a>
<a name="ln489">                                  vector_active(state-&gt;topvect) - 1);</a>
<a name="ln490">      keyword_vect = vector_init(VECTOR_MIN_SIZE);</a>
<a name="ln491">      vector_set(keyword_token-&gt;keyword, keyword_vect);</a>
<a name="ln492">      state-&gt;curvect = keyword_vect;</a>
<a name="ln493">    }</a>
<a name="ln494">  else</a>
<a name="ln495">    {</a>
<a name="ln496">      format_parser_error(state, &quot;Unexpected '|'&quot;);</a>
<a name="ln497">    }</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">static void</a>
<a name="ln501">format_parser_read_word(struct format_parser_state *state)</a>
<a name="ln502">{</a>
<a name="ln503">  const char *start;</a>
<a name="ln504">  int len;</a>
<a name="ln505">  char *cmd;</a>
<a name="ln506">  struct cmd_token *token;</a>
<a name="ln507"> </a>
<a name="ln508">  start = state-&gt;cp;</a>
<a name="ln509"> </a>
<a name="ln510">  while (state-&gt;cp[0] != '\0'</a>
<a name="ln511">         &amp;&amp; !strchr(&quot;\r\n(){}|&quot;, state-&gt;cp[0])</a>
<a name="ln512">         &amp;&amp; !isspace((int)state-&gt;cp[0]))</a>
<a name="ln513">    state-&gt;cp++;</a>
<a name="ln514"> </a>
<a name="ln515">  len = state-&gt;cp - start;</a>
<a name="ln516">  cmd = XMALLOC(MTYPE_CMD_TOKENS, len + 1);</a>
<a name="ln517">  memcpy(cmd, start, len);</a>
<a name="ln518">  cmd[len] = '\0';</a>
<a name="ln519"> </a>
<a name="ln520">  token = XCALLOC(MTYPE_CMD_TOKENS, sizeof(*token));</a>
<a name="ln521">  token-&gt;type = TOKEN_TERMINAL;</a>
<a name="ln522">  if (strcmp (cmd, &quot;A.B.C.D&quot;) == 0)</a>
<a name="ln523">    token-&gt;terminal = TERMINAL_IPV4;</a>
<a name="ln524">  else if (strcmp (cmd, &quot;A.B.C.D/M&quot;) == 0)</a>
<a name="ln525">    token-&gt;terminal = TERMINAL_IPV4_PREFIX;</a>
<a name="ln526">  else if (strcmp (cmd, &quot;X:X::X:X&quot;) == 0)</a>
<a name="ln527">    token-&gt;terminal = TERMINAL_IPV6;</a>
<a name="ln528">  else if (strcmp (cmd, &quot;X:X::X:X/M&quot;) == 0)</a>
<a name="ln529">    token-&gt;terminal = TERMINAL_IPV6_PREFIX;</a>
<a name="ln530">  else if (cmd[0] == '[')</a>
<a name="ln531">    token-&gt;terminal = TERMINAL_OPTION;</a>
<a name="ln532">  else if (cmd[0] == '.')</a>
<a name="ln533">    token-&gt;terminal = TERMINAL_VARARG;</a>
<a name="ln534">  else if (cmd[0] == '&lt;')</a>
<a name="ln535">    token-&gt;terminal = TERMINAL_RANGE;</a>
<a name="ln536">  else if (cmd[0] &gt;= 'A' &amp;&amp; cmd[0] &lt;= 'Z')</a>
<a name="ln537">    token-&gt;terminal = TERMINAL_VARIABLE;</a>
<a name="ln538">  else</a>
<a name="ln539">    token-&gt;terminal = TERMINAL_LITERAL;</a>
<a name="ln540"> </a>
<a name="ln541">  token-&gt;cmd = cmd;</a>
<a name="ln542">  token-&gt;desc = format_parser_desc_str(state);</a>
<a name="ln543">  vector_set(state-&gt;curvect, token);</a>
<a name="ln544"> </a>
<a name="ln545">  if (state-&gt;in_keyword == 1)</a>
<a name="ln546">    state-&gt;in_keyword = 2;</a>
<a name="ln547"> </a>
<a name="ln548">  state-&gt;just_read_word = 1;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">/**</a>
<a name="ln552"> * Parse a given command format string and build a tree of tokens from</a>
<a name="ln553"> * it that is suitable to be used by the command subsystem.</a>
<a name="ln554"> *</a>
<a name="ln555"> * @param string Command format string.</a>
<a name="ln556"> * @param descstr Description string.</a>
<a name="ln557"> * @return A vector of struct cmd_token representing the given command,</a>
<a name="ln558"> *         or NULL on error.</a>
<a name="ln559"> */</a>
<a name="ln560">static vector</a>
<a name="ln561">cmd_parse_format(const char *string, const char *descstr)</a>
<a name="ln562">{</a>
<a name="ln563">  struct format_parser_state state;</a>
<a name="ln564"> </a>
<a name="ln565">  if (string == NULL)</a>
<a name="ln566">    return NULL;</a>
<a name="ln567"> </a>
<a name="ln568">  memset(&amp;state, 0, sizeof(state));</a>
<a name="ln569">  state.topvect = state.curvect = vector_init(VECTOR_MIN_SIZE);</a>
<a name="ln570">  state.cp = state.string = string;</a>
<a name="ln571">  state.dp = descstr;</a>
<a name="ln572"> </a>
<a name="ln573">  while (1)</a>
<a name="ln574">    {</a>
<a name="ln575">      while (isspace((int)state.cp[0]) &amp;&amp; state.cp[0] != '\0')</a>
<a name="ln576">        state.cp++;</a>
<a name="ln577"> </a>
<a name="ln578">      switch (state.cp[0])</a>
<a name="ln579">        {</a>
<a name="ln580">        case '\0':</a>
<a name="ln581">          if (state.in_keyword</a>
<a name="ln582">              || state.in_multiple)</a>
<a name="ln583">            format_parser_error(&amp;state, &quot;Unclosed group/keyword&quot;);</a>
<a name="ln584">          return state.topvect;</a>
<a name="ln585">        case '{':</a>
<a name="ln586">          format_parser_begin_keyword(&amp;state);</a>
<a name="ln587">          break;</a>
<a name="ln588">        case '(':</a>
<a name="ln589">          format_parser_begin_multiple(&amp;state);</a>
<a name="ln590">          break;</a>
<a name="ln591">        case '}':</a>
<a name="ln592">          format_parser_end_keyword(&amp;state);</a>
<a name="ln593">          break;</a>
<a name="ln594">        case ')':</a>
<a name="ln595">          format_parser_end_multiple(&amp;state);</a>
<a name="ln596">          break;</a>
<a name="ln597">        case '|':</a>
<a name="ln598">          format_parser_handle_pipe(&amp;state);</a>
<a name="ln599">          break;</a>
<a name="ln600">        default:</a>
<a name="ln601">          format_parser_read_word(&amp;state);</a>
<a name="ln602">        }</a>
<a name="ln603">    }</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">/* Return prompt character of specified node. */</a>
<a name="ln607">const char *</a>
<a name="ln608">cmd_prompt (enum node_type node)</a>
<a name="ln609">{</a>
<a name="ln610">  struct cmd_node *cnode;</a>
<a name="ln611"> </a>
<a name="ln612">  cnode = vector_slot (cmdvec, node);</a>
<a name="ln613">  return cnode-&gt;prompt;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">/* Install a command into a node. */</a>
<a name="ln617">void</a>
<a name="ln618">install_element (enum node_type ntype, struct cmd_element *cmd)</a>
<a name="ln619">{</a>
<a name="ln620">  struct cmd_node *cnode;</a>
<a name="ln621">  </a>
<a name="ln622">  /* cmd_init hasn't been called */</a>
<a name="ln623">  if (!cmdvec)</a>
<a name="ln624">    {</a>
<a name="ln625">      fprintf (stderr, &quot;%s called before cmd_init, breakage likely\n&quot;,</a>
<a name="ln626">               __func__);</a>
<a name="ln627">      return;</a>
<a name="ln628">    }</a>
<a name="ln629">  </a>
<a name="ln630">  cnode = vector_slot (cmdvec, ntype);</a>
<a name="ln631"> </a>
<a name="ln632">  if (cnode == NULL) </a>
<a name="ln633">    {</a>
<a name="ln634">      fprintf (stderr, &quot;Command node %d doesn't exist, please check it\n&quot;,</a>
<a name="ln635">	       ntype);</a>
<a name="ln636">      exit (1);</a>
<a name="ln637">    }</a>
<a name="ln638">  </a>
<a name="ln639">  if (hash_lookup (cnode-&gt;cmd_hash, cmd) != NULL)</a>
<a name="ln640">    {</a>
<a name="ln641">#ifdef DEV_BUILD</a>
<a name="ln642">      fprintf (stderr, </a>
<a name="ln643">               &quot;Multiple command installs to node %d of command:\n%s\n&quot;,</a>
<a name="ln644">               ntype, cmd-&gt;string);</a>
<a name="ln645">#endif</a>
<a name="ln646">      return;</a>
<a name="ln647">    }</a>
<a name="ln648">  </a>
<a name="ln649">  assert (hash_get (cnode-&gt;cmd_hash, cmd, hash_alloc_intern));</a>
<a name="ln650">  </a>
<a name="ln651">  vector_set (cnode-&gt;cmd_vector, cmd);</a>
<a name="ln652">  if (cmd-&gt;tokens == NULL)</a>
<a name="ln653">    cmd-&gt;tokens = cmd_parse_format(cmd-&gt;string, cmd-&gt;doc);</a>
<a name="ln654"> </a>
<a name="ln655">  if (ntype == VIEW_NODE)</a>
<a name="ln656">    install_element (ENABLE_NODE, cmd);</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">static const unsigned char itoa64[] =</a>
<a name="ln660">&quot;./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz&quot;;</a>
<a name="ln661"> </a>
<a name="ln662">static void</a>
<a name="ln663">to64(char *s, long v, int n)</a>
<a name="ln664">{</a>
<a name="ln665">  while (--n &gt;= 0) </a>
<a name="ln666">    {</a>
<a name="ln667">      *s++ = itoa64[v&amp;0x3f];</a>
<a name="ln668">      v &gt;&gt;= 6;</a>
<a name="ln669">    }</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">static char *</a>
<a name="ln673">zencrypt (const char *passwd)</a>
<a name="ln674">{</a>
<a name="ln675">  char salt[6];</a>
<a name="ln676">  struct timeval tv;</a>
<a name="ln677">  char *crypt (const char *, const char *);</a>
<a name="ln678"> </a>
<a name="ln679">  gettimeofday(&amp;tv,0);</a>
<a name="ln680">  </a>
<a name="ln681">  to64(&amp;salt[0], random(), 3);</a>
<a name="ln682">  to64(&amp;salt[3], tv.tv_usec, 3);</a>
<a name="ln683">  salt[5] = '\0';</a>
<a name="ln684"> </a>
<a name="ln685">  return crypt (passwd, salt);</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">/* This function write configuration of this host. */</a>
<a name="ln689">static int</a>
<a name="ln690">config_write_host (struct vty *vty)</a>
<a name="ln691">{</a>
<a name="ln692">  if (host.name)</a>
<a name="ln693">    vty_out (vty, &quot;hostname %s%s&quot;, host.name, VTY_NEWLINE);</a>
<a name="ln694"> </a>
<a name="ln695">  if (host.encrypt)</a>
<a name="ln696">    {</a>
<a name="ln697">      if (host.password_encrypt)</a>
<a name="ln698">        vty_out (vty, &quot;password 8 %s%s&quot;, host.password_encrypt, VTY_NEWLINE); </a>
<a name="ln699">      if (host.enable_encrypt)</a>
<a name="ln700">        vty_out (vty, &quot;enable password 8 %s%s&quot;, host.enable_encrypt, VTY_NEWLINE); </a>
<a name="ln701">    }</a>
<a name="ln702">  else</a>
<a name="ln703">    {</a>
<a name="ln704">      if (host.password)</a>
<a name="ln705">        vty_out (vty, &quot;password %s%s&quot;, host.password, VTY_NEWLINE);</a>
<a name="ln706">      if (host.enable)</a>
<a name="ln707">        vty_out (vty, &quot;enable password %s%s&quot;, host.enable, VTY_NEWLINE);</a>
<a name="ln708">    }</a>
<a name="ln709"> </a>
<a name="ln710">  if (zlog_default-&gt;default_lvl != LOG_DEBUG)</a>
<a name="ln711">    {</a>
<a name="ln712">      vty_out (vty, &quot;! N.B. The 'log trap' command is deprecated.%s&quot;,</a>
<a name="ln713">	       VTY_NEWLINE);</a>
<a name="ln714">      vty_out (vty, &quot;log trap %s%s&quot;,</a>
<a name="ln715">	       zlog_priority[zlog_default-&gt;default_lvl], VTY_NEWLINE);</a>
<a name="ln716">    }</a>
<a name="ln717"> </a>
<a name="ln718">  if (host.logfile &amp;&amp; (zlog_default-&gt;maxlvl[ZLOG_DEST_FILE] != ZLOG_DISABLED))</a>
<a name="ln719">    {</a>
<a name="ln720">      vty_out (vty, &quot;log file %s&quot;, host.logfile);</a>
<a name="ln721">      if (zlog_default-&gt;maxlvl[ZLOG_DEST_FILE] != zlog_default-&gt;default_lvl)</a>
<a name="ln722">	vty_out (vty, &quot; %s&quot;,</a>
<a name="ln723">		 zlog_priority[zlog_default-&gt;maxlvl[ZLOG_DEST_FILE]]);</a>
<a name="ln724">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln725">    }</a>
<a name="ln726"> </a>
<a name="ln727">  if (zlog_default-&gt;maxlvl[ZLOG_DEST_STDOUT] != ZLOG_DISABLED)</a>
<a name="ln728">    {</a>
<a name="ln729">      vty_out (vty, &quot;log stdout&quot;);</a>
<a name="ln730">      if (zlog_default-&gt;maxlvl[ZLOG_DEST_STDOUT] != zlog_default-&gt;default_lvl)</a>
<a name="ln731">	vty_out (vty, &quot; %s&quot;,</a>
<a name="ln732">		 zlog_priority[zlog_default-&gt;maxlvl[ZLOG_DEST_STDOUT]]);</a>
<a name="ln733">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln734">    }</a>
<a name="ln735"> </a>
<a name="ln736">  if (zlog_default-&gt;maxlvl[ZLOG_DEST_MONITOR] == ZLOG_DISABLED)</a>
<a name="ln737">    vty_out(vty,&quot;no log monitor%s&quot;,VTY_NEWLINE);</a>
<a name="ln738">  else if (zlog_default-&gt;maxlvl[ZLOG_DEST_MONITOR] != zlog_default-&gt;default_lvl)</a>
<a name="ln739">    vty_out(vty,&quot;log monitor %s%s&quot;,</a>
<a name="ln740">	    zlog_priority[zlog_default-&gt;maxlvl[ZLOG_DEST_MONITOR]],VTY_NEWLINE);</a>
<a name="ln741"> </a>
<a name="ln742">  if (zlog_default-&gt;maxlvl[ZLOG_DEST_SYSLOG] != ZLOG_DISABLED)</a>
<a name="ln743">    {</a>
<a name="ln744">      vty_out (vty, &quot;log syslog&quot;);</a>
<a name="ln745">      if (zlog_default-&gt;maxlvl[ZLOG_DEST_SYSLOG] != zlog_default-&gt;default_lvl)</a>
<a name="ln746">	vty_out (vty, &quot; %s&quot;,</a>
<a name="ln747">		 zlog_priority[zlog_default-&gt;maxlvl[ZLOG_DEST_SYSLOG]]);</a>
<a name="ln748">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln749">    }</a>
<a name="ln750"> </a>
<a name="ln751">  if (zlog_default-&gt;facility != LOG_DAEMON)</a>
<a name="ln752">    vty_out (vty, &quot;log facility %s%s&quot;,</a>
<a name="ln753">	     facility_name(zlog_default-&gt;facility), VTY_NEWLINE);</a>
<a name="ln754"> </a>
<a name="ln755">  if (zlog_default-&gt;record_priority == 1)</a>
<a name="ln756">    vty_out (vty, &quot;log record-priority%s&quot;, VTY_NEWLINE);</a>
<a name="ln757"> </a>
<a name="ln758">  if (zlog_default-&gt;timestamp_precision &gt; 0)</a>
<a name="ln759">    vty_out (vty, &quot;log timestamp precision %d%s&quot;,</a>
<a name="ln760">	     zlog_default-&gt;timestamp_precision, VTY_NEWLINE);</a>
<a name="ln761"> </a>
<a name="ln762">  if (host.advanced)</a>
<a name="ln763">    vty_out (vty, &quot;service advanced-vty%s&quot;, VTY_NEWLINE);</a>
<a name="ln764"> </a>
<a name="ln765">  if (host.encrypt)</a>
<a name="ln766">    vty_out (vty, &quot;service password-encryption%s&quot;, VTY_NEWLINE);</a>
<a name="ln767"> </a>
<a name="ln768">  if (host.lines &gt;= 0)</a>
<a name="ln769">    vty_out (vty, &quot;service terminal-length %d%s&quot;, host.lines,</a>
<a name="ln770">	     VTY_NEWLINE);</a>
<a name="ln771"> </a>
<a name="ln772">  if (host.motdfile)</a>
<a name="ln773">    vty_out (vty, &quot;banner motd file %s%s&quot;, host.motdfile, VTY_NEWLINE);</a>
<a name="ln774">  else if (! host.motd)</a>
<a name="ln775">    vty_out (vty, &quot;no banner motd%s&quot;, VTY_NEWLINE);</a>
<a name="ln776"> </a>
<a name="ln777">  return 1;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">/* Utility function for getting command vector. */</a>
<a name="ln781">static vector</a>
<a name="ln782">cmd_node_vector (vector v, enum node_type ntype)</a>
<a name="ln783">{</a>
<a name="ln784">  struct cmd_node *cnode = vector_slot (v, ntype);</a>
<a name="ln785">  return cnode-&gt;cmd_vector;</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">/* Completion match types. */</a>
<a name="ln789">enum match_type </a>
<a name="ln790">{</a>
<a name="ln791">  no_match,</a>
<a name="ln792">  extend_match,</a>
<a name="ln793">  ipv4_prefix_match,</a>
<a name="ln794">  ipv4_match,</a>
<a name="ln795">  ipv6_prefix_match,</a>
<a name="ln796">  ipv6_match,</a>
<a name="ln797">  range_match,</a>
<a name="ln798">  vararg_match,</a>
<a name="ln799">  partly_match,</a>
<a name="ln800">  exact_match </a>
<a name="ln801">};</a>
<a name="ln802"> </a>
<a name="ln803">static enum match_type</a>
<a name="ln804">cmd_ipv4_match (const char *str)</a>
<a name="ln805">{</a>
<a name="ln806">  const char *sp;</a>
<a name="ln807">  int dots = 0, nums = 0;</a>
<a name="ln808">  char buf[4];</a>
<a name="ln809"> </a>
<a name="ln810">  if (str == NULL)</a>
<a name="ln811">    return partly_match;</a>
<a name="ln812"> </a>
<a name="ln813">  for (;;)</a>
<a name="ln814">    {</a>
<a name="ln815">      memset (buf, 0, sizeof (buf));</a>
<a name="ln816">      sp = str;</a>
<a name="ln817">      while (*str != '\0')</a>
<a name="ln818">	{</a>
<a name="ln819">	  if (*str == '.')</a>
<a name="ln820">	    {</a>
<a name="ln821">	      if (dots &gt;= 3)</a>
<a name="ln822">		return no_match;</a>
<a name="ln823"> </a>
<a name="ln824">	      if (*(str + 1) == '.')</a>
<a name="ln825">		return no_match;</a>
<a name="ln826"> </a>
<a name="ln827">	      if (*(str + 1) == '\0')</a>
<a name="ln828">		return partly_match;</a>
<a name="ln829"> </a>
<a name="ln830">	      dots++;</a>
<a name="ln831">	      break;</a>
<a name="ln832">	    }</a>
<a name="ln833">	  if (!isdigit ((int) *str))</a>
<a name="ln834">	    return no_match;</a>
<a name="ln835"> </a>
<a name="ln836">	  str++;</a>
<a name="ln837">	}</a>
<a name="ln838"> </a>
<a name="ln839">      if (str - sp &gt; 3)</a>
<a name="ln840">	return no_match;</a>
<a name="ln841"> </a>
<a name="ln842">      strncpy (buf, sp, str - sp);</a>
<a name="ln843">      if (atoi (buf) &gt; 255)</a>
<a name="ln844">	return no_match;</a>
<a name="ln845"> </a>
<a name="ln846">      nums++;</a>
<a name="ln847"> </a>
<a name="ln848">      if (*str == '\0')</a>
<a name="ln849">	break;</a>
<a name="ln850"> </a>
<a name="ln851">      str++;</a>
<a name="ln852">    }</a>
<a name="ln853"> </a>
<a name="ln854">  if (nums &lt; 4)</a>
<a name="ln855">    return partly_match;</a>
<a name="ln856"> </a>
<a name="ln857">  return exact_match;</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">static enum match_type</a>
<a name="ln861">cmd_ipv4_prefix_match (const char *str)</a>
<a name="ln862">{</a>
<a name="ln863">  const char *sp;</a>
<a name="ln864">  int dots = 0;</a>
<a name="ln865">  char buf[4];</a>
<a name="ln866"> </a>
<a name="ln867">  if (str == NULL)</a>
<a name="ln868">    return partly_match;</a>
<a name="ln869"> </a>
<a name="ln870">  for (;;)</a>
<a name="ln871">    {</a>
<a name="ln872">      memset (buf, 0, sizeof (buf));</a>
<a name="ln873">      sp = str;</a>
<a name="ln874">      while (*str != '\0' &amp;&amp; *str != '/')</a>
<a name="ln875">	{</a>
<a name="ln876">	  if (*str == '.')</a>
<a name="ln877">	    {</a>
<a name="ln878">	      if (dots == 3)</a>
<a name="ln879">		return no_match;</a>
<a name="ln880"> </a>
<a name="ln881">	      if (*(str + 1) == '.' || *(str + 1) == '/')</a>
<a name="ln882">		return no_match;</a>
<a name="ln883"> </a>
<a name="ln884">	      if (*(str + 1) == '\0')</a>
<a name="ln885">		return partly_match;</a>
<a name="ln886"> </a>
<a name="ln887">	      dots++;</a>
<a name="ln888">	      break;</a>
<a name="ln889">	    }</a>
<a name="ln890"> </a>
<a name="ln891">	  if (!isdigit ((int) *str))</a>
<a name="ln892">	    return no_match;</a>
<a name="ln893"> </a>
<a name="ln894">	  str++;</a>
<a name="ln895">	}</a>
<a name="ln896"> </a>
<a name="ln897">      if (str - sp &gt; 3)</a>
<a name="ln898">	return no_match;</a>
<a name="ln899"> </a>
<a name="ln900">      strncpy (buf, sp, str - sp);</a>
<a name="ln901">      if (atoi (buf) &gt; 255)</a>
<a name="ln902">	return no_match;</a>
<a name="ln903"> </a>
<a name="ln904">      if (dots == 3)</a>
<a name="ln905">	{</a>
<a name="ln906">	  if (*str == '/')</a>
<a name="ln907">	    {</a>
<a name="ln908">	      if (*(str + 1) == '\0')</a>
<a name="ln909">		return partly_match;</a>
<a name="ln910"> </a>
<a name="ln911">	      str++;</a>
<a name="ln912">	      break;</a>
<a name="ln913">	    }</a>
<a name="ln914">	  else if (*str == '\0')</a>
<a name="ln915">	    return partly_match;</a>
<a name="ln916">	}</a>
<a name="ln917"> </a>
<a name="ln918">      if (*str == '\0')</a>
<a name="ln919">	return partly_match;</a>
<a name="ln920"> </a>
<a name="ln921">      str++;</a>
<a name="ln922">    }</a>
<a name="ln923"> </a>
<a name="ln924">  sp = str;</a>
<a name="ln925">  while (*str != '\0')</a>
<a name="ln926">    {</a>
<a name="ln927">      if (!isdigit ((int) *str))</a>
<a name="ln928">	return no_match;</a>
<a name="ln929"> </a>
<a name="ln930">      str++;</a>
<a name="ln931">    }</a>
<a name="ln932"> </a>
<a name="ln933">  if (atoi (sp) &gt; 32)</a>
<a name="ln934">    return no_match;</a>
<a name="ln935"> </a>
<a name="ln936">  return exact_match;</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939">#define IPV6_ADDR_STR		&quot;0123456789abcdefABCDEF:.%&quot;</a>
<a name="ln940">#define IPV6_PREFIX_STR		&quot;0123456789abcdefABCDEF:.%/&quot;</a>
<a name="ln941">#define STATE_START		1</a>
<a name="ln942">#define STATE_COLON		2</a>
<a name="ln943">#define STATE_DOUBLE		3</a>
<a name="ln944">#define STATE_ADDR		4</a>
<a name="ln945">#define STATE_DOT               5</a>
<a name="ln946">#define STATE_SLASH		6</a>
<a name="ln947">#define STATE_MASK		7</a>
<a name="ln948"> </a>
<a name="ln949">#ifdef HAVE_IPV6</a>
<a name="ln950"> </a>
<a name="ln951">static enum match_type</a>
<a name="ln952">cmd_ipv6_match (const char *str)</a>
<a name="ln953">{</a>
<a name="ln954">  struct sockaddr_in6 sin6_dummy;</a>
<a name="ln955">  int ret;</a>
<a name="ln956"> </a>
<a name="ln957">  if (str == NULL)</a>
<a name="ln958">    return partly_match;</a>
<a name="ln959"> </a>
<a name="ln960">  if (strspn (str, IPV6_ADDR_STR) != strlen (str))</a>
<a name="ln961">    return no_match;</a>
<a name="ln962"> </a>
<a name="ln963">  /* use inet_pton that has a better support,</a>
<a name="ln964">   * for example inet_pton can support the automatic addresses:</a>
<a name="ln965">   *  ::1.2.3.4</a>
<a name="ln966">   */</a>
<a name="ln967">  ret = inet_pton(AF_INET6, str, &amp;sin6_dummy.sin6_addr);</a>
<a name="ln968">   </a>
<a name="ln969">  if (ret == 1)</a>
<a name="ln970">    return exact_match;</a>
<a name="ln971"> </a>
<a name="ln972">  return no_match;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">static enum match_type</a>
<a name="ln976">cmd_ipv6_prefix_match (const char *str)</a>
<a name="ln977">{</a>
<a name="ln978">  int state = STATE_START;</a>
<a name="ln979">  int colons = 0, nums = 0, double_colon = 0;</a>
<a name="ln980">  int mask;</a>
<a name="ln981">  const char *sp = NULL;</a>
<a name="ln982">  char *endptr = NULL;</a>
<a name="ln983"> </a>
<a name="ln984">  if (str == NULL)</a>
<a name="ln985">    return partly_match;</a>
<a name="ln986"> </a>
<a name="ln987">  if (strspn (str, IPV6_PREFIX_STR) != strlen (str))</a>
<a name="ln988">    return no_match;</a>
<a name="ln989"> </a>
<a name="ln990">  while (*str != '\0' &amp;&amp; state != STATE_MASK)</a>
<a name="ln991">    {</a>
<a name="ln992">      switch (state)</a>
<a name="ln993">	{</a>
<a name="ln994">	case STATE_START:</a>
<a name="ln995">	  if (*str == ':')</a>
<a name="ln996">	    {</a>
<a name="ln997">	      if (*(str + 1) != ':' &amp;&amp; *(str + 1) != '\0')</a>
<a name="ln998">		return no_match;</a>
<a name="ln999">	      colons--;</a>
<a name="ln1000">	      state = STATE_COLON;</a>
<a name="ln1001">	    }</a>
<a name="ln1002">	  else</a>
<a name="ln1003">	    {</a>
<a name="ln1004">	      sp = str;</a>
<a name="ln1005">	      state = STATE_ADDR;</a>
<a name="ln1006">	    }</a>
<a name="ln1007"> </a>
<a name="ln1008">	  continue;</a>
<a name="ln1009">	case STATE_COLON:</a>
<a name="ln1010">	  colons++;</a>
<a name="ln1011">	  if (*(str + 1) == '/')</a>
<a name="ln1012">	    return no_match;</a>
<a name="ln1013">	  else if (*(str + 1) == ':')</a>
<a name="ln1014">	    state = STATE_DOUBLE;</a>
<a name="ln1015">	  else</a>
<a name="ln1016">	    {</a>
<a name="ln1017">	      sp = str + 1;</a>
<a name="ln1018">	      state = STATE_ADDR;</a>
<a name="ln1019">	    }</a>
<a name="ln1020">	  break;</a>
<a name="ln1021">	case STATE_DOUBLE:</a>
<a name="ln1022">	  if (double_colon)</a>
<a name="ln1023">	    return no_match;</a>
<a name="ln1024"> </a>
<a name="ln1025">	  if (*(str + 1) == ':')</a>
<a name="ln1026">	    return no_match;</a>
<a name="ln1027">	  else</a>
<a name="ln1028">	    {</a>
<a name="ln1029">	      if (*(str + 1) != '\0' &amp;&amp; *(str + 1) != '/')</a>
<a name="ln1030">		colons++;</a>
<a name="ln1031">	      sp = str + 1;</a>
<a name="ln1032"> </a>
<a name="ln1033">	      if (*(str + 1) == '/')</a>
<a name="ln1034">		state = STATE_SLASH;</a>
<a name="ln1035">	      else</a>
<a name="ln1036">		state = STATE_ADDR;</a>
<a name="ln1037">	    }</a>
<a name="ln1038"> </a>
<a name="ln1039">	  double_colon++;</a>
<a name="ln1040">	  nums += 1;</a>
<a name="ln1041">	  break;</a>
<a name="ln1042">	case STATE_ADDR:</a>
<a name="ln1043">	  if (*(str + 1) == ':' || *(str + 1) == '.'</a>
<a name="ln1044">	      || *(str + 1) == '\0' || *(str + 1) == '/')</a>
<a name="ln1045">	    {</a>
<a name="ln1046">	      if (str - sp &gt; 3)</a>
<a name="ln1047">		return no_match;</a>
<a name="ln1048"> </a>
<a name="ln1049">	      for (; sp &lt;= str; sp++)</a>
<a name="ln1050">		if (*sp == '/')</a>
<a name="ln1051">		  return no_match;</a>
<a name="ln1052"> </a>
<a name="ln1053">	      nums++;</a>
<a name="ln1054"> </a>
<a name="ln1055">	      if (*(str + 1) == ':')</a>
<a name="ln1056">		state = STATE_COLON;</a>
<a name="ln1057">	      else if (*(str + 1) == '.')</a>
<a name="ln1058">		{</a>
<a name="ln1059">		  if (colons || double_colon)</a>
<a name="ln1060">		    state = STATE_DOT;</a>
<a name="ln1061">		  else</a>
<a name="ln1062">		    return no_match;</a>
<a name="ln1063">		}</a>
<a name="ln1064">	      else if (*(str + 1) == '/')</a>
<a name="ln1065">		state = STATE_SLASH;</a>
<a name="ln1066">	    }</a>
<a name="ln1067">	  break;</a>
<a name="ln1068">	case STATE_DOT:</a>
<a name="ln1069">	  state = STATE_ADDR;</a>
<a name="ln1070">	  break;</a>
<a name="ln1071">	case STATE_SLASH:</a>
<a name="ln1072">	  if (*(str + 1) == '\0')</a>
<a name="ln1073">	    return partly_match;</a>
<a name="ln1074"> </a>
<a name="ln1075">	  state = STATE_MASK;</a>
<a name="ln1076">	  break;</a>
<a name="ln1077">	default:</a>
<a name="ln1078">	  break;</a>
<a name="ln1079">	}</a>
<a name="ln1080"> </a>
<a name="ln1081">      if (nums &gt; 11)</a>
<a name="ln1082">	return no_match;</a>
<a name="ln1083"> </a>
<a name="ln1084">      if (colons &gt; 7)</a>
<a name="ln1085">	return no_match;</a>
<a name="ln1086"> </a>
<a name="ln1087">      str++;</a>
<a name="ln1088">    }</a>
<a name="ln1089"> </a>
<a name="ln1090">  if (state &lt; STATE_MASK)</a>
<a name="ln1091">    return partly_match;</a>
<a name="ln1092"> </a>
<a name="ln1093">  mask = strtol (str, &amp;endptr, 10);</a>
<a name="ln1094">  if (*endptr != '\0')</a>
<a name="ln1095">    return no_match;</a>
<a name="ln1096"> </a>
<a name="ln1097">  if (mask &lt; 0 || mask &gt; 128)</a>
<a name="ln1098">    return no_match;</a>
<a name="ln1099">  </a>
<a name="ln1100">  return exact_match;</a>
<a name="ln1101">}</a>
<a name="ln1102"> </a>
<a name="ln1103">#endif /* HAVE_IPV6  */</a>
<a name="ln1104"> </a>
<a name="ln1105">#define DECIMAL_STRLEN_MAX 10</a>
<a name="ln1106"> </a>
<a name="ln1107">static int</a>
<a name="ln1108">cmd_range_match (const char *range, const char *str)</a>
<a name="ln1109">{</a>
<a name="ln1110">  char *p;</a>
<a name="ln1111">  char buf[DECIMAL_STRLEN_MAX + 1];</a>
<a name="ln1112">  char *endptr = NULL;</a>
<a name="ln1113">  unsigned long min, max, val;</a>
<a name="ln1114"> </a>
<a name="ln1115">  if (str == NULL)</a>
<a name="ln1116">    return 1;</a>
<a name="ln1117"> </a>
<a name="ln1118">  val = strtoul (str, &amp;endptr, 10);</a>
<a name="ln1119">  if (*endptr != '\0')</a>
<a name="ln1120">    return 0;</a>
<a name="ln1121"> </a>
<a name="ln1122">  range++;</a>
<a name="ln1123">  p = strchr (range, '-');</a>
<a name="ln1124">  if (p == NULL)</a>
<a name="ln1125">    return 0;</a>
<a name="ln1126">  if (p - range &gt; DECIMAL_STRLEN_MAX)</a>
<a name="ln1127">    return 0;</a>
<a name="ln1128">  strncpy (buf, range, p - range);</a>
<a name="ln1129">  buf[p - range] = '\0';</a>
<a name="ln1130">  min = strtoul (buf, &amp;endptr, 10);</a>
<a name="ln1131">  if (*endptr != '\0')</a>
<a name="ln1132">    return 0;</a>
<a name="ln1133"> </a>
<a name="ln1134">  range = p + 1;</a>
<a name="ln1135">  p = strchr (range, '&gt;');</a>
<a name="ln1136">  if (p == NULL)</a>
<a name="ln1137">    return 0;</a>
<a name="ln1138">  if (p - range &gt; DECIMAL_STRLEN_MAX)</a>
<a name="ln1139">    return 0;</a>
<a name="ln1140">  strncpy (buf, range, p - range);</a>
<a name="ln1141">  buf[p - range] = '\0';</a>
<a name="ln1142">  max = strtoul (buf, &amp;endptr, 10);</a>
<a name="ln1143">  if (*endptr != '\0')</a>
<a name="ln1144">    return 0;</a>
<a name="ln1145"> </a>
<a name="ln1146">  if (val &lt; min || val &gt; max)</a>
<a name="ln1147">    return 0;</a>
<a name="ln1148"> </a>
<a name="ln1149">  return 1;</a>
<a name="ln1150">}</a>
<a name="ln1151"> </a>
<a name="ln1152">static enum match_type</a>
<a name="ln1153">cmd_word_match(struct cmd_token *token,</a>
<a name="ln1154">               enum filter_type filter,</a>
<a name="ln1155">               const char *word)</a>
<a name="ln1156">{</a>
<a name="ln1157">  const char *str;</a>
<a name="ln1158">  enum match_type match_type;</a>
<a name="ln1159"> </a>
<a name="ln1160">  str = token-&gt;cmd;</a>
<a name="ln1161"> </a>
<a name="ln1162">  if (filter == FILTER_RELAXED)</a>
<a name="ln1163">    if (!word || !strlen(word))</a>
<a name="ln1164">      return partly_match;</a>
<a name="ln1165"> </a>
<a name="ln1166">  if (!word)</a>
<a name="ln1167">    return no_match;</a>
<a name="ln1168"> </a>
<a name="ln1169">  switch (token-&gt;terminal)</a>
<a name="ln1170">    {</a>
<a name="ln1171">      case TERMINAL_VARARG:</a>
<a name="ln1172">        return vararg_match;</a>
<a name="ln1173"> </a>
<a name="ln1174">      case TERMINAL_RANGE:</a>
<a name="ln1175">        if (cmd_range_match(str, word))</a>
<a name="ln1176">          return range_match;</a>
<a name="ln1177">        break;</a>
<a name="ln1178"> </a>
<a name="ln1179">      case TERMINAL_IPV6:</a>
<a name="ln1180">        match_type = cmd_ipv6_match(word);</a>
<a name="ln1181">        if ((filter == FILTER_RELAXED &amp;&amp; match_type != no_match)</a>
<a name="ln1182">          || (filter == FILTER_STRICT &amp;&amp; match_type == exact_match))</a>
<a name="ln1183">          return ipv6_match;</a>
<a name="ln1184">        break;</a>
<a name="ln1185"> </a>
<a name="ln1186">      case TERMINAL_IPV6_PREFIX:</a>
<a name="ln1187">        match_type = cmd_ipv6_prefix_match(word);</a>
<a name="ln1188">        if ((filter == FILTER_RELAXED &amp;&amp; match_type != no_match)</a>
<a name="ln1189">            || (filter == FILTER_STRICT &amp;&amp; match_type == exact_match))</a>
<a name="ln1190">          return ipv6_prefix_match;</a>
<a name="ln1191">        break;</a>
<a name="ln1192"> </a>
<a name="ln1193">      case TERMINAL_IPV4:</a>
<a name="ln1194">        match_type = cmd_ipv4_match(word);</a>
<a name="ln1195">        if ((filter == FILTER_RELAXED &amp;&amp; match_type != no_match)</a>
<a name="ln1196">            || (filter == FILTER_STRICT &amp;&amp; match_type == exact_match))</a>
<a name="ln1197">          return ipv4_match;</a>
<a name="ln1198">        break;</a>
<a name="ln1199"> </a>
<a name="ln1200">      case TERMINAL_IPV4_PREFIX:</a>
<a name="ln1201">        match_type = cmd_ipv4_prefix_match(word);</a>
<a name="ln1202">        if ((filter == FILTER_RELAXED &amp;&amp; match_type != no_match)</a>
<a name="ln1203">            || (filter == FILTER_STRICT &amp;&amp; match_type == exact_match))</a>
<a name="ln1204">          return ipv4_prefix_match;</a>
<a name="ln1205">        break;</a>
<a name="ln1206"> </a>
<a name="ln1207">      case TERMINAL_OPTION:</a>
<a name="ln1208">      case TERMINAL_VARIABLE:</a>
<a name="ln1209">        return extend_match;</a>
<a name="ln1210"> </a>
<a name="ln1211">      case TERMINAL_LITERAL:</a>
<a name="ln1212">        if (filter == FILTER_RELAXED &amp;&amp; !strncmp(str, word, strlen(word)))</a>
<a name="ln1213">          {</a>
<a name="ln1214">            if (!strcmp(str, word))</a>
<a name="ln1215">              return exact_match;</a>
<a name="ln1216">            return partly_match;</a>
<a name="ln1217">          }</a>
<a name="ln1218">        if (filter == FILTER_STRICT &amp;&amp; !strcmp(str, word))</a>
<a name="ln1219">          return exact_match;</a>
<a name="ln1220">        break;</a>
<a name="ln1221"> </a>
<a name="ln1222">      default:</a>
<a name="ln1223">        assert (0);</a>
<a name="ln1224">    }</a>
<a name="ln1225"> </a>
<a name="ln1226">  return no_match;</a>
<a name="ln1227">}</a>
<a name="ln1228"> </a>
<a name="ln1229">struct cmd_matcher</a>
<a name="ln1230">{</a>
<a name="ln1231">  struct cmd_element *cmd; /* The command element the matcher is using */</a>
<a name="ln1232">  enum filter_type filter; /* Whether to use strict or relaxed matching */</a>
<a name="ln1233">  vector vline; /* The tokenized commandline which is to be matched */</a>
<a name="ln1234">  unsigned int index; /* The index up to which matching should be done */</a>
<a name="ln1235"> </a>
<a name="ln1236">  /* If set, construct a list of matches at the position given by index */</a>
<a name="ln1237">  enum match_type *match_type;</a>
<a name="ln1238">  vector *match;</a>
<a name="ln1239"> </a>
<a name="ln1240">  unsigned int word_index; /* iterating over vline */</a>
<a name="ln1241">};</a>
<a name="ln1242"> </a>
<a name="ln1243">static int</a>
<a name="ln1244">push_argument(int *argc, const char **argv, const char *arg)</a>
<a name="ln1245">{</a>
<a name="ln1246">  if (!arg || !strlen(arg))</a>
<a name="ln1247">    arg = NULL;</a>
<a name="ln1248"> </a>
<a name="ln1249">  if (!argc || !argv)</a>
<a name="ln1250">    return 0;</a>
<a name="ln1251"> </a>
<a name="ln1252">  if (*argc &gt;= CMD_ARGC_MAX)</a>
<a name="ln1253">    return -1;</a>
<a name="ln1254"> </a>
<a name="ln1255">  argv[(*argc)++] = arg;</a>
<a name="ln1256">  return 0;</a>
<a name="ln1257">}</a>
<a name="ln1258"> </a>
<a name="ln1259">static void</a>
<a name="ln1260">cmd_matcher_record_match(struct cmd_matcher *matcher,</a>
<a name="ln1261">                         enum match_type match_type,</a>
<a name="ln1262">                         struct cmd_token *token)</a>
<a name="ln1263">{</a>
<a name="ln1264">  if (matcher-&gt;word_index != matcher-&gt;index)</a>
<a name="ln1265">    return;</a>
<a name="ln1266"> </a>
<a name="ln1267">  if (matcher-&gt;match)</a>
<a name="ln1268">    {</a>
<a name="ln1269">      if (!*matcher-&gt;match)</a>
<a name="ln1270">        *matcher-&gt;match = vector_init(VECTOR_MIN_SIZE);</a>
<a name="ln1271">      vector_set(*matcher-&gt;match, token);</a>
<a name="ln1272">    }</a>
<a name="ln1273"> </a>
<a name="ln1274">  if (matcher-&gt;match_type)</a>
<a name="ln1275">    {</a>
<a name="ln1276">      if (match_type &gt; *matcher-&gt;match_type)</a>
<a name="ln1277">        *matcher-&gt;match_type = match_type;</a>
<a name="ln1278">    }</a>
<a name="ln1279">}</a>
<a name="ln1280"> </a>
<a name="ln1281">static int</a>
<a name="ln1282">cmd_matcher_words_left(struct cmd_matcher *matcher)</a>
<a name="ln1283">{</a>
<a name="ln1284">  return matcher-&gt;word_index &lt; vector_active(matcher-&gt;vline);</a>
<a name="ln1285">}</a>
<a name="ln1286"> </a>
<a name="ln1287">static const char*</a>
<a name="ln1288">cmd_matcher_get_word(struct cmd_matcher *matcher)</a>
<a name="ln1289">{</a>
<a name="ln1290">  assert(cmd_matcher_words_left(matcher));</a>
<a name="ln1291"> </a>
<a name="ln1292">  return vector_slot(matcher-&gt;vline, matcher-&gt;word_index);</a>
<a name="ln1293">}</a>
<a name="ln1294"> </a>
<a name="ln1295">static enum matcher_rv</a>
<a name="ln1296">cmd_matcher_match_terminal(struct cmd_matcher *matcher,</a>
<a name="ln1297">                           struct cmd_token *token,</a>
<a name="ln1298">                           int *argc, const char **argv)</a>
<a name="ln1299">{</a>
<a name="ln1300">  const char *word;</a>
<a name="ln1301">  enum match_type word_match;</a>
<a name="ln1302"> </a>
<a name="ln1303">  assert(token-&gt;type == TOKEN_TERMINAL);</a>
<a name="ln1304"> </a>
<a name="ln1305">  if (!cmd_matcher_words_left(matcher))</a>
<a name="ln1306">    {</a>
<a name="ln1307">      if (token-&gt;terminal == TERMINAL_OPTION)</a>
<a name="ln1308">        return MATCHER_OK; /* missing optional args are NOT pushed as NULL */</a>
<a name="ln1309">      else</a>
<a name="ln1310">        return MATCHER_INCOMPLETE;</a>
<a name="ln1311">    }</a>
<a name="ln1312"> </a>
<a name="ln1313">  word = cmd_matcher_get_word(matcher);</a>
<a name="ln1314">  word_match = cmd_word_match(token, matcher-&gt;filter, word);</a>
<a name="ln1315">  if (word_match == no_match)</a>
<a name="ln1316">    return MATCHER_NO_MATCH;</a>
<a name="ln1317"> </a>
<a name="ln1318">  /* We have to record the input word as argument if it matched</a>
<a name="ln1319">   * against a variable. */</a>
<a name="ln1320">  if (TERMINAL_RECORD (token-&gt;terminal))</a>
<a name="ln1321">    {</a>
<a name="ln1322">      if (push_argument(argc, argv, word))</a>
<a name="ln1323">        return MATCHER_EXCEED_ARGC_MAX;</a>
<a name="ln1324">    }</a>
<a name="ln1325"> </a>
<a name="ln1326">  cmd_matcher_record_match(matcher, word_match, token);</a>
<a name="ln1327"> </a>
<a name="ln1328">  matcher-&gt;word_index++;</a>
<a name="ln1329"> </a>
<a name="ln1330">  /* A vararg token should consume all left over words as arguments */</a>
<a name="ln1331">  if (token-&gt;terminal == TERMINAL_VARARG)</a>
<a name="ln1332">    while (cmd_matcher_words_left(matcher))</a>
<a name="ln1333">      {</a>
<a name="ln1334">        word = cmd_matcher_get_word(matcher);</a>
<a name="ln1335">        if (word &amp;&amp; strlen(word))</a>
<a name="ln1336">          push_argument(argc, argv, word);</a>
<a name="ln1337">        matcher-&gt;word_index++;</a>
<a name="ln1338">      }</a>
<a name="ln1339"> </a>
<a name="ln1340">  return MATCHER_OK;</a>
<a name="ln1341">}</a>
<a name="ln1342"> </a>
<a name="ln1343">static enum matcher_rv</a>
<a name="ln1344">cmd_matcher_match_multiple(struct cmd_matcher *matcher,</a>
<a name="ln1345">                           struct cmd_token *token,</a>
<a name="ln1346">                           int *argc, const char **argv)</a>
<a name="ln1347">{</a>
<a name="ln1348">  enum match_type multiple_match;</a>
<a name="ln1349">  unsigned int multiple_index;</a>
<a name="ln1350">  const char *word;</a>
<a name="ln1351">  const char *arg = NULL;</a>
<a name="ln1352">  struct cmd_token *word_token;</a>
<a name="ln1353">  enum match_type word_match;</a>
<a name="ln1354"> </a>
<a name="ln1355">  assert(token-&gt;type == TOKEN_MULTIPLE);</a>
<a name="ln1356"> </a>
<a name="ln1357">  multiple_match = no_match;</a>
<a name="ln1358"> </a>
<a name="ln1359">  if (!cmd_matcher_words_left(matcher))</a>
<a name="ln1360">    return MATCHER_INCOMPLETE;</a>
<a name="ln1361"> </a>
<a name="ln1362">  word = cmd_matcher_get_word(matcher);</a>
<a name="ln1363">  for (multiple_index = 0;</a>
<a name="ln1364">       multiple_index &lt; vector_active(token-&gt;multiple);</a>
<a name="ln1365">       multiple_index++)</a>
<a name="ln1366">    {</a>
<a name="ln1367">      word_token = vector_slot(token-&gt;multiple, multiple_index);</a>
<a name="ln1368"> </a>
<a name="ln1369">      word_match = cmd_word_match(word_token, matcher-&gt;filter, word);</a>
<a name="ln1370">      if (word_match == no_match)</a>
<a name="ln1371">        continue;</a>
<a name="ln1372"> </a>
<a name="ln1373">      cmd_matcher_record_match(matcher, word_match, word_token);</a>
<a name="ln1374"> </a>
<a name="ln1375">      if (word_match &gt; multiple_match)</a>
<a name="ln1376">        {</a>
<a name="ln1377">          multiple_match = word_match;</a>
<a name="ln1378">          arg = word;</a>
<a name="ln1379">        }</a>
<a name="ln1380">      /* To mimic the behavior of the old command implementation, we</a>
<a name="ln1381">       * tolerate any ambiguities here :/ */</a>
<a name="ln1382">    }</a>
<a name="ln1383"> </a>
<a name="ln1384">  matcher-&gt;word_index++;</a>
<a name="ln1385"> </a>
<a name="ln1386">  if (multiple_match == no_match)</a>
<a name="ln1387">    return MATCHER_NO_MATCH;</a>
<a name="ln1388"> </a>
<a name="ln1389">  if (push_argument(argc, argv, arg))</a>
<a name="ln1390">    return MATCHER_EXCEED_ARGC_MAX;</a>
<a name="ln1391"> </a>
<a name="ln1392">  return MATCHER_OK;</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">static enum matcher_rv</a>
<a name="ln1396">cmd_matcher_read_keywords(struct cmd_matcher *matcher,</a>
<a name="ln1397">                          struct cmd_token *token,</a>
<a name="ln1398">                          vector args_vector)</a>
<a name="ln1399">{</a>
<a name="ln1400">  unsigned int i;</a>
<a name="ln1401">  unsigned long keyword_mask;</a>
<a name="ln1402">  unsigned int keyword_found;</a>
<a name="ln1403">  enum match_type keyword_match;</a>
<a name="ln1404">  enum match_type word_match;</a>
<a name="ln1405">  vector keyword_vector;</a>
<a name="ln1406">  struct cmd_token *word_token;</a>
<a name="ln1407">  const char *word;</a>
<a name="ln1408">  int keyword_argc;</a>
<a name="ln1409">  const char **keyword_argv;</a>
<a name="ln1410">  enum matcher_rv rv = MATCHER_NO_MATCH;</a>
<a name="ln1411"> </a>
<a name="ln1412">  keyword_mask = 0;</a>
<a name="ln1413">  while (1)</a>
<a name="ln1414">    {</a>
<a name="ln1415">      if (!cmd_matcher_words_left(matcher))</a>
<a name="ln1416">        return MATCHER_OK;</a>
<a name="ln1417"> </a>
<a name="ln1418">      word = cmd_matcher_get_word(matcher);</a>
<a name="ln1419"> </a>
<a name="ln1420">      keyword_found = -1;</a>
<a name="ln1421">      keyword_match = no_match;</a>
<a name="ln1422">      for (i = 0; i &lt; vector_active(token-&gt;keyword); i++)</a>
<a name="ln1423">        {</a>
<a name="ln1424">          if (keyword_mask &amp; (1 &lt;&lt; i))</a>
<a name="ln1425">            continue;</a>
<a name="ln1426"> </a>
<a name="ln1427">          keyword_vector = vector_slot(token-&gt;keyword, i);</a>
<a name="ln1428">          word_token = vector_slot(keyword_vector, 0);</a>
<a name="ln1429"> </a>
<a name="ln1430">          word_match = cmd_word_match(word_token, matcher-&gt;filter, word);</a>
<a name="ln1431">          if (word_match == no_match)</a>
<a name="ln1432">            continue;</a>
<a name="ln1433"> </a>
<a name="ln1434">          cmd_matcher_record_match(matcher, word_match, word_token);</a>
<a name="ln1435"> </a>
<a name="ln1436">          if (word_match &gt; keyword_match)</a>
<a name="ln1437">            {</a>
<a name="ln1438">              keyword_match = word_match;</a>
<a name="ln1439">              keyword_found = i;</a>
<a name="ln1440">            }</a>
<a name="ln1441">          else if (word_match == keyword_match)</a>
<a name="ln1442">            {</a>
<a name="ln1443">              if (matcher-&gt;word_index != matcher-&gt;index || args_vector)</a>
<a name="ln1444">                return MATCHER_AMBIGUOUS;</a>
<a name="ln1445">            }</a>
<a name="ln1446">        }</a>
<a name="ln1447"> </a>
<a name="ln1448">      if (keyword_found == (unsigned int)-1)</a>
<a name="ln1449">        return MATCHER_NO_MATCH;</a>
<a name="ln1450"> </a>
<a name="ln1451">      matcher-&gt;word_index++;</a>
<a name="ln1452"> </a>
<a name="ln1453">      if (matcher-&gt;word_index &gt; matcher-&gt;index)</a>
<a name="ln1454">        return MATCHER_OK;</a>
<a name="ln1455"> </a>
<a name="ln1456">      keyword_mask |= (1 &lt;&lt; keyword_found);</a>
<a name="ln1457"> </a>
<a name="ln1458">      if (args_vector)</a>
<a name="ln1459">        {</a>
<a name="ln1460">          keyword_argc = 0;</a>
<a name="ln1461">          keyword_argv = XMALLOC(MTYPE_TMP, (CMD_ARGC_MAX + 1) * sizeof(char*));</a>
<a name="ln1462">          /* We use -1 as a marker for unused fields as NULL might be a valid value */</a>
<a name="ln1463">          for (i = 0; i &lt; CMD_ARGC_MAX + 1; i++)</a>
<a name="ln1464">            keyword_argv[i] = (void*)-1;</a>
<a name="ln1465">          vector_set_index(args_vector, keyword_found, keyword_argv);</a>
<a name="ln1466">        }</a>
<a name="ln1467">      else</a>
<a name="ln1468">        {</a>
<a name="ln1469">          keyword_argv = NULL;</a>
<a name="ln1470">        }</a>
<a name="ln1471"> </a>
<a name="ln1472">      keyword_vector = vector_slot(token-&gt;keyword, keyword_found);</a>
<a name="ln1473">      /* the keyword itself is at 0. We are only interested in the arguments,</a>
<a name="ln1474">       * so start counting at 1. */</a>
<a name="ln1475">      for (i = 1; i &lt; vector_active(keyword_vector); i++)</a>
<a name="ln1476">        {</a>
<a name="ln1477">          word_token = vector_slot(keyword_vector, i);</a>
<a name="ln1478"> </a>
<a name="ln1479">          switch (word_token-&gt;type)</a>
<a name="ln1480">            {</a>
<a name="ln1481">            case TOKEN_TERMINAL:</a>
<a name="ln1482">              rv = cmd_matcher_match_terminal(matcher, word_token,</a>
<a name="ln1483">                                              &amp;keyword_argc, keyword_argv);</a>
<a name="ln1484">              break;</a>
<a name="ln1485">            case TOKEN_MULTIPLE:</a>
<a name="ln1486">              rv = cmd_matcher_match_multiple(matcher, word_token,</a>
<a name="ln1487">                                              &amp;keyword_argc, keyword_argv);</a>
<a name="ln1488">              break;</a>
<a name="ln1489">            case TOKEN_KEYWORD:</a>
<a name="ln1490">              assert(!&quot;Keywords should never be nested.&quot;);</a>
<a name="ln1491">              break;</a>
<a name="ln1492">            }</a>
<a name="ln1493"> </a>
<a name="ln1494">          if (MATCHER_ERROR(rv))</a>
<a name="ln1495">            return rv;</a>
<a name="ln1496"> </a>
<a name="ln1497">          if (matcher-&gt;word_index &gt; matcher-&gt;index)</a>
<a name="ln1498">            return MATCHER_OK;</a>
<a name="ln1499">        }</a>
<a name="ln1500">    }</a>
<a name="ln1501">  /* not reached */</a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>
<a name="ln1504">static enum matcher_rv</a>
<a name="ln1505">cmd_matcher_build_keyword_args(struct cmd_matcher *matcher,</a>
<a name="ln1506">                               struct cmd_token *token,</a>
<a name="ln1507">                               int *argc, const char **argv,</a>
<a name="ln1508">                               vector keyword_args_vector)</a>
<a name="ln1509">{</a>
<a name="ln1510">  unsigned int i, j;</a>
<a name="ln1511">  const char **keyword_args;</a>
<a name="ln1512">  vector keyword_vector;</a>
<a name="ln1513">  struct cmd_token *word_token;</a>
<a name="ln1514">  const char *arg;</a>
<a name="ln1515">  enum matcher_rv rv;</a>
<a name="ln1516"> </a>
<a name="ln1517">  rv = MATCHER_OK;</a>
<a name="ln1518"> </a>
<a name="ln1519">  if (keyword_args_vector == NULL)</a>
<a name="ln1520">    return rv;</a>
<a name="ln1521"> </a>
<a name="ln1522">  for (i = 0; i &lt; vector_active(token-&gt;keyword); i++)</a>
<a name="ln1523">    {</a>
<a name="ln1524">      keyword_vector = vector_slot(token-&gt;keyword, i);</a>
<a name="ln1525">      keyword_args = vector_lookup(keyword_args_vector, i);</a>
<a name="ln1526"> </a>
<a name="ln1527">      if (vector_active(keyword_vector) == 1)</a>
<a name="ln1528">        {</a>
<a name="ln1529">          /* this is a keyword without arguments */</a>
<a name="ln1530">          if (keyword_args)</a>
<a name="ln1531">            {</a>
<a name="ln1532">              word_token = vector_slot(keyword_vector, 0);</a>
<a name="ln1533">              arg = word_token-&gt;cmd;</a>
<a name="ln1534">            }</a>
<a name="ln1535">          else</a>
<a name="ln1536">            {</a>
<a name="ln1537">              arg = NULL;</a>
<a name="ln1538">            }</a>
<a name="ln1539"> </a>
<a name="ln1540">          if (push_argument(argc, argv, arg))</a>
<a name="ln1541">            rv = MATCHER_EXCEED_ARGC_MAX;</a>
<a name="ln1542">        }</a>
<a name="ln1543">      else</a>
<a name="ln1544">        {</a>
<a name="ln1545">          /* this is a keyword with arguments */</a>
<a name="ln1546">          if (keyword_args)</a>
<a name="ln1547">            {</a>
<a name="ln1548">              /* the keyword was present, so just fill in the arguments */</a>
<a name="ln1549">              for (j = 0; keyword_args[j] != (void*)-1; j++)</a>
<a name="ln1550">                if (push_argument(argc, argv, keyword_args[j]))</a>
<a name="ln1551">                  rv = MATCHER_EXCEED_ARGC_MAX;</a>
<a name="ln1552">              XFREE(MTYPE_TMP, keyword_args);</a>
<a name="ln1553">            }</a>
<a name="ln1554">          else</a>
<a name="ln1555">            {</a>
<a name="ln1556">              /* the keyword was not present, insert NULL for the arguments</a>
<a name="ln1557">               * the keyword would have taken. */</a>
<a name="ln1558">              for (j = 1; j &lt; vector_active(keyword_vector); j++)</a>
<a name="ln1559">                {</a>
<a name="ln1560">                  word_token = vector_slot(keyword_vector, j);</a>
<a name="ln1561">                  if ((word_token-&gt;type == TOKEN_TERMINAL</a>
<a name="ln1562">                       &amp;&amp; TERMINAL_RECORD (word_token-&gt;terminal))</a>
<a name="ln1563">                      || word_token-&gt;type == TOKEN_MULTIPLE)</a>
<a name="ln1564">                    {</a>
<a name="ln1565">                      if (push_argument(argc, argv, NULL))</a>
<a name="ln1566">                        rv = MATCHER_EXCEED_ARGC_MAX;</a>
<a name="ln1567">                    }</a>
<a name="ln1568">                }</a>
<a name="ln1569">            }</a>
<a name="ln1570">        }</a>
<a name="ln1571">    }</a>
<a name="ln1572">  vector_free(keyword_args_vector);</a>
<a name="ln1573">  return rv;</a>
<a name="ln1574">}</a>
<a name="ln1575"> </a>
<a name="ln1576">static enum matcher_rv</a>
<a name="ln1577">cmd_matcher_match_keyword(struct cmd_matcher *matcher,</a>
<a name="ln1578">                          struct cmd_token *token,</a>
<a name="ln1579">                          int *argc, const char **argv)</a>
<a name="ln1580">{</a>
<a name="ln1581">  vector keyword_args_vector;</a>
<a name="ln1582">  enum matcher_rv reader_rv;</a>
<a name="ln1583">  enum matcher_rv builder_rv;</a>
<a name="ln1584"> </a>
<a name="ln1585">  assert(token-&gt;type == TOKEN_KEYWORD);</a>
<a name="ln1586"> </a>
<a name="ln1587">  if (argc &amp;&amp; argv)</a>
<a name="ln1588">    keyword_args_vector = vector_init(VECTOR_MIN_SIZE);</a>
<a name="ln1589">  else</a>
<a name="ln1590">    keyword_args_vector = NULL;</a>
<a name="ln1591"> </a>
<a name="ln1592">  reader_rv = cmd_matcher_read_keywords(matcher, token, keyword_args_vector);</a>
<a name="ln1593">  builder_rv = cmd_matcher_build_keyword_args(matcher, token, argc,</a>
<a name="ln1594">                                              argv, keyword_args_vector);</a>
<a name="ln1595">  /* keyword_args_vector is consumed by cmd_matcher_build_keyword_args */</a>
<a name="ln1596"> </a>
<a name="ln1597">  if (!MATCHER_ERROR(reader_rv) &amp;&amp; MATCHER_ERROR(builder_rv))</a>
<a name="ln1598">    return builder_rv;</a>
<a name="ln1599"> </a>
<a name="ln1600">  return reader_rv;</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603">static void</a>
<a name="ln1604">cmd_matcher_init(struct cmd_matcher *matcher,</a>
<a name="ln1605">                 struct cmd_element *cmd,</a>
<a name="ln1606">                 enum filter_type filter,</a>
<a name="ln1607">                 vector vline,</a>
<a name="ln1608">                 unsigned int index,</a>
<a name="ln1609">                 enum match_type *match_type,</a>
<a name="ln1610">                 vector *match)</a>
<a name="ln1611">{</a>
<a name="ln1612">  memset(matcher, 0, sizeof(*matcher));</a>
<a name="ln1613"> </a>
<a name="ln1614">  matcher-&gt;cmd = cmd;</a>
<a name="ln1615">  matcher-&gt;filter = filter;</a>
<a name="ln1616">  matcher-&gt;vline = vline;</a>
<a name="ln1617">  matcher-&gt;index = index;</a>
<a name="ln1618"> </a>
<a name="ln1619">  matcher-&gt;match_type = match_type;</a>
<a name="ln1620">  if (matcher-&gt;match_type)</a>
<a name="ln1621">    *matcher-&gt;match_type = no_match;</a>
<a name="ln1622">  matcher-&gt;match = match;</a>
<a name="ln1623"> </a>
<a name="ln1624">  matcher-&gt;word_index = 0;</a>
<a name="ln1625">}</a>
<a name="ln1626"> </a>
<a name="ln1627">static enum matcher_rv</a>
<a name="ln1628">cmd_element_match(struct cmd_element *cmd_element,</a>
<a name="ln1629">                  enum filter_type filter,</a>
<a name="ln1630">                  vector vline,</a>
<a name="ln1631">                  unsigned int index,</a>
<a name="ln1632">                  enum match_type *match_type,</a>
<a name="ln1633">                  vector *match,</a>
<a name="ln1634">                  int *argc,</a>
<a name="ln1635">                  const char **argv)</a>
<a name="ln1636">{</a>
<a name="ln1637">  struct cmd_matcher matcher;</a>
<a name="ln1638">  unsigned int token_index;</a>
<a name="ln1639">  enum matcher_rv rv = MATCHER_NO_MATCH;</a>
<a name="ln1640"> </a>
<a name="ln1641">  cmd_matcher_init(&amp;matcher, cmd_element, filter,</a>
<a name="ln1642">                   vline, index, match_type, match);</a>
<a name="ln1643"> </a>
<a name="ln1644">  if (argc != NULL)</a>
<a name="ln1645">    *argc = 0;</a>
<a name="ln1646"> </a>
<a name="ln1647">  for (token_index = 0;</a>
<a name="ln1648">       token_index &lt; vector_active(cmd_element-&gt;tokens);</a>
<a name="ln1649">       token_index++)</a>
<a name="ln1650">    {</a>
<a name="ln1651">      struct cmd_token *token = vector_slot(cmd_element-&gt;tokens, token_index);</a>
<a name="ln1652"> </a>
<a name="ln1653">      switch (token-&gt;type)</a>
<a name="ln1654">        {</a>
<a name="ln1655">        case TOKEN_TERMINAL:</a>
<a name="ln1656">          rv = cmd_matcher_match_terminal(&amp;matcher, token, argc, argv);</a>
<a name="ln1657">          break;</a>
<a name="ln1658">        case TOKEN_MULTIPLE:</a>
<a name="ln1659">          rv = cmd_matcher_match_multiple(&amp;matcher, token, argc, argv);</a>
<a name="ln1660">          break;</a>
<a name="ln1661">        case TOKEN_KEYWORD:</a>
<a name="ln1662">          rv = cmd_matcher_match_keyword(&amp;matcher, token, argc, argv);</a>
<a name="ln1663">        }</a>
<a name="ln1664"> </a>
<a name="ln1665">      if (MATCHER_ERROR(rv))</a>
<a name="ln1666">        return rv;</a>
<a name="ln1667"> </a>
<a name="ln1668">      if (matcher.word_index &gt; index)</a>
<a name="ln1669">        return MATCHER_OK;</a>
<a name="ln1670">    }</a>
<a name="ln1671"> </a>
<a name="ln1672">  /* return MATCHER_COMPLETE if all words were consumed */</a>
<a name="ln1673">  if (matcher.word_index &gt;= vector_active(vline))</a>
<a name="ln1674">    return MATCHER_COMPLETE;</a>
<a name="ln1675"> </a>
<a name="ln1676">  /* return MATCHER_COMPLETE also if only an empty word is left. */</a>
<a name="ln1677">  if (matcher.word_index == vector_active(vline) - 1</a>
<a name="ln1678">      &amp;&amp; (!vector_slot(vline, matcher.word_index)</a>
<a name="ln1679">          || !strlen((char*)vector_slot(vline, matcher.word_index))))</a>
<a name="ln1680">    return MATCHER_COMPLETE;</a>
<a name="ln1681"> </a>
<a name="ln1682">  return MATCHER_NO_MATCH; /* command is too long to match */</a>
<a name="ln1683">}</a>
<a name="ln1684"> </a>
<a name="ln1685">/**</a>
<a name="ln1686"> * Filter a given vector of commands against a given commandline and</a>
<a name="ln1687"> * calculate possible completions.</a>
<a name="ln1688"> *</a>
<a name="ln1689"> * @param commands A vector of struct cmd_element*. Commands that don't</a>
<a name="ln1690"> *                 match against the given command line will be overwritten</a>
<a name="ln1691"> *                 with NULL in that vector.</a>
<a name="ln1692"> * @param filter Either FILTER_RELAXED or FILTER_STRICT. This basically</a>
<a name="ln1693"> *               determines how incomplete commands are handled, compare with</a>
<a name="ln1694"> *               cmd_word_match for details.</a>
<a name="ln1695"> * @param vline A vector of char* containing the tokenized commandline.</a>
<a name="ln1696"> * @param index Only match up to the given token of the commandline.</a>
<a name="ln1697"> * @param match_type Record the type of the best match here.</a>
<a name="ln1698"> * @param matches Record the matches here. For each cmd_element in the commands</a>
<a name="ln1699"> *                vector, a match vector will be created in the matches vector.</a>
<a name="ln1700"> *                That vector will contain all struct command_token* of the</a>
<a name="ln1701"> *                cmd_element which matched against the given vline at the given</a>
<a name="ln1702"> *                index.</a>
<a name="ln1703"> * @return A code specifying if an error occurred. If all went right, it's</a>
<a name="ln1704"> *         CMD_SUCCESS.</a>
<a name="ln1705"> */</a>
<a name="ln1706">static int</a>
<a name="ln1707">cmd_vector_filter(vector commands,</a>
<a name="ln1708">                  enum filter_type filter,</a>
<a name="ln1709">                  vector vline,</a>
<a name="ln1710">                  unsigned int index,</a>
<a name="ln1711">                  enum match_type *match_type,</a>
<a name="ln1712">                  vector *matches)</a>
<a name="ln1713">{</a>
<a name="ln1714">  unsigned int i;</a>
<a name="ln1715">  struct cmd_element *cmd_element;</a>
<a name="ln1716">  enum match_type best_match;</a>
<a name="ln1717">  enum match_type element_match;</a>
<a name="ln1718">  enum matcher_rv matcher_rv;</a>
<a name="ln1719"> </a>
<a name="ln1720">  best_match = no_match;</a>
<a name="ln1721">  *matches = vector_init(VECTOR_MIN_SIZE);</a>
<a name="ln1722"> </a>
<a name="ln1723">  for (i = 0; i &lt; vector_active (commands); i++)</a>
<a name="ln1724">    if ((cmd_element = vector_slot (commands, i)) != NULL)</a>
<a name="ln1725">      {</a>
<a name="ln1726">        vector_set_index(*matches, i, NULL);</a>
<a name="ln1727">        matcher_rv = cmd_element_match(cmd_element, filter,</a>
<a name="ln1728">                                       vline, index,</a>
<a name="ln1729">                                       &amp;element_match,</a>
<a name="ln1730">                                       (vector*)&amp;vector_slot(*matches, i),</a>
<a name="ln1731">                                       NULL, NULL);</a>
<a name="ln1732">        if (MATCHER_ERROR(matcher_rv))</a>
<a name="ln1733">          {</a>
<a name="ln1734">            vector_slot(commands, i) = NULL;</a>
<a name="ln1735">            if (matcher_rv == MATCHER_AMBIGUOUS)</a>
<a name="ln1736">              return CMD_ERR_AMBIGUOUS;</a>
<a name="ln1737">            if (matcher_rv == MATCHER_EXCEED_ARGC_MAX)</a>
<a name="ln1738">              return CMD_ERR_EXEED_ARGC_MAX;</a>
<a name="ln1739">          }</a>
<a name="ln1740">        else if (element_match &gt; best_match)</a>
<a name="ln1741">          {</a>
<a name="ln1742">            best_match = element_match;</a>
<a name="ln1743">          }</a>
<a name="ln1744">      }</a>
<a name="ln1745">  *match_type = best_match;</a>
<a name="ln1746">  return CMD_SUCCESS;</a>
<a name="ln1747">}</a>
<a name="ln1748"> </a>
<a name="ln1749">/**</a>
<a name="ln1750"> * Check whether a given commandline is complete if used for a specific</a>
<a name="ln1751"> * cmd_element.</a>
<a name="ln1752"> *</a>
<a name="ln1753"> * @param cmd_element A cmd_element against which the commandline should be</a>
<a name="ln1754"> *                    checked.</a>
<a name="ln1755"> * @param vline The tokenized commandline.</a>
<a name="ln1756"> * @return 1 if the given commandline is complete, 0 otherwise.</a>
<a name="ln1757"> */</a>
<a name="ln1758">static int</a>
<a name="ln1759">cmd_is_complete(struct cmd_element *cmd_element,</a>
<a name="ln1760">                vector vline)</a>
<a name="ln1761">{</a>
<a name="ln1762">  enum matcher_rv rv;</a>
<a name="ln1763"> </a>
<a name="ln1764">  rv = cmd_element_match(cmd_element,</a>
<a name="ln1765">                         FILTER_RELAXED,</a>
<a name="ln1766">                         vline, -1,</a>
<a name="ln1767">                         NULL, NULL,</a>
<a name="ln1768">                         NULL, NULL);</a>
<a name="ln1769">  return (rv == MATCHER_COMPLETE);</a>
<a name="ln1770">}</a>
<a name="ln1771"> </a>
<a name="ln1772">/**</a>
<a name="ln1773"> * Parse a given commandline and construct a list of arguments for the</a>
<a name="ln1774"> * given command_element.</a>
<a name="ln1775"> *</a>
<a name="ln1776"> * @param cmd_element The cmd_element for which we want to construct arguments.</a>
<a name="ln1777"> * @param vline The tokenized commandline.</a>
<a name="ln1778"> * @param argc Where to store the argument count.</a>
<a name="ln1779"> * @param argv Where to store the argument list. Should be at least</a>
<a name="ln1780"> *             CMD_ARGC_MAX elements long.</a>
<a name="ln1781"> * @return CMD_SUCCESS if everything went alright, an error otherwise.</a>
<a name="ln1782"> */</a>
<a name="ln1783">static int</a>
<a name="ln1784">cmd_parse(struct cmd_element *cmd_element,</a>
<a name="ln1785">          vector vline,</a>
<a name="ln1786">          int *argc, const char **argv)</a>
<a name="ln1787">{</a>
<a name="ln1788">  enum matcher_rv rv = cmd_element_match(cmd_element,</a>
<a name="ln1789">                                         FILTER_RELAXED,</a>
<a name="ln1790">                                         vline, -1,</a>
<a name="ln1791">                                         NULL, NULL,</a>
<a name="ln1792">                                         argc, argv);</a>
<a name="ln1793">  switch (rv)</a>
<a name="ln1794">    {</a>
<a name="ln1795">    case MATCHER_COMPLETE:</a>
<a name="ln1796">      return CMD_SUCCESS;</a>
<a name="ln1797"> </a>
<a name="ln1798">    case MATCHER_NO_MATCH:</a>
<a name="ln1799">      return CMD_ERR_NO_MATCH;</a>
<a name="ln1800"> </a>
<a name="ln1801">    case MATCHER_AMBIGUOUS:</a>
<a name="ln1802">      return CMD_ERR_AMBIGUOUS;</a>
<a name="ln1803"> </a>
<a name="ln1804">    case MATCHER_EXCEED_ARGC_MAX:</a>
<a name="ln1805">      return CMD_ERR_EXEED_ARGC_MAX;</a>
<a name="ln1806"> </a>
<a name="ln1807">    default:</a>
<a name="ln1808">      return CMD_ERR_INCOMPLETE;</a>
<a name="ln1809">    }</a>
<a name="ln1810">}</a>
<a name="ln1811"> </a>
<a name="ln1812">/* Check ambiguous match */</a>
<a name="ln1813">static int</a>
<a name="ln1814">is_cmd_ambiguous (vector cmd_vector,</a>
<a name="ln1815">                  const char *command,</a>
<a name="ln1816">                  vector matches,</a>
<a name="ln1817">                  enum match_type type)</a>
<a name="ln1818">{</a>
<a name="ln1819">  unsigned int i;</a>
<a name="ln1820">  unsigned int j;</a>
<a name="ln1821">  const char *str = NULL;</a>
<a name="ln1822">  const char *matched = NULL;</a>
<a name="ln1823">  vector match_vector;</a>
<a name="ln1824">  struct cmd_token *cmd_token;</a>
<a name="ln1825"> </a>
<a name="ln1826">  if (command == NULL)</a>
<a name="ln1827">    command = &quot;&quot;;</a>
<a name="ln1828"> </a>
<a name="ln1829">  for (i = 0; i &lt; vector_active (matches); i++)</a>
<a name="ln1830">    if ((match_vector = vector_slot (matches, i)) != NULL)</a>
<a name="ln1831">      {</a>
<a name="ln1832">	int match = 0;</a>
<a name="ln1833"> </a>
<a name="ln1834">	for (j = 0; j &lt; vector_active (match_vector); j++)</a>
<a name="ln1835">	  if ((cmd_token = vector_slot (match_vector, j)) != NULL)</a>
<a name="ln1836">	    {</a>
<a name="ln1837">	      enum match_type ret;</a>
<a name="ln1838"> </a>
<a name="ln1839">	      assert(cmd_token-&gt;type == TOKEN_TERMINAL);</a>
<a name="ln1840">	      if (cmd_token-&gt;type != TOKEN_TERMINAL)</a>
<a name="ln1841">		continue;</a>
<a name="ln1842"> </a>
<a name="ln1843">	      str = cmd_token-&gt;cmd;</a>
<a name="ln1844"> </a>
<a name="ln1845">	      switch (type)</a>
<a name="ln1846">		{</a>
<a name="ln1847">		case exact_match:</a>
<a name="ln1848">		  if (!TERMINAL_RECORD (cmd_token-&gt;terminal)</a>
<a name="ln1849">		      &amp;&amp; strcmp (command, str) == 0)</a>
<a name="ln1850">		    match++;</a>
<a name="ln1851">		  break;</a>
<a name="ln1852">		case partly_match:</a>
<a name="ln1853">		  if (!TERMINAL_RECORD (cmd_token-&gt;terminal)</a>
<a name="ln1854">		      &amp;&amp; strncmp (command, str, strlen (command)) == 0)</a>
<a name="ln1855">		    {</a>
<a name="ln1856">		      if (matched &amp;&amp; strcmp (matched, str) != 0)</a>
<a name="ln1857">			return 1;	/* There is ambiguous match. */</a>
<a name="ln1858">		      else</a>
<a name="ln1859">			matched = str;</a>
<a name="ln1860">		      match++;</a>
<a name="ln1861">		    }</a>
<a name="ln1862">		  break;</a>
<a name="ln1863">		case range_match:</a>
<a name="ln1864">		  if (cmd_range_match (str, command))</a>
<a name="ln1865">		    {</a>
<a name="ln1866">		      if (matched &amp;&amp; strcmp (matched, str) != 0)</a>
<a name="ln1867">			return 1;</a>
<a name="ln1868">		      else</a>
<a name="ln1869">			matched = str;</a>
<a name="ln1870">		      match++;</a>
<a name="ln1871">		    }</a>
<a name="ln1872">		  break;</a>
<a name="ln1873">#ifdef HAVE_IPV6</a>
<a name="ln1874">		case ipv6_match:</a>
<a name="ln1875">		  if (cmd_token-&gt;terminal == TERMINAL_IPV6)</a>
<a name="ln1876">		    match++;</a>
<a name="ln1877">		  break;</a>
<a name="ln1878">		case ipv6_prefix_match:</a>
<a name="ln1879">		  if ((ret = cmd_ipv6_prefix_match (command)) != no_match)</a>
<a name="ln1880">		    {</a>
<a name="ln1881">		      if (ret == partly_match)</a>
<a name="ln1882">			return 2;	/* There is incomplete match. */</a>
<a name="ln1883"> </a>
<a name="ln1884">		      match++;</a>
<a name="ln1885">		    }</a>
<a name="ln1886">		  break;</a>
<a name="ln1887">#endif /* HAVE_IPV6 */</a>
<a name="ln1888">		case ipv4_match:</a>
<a name="ln1889">		  if (cmd_token-&gt;terminal == TERMINAL_IPV4)</a>
<a name="ln1890">		    match++;</a>
<a name="ln1891">		  break;</a>
<a name="ln1892">		case ipv4_prefix_match:</a>
<a name="ln1893">		  if ((ret = cmd_ipv4_prefix_match (command)) != no_match)</a>
<a name="ln1894">		    {</a>
<a name="ln1895">		      if (ret == partly_match)</a>
<a name="ln1896">			return 2;	/* There is incomplete match. */</a>
<a name="ln1897"> </a>
<a name="ln1898">		      match++;</a>
<a name="ln1899">		    }</a>
<a name="ln1900">		  break;</a>
<a name="ln1901">		case extend_match:</a>
<a name="ln1902">		  if (TERMINAL_RECORD (cmd_token-&gt;terminal))</a>
<a name="ln1903">		    match++;</a>
<a name="ln1904">		  break;</a>
<a name="ln1905">		case no_match:</a>
<a name="ln1906">		default:</a>
<a name="ln1907">		  break;</a>
<a name="ln1908">		}</a>
<a name="ln1909">	    }</a>
<a name="ln1910">	if (!match)</a>
<a name="ln1911">	  vector_slot (cmd_vector, i) = NULL;</a>
<a name="ln1912">      }</a>
<a name="ln1913">  return 0;</a>
<a name="ln1914">}</a>
<a name="ln1915"> </a>
<a name="ln1916">/* If src matches dst return dst string, otherwise return NULL */</a>
<a name="ln1917">static const char *</a>
<a name="ln1918">cmd_entry_function (const char *src, struct cmd_token *token)</a>
<a name="ln1919">{</a>
<a name="ln1920">  const char *dst = token-&gt;cmd;</a>
<a name="ln1921"> </a>
<a name="ln1922">  /* Skip variable arguments. */</a>
<a name="ln1923">  if (TERMINAL_RECORD (token-&gt;terminal))</a>
<a name="ln1924">    return NULL;</a>
<a name="ln1925"> </a>
<a name="ln1926">  /* In case of 'command \t', given src is NULL string. */</a>
<a name="ln1927">  if (src == NULL)</a>
<a name="ln1928">    return dst;</a>
<a name="ln1929"> </a>
<a name="ln1930">  /* Matched with input string. */</a>
<a name="ln1931">  if (strncmp (src, dst, strlen (src)) == 0)</a>
<a name="ln1932">    return dst;</a>
<a name="ln1933"> </a>
<a name="ln1934">  return NULL;</a>
<a name="ln1935">}</a>
<a name="ln1936"> </a>
<a name="ln1937">/* If src matches dst return dst string, otherwise return NULL */</a>
<a name="ln1938">/* This version will return the dst string always if it is</a>
<a name="ln1939">   CMD_VARIABLE for '?' key processing */</a>
<a name="ln1940">static const char *</a>
<a name="ln1941">cmd_entry_function_desc (const char *src, struct cmd_token *token)</a>
<a name="ln1942">{</a>
<a name="ln1943">  const char *dst = token-&gt;cmd;</a>
<a name="ln1944"> </a>
<a name="ln1945">  switch (token-&gt;terminal)</a>
<a name="ln1946">    {</a>
<a name="ln1947">      case TERMINAL_VARARG:</a>
<a name="ln1948">        return dst;</a>
<a name="ln1949"> </a>
<a name="ln1950">      case TERMINAL_RANGE:</a>
<a name="ln1951">        if (cmd_range_match (dst, src))</a>
<a name="ln1952">          return dst;</a>
<a name="ln1953">        else</a>
<a name="ln1954">          return NULL;</a>
<a name="ln1955"> </a>
<a name="ln1956">      case TERMINAL_IPV6:</a>
<a name="ln1957">        if (cmd_ipv6_match (src))</a>
<a name="ln1958">          return dst;</a>
<a name="ln1959">        else</a>
<a name="ln1960">          return NULL;</a>
<a name="ln1961"> </a>
<a name="ln1962">      case TERMINAL_IPV6_PREFIX:</a>
<a name="ln1963">        if (cmd_ipv6_prefix_match (src))</a>
<a name="ln1964">          return dst;</a>
<a name="ln1965">        else</a>
<a name="ln1966">          return NULL;</a>
<a name="ln1967"> </a>
<a name="ln1968">      case TERMINAL_IPV4:</a>
<a name="ln1969">        if (cmd_ipv4_match (src))</a>
<a name="ln1970">          return dst;</a>
<a name="ln1971">        else</a>
<a name="ln1972">          return NULL;</a>
<a name="ln1973"> </a>
<a name="ln1974">      case TERMINAL_IPV4_PREFIX:</a>
<a name="ln1975">        if (cmd_ipv4_prefix_match (src))</a>
<a name="ln1976">          return dst;</a>
<a name="ln1977">        else</a>
<a name="ln1978">          return NULL;</a>
<a name="ln1979"> </a>
<a name="ln1980">      /* Optional or variable commands always match on '?' */</a>
<a name="ln1981">      case TERMINAL_OPTION:</a>
<a name="ln1982">      case TERMINAL_VARIABLE:</a>
<a name="ln1983">        return dst;</a>
<a name="ln1984"> </a>
<a name="ln1985">      case TERMINAL_LITERAL:</a>
<a name="ln1986">        /* In case of 'command \t', given src is NULL string. */</a>
<a name="ln1987">        if (src == NULL)</a>
<a name="ln1988">          return dst;</a>
<a name="ln1989"> </a>
<a name="ln1990">        if (strncmp (src, dst, strlen (src)) == 0)</a>
<a name="ln1991">          return dst;</a>
<a name="ln1992">        else</a>
<a name="ln1993">          return NULL;</a>
<a name="ln1994"> </a>
<a name="ln1995">      default:</a>
<a name="ln1996">        assert(0);</a>
<a name="ln1997">        return NULL;</a>
<a name="ln1998">    }</a>
<a name="ln1999">}</a>
<a name="ln2000"> </a>
<a name="ln2001">/**</a>
<a name="ln2002"> * Check whether a string is already present in a vector of strings.</a>
<a name="ln2003"> * @param v A vector of char*.</a>
<a name="ln2004"> * @param str A char*.</a>
<a name="ln2005"> * @return 0 if str is already present in the vector, 1 otherwise.</a>
<a name="ln2006"> */</a>
<a name="ln2007">static int</a>
<a name="ln2008">cmd_unique_string (vector v, const char *str)</a>
<a name="ln2009">{</a>
<a name="ln2010">  unsigned int i;</a>
<a name="ln2011">  char *match;</a>
<a name="ln2012"> </a>
<a name="ln2013">  for (i = 0; i &lt; vector_active (v); i++)</a>
<a name="ln2014">    if ((match = vector_slot (v, i)) != NULL)</a>
<a name="ln2015">      if (strcmp (match, str) == 0)</a>
<a name="ln2016">	return 0;</a>
<a name="ln2017">  return 1;</a>
<a name="ln2018">}</a>
<a name="ln2019"> </a>
<a name="ln2020">/**</a>
<a name="ln2021"> * Check whether a struct cmd_token matching a given string is already</a>
<a name="ln2022"> * present in a vector of struct cmd_token.</a>
<a name="ln2023"> * @param v A vector of struct cmd_token*.</a>
<a name="ln2024"> * @param str A char* which should be searched for.</a>
<a name="ln2025"> * @return 0 if there is a struct cmd_token* with its cmd matching str,</a>
<a name="ln2026"> *         1 otherwise.</a>
<a name="ln2027"> */</a>
<a name="ln2028">static int</a>
<a name="ln2029">desc_unique_string (vector v, const char *str)</a>
<a name="ln2030">{</a>
<a name="ln2031">  unsigned int i;</a>
<a name="ln2032">  struct cmd_token *token;</a>
<a name="ln2033"> </a>
<a name="ln2034">  for (i = 0; i &lt; vector_active (v); i++)</a>
<a name="ln2035">    if ((token = vector_slot (v, i)) != NULL)</a>
<a name="ln2036">      if (strcmp (token-&gt;cmd, str) == 0)</a>
<a name="ln2037">	return 0;</a>
<a name="ln2038">  return 1;</a>
<a name="ln2039">}</a>
<a name="ln2040"> </a>
<a name="ln2041">static int </a>
<a name="ln2042">cmd_try_do_shortcut (enum node_type node, char* first_word) {</a>
<a name="ln2043">  if ( first_word != NULL &amp;&amp;</a>
<a name="ln2044">       node != AUTH_NODE &amp;&amp;</a>
<a name="ln2045">       node != VIEW_NODE &amp;&amp;</a>
<a name="ln2046">       node != AUTH_ENABLE_NODE &amp;&amp;</a>
<a name="ln2047">       node != ENABLE_NODE &amp;&amp;</a>
<a name="ln2048">       node != RESTRICTED_NODE &amp;&amp;</a>
<a name="ln2049">       0 == strcmp( &quot;do&quot;, first_word ) )</a>
<a name="ln2050">    return 1;</a>
<a name="ln2051">  return 0;</a>
<a name="ln2052">}</a>
<a name="ln2053"> </a>
<a name="ln2054">static void</a>
<a name="ln2055">cmd_matches_free(vector *matches)</a>
<a name="ln2056">{</a>
<a name="ln2057">  unsigned int i;</a>
<a name="ln2058">  vector cmd_matches;</a>
<a name="ln2059"> </a>
<a name="ln2060">  for (i = 0; i &lt; vector_active(*matches); i++)</a>
<a name="ln2061">    if ((cmd_matches = vector_slot(*matches, i)) != NULL)</a>
<a name="ln2062">      vector_free(cmd_matches);</a>
<a name="ln2063">  vector_free(*matches);</a>
<a name="ln2064">  *matches = NULL;</a>
<a name="ln2065">}</a>
<a name="ln2066"> </a>
<a name="ln2067">static int</a>
<a name="ln2068">cmd_describe_cmp(const void *a, const void *b)</a>
<a name="ln2069">{</a>
<a name="ln2070">  const struct cmd_token *first = *(struct cmd_token * const *)a;</a>
<a name="ln2071">  const struct cmd_token *second = *(struct cmd_token * const *)b;</a>
<a name="ln2072"> </a>
<a name="ln2073">  return strcmp(first-&gt;cmd, second-&gt;cmd);</a>
<a name="ln2074">}</a>
<a name="ln2075"> </a>
<a name="ln2076">static void</a>
<a name="ln2077">cmd_describe_sort(vector matchvec)</a>
<a name="ln2078">{</a>
<a name="ln2079">  qsort(matchvec-&gt;index, vector_active(matchvec),</a>
<a name="ln2080">        sizeof(void*), cmd_describe_cmp);</a>
<a name="ln2081">}</a>
<a name="ln2082"> </a>
<a name="ln2083">/* '?' describe command support. */</a>
<a name="ln2084">static vector</a>
<a name="ln2085">cmd_describe_command_real (vector vline, struct vty *vty, int *status)</a>
<a name="ln2086">{</a>
<a name="ln2087">  unsigned int i;</a>
<a name="ln2088">  vector cmd_vector;</a>
<a name="ln2089">#define INIT_MATCHVEC_SIZE 10</a>
<a name="ln2090">  vector matchvec;</a>
<a name="ln2091">  struct cmd_element *cmd_element;</a>
<a name="ln2092">  unsigned int index;</a>
<a name="ln2093">  int ret;</a>
<a name="ln2094">  enum match_type match;</a>
<a name="ln2095">  char *command;</a>
<a name="ln2096">  vector matches = NULL;</a>
<a name="ln2097">  vector match_vector;</a>
<a name="ln2098">  uint32_t command_found = 0;</a>
<a name="ln2099">  const char *last_word;</a>
<a name="ln2100"> </a>
<a name="ln2101">  /* Set index. */</a>
<a name="ln2102">  if (vector_active (vline) == 0)</a>
<a name="ln2103">    {</a>
<a name="ln2104">      *status = CMD_ERR_NO_MATCH;</a>
<a name="ln2105">      return NULL;</a>
<a name="ln2106">    }</a>
<a name="ln2107"> </a>
<a name="ln2108">  index = vector_active (vline) - 1;</a>
<a name="ln2109"> </a>
<a name="ln2110">  /* Make copy vector of current node's command vector. */</a>
<a name="ln2111">  cmd_vector = vector_copy (cmd_node_vector (cmdvec, vty-&gt;node));</a>
<a name="ln2112"> </a>
<a name="ln2113">  /* Prepare match vector */</a>
<a name="ln2114">  matchvec = vector_init (INIT_MATCHVEC_SIZE);</a>
<a name="ln2115"> </a>
<a name="ln2116">  /* Filter commands and build a list how they could possibly continue. */</a>
<a name="ln2117">  for (i = 0; i &lt;= index; i++)</a>
<a name="ln2118">    {</a>
<a name="ln2119">      command = vector_slot (vline, i);</a>
<a name="ln2120"> </a>
<a name="ln2121">      if (matches)</a>
<a name="ln2122">	cmd_matches_free(&amp;matches);</a>
<a name="ln2123"> </a>
<a name="ln2124">      ret = cmd_vector_filter(cmd_vector,</a>
<a name="ln2125">	                      FILTER_RELAXED,</a>
<a name="ln2126">	                      vline, i,</a>
<a name="ln2127">	                      &amp;match,</a>
<a name="ln2128">	                      &amp;matches);</a>
<a name="ln2129"> </a>
<a name="ln2130">      if (ret != CMD_SUCCESS)</a>
<a name="ln2131">	{</a>
<a name="ln2132">	  vector_free (cmd_vector);</a>
<a name="ln2133">	  vector_free (matchvec);</a>
<a name="ln2134">	  cmd_matches_free(&amp;matches);</a>
<a name="ln2135">	  *status = ret;</a>
<a name="ln2136">	  return NULL;</a>
<a name="ln2137">	}</a>
<a name="ln2138"> </a>
<a name="ln2139">      /* The last match may well be ambigious, so break here */</a>
<a name="ln2140">      if (i == index)</a>
<a name="ln2141">	break;</a>
<a name="ln2142"> </a>
<a name="ln2143">      if (match == vararg_match)</a>
<a name="ln2144">	{</a>
<a name="ln2145">	  /* We found a vararg match - so we can throw out the current matches here</a>
<a name="ln2146">	   * and don't need to continue checking the command input */</a>
<a name="ln2147">	  unsigned int j, k;</a>
<a name="ln2148"> </a>
<a name="ln2149">	  for (j = 0; j &lt; vector_active (matches); j++)</a>
<a name="ln2150">	    if ((match_vector = vector_slot (matches, j)) != NULL)</a>
<a name="ln2151">	      for (k = 0; k &lt; vector_active (match_vector); k++)</a>
<a name="ln2152">	        {</a>
<a name="ln2153">	          struct cmd_token *token = vector_slot (match_vector, k);</a>
<a name="ln2154">	          vector_set (matchvec, token);</a>
<a name="ln2155">	        }</a>
<a name="ln2156"> </a>
<a name="ln2157">	  *status = CMD_SUCCESS;</a>
<a name="ln2158">	  vector_set(matchvec, &amp;token_cr);</a>
<a name="ln2159">	  vector_free (cmd_vector);</a>
<a name="ln2160">	  cmd_matches_free(&amp;matches);</a>
<a name="ln2161">	  cmd_describe_sort(matchvec);</a>
<a name="ln2162">	  return matchvec;</a>
<a name="ln2163">	}</a>
<a name="ln2164"> </a>
<a name="ln2165">      ret = is_cmd_ambiguous(cmd_vector, command, matches, match);</a>
<a name="ln2166">      if (ret == 1)</a>
<a name="ln2167">	{</a>
<a name="ln2168">	  vector_free (cmd_vector);</a>
<a name="ln2169">	  vector_free (matchvec);</a>
<a name="ln2170">	  cmd_matches_free(&amp;matches);</a>
<a name="ln2171">	  *status = CMD_ERR_AMBIGUOUS;</a>
<a name="ln2172">	  return NULL;</a>
<a name="ln2173">	}</a>
<a name="ln2174">      else if (ret == 2)</a>
<a name="ln2175">	{</a>
<a name="ln2176">	  vector_free (cmd_vector);</a>
<a name="ln2177">	  vector_free (matchvec);</a>
<a name="ln2178">	  cmd_matches_free(&amp;matches);</a>
<a name="ln2179">	  *status = CMD_ERR_NO_MATCH;</a>
<a name="ln2180">	  return NULL;</a>
<a name="ln2181">	}</a>
<a name="ln2182">    }</a>
<a name="ln2183"> </a>
<a name="ln2184">  /* Make description vector. */</a>
<a name="ln2185">  for (i = 0; i &lt; vector_active (matches); i++)</a>
<a name="ln2186">    {</a>
<a name="ln2187">      if ((cmd_element = vector_slot (cmd_vector, i)) != NULL)</a>
<a name="ln2188">	{</a>
<a name="ln2189">	  unsigned int j;</a>
<a name="ln2190">	  vector vline_trimmed;</a>
<a name="ln2191"> </a>
<a name="ln2192">	  command_found++;</a>
<a name="ln2193">	  last_word = vector_slot(vline, vector_active(vline) - 1);</a>
<a name="ln2194">	  if (last_word == NULL || !strlen(last_word))</a>
<a name="ln2195">	    {</a>
<a name="ln2196">	      vline_trimmed = vector_copy(vline);</a>
<a name="ln2197">	      vector_unset(vline_trimmed, vector_active(vline_trimmed) - 1);</a>
<a name="ln2198"> </a>
<a name="ln2199">	      if (cmd_is_complete(cmd_element, vline_trimmed)</a>
<a name="ln2200">		  &amp;&amp; desc_unique_string(matchvec, command_cr))</a>
<a name="ln2201">		{</a>
<a name="ln2202">		  if (match != vararg_match)</a>
<a name="ln2203">		    vector_set(matchvec, &amp;token_cr);</a>
<a name="ln2204">		}</a>
<a name="ln2205"> </a>
<a name="ln2206">	      vector_free(vline_trimmed);</a>
<a name="ln2207">	    }</a>
<a name="ln2208"> </a>
<a name="ln2209">	  match_vector = vector_slot (matches, i);</a>
<a name="ln2210">	  if (match_vector)</a>
<a name="ln2211">	    {</a>
<a name="ln2212">	      for (j = 0; j &lt; vector_active(match_vector); j++)</a>
<a name="ln2213">		{</a>
<a name="ln2214">		  struct cmd_token *token = vector_slot(match_vector, j);</a>
<a name="ln2215">		  const char *string;</a>
<a name="ln2216"> </a>
<a name="ln2217">		  string = cmd_entry_function_desc(command, token);</a>
<a name="ln2218">		  if (string &amp;&amp; desc_unique_string(matchvec, string))</a>
<a name="ln2219">		    vector_set(matchvec, token);</a>
<a name="ln2220">		}</a>
<a name="ln2221">	    }</a>
<a name="ln2222">	}</a>
<a name="ln2223">    }</a>
<a name="ln2224"> </a>
<a name="ln2225">  /*</a>
<a name="ln2226">   * We can get into this situation when the command is complete</a>
<a name="ln2227">   * but the last part of the command is an optional piece of</a>
<a name="ln2228">   * the cli.</a>
<a name="ln2229">   */</a>
<a name="ln2230">  last_word = vector_slot(vline, vector_active(vline) - 1);</a>
<a name="ln2231">  if (command_found == 0 &amp;&amp; (last_word == NULL || !strlen(last_word)))</a>
<a name="ln2232">    vector_set(matchvec, &amp;token_cr);</a>
<a name="ln2233"> </a>
<a name="ln2234">  vector_free (cmd_vector);</a>
<a name="ln2235">  cmd_matches_free(&amp;matches);</a>
<a name="ln2236"> </a>
<a name="ln2237">  if (vector_slot (matchvec, 0) == NULL)</a>
<a name="ln2238">    {</a>
<a name="ln2239">      vector_free (matchvec);</a>
<a name="ln2240">      *status = CMD_ERR_NO_MATCH;</a>
<a name="ln2241">      return NULL;</a>
<a name="ln2242">    }</a>
<a name="ln2243"> </a>
<a name="ln2244">  *status = CMD_SUCCESS;</a>
<a name="ln2245">  cmd_describe_sort(matchvec);</a>
<a name="ln2246">  return matchvec;</a>
<a name="ln2247">}</a>
<a name="ln2248"> </a>
<a name="ln2249">vector</a>
<a name="ln2250">cmd_describe_command (vector vline, struct vty *vty, int *status)</a>
<a name="ln2251">{</a>
<a name="ln2252">  vector ret;</a>
<a name="ln2253"> </a>
<a name="ln2254">  if ( cmd_try_do_shortcut(vty-&gt;node, vector_slot(vline, 0) ) )</a>
<a name="ln2255">    {</a>
<a name="ln2256">      enum node_type onode;</a>
<a name="ln2257">      vector shifted_vline;</a>
<a name="ln2258">      unsigned int index;</a>
<a name="ln2259"> </a>
<a name="ln2260">      onode = vty-&gt;node;</a>
<a name="ln2261">      vty-&gt;node = ENABLE_NODE;</a>
<a name="ln2262">      /* We can try it on enable node, cos' the vty is authenticated */</a>
<a name="ln2263"> </a>
<a name="ln2264">      shifted_vline = vector_init (vector_count(vline));</a>
<a name="ln2265">      /* use memcpy? */</a>
<a name="ln2266">      for (index = 1; index &lt; vector_active (vline); index++) </a>
<a name="ln2267">	{</a>
<a name="ln2268">	  vector_set_index (shifted_vline, index-1, vector_lookup(vline, index));</a>
<a name="ln2269">	}</a>
<a name="ln2270"> </a>
<a name="ln2271">      ret = cmd_describe_command_real (shifted_vline, vty, status);</a>
<a name="ln2272"> </a>
<a name="ln2273">      vector_free(shifted_vline);</a>
<a name="ln2274">      vty-&gt;node = onode;</a>
<a name="ln2275">      return ret;</a>
<a name="ln2276">  }</a>
<a name="ln2277"> </a>
<a name="ln2278"> </a>
<a name="ln2279">  return cmd_describe_command_real (vline, vty, status);</a>
<a name="ln2280">}</a>
<a name="ln2281"> </a>
<a name="ln2282"> </a>
<a name="ln2283">/* Check LCD of matched command. */</a>
<a name="ln2284">static int</a>
<a name="ln2285">cmd_lcd (char **matched)</a>
<a name="ln2286">{</a>
<a name="ln2287">  int i;</a>
<a name="ln2288">  int j;</a>
<a name="ln2289">  int lcd = -1;</a>
<a name="ln2290">  char *s1, *s2;</a>
<a name="ln2291">  char c1, c2;</a>
<a name="ln2292"> </a>
<a name="ln2293">  if (matched[0] == NULL || matched[1] == NULL)</a>
<a name="ln2294">    return 0;</a>
<a name="ln2295"> </a>
<a name="ln2296">  for (i = 1; matched[i] != NULL; i++)</a>
<a name="ln2297">    {</a>
<a name="ln2298">      s1 = matched[i - 1];</a>
<a name="ln2299">      s2 = matched[i];</a>
<a name="ln2300"> </a>
<a name="ln2301">      for (j = 0; (c1 = s1[j]) &amp;&amp; (c2 = s2[j]); j++)</a>
<a name="ln2302">	if (c1 != c2)</a>
<a name="ln2303">	  break;</a>
<a name="ln2304"> </a>
<a name="ln2305">      if (lcd &lt; 0)</a>
<a name="ln2306">	lcd = j;</a>
<a name="ln2307">      else</a>
<a name="ln2308">	{</a>
<a name="ln2309">	  if (lcd &gt; j)</a>
<a name="ln2310">	    lcd = j;</a>
<a name="ln2311">	}</a>
<a name="ln2312">    }</a>
<a name="ln2313">  return lcd;</a>
<a name="ln2314">}</a>
<a name="ln2315"> </a>
<a name="ln2316">static int</a>
<a name="ln2317">cmd_complete_cmp(const void *a, const void *b)</a>
<a name="ln2318">{</a>
<a name="ln2319">  const char *first = *(char * const *)a;</a>
<a name="ln2320">  const char *second = *(char * const *)b;</a>
<a name="ln2321"> </a>
<a name="ln2322">  if (!first)</a>
<a name="ln2323">    {</a>
<a name="ln2324">      if (!second)</a>
<a name="ln2325">        return 0;</a>
<a name="ln2326">      return 1;</a>
<a name="ln2327">    }</a>
<a name="ln2328">  if (!second)</a>
<a name="ln2329">    return -1;</a>
<a name="ln2330"> </a>
<a name="ln2331">  return strcmp(first, second);</a>
<a name="ln2332">}</a>
<a name="ln2333"> </a>
<a name="ln2334">static void</a>
<a name="ln2335">cmd_complete_sort(vector matchvec)</a>
<a name="ln2336">{</a>
<a name="ln2337">  qsort(matchvec-&gt;index, vector_active(matchvec),</a>
<a name="ln2338">        sizeof(void*), cmd_complete_cmp);</a>
<a name="ln2339">}</a>
<a name="ln2340"> </a>
<a name="ln2341">/* Command line completion support. */</a>
<a name="ln2342">static char **</a>
<a name="ln2343">cmd_complete_command_real (vector vline, struct vty *vty, int *status, int islib)</a>
<a name="ln2344">{</a>
<a name="ln2345">  unsigned int i;</a>
<a name="ln2346">  vector cmd_vector = vector_copy (cmd_node_vector (cmdvec, vty-&gt;node));</a>
<a name="ln2347">#define INIT_MATCHVEC_SIZE 10</a>
<a name="ln2348">  vector matchvec;</a>
<a name="ln2349">  unsigned int index;</a>
<a name="ln2350">  char **match_str;</a>
<a name="ln2351">  struct cmd_token *token;</a>
<a name="ln2352">  char *command;</a>
<a name="ln2353">  int lcd;</a>
<a name="ln2354">  vector matches = NULL;</a>
<a name="ln2355">  vector match_vector;</a>
<a name="ln2356"> </a>
<a name="ln2357">  if (vector_active (vline) == 0)</a>
<a name="ln2358">    {</a>
<a name="ln2359">      vector_free (cmd_vector);</a>
<a name="ln2360">      *status = CMD_ERR_NO_MATCH;</a>
<a name="ln2361">      return NULL;</a>
<a name="ln2362">    }</a>
<a name="ln2363">  else</a>
<a name="ln2364">    index = vector_active (vline) - 1;</a>
<a name="ln2365"> </a>
<a name="ln2366">  /* First, filter by command string */</a>
<a name="ln2367">  for (i = 0; i &lt;= index; i++)</a>
<a name="ln2368">    {</a>
<a name="ln2369">      command = vector_slot (vline, i);</a>
<a name="ln2370">      enum match_type match;</a>
<a name="ln2371">      int ret;</a>
<a name="ln2372"> </a>
<a name="ln2373">      if (matches)</a>
<a name="ln2374">        cmd_matches_free(&amp;matches);</a>
<a name="ln2375"> </a>
<a name="ln2376">      /* First try completion match, if there is exactly match return 1 */</a>
<a name="ln2377">      ret = cmd_vector_filter(cmd_vector,</a>
<a name="ln2378">	                      FILTER_RELAXED,</a>
<a name="ln2379">	                      vline, i,</a>
<a name="ln2380">	                      &amp;match,</a>
<a name="ln2381">	                      &amp;matches);</a>
<a name="ln2382"> </a>
<a name="ln2383">      if (ret != CMD_SUCCESS)</a>
<a name="ln2384">	{</a>
<a name="ln2385">	  vector_free(cmd_vector);</a>
<a name="ln2386">	  cmd_matches_free(&amp;matches);</a>
<a name="ln2387">	  *status = ret;</a>
<a name="ln2388">	  return NULL;</a>
<a name="ln2389">	}</a>
<a name="ln2390"> </a>
<a name="ln2391">      /* Break here - the completion mustn't be checked to be non-ambiguous */</a>
<a name="ln2392">      if (i == index)</a>
<a name="ln2393">	break;</a>
<a name="ln2394"> </a>
<a name="ln2395">      /* If there is exact match then filter ambiguous match else check</a>
<a name="ln2396">	 ambiguousness. */</a>
<a name="ln2397">      ret = is_cmd_ambiguous (cmd_vector, command, matches, match);</a>
<a name="ln2398">      if (ret == 1)</a>
<a name="ln2399">	{</a>
<a name="ln2400">	  vector_free (cmd_vector);</a>
<a name="ln2401">	  cmd_matches_free(&amp;matches);</a>
<a name="ln2402">	  *status = CMD_ERR_AMBIGUOUS;</a>
<a name="ln2403">	  return NULL;</a>
<a name="ln2404">	}</a>
<a name="ln2405">    }</a>
<a name="ln2406">  </a>
<a name="ln2407">  /* Prepare match vector. */</a>
<a name="ln2408">  matchvec = vector_init (INIT_MATCHVEC_SIZE);</a>
<a name="ln2409"> </a>
<a name="ln2410">  /* Build the possible list of continuations into a list of completions */</a>
<a name="ln2411">  for (i = 0; i &lt; vector_active (matches); i++)</a>
<a name="ln2412">    if ((match_vector = vector_slot (matches, i)))</a>
<a name="ln2413">      {</a>
<a name="ln2414">	const char *string;</a>
<a name="ln2415">	unsigned int j;</a>
<a name="ln2416"> </a>
<a name="ln2417">	for (j = 0; j &lt; vector_active (match_vector); j++)</a>
<a name="ln2418">	  if ((token = vector_slot (match_vector, j)))</a>
<a name="ln2419">            {</a>
<a name="ln2420">              string = cmd_entry_function (vector_slot (vline, index), token);</a>
<a name="ln2421">              if (string &amp;&amp; cmd_unique_string (matchvec, string))</a>
<a name="ln2422">                vector_set (matchvec, (islib != 0 ?</a>
<a name="ln2423">                                      XSTRDUP (MTYPE_TMP, string) :</a>
<a name="ln2424">                                      strdup (string) /* rl freed */));</a>
<a name="ln2425">            }</a>
<a name="ln2426">      }</a>
<a name="ln2427"> </a>
<a name="ln2428">  /* We don't need cmd_vector any more. */</a>
<a name="ln2429">  vector_free (cmd_vector);</a>
<a name="ln2430">  cmd_matches_free(&amp;matches);</a>
<a name="ln2431"> </a>
<a name="ln2432">  /* No matched command */</a>
<a name="ln2433">  if (vector_slot (matchvec, 0) == NULL)</a>
<a name="ln2434">    {</a>
<a name="ln2435">      vector_free (matchvec);</a>
<a name="ln2436"> </a>
<a name="ln2437">      /* In case of 'command \t' pattern.  Do you need '?' command at</a>
<a name="ln2438">         the end of the line. */</a>
<a name="ln2439">      if (vector_slot (vline, index) == '\0')</a>
<a name="ln2440">	*status = CMD_ERR_NOTHING_TODO;</a>
<a name="ln2441">      else</a>
<a name="ln2442">	*status = CMD_ERR_NO_MATCH;</a>
<a name="ln2443">      return NULL;</a>
<a name="ln2444">    }</a>
<a name="ln2445"> </a>
<a name="ln2446">  /* Only one matched */</a>
<a name="ln2447">  if (vector_slot (matchvec, 1) == NULL)</a>
<a name="ln2448">    {</a>
<a name="ln2449">      match_str = (char **) matchvec-&gt;index;</a>
<a name="ln2450">      vector_only_wrapper_free (matchvec);</a>
<a name="ln2451">      *status = CMD_COMPLETE_FULL_MATCH;</a>
<a name="ln2452">      return match_str;</a>
<a name="ln2453">    }</a>
<a name="ln2454">  /* Make it sure last element is NULL. */</a>
<a name="ln2455">  vector_set (matchvec, NULL);</a>
<a name="ln2456"> </a>
<a name="ln2457">  /* Check LCD of matched strings. */</a>
<a name="ln2458">  if (vector_slot (vline, index) != NULL)</a>
<a name="ln2459">    {</a>
<a name="ln2460">      lcd = cmd_lcd ((char **) matchvec-&gt;index);</a>
<a name="ln2461"> </a>
<a name="ln2462">      if (lcd)</a>
<a name="ln2463">	{</a>
<a name="ln2464">	  int len = strlen (vector_slot (vline, index));</a>
<a name="ln2465"> </a>
<a name="ln2466">	  if (len &lt; lcd)</a>
<a name="ln2467">	    {</a>
<a name="ln2468">	      char *lcdstr;</a>
<a name="ln2469"> </a>
<a name="ln2470">	      lcdstr = (islib != 0 ?</a>
<a name="ln2471">                        XMALLOC (MTYPE_TMP, lcd + 1) :</a>
<a name="ln2472">                        malloc(lcd + 1));</a>
<a name="ln2473">	      memcpy (lcdstr, matchvec-&gt;index[0], lcd);</a>
<a name="ln2474">	      lcdstr[lcd] = '\0';</a>
<a name="ln2475"> </a>
<a name="ln2476">	      /* Free matchvec. */</a>
<a name="ln2477">	      for (i = 0; i &lt; vector_active (matchvec); i++)</a>
<a name="ln2478">                {</a>
<a name="ln2479">                  if (vector_slot (matchvec, i))</a>
<a name="ln2480">                    {</a>
<a name="ln2481">                      if (islib != 0)</a>
<a name="ln2482">                        XFREE (MTYPE_TMP, vector_slot (matchvec, i));</a>
<a name="ln2483">                      else</a>
<a name="ln2484">                        free (vector_slot (matchvec, i));</a>
<a name="ln2485">                    }</a>
<a name="ln2486">                }</a>
<a name="ln2487">	      vector_free (matchvec);</a>
<a name="ln2488"> </a>
<a name="ln2489">	      /* Make new matchvec. */</a>
<a name="ln2490">	      matchvec = vector_init (INIT_MATCHVEC_SIZE);</a>
<a name="ln2491">	      vector_set (matchvec, lcdstr);</a>
<a name="ln2492">	      match_str = (char **) matchvec-&gt;index;</a>
<a name="ln2493">	      vector_only_wrapper_free (matchvec);</a>
<a name="ln2494"> </a>
<a name="ln2495">	      *status = CMD_COMPLETE_MATCH;</a>
<a name="ln2496">	      return match_str;</a>
<a name="ln2497">	    }</a>
<a name="ln2498">	}</a>
<a name="ln2499">    }</a>
<a name="ln2500"> </a>
<a name="ln2501">  match_str = (char **) matchvec-&gt;index;</a>
<a name="ln2502">  cmd_complete_sort(matchvec);</a>
<a name="ln2503">  vector_only_wrapper_free (matchvec);</a>
<a name="ln2504">  *status = CMD_COMPLETE_LIST_MATCH;</a>
<a name="ln2505">  return match_str;</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">char **</a>
<a name="ln2509">cmd_complete_command_lib (vector vline, struct vty *vty, int *status, int islib)</a>
<a name="ln2510">{</a>
<a name="ln2511">  char **ret;</a>
<a name="ln2512"> </a>
<a name="ln2513">  if ( cmd_try_do_shortcut(vty-&gt;node, vector_slot(vline, 0) ) )</a>
<a name="ln2514">    {</a>
<a name="ln2515">      enum node_type onode;</a>
<a name="ln2516">      vector shifted_vline;</a>
<a name="ln2517">      unsigned int index;</a>
<a name="ln2518"> </a>
<a name="ln2519">      onode = vty-&gt;node;</a>
<a name="ln2520">      vty-&gt;node = ENABLE_NODE;</a>
<a name="ln2521">      /* We can try it on enable node, cos' the vty is authenticated */</a>
<a name="ln2522"> </a>
<a name="ln2523">      shifted_vline = vector_init (vector_count(vline));</a>
<a name="ln2524">      /* use memcpy? */</a>
<a name="ln2525">      for (index = 1; index &lt; vector_active (vline); index++) </a>
<a name="ln2526">	{</a>
<a name="ln2527">	  vector_set_index (shifted_vline, index-1, vector_lookup(vline, index));</a>
<a name="ln2528">	}</a>
<a name="ln2529"> </a>
<a name="ln2530">      ret = cmd_complete_command_real (shifted_vline, vty, status, islib);</a>
<a name="ln2531"> </a>
<a name="ln2532">      vector_free(shifted_vline);</a>
<a name="ln2533">      vty-&gt;node = onode;</a>
<a name="ln2534">      return ret;</a>
<a name="ln2535">  }</a>
<a name="ln2536"> </a>
<a name="ln2537">  return cmd_complete_command_real (vline, vty, status, islib);</a>
<a name="ln2538">}</a>
<a name="ln2539"> </a>
<a name="ln2540">char **</a>
<a name="ln2541">cmd_complete_command (vector vline, struct vty *vty, int *status)</a>
<a name="ln2542">{</a>
<a name="ln2543">  return cmd_complete_command_lib (vline, vty, status, 0);</a>
<a name="ln2544">}</a>
<a name="ln2545"> </a>
<a name="ln2546">/* return parent node */</a>
<a name="ln2547">/* MUST eventually converge on CONFIG_NODE */</a>
<a name="ln2548">enum node_type</a>
<a name="ln2549">node_parent ( enum node_type node )</a>
<a name="ln2550">{</a>
<a name="ln2551">  enum node_type ret;</a>
<a name="ln2552"> </a>
<a name="ln2553">  assert (node &gt; CONFIG_NODE);</a>
<a name="ln2554"> </a>
<a name="ln2555">  switch (node)</a>
<a name="ln2556">    {</a>
<a name="ln2557">    case BGP_VPNV4_NODE:</a>
<a name="ln2558">    case BGP_VPNV6_NODE:</a>
<a name="ln2559">    case BGP_ENCAP_NODE:</a>
<a name="ln2560">    case BGP_ENCAPV6_NODE:</a>
<a name="ln2561">    case BGP_IPV4_NODE:</a>
<a name="ln2562">    case BGP_IPV4M_NODE:</a>
<a name="ln2563">    case BGP_IPV6_NODE:</a>
<a name="ln2564">    case BGP_IPV6M_NODE:</a>
<a name="ln2565">      ret = BGP_NODE;</a>
<a name="ln2566">      break;</a>
<a name="ln2567">    case KEYCHAIN_KEY_NODE:</a>
<a name="ln2568">      ret = KEYCHAIN_NODE;</a>
<a name="ln2569">      break;</a>
<a name="ln2570">    case LINK_PARAMS_NODE:</a>
<a name="ln2571">      ret = INTERFACE_NODE;</a>
<a name="ln2572">      break;</a>
<a name="ln2573">    default:</a>
<a name="ln2574">      ret = CONFIG_NODE;</a>
<a name="ln2575">      break;</a>
<a name="ln2576">    }</a>
<a name="ln2577"> </a>
<a name="ln2578">  return ret;</a>
<a name="ln2579">}</a>
<a name="ln2580"> </a>
<a name="ln2581">/* Execute command by argument vline vector. */</a>
<a name="ln2582">static int</a>
<a name="ln2583">cmd_execute_command_real (vector vline,</a>
<a name="ln2584">			  enum filter_type filter,</a>
<a name="ln2585">			  struct vty *vty,</a>
<a name="ln2586">			  struct cmd_element **cmd)</a>
<a name="ln2587">{</a>
<a name="ln2588">  unsigned int i;</a>
<a name="ln2589">  unsigned int index;</a>
<a name="ln2590">  vector cmd_vector;</a>
<a name="ln2591">  struct cmd_element *cmd_element;</a>
<a name="ln2592">  struct cmd_element *matched_element;</a>
<a name="ln2593">  unsigned int matched_count, incomplete_count;</a>
<a name="ln2594">  int argc;</a>
<a name="ln2595">  const char *argv[CMD_ARGC_MAX];</a>
<a name="ln2596">  enum match_type match = 0;</a>
<a name="ln2597">  char *command;</a>
<a name="ln2598">  int ret;</a>
<a name="ln2599">  vector matches;</a>
<a name="ln2600"> </a>
<a name="ln2601">  /* Make copy of command elements. */</a>
<a name="ln2602">  cmd_vector = vector_copy (cmd_node_vector (cmdvec, vty-&gt;node));</a>
<a name="ln2603"> </a>
<a name="ln2604">  for (index = 0; index &lt; vector_active (vline); index++)</a>
<a name="ln2605">    {</a>
<a name="ln2606">      command = vector_slot (vline, index);</a>
<a name="ln2607">      ret = cmd_vector_filter(cmd_vector,</a>
<a name="ln2608">			      filter,</a>
<a name="ln2609">			      vline, index,</a>
<a name="ln2610">			      &amp;match,</a>
<a name="ln2611">			      &amp;matches);</a>
<a name="ln2612"> </a>
<a name="ln2613">      if (ret != CMD_SUCCESS)</a>
<a name="ln2614">	{</a>
<a name="ln2615">	  cmd_matches_free(&amp;matches);</a>
<a name="ln2616">	  return ret;</a>
<a name="ln2617">	}</a>
<a name="ln2618"> </a>
<a name="ln2619">      if (match == vararg_match)</a>
<a name="ln2620">	{</a>
<a name="ln2621">	  cmd_matches_free(&amp;matches);</a>
<a name="ln2622">	  break;</a>
<a name="ln2623">	}</a>
<a name="ln2624"> </a>
<a name="ln2625">      ret = is_cmd_ambiguous (cmd_vector, command, matches, match);</a>
<a name="ln2626">      cmd_matches_free(&amp;matches);</a>
<a name="ln2627"> </a>
<a name="ln2628">      if (ret == 1)</a>
<a name="ln2629">	{</a>
<a name="ln2630">	  vector_free(cmd_vector);</a>
<a name="ln2631">	  return CMD_ERR_AMBIGUOUS;</a>
<a name="ln2632">	}</a>
<a name="ln2633">      else if (ret == 2)</a>
<a name="ln2634">	{</a>
<a name="ln2635">	  vector_free(cmd_vector);</a>
<a name="ln2636">	  return CMD_ERR_NO_MATCH;</a>
<a name="ln2637">	}</a>
<a name="ln2638">    }</a>
<a name="ln2639"> </a>
<a name="ln2640">  /* Check matched count. */</a>
<a name="ln2641">  matched_element = NULL;</a>
<a name="ln2642">  matched_count = 0;</a>
<a name="ln2643">  incomplete_count = 0;</a>
<a name="ln2644"> </a>
<a name="ln2645">  for (i = 0; i &lt; vector_active (cmd_vector); i++)</a>
<a name="ln2646">    if ((cmd_element = vector_slot (cmd_vector, i)))</a>
<a name="ln2647">      {</a>
<a name="ln2648">	if (cmd_is_complete(cmd_element, vline))</a>
<a name="ln2649">	  {</a>
<a name="ln2650">	    matched_element = cmd_element;</a>
<a name="ln2651">	    matched_count++;</a>
<a name="ln2652">	  }</a>
<a name="ln2653">	else</a>
<a name="ln2654">	  {</a>
<a name="ln2655">	    incomplete_count++;</a>
<a name="ln2656">	  }</a>
<a name="ln2657">      }</a>
<a name="ln2658"> </a>
<a name="ln2659">  /* Finish of using cmd_vector. */</a>
<a name="ln2660">  vector_free (cmd_vector);</a>
<a name="ln2661"> </a>
<a name="ln2662">  /* To execute command, matched_count must be 1. */</a>
<a name="ln2663">  if (matched_count == 0)</a>
<a name="ln2664">    {</a>
<a name="ln2665">      if (incomplete_count)</a>
<a name="ln2666">	return CMD_ERR_INCOMPLETE;</a>
<a name="ln2667">      else</a>
<a name="ln2668">	return CMD_ERR_NO_MATCH;</a>
<a name="ln2669">    }</a>
<a name="ln2670"> </a>
<a name="ln2671">  if (matched_count &gt; 1)</a>
<a name="ln2672">    return CMD_ERR_AMBIGUOUS;</a>
<a name="ln2673"> </a>
<a name="ln2674">  ret = cmd_parse(matched_element, vline, &amp;argc, argv);</a>
<a name="ln2675">  if (ret != CMD_SUCCESS)</a>
<a name="ln2676">    return ret;</a>
<a name="ln2677"> </a>
<a name="ln2678">  /* For vtysh execution. */</a>
<a name="ln2679">  if (cmd)</a>
<a name="ln2680">    *cmd = matched_element;</a>
<a name="ln2681"> </a>
<a name="ln2682">  if (matched_element-&gt;daemon)</a>
<a name="ln2683">    return CMD_SUCCESS_DAEMON;</a>
<a name="ln2684"> </a>
<a name="ln2685">  /* Execute matched command. */</a>
<a name="ln2686">  return (*matched_element-&gt;func) (matched_element, vty, argc, argv);</a>
<a name="ln2687">}</a>
<a name="ln2688"> </a>
<a name="ln2689">/**</a>
<a name="ln2690"> * Execute a given command, handling things like &quot;do ...&quot; and checking</a>
<a name="ln2691"> * whether the given command might apply at a parent node if doesn't</a>
<a name="ln2692"> * apply for the current node.</a>
<a name="ln2693"> *</a>
<a name="ln2694"> * @param vline Command line input, vector of char* where each element is</a>
<a name="ln2695"> *              one input token.</a>
<a name="ln2696"> * @param vty The vty context in which the command should be executed.</a>
<a name="ln2697"> * @param cmd Pointer where the struct cmd_element of the matched command</a>
<a name="ln2698"> *            will be stored, if any. May be set to NULL if this info is</a>
<a name="ln2699"> *            not needed.</a>
<a name="ln2700"> * @param vtysh If set != 0, don't lookup the command at parent nodes.</a>
<a name="ln2701"> * @return The status of the command that has been executed or an error code</a>
<a name="ln2702"> *         as to why no command could be executed.</a>
<a name="ln2703"> */</a>
<a name="ln2704">int</a>
<a name="ln2705">cmd_execute_command (vector vline, struct vty *vty, struct cmd_element **cmd,</a>
<a name="ln2706">		     int vtysh) {</a>
<a name="ln2707">  int ret, saved_ret, tried = 0;</a>
<a name="ln2708">  enum node_type onode, try_node;</a>
<a name="ln2709"> </a>
<a name="ln2710">  onode = try_node = vty-&gt;node;</a>
<a name="ln2711"> </a>
<a name="ln2712">  if ( cmd_try_do_shortcut(vty-&gt;node, vector_slot(vline, 0) ) )</a>
<a name="ln2713">    {</a>
<a name="ln2714">      vector shifted_vline;</a>
<a name="ln2715">      unsigned int index;</a>
<a name="ln2716"> </a>
<a name="ln2717">      vty-&gt;node = ENABLE_NODE;</a>
<a name="ln2718">      /* We can try it on enable node, cos' the vty is authenticated */</a>
<a name="ln2719"> </a>
<a name="ln2720">      shifted_vline = vector_init (vector_count(vline));</a>
<a name="ln2721">      /* use memcpy? */</a>
<a name="ln2722">      for (index = 1; index &lt; vector_active (vline); index++) </a>
<a name="ln2723">	{</a>
<a name="ln2724">	  vector_set_index (shifted_vline, index-1, vector_lookup(vline, index));</a>
<a name="ln2725">	}</a>
<a name="ln2726"> </a>
<a name="ln2727">      ret = cmd_execute_command_real (shifted_vline, FILTER_RELAXED, vty, cmd);</a>
<a name="ln2728"> </a>
<a name="ln2729">      vector_free(shifted_vline);</a>
<a name="ln2730">      vty-&gt;node = onode;</a>
<a name="ln2731">      return ret;</a>
<a name="ln2732">  }</a>
<a name="ln2733"> </a>
<a name="ln2734"> </a>
<a name="ln2735">  saved_ret = ret = cmd_execute_command_real (vline, FILTER_RELAXED, vty, cmd);</a>
<a name="ln2736"> </a>
<a name="ln2737">  if (vtysh)</a>
<a name="ln2738">    return saved_ret;</a>
<a name="ln2739"> </a>
<a name="ln2740">  /* This assumes all nodes above CONFIG_NODE are childs of CONFIG_NODE */</a>
<a name="ln2741">  while ( ret != CMD_SUCCESS &amp;&amp; ret != CMD_WARNING </a>
<a name="ln2742">	  &amp;&amp; vty-&gt;node &gt; CONFIG_NODE )</a>
<a name="ln2743">    {</a>
<a name="ln2744">      try_node = node_parent(try_node);</a>
<a name="ln2745">      vty-&gt;node = try_node;</a>
<a name="ln2746">      ret = cmd_execute_command_real (vline, FILTER_RELAXED, vty, cmd);</a>
<a name="ln2747">      tried = 1;</a>
<a name="ln2748">      if (ret == CMD_SUCCESS || ret == CMD_WARNING)</a>
<a name="ln2749">	{</a>
<a name="ln2750">	  /* succesfull command, leave the node as is */</a>
<a name="ln2751">	  return ret;</a>
<a name="ln2752">	}</a>
<a name="ln2753">    }</a>
<a name="ln2754">  /* no command succeeded, reset the vty to the original node and</a>
<a name="ln2755">     return the error for this node */</a>
<a name="ln2756">  if ( tried )</a>
<a name="ln2757">    vty-&gt;node = onode;</a>
<a name="ln2758">  return saved_ret;</a>
<a name="ln2759">}</a>
<a name="ln2760"> </a>
<a name="ln2761">/**</a>
<a name="ln2762"> * Execute a given command, matching it strictly against the current node.</a>
<a name="ln2763"> * This mode is used when reading config files.</a>
<a name="ln2764"> *</a>
<a name="ln2765"> * @param vline Command line input, vector of char* where each element is</a>
<a name="ln2766"> *              one input token.</a>
<a name="ln2767"> * @param vty The vty context in which the command should be executed.</a>
<a name="ln2768"> * @param cmd Pointer where the struct cmd_element* of the matched command</a>
<a name="ln2769"> *            will be stored, if any. May be set to NULL if this info is</a>
<a name="ln2770"> *            not needed.</a>
<a name="ln2771"> * @return The status of the command that has been executed or an error code</a>
<a name="ln2772"> *         as to why no command could be executed.</a>
<a name="ln2773"> */</a>
<a name="ln2774">int</a>
<a name="ln2775">cmd_execute_command_strict (vector vline, struct vty *vty,</a>
<a name="ln2776">			    struct cmd_element **cmd)</a>
<a name="ln2777">{</a>
<a name="ln2778">  return cmd_execute_command_real(vline, FILTER_STRICT, vty, cmd);</a>
<a name="ln2779">}</a>
<a name="ln2780"> </a>
<a name="ln2781">/**</a>
<a name="ln2782"> * Parse one line of config, walking up the parse tree attempting to find a match</a>
<a name="ln2783"> *</a>
<a name="ln2784"> * @param vty The vty context in which the command should be executed.</a>
<a name="ln2785"> * @param cmd Pointer where the struct cmd_element* of the match command</a>
<a name="ln2786"> *            will be stored, if any.  May be set to NULL if this info is</a>
<a name="ln2787"> *            not needed.</a>
<a name="ln2788"> * @param use_daemon Boolean to control whether or not we match on CMD_SUCCESS_DAEMON</a>
<a name="ln2789"> *                   or not.</a>
<a name="ln2790"> * @return The status of the command that has been executed or an error code</a>
<a name="ln2791"> *         as to why no command could be executed.</a>
<a name="ln2792"> */</a>
<a name="ln2793">int</a>
<a name="ln2794">command_config_read_one_line (struct vty *vty, struct cmd_element **cmd, int use_daemon)</a>
<a name="ln2795">{</a>
<a name="ln2796">  vector vline;</a>
<a name="ln2797">  int saved_node;</a>
<a name="ln2798">  int ret;</a>
<a name="ln2799"> </a>
<a name="ln2800">  vline = cmd_make_strvec (vty-&gt;buf);</a>
<a name="ln2801"> </a>
<a name="ln2802">  /* In case of comment line */</a>
<a name="ln2803">  if (vline == NULL)</a>
<a name="ln2804">    return CMD_SUCCESS;</a>
<a name="ln2805"> </a>
<a name="ln2806">  /* Execute configuration command : this is strict match */</a>
<a name="ln2807">  ret = cmd_execute_command_strict (vline, vty, cmd);</a>
<a name="ln2808"> </a>
<a name="ln2809">  saved_node = vty-&gt;node;</a>
<a name="ln2810"> </a>
<a name="ln2811">  while (!(use_daemon &amp;&amp; ret == CMD_SUCCESS_DAEMON) &amp;&amp;</a>
<a name="ln2812">	 ret != CMD_SUCCESS &amp;&amp; ret != CMD_WARNING &amp;&amp;</a>
<a name="ln2813">	 ret != CMD_ERR_NOTHING_TODO &amp;&amp; vty-&gt;node != CONFIG_NODE) {</a>
<a name="ln2814">    vty-&gt;node = node_parent(vty-&gt;node);</a>
<a name="ln2815">    ret = cmd_execute_command_strict (vline, vty, cmd);</a>
<a name="ln2816">  }</a>
<a name="ln2817"> </a>
<a name="ln2818">  // If climbing the tree did not work then ignore the command and</a>
<a name="ln2819">  // stay at the same node</a>
<a name="ln2820">  if (!(use_daemon &amp;&amp; ret == CMD_SUCCESS_DAEMON) &amp;&amp;</a>
<a name="ln2821">      ret != CMD_SUCCESS &amp;&amp; ret != CMD_WARNING &amp;&amp;</a>
<a name="ln2822">      ret != CMD_ERR_NOTHING_TODO)</a>
<a name="ln2823">    {</a>
<a name="ln2824">      vty-&gt;node = saved_node;</a>
<a name="ln2825">    }</a>
<a name="ln2826"> </a>
<a name="ln2827">  cmd_free_strvec (vline);</a>
<a name="ln2828"> </a>
<a name="ln2829">  return ret;</a>
<a name="ln2830">}</a>
<a name="ln2831"> </a>
<a name="ln2832">/* Configration make from file. */</a>
<a name="ln2833">int</a>
<a name="ln2834">config_from_file (struct vty *vty, FILE *fp, unsigned int *line_num)</a>
<a name="ln2835">{</a>
<a name="ln2836">  int ret;</a>
<a name="ln2837">  *line_num = 0;</a>
<a name="ln2838"> </a>
<a name="ln2839">  while (fgets (vty-&gt;buf, vty-&gt;max, fp))</a>
<a name="ln2840">    {</a>
<a name="ln2841">      ++(*line_num);</a>
<a name="ln2842"> </a>
<a name="ln2843">      ret = command_config_read_one_line (vty, NULL, 0);</a>
<a name="ln2844"> </a>
<a name="ln2845">      if (ret != CMD_SUCCESS &amp;&amp; ret != CMD_WARNING</a>
<a name="ln2846">	  &amp;&amp; ret != CMD_ERR_NOTHING_TODO)</a>
<a name="ln2847">	return ret;</a>
<a name="ln2848">    }</a>
<a name="ln2849">  return CMD_SUCCESS;</a>
<a name="ln2850">}</a>
<a name="ln2851"> </a>
<a name="ln2852">/* Configration from terminal */</a>
<a name="ln2853">DEFUN (config_terminal,</a>
<a name="ln2854">       config_terminal_cmd,</a>
<a name="ln2855">       &quot;configure terminal&quot;,</a>
<a name="ln2856">       &quot;Configuration from vty interface\n&quot;</a>
<a name="ln2857">       &quot;Configuration terminal\n&quot;)</a>
<a name="ln2858">{</a>
<a name="ln2859">  if (vty_config_lock (vty))</a>
<a name="ln2860">    vty-&gt;node = CONFIG_NODE;</a>
<a name="ln2861">  else</a>
<a name="ln2862">    {</a>
<a name="ln2863">      vty_out (vty, &quot;VTY configuration is locked by other VTY%s&quot;, VTY_NEWLINE);</a>
<a name="ln2864">      return CMD_WARNING;</a>
<a name="ln2865">    }</a>
<a name="ln2866">  return CMD_SUCCESS;</a>
<a name="ln2867">}</a>
<a name="ln2868"> </a>
<a name="ln2869">/* Enable command */</a>
<a name="ln2870">DEFUN (enable, </a>
<a name="ln2871">       config_enable_cmd,</a>
<a name="ln2872">       &quot;enable&quot;,</a>
<a name="ln2873">       &quot;Turn on privileged mode command\n&quot;)</a>
<a name="ln2874">{</a>
<a name="ln2875">  /* If enable password is NULL, change to ENABLE_NODE */</a>
<a name="ln2876">  if ((host.enable == NULL &amp;&amp; host.enable_encrypt == NULL) ||</a>
<a name="ln2877">      vty-&gt;type == VTY_SHELL_SERV)</a>
<a name="ln2878">    vty-&gt;node = ENABLE_NODE;</a>
<a name="ln2879">  else</a>
<a name="ln2880">    vty-&gt;node = AUTH_ENABLE_NODE;</a>
<a name="ln2881"> </a>
<a name="ln2882">  return CMD_SUCCESS;</a>
<a name="ln2883">}</a>
<a name="ln2884"> </a>
<a name="ln2885">/* Disable command */</a>
<a name="ln2886">DEFUN (disable, </a>
<a name="ln2887">       config_disable_cmd,</a>
<a name="ln2888">       &quot;disable&quot;,</a>
<a name="ln2889">       &quot;Turn off privileged mode command\n&quot;)</a>
<a name="ln2890">{</a>
<a name="ln2891">  if (vty-&gt;node == ENABLE_NODE)</a>
<a name="ln2892">    vty-&gt;node = VIEW_NODE;</a>
<a name="ln2893">  return CMD_SUCCESS;</a>
<a name="ln2894">}</a>
<a name="ln2895"> </a>
<a name="ln2896">/* Down vty node level. */</a>
<a name="ln2897">DEFUN (config_exit,</a>
<a name="ln2898">       config_exit_cmd,</a>
<a name="ln2899">       &quot;exit&quot;,</a>
<a name="ln2900">       &quot;Exit current mode and down to previous mode\n&quot;)</a>
<a name="ln2901">{</a>
<a name="ln2902">  switch (vty-&gt;node)</a>
<a name="ln2903">    {</a>
<a name="ln2904">    case VIEW_NODE:</a>
<a name="ln2905">    case ENABLE_NODE:</a>
<a name="ln2906">    case RESTRICTED_NODE:</a>
<a name="ln2907">      if (vty_shell (vty))</a>
<a name="ln2908">	exit (0);</a>
<a name="ln2909">      else</a>
<a name="ln2910">	vty-&gt;status = VTY_CLOSE;</a>
<a name="ln2911">      break;</a>
<a name="ln2912">    case CONFIG_NODE:</a>
<a name="ln2913">      vty-&gt;node = ENABLE_NODE;</a>
<a name="ln2914">      vty_config_unlock (vty);</a>
<a name="ln2915">      break;</a>
<a name="ln2916">    case INTERFACE_NODE:</a>
<a name="ln2917">    case ZEBRA_NODE:</a>
<a name="ln2918">    case BGP_NODE:</a>
<a name="ln2919">    case RIP_NODE:</a>
<a name="ln2920">    case RIPNG_NODE:</a>
<a name="ln2921">    case BABEL_NODE:</a>
<a name="ln2922">    case OSPF_NODE:</a>
<a name="ln2923">    case OSPF6_NODE:</a>
<a name="ln2924">    case ISIS_NODE:</a>
<a name="ln2925">    case KEYCHAIN_NODE:</a>
<a name="ln2926">    case MASC_NODE:</a>
<a name="ln2927">    case RMAP_NODE:</a>
<a name="ln2928">    case PIM_NODE:</a>
<a name="ln2929">    case VTY_NODE:</a>
<a name="ln2930">      vty-&gt;node = CONFIG_NODE;</a>
<a name="ln2931">      break;</a>
<a name="ln2932">    case BGP_IPV4_NODE:</a>
<a name="ln2933">    case BGP_IPV4M_NODE:</a>
<a name="ln2934">    case BGP_VPNV4_NODE:</a>
<a name="ln2935">    case BGP_VPNV6_NODE:</a>
<a name="ln2936">    case BGP_ENCAP_NODE:</a>
<a name="ln2937">    case BGP_ENCAPV6_NODE:</a>
<a name="ln2938">    case BGP_IPV6_NODE:</a>
<a name="ln2939">    case BGP_IPV6M_NODE:</a>
<a name="ln2940">      vty-&gt;node = BGP_NODE;</a>
<a name="ln2941">      break;</a>
<a name="ln2942">    case KEYCHAIN_KEY_NODE:</a>
<a name="ln2943">      vty-&gt;node = KEYCHAIN_NODE;</a>
<a name="ln2944">      break;</a>
<a name="ln2945">    case LINK_PARAMS_NODE:</a>
<a name="ln2946">      vty-&gt;node = INTERFACE_NODE;</a>
<a name="ln2947">      break;</a>
<a name="ln2948">    default:</a>
<a name="ln2949">      break;</a>
<a name="ln2950">    }</a>
<a name="ln2951">  return CMD_SUCCESS;</a>
<a name="ln2952">}</a>
<a name="ln2953"> </a>
<a name="ln2954">/* quit is alias of exit. */</a>
<a name="ln2955">ALIAS (config_exit,</a>
<a name="ln2956">       config_quit_cmd,</a>
<a name="ln2957">       &quot;quit&quot;,</a>
<a name="ln2958">       &quot;Exit current mode and down to previous mode\n&quot;)</a>
<a name="ln2959">       </a>
<a name="ln2960">/* End of configuration. */</a>
<a name="ln2961">DEFUN (config_end,</a>
<a name="ln2962">       config_end_cmd,</a>
<a name="ln2963">       &quot;end&quot;,</a>
<a name="ln2964">       &quot;End current mode and change to enable mode.&quot;)</a>
<a name="ln2965">{</a>
<a name="ln2966">  switch (vty-&gt;node)</a>
<a name="ln2967">    {</a>
<a name="ln2968">    case VIEW_NODE:</a>
<a name="ln2969">    case ENABLE_NODE:</a>
<a name="ln2970">    case RESTRICTED_NODE:</a>
<a name="ln2971">      /* Nothing to do. */</a>
<a name="ln2972">      break;</a>
<a name="ln2973">    case CONFIG_NODE:</a>
<a name="ln2974">    case INTERFACE_NODE:</a>
<a name="ln2975">    case ZEBRA_NODE:</a>
<a name="ln2976">    case RIP_NODE:</a>
<a name="ln2977">    case RIPNG_NODE:</a>
<a name="ln2978">    case BABEL_NODE:</a>
<a name="ln2979">    case BGP_NODE:</a>
<a name="ln2980">    case BGP_ENCAP_NODE:</a>
<a name="ln2981">    case BGP_ENCAPV6_NODE:</a>
<a name="ln2982">    case BGP_VPNV4_NODE:</a>
<a name="ln2983">    case BGP_VPNV6_NODE:</a>
<a name="ln2984">    case BGP_IPV4_NODE:</a>
<a name="ln2985">    case BGP_IPV4M_NODE:</a>
<a name="ln2986">    case BGP_IPV6_NODE:</a>
<a name="ln2987">    case BGP_IPV6M_NODE:</a>
<a name="ln2988">    case RMAP_NODE:</a>
<a name="ln2989">    case OSPF_NODE:</a>
<a name="ln2990">    case OSPF6_NODE:</a>
<a name="ln2991">    case ISIS_NODE:</a>
<a name="ln2992">    case KEYCHAIN_NODE:</a>
<a name="ln2993">    case KEYCHAIN_KEY_NODE:</a>
<a name="ln2994">    case MASC_NODE:</a>
<a name="ln2995">    case PIM_NODE:</a>
<a name="ln2996">    case VTY_NODE:</a>
<a name="ln2997">    case LINK_PARAMS_NODE:</a>
<a name="ln2998">      vty_config_unlock (vty);</a>
<a name="ln2999">      vty-&gt;node = ENABLE_NODE;</a>
<a name="ln3000">      break;</a>
<a name="ln3001">    default:</a>
<a name="ln3002">      break;</a>
<a name="ln3003">    }</a>
<a name="ln3004">  return CMD_SUCCESS;</a>
<a name="ln3005">}</a>
<a name="ln3006"> </a>
<a name="ln3007">/* Show version. */</a>
<a name="ln3008">DEFUN (show_version,</a>
<a name="ln3009">       show_version_cmd,</a>
<a name="ln3010">       &quot;show version&quot;,</a>
<a name="ln3011">       SHOW_STR</a>
<a name="ln3012">       &quot;Displays zebra version\n&quot;)</a>
<a name="ln3013">{</a>
<a name="ln3014">  vty_out (vty, &quot;Quagga %s (%s).%s&quot;, QUAGGA_VERSION, host.name?host.name:&quot;&quot;,</a>
<a name="ln3015">	   VTY_NEWLINE);</a>
<a name="ln3016">  vty_out (vty, &quot;%s%s%s&quot;, QUAGGA_COPYRIGHT, GIT_INFO, VTY_NEWLINE);</a>
<a name="ln3017">  vty_out (vty, &quot;configured with:%s    %s%s&quot;, VTY_NEWLINE,</a>
<a name="ln3018">           QUAGGA_CONFIG_ARGS, VTY_NEWLINE);</a>
<a name="ln3019"> </a>
<a name="ln3020">  return CMD_SUCCESS;</a>
<a name="ln3021">}</a>
<a name="ln3022"> </a>
<a name="ln3023">/* Help display function for all node. */</a>
<a name="ln3024">DEFUN (config_help,</a>
<a name="ln3025">       config_help_cmd,</a>
<a name="ln3026">       &quot;help&quot;,</a>
<a name="ln3027">       &quot;Description of the interactive help system\n&quot;)</a>
<a name="ln3028">{</a>
<a name="ln3029">  vty_out (vty, </a>
<a name="ln3030">	   &quot;Quagga VTY provides advanced help feature.  When you need help,%s\</a>
<a name="ln3031">anytime at the command line please press '?'.%s\</a>
<a name="ln3032">%s\</a>
<a name="ln3033">If nothing matches, the help list will be empty and you must backup%s\</a>
<a name="ln3034"> until entering a '?' shows the available options.%s\</a>
<a name="ln3035">Two styles of help are provided:%s\</a>
<a name="ln3036">1. Full help is available when you are ready to enter a%s\</a>
<a name="ln3037">command argument (e.g. 'show ?') and describes each possible%s\</a>
<a name="ln3038">argument.%s\</a>
<a name="ln3039">2. Partial help is provided when an abbreviated argument is entered%s\</a>
<a name="ln3040">   and you want to know what arguments match the input%s\</a>
<a name="ln3041">   (e.g. 'show me?'.)%s%s&quot;, VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE,</a>
<a name="ln3042">	   VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE,</a>
<a name="ln3043">	   VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln3044">  return CMD_SUCCESS;</a>
<a name="ln3045">}</a>
<a name="ln3046"> </a>
<a name="ln3047">/* Help display function for all node. */</a>
<a name="ln3048">DEFUN (config_list,</a>
<a name="ln3049">       config_list_cmd,</a>
<a name="ln3050">       &quot;list&quot;,</a>
<a name="ln3051">       &quot;Print command list\n&quot;)</a>
<a name="ln3052">{</a>
<a name="ln3053">  unsigned int i;</a>
<a name="ln3054">  struct cmd_node *cnode = vector_slot (cmdvec, vty-&gt;node);</a>
<a name="ln3055">  struct cmd_element *cmd;</a>
<a name="ln3056"> </a>
<a name="ln3057">  for (i = 0; i &lt; vector_active (cnode-&gt;cmd_vector); i++)</a>
<a name="ln3058">    if ((cmd = vector_slot (cnode-&gt;cmd_vector, i)) != NULL</a>
<a name="ln3059">        &amp;&amp; !(cmd-&gt;attr == CMD_ATTR_DEPRECATED</a>
<a name="ln3060">             || cmd-&gt;attr == CMD_ATTR_HIDDEN))</a>
<a name="ln3061">      vty_out (vty, &quot;  %s%s&quot;, cmd-&gt;string,</a>
<a name="ln3062">	       VTY_NEWLINE);</a>
<a name="ln3063">  return CMD_SUCCESS;</a>
<a name="ln3064">}</a>
<a name="ln3065"> </a>
<a name="ln3066">/* Write current configuration into file. */</a>
<a name="ln3067">DEFUN (config_write_file, </a>
<a name="ln3068">       config_write_file_cmd,</a>
<a name="ln3069">       &quot;write file&quot;,  </a>
<a name="ln3070">       &quot;Write running configuration to memory, network, or terminal\n&quot;</a>
<a name="ln3071">       &quot;Write to configuration file\n&quot;)</a>
<a name="ln3072">{</a>
<a name="ln3073">  unsigned int i;</a>
<a name="ln3074">  int fd, dupfd = -1;</a>
<a name="ln3075">  struct cmd_node *node;</a>
<a name="ln3076">  char *config_file;</a>
<a name="ln3077">  char *config_file_tmp = NULL;</a>
<a name="ln3078">  char *config_file_sav = NULL;</a>
<a name="ln3079">  int ret = CMD_WARNING;</a>
<a name="ln3080">  struct vty *file_vty;</a>
<a name="ln3081"> </a>
<a name="ln3082">  /* Check and see if we are operating under vtysh configuration */</a>
<a name="ln3083">  if (host.config == NULL)</a>
<a name="ln3084">    {</a>
<a name="ln3085">      vty_out (vty, &quot;Can't save to configuration file, using vtysh.%s&quot;,</a>
<a name="ln3086">	       VTY_NEWLINE);</a>
<a name="ln3087">      return CMD_WARNING;</a>
<a name="ln3088">    }</a>
<a name="ln3089"> </a>
<a name="ln3090">  /* Get filename. */</a>
<a name="ln3091">  config_file = host.config;</a>
<a name="ln3092">  </a>
<a name="ln3093">  config_file_sav =</a>
<a name="ln3094">    XMALLOC (MTYPE_TMP, strlen (config_file) + strlen (CONF_BACKUP_EXT) + 1);</a>
<a name="ln3095">  strcpy (config_file_sav, config_file);</a>
<a name="ln3096">  strcat (config_file_sav, CONF_BACKUP_EXT);</a>
<a name="ln3097"> </a>
<a name="ln3098"> </a>
<a name="ln3099">  config_file_tmp = XMALLOC (MTYPE_TMP, strlen (config_file) + 8);</a>
<a name="ln3100">  sprintf (config_file_tmp, &quot;%s.XXXXXX&quot;, config_file);</a>
<a name="ln3101">  </a>
<a name="ln3102">  /* Open file to configuration write. */</a>
<a name="ln3103">  fd = mkstemp (config_file_tmp);</a>
<a name="ln3104">  if (fd &lt; 0)</a>
<a name="ln3105">    {</a>
<a name="ln3106">      vty_out (vty, &quot;Can't open configuration file %s.%s&quot;, config_file_tmp,</a>
<a name="ln3107">	       VTY_NEWLINE);</a>
<a name="ln3108">      goto finished;</a>
<a name="ln3109">    }</a>
<a name="ln3110">  </a>
<a name="ln3111">  /* Make vty for configuration file. */</a>
<a name="ln3112">  file_vty = vty_new ();</a>
<a name="ln3113">  file_vty-&gt;wfd = fd;</a>
<a name="ln3114">  file_vty-&gt;type = VTY_FILE;</a>
<a name="ln3115"> </a>
<a name="ln3116">  /* Config file header print. */</a>
<a name="ln3117">  vty_out (file_vty, &quot;!\n! Zebra configuration saved from vty\n!   &quot;);</a>
<a name="ln3118">  vty_time_print (file_vty, 1);</a>
<a name="ln3119">  vty_out (file_vty, &quot;!\n&quot;);</a>
<a name="ln3120"> </a>
<a name="ln3121">  for (i = 0; i &lt; vector_active (cmdvec); i++)</a>
<a name="ln3122">    if ((node = vector_slot (cmdvec, i)) &amp;&amp; node-&gt;func)</a>
<a name="ln3123">      {</a>
<a name="ln3124">	if ((*node-&gt;func) (file_vty))</a>
<a name="ln3125">	  vty_out (file_vty, &quot;!\n&quot;);</a>
<a name="ln3126">      }</a>
<a name="ln3127">  </a>
<a name="ln3128">  if ((dupfd = dup (file_vty-&gt;wfd)) &lt; 0)</a>
<a name="ln3129">    {</a>
<a name="ln3130">      vty_out (vty, &quot;Couldn't dup fd (for fdatasync) for %s, %s (%d).%s&quot;, </a>
<a name="ln3131">               config_file, safe_strerror(errno), errno, VTY_NEWLINE);</a>
<a name="ln3132">    }</a>
<a name="ln3133"> </a>
<a name="ln3134">  vty_close (file_vty);</a>
<a name="ln3135">  </a>
<a name="ln3136">  if (fdatasync (dupfd) &lt; 0)</a>
<a name="ln3137">    {</a>
<a name="ln3138">      vty_out (vty, &quot;Couldn't fdatasync %s, %s (%d)!%s&quot;,</a>
<a name="ln3139">               config_file, safe_strerror(errno), errno, VTY_NEWLINE);</a>
<a name="ln3140">    }</a>
<a name="ln3141"> </a>
<a name="ln3142">  if (unlink (config_file_sav) != 0)</a>
<a name="ln3143">    if (errno != ENOENT)</a>
<a name="ln3144">      {</a>
<a name="ln3145">	vty_out (vty, &quot;Can't unlink backup configuration file %s.%s&quot;, config_file_sav,</a>
<a name="ln3146">		 VTY_NEWLINE);</a>
<a name="ln3147">        goto finished;</a>
<a name="ln3148">      }</a>
<a name="ln3149">  if (link (config_file, config_file_sav) != 0)</a>
<a name="ln3150">    {</a>
<a name="ln3151">      vty_out (vty, &quot;Can't backup old configuration file %s.%s&quot;, config_file_sav,</a>
<a name="ln3152">	        VTY_NEWLINE);</a>
<a name="ln3153">      goto finished;</a>
<a name="ln3154">    }</a>
<a name="ln3155">  if (rename (config_file_tmp, config_file) != 0)</a>
<a name="ln3156">    {</a>
<a name="ln3157">      vty_out (vty, &quot;Can't move configuration file %s into place.%s&quot;,</a>
<a name="ln3158">               config_file, VTY_NEWLINE);</a>
<a name="ln3159">      goto finished;</a>
<a name="ln3160">    }</a>
<a name="ln3161">  if (chmod (config_file, CONFIGFILE_MASK) != 0)</a>
<a name="ln3162">    {</a>
<a name="ln3163">      vty_out (vty, &quot;Can't chmod configuration file %s: %s (%d).%s&quot;, </a>
<a name="ln3164">	config_file, safe_strerror(errno), errno, VTY_NEWLINE);</a>
<a name="ln3165">      goto finished;</a>
<a name="ln3166">    }</a>
<a name="ln3167"> </a>
<a name="ln3168">  vty_out (vty, &quot;Configuration saved to %s%s&quot;, config_file,</a>
<a name="ln3169">	   VTY_NEWLINE);</a>
<a name="ln3170">  ret = CMD_SUCCESS;</a>
<a name="ln3171"> </a>
<a name="ln3172">finished:</a>
<a name="ln3173">  if (dupfd &gt;= 0)</a>
<a name="ln3174">    close (dupfd);</a>
<a name="ln3175">  unlink (config_file_tmp);</a>
<a name="ln3176">  XFREE (MTYPE_TMP, config_file_tmp);</a>
<a name="ln3177">  XFREE (MTYPE_TMP, config_file_sav);</a>
<a name="ln3178">  return ret;</a>
<a name="ln3179">}</a>
<a name="ln3180"> </a>
<a name="ln3181">ALIAS (config_write_file, </a>
<a name="ln3182">       config_write_cmd,</a>
<a name="ln3183">       &quot;write&quot;,  </a>
<a name="ln3184">       &quot;Write running configuration to memory, network, or terminal\n&quot;)</a>
<a name="ln3185"> </a>
<a name="ln3186">ALIAS (config_write_file, </a>
<a name="ln3187">       config_write_memory_cmd,</a>
<a name="ln3188">       &quot;write memory&quot;,  </a>
<a name="ln3189">       &quot;Write running configuration to memory, network, or terminal\n&quot;</a>
<a name="ln3190">       &quot;Write configuration to the file (same as write file)\n&quot;)</a>
<a name="ln3191"> </a>
<a name="ln3192">ALIAS (config_write_file, </a>
<a name="ln3193">       copy_runningconfig_startupconfig_cmd,</a>
<a name="ln3194">       &quot;copy running-config startup-config&quot;,  </a>
<a name="ln3195">       &quot;Copy configuration\n&quot;</a>
<a name="ln3196">       &quot;Copy running config to... \n&quot;</a>
<a name="ln3197">       &quot;Copy running config to startup config (same as write file)\n&quot;)</a>
<a name="ln3198"> </a>
<a name="ln3199">/* Write current configuration into the terminal. */</a>
<a name="ln3200">DEFUN (config_write_terminal,</a>
<a name="ln3201">       config_write_terminal_cmd,</a>
<a name="ln3202">       &quot;write terminal&quot;,</a>
<a name="ln3203">       &quot;Write running configuration to memory, network, or terminal\n&quot;</a>
<a name="ln3204">       &quot;Write to terminal\n&quot;)</a>
<a name="ln3205">{</a>
<a name="ln3206">  unsigned int i;</a>
<a name="ln3207">  struct cmd_node *node;</a>
<a name="ln3208"> </a>
<a name="ln3209">  if (vty-&gt;type == VTY_SHELL_SERV)</a>
<a name="ln3210">    {</a>
<a name="ln3211">      for (i = 0; i &lt; vector_active (cmdvec); i++)</a>
<a name="ln3212">	if ((node = vector_slot (cmdvec, i)) &amp;&amp; node-&gt;func &amp;&amp; node-&gt;vtysh)</a>
<a name="ln3213">	  {</a>
<a name="ln3214">	    if ((*node-&gt;func) (vty))</a>
<a name="ln3215">	      vty_out (vty, &quot;!%s&quot;, VTY_NEWLINE);</a>
<a name="ln3216">	  }</a>
<a name="ln3217">    }</a>
<a name="ln3218">  else</a>
<a name="ln3219">    {</a>
<a name="ln3220">      vty_out (vty, &quot;%sCurrent configuration:%s&quot;, VTY_NEWLINE,</a>
<a name="ln3221">	       VTY_NEWLINE);</a>
<a name="ln3222">      vty_out (vty, &quot;!%s&quot;, VTY_NEWLINE);</a>
<a name="ln3223"> </a>
<a name="ln3224">      for (i = 0; i &lt; vector_active (cmdvec); i++)</a>
<a name="ln3225">	if ((node = vector_slot (cmdvec, i)) &amp;&amp; node-&gt;func)</a>
<a name="ln3226">	  {</a>
<a name="ln3227">	    if ((*node-&gt;func) (vty))</a>
<a name="ln3228">	      vty_out (vty, &quot;!%s&quot;, VTY_NEWLINE);</a>
<a name="ln3229">	  }</a>
<a name="ln3230">      vty_out (vty, &quot;end%s&quot;,VTY_NEWLINE);</a>
<a name="ln3231">    }</a>
<a name="ln3232">  return CMD_SUCCESS;</a>
<a name="ln3233">}</a>
<a name="ln3234"> </a>
<a name="ln3235">/* Write current configuration into the terminal. */</a>
<a name="ln3236">ALIAS (config_write_terminal,</a>
<a name="ln3237">       show_running_config_cmd,</a>
<a name="ln3238">       &quot;show running-config&quot;,</a>
<a name="ln3239">       SHOW_STR</a>
<a name="ln3240">       &quot;running configuration\n&quot;)</a>
<a name="ln3241"> </a>
<a name="ln3242">/* Write startup configuration into the terminal. */</a>
<a name="ln3243">DEFUN (show_startup_config,</a>
<a name="ln3244">       show_startup_config_cmd,</a>
<a name="ln3245">       &quot;show startup-config&quot;,</a>
<a name="ln3246">       SHOW_STR</a>
<a name="ln3247">       &quot;Contentes of startup configuration\n&quot;)</a>
<a name="ln3248">{</a>
<a name="ln3249">  char buf[BUFSIZ];</a>
<a name="ln3250">  FILE *confp;</a>
<a name="ln3251"> </a>
<a name="ln3252">  confp = fopen (host.config, &quot;r&quot;);</a>
<a name="ln3253">  if (confp == NULL)</a>
<a name="ln3254">    {</a>
<a name="ln3255">      vty_out (vty, &quot;Can't open configuration file [%s]%s&quot;,</a>
<a name="ln3256">	       host.config, VTY_NEWLINE);</a>
<a name="ln3257">      return CMD_WARNING;</a>
<a name="ln3258">    }</a>
<a name="ln3259"> </a>
<a name="ln3260">  while (fgets (buf, BUFSIZ, confp))</a>
<a name="ln3261">    {</a>
<a name="ln3262">      char *cp = buf;</a>
<a name="ln3263"> </a>
<a name="ln3264">      while (*cp != '\r' &amp;&amp; *cp != '\n' &amp;&amp; *cp != '\0')</a>
<a name="ln3265">	cp++;</a>
<a name="ln3266">      *cp = '\0';</a>
<a name="ln3267"> </a>
<a name="ln3268">      vty_out (vty, &quot;%s%s&quot;, buf, VTY_NEWLINE);</a>
<a name="ln3269">    }</a>
<a name="ln3270"> </a>
<a name="ln3271">  fclose (confp);</a>
<a name="ln3272"> </a>
<a name="ln3273">  return CMD_SUCCESS;</a>
<a name="ln3274">}</a>
<a name="ln3275"> </a>
<a name="ln3276">/* Hostname configuration */</a>
<a name="ln3277">DEFUN (config_hostname, </a>
<a name="ln3278">       hostname_cmd,</a>
<a name="ln3279">       &quot;hostname WORD&quot;,</a>
<a name="ln3280">       &quot;Set system's network name\n&quot;</a>
<a name="ln3281">       &quot;This system's network name\n&quot;)</a>
<a name="ln3282">{</a>
<a name="ln3283">  if (!isalpha((int) *argv[0]))</a>
<a name="ln3284">    {</a>
<a name="ln3285">      vty_out (vty, &quot;Please specify string starting with alphabet%s&quot;, VTY_NEWLINE);</a>
<a name="ln3286">      return CMD_WARNING;</a>
<a name="ln3287">    }</a>
<a name="ln3288"> </a>
<a name="ln3289">  if (host.name)</a>
<a name="ln3290">    XFREE (MTYPE_HOST, host.name);</a>
<a name="ln3291">    </a>
<a name="ln3292">  host.name = XSTRDUP (MTYPE_HOST, argv[0]);</a>
<a name="ln3293">  return CMD_SUCCESS;</a>
<a name="ln3294">}</a>
<a name="ln3295"> </a>
<a name="ln3296">DEFUN (config_no_hostname, </a>
<a name="ln3297">       no_hostname_cmd,</a>
<a name="ln3298">       &quot;no hostname [HOSTNAME]&quot;,</a>
<a name="ln3299">       NO_STR</a>
<a name="ln3300">       &quot;Reset system's network name\n&quot;</a>
<a name="ln3301">       &quot;Host name of this router\n&quot;)</a>
<a name="ln3302">{</a>
<a name="ln3303">  if (host.name)</a>
<a name="ln3304">    XFREE (MTYPE_HOST, host.name);</a>
<a name="ln3305">  host.name = NULL;</a>
<a name="ln3306">  return CMD_SUCCESS;</a>
<a name="ln3307">}</a>
<a name="ln3308"> </a>
<a name="ln3309">/* VTY interface password set. */</a>
<a name="ln3310">DEFUN (config_password, password_cmd,</a>
<a name="ln3311">       &quot;password (8|) WORD&quot;,</a>
<a name="ln3312">       &quot;Assign the terminal connection password\n&quot;</a>
<a name="ln3313">       &quot;Specifies a HIDDEN password will follow\n&quot;</a>
<a name="ln3314">       &quot;dummy string \n&quot;</a>
<a name="ln3315">       &quot;The HIDDEN line password string\n&quot;)</a>
<a name="ln3316">{</a>
<a name="ln3317">  /* Argument check. */</a>
<a name="ln3318">  if (argc == 0)</a>
<a name="ln3319">    {</a>
<a name="ln3320">      vty_out (vty, &quot;Please specify password.%s&quot;, VTY_NEWLINE);</a>
<a name="ln3321">      return CMD_WARNING;</a>
<a name="ln3322">    }</a>
<a name="ln3323"> </a>
<a name="ln3324">  if (argc == 2)</a>
<a name="ln3325">    {</a>
<a name="ln3326">      if (*argv[0] == '8')</a>
<a name="ln3327">	{</a>
<a name="ln3328">	  if (host.password)</a>
<a name="ln3329">	    XFREE (MTYPE_HOST, host.password);</a>
<a name="ln3330">	  host.password = NULL;</a>
<a name="ln3331">	  if (host.password_encrypt)</a>
<a name="ln3332">	    XFREE (MTYPE_HOST, host.password_encrypt);</a>
<a name="ln3333">	  host.password_encrypt = XSTRDUP (MTYPE_HOST, argv[1]);</a>
<a name="ln3334">	  return CMD_SUCCESS;</a>
<a name="ln3335">	}</a>
<a name="ln3336">      else</a>
<a name="ln3337">	{</a>
<a name="ln3338">	  vty_out (vty, &quot;Unknown encryption type.%s&quot;, VTY_NEWLINE);</a>
<a name="ln3339">	  return CMD_WARNING;</a>
<a name="ln3340">	}</a>
<a name="ln3341">    }</a>
<a name="ln3342"> </a>
<a name="ln3343">  if (!isalnum ((int) *argv[0]))</a>
<a name="ln3344">    {</a>
<a name="ln3345">      vty_out (vty, </a>
<a name="ln3346">	       &quot;Please specify string starting with alphanumeric%s&quot;, VTY_NEWLINE);</a>
<a name="ln3347">      return CMD_WARNING;</a>
<a name="ln3348">    }</a>
<a name="ln3349"> </a>
<a name="ln3350">  if (host.password)</a>
<a name="ln3351">    XFREE (MTYPE_HOST, host.password);</a>
<a name="ln3352">  host.password = NULL;</a>
<a name="ln3353"> </a>
<a name="ln3354">  if (host.encrypt)</a>
<a name="ln3355">    {</a>
<a name="ln3356">      if (host.password_encrypt)</a>
<a name="ln3357">	XFREE (MTYPE_HOST, host.password_encrypt);</a>
<a name="ln3358">      host.password_encrypt = XSTRDUP (MTYPE_HOST, zencrypt (argv[0]));</a>
<a name="ln3359">    }</a>
<a name="ln3360">  else</a>
<a name="ln3361">    host.password = XSTRDUP (MTYPE_HOST, argv[0]);</a>
<a name="ln3362"> </a>
<a name="ln3363">  return CMD_SUCCESS;</a>
<a name="ln3364">}</a>
<a name="ln3365"> </a>
<a name="ln3366">ALIAS (config_password, password_text_cmd,</a>
<a name="ln3367">       &quot;password LINE&quot;,</a>
<a name="ln3368">       &quot;Assign the terminal connection password\n&quot;</a>
<a name="ln3369">       &quot;The UNENCRYPTED (cleartext) line password\n&quot;)</a>
<a name="ln3370"> </a>
<a name="ln3371">/* VTY enable password set. */</a>
<a name="ln3372">DEFUN (config_enable_password, enable_password_cmd,</a>
<a name="ln3373">       &quot;enable password (8|) WORD&quot;,</a>
<a name="ln3374">       &quot;Modify enable password parameters\n&quot;</a>
<a name="ln3375">       &quot;Assign the privileged level password\n&quot;</a>
<a name="ln3376">       &quot;Specifies a HIDDEN password will follow\n&quot;</a>
<a name="ln3377">       &quot;dummy string \n&quot;</a>
<a name="ln3378">       &quot;The HIDDEN 'enable' password string\n&quot;)</a>
<a name="ln3379">{</a>
<a name="ln3380">  /* Argument check. */</a>
<a name="ln3381">  if (argc == 0)</a>
<a name="ln3382">    {</a>
<a name="ln3383">      vty_out (vty, &quot;Please specify password.%s&quot;, VTY_NEWLINE);</a>
<a name="ln3384">      return CMD_WARNING;</a>
<a name="ln3385">    }</a>
<a name="ln3386"> </a>
<a name="ln3387">  /* Crypt type is specified. */</a>
<a name="ln3388">  if (argc == 2)</a>
<a name="ln3389">    {</a>
<a name="ln3390">      if (*argv[0] == '8')</a>
<a name="ln3391">	{</a>
<a name="ln3392">	  if (host.enable)</a>
<a name="ln3393">	    XFREE (MTYPE_HOST, host.enable);</a>
<a name="ln3394">	  host.enable = NULL;</a>
<a name="ln3395"> </a>
<a name="ln3396">	  if (host.enable_encrypt)</a>
<a name="ln3397">	    XFREE (MTYPE_HOST, host.enable_encrypt);</a>
<a name="ln3398">	  host.enable_encrypt = XSTRDUP (MTYPE_HOST, argv[1]);</a>
<a name="ln3399"> </a>
<a name="ln3400">	  return CMD_SUCCESS;</a>
<a name="ln3401">	}</a>
<a name="ln3402">      else</a>
<a name="ln3403">	{</a>
<a name="ln3404">	  vty_out (vty, &quot;Unknown encryption type.%s&quot;, VTY_NEWLINE);</a>
<a name="ln3405">	  return CMD_WARNING;</a>
<a name="ln3406">	}</a>
<a name="ln3407">    }</a>
<a name="ln3408"> </a>
<a name="ln3409">  if (!isalnum ((int) *argv[0]))</a>
<a name="ln3410">    {</a>
<a name="ln3411">      vty_out (vty, </a>
<a name="ln3412">	       &quot;Please specify string starting with alphanumeric%s&quot;, VTY_NEWLINE);</a>
<a name="ln3413">      return CMD_WARNING;</a>
<a name="ln3414">    }</a>
<a name="ln3415"> </a>
<a name="ln3416">  if (host.enable)</a>
<a name="ln3417">    XFREE (MTYPE_HOST, host.enable);</a>
<a name="ln3418">  host.enable = NULL;</a>
<a name="ln3419"> </a>
<a name="ln3420">  /* Plain password input. */</a>
<a name="ln3421">  if (host.encrypt)</a>
<a name="ln3422">    {</a>
<a name="ln3423">      if (host.enable_encrypt)</a>
<a name="ln3424">	XFREE (MTYPE_HOST, host.enable_encrypt);</a>
<a name="ln3425">      host.enable_encrypt = XSTRDUP (MTYPE_HOST, zencrypt (argv[0]));</a>
<a name="ln3426">    }</a>
<a name="ln3427">  else</a>
<a name="ln3428">    host.enable = XSTRDUP (MTYPE_HOST, argv[0]);</a>
<a name="ln3429"> </a>
<a name="ln3430">  return CMD_SUCCESS;</a>
<a name="ln3431">}</a>
<a name="ln3432"> </a>
<a name="ln3433">ALIAS (config_enable_password,</a>
<a name="ln3434">       enable_password_text_cmd,</a>
<a name="ln3435">       &quot;enable password LINE&quot;,</a>
<a name="ln3436">       &quot;Modify enable password parameters\n&quot;</a>
<a name="ln3437">       &quot;Assign the privileged level password\n&quot;</a>
<a name="ln3438">       &quot;The UNENCRYPTED (cleartext) 'enable' password\n&quot;)</a>
<a name="ln3439"> </a>
<a name="ln3440">/* VTY enable password delete. */</a>
<a name="ln3441">DEFUN (no_config_enable_password, no_enable_password_cmd,</a>
<a name="ln3442">       &quot;no enable password&quot;,</a>
<a name="ln3443">       NO_STR</a>
<a name="ln3444">       &quot;Modify enable password parameters\n&quot;</a>
<a name="ln3445">       &quot;Assign the privileged level password\n&quot;)</a>
<a name="ln3446">{</a>
<a name="ln3447">  if (host.enable)</a>
<a name="ln3448">    XFREE (MTYPE_HOST, host.enable);</a>
<a name="ln3449">  host.enable = NULL;</a>
<a name="ln3450"> </a>
<a name="ln3451">  if (host.enable_encrypt)</a>
<a name="ln3452">    XFREE (MTYPE_HOST, host.enable_encrypt);</a>
<a name="ln3453">  host.enable_encrypt = NULL;</a>
<a name="ln3454"> </a>
<a name="ln3455">  return CMD_SUCCESS;</a>
<a name="ln3456">}</a>
<a name="ln3457">	</a>
<a name="ln3458">DEFUN (service_password_encrypt,</a>
<a name="ln3459">       service_password_encrypt_cmd,</a>
<a name="ln3460">       &quot;service password-encryption&quot;,</a>
<a name="ln3461">       &quot;Set up miscellaneous service\n&quot;</a>
<a name="ln3462">       &quot;Enable encrypted passwords\n&quot;)</a>
<a name="ln3463">{</a>
<a name="ln3464">  if (host.encrypt)</a>
<a name="ln3465">    return CMD_SUCCESS;</a>
<a name="ln3466"> </a>
<a name="ln3467">  host.encrypt = 1;</a>
<a name="ln3468"> </a>
<a name="ln3469">  if (host.password)</a>
<a name="ln3470">    {</a>
<a name="ln3471">      if (host.password_encrypt)</a>
<a name="ln3472">	XFREE (MTYPE_HOST, host.password_encrypt);</a>
<a name="ln3473">      host.password_encrypt = XSTRDUP (MTYPE_HOST, zencrypt (host.password));</a>
<a name="ln3474">    }</a>
<a name="ln3475">  if (host.enable)</a>
<a name="ln3476">    {</a>
<a name="ln3477">      if (host.enable_encrypt)</a>
<a name="ln3478">	XFREE (MTYPE_HOST, host.enable_encrypt);</a>
<a name="ln3479">      host.enable_encrypt = XSTRDUP (MTYPE_HOST, zencrypt (host.enable));</a>
<a name="ln3480">    }</a>
<a name="ln3481"> </a>
<a name="ln3482">  return CMD_SUCCESS;</a>
<a name="ln3483">}</a>
<a name="ln3484"> </a>
<a name="ln3485">DEFUN (no_service_password_encrypt,</a>
<a name="ln3486">       no_service_password_encrypt_cmd,</a>
<a name="ln3487">       &quot;no service password-encryption&quot;,</a>
<a name="ln3488">       NO_STR</a>
<a name="ln3489">       &quot;Set up miscellaneous service\n&quot;</a>
<a name="ln3490">       &quot;Enable encrypted passwords\n&quot;)</a>
<a name="ln3491">{</a>
<a name="ln3492">  if (! host.encrypt)</a>
<a name="ln3493">    return CMD_SUCCESS;</a>
<a name="ln3494"> </a>
<a name="ln3495">  host.encrypt = 0;</a>
<a name="ln3496"> </a>
<a name="ln3497">  if (host.password_encrypt)</a>
<a name="ln3498">    XFREE (MTYPE_HOST, host.password_encrypt);</a>
<a name="ln3499">  host.password_encrypt = NULL;</a>
<a name="ln3500"> </a>
<a name="ln3501">  if (host.enable_encrypt)</a>
<a name="ln3502">    XFREE (MTYPE_HOST, host.enable_encrypt);</a>
<a name="ln3503">  host.enable_encrypt = NULL;</a>
<a name="ln3504"> </a>
<a name="ln3505">  return CMD_SUCCESS;</a>
<a name="ln3506">}</a>
<a name="ln3507"> </a>
<a name="ln3508">DEFUN (config_terminal_length, config_terminal_length_cmd,</a>
<a name="ln3509">       &quot;terminal length &lt;0-512&gt;&quot;,</a>
<a name="ln3510">       &quot;Set terminal line parameters\n&quot;</a>
<a name="ln3511">       &quot;Set number of lines on a screen\n&quot;</a>
<a name="ln3512">       &quot;Number of lines on screen (0 for no pausing)\n&quot;)</a>
<a name="ln3513">{</a>
<a name="ln3514">  int lines;</a>
<a name="ln3515">  char *endptr = NULL;</a>
<a name="ln3516"> </a>
<a name="ln3517">  lines = strtol (argv[0], &amp;endptr, 10);</a>
<a name="ln3518">  if (lines &lt; 0 || lines &gt; 512 || *endptr != '\0')</a>
<a name="ln3519">    {</a>
<a name="ln3520">      vty_out (vty, &quot;length is malformed%s&quot;, VTY_NEWLINE);</a>
<a name="ln3521">      return CMD_WARNING;</a>
<a name="ln3522">    }</a>
<a name="ln3523">  vty-&gt;lines = lines;</a>
<a name="ln3524"> </a>
<a name="ln3525">  return CMD_SUCCESS;</a>
<a name="ln3526">}</a>
<a name="ln3527"> </a>
<a name="ln3528">DEFUN (config_terminal_no_length, config_terminal_no_length_cmd,</a>
<a name="ln3529">       &quot;terminal no length&quot;,</a>
<a name="ln3530">       &quot;Set terminal line parameters\n&quot;</a>
<a name="ln3531">       NO_STR</a>
<a name="ln3532">       &quot;Set number of lines on a screen\n&quot;)</a>
<a name="ln3533">{</a>
<a name="ln3534">  vty-&gt;lines = -1;</a>
<a name="ln3535">  return CMD_SUCCESS;</a>
<a name="ln3536">}</a>
<a name="ln3537"> </a>
<a name="ln3538">DEFUN (service_terminal_length, service_terminal_length_cmd,</a>
<a name="ln3539">       &quot;service terminal-length &lt;0-512&gt;&quot;,</a>
<a name="ln3540">       &quot;Set up miscellaneous service\n&quot;</a>
<a name="ln3541">       &quot;System wide terminal length configuration\n&quot;</a>
<a name="ln3542">       &quot;Number of lines of VTY (0 means no line control)\n&quot;)</a>
<a name="ln3543">{</a>
<a name="ln3544">  int lines;</a>
<a name="ln3545">  char *endptr = NULL;</a>
<a name="ln3546"> </a>
<a name="ln3547">  lines = strtol (argv[0], &amp;endptr, 10);</a>
<a name="ln3548">  if (lines &lt; 0 || lines &gt; 512 || *endptr != '\0')</a>
<a name="ln3549">    {</a>
<a name="ln3550">      vty_out (vty, &quot;length is malformed%s&quot;, VTY_NEWLINE);</a>
<a name="ln3551">      return CMD_WARNING;</a>
<a name="ln3552">    }</a>
<a name="ln3553">  host.lines = lines;</a>
<a name="ln3554"> </a>
<a name="ln3555">  return CMD_SUCCESS;</a>
<a name="ln3556">}</a>
<a name="ln3557"> </a>
<a name="ln3558">DEFUN (no_service_terminal_length, no_service_terminal_length_cmd,</a>
<a name="ln3559">       &quot;no service terminal-length [&lt;0-512&gt;]&quot;,</a>
<a name="ln3560">       NO_STR</a>
<a name="ln3561">       &quot;Set up miscellaneous service\n&quot;</a>
<a name="ln3562">       &quot;System wide terminal length configuration\n&quot;</a>
<a name="ln3563">       &quot;Number of lines of VTY (0 means no line control)\n&quot;)</a>
<a name="ln3564">{</a>
<a name="ln3565">  host.lines = -1;</a>
<a name="ln3566">  return CMD_SUCCESS;</a>
<a name="ln3567">}</a>
<a name="ln3568"> </a>
<a name="ln3569">DEFUN_HIDDEN (do_echo,</a>
<a name="ln3570">	      echo_cmd,</a>
<a name="ln3571">	      &quot;echo .MESSAGE&quot;,</a>
<a name="ln3572">	      &quot;Echo a message back to the vty\n&quot;</a>
<a name="ln3573">	      &quot;The message to echo\n&quot;)</a>
<a name="ln3574">{</a>
<a name="ln3575">  char *message;</a>
<a name="ln3576"> </a>
<a name="ln3577">  vty_out (vty, &quot;%s%s&quot;, ((message = argv_concat(argv, argc, 0)) ? message : &quot;&quot;),</a>
<a name="ln3578">	   VTY_NEWLINE);</a>
<a name="ln3579">  if (message)</a>
<a name="ln3580">    XFREE(MTYPE_TMP, message);</a>
<a name="ln3581">  return CMD_SUCCESS;</a>
<a name="ln3582">}</a>
<a name="ln3583"> </a>
<a name="ln3584">DEFUN (config_logmsg,</a>
<a name="ln3585">       config_logmsg_cmd,</a>
<a name="ln3586">       &quot;logmsg &quot;LOG_LEVELS&quot; .MESSAGE&quot;,</a>
<a name="ln3587">       &quot;Send a message to enabled logging destinations\n&quot;</a>
<a name="ln3588">       LOG_LEVEL_DESC</a>
<a name="ln3589">       &quot;The message to send\n&quot;)</a>
<a name="ln3590">{</a>
<a name="ln3591">  int level;</a>
<a name="ln3592">  char *message;</a>
<a name="ln3593"> </a>
<a name="ln3594">  if ((level = level_match(argv[0])) == ZLOG_DISABLED)</a>
<a name="ln3595">    return CMD_ERR_NO_MATCH;</a>
<a name="ln3596"> </a>
<a name="ln3597">  zlog(NULL, level, &quot;%s&quot;, ((message = argv_concat(argv, argc, 1)) ? message : &quot;&quot;));</a>
<a name="ln3598">  if (message)</a>
<a name="ln3599">    XFREE(MTYPE_TMP, message);</a>
<a name="ln3600">  return CMD_SUCCESS;</a>
<a name="ln3601">}</a>
<a name="ln3602"> </a>
<a name="ln3603">DEFUN (show_logging,</a>
<a name="ln3604">       show_logging_cmd,</a>
<a name="ln3605">       &quot;show logging&quot;,</a>
<a name="ln3606">       SHOW_STR</a>
<a name="ln3607">       &quot;Show current logging configuration\n&quot;)</a>
<a name="ln3608">{</a>
<a name="ln3609">  struct zlog *zl = zlog_default;</a>
<a name="ln3610"> </a>
<a name="ln3611">  vty_out (vty, &quot;Syslog logging: &quot;);</a>
<a name="ln3612">  if (zl-&gt;maxlvl[ZLOG_DEST_SYSLOG] == ZLOG_DISABLED)</a>
<a name="ln3613">    vty_out (vty, &quot;disabled&quot;);</a>
<a name="ln3614">  else</a>
<a name="ln3615">    vty_out (vty, &quot;level %s, facility %s, ident %s&quot;,</a>
<a name="ln3616">	     zlog_priority[zl-&gt;maxlvl[ZLOG_DEST_SYSLOG]],</a>
<a name="ln3617">	     facility_name(zl-&gt;facility), zl-&gt;ident);</a>
<a name="ln3618">  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln3619"> </a>
<a name="ln3620">  vty_out (vty, &quot;Stdout logging: &quot;);</a>
<a name="ln3621">  if (zl-&gt;maxlvl[ZLOG_DEST_STDOUT] == ZLOG_DISABLED)</a>
<a name="ln3622">    vty_out (vty, &quot;disabled&quot;);</a>
<a name="ln3623">  else</a>
<a name="ln3624">    vty_out (vty, &quot;level %s&quot;,</a>
<a name="ln3625">	     zlog_priority[zl-&gt;maxlvl[ZLOG_DEST_STDOUT]]);</a>
<a name="ln3626">  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln3627"> </a>
<a name="ln3628">  vty_out (vty, &quot;Monitor logging: &quot;);</a>
<a name="ln3629">  if (zl-&gt;maxlvl[ZLOG_DEST_MONITOR] == ZLOG_DISABLED)</a>
<a name="ln3630">    vty_out (vty, &quot;disabled&quot;);</a>
<a name="ln3631">  else</a>
<a name="ln3632">    vty_out (vty, &quot;level %s&quot;,</a>
<a name="ln3633">	     zlog_priority[zl-&gt;maxlvl[ZLOG_DEST_MONITOR]]);</a>
<a name="ln3634">  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln3635"> </a>
<a name="ln3636">  vty_out (vty, &quot;File logging: &quot;);</a>
<a name="ln3637">  if ((zl-&gt;maxlvl[ZLOG_DEST_FILE] == ZLOG_DISABLED) ||</a>
<a name="ln3638">      !zl-&gt;fp)</a>
<a name="ln3639">    vty_out (vty, &quot;disabled&quot;);</a>
<a name="ln3640">  else</a>
<a name="ln3641">    vty_out (vty, &quot;level %s, filename %s&quot;,</a>
<a name="ln3642">	     zlog_priority[zl-&gt;maxlvl[ZLOG_DEST_FILE]],</a>
<a name="ln3643">	     zl-&gt;filename);</a>
<a name="ln3644">  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln3645"> </a>
<a name="ln3646">  vty_out (vty, &quot;Protocol name: %s%s&quot;,</a>
<a name="ln3647">  	   zlog_proto_names[zl-&gt;protocol], VTY_NEWLINE);</a>
<a name="ln3648">  vty_out (vty, &quot;Record priority: %s%s&quot;,</a>
<a name="ln3649">  	   (zl-&gt;record_priority ? &quot;enabled&quot; : &quot;disabled&quot;), VTY_NEWLINE);</a>
<a name="ln3650">  vty_out (vty, &quot;Timestamp precision: %d%s&quot;,</a>
<a name="ln3651">	   zl-&gt;timestamp_precision, VTY_NEWLINE);</a>
<a name="ln3652"> </a>
<a name="ln3653">  return CMD_SUCCESS;</a>
<a name="ln3654">}</a>
<a name="ln3655"> </a>
<a name="ln3656">DEFUN (config_log_stdout,</a>
<a name="ln3657">       config_log_stdout_cmd,</a>
<a name="ln3658">       &quot;log stdout&quot;,</a>
<a name="ln3659">       &quot;Logging control\n&quot;</a>
<a name="ln3660">       &quot;Set stdout logging level\n&quot;)</a>
<a name="ln3661">{</a>
<a name="ln3662">  zlog_set_level (NULL, ZLOG_DEST_STDOUT, zlog_default-&gt;default_lvl);</a>
<a name="ln3663">  return CMD_SUCCESS;</a>
<a name="ln3664">}</a>
<a name="ln3665"> </a>
<a name="ln3666">DEFUN (config_log_stdout_level,</a>
<a name="ln3667">       config_log_stdout_level_cmd,</a>
<a name="ln3668">       &quot;log stdout &quot;LOG_LEVELS,</a>
<a name="ln3669">       &quot;Logging control\n&quot;</a>
<a name="ln3670">       &quot;Set stdout logging level\n&quot;</a>
<a name="ln3671">       LOG_LEVEL_DESC)</a>
<a name="ln3672">{</a>
<a name="ln3673">  int level;</a>
<a name="ln3674"> </a>
<a name="ln3675">  if ((level = level_match(argv[0])) == ZLOG_DISABLED)</a>
<a name="ln3676">    return CMD_ERR_NO_MATCH;</a>
<a name="ln3677">  zlog_set_level (NULL, ZLOG_DEST_STDOUT, level);</a>
<a name="ln3678">  return CMD_SUCCESS;</a>
<a name="ln3679">}</a>
<a name="ln3680"> </a>
<a name="ln3681">DEFUN (no_config_log_stdout,</a>
<a name="ln3682">       no_config_log_stdout_cmd,</a>
<a name="ln3683">       &quot;no log stdout [LEVEL]&quot;,</a>
<a name="ln3684">       NO_STR</a>
<a name="ln3685">       &quot;Logging control\n&quot;</a>
<a name="ln3686">       &quot;Cancel logging to stdout\n&quot;</a>
<a name="ln3687">       &quot;Logging level\n&quot;)</a>
<a name="ln3688">{</a>
<a name="ln3689">  zlog_set_level (NULL, ZLOG_DEST_STDOUT, ZLOG_DISABLED);</a>
<a name="ln3690">  return CMD_SUCCESS;</a>
<a name="ln3691">}</a>
<a name="ln3692"> </a>
<a name="ln3693">DEFUN (config_log_monitor,</a>
<a name="ln3694">       config_log_monitor_cmd,</a>
<a name="ln3695">       &quot;log monitor&quot;,</a>
<a name="ln3696">       &quot;Logging control\n&quot;</a>
<a name="ln3697">       &quot;Set terminal line (monitor) logging level\n&quot;)</a>
<a name="ln3698">{</a>
<a name="ln3699">  zlog_set_level (NULL, ZLOG_DEST_MONITOR, zlog_default-&gt;default_lvl);</a>
<a name="ln3700">  return CMD_SUCCESS;</a>
<a name="ln3701">}</a>
<a name="ln3702"> </a>
<a name="ln3703">DEFUN (config_log_monitor_level,</a>
<a name="ln3704">       config_log_monitor_level_cmd,</a>
<a name="ln3705">       &quot;log monitor &quot;LOG_LEVELS,</a>
<a name="ln3706">       &quot;Logging control\n&quot;</a>
<a name="ln3707">       &quot;Set terminal line (monitor) logging level\n&quot;</a>
<a name="ln3708">       LOG_LEVEL_DESC)</a>
<a name="ln3709">{</a>
<a name="ln3710">  int level;</a>
<a name="ln3711"> </a>
<a name="ln3712">  if ((level = level_match(argv[0])) == ZLOG_DISABLED)</a>
<a name="ln3713">    return CMD_ERR_NO_MATCH;</a>
<a name="ln3714">  zlog_set_level (NULL, ZLOG_DEST_MONITOR, level);</a>
<a name="ln3715">  return CMD_SUCCESS;</a>
<a name="ln3716">}</a>
<a name="ln3717"> </a>
<a name="ln3718">DEFUN (no_config_log_monitor,</a>
<a name="ln3719">       no_config_log_monitor_cmd,</a>
<a name="ln3720">       &quot;no log monitor [LEVEL]&quot;,</a>
<a name="ln3721">       NO_STR</a>
<a name="ln3722">       &quot;Logging control\n&quot;</a>
<a name="ln3723">       &quot;Disable terminal line (monitor) logging\n&quot;</a>
<a name="ln3724">       &quot;Logging level\n&quot;)</a>
<a name="ln3725">{</a>
<a name="ln3726">  zlog_set_level (NULL, ZLOG_DEST_MONITOR, ZLOG_DISABLED);</a>
<a name="ln3727">  return CMD_SUCCESS;</a>
<a name="ln3728">}</a>
<a name="ln3729"> </a>
<a name="ln3730">static int</a>
<a name="ln3731">set_log_file(struct vty *vty, const char *fname, int loglevel)</a>
<a name="ln3732">{</a>
<a name="ln3733">  int ret;</a>
<a name="ln3734">  char *p = NULL;</a>
<a name="ln3735">  const char *fullpath;</a>
<a name="ln3736">  </a>
<a name="ln3737">  /* Path detection. */</a>
<a name="ln3738">  if (! IS_DIRECTORY_SEP (*fname))</a>
<a name="ln3739">    {</a>
<a name="ln3740">      char cwd[MAXPATHLEN+1];</a>
<a name="ln3741">      cwd[MAXPATHLEN] = '\0';</a>
<a name="ln3742">      </a>
<a name="ln3743">      if (getcwd (cwd, MAXPATHLEN) == NULL)</a>
<a name="ln3744">        {</a>
<a name="ln3745">          zlog_err (&quot;config_log_file: Unable to alloc mem!&quot;);</a>
<a name="ln3746">          return CMD_WARNING;</a>
<a name="ln3747">        }</a>
<a name="ln3748">      </a>
<a name="ln3749">      if ( (p = XMALLOC (MTYPE_TMP, strlen (cwd) + strlen (fname) + 2))</a>
<a name="ln3750">          == NULL)</a>
<a name="ln3751">        {</a>
<a name="ln3752">          zlog_err (&quot;config_log_file: Unable to alloc mem!&quot;);</a>
<a name="ln3753">          return CMD_WARNING;</a>
<a name="ln3754">        }</a>
<a name="ln3755">      sprintf (p, &quot;%s/%s&quot;, cwd, fname);</a>
<a name="ln3756">      fullpath = p;</a>
<a name="ln3757">    }</a>
<a name="ln3758">  else</a>
<a name="ln3759">    fullpath = fname;</a>
<a name="ln3760"> </a>
<a name="ln3761">  ret = zlog_set_file (NULL, fullpath, loglevel);</a>
<a name="ln3762"> </a>
<a name="ln3763">  if (p)</a>
<a name="ln3764">    XFREE (MTYPE_TMP, p);</a>
<a name="ln3765"> </a>
<a name="ln3766">  if (!ret)</a>
<a name="ln3767">    {</a>
<a name="ln3768">      vty_out (vty, &quot;can't open logfile %s\n&quot;, fname);</a>
<a name="ln3769">      return CMD_WARNING;</a>
<a name="ln3770">    }</a>
<a name="ln3771"> </a>
<a name="ln3772">  if (host.logfile)</a>
<a name="ln3773">    XFREE (MTYPE_HOST, host.logfile);</a>
<a name="ln3774"> </a>
<a name="ln3775">  host.logfile = XSTRDUP (MTYPE_HOST, fname);</a>
<a name="ln3776"> </a>
<a name="ln3777">  return CMD_SUCCESS;</a>
<a name="ln3778">}</a>
<a name="ln3779"> </a>
<a name="ln3780">DEFUN (config_log_file,</a>
<a name="ln3781">       config_log_file_cmd,</a>
<a name="ln3782">       &quot;log file FILENAME&quot;,</a>
<a name="ln3783">       &quot;Logging control\n&quot;</a>
<a name="ln3784">       &quot;Logging to file\n&quot;</a>
<a name="ln3785">       &quot;Logging filename\n&quot;)</a>
<a name="ln3786">{</a>
<a name="ln3787">  return set_log_file(vty, argv[0], zlog_default-&gt;default_lvl);</a>
<a name="ln3788">}</a>
<a name="ln3789"> </a>
<a name="ln3790">DEFUN (config_log_file_level,</a>
<a name="ln3791">       config_log_file_level_cmd,</a>
<a name="ln3792">       &quot;log file FILENAME &quot;LOG_LEVELS,</a>
<a name="ln3793">       &quot;Logging control\n&quot;</a>
<a name="ln3794">       &quot;Logging to file\n&quot;</a>
<a name="ln3795">       &quot;Logging filename\n&quot;</a>
<a name="ln3796">       LOG_LEVEL_DESC)</a>
<a name="ln3797">{</a>
<a name="ln3798">  int level;</a>
<a name="ln3799"> </a>
<a name="ln3800">  if ((level = level_match(argv[1])) == ZLOG_DISABLED)</a>
<a name="ln3801">    return CMD_ERR_NO_MATCH;</a>
<a name="ln3802">  return set_log_file(vty, argv[0], level);</a>
<a name="ln3803">}</a>
<a name="ln3804"> </a>
<a name="ln3805">DEFUN (no_config_log_file,</a>
<a name="ln3806">       no_config_log_file_cmd,</a>
<a name="ln3807">       &quot;no log file [FILENAME]&quot;,</a>
<a name="ln3808">       NO_STR</a>
<a name="ln3809">       &quot;Logging control\n&quot;</a>
<a name="ln3810">       &quot;Cancel logging to file\n&quot;</a>
<a name="ln3811">       &quot;Logging file name\n&quot;)</a>
<a name="ln3812">{</a>
<a name="ln3813">  zlog_reset_file (NULL);</a>
<a name="ln3814"> </a>
<a name="ln3815">  if (host.logfile)</a>
<a name="ln3816">    XFREE (MTYPE_HOST, host.logfile);</a>
<a name="ln3817"> </a>
<a name="ln3818">  host.logfile = NULL;</a>
<a name="ln3819"> </a>
<a name="ln3820">  return CMD_SUCCESS;</a>
<a name="ln3821">}</a>
<a name="ln3822"> </a>
<a name="ln3823">ALIAS (no_config_log_file,</a>
<a name="ln3824">       no_config_log_file_level_cmd,</a>
<a name="ln3825">       &quot;no log file FILENAME LEVEL&quot;,</a>
<a name="ln3826">       NO_STR</a>
<a name="ln3827">       &quot;Logging control\n&quot;</a>
<a name="ln3828">       &quot;Cancel logging to file\n&quot;</a>
<a name="ln3829">       &quot;Logging file name\n&quot;</a>
<a name="ln3830">       &quot;Logging level\n&quot;)</a>
<a name="ln3831"> </a>
<a name="ln3832">DEFUN (config_log_syslog,</a>
<a name="ln3833">       config_log_syslog_cmd,</a>
<a name="ln3834">       &quot;log syslog&quot;,</a>
<a name="ln3835">       &quot;Logging control\n&quot;</a>
<a name="ln3836">       &quot;Set syslog logging level\n&quot;)</a>
<a name="ln3837">{</a>
<a name="ln3838">  zlog_set_level (NULL, ZLOG_DEST_SYSLOG, zlog_default-&gt;default_lvl);</a>
<a name="ln3839">  return CMD_SUCCESS;</a>
<a name="ln3840">}</a>
<a name="ln3841"> </a>
<a name="ln3842">DEFUN (config_log_syslog_level,</a>
<a name="ln3843">       config_log_syslog_level_cmd,</a>
<a name="ln3844">       &quot;log syslog &quot;LOG_LEVELS,</a>
<a name="ln3845">       &quot;Logging control\n&quot;</a>
<a name="ln3846">       &quot;Set syslog logging level\n&quot;</a>
<a name="ln3847">       LOG_LEVEL_DESC)</a>
<a name="ln3848">{</a>
<a name="ln3849">  int level;</a>
<a name="ln3850"> </a>
<a name="ln3851">  if ((level = level_match(argv[0])) == ZLOG_DISABLED)</a>
<a name="ln3852">    return CMD_ERR_NO_MATCH;</a>
<a name="ln3853">  zlog_set_level (NULL, ZLOG_DEST_SYSLOG, level);</a>
<a name="ln3854">  return CMD_SUCCESS;</a>
<a name="ln3855">}</a>
<a name="ln3856"> </a>
<a name="ln3857">DEFUN_DEPRECATED (config_log_syslog_facility,</a>
<a name="ln3858">		  config_log_syslog_facility_cmd,</a>
<a name="ln3859">		  &quot;log syslog facility &quot;LOG_FACILITIES,</a>
<a name="ln3860">		  &quot;Logging control\n&quot;</a>
<a name="ln3861">		  &quot;Logging goes to syslog\n&quot;</a>
<a name="ln3862">		  &quot;(Deprecated) Facility parameter for syslog messages\n&quot;</a>
<a name="ln3863">		  LOG_FACILITY_DESC)</a>
<a name="ln3864">{</a>
<a name="ln3865">  int facility;</a>
<a name="ln3866"> </a>
<a name="ln3867">  if ((facility = facility_match(argv[0])) &lt; 0)</a>
<a name="ln3868">    return CMD_ERR_NO_MATCH;</a>
<a name="ln3869"> </a>
<a name="ln3870">  zlog_set_level (NULL, ZLOG_DEST_SYSLOG, zlog_default-&gt;default_lvl);</a>
<a name="ln3871">  zlog_default-&gt;facility = facility;</a>
<a name="ln3872">  return CMD_SUCCESS;</a>
<a name="ln3873">}</a>
<a name="ln3874"> </a>
<a name="ln3875">DEFUN (no_config_log_syslog,</a>
<a name="ln3876">       no_config_log_syslog_cmd,</a>
<a name="ln3877">       &quot;no log syslog [LEVEL]&quot;,</a>
<a name="ln3878">       NO_STR</a>
<a name="ln3879">       &quot;Logging control\n&quot;</a>
<a name="ln3880">       &quot;Cancel logging to syslog\n&quot;</a>
<a name="ln3881">       &quot;Logging level\n&quot;)</a>
<a name="ln3882">{</a>
<a name="ln3883">  zlog_set_level (NULL, ZLOG_DEST_SYSLOG, ZLOG_DISABLED);</a>
<a name="ln3884">  return CMD_SUCCESS;</a>
<a name="ln3885">}</a>
<a name="ln3886"> </a>
<a name="ln3887">ALIAS (no_config_log_syslog,</a>
<a name="ln3888">       no_config_log_syslog_facility_cmd,</a>
<a name="ln3889">       &quot;no log syslog facility &quot;LOG_FACILITIES,</a>
<a name="ln3890">       NO_STR</a>
<a name="ln3891">       &quot;Logging control\n&quot;</a>
<a name="ln3892">       &quot;Logging goes to syslog\n&quot;</a>
<a name="ln3893">       &quot;Facility parameter for syslog messages\n&quot;</a>
<a name="ln3894">       LOG_FACILITY_DESC)</a>
<a name="ln3895"> </a>
<a name="ln3896">DEFUN (config_log_facility,</a>
<a name="ln3897">       config_log_facility_cmd,</a>
<a name="ln3898">       &quot;log facility &quot;LOG_FACILITIES,</a>
<a name="ln3899">       &quot;Logging control\n&quot;</a>
<a name="ln3900">       &quot;Facility parameter for syslog messages\n&quot;</a>
<a name="ln3901">       LOG_FACILITY_DESC)</a>
<a name="ln3902">{</a>
<a name="ln3903">  int facility;</a>
<a name="ln3904"> </a>
<a name="ln3905">  if ((facility = facility_match(argv[0])) &lt; 0)</a>
<a name="ln3906">    return CMD_ERR_NO_MATCH;</a>
<a name="ln3907">  zlog_default-&gt;facility = facility;</a>
<a name="ln3908">  return CMD_SUCCESS;</a>
<a name="ln3909">}</a>
<a name="ln3910"> </a>
<a name="ln3911">DEFUN (no_config_log_facility,</a>
<a name="ln3912">       no_config_log_facility_cmd,</a>
<a name="ln3913">       &quot;no log facility [FACILITY]&quot;,</a>
<a name="ln3914">       NO_STR</a>
<a name="ln3915">       &quot;Logging control\n&quot;</a>
<a name="ln3916">       &quot;Reset syslog facility to default (daemon)\n&quot;</a>
<a name="ln3917">       &quot;Syslog facility\n&quot;)</a>
<a name="ln3918">{</a>
<a name="ln3919">  zlog_default-&gt;facility = LOG_DAEMON;</a>
<a name="ln3920">  return CMD_SUCCESS;</a>
<a name="ln3921">}</a>
<a name="ln3922"> </a>
<a name="ln3923">DEFUN_DEPRECATED (config_log_trap,</a>
<a name="ln3924">		  config_log_trap_cmd,</a>
<a name="ln3925">		  &quot;log trap &quot;LOG_LEVELS,</a>
<a name="ln3926">		  &quot;Logging control\n&quot;</a>
<a name="ln3927">		  &quot;(Deprecated) Set logging level and default for all destinations\n&quot;</a>
<a name="ln3928">		  LOG_LEVEL_DESC)</a>
<a name="ln3929">{</a>
<a name="ln3930">  int new_level ;</a>
<a name="ln3931">  int i;</a>
<a name="ln3932">  </a>
<a name="ln3933">  if ((new_level = level_match(argv[0])) == ZLOG_DISABLED)</a>
<a name="ln3934">    return CMD_ERR_NO_MATCH;</a>
<a name="ln3935"> </a>
<a name="ln3936">  zlog_default-&gt;default_lvl = new_level;</a>
<a name="ln3937">  for (i = 0; i &lt; ZLOG_NUM_DESTS; i++)</a>
<a name="ln3938">    if (zlog_default-&gt;maxlvl[i] != ZLOG_DISABLED)</a>
<a name="ln3939">      zlog_default-&gt;maxlvl[i] = new_level;</a>
<a name="ln3940">  return CMD_SUCCESS;</a>
<a name="ln3941">}</a>
<a name="ln3942"> </a>
<a name="ln3943">DEFUN_DEPRECATED (no_config_log_trap,</a>
<a name="ln3944">		  no_config_log_trap_cmd,</a>
<a name="ln3945">		  &quot;no log trap [LEVEL]&quot;,</a>
<a name="ln3946">		  NO_STR</a>
<a name="ln3947">		  &quot;Logging control\n&quot;</a>
<a name="ln3948">		  &quot;Permit all logging information\n&quot;</a>
<a name="ln3949">		  &quot;Logging level\n&quot;)</a>
<a name="ln3950">{</a>
<a name="ln3951">  zlog_default-&gt;default_lvl = LOG_DEBUG;</a>
<a name="ln3952">  return CMD_SUCCESS;</a>
<a name="ln3953">}</a>
<a name="ln3954"> </a>
<a name="ln3955">DEFUN (config_log_record_priority,</a>
<a name="ln3956">       config_log_record_priority_cmd,</a>
<a name="ln3957">       &quot;log record-priority&quot;,</a>
<a name="ln3958">       &quot;Logging control\n&quot;</a>
<a name="ln3959">       &quot;Log the priority of the message within the message\n&quot;)</a>
<a name="ln3960">{</a>
<a name="ln3961">  zlog_default-&gt;record_priority = 1 ;</a>
<a name="ln3962">  return CMD_SUCCESS;</a>
<a name="ln3963">}</a>
<a name="ln3964"> </a>
<a name="ln3965">DEFUN (no_config_log_record_priority,</a>
<a name="ln3966">       no_config_log_record_priority_cmd,</a>
<a name="ln3967">       &quot;no log record-priority&quot;,</a>
<a name="ln3968">       NO_STR</a>
<a name="ln3969">       &quot;Logging control\n&quot;</a>
<a name="ln3970">       &quot;Do not log the priority of the message within the message\n&quot;)</a>
<a name="ln3971">{</a>
<a name="ln3972">  zlog_default-&gt;record_priority = 0 ;</a>
<a name="ln3973">  return CMD_SUCCESS;</a>
<a name="ln3974">}</a>
<a name="ln3975"> </a>
<a name="ln3976">DEFUN (config_log_timestamp_precision,</a>
<a name="ln3977">       config_log_timestamp_precision_cmd,</a>
<a name="ln3978">       &quot;log timestamp precision &lt;0-6&gt;&quot;,</a>
<a name="ln3979">       &quot;Logging control\n&quot;</a>
<a name="ln3980">       &quot;Timestamp configuration\n&quot;</a>
<a name="ln3981">       &quot;Set the timestamp precision\n&quot;</a>
<a name="ln3982">       &quot;Number of subsecond digits\n&quot;)</a>
<a name="ln3983">{</a>
<a name="ln3984">  if (argc != 1)</a>
<a name="ln3985">    {</a>
<a name="ln3986">      vty_out (vty, &quot;Insufficient arguments%s&quot;, VTY_NEWLINE);</a>
<a name="ln3987">      return CMD_WARNING;</a>
<a name="ln3988">    }</a>
<a name="ln3989"> </a>
<a name="ln3990">  VTY_GET_INTEGER_RANGE(&quot;Timestamp Precision&quot;,</a>
<a name="ln3991">  			zlog_default-&gt;timestamp_precision, argv[0], 0, 6);</a>
<a name="ln3992">  return CMD_SUCCESS;</a>
<a name="ln3993">}</a>
<a name="ln3994"> </a>
<a name="ln3995">DEFUN (no_config_log_timestamp_precision,</a>
<a name="ln3996">       no_config_log_timestamp_precision_cmd,</a>
<a name="ln3997">       &quot;no log timestamp precision&quot;,</a>
<a name="ln3998">       NO_STR</a>
<a name="ln3999">       &quot;Logging control\n&quot;</a>
<a name="ln4000">       &quot;Timestamp configuration\n&quot;</a>
<a name="ln4001">       &quot;Reset the timestamp precision to the default value of 0\n&quot;)</a>
<a name="ln4002">{</a>
<a name="ln4003">  zlog_default-&gt;timestamp_precision = 0 ;</a>
<a name="ln4004">  return CMD_SUCCESS;</a>
<a name="ln4005">}</a>
<a name="ln4006"> </a>
<a name="ln4007">DEFUN (banner_motd_file,</a>
<a name="ln4008">       banner_motd_file_cmd,</a>
<a name="ln4009">       &quot;banner motd file [FILE]&quot;,</a>
<a name="ln4010">       &quot;Set banner\n&quot;</a>
<a name="ln4011">       &quot;Banner for motd\n&quot;</a>
<a name="ln4012">       &quot;Banner from a file\n&quot;</a>
<a name="ln4013">       &quot;Filename\n&quot;)</a>
<a name="ln4014">{</a>
<a name="ln4015">  if (host.motdfile)</a>
<a name="ln4016">    XFREE (MTYPE_HOST, host.motdfile);</a>
<a name="ln4017">  host.motdfile = XSTRDUP (MTYPE_HOST, argv[0]);</a>
<a name="ln4018"> </a>
<a name="ln4019">  return CMD_SUCCESS;</a>
<a name="ln4020">}</a>
<a name="ln4021"> </a>
<a name="ln4022">DEFUN (banner_motd_default,</a>
<a name="ln4023">       banner_motd_default_cmd,</a>
<a name="ln4024">       &quot;banner motd default&quot;,</a>
<a name="ln4025">       &quot;Set banner string\n&quot;</a>
<a name="ln4026">       &quot;Strings for motd\n&quot;</a>
<a name="ln4027">       &quot;Default string\n&quot;)</a>
<a name="ln4028">{</a>
<a name="ln4029">  host.motd = default_motd;</a>
<a name="ln4030">  return CMD_SUCCESS;</a>
<a name="ln4031">}</a>
<a name="ln4032"> </a>
<a name="ln4033">DEFUN (no_banner_motd,</a>
<a name="ln4034">       no_banner_motd_cmd,</a>
<a name="ln4035">       &quot;no banner motd&quot;,</a>
<a name="ln4036">       NO_STR</a>
<a name="ln4037">       &quot;Set banner string\n&quot;</a>
<a name="ln4038">       &quot;Strings for motd\n&quot;)</a>
<a name="ln4039">{</a>
<a name="ln4040">  host.motd = NULL;</a>
<a name="ln4041">  if (host.motdfile) </a>
<a name="ln4042">    XFREE (MTYPE_HOST, host.motdfile);</a>
<a name="ln4043">  host.motdfile = NULL;</a>
<a name="ln4044">  return CMD_SUCCESS;</a>
<a name="ln4045">}</a>
<a name="ln4046"> </a>
<a name="ln4047">DEFUN (show_commandtree,</a>
<a name="ln4048">       show_commandtree_cmd,</a>
<a name="ln4049">       &quot;show commandtree&quot;,</a>
<a name="ln4050">       NO_STR</a>
<a name="ln4051">       &quot;Show command tree\n&quot;)</a>
<a name="ln4052">{</a>
<a name="ln4053">  /* TBD */</a>
<a name="ln4054">  vector cmd_vector;</a>
<a name="ln4055">  unsigned int i;</a>
<a name="ln4056"> </a>
<a name="ln4057">  vty_out (vty, &quot;Current node id: %d%s&quot;, vty-&gt;node, VTY_NEWLINE);</a>
<a name="ln4058"> </a>
<a name="ln4059">  /* vector of all commands installed at this node */</a>
<a name="ln4060">  cmd_vector = vector_copy (cmd_node_vector (cmdvec, vty-&gt;node));</a>
<a name="ln4061"> </a>
<a name="ln4062">  /* loop over all commands at this node */</a>
<a name="ln4063">  for (i = 0; i &lt; vector_active(cmd_vector); ++i)</a>
<a name="ln4064">    {</a>
<a name="ln4065">      struct cmd_element *cmd_element;</a>
<a name="ln4066"> </a>
<a name="ln4067">      /* A cmd_element (seems to be) is an individual command */</a>
<a name="ln4068">      if ((cmd_element = vector_slot (cmd_vector, i)) == NULL)</a>
<a name="ln4069">        continue;</a>
<a name="ln4070"> </a>
<a name="ln4071">      vty_out (vty, &quot;    %s%s&quot;, cmd_element-&gt;string, VTY_NEWLINE);</a>
<a name="ln4072">    }</a>
<a name="ln4073"> </a>
<a name="ln4074">  vector_free (cmd_vector);</a>
<a name="ln4075">  return CMD_SUCCESS;</a>
<a name="ln4076">}</a>
<a name="ln4077"> </a>
<a name="ln4078">/* Set config filename.  Called from vty.c */</a>
<a name="ln4079">void</a>
<a name="ln4080">host_config_set (char *filename)</a>
<a name="ln4081">{</a>
<a name="ln4082">  if (host.config)</a>
<a name="ln4083">    XFREE (MTYPE_HOST, host.config);</a>
<a name="ln4084">  host.config = XSTRDUP (MTYPE_HOST, filename);</a>
<a name="ln4085">}</a>
<a name="ln4086"> </a>
<a name="ln4087">const char *</a>
<a name="ln4088">host_config_get (void)</a>
<a name="ln4089">{</a>
<a name="ln4090">  return host.config;</a>
<a name="ln4091">}</a>
<a name="ln4092"> </a>
<a name="ln4093">static void</a>
<a name="ln4094">install_default_basic (enum node_type node)</a>
<a name="ln4095">{</a>
<a name="ln4096">  install_element (node, &amp;config_exit_cmd);</a>
<a name="ln4097">  install_element (node, &amp;config_quit_cmd);</a>
<a name="ln4098">  install_element (node, &amp;config_help_cmd);</a>
<a name="ln4099">  install_element (node, &amp;config_list_cmd);</a>
<a name="ln4100">}</a>
<a name="ln4101"> </a>
<a name="ln4102">/* Install common/default commands for a privileged node */</a>
<a name="ln4103">void</a>
<a name="ln4104">install_default (enum node_type node)</a>
<a name="ln4105">{</a>
<a name="ln4106">  /* VIEW_NODE is inited below, via install_default_basic, and</a>
<a name="ln4107">     install_element's of commands to VIEW_NODE automatically are</a>
<a name="ln4108">     also installed to ENABLE_NODE.</a>
<a name="ln4109">    </a>
<a name="ln4110">     For all other nodes, we must ensure install_default_basic is</a>
<a name="ln4111">     also called/</a>
<a name="ln4112">   */</a>
<a name="ln4113">  if (node != VIEW_NODE &amp;&amp; node != ENABLE_NODE)</a>
<a name="ln4114">    install_default_basic (node);</a>
<a name="ln4115">  </a>
<a name="ln4116">  install_element (node, &amp;config_end_cmd);</a>
<a name="ln4117">  install_element (node, &amp;config_write_terminal_cmd);</a>
<a name="ln4118">  install_element (node, &amp;config_write_file_cmd);</a>
<a name="ln4119">  install_element (node, &amp;config_write_memory_cmd);</a>
<a name="ln4120">  install_element (node, &amp;config_write_cmd);</a>
<a name="ln4121">  install_element (node, &amp;show_running_config_cmd);</a>
<a name="ln4122">}</a>
<a name="ln4123"> </a>
<a name="ln4124">/* Initialize command interface. Install basic nodes and commands. */</a>
<a name="ln4125">void</a>
<a name="ln4126">cmd_init (int terminal)</a>
<a name="ln4127">{</a>
<a name="ln4128">  command_cr = XSTRDUP(MTYPE_CMD_TOKENS, &quot;&lt;cr&gt;&quot;);</a>
<a name="ln4129">  token_cr.type = TOKEN_TERMINAL;</a>
<a name="ln4130">  token_cr.terminal = TERMINAL_LITERAL;</a>
<a name="ln4131">  token_cr.cmd = command_cr;</a>
<a name="ln4132">  token_cr.desc = XSTRDUP(MTYPE_CMD_TOKENS, &quot;&quot;);</a>
<a name="ln4133"> </a>
<a name="ln4134">  /* Allocate initial top vector of commands. */</a>
<a name="ln4135">  cmdvec = vector_init (VECTOR_MIN_SIZE);</a>
<a name="ln4136">  </a>
<a name="ln4137">  /* Default host value settings. */</a>
<a name="ln4138">  host.name = NULL;</a>
<a name="ln4139">  host.password = NULL;</a>
<a name="ln4140">  host.enable = NULL;</a>
<a name="ln4141">  host.logfile = NULL;</a>
<a name="ln4142">  host.config = NULL;</a>
<a name="ln4143">  host.lines = -1;</a>
<a name="ln4144">  host.motd = default_motd;</a>
<a name="ln4145">  host.motdfile = NULL;</a>
<a name="ln4146"> </a>
<a name="ln4147">  /* Install top nodes. */</a>
<a name="ln4148">  install_node (&amp;view_node, NULL);</a>
<a name="ln4149">  install_node (&amp;enable_node, NULL);</a>
<a name="ln4150">  install_node (&amp;auth_node, NULL);</a>
<a name="ln4151">  install_node (&amp;auth_enable_node, NULL);</a>
<a name="ln4152">  install_node (&amp;restricted_node, NULL);</a>
<a name="ln4153">  install_node (&amp;config_node, config_write_host);</a>
<a name="ln4154"> </a>
<a name="ln4155">  /* Each node's basic commands. */</a>
<a name="ln4156">  install_element (VIEW_NODE, &amp;show_version_cmd);</a>
<a name="ln4157">  if (terminal)</a>
<a name="ln4158">    {</a>
<a name="ln4159">      install_default_basic (VIEW_NODE);</a>
<a name="ln4160">      </a>
<a name="ln4161">      install_element (VIEW_NODE, &amp;config_enable_cmd);</a>
<a name="ln4162">      install_element (VIEW_NODE, &amp;config_terminal_length_cmd);</a>
<a name="ln4163">      install_element (VIEW_NODE, &amp;config_terminal_no_length_cmd);</a>
<a name="ln4164">      install_element (VIEW_NODE, &amp;show_logging_cmd);</a>
<a name="ln4165">      install_element (VIEW_NODE, &amp;show_commandtree_cmd);</a>
<a name="ln4166">      install_element (VIEW_NODE, &amp;echo_cmd);</a>
<a name="ln4167"> </a>
<a name="ln4168">      install_element (RESTRICTED_NODE, &amp;config_enable_cmd);</a>
<a name="ln4169">      install_element (RESTRICTED_NODE, &amp;config_terminal_length_cmd);</a>
<a name="ln4170">      install_element (RESTRICTED_NODE, &amp;config_terminal_no_length_cmd);</a>
<a name="ln4171">      install_element (RESTRICTED_NODE, &amp;show_commandtree_cmd);</a>
<a name="ln4172">      install_element (RESTRICTED_NODE, &amp;echo_cmd);</a>
<a name="ln4173">    }</a>
<a name="ln4174"> </a>
<a name="ln4175">  if (terminal)</a>
<a name="ln4176">    {</a>
<a name="ln4177">      install_default (ENABLE_NODE);</a>
<a name="ln4178">      install_element (ENABLE_NODE, &amp;config_disable_cmd);</a>
<a name="ln4179">      install_element (ENABLE_NODE, &amp;config_terminal_cmd);</a>
<a name="ln4180">      install_element (ENABLE_NODE, &amp;copy_runningconfig_startupconfig_cmd);</a>
<a name="ln4181">    }</a>
<a name="ln4182">  install_element (ENABLE_NODE, &amp;show_startup_config_cmd);</a>
<a name="ln4183"> </a>
<a name="ln4184">  if (terminal)</a>
<a name="ln4185">    {</a>
<a name="ln4186">      install_element (ENABLE_NODE, &amp;config_logmsg_cmd);</a>
<a name="ln4187"> </a>
<a name="ln4188">      install_default (CONFIG_NODE);</a>
<a name="ln4189">    }</a>
<a name="ln4190">  </a>
<a name="ln4191">  install_element (CONFIG_NODE, &amp;hostname_cmd);</a>
<a name="ln4192">  install_element (CONFIG_NODE, &amp;no_hostname_cmd);</a>
<a name="ln4193"> </a>
<a name="ln4194">  if (terminal)</a>
<a name="ln4195">    {</a>
<a name="ln4196">      install_element (CONFIG_NODE, &amp;password_cmd);</a>
<a name="ln4197">      install_element (CONFIG_NODE, &amp;password_text_cmd);</a>
<a name="ln4198">      install_element (CONFIG_NODE, &amp;enable_password_cmd);</a>
<a name="ln4199">      install_element (CONFIG_NODE, &amp;enable_password_text_cmd);</a>
<a name="ln4200">      install_element (CONFIG_NODE, &amp;no_enable_password_cmd);</a>
<a name="ln4201"> </a>
<a name="ln4202">      install_element (CONFIG_NODE, &amp;config_log_stdout_cmd);</a>
<a name="ln4203">      install_element (CONFIG_NODE, &amp;config_log_stdout_level_cmd);</a>
<a name="ln4204">      install_element (CONFIG_NODE, &amp;no_config_log_stdout_cmd);</a>
<a name="ln4205">      install_element (CONFIG_NODE, &amp;config_log_monitor_cmd);</a>
<a name="ln4206">      install_element (CONFIG_NODE, &amp;config_log_monitor_level_cmd);</a>
<a name="ln4207">      install_element (CONFIG_NODE, &amp;no_config_log_monitor_cmd);</a>
<a name="ln4208">      install_element (CONFIG_NODE, &amp;config_log_file_cmd);</a>
<a name="ln4209">      install_element (CONFIG_NODE, &amp;config_log_file_level_cmd);</a>
<a name="ln4210">      install_element (CONFIG_NODE, &amp;no_config_log_file_cmd);</a>
<a name="ln4211">      install_element (CONFIG_NODE, &amp;no_config_log_file_level_cmd);</a>
<a name="ln4212">      install_element (CONFIG_NODE, &amp;config_log_syslog_cmd);</a>
<a name="ln4213">      install_element (CONFIG_NODE, &amp;config_log_syslog_level_cmd);</a>
<a name="ln4214">      install_element (CONFIG_NODE, &amp;config_log_syslog_facility_cmd);</a>
<a name="ln4215">      install_element (CONFIG_NODE, &amp;no_config_log_syslog_cmd);</a>
<a name="ln4216">      install_element (CONFIG_NODE, &amp;no_config_log_syslog_facility_cmd);</a>
<a name="ln4217">      install_element (CONFIG_NODE, &amp;config_log_facility_cmd);</a>
<a name="ln4218">      install_element (CONFIG_NODE, &amp;no_config_log_facility_cmd);</a>
<a name="ln4219">      install_element (CONFIG_NODE, &amp;config_log_trap_cmd);</a>
<a name="ln4220">      install_element (CONFIG_NODE, &amp;no_config_log_trap_cmd);</a>
<a name="ln4221">      install_element (CONFIG_NODE, &amp;config_log_record_priority_cmd);</a>
<a name="ln4222">      install_element (CONFIG_NODE, &amp;no_config_log_record_priority_cmd);</a>
<a name="ln4223">      install_element (CONFIG_NODE, &amp;config_log_timestamp_precision_cmd);</a>
<a name="ln4224">      install_element (CONFIG_NODE, &amp;no_config_log_timestamp_precision_cmd);</a>
<a name="ln4225">      install_element (CONFIG_NODE, &amp;service_password_encrypt_cmd);</a>
<a name="ln4226">      install_element (CONFIG_NODE, &amp;no_service_password_encrypt_cmd);</a>
<a name="ln4227">      install_element (CONFIG_NODE, &amp;banner_motd_default_cmd);</a>
<a name="ln4228">      install_element (CONFIG_NODE, &amp;banner_motd_file_cmd);</a>
<a name="ln4229">      install_element (CONFIG_NODE, &amp;no_banner_motd_cmd);</a>
<a name="ln4230">      install_element (CONFIG_NODE, &amp;service_terminal_length_cmd);</a>
<a name="ln4231">      install_element (CONFIG_NODE, &amp;no_service_terminal_length_cmd);</a>
<a name="ln4232"> </a>
<a name="ln4233">      install_element (VIEW_NODE, &amp;show_thread_cpu_cmd);</a>
<a name="ln4234">      install_element (RESTRICTED_NODE, &amp;show_thread_cpu_cmd);</a>
<a name="ln4235">      </a>
<a name="ln4236">      install_element (ENABLE_NODE, &amp;clear_thread_cpu_cmd);</a>
<a name="ln4237">      install_element (VIEW_NODE, &amp;show_work_queues_cmd);</a>
<a name="ln4238">    }</a>
<a name="ln4239">  install_element (CONFIG_NODE, &amp;show_commandtree_cmd);</a>
<a name="ln4240">  srandom(time(NULL));</a>
<a name="ln4241">}</a>
<a name="ln4242"> </a>
<a name="ln4243">static void</a>
<a name="ln4244">cmd_terminate_token(struct cmd_token *token)</a>
<a name="ln4245">{</a>
<a name="ln4246">  unsigned int i, j;</a>
<a name="ln4247">  vector keyword_vect;</a>
<a name="ln4248"> </a>
<a name="ln4249">  if (token-&gt;multiple)</a>
<a name="ln4250">    {</a>
<a name="ln4251">      for (i = 0; i &lt; vector_active(token-&gt;multiple); i++)</a>
<a name="ln4252">        cmd_terminate_token(vector_slot(token-&gt;multiple, i));</a>
<a name="ln4253">      vector_free(token-&gt;multiple);</a>
<a name="ln4254">      token-&gt;multiple = NULL;</a>
<a name="ln4255">    }</a>
<a name="ln4256"> </a>
<a name="ln4257">  if (token-&gt;keyword)</a>
<a name="ln4258">    {</a>
<a name="ln4259">      for (i = 0; i &lt; vector_active(token-&gt;keyword); i++)</a>
<a name="ln4260">        {</a>
<a name="ln4261">          keyword_vect = vector_slot(token-&gt;keyword, i);</a>
<a name="ln4262">          for (j = 0; j &lt; vector_active(keyword_vect); j++)</a>
<a name="ln4263">            cmd_terminate_token(vector_slot(keyword_vect, j));</a>
<a name="ln4264">          vector_free(keyword_vect);</a>
<a name="ln4265">        }</a>
<a name="ln4266">      vector_free(token-&gt;keyword);</a>
<a name="ln4267">      token-&gt;keyword = NULL;</a>
<a name="ln4268">    }</a>
<a name="ln4269"> </a>
<a name="ln4270">  XFREE(MTYPE_CMD_TOKENS, token-&gt;cmd);</a>
<a name="ln4271">  XFREE(MTYPE_CMD_TOKENS, token-&gt;desc);</a>
<a name="ln4272"> </a>
<a name="ln4273">  XFREE(MTYPE_CMD_TOKENS, token);</a>
<a name="ln4274">}</a>
<a name="ln4275"> </a>
<a name="ln4276">static void</a>
<a name="ln4277">cmd_terminate_element(struct cmd_element *cmd)</a>
<a name="ln4278">{</a>
<a name="ln4279">  unsigned int i;</a>
<a name="ln4280"> </a>
<a name="ln4281">  if (cmd-&gt;tokens == NULL)</a>
<a name="ln4282">    return;</a>
<a name="ln4283"> </a>
<a name="ln4284">  for (i = 0; i &lt; vector_active(cmd-&gt;tokens); i++)</a>
<a name="ln4285">    cmd_terminate_token(vector_slot(cmd-&gt;tokens, i));</a>
<a name="ln4286"> </a>
<a name="ln4287">  vector_free(cmd-&gt;tokens);</a>
<a name="ln4288">  cmd-&gt;tokens = NULL;</a>
<a name="ln4289">}</a>
<a name="ln4290"> </a>
<a name="ln4291">void</a>
<a name="ln4292">cmd_terminate ()</a>
<a name="ln4293">{</a>
<a name="ln4294">  unsigned int i, j;</a>
<a name="ln4295">  struct cmd_node *cmd_node;</a>
<a name="ln4296">  struct cmd_element *cmd_element;</a>
<a name="ln4297">  vector cmd_node_v;</a>
<a name="ln4298"> </a>
<a name="ln4299">  if (cmdvec)</a>
<a name="ln4300">    {</a>
<a name="ln4301">      for (i = 0; i &lt; vector_active (cmdvec); i++) </a>
<a name="ln4302">        if ((cmd_node = vector_slot (cmdvec, i)) != NULL)</a>
<a name="ln4303">          {</a>
<a name="ln4304">            cmd_node_v = cmd_node-&gt;cmd_vector;</a>
<a name="ln4305"> </a>
<a name="ln4306">            for (j = 0; j &lt; vector_active (cmd_node_v); j++)</a>
<a name="ln4307">              if ((cmd_element = vector_slot (cmd_node_v, j)) != NULL)</a>
<a name="ln4308">                cmd_terminate_element(cmd_element);</a>
<a name="ln4309"> </a>
<a name="ln4310">            vector_free (cmd_node_v);</a>
<a name="ln4311">            hash_clean (cmd_node-&gt;cmd_hash, NULL);</a>
<a name="ln4312">            hash_free (cmd_node-&gt;cmd_hash);</a>
<a name="ln4313">            cmd_node-&gt;cmd_hash = NULL;</a>
<a name="ln4314">          }</a>
<a name="ln4315"> </a>
<a name="ln4316">      vector_free (cmdvec);</a>
<a name="ln4317">      cmdvec = NULL;</a>
<a name="ln4318">    }</a>
<a name="ln4319"> </a>
<a name="ln4320">  if (command_cr)</a>
<a name="ln4321">    XFREE(MTYPE_CMD_TOKENS, command_cr);</a>
<a name="ln4322">  if (token_cr.desc)</a>
<a name="ln4323">    XFREE(MTYPE_CMD_TOKENS, token_cr.desc);</a>
<a name="ln4324">  if (host.name)</a>
<a name="ln4325">    XFREE (MTYPE_HOST, host.name);</a>
<a name="ln4326">  if (host.password)</a>
<a name="ln4327">    XFREE (MTYPE_HOST, host.password);</a>
<a name="ln4328">  if (host.password_encrypt)</a>
<a name="ln4329">    XFREE (MTYPE_HOST, host.password_encrypt);</a>
<a name="ln4330">  if (host.enable)</a>
<a name="ln4331">    XFREE (MTYPE_HOST, host.enable);</a>
<a name="ln4332">  if (host.enable_encrypt)</a>
<a name="ln4333">    XFREE (MTYPE_HOST, host.enable_encrypt);</a>
<a name="ln4334">  if (host.logfile)</a>
<a name="ln4335">    XFREE (MTYPE_HOST, host.logfile);</a>
<a name="ln4336">  if (host.motdfile)</a>
<a name="ln4337">    XFREE (MTYPE_HOST, host.motdfile);</a>
<a name="ln4338">  if (host.config)</a>
<a name="ln4339">    XFREE (MTYPE_HOST, host.config);</a>
<a name="ln4340">}</a>

</code></pre>
<div class="balloon" rel="10"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="1456"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v629/" target="_blank">V629</a> Consider inspecting the '1 << keyword_found' expression. Bit shifting of the 32-bit value with a subsequent expansion to the 64-bit type.</p></div>
<div class="balloon" rel="1840"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'cmd_token->type != TOKEN_TERMINAL' is always false.</p></div>
<div class="balloon" rel="1957"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v768/" target="_blank">V768</a> The expression 'cmd_ipv6_match(src)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="1963"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v768/" target="_blank">V768</a> The expression 'cmd_ipv6_prefix_match(src)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="1969"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v768/" target="_blank">V768</a> The expression 'cmd_ipv4_match(src)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="1975"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v768/" target="_blank">V768</a> The expression 'cmd_ipv4_prefix_match(src)' is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="4175"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 4157, 4175.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
