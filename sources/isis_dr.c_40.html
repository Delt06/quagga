
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_dr.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol - isis_dr.c</a>
<a name="ln3"> *                             IS-IS designated router related routines   </a>
<a name="ln4"> *</a>
<a name="ln5"> * Copyright (C) 2001,2002   Sampo Saaristo</a>
<a name="ln6"> *                           Tampere University of Technology      </a>
<a name="ln7"> *                           Institute of Communications Engineering</a>
<a name="ln8"> *</a>
<a name="ln9"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln10"> * under the terms of the GNU General Public Licenseas published by the Free </a>
<a name="ln11"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln12"> * any later version.</a>
<a name="ln13"> *</a>
<a name="ln14"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln15"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln16"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln17"> * more details.</a>
<a name="ln18"> </a>
<a name="ln19"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln20"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln21"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;zebra.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &quot;hash.h&quot;</a>
<a name="ln29">#include &quot;thread.h&quot;</a>
<a name="ln30">#include &quot;linklist.h&quot;</a>
<a name="ln31">#include &quot;vty.h&quot;</a>
<a name="ln32">#include &quot;stream.h&quot;</a>
<a name="ln33">#include &quot;if.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;isisd/dict.h&quot;</a>
<a name="ln36">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln37">#include &quot;isisd/isis_common.h&quot;</a>
<a name="ln38">#include &quot;isisd/isis_misc.h&quot;</a>
<a name="ln39">#include &quot;isisd/isis_flags.h&quot;</a>
<a name="ln40">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln41">#include &quot;isisd/isisd.h&quot;</a>
<a name="ln42">#include &quot;isisd/isis_adjacency.h&quot;</a>
<a name="ln43">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln44">#include &quot;isisd/isis_pdu.h&quot;</a>
<a name="ln45">#include &quot;isisd/isis_tlv.h&quot;</a>
<a name="ln46">#include &quot;isisd/isis_lsp.h&quot;</a>
<a name="ln47">#include &quot;isisd/isis_dr.h&quot;</a>
<a name="ln48">#include &quot;isisd/isis_events.h&quot;</a>
<a name="ln49"> </a>
<a name="ln50">const char *</a>
<a name="ln51">isis_disflag2string (int disflag)</a>
<a name="ln52">{</a>
<a name="ln53"> </a>
<a name="ln54">  switch (disflag)</a>
<a name="ln55">    {</a>
<a name="ln56">    case ISIS_IS_NOT_DIS:</a>
<a name="ln57">      return &quot;is not DIS&quot;;</a>
<a name="ln58">    case ISIS_IS_DIS:</a>
<a name="ln59">      return &quot;is DIS&quot;;</a>
<a name="ln60">    case ISIS_WAS_DIS:</a>
<a name="ln61">      return &quot;was DIS&quot;;</a>
<a name="ln62">    default:</a>
<a name="ln63">      return &quot;unknown DIS state&quot;;</a>
<a name="ln64">    }</a>
<a name="ln65">  return NULL;			/* not reached */</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">int</a>
<a name="ln69">isis_run_dr_l1 (struct thread *thread)</a>
<a name="ln70">{</a>
<a name="ln71">  struct isis_circuit *circuit;</a>
<a name="ln72"> </a>
<a name="ln73">  circuit = THREAD_ARG (thread);</a>
<a name="ln74">  assert (circuit);</a>
<a name="ln75"> </a>
<a name="ln76">  if (circuit-&gt;u.bc.run_dr_elect[0])</a>
<a name="ln77">    zlog_warn (&quot;isis_run_dr(): run_dr_elect already set for l1&quot;);</a>
<a name="ln78"> </a>
<a name="ln79">  circuit-&gt;u.bc.t_run_dr[0] = NULL;</a>
<a name="ln80">  circuit-&gt;u.bc.run_dr_elect[0] = 1;</a>
<a name="ln81"> </a>
<a name="ln82">  return ISIS_OK;</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">int</a>
<a name="ln86">isis_run_dr_l2 (struct thread *thread)</a>
<a name="ln87">{</a>
<a name="ln88">  struct isis_circuit *circuit;</a>
<a name="ln89"> </a>
<a name="ln90">  circuit = THREAD_ARG (thread);</a>
<a name="ln91">  assert (circuit);</a>
<a name="ln92"> </a>
<a name="ln93">  if (circuit-&gt;u.bc.run_dr_elect[1])</a>
<a name="ln94">    zlog_warn (&quot;isis_run_dr(): run_dr_elect already set for l2&quot;);</a>
<a name="ln95"> </a>
<a name="ln96"> </a>
<a name="ln97">  circuit-&gt;u.bc.t_run_dr[1] = NULL;</a>
<a name="ln98">  circuit-&gt;u.bc.run_dr_elect[1] = 1;</a>
<a name="ln99"> </a>
<a name="ln100">  return ISIS_OK;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">static int</a>
<a name="ln104">isis_check_dr_change (struct isis_adjacency *adj, int level)</a>
<a name="ln105">{</a>
<a name="ln106">  int i;</a>
<a name="ln107"> </a>
<a name="ln108">  if (adj-&gt;dis_record[level - 1].dis !=</a>
<a name="ln109">      adj-&gt;dis_record[(1 * ISIS_LEVELS) + level - 1].dis)</a>
<a name="ln110">    /* was there a DIS state transition ? */</a>
<a name="ln111">    {</a>
<a name="ln112">      adj-&gt;dischanges[level - 1]++;</a>
<a name="ln113">      /* ok rotate the history list through */</a>
<a name="ln114">      for (i = DIS_RECORDS - 1; i &gt; 0; i--)</a>
<a name="ln115">	{</a>
<a name="ln116">	  adj-&gt;dis_record[(i * ISIS_LEVELS) + level - 1].dis =</a>
<a name="ln117">	    adj-&gt;dis_record[((i - 1) * ISIS_LEVELS) + level - 1].dis;</a>
<a name="ln118">	  adj-&gt;dis_record[(i * ISIS_LEVELS) + level - 1].last_dis_change =</a>
<a name="ln119">	    adj-&gt;dis_record[((i - 1) * ISIS_LEVELS) + level -</a>
<a name="ln120">			    1].last_dis_change;</a>
<a name="ln121">	}</a>
<a name="ln122">    }</a>
<a name="ln123">  return ISIS_OK;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">int</a>
<a name="ln127">isis_dr_elect (struct isis_circuit *circuit, int level)</a>
<a name="ln128">{</a>
<a name="ln129">  struct list *adjdb;</a>
<a name="ln130">  struct listnode *node;</a>
<a name="ln131">  struct isis_adjacency *adj, *adj_dr = NULL;</a>
<a name="ln132">  struct list *list = list_new ();</a>
<a name="ln133">  u_char own_prio;</a>
<a name="ln134">  int biggest_prio = -1;</a>
<a name="ln135">  int cmp_res, retval = ISIS_OK;</a>
<a name="ln136"> </a>
<a name="ln137">  own_prio = circuit-&gt;priority[level - 1];</a>
<a name="ln138">  adjdb = circuit-&gt;u.bc.adjdb[level - 1];</a>
<a name="ln139"> </a>
<a name="ln140">  if (!adjdb)</a>
<a name="ln141">    {</a>
<a name="ln142">      zlog_warn (&quot;isis_dr_elect() adjdb == NULL&quot;);</a>
<a name="ln143">      list_delete (list);</a>
<a name="ln144">      return ISIS_WARNING;</a>
<a name="ln145">    }</a>
<a name="ln146">  isis_adj_build_up_list (adjdb, list);</a>
<a name="ln147"> </a>
<a name="ln148">  /*</a>
<a name="ln149">   * Loop the adjacencies and find the one with the biggest priority</a>
<a name="ln150">   */</a>
<a name="ln151">  for (ALL_LIST_ELEMENTS_RO (list, node, adj))</a>
<a name="ln152">    {</a>
<a name="ln153">      /* clear flag for show output */</a>
<a name="ln154">      adj-&gt;dis_record[level - 1].dis = ISIS_IS_NOT_DIS;</a>
<a name="ln155">      adj-&gt;dis_record[level - 1].last_dis_change = time (NULL);</a>
<a name="ln156"> </a>
<a name="ln157">      if (adj-&gt;prio[level - 1] &gt; biggest_prio)</a>
<a name="ln158">	{</a>
<a name="ln159">	  biggest_prio = adj-&gt;prio[level - 1];</a>
<a name="ln160">	  adj_dr = adj;</a>
<a name="ln161">	}</a>
<a name="ln162">      else if (adj-&gt;prio[level - 1] == biggest_prio)</a>
<a name="ln163">	{</a>
<a name="ln164">	  /*</a>
<a name="ln165">	   * Comparison of MACs breaks a tie</a>
<a name="ln166">	   */</a>
<a name="ln167">	  if (adj_dr)</a>
<a name="ln168">	    {</a>
<a name="ln169">	      cmp_res = memcmp (adj_dr-&gt;snpa, adj-&gt;snpa, ETH_ALEN);</a>
<a name="ln170">	      if (cmp_res &lt; 0)</a>
<a name="ln171">		{</a>
<a name="ln172">		  adj_dr = adj;</a>
<a name="ln173">		}</a>
<a name="ln174">	      if (cmp_res == 0)</a>
<a name="ln175">		zlog_warn</a>
<a name="ln176">		  (&quot;isis_dr_elect(): multiple adjacencies with same SNPA&quot;);</a>
<a name="ln177">	    }</a>
<a name="ln178">	  else</a>
<a name="ln179">	    {</a>
<a name="ln180">	      adj_dr = adj;</a>
<a name="ln181">	    }</a>
<a name="ln182">	}</a>
<a name="ln183">    }</a>
<a name="ln184"> </a>
<a name="ln185">  if (!adj_dr)</a>
<a name="ln186">    {</a>
<a name="ln187">      /*</a>
<a name="ln188">       * Could not find the DR - means we are alone. Resign if we were DR.</a>
<a name="ln189">       */</a>
<a name="ln190">      if (circuit-&gt;u.bc.is_dr[level - 1])</a>
<a name="ln191">        retval = isis_dr_resign (circuit, level);</a>
<a name="ln192">      list_delete (list);</a>
<a name="ln193">      return retval;</a>
<a name="ln194">    }</a>
<a name="ln195"> </a>
<a name="ln196">  /*</a>
<a name="ln197">   * Now we have the DR adjacency, compare it to self</a>
<a name="ln198">   */</a>
<a name="ln199">  if (adj_dr-&gt;prio[level - 1] &lt; own_prio ||</a>
<a name="ln200">      (adj_dr-&gt;prio[level - 1] == own_prio &amp;&amp;</a>
<a name="ln201">       memcmp (adj_dr-&gt;snpa, circuit-&gt;u.bc.snpa, ETH_ALEN) &lt; 0))</a>
<a name="ln202">    {</a>
<a name="ln203">      adj_dr-&gt;dis_record[level - 1].dis = ISIS_IS_NOT_DIS;</a>
<a name="ln204">      adj_dr-&gt;dis_record[level - 1].last_dis_change = time (NULL);</a>
<a name="ln205"> </a>
<a name="ln206">      /* rotate the history log */</a>
<a name="ln207">      for (ALL_LIST_ELEMENTS_RO (list, node, adj))</a>
<a name="ln208">        isis_check_dr_change (adj, level);</a>
<a name="ln209"> </a>
<a name="ln210">      /* We are the DR, commence DR */</a>
<a name="ln211">      if (circuit-&gt;u.bc.is_dr[level - 1] == 0 &amp;&amp; listcount (list) &gt; 0)</a>
<a name="ln212">        retval = isis_dr_commence (circuit, level);</a>
<a name="ln213">    }</a>
<a name="ln214">  else</a>
<a name="ln215">    {</a>
<a name="ln216">      /* ok we have found the DIS - lets mark the adjacency */</a>
<a name="ln217">      /* set flag for show output */</a>
<a name="ln218">      adj_dr-&gt;dis_record[level - 1].dis = ISIS_IS_DIS;</a>
<a name="ln219">      adj_dr-&gt;dis_record[level - 1].last_dis_change = time (NULL);</a>
<a name="ln220"> </a>
<a name="ln221">      /* now loop through a second time to check if there has been a DIS change</a>
<a name="ln222">       * if yes rotate the history log</a>
<a name="ln223">       */</a>
<a name="ln224"> </a>
<a name="ln225">      for (ALL_LIST_ELEMENTS_RO (list, node, adj))</a>
<a name="ln226">        isis_check_dr_change (adj, level);</a>
<a name="ln227"> </a>
<a name="ln228">      /*</a>
<a name="ln229">       * We are not DR - if we were -&gt; resign</a>
<a name="ln230">       */</a>
<a name="ln231">      if (circuit-&gt;u.bc.is_dr[level - 1])</a>
<a name="ln232">        retval = isis_dr_resign (circuit, level);</a>
<a name="ln233">    }</a>
<a name="ln234">  list_delete (list);</a>
<a name="ln235">  return retval;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">int</a>
<a name="ln239">isis_dr_resign (struct isis_circuit *circuit, int level)</a>
<a name="ln240">{</a>
<a name="ln241">  u_char id[ISIS_SYS_ID_LEN + 2];</a>
<a name="ln242"> </a>
<a name="ln243">  zlog_debug (&quot;isis_dr_resign l%d&quot;, level);</a>
<a name="ln244"> </a>
<a name="ln245">  circuit-&gt;u.bc.is_dr[level - 1] = 0;</a>
<a name="ln246">  circuit-&gt;u.bc.run_dr_elect[level - 1] = 0;</a>
<a name="ln247">  THREAD_TIMER_OFF (circuit-&gt;u.bc.t_run_dr[level - 1]);</a>
<a name="ln248">  THREAD_TIMER_OFF (circuit-&gt;u.bc.t_refresh_pseudo_lsp[level - 1]);</a>
<a name="ln249">  circuit-&gt;lsp_regenerate_pending[level - 1] = 0;</a>
<a name="ln250"> </a>
<a name="ln251">  memcpy (id, isis-&gt;sysid, ISIS_SYS_ID_LEN);</a>
<a name="ln252">  LSP_PSEUDO_ID (id) = circuit-&gt;circuit_id;</a>
<a name="ln253">  LSP_FRAGMENT (id) = 0;</a>
<a name="ln254">  lsp_purge_pseudo (id, circuit, level);</a>
<a name="ln255"> </a>
<a name="ln256">  if (level == 1)</a>
<a name="ln257">    {</a>
<a name="ln258">      memset (circuit-&gt;u.bc.l1_desig_is, 0, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln259"> </a>
<a name="ln260">      THREAD_TIMER_OFF (circuit-&gt;t_send_csnp[0]);</a>
<a name="ln261"> </a>
<a name="ln262">      THREAD_TIMER_ON (master, circuit-&gt;u.bc.t_run_dr[0], isis_run_dr_l1,</a>
<a name="ln263">		       circuit, 2 * circuit-&gt;hello_interval[0]);</a>
<a name="ln264"> </a>
<a name="ln265">      THREAD_TIMER_ON (master, circuit-&gt;t_send_psnp[0], send_l1_psnp, circuit,</a>
<a name="ln266">		       isis_jitter (circuit-&gt;psnp_interval[level - 1],</a>
<a name="ln267">				    PSNP_JITTER));</a>
<a name="ln268">    }</a>
<a name="ln269">  else</a>
<a name="ln270">    {</a>
<a name="ln271">      memset (circuit-&gt;u.bc.l2_desig_is, 0, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln272"> </a>
<a name="ln273">      THREAD_TIMER_OFF (circuit-&gt;t_send_csnp[1]);</a>
<a name="ln274"> </a>
<a name="ln275">      THREAD_TIMER_ON (master, circuit-&gt;u.bc.t_run_dr[1], isis_run_dr_l2,</a>
<a name="ln276">		       circuit, 2 * circuit-&gt;hello_interval[1]);</a>
<a name="ln277"> </a>
<a name="ln278">      THREAD_TIMER_ON (master, circuit-&gt;t_send_psnp[1], send_l2_psnp, circuit,</a>
<a name="ln279">		       isis_jitter (circuit-&gt;psnp_interval[level - 1],</a>
<a name="ln280">				    PSNP_JITTER));</a>
<a name="ln281">    }</a>
<a name="ln282"> </a>
<a name="ln283">  thread_add_event (master, isis_event_dis_status_change, circuit, 0);</a>
<a name="ln284"> </a>
<a name="ln285">  return ISIS_OK;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">int</a>
<a name="ln289">isis_dr_commence (struct isis_circuit *circuit, int level)</a>
<a name="ln290">{</a>
<a name="ln291">  u_char old_dr[ISIS_SYS_ID_LEN + 2];</a>
<a name="ln292"> </a>
<a name="ln293">  if (isis-&gt;debugs &amp; DEBUG_EVENTS)</a>
<a name="ln294">    zlog_debug (&quot;isis_dr_commence l%d&quot;, level);</a>
<a name="ln295"> </a>
<a name="ln296">  /* Lets keep a pause in DR election */</a>
<a name="ln297">  circuit-&gt;u.bc.run_dr_elect[level - 1] = 0;</a>
<a name="ln298">  if (level == 1)</a>
<a name="ln299">    THREAD_TIMER_ON (master, circuit-&gt;u.bc.t_run_dr[0], isis_run_dr_l1,</a>
<a name="ln300">		     circuit, 2 * circuit-&gt;hello_interval[0]);</a>
<a name="ln301">  else</a>
<a name="ln302">    THREAD_TIMER_ON (master, circuit-&gt;u.bc.t_run_dr[1], isis_run_dr_l2,</a>
<a name="ln303">		     circuit, 2 * circuit-&gt;hello_interval[1]);</a>
<a name="ln304">  circuit-&gt;u.bc.is_dr[level - 1] = 1;</a>
<a name="ln305"> </a>
<a name="ln306">  if (level == 1)</a>
<a name="ln307">    {</a>
<a name="ln308">      memcpy (old_dr, circuit-&gt;u.bc.l1_desig_is, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln309">      LSP_FRAGMENT (old_dr) = 0;</a>
<a name="ln310">      if (LSP_PSEUDO_ID (old_dr))</a>
<a name="ln311">	{</a>
<a name="ln312">	  /* there was a dr elected, purge its LSPs from the db */</a>
<a name="ln313">	  lsp_purge_pseudo (old_dr, circuit, level);</a>
<a name="ln314">	}</a>
<a name="ln315">      memcpy (circuit-&gt;u.bc.l1_desig_is, isis-&gt;sysid, ISIS_SYS_ID_LEN);</a>
<a name="ln316">      *(circuit-&gt;u.bc.l1_desig_is + ISIS_SYS_ID_LEN) = circuit-&gt;circuit_id;</a>
<a name="ln317"> </a>
<a name="ln318">      assert (circuit-&gt;circuit_id);	/* must be non-zero */</a>
<a name="ln319">      /*    if (circuit-&gt;t_send_l1_psnp)</a>
<a name="ln320">         thread_cancel (circuit-&gt;t_send_l1_psnp); */</a>
<a name="ln321">      lsp_generate_pseudo (circuit, 1);</a>
<a name="ln322"> </a>
<a name="ln323">      THREAD_TIMER_OFF (circuit-&gt;u.bc.t_run_dr[0]);</a>
<a name="ln324">      THREAD_TIMER_ON (master, circuit-&gt;u.bc.t_run_dr[0], isis_run_dr_l1,</a>
<a name="ln325">		       circuit, 2 * circuit-&gt;hello_interval[0]);</a>
<a name="ln326"> </a>
<a name="ln327">      THREAD_TIMER_ON (master, circuit-&gt;t_send_csnp[0], send_l1_csnp, circuit,</a>
<a name="ln328">		       isis_jitter (circuit-&gt;csnp_interval[level - 1],</a>
<a name="ln329">				    CSNP_JITTER));</a>
<a name="ln330"> </a>
<a name="ln331">    }</a>
<a name="ln332">  else</a>
<a name="ln333">    {</a>
<a name="ln334">      memcpy (old_dr, circuit-&gt;u.bc.l2_desig_is, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln335">      LSP_FRAGMENT (old_dr) = 0;</a>
<a name="ln336">      if (LSP_PSEUDO_ID (old_dr))</a>
<a name="ln337">	{</a>
<a name="ln338">	  /* there was a dr elected, purge its LSPs from the db */</a>
<a name="ln339">	  lsp_purge_pseudo (old_dr, circuit, level);</a>
<a name="ln340">	}</a>
<a name="ln341">      memcpy (circuit-&gt;u.bc.l2_desig_is, isis-&gt;sysid, ISIS_SYS_ID_LEN);</a>
<a name="ln342">      *(circuit-&gt;u.bc.l2_desig_is + ISIS_SYS_ID_LEN) = circuit-&gt;circuit_id;</a>
<a name="ln343"> </a>
<a name="ln344">      assert (circuit-&gt;circuit_id);	/* must be non-zero */</a>
<a name="ln345">      /*    if (circuit-&gt;t_send_l1_psnp)</a>
<a name="ln346">         thread_cancel (circuit-&gt;t_send_l1_psnp); */</a>
<a name="ln347">      lsp_generate_pseudo (circuit, 2);</a>
<a name="ln348"> </a>
<a name="ln349">      THREAD_TIMER_OFF (circuit-&gt;u.bc.t_run_dr[1]);</a>
<a name="ln350">      THREAD_TIMER_ON (master, circuit-&gt;u.bc.t_run_dr[1], isis_run_dr_l2,</a>
<a name="ln351">		       circuit, 2 * circuit-&gt;hello_interval[1]);</a>
<a name="ln352"> </a>
<a name="ln353">      THREAD_TIMER_ON (master, circuit-&gt;t_send_csnp[1], send_l2_csnp, circuit,</a>
<a name="ln354">		       isis_jitter (circuit-&gt;csnp_interval[level - 1],</a>
<a name="ln355">				    CSNP_JITTER));</a>
<a name="ln356">    }</a>
<a name="ln357"> </a>
<a name="ln358">  thread_add_event (master, isis_event_dis_status_change, circuit, 0);</a>
<a name="ln359"> </a>
<a name="ln360">  return ISIS_OK;</a>
<a name="ln361">}</a>

</code></pre>
<div class="balloon" rel="16"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
