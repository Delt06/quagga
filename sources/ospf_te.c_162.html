
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_te.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * This is an implementation of RFC3630</a>
<a name="ln3"> * Copyright (C) 2001 KDD R&amp;D Laboratories, Inc.</a>
<a name="ln4"> * http://www.kddlabs.co.jp/</a>
<a name="ln5"> *</a>
<a name="ln6"> * Copyright (C) 2012 Orange Labs</a>
<a name="ln7"> * http://www.orange.com</a>
<a name="ln8"> *</a>
<a name="ln9"> * This file is part of GNU Zebra.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln12"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln13"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln14"> * later version.</a>
<a name="ln15"> * </a>
<a name="ln16"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln17"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln18"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln19"> * General Public License for more details.</a>
<a name="ln20"> *</a>
<a name="ln21"> * You should have received a copy of the GNU General Public License</a>
<a name="ln22"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln23"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln24"> * 02111-1307, USA.</a>
<a name="ln25"> */</a>
<a name="ln26"> </a>
<a name="ln27">/* Add support of RFC7471 */</a>
<a name="ln28">/* Add support of RFC5392, RFC6827 */</a>
<a name="ln29"> </a>
<a name="ln30">#include &lt;zebra.h&gt;</a>
<a name="ln31">#include &lt;math.h&gt;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;linklist.h&quot;</a>
<a name="ln34">#include &quot;prefix.h&quot;</a>
<a name="ln35">#include &quot;if.h&quot;</a>
<a name="ln36">#include &quot;table.h&quot;</a>
<a name="ln37">#include &quot;memory.h&quot;</a>
<a name="ln38">#include &quot;command.h&quot;</a>
<a name="ln39">#include &quot;vty.h&quot;</a>
<a name="ln40">#include &quot;stream.h&quot;</a>
<a name="ln41">#include &quot;log.h&quot;</a>
<a name="ln42">#include &quot;thread.h&quot;</a>
<a name="ln43">#include &quot;hash.h&quot;</a>
<a name="ln44">#include &quot;sockunion.h&quot;		/* for inet_aton() */</a>
<a name="ln45">#include &quot;network.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln48">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln49">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln50">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln51">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln52">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln53">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln54">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln55">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln56">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln57">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln58">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln59">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln60">#include &quot;ospfd/ospf_ase.h&quot;</a>
<a name="ln61">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln62">#include &quot;ospfd/ospf_te.h&quot;</a>
<a name="ln63">#include &quot;ospfd/ospf_vty.h&quot;</a>
<a name="ln64"> </a>
<a name="ln65">/*</a>
<a name="ln66"> * Global variable to manage Opaque-LSA/MPLS-TE on this node.</a>
<a name="ln67"> * Note that all parameter values are stored in network byte order.</a>
<a name="ln68"> */</a>
<a name="ln69">struct ospf_mpls_te OspfMplsTE;</a>
<a name="ln70"> </a>
<a name="ln71">const char *mode2text[] = { &quot;Disable&quot;, &quot;AS&quot;, &quot;Area&quot;, &quot;Emulate&quot; };</a>
<a name="ln72"> </a>
<a name="ln73">enum oifstate</a>
<a name="ln74">{</a>
<a name="ln75">  OI_ANY, OI_DOWN, OI_UP</a>
<a name="ln76">};</a>
<a name="ln77"> </a>
<a name="ln78">/*------------------------------------------------------------------------*</a>
<a name="ln79"> * Followings are initialize/terminate functions for MPLS-TE handling.</a>
<a name="ln80"> *------------------------------------------------------------------------*/</a>
<a name="ln81"> </a>
<a name="ln82">static int ospf_mpls_te_new_if (struct interface *ifp);</a>
<a name="ln83">static int ospf_mpls_te_del_if (struct interface *ifp);</a>
<a name="ln84">static void ospf_mpls_te_ism_change (struct ospf_interface *oi,</a>
<a name="ln85">                                     int old_status);</a>
<a name="ln86">static void ospf_mpls_te_nsm_change (struct ospf_neighbor *nbr, int old_status);</a>
<a name="ln87">static void ospf_mpls_te_config_write_router (struct vty *vty);</a>
<a name="ln88">static void ospf_mpls_te_show_info (struct vty *vty, struct ospf_lsa *lsa);</a>
<a name="ln89">static int ospf_mpls_te_lsa_originate_area (void *arg);</a>
<a name="ln90">static int ospf_mpls_te_lsa_originate_as (void *arg);</a>
<a name="ln91">static struct ospf_lsa *ospf_mpls_te_lsa_refresh (struct ospf_lsa *lsa);</a>
<a name="ln92"> </a>
<a name="ln93">static void del_mpls_te_link (void *val);</a>
<a name="ln94">static void ospf_mpls_te_register_vty (void);</a>
<a name="ln95"> </a>
<a name="ln96">int</a>
<a name="ln97">ospf_mpls_te_init (void)</a>
<a name="ln98">{</a>
<a name="ln99">  int rc;</a>
<a name="ln100"> </a>
<a name="ln101">  rc = ospf_register_opaque_functab (</a>
<a name="ln102">                OSPF_OPAQUE_AREA_LSA,</a>
<a name="ln103">                OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA,</a>
<a name="ln104">		ospf_mpls_te_new_if,</a>
<a name="ln105">		ospf_mpls_te_del_if,</a>
<a name="ln106">		ospf_mpls_te_ism_change,</a>
<a name="ln107">		ospf_mpls_te_nsm_change,</a>
<a name="ln108">		ospf_mpls_te_config_write_router,</a>
<a name="ln109">		NULL,/*ospf_mpls_te_config_write_if */</a>
<a name="ln110">		NULL,/* ospf_mpls_te_config_write_debug */</a>
<a name="ln111">                ospf_mpls_te_show_info,</a>
<a name="ln112">                ospf_mpls_te_lsa_originate_area,</a>
<a name="ln113">                ospf_mpls_te_lsa_refresh,</a>
<a name="ln114">		NULL,/* ospf_mpls_te_new_lsa_hook */</a>
<a name="ln115">		NULL /* ospf_mpls_te_del_lsa_hook */);</a>
<a name="ln116">  if (rc != 0)</a>
<a name="ln117">    {</a>
<a name="ln118">      zlog_warn (&quot;ospf_mpls_te_init: Failed to register Traffic Engineering functions&quot;);</a>
<a name="ln119">      goto out;</a>
<a name="ln120">    }</a>
<a name="ln121"> </a>
<a name="ln122">  memset (&amp;OspfMplsTE, 0, sizeof (struct ospf_mpls_te));</a>
<a name="ln123">  OspfMplsTE.status = disabled;</a>
<a name="ln124">  OspfMplsTE.inter_as = Disable;</a>
<a name="ln125">  OspfMplsTE.iflist = list_new ();</a>
<a name="ln126">  OspfMplsTE.iflist-&gt;del = del_mpls_te_link;</a>
<a name="ln127"> </a>
<a name="ln128">  ospf_mpls_te_register_vty ();</a>
<a name="ln129"> </a>
<a name="ln130">out:</a>
<a name="ln131">  return rc;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">/* Additional register for RFC5392 support */</a>
<a name="ln135">static int</a>
<a name="ln136">ospf_mpls_te_register (enum inter_as_mode mode)</a>
<a name="ln137">{</a>
<a name="ln138">  int rc;</a>
<a name="ln139">  u_int8_t scope;</a>
<a name="ln140"> </a>
<a name="ln141">  if (OspfMplsTE.inter_as != Disable)</a>
<a name="ln142">    return 0;</a>
<a name="ln143"> </a>
<a name="ln144">  if (mode == AS)</a>
<a name="ln145">    scope = OSPF_OPAQUE_AS_LSA;</a>
<a name="ln146">  else</a>
<a name="ln147">    scope = OSPF_OPAQUE_AREA_LSA;</a>
<a name="ln148"> </a>
<a name="ln149">  rc = ospf_register_opaque_functab (scope,</a>
<a name="ln150">                                     OPAQUE_TYPE_INTER_AS_LSA,</a>
<a name="ln151">                                     NULL,</a>
<a name="ln152">                                     NULL,</a>
<a name="ln153">                                     NULL,</a>
<a name="ln154">                                     NULL,</a>
<a name="ln155">                                     NULL,</a>
<a name="ln156">                                     NULL,</a>
<a name="ln157">                                     NULL,</a>
<a name="ln158">                                     ospf_mpls_te_show_info,</a>
<a name="ln159">                                     ospf_mpls_te_lsa_originate_as,</a>
<a name="ln160">                                     ospf_mpls_te_lsa_refresh, NULL, NULL);</a>
<a name="ln161"> </a>
<a name="ln162">  if (rc != 0)</a>
<a name="ln163">    {</a>
<a name="ln164">      zlog_warn (&quot;ospf_router_info_init: Failed to register Inter-AS functions&quot;);</a>
<a name="ln165">      return rc;</a>
<a name="ln166">    }</a>
<a name="ln167"> </a>
<a name="ln168">  return 0;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">static int</a>
<a name="ln172">ospf_mpls_te_unregister ()</a>
<a name="ln173">{</a>
<a name="ln174">  u_int8_t scope;</a>
<a name="ln175"> </a>
<a name="ln176">  if (OspfMplsTE.inter_as == Disable)</a>
<a name="ln177">    return 0;</a>
<a name="ln178"> </a>
<a name="ln179">  if (OspfMplsTE.inter_as == AS)</a>
<a name="ln180">    scope = OSPF_OPAQUE_AS_LSA;</a>
<a name="ln181">  else</a>
<a name="ln182">    scope = OSPF_OPAQUE_AREA_LSA;</a>
<a name="ln183"> </a>
<a name="ln184">  ospf_delete_opaque_functab (scope, OPAQUE_TYPE_INTER_AS_LSA);</a>
<a name="ln185"> </a>
<a name="ln186">  return 0;</a>
<a name="ln187"> </a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">void</a>
<a name="ln191">ospf_mpls_te_term (void)</a>
<a name="ln192">{</a>
<a name="ln193">  list_delete (OspfMplsTE.iflist);</a>
<a name="ln194">  OspfMplsTE.iflist = NULL;</a>
<a name="ln195"> </a>
<a name="ln196">  ospf_delete_opaque_functab (OSPF_OPAQUE_AREA_LSA,</a>
<a name="ln197">                              OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA);</a>
<a name="ln198">  OspfMplsTE.status = disabled;</a>
<a name="ln199"> </a>
<a name="ln200">  ospf_mpls_te_unregister ();</a>
<a name="ln201">  OspfMplsTE.inter_as = Disable;</a>
<a name="ln202"> </a>
<a name="ln203">  return;</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206">/*------------------------------------------------------------------------*</a>
<a name="ln207"> * Followings are control functions for MPLS-TE parameters management.</a>
<a name="ln208"> *------------------------------------------------------------------------*/</a>
<a name="ln209"> </a>
<a name="ln210">static void</a>
<a name="ln211">del_mpls_te_link (void *val)</a>
<a name="ln212">{</a>
<a name="ln213">  XFREE (MTYPE_OSPF_MPLS_TE, val);</a>
<a name="ln214">  return;</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">u_int32_t</a>
<a name="ln218">get_mpls_te_instance_value (void)</a>
<a name="ln219">{</a>
<a name="ln220">  static u_int32_t seqno = 0;</a>
<a name="ln221"> </a>
<a name="ln222">  if (seqno &lt; MAX_LEGAL_TE_INSTANCE_NUM )</a>
<a name="ln223">    seqno += 1;</a>
<a name="ln224">  else</a>
<a name="ln225">    seqno  = 1; /* Avoid zero. */</a>
<a name="ln226"> </a>
<a name="ln227">  return seqno;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">static struct ospf_interface *</a>
<a name="ln231">lookup_oi_by_ifp (struct interface *ifp,</a>
<a name="ln232">                  struct ospf_area *area, enum oifstate oifstate)</a>
<a name="ln233">{</a>
<a name="ln234">  struct ospf_interface *oi = NULL;</a>
<a name="ln235">  struct route_node *rn;</a>
<a name="ln236"> </a>
<a name="ln237">  for (rn = route_top (IF_OIFS (ifp)); rn; rn = route_next (rn))</a>
<a name="ln238">    {</a>
<a name="ln239">      if ((oi = rn-&gt;info) == NULL)</a>
<a name="ln240">        continue;</a>
<a name="ln241"> </a>
<a name="ln242">      switch (oifstate)</a>
<a name="ln243">        {</a>
<a name="ln244">        case OI_ANY:</a>
<a name="ln245">          break;</a>
<a name="ln246">        case OI_DOWN:</a>
<a name="ln247">          if (ospf_if_is_enable (oi))</a>
<a name="ln248">            continue;</a>
<a name="ln249">          break;</a>
<a name="ln250">        case OI_UP:</a>
<a name="ln251">          if (! ospf_if_is_enable (oi))</a>
<a name="ln252">            continue;</a>
<a name="ln253">          break;</a>
<a name="ln254">        default:</a>
<a name="ln255">          zlog_warn (&quot;lookup_oi_by_ifp: Unknown oifstate: %x&quot;, oifstate);</a>
<a name="ln256">          goto out;</a>
<a name="ln257">        }</a>
<a name="ln258"> </a>
<a name="ln259">      if (area == NULL || oi-&gt;area == area)</a>
<a name="ln260">        return oi;</a>
<a name="ln261">    }</a>
<a name="ln262">out:</a>
<a name="ln263">  return NULL;</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">static struct mpls_te_link *</a>
<a name="ln267">lookup_linkparams_by_ifp (struct interface *ifp)</a>
<a name="ln268">{</a>
<a name="ln269">  struct listnode *node, *nnode;</a>
<a name="ln270">  struct mpls_te_link *lp;</a>
<a name="ln271"> </a>
<a name="ln272">  for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))</a>
<a name="ln273">    if (lp-&gt;ifp == ifp)</a>
<a name="ln274">      return lp;</a>
<a name="ln275"> </a>
<a name="ln276">  return NULL;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">static struct mpls_te_link *</a>
<a name="ln280">lookup_linkparams_by_instance (struct ospf_lsa *lsa)</a>
<a name="ln281">{</a>
<a name="ln282">  struct listnode *node;</a>
<a name="ln283">  struct mpls_te_link *lp;</a>
<a name="ln284">  unsigned int key = GET_OPAQUE_ID (ntohl (lsa-&gt;data-&gt;id.s_addr));</a>
<a name="ln285"> </a>
<a name="ln286">  for (ALL_LIST_ELEMENTS_RO (OspfMplsTE.iflist, node, lp))</a>
<a name="ln287">    if (lp-&gt;instance == key)</a>
<a name="ln288">      return lp;</a>
<a name="ln289"> </a>
<a name="ln290">  zlog_warn (&quot;lookup_linkparams_by_instance: Entry not found: key(%x)&quot;, key);</a>
<a name="ln291">  return NULL;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">static void</a>
<a name="ln295">ospf_mpls_te_foreach_area (void (*func)</a>
<a name="ln296">                           (struct mpls_te_link * lp, opcode_t sched_opcode),</a>
<a name="ln297">                           opcode_t sched_opcode)</a>
<a name="ln298">{</a>
<a name="ln299">  struct listnode *node, *nnode; </a>
<a name="ln300">  struct listnode *node2;</a>
<a name="ln301">  struct mpls_te_link *lp;</a>
<a name="ln302">  struct ospf_area *area;</a>
<a name="ln303"> </a>
<a name="ln304">  for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))</a>
<a name="ln305">    {</a>
<a name="ln306">      /* Skip Inter-AS TEv2 Links */</a>
<a name="ln307">      if (IS_INTER_AS (lp-&gt;type))</a>
<a name="ln308">        continue;</a>
<a name="ln309">      if ((area = lp-&gt;area) == NULL)</a>
<a name="ln310">        continue;</a>
<a name="ln311">      if CHECK_FLAG (lp-&gt;flags, LPFLG_LOOKUP_DONE) continue;</a>
<a name="ln312"> </a>
<a name="ln313">      if (func != NULL)</a>
<a name="ln314">        (* func)(lp, sched_opcode);</a>
<a name="ln315"> </a>
<a name="ln316">      for (node2 = listnextnode (node); node2; node2 = listnextnode (node2))</a>
<a name="ln317">        if ((lp = listgetdata (node2)) != NULL)</a>
<a name="ln318">          if (lp-&gt;area != NULL)</a>
<a name="ln319">            if (IPV4_ADDR_SAME (&amp;lp-&gt;area-&gt;area_id, &amp;area-&gt;area_id))</a>
<a name="ln320">              SET_FLAG (lp-&gt;flags, LPFLG_LOOKUP_DONE);</a>
<a name="ln321">    }</a>
<a name="ln322"> </a>
<a name="ln323">  for (ALL_LIST_ELEMENTS_RO (OspfMplsTE.iflist, node, lp))</a>
<a name="ln324">    if (lp-&gt;area != NULL)</a>
<a name="ln325">      UNSET_FLAG (lp-&gt;flags, LPFLG_LOOKUP_DONE);</a>
<a name="ln326"> </a>
<a name="ln327">  return;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">static void</a>
<a name="ln331">set_mpls_te_router_addr (struct in_addr ipv4)</a>
<a name="ln332">{</a>
<a name="ln333">  OspfMplsTE.router_addr.header.type   = htons (TE_TLV_ROUTER_ADDR);</a>
<a name="ln334">  OspfMplsTE.router_addr.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln335">  OspfMplsTE.router_addr.value = ipv4;</a>
<a name="ln336">  return;</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">static void</a>
<a name="ln340">set_linkparams_link_header (struct mpls_te_link *lp)</a>
<a name="ln341">{</a>
<a name="ln342">  u_int16_t length = 0;</a>
<a name="ln343"> </a>
<a name="ln344">  /* TE_LINK_SUBTLV_LINK_TYPE */</a>
<a name="ln345">  if (ntohs (lp-&gt;link_type.header.type) != 0)</a>
<a name="ln346">    length += TLV_SIZE (&amp;lp-&gt;link_type.header);</a>
<a name="ln347"> </a>
<a name="ln348">  /* TE_LINK_SUBTLV_LINK_ID */</a>
<a name="ln349">  if (ntohs (lp-&gt;link_id.header.type) != 0)</a>
<a name="ln350">    length += TLV_SIZE (&amp;lp-&gt;link_id.header);</a>
<a name="ln351"> </a>
<a name="ln352">  /* TE_LINK_SUBTLV_LCLIF_IPADDR */</a>
<a name="ln353">  if (lp-&gt;lclif_ipaddr.header.type != 0)</a>
<a name="ln354">    length += TLV_SIZE (&amp;lp-&gt;lclif_ipaddr.header);</a>
<a name="ln355"> </a>
<a name="ln356">  /* TE_LINK_SUBTLV_RMTIF_IPADDR */</a>
<a name="ln357">  if (lp-&gt;rmtif_ipaddr.header.type != 0)</a>
<a name="ln358">    length += TLV_SIZE (&amp;lp-&gt;rmtif_ipaddr.header);</a>
<a name="ln359"> </a>
<a name="ln360">  /* TE_LINK_SUBTLV_TE_METRIC */</a>
<a name="ln361">  if (ntohs (lp-&gt;te_metric.header.type) != 0)</a>
<a name="ln362">    length += TLV_SIZE (&amp;lp-&gt;te_metric.header);</a>
<a name="ln363"> </a>
<a name="ln364">  /* TE_LINK_SUBTLV_MAX_BW */</a>
<a name="ln365">  if (ntohs (lp-&gt;max_bw.header.type) != 0)</a>
<a name="ln366">    length += TLV_SIZE (&amp;lp-&gt;max_bw.header);</a>
<a name="ln367"> </a>
<a name="ln368">  /* TE_LINK_SUBTLV_MAX_RSV_BW */</a>
<a name="ln369">  if (ntohs (lp-&gt;max_rsv_bw.header.type) != 0)</a>
<a name="ln370">    length += TLV_SIZE (&amp;lp-&gt;max_rsv_bw.header);</a>
<a name="ln371"> </a>
<a name="ln372">  /* TE_LINK_SUBTLV_UNRSV_BW */</a>
<a name="ln373">  if (ntohs (lp-&gt;unrsv_bw.header.type) != 0)</a>
<a name="ln374">    length += TLV_SIZE (&amp;lp-&gt;unrsv_bw.header);</a>
<a name="ln375"> </a>
<a name="ln376">  /* TE_LINK_SUBTLV_RSC_CLSCLR */</a>
<a name="ln377">  if (ntohs (lp-&gt;rsc_clsclr.header.type) != 0)</a>
<a name="ln378">    length += TLV_SIZE (&amp;lp-&gt;rsc_clsclr.header);</a>
<a name="ln379"> </a>
<a name="ln380">  /* TE_LINK_SUBTLV_LLRI */</a>
<a name="ln381">  if (ntohs (lp-&gt;llri.header.type) != 0)</a>
<a name="ln382">    length += TLV_SIZE (&amp;lp-&gt;llri.header);</a>
<a name="ln383"> </a>
<a name="ln384">  /* TE_LINK_SUBTLV_RIP */</a>
<a name="ln385">  if (ntohs (lp-&gt;rip.header.type) != 0)</a>
<a name="ln386">    length += TLV_SIZE (&amp;lp-&gt;rip.header);</a>
<a name="ln387"> </a>
<a name="ln388">  /* TE_LINK_SUBTLV_RAS */</a>
<a name="ln389">  if (ntohs (lp-&gt;ras.header.type) != 0)</a>
<a name="ln390">    length += TLV_SIZE (&amp;lp-&gt;ras.header);</a>
<a name="ln391"> </a>
<a name="ln392">  /* TE_LINK_SUBTLV_LRRID */</a>
<a name="ln393">  if (ntohs (lp-&gt;lrrid.header.type) != 0)</a>
<a name="ln394">    length += TLV_SIZE (&amp;lp-&gt;lrrid.header);</a>
<a name="ln395"> </a>
<a name="ln396">  /* TE_LINK_SUBTLV_AV_DELAY */</a>
<a name="ln397">  if (ntohs (lp-&gt;av_delay.header.type) != 0)</a>
<a name="ln398">    length += TLV_SIZE (&amp;lp-&gt;av_delay.header);</a>
<a name="ln399"> </a>
<a name="ln400">  /* TE_LINK_SUBTLV_MM_DELAY */</a>
<a name="ln401">  if (ntohs (lp-&gt;mm_delay.header.type) != 0)</a>
<a name="ln402">    length += TLV_SIZE (&amp;lp-&gt;mm_delay.header);</a>
<a name="ln403"> </a>
<a name="ln404">  /* TE_LINK_SUBTLV_DELAY_VAR */</a>
<a name="ln405">  if (ntohs (lp-&gt;delay_var.header.type) != 0)</a>
<a name="ln406">    length += TLV_SIZE (&amp;lp-&gt;delay_var.header);</a>
<a name="ln407"> </a>
<a name="ln408">  /* TE_LINK_SUBTLV_PKT_LOSS */</a>
<a name="ln409">  if (ntohs (lp-&gt;pkt_loss.header.type) != 0)</a>
<a name="ln410">    length += TLV_SIZE (&amp;lp-&gt;pkt_loss.header);</a>
<a name="ln411"> </a>
<a name="ln412">  /* TE_LINK_SUBTLV_RES_BW */</a>
<a name="ln413">  if (ntohs (lp-&gt;res_bw.header.type) != 0)</a>
<a name="ln414">    length += TLV_SIZE (&amp;lp-&gt;res_bw.header);</a>
<a name="ln415"> </a>
<a name="ln416">  /* TE_LINK_SUBTLV_AVA_BW */</a>
<a name="ln417">  if (ntohs (lp-&gt;ava_bw.header.type) != 0)</a>
<a name="ln418">    length += TLV_SIZE (&amp;lp-&gt;ava_bw.header);</a>
<a name="ln419"> </a>
<a name="ln420">  /* TE_LINK_SUBTLV_USE_BW */</a>
<a name="ln421">  if (ntohs (lp-&gt;use_bw.header.type) != 0)</a>
<a name="ln422">    length += TLV_SIZE (&amp;lp-&gt;use_bw.header);</a>
<a name="ln423"> </a>
<a name="ln424">  lp-&gt;link_header.header.type   = htons (TE_TLV_LINK);</a>
<a name="ln425">  lp-&gt;link_header.header.length = htons (length);</a>
<a name="ln426"> </a>
<a name="ln427">  return;</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">static void</a>
<a name="ln431">set_linkparams_link_type (struct ospf_interface *oi, struct mpls_te_link *lp)</a>
<a name="ln432">{</a>
<a name="ln433">  lp-&gt;link_type.header.type   = htons (TE_LINK_SUBTLV_LINK_TYPE);</a>
<a name="ln434">  lp-&gt;link_type.header.length = htons (TE_LINK_SUBTLV_TYPE_SIZE);</a>
<a name="ln435"> </a>
<a name="ln436">  switch (oi-&gt;type)</a>
<a name="ln437">    {</a>
<a name="ln438">    case OSPF_IFTYPE_POINTOPOINT:</a>
<a name="ln439">      lp-&gt;link_type.link_type.value = LINK_TYPE_SUBTLV_VALUE_PTP;</a>
<a name="ln440">      break;</a>
<a name="ln441">    case OSPF_IFTYPE_BROADCAST:</a>
<a name="ln442">    case OSPF_IFTYPE_NBMA:</a>
<a name="ln443">      lp-&gt;link_type.link_type.value = LINK_TYPE_SUBTLV_VALUE_MA;</a>
<a name="ln444">      break;</a>
<a name="ln445">    default:</a>
<a name="ln446">      /* Not supported yet. *//* XXX */</a>
<a name="ln447">      lp-&gt;link_type.header.type = htons (0);</a>
<a name="ln448">      break;</a>
<a name="ln449">    }</a>
<a name="ln450">  return;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">static void</a>
<a name="ln454">set_linkparams_link_id (struct ospf_interface *oi, struct mpls_te_link *lp)</a>
<a name="ln455">{</a>
<a name="ln456">  struct ospf_neighbor *nbr;</a>
<a name="ln457">  int done = 0;</a>
<a name="ln458"> </a>
<a name="ln459">  lp-&gt;link_id.header.type   = htons (TE_LINK_SUBTLV_LINK_ID);</a>
<a name="ln460">  lp-&gt;link_id.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln461"> </a>
<a name="ln462">  /*</a>
<a name="ln463">   * The Link ID is identical to the contents of the Link ID field</a>
<a name="ln464">   * in the Router LSA for these link types.</a>
<a name="ln465">   */</a>
<a name="ln466">  switch (oi-&gt;type)</a>
<a name="ln467">    {</a>
<a name="ln468">    case OSPF_IFTYPE_POINTOPOINT:</a>
<a name="ln469">      /* Take the router ID of the neighbor. */</a>
<a name="ln470">      if ((nbr = ospf_nbr_lookup_ptop (oi)) &amp;&amp; nbr-&gt;state == NSM_Full)</a>
<a name="ln471">        {</a>
<a name="ln472">          lp-&gt;link_id.value = nbr-&gt;router_id;</a>
<a name="ln473">          done = 1;</a>
<a name="ln474">        }</a>
<a name="ln475">      break;</a>
<a name="ln476">    case OSPF_IFTYPE_BROADCAST:</a>
<a name="ln477">    case OSPF_IFTYPE_NBMA:</a>
<a name="ln478">      /* Take the interface address of the designated router. */</a>
<a name="ln479">      if ((nbr = ospf_nbr_lookup_by_addr (oi-&gt;nbrs, &amp;DR (oi))) == NULL)</a>
<a name="ln480">        break;</a>
<a name="ln481"> </a>
<a name="ln482">      if (nbr-&gt;state == NSM_Full</a>
<a name="ln483">      || (IPV4_ADDR_SAME (&amp;oi-&gt;address-&gt;u.prefix4, &amp;DR (oi))</a>
<a name="ln484">      &amp;&amp;  ospf_nbr_count (oi, NSM_Full) &gt; 0))</a>
<a name="ln485">        {</a>
<a name="ln486">          lp-&gt;link_id.value = DR (oi);</a>
<a name="ln487">          done = 1;</a>
<a name="ln488">        }</a>
<a name="ln489">      break;</a>
<a name="ln490">    default:</a>
<a name="ln491">      /* Not supported yet. *//* XXX */</a>
<a name="ln492">      lp-&gt;link_id.header.type = htons (0);</a>
<a name="ln493">      break;</a>
<a name="ln494">    }</a>
<a name="ln495"> </a>
<a name="ln496">  if (! done)</a>
<a name="ln497">    {</a>
<a name="ln498">      struct in_addr mask;</a>
<a name="ln499">      masklen2ip (oi-&gt;address-&gt;prefixlen, &amp;mask);</a>
<a name="ln500">      lp-&gt;link_id.value.s_addr = oi-&gt;address-&gt;u.prefix4.s_addr &amp; mask.s_addr;</a>
<a name="ln501">     }</a>
<a name="ln502">  return;</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">static void</a>
<a name="ln506">set_linkparams_lclif_ipaddr (struct mpls_te_link *lp, struct in_addr lclif)</a>
<a name="ln507">{</a>
<a name="ln508"> </a>
<a name="ln509">  lp-&gt;lclif_ipaddr.header.type = htons (TE_LINK_SUBTLV_LCLIF_IPADDR);</a>
<a name="ln510">  lp-&gt;lclif_ipaddr.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln511">  lp-&gt;lclif_ipaddr.value[0] = lclif;</a>
<a name="ln512">  return;</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">static void</a>
<a name="ln516">set_linkparams_rmtif_ipaddr (struct mpls_te_link *lp, struct in_addr rmtif)</a>
<a name="ln517">{</a>
<a name="ln518"> </a>
<a name="ln519">  lp-&gt;rmtif_ipaddr.header.type = htons (TE_LINK_SUBTLV_RMTIF_IPADDR);</a>
<a name="ln520">  lp-&gt;rmtif_ipaddr.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln521">  lp-&gt;rmtif_ipaddr.value[0] = rmtif;</a>
<a name="ln522">  return;</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">static void</a>
<a name="ln526">set_linkparams_te_metric (struct mpls_te_link *lp, u_int32_t te_metric)</a>
<a name="ln527">{</a>
<a name="ln528">  lp-&gt;te_metric.header.type   = htons (TE_LINK_SUBTLV_TE_METRIC);</a>
<a name="ln529">  lp-&gt;te_metric.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln530">  lp-&gt;te_metric.value = htonl (te_metric);</a>
<a name="ln531">  return;</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">static void</a>
<a name="ln535">set_linkparams_max_bw (struct mpls_te_link *lp, float fp)</a>
<a name="ln536">{</a>
<a name="ln537">  lp-&gt;max_bw.header.type   = htons (TE_LINK_SUBTLV_MAX_BW);</a>
<a name="ln538">  lp-&gt;max_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln539">  lp-&gt;max_bw.value = htonf (fp);</a>
<a name="ln540">  return;</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">static void</a>
<a name="ln544">set_linkparams_max_rsv_bw (struct mpls_te_link *lp, float fp)</a>
<a name="ln545">{</a>
<a name="ln546">  lp-&gt;max_rsv_bw.header.type   = htons (TE_LINK_SUBTLV_MAX_RSV_BW);</a>
<a name="ln547">  lp-&gt;max_rsv_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln548">  lp-&gt;max_rsv_bw.value = htonf (fp);</a>
<a name="ln549">  return;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">static void</a>
<a name="ln553">set_linkparams_unrsv_bw (struct mpls_te_link *lp, int priority, float fp)</a>
<a name="ln554">{</a>
<a name="ln555">  /* Note that TLV-length field is the size of array. */</a>
<a name="ln556">  lp-&gt;unrsv_bw.header.type   = htons (TE_LINK_SUBTLV_UNRSV_BW);</a>
<a name="ln557">  lp-&gt;unrsv_bw.header.length = htons (TE_LINK_SUBTLV_UNRSV_SIZE);</a>
<a name="ln558">  lp-&gt;unrsv_bw.value [priority] = htonf (fp);</a>
<a name="ln559">  return;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">static void</a>
<a name="ln563">set_linkparams_rsc_clsclr (struct mpls_te_link *lp, u_int32_t classcolor)</a>
<a name="ln564">{</a>
<a name="ln565">  lp-&gt;rsc_clsclr.header.type   = htons (TE_LINK_SUBTLV_RSC_CLSCLR);</a>
<a name="ln566">  lp-&gt;rsc_clsclr.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln567">  lp-&gt;rsc_clsclr.value = htonl (classcolor);</a>
<a name="ln568">  return;</a>
<a name="ln569">}</a>
<a name="ln570"> </a>
<a name="ln571">static void</a>
<a name="ln572">set_linkparams_inter_as (struct mpls_te_link *lp, struct in_addr addr,</a>
<a name="ln573">                         u_int32_t as)</a>
<a name="ln574">{</a>
<a name="ln575"> </a>
<a name="ln576">  /* Set the Remote ASBR IP address and then the associated AS number */</a>
<a name="ln577">  lp-&gt;rip.header.type = htons (TE_LINK_SUBTLV_RIP);</a>
<a name="ln578">  lp-&gt;rip.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln579">  lp-&gt;rip.value = addr;</a>
<a name="ln580"> </a>
<a name="ln581">  lp-&gt;ras.header.type = htons (TE_LINK_SUBTLV_RAS);</a>
<a name="ln582">  lp-&gt;ras.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln583">  lp-&gt;ras.value = htonl (as);</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">static void</a>
<a name="ln587">unset_linkparams_inter_as (struct mpls_te_link *lp)</a>
<a name="ln588">{</a>
<a name="ln589"> </a>
<a name="ln590">  /* Reset the Remote ASBR IP address and then the associated AS number */</a>
<a name="ln591">  lp-&gt;rip.header.type = htons (0);</a>
<a name="ln592">  lp-&gt;rip.header.length = htons (0);</a>
<a name="ln593">  lp-&gt;rip.value.s_addr = htonl (0);</a>
<a name="ln594"> </a>
<a name="ln595">  lp-&gt;ras.header.type = htons (0);</a>
<a name="ln596">  lp-&gt;ras.header.length = htons (0);</a>
<a name="ln597">  lp-&gt;ras.value = htonl (0);</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">void</a>
<a name="ln601">set_linkparams_llri (struct mpls_te_link *lp, u_int32_t local,</a>
<a name="ln602">                     u_int32_t remote)</a>
<a name="ln603">{</a>
<a name="ln604"> </a>
<a name="ln605">  lp-&gt;llri.header.type = htons (TE_LINK_SUBTLV_LLRI);</a>
<a name="ln606">  lp-&gt;llri.header.length = htons (TE_LINK_SUBTLV_LLRI_SIZE);</a>
<a name="ln607">  lp-&gt;llri.local = htonl (local);</a>
<a name="ln608">  lp-&gt;llri.remote = htonl (remote);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">void</a>
<a name="ln612">set_linkparams_lrrid (struct mpls_te_link *lp, struct in_addr local,</a>
<a name="ln613">                           struct in_addr remote)</a>
<a name="ln614">{</a>
<a name="ln615"> </a>
<a name="ln616">  lp-&gt;lrrid.header.type = htons (TE_LINK_SUBTLV_LRRID);</a>
<a name="ln617">  lp-&gt;lrrid.header.length = htons (TE_LINK_SUBTLV_LRRID_SIZE);</a>
<a name="ln618">  lp-&gt;lrrid.local.s_addr = local.s_addr;</a>
<a name="ln619">  lp-&gt;lrrid.remote.s_addr = remote.s_addr;</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">static void</a>
<a name="ln623">set_linkparams_av_delay (struct mpls_te_link *lp, u_int32_t delay, u_char anormal)</a>
<a name="ln624">{</a>
<a name="ln625">  u_int32_t tmp;</a>
<a name="ln626">  /* Note that TLV-length field is the size of array. */</a>
<a name="ln627">  lp-&gt;av_delay.header.type = htons (TE_LINK_SUBTLV_AV_DELAY);</a>
<a name="ln628">  lp-&gt;av_delay.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln629">  tmp = delay &amp; TE_EXT_MASK;</a>
<a name="ln630">  if (anormal)</a>
<a name="ln631">    tmp |= TE_EXT_ANORMAL;</a>
<a name="ln632">  lp-&gt;av_delay.value = htonl (tmp);</a>
<a name="ln633">  return;</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">static void</a>
<a name="ln637">set_linkparams_mm_delay (struct mpls_te_link *lp, u_int32_t low, u_int32_t high, u_char anormal)</a>
<a name="ln638">{</a>
<a name="ln639">  u_int32_t tmp;</a>
<a name="ln640">  /* Note that TLV-length field is the size of array. */</a>
<a name="ln641">  lp-&gt;mm_delay.header.type = htons (TE_LINK_SUBTLV_MM_DELAY);</a>
<a name="ln642">  lp-&gt;mm_delay.header.length = htons (TE_LINK_SUBTLV_MM_DELAY_SIZE);</a>
<a name="ln643">  tmp = low &amp; TE_EXT_MASK;</a>
<a name="ln644">  if (anormal)</a>
<a name="ln645">    tmp |= TE_EXT_ANORMAL;</a>
<a name="ln646">  lp-&gt;mm_delay.low = htonl (tmp);</a>
<a name="ln647">  lp-&gt;mm_delay.high = htonl (high);</a>
<a name="ln648">  return;</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">static void</a>
<a name="ln652">set_linkparams_delay_var (struct mpls_te_link *lp, u_int32_t jitter)</a>
<a name="ln653">{</a>
<a name="ln654">  /* Note that TLV-length field is the size of array. */</a>
<a name="ln655">  lp-&gt;delay_var.header.type = htons (TE_LINK_SUBTLV_DELAY_VAR);</a>
<a name="ln656">  lp-&gt;delay_var.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln657">  lp-&gt;delay_var.value = htonl (jitter &amp; TE_EXT_MASK);</a>
<a name="ln658">  return;</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661">static void</a>
<a name="ln662">set_linkparams_pkt_loss (struct mpls_te_link *lp, u_int32_t loss, u_char anormal)</a>
<a name="ln663">{</a>
<a name="ln664">  u_int32_t tmp;</a>
<a name="ln665">  /* Note that TLV-length field is the size of array. */</a>
<a name="ln666">  lp-&gt;pkt_loss.header.type = htons (TE_LINK_SUBTLV_PKT_LOSS);</a>
<a name="ln667">  lp-&gt;pkt_loss.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln668">  tmp = loss &amp; TE_EXT_MASK;</a>
<a name="ln669">  if (anormal)</a>
<a name="ln670">    tmp |= TE_EXT_ANORMAL;</a>
<a name="ln671">  lp-&gt;pkt_loss.value = htonl (tmp);</a>
<a name="ln672">  return;</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">static void</a>
<a name="ln676">set_linkparams_res_bw (struct mpls_te_link *lp, float fp)</a>
<a name="ln677">{</a>
<a name="ln678">  /* Note that TLV-length field is the size of array. */</a>
<a name="ln679">  lp-&gt;res_bw.header.type = htons (TE_LINK_SUBTLV_RES_BW);</a>
<a name="ln680">  lp-&gt;res_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln681">  lp-&gt;res_bw.value = htonf (fp);</a>
<a name="ln682">  return;</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">static void</a>
<a name="ln686">set_linkparams_ava_bw (struct mpls_te_link *lp, float fp)</a>
<a name="ln687">{</a>
<a name="ln688">  /* Note that TLV-length field is the size of array. */</a>
<a name="ln689">  lp-&gt;ava_bw.header.type = htons (TE_LINK_SUBTLV_AVA_BW);</a>
<a name="ln690">  lp-&gt;ava_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln691">  lp-&gt;ava_bw.value = htonf (fp);</a>
<a name="ln692">  return;</a>
<a name="ln693">}</a>
<a name="ln694"> </a>
<a name="ln695">static void</a>
<a name="ln696">set_linkparams_use_bw (struct mpls_te_link *lp, float fp)</a>
<a name="ln697">{</a>
<a name="ln698">  /* Note that TLV-length field is the size of array. */</a>
<a name="ln699">  lp-&gt;use_bw.header.type = htons (TE_LINK_SUBTLV_USE_BW);</a>
<a name="ln700">  lp-&gt;use_bw.header.length = htons (TE_LINK_SUBTLV_DEF_SIZE);</a>
<a name="ln701">  lp-&gt;use_bw.value = htonf (fp);</a>
<a name="ln702">  return;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">/* Update TE parameters from Interface */</a>
<a name="ln706">static void</a>
<a name="ln707">update_linkparams(struct mpls_te_link *lp)</a>
<a name="ln708">{</a>
<a name="ln709">  int i;</a>
<a name="ln710">  struct interface *ifp;</a>
<a name="ln711"> </a>
<a name="ln712">  /* Get the Interface structure */</a>
<a name="ln713">  if ((ifp = lp-&gt;ifp) == NULL)</a>
<a name="ln714">    {</a>
<a name="ln715">      zlog_warn(&quot;OSPF MPLS-TE: Abort update TE parameters: no interface associated to Link Parameters&quot;);</a>
<a name="ln716">      return;</a>
<a name="ln717">    }</a>
<a name="ln718">  if (!HAS_LINK_PARAMS(ifp))</a>
<a name="ln719">    {</a>
<a name="ln720">      zlog_warn(&quot;OSPF MPLS-TE: Abort update TE parameters: no Link Parameters for interface&quot;);</a>
<a name="ln721">      return;</a>
<a name="ln722">    }</a>
<a name="ln723"> </a>
<a name="ln724">  /* RFC3630 metrics */</a>
<a name="ln725">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_ADM_GRP))</a>
<a name="ln726">    set_linkparams_rsc_clsclr (lp, ifp-&gt;link_params-&gt;admin_grp);</a>
<a name="ln727">  else</a>
<a name="ln728">    TLV_TYPE(lp-&gt;rsc_clsclr) = 0;</a>
<a name="ln729"> </a>
<a name="ln730">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_MAX_BW))</a>
<a name="ln731">    set_linkparams_max_bw (lp, ifp-&gt;link_params-&gt;max_bw);</a>
<a name="ln732">  else</a>
<a name="ln733">    TLV_TYPE(lp-&gt;max_bw) = 0;</a>
<a name="ln734"> </a>
<a name="ln735">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_MAX_RSV_BW))</a>
<a name="ln736">    set_linkparams_max_rsv_bw (lp, ifp-&gt;link_params-&gt;max_rsv_bw);</a>
<a name="ln737">  else</a>
<a name="ln738">    TLV_TYPE(lp-&gt;max_rsv_bw) = 0;</a>
<a name="ln739"> </a>
<a name="ln740">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_UNRSV_BW))</a>
<a name="ln741">    for (i = 0; i &lt; MAX_CLASS_TYPE; i++)</a>
<a name="ln742">      set_linkparams_unrsv_bw (lp, i, ifp-&gt;link_params-&gt;unrsv_bw[i]);</a>
<a name="ln743">  else</a>
<a name="ln744">    TLV_TYPE(lp-&gt;unrsv_bw) = 0;</a>
<a name="ln745"> </a>
<a name="ln746">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_TE))</a>
<a name="ln747">    set_linkparams_te_metric(lp, ifp-&gt;link_params-&gt;te_metric);</a>
<a name="ln748">  else</a>
<a name="ln749">    TLV_TYPE(lp-&gt;te_metric) = 0;</a>
<a name="ln750"> </a>
<a name="ln751">  /* TE metric Extensions */</a>
<a name="ln752">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_DELAY))</a>
<a name="ln753">    set_linkparams_av_delay(lp, ifp-&gt;link_params-&gt;av_delay, 0);</a>
<a name="ln754">  else</a>
<a name="ln755">    TLV_TYPE(lp-&gt;av_delay) = 0;</a>
<a name="ln756"> </a>
<a name="ln757">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_MM_DELAY))</a>
<a name="ln758">    set_linkparams_mm_delay(lp, ifp-&gt;link_params-&gt;min_delay, ifp-&gt;link_params-&gt;max_delay, 0);</a>
<a name="ln759">  else</a>
<a name="ln760">    TLV_TYPE(lp-&gt;mm_delay) = 0;</a>
<a name="ln761"> </a>
<a name="ln762">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_DELAY_VAR))</a>
<a name="ln763">    set_linkparams_delay_var(lp, ifp-&gt;link_params-&gt;delay_var);</a>
<a name="ln764">  else</a>
<a name="ln765">    TLV_TYPE(lp-&gt;delay_var) = 0;</a>
<a name="ln766"> </a>
<a name="ln767">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_PKT_LOSS))</a>
<a name="ln768">    set_linkparams_pkt_loss(lp, ifp-&gt;link_params-&gt;pkt_loss, 0);</a>
<a name="ln769">  else</a>
<a name="ln770">    TLV_TYPE(lp-&gt;pkt_loss) = 0;</a>
<a name="ln771"> </a>
<a name="ln772">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_RES_BW))</a>
<a name="ln773">    set_linkparams_res_bw(lp, ifp-&gt;link_params-&gt;res_bw);</a>
<a name="ln774">  else</a>
<a name="ln775">    TLV_TYPE(lp-&gt;res_bw) = 0;</a>
<a name="ln776"> </a>
<a name="ln777">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_AVA_BW))</a>
<a name="ln778">    set_linkparams_ava_bw(lp, ifp-&gt;link_params-&gt;ava_bw);</a>
<a name="ln779">  else</a>
<a name="ln780">    TLV_TYPE(lp-&gt;ava_bw) = 0;</a>
<a name="ln781"> </a>
<a name="ln782">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_USE_BW))</a>
<a name="ln783">    set_linkparams_use_bw(lp, ifp-&gt;link_params-&gt;use_bw);</a>
<a name="ln784">  else</a>
<a name="ln785">    TLV_TYPE(lp-&gt;use_bw) = 0;</a>
<a name="ln786"> </a>
<a name="ln787">  /* RFC5392 */</a>
<a name="ln788">  if (IS_PARAM_SET(ifp-&gt;link_params, LP_RMT_AS))</a>
<a name="ln789">    {</a>
<a name="ln790">      /* Flush LSA if it engaged and was previously a STD_TE one */</a>
<a name="ln791">      if (IS_STD_TE(lp-&gt;type) &amp;&amp; CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED))</a>
<a name="ln792">        {</a>
<a name="ln793">          if (IS_DEBUG_OSPF_TE)</a>
<a name="ln794">            zlog_debug(&quot;OSPF MPLS-TE Update IF: Switch from Standard LSA to INTER-AS for %s[%d/%d]&quot;,</a>
<a name="ln795">              ifp-&gt;name, lp-&gt;flags, lp-&gt;type);</a>
<a name="ln796"> </a>
<a name="ln797">          ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);</a>
<a name="ln798">          /* Then, switch it to INTER-AS */</a>
<a name="ln799">          if (OspfMplsTE.inter_as == AS)</a>
<a name="ln800">            lp-&gt;flags = INTER_AS | FLOOD_AS;</a>
<a name="ln801">          else</a>
<a name="ln802">            {</a>
<a name="ln803">              lp-&gt;flags = INTER_AS | FLOOD_AREA;</a>
<a name="ln804">              lp-&gt;area = ospf_area_lookup_by_area_id (ospf_lookup(), OspfMplsTE.interas_areaid);</a>
<a name="ln805">            }</a>
<a name="ln806">        }</a>
<a name="ln807">      set_linkparams_inter_as(lp, ifp-&gt;link_params-&gt;rmt_ip, ifp-&gt;link_params-&gt;rmt_as);</a>
<a name="ln808">    }</a>
<a name="ln809">  else</a>
<a name="ln810">    {</a>
<a name="ln811">      if (IS_DEBUG_OSPF_TE)</a>
<a name="ln812">        zlog_debug(&quot;OSPF MPLS-TE Update IF: Switch from INTER-AS LSA to Standard for %s[%d/%d]&quot;,</a>
<a name="ln813">          ifp-&gt;name, lp-&gt;flags, lp-&gt;type);</a>
<a name="ln814"> </a>
<a name="ln815">      /* reset inter-as TE params */</a>
<a name="ln816">      /* Flush LSA if it engaged and was previously an INTER_AS one */</a>
<a name="ln817">      if (IS_INTER_AS(lp-&gt;type) &amp;&amp; CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED))</a>
<a name="ln818">        {</a>
<a name="ln819">          ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);</a>
<a name="ln820">          /* Then, switch it to Standard TE */</a>
<a name="ln821">          lp-&gt;flags = STD_TE | FLOOD_AREA;</a>
<a name="ln822">        }</a>
<a name="ln823">      unset_linkparams_inter_as (lp);</a>
<a name="ln824">    }</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">static void</a>
<a name="ln828">initialize_linkparams (struct mpls_te_link *lp)</a>
<a name="ln829">{</a>
<a name="ln830">  struct interface *ifp = lp-&gt;ifp;</a>
<a name="ln831">  struct ospf_interface *oi;</a>
<a name="ln832"> </a>
<a name="ln833">  if (IS_DEBUG_OSPF_TE)</a>
<a name="ln834">    zlog_debug(&quot;MPLS-TE(initialize_linkparams) Initialize Link Parameters for interface %s&quot;,</a>
<a name="ln835">                ifp-&gt;name);</a>
<a name="ln836"> </a>
<a name="ln837">  if ((oi = lookup_oi_by_ifp (ifp, NULL, OI_ANY)) == NULL)</a>
<a name="ln838">    {</a>
<a name="ln839">      zlog_warn(&quot;MPLS-TE(initialize_linkparams) Could not find corresponding OSPF Interface for %s&quot;,</a>
<a name="ln840">                 ifp-&gt;name);</a>
<a name="ln841">      return;</a>
<a name="ln842">    }</a>
<a name="ln843"> </a>
<a name="ln844">  /*</a>
<a name="ln845">   * Try to set initial values those can be derived from</a>
<a name="ln846">   * zebra-interface information.</a>
<a name="ln847">   */</a>
<a name="ln848">  set_linkparams_link_type (oi, lp);</a>
<a name="ln849"> </a>
<a name="ln850">  /* Set local IP addr */</a>
<a name="ln851">  set_linkparams_lclif_ipaddr (lp, oi-&gt;address-&gt;u.prefix4);</a>
<a name="ln852"> </a>
<a name="ln853">  /* Set Remote IP addr if Point to Point Interface */</a>
<a name="ln854">  if (oi-&gt;type == LINK_TYPE_SUBTLV_VALUE_PTP)</a>
<a name="ln855">    {</a>
<a name="ln856">      struct prefix *pref = CONNECTED_PREFIX(oi-&gt;connected);</a>
<a name="ln857">      if (pref != NULL)</a>
<a name="ln858">        set_linkparams_rmtif_ipaddr(lp, pref-&gt;u.prefix4);</a>
<a name="ln859">    }</a>
<a name="ln860"> </a>
<a name="ln861">  /* Keep Area information in combination with link parameters. */</a>
<a name="ln862">  lp-&gt;area = oi-&gt;area;</a>
<a name="ln863"> </a>
<a name="ln864">  return;</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">static int</a>
<a name="ln868">is_mandated_params_set (struct mpls_te_link *lp)</a>
<a name="ln869">{</a>
<a name="ln870">  int rc = 0;</a>
<a name="ln871"> </a>
<a name="ln872">  if (ntohs (OspfMplsTE.router_addr.header.type) == 0)</a>
<a name="ln873">    {</a>
<a name="ln874">      zlog_warn (&quot;MPLS-TE(is_mandated_params_set) Missing Router Address&quot;);</a>
<a name="ln875">    goto out;</a>
<a name="ln876">    }</a>
<a name="ln877"> </a>
<a name="ln878">  if (ntohs (lp-&gt;link_type.header.type) == 0)</a>
<a name="ln879">    {</a>
<a name="ln880">      zlog_warn (&quot;MPLS-TE(is_mandated_params_set) Missing Link Type&quot;);</a>
<a name="ln881">    goto out;</a>
<a name="ln882">    }</a>
<a name="ln883"> </a>
<a name="ln884">  if (!IS_INTER_AS (lp-&gt;type) &amp;&amp; (ntohs (lp-&gt;link_id.header.type) == 0))</a>
<a name="ln885">    {</a>
<a name="ln886">      zlog_warn (&quot;MPLS-TE(is_mandated_params_set) Missing Link ID&quot;);</a>
<a name="ln887">    goto out;</a>
<a name="ln888">    }</a>
<a name="ln889"> </a>
<a name="ln890">  rc = 1;</a>
<a name="ln891">out:</a>
<a name="ln892">  return rc;</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">/*------------------------------------------------------------------------*</a>
<a name="ln896"> * Followings are callback functions against generic Opaque-LSAs handling.</a>
<a name="ln897"> *------------------------------------------------------------------------*/</a>
<a name="ln898"> </a>
<a name="ln899">static int</a>
<a name="ln900">ospf_mpls_te_new_if (struct interface *ifp)</a>
<a name="ln901">{</a>
<a name="ln902">  struct mpls_te_link *new;</a>
<a name="ln903">  int rc = -1;</a>
<a name="ln904"> </a>
<a name="ln905">  if (IS_DEBUG_OSPF_TE)</a>
<a name="ln906">    zlog_debug (&quot;MPLS-TE(ospf_mpls_te_new_if) Add new %s interface %s to MPLS-TE list&quot;,</a>
<a name="ln907">                 ifp-&gt;link_params ? &quot;Active&quot; : &quot;Inactive&quot;, ifp-&gt;name);</a>
<a name="ln908"> </a>
<a name="ln909">  if (lookup_linkparams_by_ifp (ifp) != NULL)</a>
<a name="ln910">    {</a>
<a name="ln911">      zlog_warn (&quot;ospf_mpls_te_new_if: ifp(%p) already in use?&quot;, (void *)ifp);</a>
<a name="ln912">      rc = 0; /* Do nothing here. */</a>
<a name="ln913">      goto out;</a>
<a name="ln914">    }</a>
<a name="ln915"> </a>
<a name="ln916">  new = XCALLOC (MTYPE_OSPF_MPLS_TE, sizeof (struct mpls_te_link));</a>
<a name="ln917">  if (new == NULL)</a>
<a name="ln918">    {</a>
<a name="ln919">      zlog_warn (&quot;ospf_mpls_te_new_if: XMALLOC: %s&quot;, safe_strerror (errno));</a>
<a name="ln920">      goto out;</a>
<a name="ln921">    }</a>
<a name="ln922"> </a>
<a name="ln923">  new-&gt;instance = get_mpls_te_instance_value ();</a>
<a name="ln924">  new-&gt;ifp = ifp;</a>
<a name="ln925">  /* By default TE-Link is RFC3630 compatible flooding in Area and not active */</a>
<a name="ln926">  /* This default behavior will be adapted with call to ospf_mpls_te_update_if() */</a>
<a name="ln927">  new-&gt;type = STD_TE | FLOOD_AREA;</a>
<a name="ln928">  new-&gt;flags = LPFLG_LSA_INACTIVE;</a>
<a name="ln929"> </a>
<a name="ln930">  /* Initialize Link Parameters from Interface */</a>
<a name="ln931">  initialize_linkparams(new);</a>
<a name="ln932"> </a>
<a name="ln933">  /* Set TE Parameters from Interface */</a>
<a name="ln934">  update_linkparams(new);</a>
<a name="ln935"> </a>
<a name="ln936">  /* Add Link Parameters structure to the list */</a>
<a name="ln937">  listnode_add (OspfMplsTE.iflist, new);</a>
<a name="ln938"> </a>
<a name="ln939">  if (IS_DEBUG_OSPF_TE)</a>
<a name="ln940">    zlog_debug(&quot;OSPF MPLS-TE New IF: Add new LP context for %s[%d/%d]&quot;,</a>
<a name="ln941">      ifp-&gt;name, new-&gt;flags, new-&gt;type);</a>
<a name="ln942"> </a>
<a name="ln943">  /* Schedule Opaque-LSA refresh. *//* XXX */</a>
<a name="ln944"> </a>
<a name="ln945">  rc = 0;</a>
<a name="ln946">out:</a>
<a name="ln947">  return rc;</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950">static int</a>
<a name="ln951">ospf_mpls_te_del_if (struct interface *ifp)</a>
<a name="ln952">{</a>
<a name="ln953">  struct mpls_te_link *lp;</a>
<a name="ln954">  int rc = -1;</a>
<a name="ln955"> </a>
<a name="ln956">  if ((lp = lookup_linkparams_by_ifp (ifp)) != NULL)</a>
<a name="ln957">    {</a>
<a name="ln958">      struct list *iflist = OspfMplsTE.iflist;</a>
<a name="ln959"> </a>
<a name="ln960">      /* Dequeue listnode entry from the list. */</a>
<a name="ln961">      listnode_delete (iflist, lp);</a>
<a name="ln962"> </a>
<a name="ln963">      /* Avoid misjudgement in the next lookup. */</a>
<a name="ln964">      if (listcount (iflist) == 0)</a>
<a name="ln965">        iflist-&gt;head = iflist-&gt;tail = NULL;</a>
<a name="ln966"> </a>
<a name="ln967">      XFREE (MTYPE_OSPF_MPLS_TE, lp);</a>
<a name="ln968">    }</a>
<a name="ln969"> </a>
<a name="ln970">  /* Schedule Opaque-LSA refresh. *//* XXX */</a>
<a name="ln971"> </a>
<a name="ln972">  rc = 0;</a>
<a name="ln973">/*out:*/</a>
<a name="ln974">  return rc;</a>
<a name="ln975">}</a>
<a name="ln976"> </a>
<a name="ln977">/* Main initialization / update function of the MPLS TE Link context */</a>
<a name="ln978"> </a>
<a name="ln979">/* Call when interface TE Link parameters are modified */</a>
<a name="ln980">void</a>
<a name="ln981">ospf_mpls_te_update_if (struct interface *ifp)</a>
<a name="ln982">{</a>
<a name="ln983">  struct mpls_te_link *lp;</a>
<a name="ln984"> </a>
<a name="ln985">  if (IS_DEBUG_OSPF_TE)</a>
<a name="ln986">    zlog_debug (&quot;OSPF MPLS-TE: Update LSA parameters for interface %s [%s]&quot;,</a>
<a name="ln987">        ifp-&gt;name, HAS_LINK_PARAMS(ifp) ? &quot;ON&quot; : &quot;OFF&quot;);</a>
<a name="ln988"> </a>
<a name="ln989">  /* Get Link context from interface */</a>
<a name="ln990">  if ((lp = lookup_linkparams_by_ifp(ifp)) == NULL)</a>
<a name="ln991">    {</a>
<a name="ln992">      zlog_warn (&quot;OSPF MPLS-TE Update: Did not find Link Parameters context for interface %s&quot;, ifp-&gt;name);</a>
<a name="ln993">      return;</a>
<a name="ln994">    }</a>
<a name="ln995"> </a>
<a name="ln996">  /* Fulfill MPLS-TE Link TLV from Interface TE Link parameters */</a>
<a name="ln997">  if (HAS_LINK_PARAMS(ifp))</a>
<a name="ln998">    {</a>
<a name="ln999">      SET_FLAG (lp-&gt;flags, LPFLG_LSA_ACTIVE);</a>
<a name="ln1000"> </a>
<a name="ln1001">      /* Update TE parameters */</a>
<a name="ln1002">      update_linkparams(lp);</a>
<a name="ln1003"> </a>
<a name="ln1004">      /* Finally Re-Originate or Refresh Opaque LSA if MPLS_TE is enabled */</a>
<a name="ln1005">      if (OspfMplsTE.status == enabled)</a>
<a name="ln1006">        if (lp-&gt;area != NULL)</a>
<a name="ln1007">          {</a>
<a name="ln1008">            if CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED)</a>
<a name="ln1009">                ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);</a>
<a name="ln1010">            else</a>
<a name="ln1011">                ospf_mpls_te_lsa_schedule (lp, REORIGINATE_THIS_LSA);</a>
<a name="ln1012">          }</a>
<a name="ln1013">    }</a>
<a name="ln1014">  else</a>
<a name="ln1015">    {</a>
<a name="ln1016">      /* If MPLS TE is disable on this interface, flush LSA if it is already engaged */</a>
<a name="ln1017">      if CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED)</a>
<a name="ln1018">          ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);</a>
<a name="ln1019">      else</a>
<a name="ln1020">        /* Reset Activity flag */</a>
<a name="ln1021">        lp-&gt;flags = LPFLG_LSA_INACTIVE;</a>
<a name="ln1022">    }</a>
<a name="ln1023"> </a>
<a name="ln1024">  return;</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">static void</a>
<a name="ln1028">ospf_mpls_te_ism_change (struct ospf_interface *oi, int old_state)</a>
<a name="ln1029">{</a>
<a name="ln1030">  struct te_link_subtlv_link_type old_type;</a>
<a name="ln1031">  struct te_link_subtlv_link_id   old_id;</a>
<a name="ln1032">  struct mpls_te_link *lp;</a>
<a name="ln1033"> </a>
<a name="ln1034">  if ((lp = lookup_linkparams_by_ifp (oi-&gt;ifp)) == NULL)</a>
<a name="ln1035">    {</a>
<a name="ln1036">      zlog_warn (&quot;ospf_mpls_te_ism_change: Cannot get linkparams from OI(%s)?&quot;, IF_NAME (oi));</a>
<a name="ln1037">      goto out;</a>
<a name="ln1038">    }</a>
<a name="ln1039"> </a>
<a name="ln1040">  if (oi-&gt;area == NULL || oi-&gt;area-&gt;ospf == NULL)</a>
<a name="ln1041">    {</a>
<a name="ln1042">      zlog_warn (&quot;ospf_mpls_te_ism_change: Cannot refer to OSPF from OI(%s)?&quot;, IF_NAME (oi));</a>
<a name="ln1043">      goto out;</a>
<a name="ln1044">    }</a>
<a name="ln1045">#ifdef notyet</a>
<a name="ln1046">  if ((lp-&gt;area != NULL</a>
<a name="ln1047">  &amp;&amp;   ! IPV4_ADDR_SAME (&amp;lp-&gt;area-&gt;area_id, &amp;oi-&gt;area-&gt;area_id))</a>
<a name="ln1048">  || (lp-&gt;area != NULL &amp;&amp; oi-&gt;area == NULL))</a>
<a name="ln1049">    {</a>
<a name="ln1050">      /* How should we consider this case? */</a>
<a name="ln1051">      zlog_warn (&quot;MPLS-TE: Area for OI(%s) has changed to [%s], flush previous LSAs&quot;,</a>
<a name="ln1052">         IF_NAME (oi), oi-&gt;area ? inet_ntoa (oi-&gt;area-&gt;area_id) : &quot;N/A&quot;);</a>
<a name="ln1053">      ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);</a>
<a name="ln1054">    }</a>
<a name="ln1055">#endif</a>
<a name="ln1056">  /* Keep Area information in combination with linkparams. */</a>
<a name="ln1057">  lp-&gt;area = oi-&gt;area;</a>
<a name="ln1058"> </a>
<a name="ln1059">  /* Keep interface MPLS-TE status */</a>
<a name="ln1060">  lp-&gt;flags = HAS_LINK_PARAMS(oi-&gt;ifp);</a>
<a name="ln1061"> </a>
<a name="ln1062">  switch (oi-&gt;state)</a>
<a name="ln1063">    {</a>
<a name="ln1064">    case ISM_PointToPoint:</a>
<a name="ln1065">    case ISM_DROther:</a>
<a name="ln1066">    case ISM_Backup:</a>
<a name="ln1067">    case ISM_DR:</a>
<a name="ln1068">      old_type = lp-&gt;link_type;</a>
<a name="ln1069">      old_id   = lp-&gt;link_id;</a>
<a name="ln1070"> </a>
<a name="ln1071">      /* Set Link type, Link ID, Local and Remote IP addr */</a>
<a name="ln1072">      set_linkparams_link_type (oi, lp);</a>
<a name="ln1073">      set_linkparams_link_id (oi, lp);</a>
<a name="ln1074">      set_linkparams_lclif_ipaddr (lp, oi-&gt;address-&gt;u.prefix4);</a>
<a name="ln1075"> </a>
<a name="ln1076">      if (oi-&gt;type == LINK_TYPE_SUBTLV_VALUE_PTP)</a>
<a name="ln1077">        {</a>
<a name="ln1078">          struct prefix *pref = CONNECTED_PREFIX(oi-&gt;connected);</a>
<a name="ln1079">          if (pref != NULL)</a>
<a name="ln1080">            set_linkparams_rmtif_ipaddr(lp, pref-&gt;u.prefix4);</a>
<a name="ln1081">        }</a>
<a name="ln1082"> </a>
<a name="ln1083">      /* Update TE parameters */</a>
<a name="ln1084">      update_linkparams(lp);</a>
<a name="ln1085"> </a>
<a name="ln1086">      /* Try to Schedule LSA */</a>
<a name="ln1087">      if ((ntohs (old_type.header.type) != ntohs (lp-&gt;link_type.header.type)</a>
<a name="ln1088">      ||   old_type.link_type.value     != lp-&gt;link_type.link_type.value)</a>
<a name="ln1089">      ||  (ntohs (old_id.header.type)   != ntohs (lp-&gt;link_id.header.type)</a>
<a name="ln1090">              || ntohl (old_id.value.s_addr) !=</a>
<a name="ln1091">              ntohl (lp-&gt;link_id.value.s_addr)))</a>
<a name="ln1092">        {</a>
<a name="ln1093">          if CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED)</a>
<a name="ln1094">            ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);</a>
<a name="ln1095">          else</a>
<a name="ln1096">            ospf_mpls_te_lsa_schedule (lp, REORIGINATE_THIS_LSA);</a>
<a name="ln1097"> </a>
<a name="ln1098">        }</a>
<a name="ln1099">      break;</a>
<a name="ln1100">    default:</a>
<a name="ln1101">      lp-&gt;link_type.header.type = htons (0);</a>
<a name="ln1102">      lp-&gt;link_id.header.type   = htons (0);</a>
<a name="ln1103"> </a>
<a name="ln1104">      if CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED)</a>
<a name="ln1105">        ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);</a>
<a name="ln1106">      break;</a>
<a name="ln1107">    }</a>
<a name="ln1108"> </a>
<a name="ln1109">out:</a>
<a name="ln1110">  return;</a>
<a name="ln1111"> </a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114">static void</a>
<a name="ln1115">ospf_mpls_te_nsm_change (struct ospf_neighbor *nbr, int old_state)</a>
<a name="ln1116">{</a>
<a name="ln1117">  /* Nothing to do here */</a>
<a name="ln1118">  return;</a>
<a name="ln1119">}</a>
<a name="ln1120"> </a>
<a name="ln1121">/*------------------------------------------------------------------------*</a>
<a name="ln1122"> * Followings are OSPF protocol processing functions for MPLS-TE.</a>
<a name="ln1123"> *------------------------------------------------------------------------*/</a>
<a name="ln1124"> </a>
<a name="ln1125">static void</a>
<a name="ln1126">build_tlv_header (struct stream *s, struct te_tlv_header *tlvh)</a>
<a name="ln1127">{</a>
<a name="ln1128">  stream_put (s, tlvh, sizeof (struct te_tlv_header));</a>
<a name="ln1129">  return;</a>
<a name="ln1130">}</a>
<a name="ln1131"> </a>
<a name="ln1132">static void</a>
<a name="ln1133">build_router_tlv (struct stream *s)</a>
<a name="ln1134">{</a>
<a name="ln1135">  struct te_tlv_header *tlvh = &amp;OspfMplsTE.router_addr.header;</a>
<a name="ln1136">  if (ntohs (tlvh-&gt;type) != 0)</a>
<a name="ln1137">    {</a>
<a name="ln1138">      build_tlv_header (s, tlvh);</a>
<a name="ln1139">      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));</a>
<a name="ln1140">    }</a>
<a name="ln1141">  return;</a>
<a name="ln1142">}</a>
<a name="ln1143"> </a>
<a name="ln1144">static void</a>
<a name="ln1145">build_link_subtlv (struct stream *s, struct te_tlv_header *tlvh)</a>
<a name="ln1146">    {</a>
<a name="ln1147"> </a>
<a name="ln1148">  if ((tlvh != NULL) &amp;&amp; (ntohs (tlvh-&gt;type) != 0))</a>
<a name="ln1149">    {</a>
<a name="ln1150">      build_tlv_header (s, tlvh);</a>
<a name="ln1151">      stream_put (s, tlvh+1, TLV_BODY_SIZE (tlvh));</a>
<a name="ln1152">    }</a>
<a name="ln1153">  return;</a>
<a name="ln1154">}</a>
<a name="ln1155"> </a>
<a name="ln1156">static void</a>
<a name="ln1157">build_link_tlv (struct stream *s, struct mpls_te_link *lp)</a>
<a name="ln1158">{</a>
<a name="ln1159">  set_linkparams_link_header (lp);</a>
<a name="ln1160">  build_tlv_header (s, &amp;lp-&gt;link_header.header);</a>
<a name="ln1161"> </a>
<a name="ln1162">  build_link_subtlv (s, &amp;lp-&gt;link_type.header);</a>
<a name="ln1163">  build_link_subtlv (s, &amp;lp-&gt;link_id.header);</a>
<a name="ln1164">  build_link_subtlv (s, &amp;lp-&gt;lclif_ipaddr.header);</a>
<a name="ln1165">  build_link_subtlv (s, &amp;lp-&gt;rmtif_ipaddr.header);</a>
<a name="ln1166">  build_link_subtlv (s, &amp;lp-&gt;te_metric.header);</a>
<a name="ln1167">  build_link_subtlv (s, &amp;lp-&gt;max_bw.header);</a>
<a name="ln1168">  build_link_subtlv (s, &amp;lp-&gt;max_rsv_bw.header);</a>
<a name="ln1169">  build_link_subtlv (s, &amp;lp-&gt;unrsv_bw.header);</a>
<a name="ln1170">  build_link_subtlv (s, &amp;lp-&gt;rsc_clsclr.header);</a>
<a name="ln1171">  build_link_subtlv (s, &amp;lp-&gt;lrrid.header);</a>
<a name="ln1172">  build_link_subtlv (s, &amp;lp-&gt;llri.header);</a>
<a name="ln1173">  build_link_subtlv (s, &amp;lp-&gt;rip.header);</a>
<a name="ln1174">  build_link_subtlv (s, &amp;lp-&gt;ras.header);</a>
<a name="ln1175">  build_link_subtlv (s, &amp;lp-&gt;av_delay.header);</a>
<a name="ln1176">  build_link_subtlv (s, &amp;lp-&gt;mm_delay.header);</a>
<a name="ln1177">  build_link_subtlv (s, &amp;lp-&gt;delay_var.header);</a>
<a name="ln1178">  build_link_subtlv (s, &amp;lp-&gt;pkt_loss.header);</a>
<a name="ln1179">  build_link_subtlv (s, &amp;lp-&gt;res_bw.header);</a>
<a name="ln1180">  build_link_subtlv (s, &amp;lp-&gt;ava_bw.header);</a>
<a name="ln1181">  build_link_subtlv (s, &amp;lp-&gt;res_bw.header);</a>
<a name="ln1182"> </a>
<a name="ln1183">  return;</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186">static void</a>
<a name="ln1187">ospf_mpls_te_lsa_body_set (struct stream *s, struct mpls_te_link *lp)</a>
<a name="ln1188">{</a>
<a name="ln1189">  /*</a>
<a name="ln1190">   * The router address TLV is type 1, and ...</a>
<a name="ln1191">   *                                      It must appear in exactly one</a>
<a name="ln1192">   * Traffic Engineering LSA originated by a router.</a>
<a name="ln1193">   */</a>
<a name="ln1194">  build_router_tlv (s);</a>
<a name="ln1195"> </a>
<a name="ln1196">  /*</a>
<a name="ln1197">   * Only one Link TLV shall be carried in each LSA, allowing for fine</a>
<a name="ln1198">   * granularity changes in topology.</a>
<a name="ln1199">   */</a>
<a name="ln1200">  build_link_tlv (s, lp);</a>
<a name="ln1201">  return;</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204">/* Create new opaque-LSA. */</a>
<a name="ln1205">static struct ospf_lsa *</a>
<a name="ln1206">ospf_mpls_te_lsa_new (struct ospf_area *area, struct mpls_te_link *lp)</a>
<a name="ln1207">{</a>
<a name="ln1208">  struct stream *s;</a>
<a name="ln1209">  struct lsa_header *lsah;</a>
<a name="ln1210">  struct ospf_lsa *new = NULL;</a>
<a name="ln1211">  u_char options, lsa_type = 0;</a>
<a name="ln1212">  struct in_addr lsa_id;</a>
<a name="ln1213">  u_int32_t tmp;</a>
<a name="ln1214">  u_int16_t length;</a>
<a name="ln1215"> </a>
<a name="ln1216">  /* Create a stream for LSA. */</a>
<a name="ln1217">  if ((s = stream_new (OSPF_MAX_LSA_SIZE)) == NULL)</a>
<a name="ln1218">    {</a>
<a name="ln1219">      zlog_warn (&quot;ospf_mpls_te_lsa_new: stream_new() ?&quot;);</a>
<a name="ln1220">      goto out;</a>
<a name="ln1221">    }</a>
<a name="ln1222">  lsah = (struct lsa_header *) STREAM_DATA (s);</a>
<a name="ln1223"> </a>
<a name="ln1224">  options = OSPF_OPTION_O;      /* Don't forget this :-) */</a>
<a name="ln1225"> </a>
<a name="ln1226">  /* Set opaque-LSA header fields depending of the type of RFC */</a>
<a name="ln1227">  if (IS_INTER_AS (lp-&gt;type))</a>
<a name="ln1228">    {</a>
<a name="ln1229">      if IS_FLOOD_AS (lp-&gt;type)</a>
<a name="ln1230">        {</a>
<a name="ln1231">          options |= OSPF_OPTION_E;     /* Enable AS external as we flood Inter-AS with Opaque Type 11 */</a>
<a name="ln1232">          lsa_type = OSPF_OPAQUE_AS_LSA;</a>
<a name="ln1233">        }</a>
<a name="ln1234">      else</a>
<a name="ln1235">        {</a>
<a name="ln1236">          options |= LSA_OPTIONS_GET (area);    /* Get area default option */</a>
<a name="ln1237">          options |= LSA_OPTIONS_NSSA_GET (area);</a>
<a name="ln1238">          lsa_type = OSPF_OPAQUE_AREA_LSA;</a>
<a name="ln1239">        }</a>
<a name="ln1240">      tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_INTER_AS_LSA, lp-&gt;instance);</a>
<a name="ln1241">      lsa_id.s_addr = htonl (tmp);</a>
<a name="ln1242"> </a>
<a name="ln1243">      struct ospf *top = ospf_lookup ();</a>
<a name="ln1244"> </a>
<a name="ln1245">      lsa_header_set (s, options, lsa_type, lsa_id, top-&gt;router_id);</a>
<a name="ln1246">    }</a>
<a name="ln1247">  else</a>
<a name="ln1248">    {</a>
<a name="ln1249">      options |= LSA_OPTIONS_GET (area);        /* Get area default option */</a>
<a name="ln1250">      options |= LSA_OPTIONS_NSSA_GET (area);</a>
<a name="ln1251">      lsa_type = OSPF_OPAQUE_AREA_LSA;</a>
<a name="ln1252">      tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA, lp-&gt;instance);</a>
<a name="ln1253">      lsa_id.s_addr = htonl (tmp);</a>
<a name="ln1254">      lsa_header_set (s, options, lsa_type, lsa_id, area-&gt;ospf-&gt;router_id);</a>
<a name="ln1255">    }</a>
<a name="ln1256"> </a>
<a name="ln1257">  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))</a>
<a name="ln1258">    zlog_debug (&quot;LSA[Type%d:%s]: Create an Opaque-LSA/MPLS-TE instance&quot;,</a>
<a name="ln1259">                lsa_type, inet_ntoa (lsa_id));</a>
<a name="ln1260"> </a>
<a name="ln1261">  /* Set opaque-LSA body fields. */</a>
<a name="ln1262">  ospf_mpls_te_lsa_body_set (s, lp);</a>
<a name="ln1263"> </a>
<a name="ln1264">  /* Set length. */</a>
<a name="ln1265">  length = stream_get_endp (s);</a>
<a name="ln1266">  lsah-&gt;length = htons (length);</a>
<a name="ln1267"> </a>
<a name="ln1268">  /* Now, create an OSPF LSA instance. */</a>
<a name="ln1269">  if ((new = ospf_lsa_new ()) == NULL)</a>
<a name="ln1270">    {</a>
<a name="ln1271">      zlog_warn (&quot;ospf_mpls_te_lsa_new: ospf_lsa_new() ?&quot;);</a>
<a name="ln1272">      stream_free (s);</a>
<a name="ln1273">      goto out;</a>
<a name="ln1274">    }</a>
<a name="ln1275">  if ((new-&gt;data = ospf_lsa_data_new (length)) == NULL)</a>
<a name="ln1276">    {</a>
<a name="ln1277">      zlog_warn (&quot;ospf_mpls_te_lsa_new: ospf_lsa_data_new() ?&quot;);</a>
<a name="ln1278">      ospf_lsa_unlock (&amp;new);</a>
<a name="ln1279">      new = NULL;</a>
<a name="ln1280">      stream_free (s);</a>
<a name="ln1281">      goto out;</a>
<a name="ln1282">    }</a>
<a name="ln1283"> </a>
<a name="ln1284">  new-&gt;area = area;</a>
<a name="ln1285">  SET_FLAG (new-&gt;flags, OSPF_LSA_SELF);</a>
<a name="ln1286">  memcpy (new-&gt;data, lsah, length);</a>
<a name="ln1287">  stream_free (s);</a>
<a name="ln1288"> </a>
<a name="ln1289">out:</a>
<a name="ln1290">  return new;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293">static int</a>
<a name="ln1294">ospf_mpls_te_lsa_originate1 (struct ospf_area *area, struct mpls_te_link *lp)</a>
<a name="ln1295">{</a>
<a name="ln1296">  struct ospf_lsa *new;</a>
<a name="ln1297">  int rc = -1;</a>
<a name="ln1298"> </a>
<a name="ln1299">  /* Create new Opaque-LSA/MPLS-TE instance. */</a>
<a name="ln1300">  if ((new = ospf_mpls_te_lsa_new (area, lp)) == NULL)</a>
<a name="ln1301">    {</a>
<a name="ln1302">      zlog_warn (&quot;ospf_mpls_te_lsa_originate1: ospf_mpls_te_lsa_new() ?&quot;);</a>
<a name="ln1303">      goto out;</a>
<a name="ln1304">    }</a>
<a name="ln1305"> </a>
<a name="ln1306">  /* Install this LSA into LSDB. */</a>
<a name="ln1307">  if (ospf_lsa_install (area-&gt;ospf, NULL/*oi*/, new) == NULL)</a>
<a name="ln1308">    {</a>
<a name="ln1309">      zlog_warn (&quot;ospf_mpls_te_lsa_originate1: ospf_lsa_install() ?&quot;);</a>
<a name="ln1310">      ospf_lsa_unlock (&amp;new);</a>
<a name="ln1311">      goto out;</a>
<a name="ln1312">    }</a>
<a name="ln1313"> </a>
<a name="ln1314">  /* Now this link-parameter entry has associated LSA. */</a>
<a name="ln1315">  SET_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED);</a>
<a name="ln1316">  /* Update new LSA origination count. */</a>
<a name="ln1317">  area-&gt;ospf-&gt;lsa_originate_count++;</a>
<a name="ln1318"> </a>
<a name="ln1319">  /* Flood new LSA through area. */</a>
<a name="ln1320">  ospf_flood_through_area (area, NULL/*nbr*/, new);</a>
<a name="ln1321"> </a>
<a name="ln1322">  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))</a>
<a name="ln1323">    {</a>
<a name="ln1324">      char area_id[INET_ADDRSTRLEN];</a>
<a name="ln1325">      strcpy (area_id, inet_ntoa (area-&gt;area_id));</a>
<a name="ln1326">      zlog_debug (&quot;LSA[Type%d:%s]: Originate Opaque-LSA/MPLS-TE: Area(%s), Link(%s)&quot;,</a>
<a name="ln1327">                   new-&gt;data-&gt;type, inet_ntoa (new-&gt;data-&gt;id), area_id, lp-&gt;ifp-&gt;name);</a>
<a name="ln1328">      ospf_lsa_header_dump (new-&gt;data);</a>
<a name="ln1329">    }</a>
<a name="ln1330"> </a>
<a name="ln1331">  rc = 0;</a>
<a name="ln1332">out:</a>
<a name="ln1333">  return rc;</a>
<a name="ln1334">}</a>
<a name="ln1335"> </a>
<a name="ln1336">static int</a>
<a name="ln1337">ospf_mpls_te_lsa_originate_area (void *arg)</a>
<a name="ln1338">{</a>
<a name="ln1339">  struct ospf_area *area = (struct ospf_area *) arg;</a>
<a name="ln1340">  struct listnode *node, *nnode;</a>
<a name="ln1341">  struct mpls_te_link *lp;</a>
<a name="ln1342">  int rc = -1;</a>
<a name="ln1343"> </a>
<a name="ln1344">  if (OspfMplsTE.status == disabled)</a>
<a name="ln1345">    {</a>
<a name="ln1346">      zlog_info (&quot;ospf_mpls_te_lsa_originate_area: MPLS-TE is disabled now.&quot;);</a>
<a name="ln1347">      rc = 0; /* This is not an error case. */</a>
<a name="ln1348">      goto out;</a>
<a name="ln1349">    }</a>
<a name="ln1350"> </a>
<a name="ln1351">  for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))</a>
<a name="ln1352">    {</a>
<a name="ln1353">      /* Process only enabled LSA with area scope flooding */</a>
<a name="ln1354">      if (!CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ACTIVE) || IS_FLOOD_AS (lp-&gt;type))</a>
<a name="ln1355">        continue;</a>
<a name="ln1356"> </a>
<a name="ln1357">      if (lp-&gt;area == NULL)</a>
<a name="ln1358">        continue;</a>
<a name="ln1359"> </a>
<a name="ln1360">      if (! IPV4_ADDR_SAME (&amp;lp-&gt;area-&gt;area_id, &amp;area-&gt;area_id))</a>
<a name="ln1361">        continue;</a>
<a name="ln1362"> </a>
<a name="ln1363">      if CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED)</a>
<a name="ln1364">        {</a>
<a name="ln1365">          if CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_FORCED_REFRESH)</a>
<a name="ln1366">            {</a>
<a name="ln1367">              UNSET_FLAG (lp-&gt;flags, LPFLG_LSA_FORCED_REFRESH);</a>
<a name="ln1368">              zlog_warn (&quot;OSPF MPLS-TE (ospf_mpls_te_lsa_originate_area): Refresh instead of Originate&quot;);</a>
<a name="ln1369">              ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);</a>
<a name="ln1370">            }</a>
<a name="ln1371">          continue;</a>
<a name="ln1372">        }</a>
<a name="ln1373">      if (! is_mandated_params_set (lp))</a>
<a name="ln1374">        {</a>
<a name="ln1375">          zlog_warn (&quot;ospf_mpls_te_lsa_originate_area: Link(%s) lacks some mandated MPLS-TE parameters.&quot;,</a>
<a name="ln1376">              lp-&gt;ifp ? lp-&gt;ifp-&gt;name : &quot;?&quot;);</a>
<a name="ln1377">          continue;</a>
<a name="ln1378">        }</a>
<a name="ln1379"> </a>
<a name="ln1380">      /* Ok, let's try to originate an LSA for this area and Link. */</a>
<a name="ln1381">      if (IS_DEBUG_OSPF_TE)</a>
<a name="ln1382">        zlog_debug (&quot;MPLS-TE(ospf_mpls_te_lsa_originate_area) Let's finally reoriginate the LSA %d through the Area %s for Link %s&quot;,</a>
<a name="ln1383">                     lp-&gt;instance, inet_ntoa (area-&gt;area_id), lp-&gt;ifp ? lp-&gt;ifp-&gt;name : &quot;?&quot;);</a>
<a name="ln1384">      if (ospf_mpls_te_lsa_originate1 (area, lp) != 0)</a>
<a name="ln1385">        goto out;</a>
<a name="ln1386">    }</a>
<a name="ln1387"> </a>
<a name="ln1388">  rc = 0;</a>
<a name="ln1389">out:</a>
<a name="ln1390">  return rc;</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393">static int</a>
<a name="ln1394">ospf_mpls_te_lsa_originate2 (struct ospf *top, struct mpls_te_link *lp)</a>
<a name="ln1395">{</a>
<a name="ln1396">  struct ospf_lsa *new;</a>
<a name="ln1397">  int rc = -1;</a>
<a name="ln1398"> </a>
<a name="ln1399">  /* Create new Opaque-LSA/Inter-AS instance. */</a>
<a name="ln1400">  if ((new = ospf_mpls_te_lsa_new (NULL, lp)) == NULL)</a>
<a name="ln1401">    {</a>
<a name="ln1402">      zlog_warn (&quot;ospf_mpls_te_lsa_originate2: ospf_router_info_lsa_new() ?&quot;);</a>
<a name="ln1403">      goto out;</a>
<a name="ln1404">    }</a>
<a name="ln1405"> </a>
<a name="ln1406">  /* Install this LSA into LSDB. */</a>
<a name="ln1407">  if (ospf_lsa_install (top, NULL /*oi */ , new) == NULL)</a>
<a name="ln1408">    {</a>
<a name="ln1409">      zlog_warn (&quot;ospf_mpls_te_lsa_originate2: ospf_lsa_install() ?&quot;);</a>
<a name="ln1410">      ospf_lsa_unlock (&amp;new);</a>
<a name="ln1411">      goto out;</a>
<a name="ln1412">    }</a>
<a name="ln1413"> </a>
<a name="ln1414">  /* Now this Router Info parameter entry has associated LSA. */</a>
<a name="ln1415">  SET_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED);</a>
<a name="ln1416">  /* Update new LSA origination count. */</a>
<a name="ln1417">  top-&gt;lsa_originate_count++;</a>
<a name="ln1418"> </a>
<a name="ln1419">  /* Flood new LSA through AS. */</a>
<a name="ln1420">  ospf_flood_through_as (top, NULL /*nbr */ , new);</a>
<a name="ln1421"> </a>
<a name="ln1422">  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))</a>
<a name="ln1423">    {</a>
<a name="ln1424">      zlog_debug (&quot;LSA[Type%d:%s]: Originate Opaque-LSA/MPLS-TE Inter-AS&quot;,</a>
<a name="ln1425">                  new-&gt;data-&gt;type, inet_ntoa (new-&gt;data-&gt;id));</a>
<a name="ln1426">      ospf_lsa_header_dump (new-&gt;data);</a>
<a name="ln1427">    }</a>
<a name="ln1428"> </a>
<a name="ln1429">  rc = 0;</a>
<a name="ln1430">out:return rc;</a>
<a name="ln1431">}</a>
<a name="ln1432"> </a>
<a name="ln1433">static int</a>
<a name="ln1434">ospf_mpls_te_lsa_originate_as (void *arg)</a>
<a name="ln1435">{</a>
<a name="ln1436">  struct ospf *top;</a>
<a name="ln1437">  struct ospf_area *area;</a>
<a name="ln1438">  struct listnode *node, *nnode;</a>
<a name="ln1439">  struct mpls_te_link *lp;</a>
<a name="ln1440">  int rc = -1;</a>
<a name="ln1441"> </a>
<a name="ln1442">  if ((OspfMplsTE.status == disabled) || (OspfMplsTE.inter_as == Disable))</a>
<a name="ln1443">    {</a>
<a name="ln1444">      zlog_info</a>
<a name="ln1445">        (&quot;ospf_mpls_te_lsa_originate_as: MPLS-TE Inter-AS is disabled for now.&quot;);</a>
<a name="ln1446">      rc = 0;                   /* This is not an error case. */</a>
<a name="ln1447">      goto out;</a>
<a name="ln1448">    }</a>
<a name="ln1449"> </a>
<a name="ln1450">  for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))</a>
<a name="ln1451">    {</a>
<a name="ln1452">      /* Process only enabled INTER_AS Links or Pseudo-Links */</a>
<a name="ln1453">      if (!CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ACTIVE) || !IS_INTER_AS (lp-&gt;type))</a>
<a name="ln1454">        continue;</a>
<a name="ln1455"> </a>
<a name="ln1456">      if CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED)</a>
<a name="ln1457">        {</a>
<a name="ln1458">          if CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_FORCED_REFRESH)</a>
<a name="ln1459">            {</a>
<a name="ln1460">              UNSET_FLAG (lp-&gt;flags, LPFLG_LSA_FORCED_REFRESH);</a>
<a name="ln1461">              ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);</a>
<a name="ln1462">            }</a>
<a name="ln1463">          continue;</a>
<a name="ln1464">        }</a>
<a name="ln1465">      if (!is_mandated_params_set (lp))</a>
<a name="ln1466">        {</a>
<a name="ln1467">          zlog_warn (&quot;ospf_mpls_te_lsa_originate_as: Link(%s) lacks some mandated MPLS-TE parameters.&quot;,</a>
<a name="ln1468">             lp-&gt;ifp ? lp-&gt;ifp-&gt;name : &quot;?&quot;);</a>
<a name="ln1469">          continue;</a>
<a name="ln1470">        }</a>
<a name="ln1471"> </a>
<a name="ln1472">      /* Ok, let's try to originate an LSA for this AS and Link. */</a>
<a name="ln1473">      if (IS_DEBUG_OSPF_TE)</a>
<a name="ln1474">        zlog_debug (&quot;MPLS-TE(ospf_mpls_te_lsa_originate_as) Let's finally re-originate the Inter-AS LSA %d through the %s for Link %s&quot;,</a>
<a name="ln1475">                    lp-&gt;instance, IS_FLOOD_AS (lp-&gt;type) ? &quot;AS&quot; : &quot;Area&quot;, lp-&gt;ifp ? lp-&gt;ifp-&gt;name : &quot;Unknown&quot;);</a>
<a name="ln1476"> </a>
<a name="ln1477">      if (IS_FLOOD_AS (lp-&gt;type))</a>
<a name="ln1478">        {</a>
<a name="ln1479">          top = (struct ospf *) arg;</a>
<a name="ln1480">          rc = ospf_mpls_te_lsa_originate2 (top, lp);</a>
<a name="ln1481">        }</a>
<a name="ln1482">      else</a>
<a name="ln1483">        {</a>
<a name="ln1484">          area = (struct ospf_area *) arg;</a>
<a name="ln1485">          rc = ospf_mpls_te_lsa_originate1 (area, lp);</a>
<a name="ln1486">        }</a>
<a name="ln1487">    }</a>
<a name="ln1488"> </a>
<a name="ln1489">  rc = 0;</a>
<a name="ln1490">out:return rc;</a>
<a name="ln1491">}</a>
<a name="ln1492"> </a>
<a name="ln1493">static struct ospf_lsa *</a>
<a name="ln1494">ospf_mpls_te_lsa_refresh (struct ospf_lsa *lsa)</a>
<a name="ln1495">{</a>
<a name="ln1496">  struct mpls_te_link *lp;</a>
<a name="ln1497">  struct ospf_area *area = lsa-&gt;area;</a>
<a name="ln1498">  struct ospf *top;</a>
<a name="ln1499">  struct ospf_lsa *new = NULL;</a>
<a name="ln1500"> </a>
<a name="ln1501">  if (OspfMplsTE.status == disabled)</a>
<a name="ln1502">    {</a>
<a name="ln1503">      /*</a>
<a name="ln1504">       * This LSA must have flushed before due to MPLS-TE status change.</a>
<a name="ln1505">       * It seems a slip among routers in the routing domain.</a>
<a name="ln1506">       */</a>
<a name="ln1507">      zlog_info (&quot;ospf_mpls_te_lsa_refresh: MPLS-TE is disabled now.&quot;);</a>
<a name="ln1508">      lsa-&gt;data-&gt;ls_age = htons (OSPF_LSA_MAXAGE); /* Flush it anyway. */</a>
<a name="ln1509">    }</a>
<a name="ln1510"> </a>
<a name="ln1511">  /* At first, resolve lsa/lp relationship. */</a>
<a name="ln1512">  if ((lp = lookup_linkparams_by_instance (lsa)) == NULL)</a>
<a name="ln1513">    {</a>
<a name="ln1514">      zlog_warn (&quot;ospf_mpls_te_lsa_refresh: Invalid parameter?&quot;);</a>
<a name="ln1515">      lsa-&gt;data-&gt;ls_age = htons (OSPF_LSA_MAXAGE); /* Flush it anyway. */</a>
<a name="ln1516">    }</a>
<a name="ln1517"> </a>
<a name="ln1518">  /* Check if lp was not disable in the interval */</a>
<a name="ln1519">  if (!CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ACTIVE))</a>
<a name="ln1520">    {</a>
<a name="ln1521">      zlog_warn (&quot;ospf_mpls_te_lsa_refresh: lp was disabled: Flush it!&quot;);</a>
<a name="ln1522">      lsa-&gt;data-&gt;ls_age = htons (OSPF_LSA_MAXAGE); /* Flush it anyway. */</a>
<a name="ln1523">    }</a>
<a name="ln1524"> </a>
<a name="ln1525">  /* If the lsa's age reached to MaxAge, start flushing procedure. */</a>
<a name="ln1526">  if (IS_LSA_MAXAGE (lsa))</a>
<a name="ln1527">    {</a>
<a name="ln1528">      if (lp)</a>
<a name="ln1529">        UNSET_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED);</a>
<a name="ln1530">      ospf_opaque_lsa_flush_schedule (lsa);</a>
<a name="ln1531">      goto out;</a>
<a name="ln1532">    }</a>
<a name="ln1533"> </a>
<a name="ln1534">  /* Create new Opaque-LSA/MPLS-TE instance. */</a>
<a name="ln1535">  if ((new = ospf_mpls_te_lsa_new (area, lp)) == NULL)</a>
<a name="ln1536">    {</a>
<a name="ln1537">      zlog_warn (&quot;ospf_mpls_te_lsa_refresh: ospf_mpls_te_lsa_new() ?&quot;);</a>
<a name="ln1538">      goto out;</a>
<a name="ln1539">    }</a>
<a name="ln1540">  new-&gt;data-&gt;ls_seqnum = lsa_seqnum_increment (lsa);</a>
<a name="ln1541"> </a>
<a name="ln1542">  /* Install this LSA into LSDB. */</a>
<a name="ln1543">  /* Given &quot;lsa&quot; will be freed in the next function. */</a>
<a name="ln1544">  /* As area could be NULL i.e. when using OPAQUE_LSA_AS, we prefer to use ospf_lookup() to get ospf instance */</a>
<a name="ln1545">  if (area)</a>
<a name="ln1546">    top = area-&gt;ospf;</a>
<a name="ln1547">  else</a>
<a name="ln1548">    top = ospf_lookup ();</a>
<a name="ln1549"> </a>
<a name="ln1550">  if (ospf_lsa_install (top, NULL /*oi */ , new) == NULL)</a>
<a name="ln1551">    {</a>
<a name="ln1552">      zlog_warn (&quot;ospf_mpls_te_lsa_refresh: ospf_lsa_install() ?&quot;);</a>
<a name="ln1553">      ospf_lsa_unlock (&amp;new);</a>
<a name="ln1554">      goto out;</a>
<a name="ln1555">    }</a>
<a name="ln1556"> </a>
<a name="ln1557">  /* Flood updated LSA through AS or Area depending of the RFC of the link */</a>
<a name="ln1558">  if (IS_FLOOD_AS (lp-&gt;type))</a>
<a name="ln1559">    ospf_flood_through_as (top, NULL, new);</a>
<a name="ln1560">  else</a>
<a name="ln1561">    ospf_flood_through_area (area, NULL/*nbr*/, new);</a>
<a name="ln1562"> </a>
<a name="ln1563">  /* Debug logging. */</a>
<a name="ln1564">  if (IS_DEBUG_OSPF (lsa, LSA_GENERATE))</a>
<a name="ln1565">    {</a>
<a name="ln1566">      zlog_debug (&quot;LSA[Type%d:%s]: Refresh Opaque-LSA/MPLS-TE&quot;,</a>
<a name="ln1567">		 new-&gt;data-&gt;type, inet_ntoa (new-&gt;data-&gt;id));</a>
<a name="ln1568">      ospf_lsa_header_dump (new-&gt;data);</a>
<a name="ln1569">    }</a>
<a name="ln1570"> </a>
<a name="ln1571">out:</a>
<a name="ln1572">  return new;</a>
<a name="ln1573">}</a>
<a name="ln1574"> </a>
<a name="ln1575">void</a>
<a name="ln1576">ospf_mpls_te_lsa_schedule (struct mpls_te_link *lp, opcode_t opcode)</a>
<a name="ln1577">{</a>
<a name="ln1578">  struct ospf_lsa lsa;</a>
<a name="ln1579">  struct lsa_header lsah;</a>
<a name="ln1580">  struct ospf *top;</a>
<a name="ln1581">  u_int32_t tmp;</a>
<a name="ln1582"> </a>
<a name="ln1583">  memset (&amp;lsa, 0, sizeof (lsa));</a>
<a name="ln1584">  memset (&amp;lsah, 0, sizeof (lsah));</a>
<a name="ln1585">  top = ospf_lookup ();</a>
<a name="ln1586"> </a>
<a name="ln1587">  /* Check if the pseudo link is ready to flood */</a>
<a name="ln1588">  if (!(CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ACTIVE))</a>
<a name="ln1589">      || !(IS_FLOOD_AREA (lp-&gt;type) || IS_FLOOD_AS (lp-&gt;type))) {</a>
<a name="ln1590">    return;</a>
<a name="ln1591">  }</a>
<a name="ln1592"> </a>
<a name="ln1593">  lsa.area = lp-&gt;area;</a>
<a name="ln1594">  lsa.data = &amp;lsah;</a>
<a name="ln1595">  if (IS_FLOOD_AS (lp-&gt;type))</a>
<a name="ln1596">    {</a>
<a name="ln1597">      lsah.type = OSPF_OPAQUE_AS_LSA;</a>
<a name="ln1598">      tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_INTER_AS_LSA, lp-&gt;instance);</a>
<a name="ln1599">      lsah.id.s_addr = htonl (tmp);</a>
<a name="ln1600">    }</a>
<a name="ln1601">  else</a>
<a name="ln1602">    {</a>
<a name="ln1603">      lsah.type = OSPF_OPAQUE_AREA_LSA;</a>
<a name="ln1604">      if (IS_INTER_AS (lp-&gt;type))</a>
<a name="ln1605">        {</a>
<a name="ln1606">          /* Set the area context if not know */</a>
<a name="ln1607">          if (lp-&gt;area == NULL)</a>
<a name="ln1608">            lp-&gt;area = ospf_area_lookup_by_area_id (top, OspfMplsTE.interas_areaid);</a>
<a name="ln1609">          /* Unable to set the area context. Abort! */</a>
<a name="ln1610">          if (lp-&gt;area == NULL)</a>
<a name="ln1611">            {</a>
<a name="ln1612">              zlog_warn (&quot;MPLS-TE(ospf_mpls_te_lsa_schedule) Area context is null. Abort !&quot;);</a>
<a name="ln1613">              return;</a>
<a name="ln1614">            }</a>
<a name="ln1615">          tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_INTER_AS_LSA, lp-&gt;instance);</a>
<a name="ln1616">        }</a>
<a name="ln1617">      else</a>
<a name="ln1618">        tmp = SET_OPAQUE_LSID (OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA, lp-&gt;instance);</a>
<a name="ln1619">      lsah.id.s_addr = htonl (tmp);</a>
<a name="ln1620">    }</a>
<a name="ln1621"> </a>
<a name="ln1622">  switch (opcode)</a>
<a name="ln1623">    {</a>
<a name="ln1624">    case REORIGINATE_THIS_LSA:</a>
<a name="ln1625">      if (IS_FLOOD_AS (lp-&gt;type))</a>
<a name="ln1626">        {</a>
<a name="ln1627">          ospf_opaque_lsa_reoriginate_schedule ((void *) top, OSPF_OPAQUE_AS_LSA,</a>
<a name="ln1628">              OPAQUE_TYPE_INTER_AS_LSA);</a>
<a name="ln1629">          break;</a>
<a name="ln1630">        }</a>
<a name="ln1631"> </a>
<a name="ln1632">      if (IS_FLOOD_AREA (lp-&gt;type))</a>
<a name="ln1633">        {</a>
<a name="ln1634">          if (IS_INTER_AS (lp-&gt;type))</a>
<a name="ln1635">            ospf_opaque_lsa_reoriginate_schedule ((void *) lp-&gt;area, OSPF_OPAQUE_AREA_LSA,</a>
<a name="ln1636">                OPAQUE_TYPE_INTER_AS_LSA);</a>
<a name="ln1637">          else</a>
<a name="ln1638">            ospf_opaque_lsa_reoriginate_schedule ((void *) lp-&gt;area, OSPF_OPAQUE_AREA_LSA,</a>
<a name="ln1639">                OPAQUE_TYPE_TRAFFIC_ENGINEERING_LSA);</a>
<a name="ln1640">          break;</a>
<a name="ln1641">        }</a>
<a name="ln1642">      break;</a>
<a name="ln1643">    case REFRESH_THIS_LSA:</a>
<a name="ln1644">      ospf_opaque_lsa_refresh_schedule (&amp;lsa);</a>
<a name="ln1645">      break;</a>
<a name="ln1646">    case FLUSH_THIS_LSA:</a>
<a name="ln1647">      /* Reset Activity flag */</a>
<a name="ln1648">      lp-&gt;flags = LPFLG_LSA_INACTIVE;</a>
<a name="ln1649">      ospf_opaque_lsa_flush_schedule (&amp;lsa);</a>
<a name="ln1650">      break;</a>
<a name="ln1651">    default:</a>
<a name="ln1652">      zlog_warn (&quot;ospf_mpls_te_lsa_schedule: Unknown opcode (%u)&quot;, opcode);</a>
<a name="ln1653">      break;</a>
<a name="ln1654">    }</a>
<a name="ln1655"> </a>
<a name="ln1656">  return;</a>
<a name="ln1657">}</a>
<a name="ln1658"> </a>
<a name="ln1659"> </a>
<a name="ln1660">/*------------------------------------------------------------------------*</a>
<a name="ln1661"> * Followings are vty session control functions.</a>
<a name="ln1662"> *------------------------------------------------------------------------*/</a>
<a name="ln1663"> </a>
<a name="ln1664">static u_int16_t</a>
<a name="ln1665">show_vty_router_addr (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1666">{</a>
<a name="ln1667">  struct te_tlv_router_addr *top = (struct te_tlv_router_addr *) tlvh;</a>
<a name="ln1668"> </a>
<a name="ln1669">  if (vty != NULL)</a>
<a name="ln1670">    vty_out (vty, &quot;  Router-Address: %s%s&quot;, inet_ntoa (top-&gt;value),</a>
<a name="ln1671">             VTY_NEWLINE);</a>
<a name="ln1672">  else</a>
<a name="ln1673">    zlog_debug (&quot;    Router-Address: %s&quot;, inet_ntoa (top-&gt;value));</a>
<a name="ln1674"> </a>
<a name="ln1675">  return TLV_SIZE (tlvh);</a>
<a name="ln1676">}</a>
<a name="ln1677"> </a>
<a name="ln1678">static u_int16_t</a>
<a name="ln1679">show_vty_link_header (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1680">{</a>
<a name="ln1681">  struct te_tlv_link *top = (struct te_tlv_link *) tlvh;</a>
<a name="ln1682"> </a>
<a name="ln1683">  if (vty != NULL)</a>
<a name="ln1684">    vty_out (vty, &quot;  Link: %u octets of data%s&quot;, ntohs (top-&gt;header.length),</a>
<a name="ln1685">             VTY_NEWLINE);</a>
<a name="ln1686">  else</a>
<a name="ln1687">    zlog_debug (&quot;    Link: %u octets of data&quot;, ntohs (top-&gt;header.length));</a>
<a name="ln1688"> </a>
<a name="ln1689">  return TLV_HDR_SIZE;	/* Here is special, not &quot;TLV_SIZE&quot;. */</a>
<a name="ln1690">}</a>
<a name="ln1691"> </a>
<a name="ln1692">static u_int16_t</a>
<a name="ln1693">show_vty_link_subtlv_link_type (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1694">{</a>
<a name="ln1695">  struct te_link_subtlv_link_type *top;</a>
<a name="ln1696">  const char *cp = &quot;Unknown&quot;;</a>
<a name="ln1697"> </a>
<a name="ln1698">  top = (struct te_link_subtlv_link_type *) tlvh;</a>
<a name="ln1699">  switch (top-&gt;link_type.value)</a>
<a name="ln1700">    {</a>
<a name="ln1701">    case LINK_TYPE_SUBTLV_VALUE_PTP:</a>
<a name="ln1702">      cp = &quot;Point-to-point&quot;;</a>
<a name="ln1703">      break;</a>
<a name="ln1704">    case LINK_TYPE_SUBTLV_VALUE_MA:</a>
<a name="ln1705">      cp = &quot;Multiaccess&quot;;</a>
<a name="ln1706">      break;</a>
<a name="ln1707">    default:</a>
<a name="ln1708">      break;</a>
<a name="ln1709">    }</a>
<a name="ln1710"> </a>
<a name="ln1711">  if (vty != NULL)</a>
<a name="ln1712">    vty_out (vty, &quot;  Link-Type: %s (%u)%s&quot;, cp, top-&gt;link_type.value,</a>
<a name="ln1713">             VTY_NEWLINE);</a>
<a name="ln1714">  else</a>
<a name="ln1715">    zlog_debug (&quot;    Link-Type: %s (%u)&quot;, cp, top-&gt;link_type.value);</a>
<a name="ln1716"> </a>
<a name="ln1717">  return TLV_SIZE (tlvh);</a>
<a name="ln1718">}</a>
<a name="ln1719"> </a>
<a name="ln1720">static u_int16_t</a>
<a name="ln1721">show_vty_link_subtlv_link_id (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1722">{</a>
<a name="ln1723">  struct te_link_subtlv_link_id *top;</a>
<a name="ln1724"> </a>
<a name="ln1725">  top = (struct te_link_subtlv_link_id *) tlvh;</a>
<a name="ln1726">  if (vty != NULL)</a>
<a name="ln1727">    vty_out (vty, &quot;  Link-ID: %s%s&quot;, inet_ntoa (top-&gt;value), VTY_NEWLINE);</a>
<a name="ln1728">  else</a>
<a name="ln1729">    zlog_debug (&quot;    Link-ID: %s&quot;, inet_ntoa (top-&gt;value));</a>
<a name="ln1730"> </a>
<a name="ln1731">  return TLV_SIZE (tlvh);</a>
<a name="ln1732">}</a>
<a name="ln1733"> </a>
<a name="ln1734">static u_int16_t</a>
<a name="ln1735">show_vty_link_subtlv_lclif_ipaddr (struct vty *vty,</a>
<a name="ln1736">                                   struct te_tlv_header *tlvh)</a>
<a name="ln1737">{</a>
<a name="ln1738">  struct te_link_subtlv_lclif_ipaddr *top;</a>
<a name="ln1739">  int i, n;</a>
<a name="ln1740"> </a>
<a name="ln1741">  top = (struct te_link_subtlv_lclif_ipaddr *) tlvh;</a>
<a name="ln1742">  n = ntohs (tlvh-&gt;length) / sizeof (top-&gt;value[0]);</a>
<a name="ln1743"> </a>
<a name="ln1744">  if (vty != NULL)</a>
<a name="ln1745">    vty_out (vty, &quot;  Local Interface IP Address(es): %d%s&quot;, n, VTY_NEWLINE);</a>
<a name="ln1746">  else</a>
<a name="ln1747">    zlog_debug (&quot;    Local Interface IP Address(es): %d&quot;, n);</a>
<a name="ln1748"> </a>
<a name="ln1749">  for (i = 0; i &lt; n; i++)</a>
<a name="ln1750">    {</a>
<a name="ln1751">      if (vty != NULL)</a>
<a name="ln1752">        vty_out (vty, &quot;    #%d: %s%s&quot;, i, inet_ntoa (top-&gt;value[i]),</a>
<a name="ln1753">                 VTY_NEWLINE);</a>
<a name="ln1754">      else</a>
<a name="ln1755">        zlog_debug (&quot;      #%d: %s&quot;, i, inet_ntoa (top-&gt;value[i]));</a>
<a name="ln1756">    }</a>
<a name="ln1757">  return TLV_SIZE (tlvh);</a>
<a name="ln1758">}</a>
<a name="ln1759"> </a>
<a name="ln1760">static u_int16_t</a>
<a name="ln1761">show_vty_link_subtlv_rmtif_ipaddr (struct vty *vty,</a>
<a name="ln1762">                                   struct te_tlv_header *tlvh)</a>
<a name="ln1763">{</a>
<a name="ln1764">  struct te_link_subtlv_rmtif_ipaddr *top;</a>
<a name="ln1765">  int i, n;</a>
<a name="ln1766"> </a>
<a name="ln1767">  top = (struct te_link_subtlv_rmtif_ipaddr *) tlvh;</a>
<a name="ln1768">  n = ntohs (tlvh-&gt;length) / sizeof (top-&gt;value[0]);</a>
<a name="ln1769">  if (vty != NULL)</a>
<a name="ln1770">    vty_out (vty, &quot;  Remote Interface IP Address(es): %d%s&quot;, n, VTY_NEWLINE);</a>
<a name="ln1771">  else</a>
<a name="ln1772">    zlog_debug (&quot;    Remote Interface IP Address(es): %d&quot;, n);</a>
<a name="ln1773"> </a>
<a name="ln1774">  for (i = 0; i &lt; n; i++)</a>
<a name="ln1775">    {</a>
<a name="ln1776">      if (vty != NULL)</a>
<a name="ln1777">        vty_out (vty, &quot;    #%d: %s%s&quot;, i, inet_ntoa (top-&gt;value[i]),</a>
<a name="ln1778">                 VTY_NEWLINE);</a>
<a name="ln1779">      else</a>
<a name="ln1780">        zlog_debug (&quot;      #%d: %s&quot;, i, inet_ntoa (top-&gt;value[i]));</a>
<a name="ln1781">    }</a>
<a name="ln1782">  return TLV_SIZE (tlvh);</a>
<a name="ln1783">}</a>
<a name="ln1784"> </a>
<a name="ln1785">static u_int16_t</a>
<a name="ln1786">show_vty_link_subtlv_te_metric (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1787">{</a>
<a name="ln1788">  struct te_link_subtlv_te_metric *top;</a>
<a name="ln1789"> </a>
<a name="ln1790">  top = (struct te_link_subtlv_te_metric *) tlvh;</a>
<a name="ln1791">  if (vty != NULL)</a>
<a name="ln1792">    vty_out (vty, &quot;  Traffic Engineering Metric: %u%s&quot;,</a>
<a name="ln1793">             (u_int32_t) ntohl (top-&gt;value), VTY_NEWLINE);</a>
<a name="ln1794">  else</a>
<a name="ln1795">    zlog_debug (&quot;    Traffic Engineering Metric: %u&quot;,</a>
<a name="ln1796">                (u_int32_t) ntohl (top-&gt;value));</a>
<a name="ln1797"> </a>
<a name="ln1798">  return TLV_SIZE (tlvh);</a>
<a name="ln1799">}</a>
<a name="ln1800"> </a>
<a name="ln1801">static u_int16_t</a>
<a name="ln1802">show_vty_link_subtlv_max_bw (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1803">{</a>
<a name="ln1804">  struct te_link_subtlv_max_bw *top;</a>
<a name="ln1805">  float fval;</a>
<a name="ln1806"> </a>
<a name="ln1807">  top = (struct te_link_subtlv_max_bw *) tlvh;</a>
<a name="ln1808">  fval = ntohf (top-&gt;value);</a>
<a name="ln1809"> </a>
<a name="ln1810">  if (vty != NULL)</a>
<a name="ln1811">    vty_out (vty, &quot;  Maximum Bandwidth: %g (Bytes/sec)%s&quot;, fval, VTY_NEWLINE);</a>
<a name="ln1812">  else</a>
<a name="ln1813">    zlog_debug (&quot;    Maximum Bandwidth: %g (Bytes/sec)&quot;, fval);</a>
<a name="ln1814"> </a>
<a name="ln1815">  return TLV_SIZE (tlvh);</a>
<a name="ln1816">}</a>
<a name="ln1817"> </a>
<a name="ln1818">static u_int16_t</a>
<a name="ln1819">show_vty_link_subtlv_max_rsv_bw (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1820">{</a>
<a name="ln1821">  struct te_link_subtlv_max_rsv_bw *top;</a>
<a name="ln1822">  float fval;</a>
<a name="ln1823"> </a>
<a name="ln1824">  top = (struct te_link_subtlv_max_rsv_bw *) tlvh;</a>
<a name="ln1825">  fval = ntohf (top-&gt;value);</a>
<a name="ln1826"> </a>
<a name="ln1827">  if (vty != NULL)</a>
<a name="ln1828">    vty_out (vty, &quot;  Maximum Reservable Bandwidth: %g (Bytes/sec)%s&quot;, fval,</a>
<a name="ln1829">             VTY_NEWLINE);</a>
<a name="ln1830">  else</a>
<a name="ln1831">    zlog_debug (&quot;    Maximum Reservable Bandwidth: %g (Bytes/sec)&quot;, fval);</a>
<a name="ln1832"> </a>
<a name="ln1833">  return TLV_SIZE (tlvh);</a>
<a name="ln1834">}</a>
<a name="ln1835"> </a>
<a name="ln1836">static u_int16_t</a>
<a name="ln1837">show_vty_link_subtlv_unrsv_bw (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1838">{</a>
<a name="ln1839">  struct te_link_subtlv_unrsv_bw *top;</a>
<a name="ln1840">  float fval1, fval2;</a>
<a name="ln1841">  int i;</a>
<a name="ln1842"> </a>
<a name="ln1843">  top = (struct te_link_subtlv_unrsv_bw *) tlvh;</a>
<a name="ln1844">  if (vty != NULL)</a>
<a name="ln1845">    vty_out (vty, &quot;  Unreserved Bandwidth per Class Type in Byte/s:%s&quot;, VTY_NEWLINE);</a>
<a name="ln1846">  else</a>
<a name="ln1847">    zlog_debug (&quot;    Unreserved Bandwidth per Class Type in Byte/s:&quot;);</a>
<a name="ln1848">  for (i = 0; i &lt; MAX_CLASS_TYPE; i+=2)</a>
<a name="ln1849">    {</a>
<a name="ln1850">      fval1 = ntohf (top-&gt;value[i]);</a>
<a name="ln1851">      fval2 = ntohf (top-&gt;value[i+1]);</a>
<a name="ln1852"> </a>
<a name="ln1853">      if (vty != NULL)</a>
<a name="ln1854">        vty_out(vty, &quot;    [%d]: %g (Bytes/sec),\t[%d]: %g (Bytes/sec)%s&quot;,</a>
<a name="ln1855">                i, fval1, i+1, fval2, VTY_NEWLINE);</a>
<a name="ln1856">      else</a>
<a name="ln1857">        zlog_debug (&quot;      [%d]: %g (Bytes/sec),\t[%d]: %g (Bytes/sec)&quot;,</a>
<a name="ln1858">                    i, fval1, i+1, fval2);</a>
<a name="ln1859">    }</a>
<a name="ln1860"> </a>
<a name="ln1861">  return TLV_SIZE (tlvh);</a>
<a name="ln1862">}</a>
<a name="ln1863"> </a>
<a name="ln1864">static u_int16_t</a>
<a name="ln1865">show_vty_link_subtlv_rsc_clsclr (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1866">{</a>
<a name="ln1867">  struct te_link_subtlv_rsc_clsclr *top;</a>
<a name="ln1868"> </a>
<a name="ln1869">  top = (struct te_link_subtlv_rsc_clsclr *) tlvh;</a>
<a name="ln1870">  if (vty != NULL)</a>
<a name="ln1871">    vty_out (vty, &quot;  Resource class/color: 0x%x%s&quot;,</a>
<a name="ln1872">             (u_int32_t) ntohl (top-&gt;value), VTY_NEWLINE);</a>
<a name="ln1873">  else</a>
<a name="ln1874">    zlog_debug (&quot;    Resource Class/Color: 0x%x&quot;,</a>
<a name="ln1875">                (u_int32_t) ntohl (top-&gt;value));</a>
<a name="ln1876"> </a>
<a name="ln1877">  return TLV_SIZE (tlvh);</a>
<a name="ln1878">}</a>
<a name="ln1879"> </a>
<a name="ln1880">static u_int16_t</a>
<a name="ln1881">show_vty_link_subtlv_lrrid (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1882">{</a>
<a name="ln1883">  struct te_link_subtlv_lrrid *top;</a>
<a name="ln1884"> </a>
<a name="ln1885">  top = (struct te_link_subtlv_lrrid *) tlvh;</a>
<a name="ln1886"> </a>
<a name="ln1887">  if (vty != NULL)</a>
<a name="ln1888">    {</a>
<a name="ln1889">      vty_out (vty, &quot;  Local  TE Router ID: %s%s&quot;, inet_ntoa (top-&gt;local),</a>
<a name="ln1890">               VTY_NEWLINE);</a>
<a name="ln1891">      vty_out (vty, &quot;  Remote TE Router ID: %s%s&quot;, inet_ntoa (top-&gt;remote),</a>
<a name="ln1892">               VTY_NEWLINE);</a>
<a name="ln1893">    }</a>
<a name="ln1894">  else</a>
<a name="ln1895">    {</a>
<a name="ln1896">      zlog_debug (&quot;    Local  TE Router ID: %s&quot;, inet_ntoa (top-&gt;local));</a>
<a name="ln1897">      zlog_debug (&quot;    Remote TE Router ID: %s&quot;, inet_ntoa (top-&gt;remote));</a>
<a name="ln1898">    }</a>
<a name="ln1899"> </a>
<a name="ln1900">  return TLV_SIZE (tlvh);</a>
<a name="ln1901">}</a>
<a name="ln1902"> </a>
<a name="ln1903">static u_int16_t</a>
<a name="ln1904">show_vty_link_subtlv_llri (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1905">{</a>
<a name="ln1906">  struct te_link_subtlv_llri *top;</a>
<a name="ln1907"> </a>
<a name="ln1908">  top = (struct te_link_subtlv_llri *) tlvh;</a>
<a name="ln1909"> </a>
<a name="ln1910">  if (vty != NULL)</a>
<a name="ln1911">    {</a>
<a name="ln1912">      vty_out (vty, &quot;  Link Local  ID: %d%s&quot;, (u_int32_t) ntohl (top-&gt;local),</a>
<a name="ln1913">               VTY_NEWLINE);</a>
<a name="ln1914">      vty_out (vty, &quot;  Link Remote ID: %d%s&quot;, (u_int32_t) ntohl (top-&gt;remote),</a>
<a name="ln1915">               VTY_NEWLINE);</a>
<a name="ln1916">    }</a>
<a name="ln1917">  else</a>
<a name="ln1918">    {</a>
<a name="ln1919">      zlog_debug (&quot;    Link Local  ID: %d&quot;, (u_int32_t) ntohl (top-&gt;local));</a>
<a name="ln1920">      zlog_debug (&quot;    Link Remote ID: %d&quot;, (u_int32_t) ntohl (top-&gt;remote));</a>
<a name="ln1921">    }</a>
<a name="ln1922"> </a>
<a name="ln1923">  return TLV_SIZE (tlvh);</a>
<a name="ln1924">}</a>
<a name="ln1925"> </a>
<a name="ln1926">static u_int16_t</a>
<a name="ln1927">show_vty_link_subtlv_rip (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1928">{</a>
<a name="ln1929">  struct te_link_subtlv_rip *top;</a>
<a name="ln1930"> </a>
<a name="ln1931">  top = (struct te_link_subtlv_rip *) tlvh;</a>
<a name="ln1932"> </a>
<a name="ln1933">  if (vty != NULL)</a>
<a name="ln1934">    vty_out (vty, &quot;  Inter-AS TE Remote ASBR IP address: %s%s&quot;,</a>
<a name="ln1935">             inet_ntoa (top-&gt;value), VTY_NEWLINE);</a>
<a name="ln1936">  else</a>
<a name="ln1937">    zlog_debug (&quot;    Inter-AS TE Remote ASBR IP address: %s&quot;,</a>
<a name="ln1938">                inet_ntoa (top-&gt;value));</a>
<a name="ln1939"> </a>
<a name="ln1940">  return TLV_SIZE (tlvh);</a>
<a name="ln1941">}</a>
<a name="ln1942"> </a>
<a name="ln1943">static u_int16_t</a>
<a name="ln1944">show_vty_link_subtlv_ras (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1945">{</a>
<a name="ln1946">  struct te_link_subtlv_ras *top;</a>
<a name="ln1947"> </a>
<a name="ln1948">  top = (struct te_link_subtlv_ras *) tlvh;</a>
<a name="ln1949"> </a>
<a name="ln1950">  if (vty != NULL)</a>
<a name="ln1951">    vty_out (vty, &quot;  Inter-AS TE Remote AS number: %u%s&quot;, ntohl (top-&gt;value),</a>
<a name="ln1952">             VTY_NEWLINE);</a>
<a name="ln1953">  else</a>
<a name="ln1954">    zlog_debug (&quot;    Inter-AS TE Remote AS number: %u&quot;, ntohl (top-&gt;value));</a>
<a name="ln1955"> </a>
<a name="ln1956">  return TLV_SIZE (tlvh);</a>
<a name="ln1957">}</a>
<a name="ln1958"> </a>
<a name="ln1959">static u_int16_t</a>
<a name="ln1960">show_vty_link_subtlv_av_delay (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1961">{</a>
<a name="ln1962">  struct te_link_subtlv_av_delay *top;</a>
<a name="ln1963">  u_int32_t delay;</a>
<a name="ln1964">  u_int32_t anomalous;</a>
<a name="ln1965"> </a>
<a name="ln1966">  top = (struct te_link_subtlv_av_delay *) tlvh;</a>
<a name="ln1967">  delay = (u_int32_t) ntohl (top-&gt;value) &amp; TE_EXT_MASK;</a>
<a name="ln1968">  anomalous = (u_int32_t) ntohl (top-&gt;value) &amp; TE_EXT_ANORMAL;</a>
<a name="ln1969"> </a>
<a name="ln1970">  if (vty != NULL)</a>
<a name="ln1971">    vty_out (vty, &quot;  %s Average Link Delay: %d (micro-sec)%s&quot;,</a>
<a name="ln1972">             anomalous ? &quot;Anomalous&quot; : &quot;Normal&quot;, delay, VTY_NEWLINE);</a>
<a name="ln1973">  else</a>
<a name="ln1974">    zlog_debug (&quot;    %s Average Link Delay: %d (micro-sec)&quot;,</a>
<a name="ln1975">                anomalous ? &quot;Anomalous&quot; : &quot;Normal&quot;, delay);</a>
<a name="ln1976"> </a>
<a name="ln1977">  return TLV_SIZE (tlvh);</a>
<a name="ln1978">}</a>
<a name="ln1979"> </a>
<a name="ln1980">static u_int16_t</a>
<a name="ln1981">show_vty_link_subtlv_mm_delay (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln1982">{</a>
<a name="ln1983">  struct te_link_subtlv_mm_delay *top;</a>
<a name="ln1984">  u_int32_t low, high;</a>
<a name="ln1985">  u_int32_t anomalous;</a>
<a name="ln1986"> </a>
<a name="ln1987">  top = (struct te_link_subtlv_mm_delay *) tlvh;</a>
<a name="ln1988">  low = (u_int32_t) ntohl (top-&gt;low) &amp; TE_EXT_MASK;</a>
<a name="ln1989">  anomalous = (u_int32_t) ntohl (top-&gt;low) &amp; TE_EXT_ANORMAL;</a>
<a name="ln1990">  high = (u_int32_t) ntohl (top-&gt;high);</a>
<a name="ln1991"> </a>
<a name="ln1992">  if (vty != NULL)</a>
<a name="ln1993">    vty_out (vty, &quot;  %s Min/Max Link Delay: %d/%d (micro-sec)%s&quot;,</a>
<a name="ln1994">             anomalous ? &quot;Anomalous&quot; : &quot;Normal&quot;, low, high, VTY_NEWLINE);</a>
<a name="ln1995">  else</a>
<a name="ln1996">    zlog_debug (&quot;    %s Min/Max Link Delay: %d/%d (micro-sec)&quot;,</a>
<a name="ln1997">                anomalous ? &quot;Anomalous&quot; : &quot;Normal&quot;, low, high);</a>
<a name="ln1998"> </a>
<a name="ln1999">  return TLV_SIZE (tlvh);</a>
<a name="ln2000">}</a>
<a name="ln2001"> </a>
<a name="ln2002">static u_int16_t</a>
<a name="ln2003">show_vty_link_subtlv_delay_var (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln2004">{</a>
<a name="ln2005">  struct te_link_subtlv_delay_var *top;</a>
<a name="ln2006">  u_int32_t jitter;</a>
<a name="ln2007"> </a>
<a name="ln2008">  top = (struct te_link_subtlv_delay_var *) tlvh;</a>
<a name="ln2009">  jitter = (u_int32_t) ntohl (top-&gt;value) &amp; TE_EXT_MASK;</a>
<a name="ln2010"> </a>
<a name="ln2011">  if (vty != NULL)</a>
<a name="ln2012">    vty_out (vty, &quot;  Delay Variation: %d (micro-sec)%s&quot;, jitter, VTY_NEWLINE);</a>
<a name="ln2013">  else</a>
<a name="ln2014">    zlog_debug (&quot;    Delay Variation: %d (micro-sec)&quot;, jitter);</a>
<a name="ln2015"> </a>
<a name="ln2016">  return TLV_SIZE (tlvh);</a>
<a name="ln2017">}</a>
<a name="ln2018"> </a>
<a name="ln2019">static u_int16_t</a>
<a name="ln2020">show_vty_link_subtlv_pkt_loss (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln2021">{</a>
<a name="ln2022">  struct te_link_subtlv_pkt_loss *top;</a>
<a name="ln2023">  u_int32_t loss;</a>
<a name="ln2024">  u_int32_t anomalous;</a>
<a name="ln2025">  float fval;</a>
<a name="ln2026"> </a>
<a name="ln2027">  top = (struct te_link_subtlv_pkt_loss *) tlvh;</a>
<a name="ln2028">  loss = (u_int32_t) ntohl (top-&gt;value) &amp; TE_EXT_MASK;</a>
<a name="ln2029">  fval = (float) (loss * LOSS_PRECISION);</a>
<a name="ln2030">  anomalous = (u_int32_t) ntohl (top-&gt;value) &amp; TE_EXT_ANORMAL;</a>
<a name="ln2031"> </a>
<a name="ln2032">  if (vty != NULL)</a>
<a name="ln2033">    vty_out (vty, &quot;  %s Link Loss: %g (%%)%s&quot;, anomalous ? &quot;Anomalous&quot; : &quot;Normal&quot;,</a>
<a name="ln2034">             fval, VTY_NEWLINE);</a>
<a name="ln2035">  else</a>
<a name="ln2036">    zlog_debug (&quot;    %s Link Loss: %g (%%)&quot;, anomalous ? &quot;Anomalous&quot; : &quot;Normal&quot;,</a>
<a name="ln2037">                fval);</a>
<a name="ln2038"> </a>
<a name="ln2039">  return TLV_SIZE (tlvh);</a>
<a name="ln2040">}</a>
<a name="ln2041"> </a>
<a name="ln2042">static u_int16_t</a>
<a name="ln2043">show_vty_link_subtlv_res_bw (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln2044">{</a>
<a name="ln2045">  struct te_link_subtlv_res_bw *top;</a>
<a name="ln2046">  float fval;</a>
<a name="ln2047"> </a>
<a name="ln2048">  top = (struct te_link_subtlv_res_bw *) tlvh;</a>
<a name="ln2049">  fval = ntohf (top-&gt;value);</a>
<a name="ln2050"> </a>
<a name="ln2051">  if (vty != NULL)</a>
<a name="ln2052">    vty_out (vty, &quot;  Unidirectional Residual Bandwidth: %g (Bytes/sec)%s&quot;,</a>
<a name="ln2053">             fval, VTY_NEWLINE);</a>
<a name="ln2054">  else</a>
<a name="ln2055">    zlog_debug (&quot;    Unidirectional Residual Bandwidth: %g (Bytes/sec)&quot;,</a>
<a name="ln2056">                fval);</a>
<a name="ln2057"> </a>
<a name="ln2058">  return TLV_SIZE (tlvh);</a>
<a name="ln2059">}</a>
<a name="ln2060"> </a>
<a name="ln2061">static u_int16_t</a>
<a name="ln2062">show_vty_link_subtlv_ava_bw (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln2063">{</a>
<a name="ln2064">  struct te_link_subtlv_ava_bw *top;</a>
<a name="ln2065">  float fval;</a>
<a name="ln2066"> </a>
<a name="ln2067">  top = (struct te_link_subtlv_ava_bw *) tlvh;</a>
<a name="ln2068">  fval = ntohf (top-&gt;value);</a>
<a name="ln2069"> </a>
<a name="ln2070">  if (vty != NULL)</a>
<a name="ln2071">    vty_out (vty, &quot;  Unidirectional Available Bandwidth: %g (Bytes/sec)%s&quot;,</a>
<a name="ln2072">             fval, VTY_NEWLINE);</a>
<a name="ln2073">  else</a>
<a name="ln2074">    zlog_debug (&quot;    Unidirectional Available Bandwidth: %g (Bytes/sec)&quot;,</a>
<a name="ln2075">                fval);</a>
<a name="ln2076"> </a>
<a name="ln2077">  return TLV_SIZE (tlvh);</a>
<a name="ln2078">}</a>
<a name="ln2079"> </a>
<a name="ln2080">static u_int16_t</a>
<a name="ln2081">show_vty_link_subtlv_use_bw (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln2082">{</a>
<a name="ln2083">  struct te_link_subtlv_use_bw *top;</a>
<a name="ln2084">  float fval;</a>
<a name="ln2085"> </a>
<a name="ln2086">  top = (struct te_link_subtlv_use_bw *) tlvh;</a>
<a name="ln2087">  fval = ntohf (top-&gt;value);</a>
<a name="ln2088"> </a>
<a name="ln2089">  if (vty != NULL)</a>
<a name="ln2090">    vty_out (vty, &quot;  Unidirectional Utilized Bandwidth: %g (Bytes/sec)%s&quot;,</a>
<a name="ln2091">             fval, VTY_NEWLINE);</a>
<a name="ln2092">  else</a>
<a name="ln2093">    zlog_debug (&quot;    Unidirectional Utilized Bandwidth: %g (Bytes/sec)&quot;,</a>
<a name="ln2094">                fval);</a>
<a name="ln2095"> </a>
<a name="ln2096">  return TLV_SIZE (tlvh);</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">static u_int16_t</a>
<a name="ln2100">show_vty_unknown_tlv (struct vty *vty, struct te_tlv_header *tlvh)</a>
<a name="ln2101">{</a>
<a name="ln2102">  if (vty != NULL)</a>
<a name="ln2103">    vty_out (vty, &quot;  Unknown TLV: [type(0x%x), length(0x%x)]%s&quot;,</a>
<a name="ln2104">             ntohs (tlvh-&gt;type), ntohs (tlvh-&gt;length), VTY_NEWLINE);</a>
<a name="ln2105">  else</a>
<a name="ln2106">    zlog_debug (&quot;    Unknown TLV: [type(0x%x), length(0x%x)]&quot;,</a>
<a name="ln2107">                ntohs (tlvh-&gt;type), ntohs (tlvh-&gt;length));</a>
<a name="ln2108"> </a>
<a name="ln2109">  return TLV_SIZE (tlvh);</a>
<a name="ln2110">}</a>
<a name="ln2111"> </a>
<a name="ln2112">static u_int16_t</a>
<a name="ln2113">ospf_mpls_te_show_link_subtlv (struct vty *vty, struct te_tlv_header *tlvh0,</a>
<a name="ln2114">                               u_int16_t subtotal, u_int16_t total)</a>
<a name="ln2115">{</a>
<a name="ln2116">  struct te_tlv_header *tlvh, *next;</a>
<a name="ln2117">  u_int16_t sum = subtotal;</a>
<a name="ln2118"> </a>
<a name="ln2119">  for (tlvh = tlvh0; sum &lt; total; tlvh = (next ? next : TLV_HDR_NEXT (tlvh)))</a>
<a name="ln2120">    {</a>
<a name="ln2121">      next = NULL;</a>
<a name="ln2122">      switch (ntohs (tlvh-&gt;type))</a>
<a name="ln2123">        {</a>
<a name="ln2124">        case TE_LINK_SUBTLV_LINK_TYPE:</a>
<a name="ln2125">          sum += show_vty_link_subtlv_link_type (vty, tlvh);</a>
<a name="ln2126">          break;</a>
<a name="ln2127">        case TE_LINK_SUBTLV_LINK_ID:</a>
<a name="ln2128">          sum += show_vty_link_subtlv_link_id (vty, tlvh);</a>
<a name="ln2129">          break;</a>
<a name="ln2130">        case TE_LINK_SUBTLV_LCLIF_IPADDR:</a>
<a name="ln2131">          sum += show_vty_link_subtlv_lclif_ipaddr (vty, tlvh);</a>
<a name="ln2132">          break;</a>
<a name="ln2133">        case TE_LINK_SUBTLV_RMTIF_IPADDR:</a>
<a name="ln2134">          sum += show_vty_link_subtlv_rmtif_ipaddr (vty, tlvh);</a>
<a name="ln2135">          break;</a>
<a name="ln2136">        case TE_LINK_SUBTLV_TE_METRIC:</a>
<a name="ln2137">          sum += show_vty_link_subtlv_te_metric (vty, tlvh);</a>
<a name="ln2138">          break;</a>
<a name="ln2139">        case TE_LINK_SUBTLV_MAX_BW:</a>
<a name="ln2140">          sum += show_vty_link_subtlv_max_bw (vty, tlvh);</a>
<a name="ln2141">          break;</a>
<a name="ln2142">        case TE_LINK_SUBTLV_MAX_RSV_BW:</a>
<a name="ln2143">          sum += show_vty_link_subtlv_max_rsv_bw (vty, tlvh);</a>
<a name="ln2144">          break;</a>
<a name="ln2145">        case TE_LINK_SUBTLV_UNRSV_BW:</a>
<a name="ln2146">          sum += show_vty_link_subtlv_unrsv_bw (vty, tlvh);</a>
<a name="ln2147">          break;</a>
<a name="ln2148">        case TE_LINK_SUBTLV_RSC_CLSCLR:</a>
<a name="ln2149">          sum += show_vty_link_subtlv_rsc_clsclr (vty, tlvh);</a>
<a name="ln2150">          break;</a>
<a name="ln2151">        case TE_LINK_SUBTLV_LRRID:</a>
<a name="ln2152">          sum += show_vty_link_subtlv_lrrid (vty, tlvh);</a>
<a name="ln2153">          break;</a>
<a name="ln2154">        case TE_LINK_SUBTLV_LLRI:</a>
<a name="ln2155">          sum += show_vty_link_subtlv_llri (vty, tlvh);</a>
<a name="ln2156">          break;</a>
<a name="ln2157">        case TE_LINK_SUBTLV_RIP:</a>
<a name="ln2158">          sum += show_vty_link_subtlv_rip (vty, tlvh);</a>
<a name="ln2159">          break;</a>
<a name="ln2160">        case TE_LINK_SUBTLV_RAS:</a>
<a name="ln2161">          sum += show_vty_link_subtlv_ras (vty, tlvh);</a>
<a name="ln2162">          break;</a>
<a name="ln2163">        case TE_LINK_SUBTLV_AV_DELAY:</a>
<a name="ln2164">          sum += show_vty_link_subtlv_av_delay (vty, tlvh);</a>
<a name="ln2165">          break;</a>
<a name="ln2166">        case TE_LINK_SUBTLV_MM_DELAY:</a>
<a name="ln2167">          sum += show_vty_link_subtlv_mm_delay (vty, tlvh);</a>
<a name="ln2168">          break;</a>
<a name="ln2169">        case TE_LINK_SUBTLV_DELAY_VAR:</a>
<a name="ln2170">          sum += show_vty_link_subtlv_delay_var (vty, tlvh);</a>
<a name="ln2171">          break;</a>
<a name="ln2172">        case TE_LINK_SUBTLV_PKT_LOSS:</a>
<a name="ln2173">          sum += show_vty_link_subtlv_pkt_loss (vty, tlvh);</a>
<a name="ln2174">          break;</a>
<a name="ln2175">        case TE_LINK_SUBTLV_RES_BW:</a>
<a name="ln2176">          sum += show_vty_link_subtlv_res_bw (vty, tlvh);</a>
<a name="ln2177">          break;</a>
<a name="ln2178">        case TE_LINK_SUBTLV_AVA_BW:</a>
<a name="ln2179">          sum += show_vty_link_subtlv_ava_bw (vty, tlvh);</a>
<a name="ln2180">          break;</a>
<a name="ln2181">        case TE_LINK_SUBTLV_USE_BW:</a>
<a name="ln2182">          sum += show_vty_link_subtlv_use_bw (vty, tlvh);</a>
<a name="ln2183">          break;</a>
<a name="ln2184">        default:</a>
<a name="ln2185">          sum += show_vty_unknown_tlv (vty, tlvh);</a>
<a name="ln2186">          break;</a>
<a name="ln2187">        }</a>
<a name="ln2188">    }</a>
<a name="ln2189">  return sum;</a>
<a name="ln2190">}</a>
<a name="ln2191"> </a>
<a name="ln2192">static void</a>
<a name="ln2193">ospf_mpls_te_show_info (struct vty *vty, struct ospf_lsa *lsa)</a>
<a name="ln2194">{</a>
<a name="ln2195">  struct lsa_header *lsah = (struct lsa_header *) lsa-&gt;data;</a>
<a name="ln2196">  struct te_tlv_header *tlvh, *next;</a>
<a name="ln2197">  u_int16_t sum, total;</a>
<a name="ln2198">  u_int16_t (* subfunc)(struct vty *vty, struct te_tlv_header *tlvh,</a>
<a name="ln2199">                        u_int16_t subtotal, u_int16_t total) = NULL;</a>
<a name="ln2200"> </a>
<a name="ln2201">  sum = 0;</a>
<a name="ln2202">  total = ntohs (lsah-&gt;length) - OSPF_LSA_HEADER_SIZE;</a>
<a name="ln2203"> </a>
<a name="ln2204">  for (tlvh = TLV_HDR_TOP (lsah); sum &lt; total;</a>
<a name="ln2205">			tlvh = (next ? next : TLV_HDR_NEXT (tlvh)))</a>
<a name="ln2206">    {</a>
<a name="ln2207">      if (subfunc != NULL)</a>
<a name="ln2208">        {</a>
<a name="ln2209">          sum = (* subfunc)(vty, tlvh, sum, total);</a>
<a name="ln2210">	  next = (struct te_tlv_header *)((char *) tlvh + sum);</a>
<a name="ln2211">          subfunc = NULL;</a>
<a name="ln2212">          continue;</a>
<a name="ln2213">        }</a>
<a name="ln2214"> </a>
<a name="ln2215">      next = NULL;</a>
<a name="ln2216">      switch (ntohs (tlvh-&gt;type))</a>
<a name="ln2217">        {</a>
<a name="ln2218">        case TE_TLV_ROUTER_ADDR:</a>
<a name="ln2219">          sum += show_vty_router_addr (vty, tlvh);</a>
<a name="ln2220">          break;</a>
<a name="ln2221">        case TE_TLV_LINK:</a>
<a name="ln2222">          sum += show_vty_link_header (vty, tlvh);</a>
<a name="ln2223">	  subfunc = ospf_mpls_te_show_link_subtlv;</a>
<a name="ln2224">	  next = tlvh + 1;</a>
<a name="ln2225">          break;</a>
<a name="ln2226">        default:</a>
<a name="ln2227">          sum += show_vty_unknown_tlv (vty, tlvh);</a>
<a name="ln2228">          break;</a>
<a name="ln2229">        }</a>
<a name="ln2230">    }</a>
<a name="ln2231">  return;</a>
<a name="ln2232">}</a>
<a name="ln2233"> </a>
<a name="ln2234">static void</a>
<a name="ln2235">ospf_mpls_te_config_write_router (struct vty *vty)</a>
<a name="ln2236">{</a>
<a name="ln2237"> </a>
<a name="ln2238">  if (OspfMplsTE.status == enabled)</a>
<a name="ln2239">    {</a>
<a name="ln2240">      vty_out (vty, &quot;  mpls-te on%s&quot;, VTY_NEWLINE);</a>
<a name="ln2241">      vty_out (vty, &quot;  mpls-te router-address %s%s&quot;,</a>
<a name="ln2242">               inet_ntoa (OspfMplsTE.router_addr.value), VTY_NEWLINE);</a>
<a name="ln2243">    }</a>
<a name="ln2244"> </a>
<a name="ln2245">  if (OspfMplsTE.inter_as == AS)</a>
<a name="ln2246">    vty_out (vty, &quot;  mpls-te inter-as as%s&quot;, VTY_NEWLINE);</a>
<a name="ln2247">  if (OspfMplsTE.inter_as == Area)</a>
<a name="ln2248">    vty_out (vty, &quot;  mpls-te inter-as area %s %s&quot;,</a>
<a name="ln2249">             inet_ntoa (OspfMplsTE.interas_areaid), VTY_NEWLINE);</a>
<a name="ln2250"> </a>
<a name="ln2251">  return;</a>
<a name="ln2252">}</a>
<a name="ln2253"> </a>
<a name="ln2254">/*------------------------------------------------------------------------*</a>
<a name="ln2255"> * Followings are vty command functions.</a>
<a name="ln2256"> *------------------------------------------------------------------------*/</a>
<a name="ln2257"> </a>
<a name="ln2258">DEFUN (ospf_mpls_te_on,</a>
<a name="ln2259">       ospf_mpls_te_on_cmd,</a>
<a name="ln2260">       &quot;mpls-te on&quot;,</a>
<a name="ln2261">       MPLS_TE_STR</a>
<a name="ln2262">       &quot;Enable the MPLS-TE functionality\n&quot;)</a>
<a name="ln2263">{</a>
<a name="ln2264">  struct listnode *node;</a>
<a name="ln2265">  struct mpls_te_link *lp;</a>
<a name="ln2266"> </a>
<a name="ln2267">  if (OspfMplsTE.status == enabled)</a>
<a name="ln2268">    return CMD_SUCCESS;</a>
<a name="ln2269"> </a>
<a name="ln2270">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2271">    zlog_debug (&quot;MPLS-TE: OFF -&gt; ON&quot;);</a>
<a name="ln2272"> </a>
<a name="ln2273">  OspfMplsTE.status = enabled;</a>
<a name="ln2274"> </a>
<a name="ln2275">  /* Reoriginate RFC3630 &amp; RFC6827 Links */</a>
<a name="ln2276">  ospf_mpls_te_foreach_area (ospf_mpls_te_lsa_schedule, REORIGINATE_THIS_LSA);</a>
<a name="ln2277"> </a>
<a name="ln2278">  /* Reoriginate LSA if INTER-AS is always on */</a>
<a name="ln2279">  if (OspfMplsTE.inter_as != Disable)</a>
<a name="ln2280">    {</a>
<a name="ln2281">      for (ALL_LIST_ELEMENTS_RO (OspfMplsTE.iflist, node, lp))</a>
<a name="ln2282">        {</a>
<a name="ln2283">          if (IS_INTER_AS (lp-&gt;type))</a>
<a name="ln2284">            {</a>
<a name="ln2285">              ospf_mpls_te_lsa_schedule (lp, REORIGINATE_THIS_LSA);</a>
<a name="ln2286">            }</a>
<a name="ln2287">        }</a>
<a name="ln2288">    }</a>
<a name="ln2289"> </a>
<a name="ln2290">  return CMD_SUCCESS;</a>
<a name="ln2291">}</a>
<a name="ln2292"> </a>
<a name="ln2293">DEFUN (no_ospf_mpls_te,</a>
<a name="ln2294">       no_ospf_mpls_te_cmd,</a>
<a name="ln2295">       &quot;no mpls-te&quot;,</a>
<a name="ln2296">       NO_STR</a>
<a name="ln2297">       &quot;Disable the MPLS-TE functionality\n&quot;)</a>
<a name="ln2298">{</a>
<a name="ln2299">  struct listnode *node, *nnode;</a>
<a name="ln2300">  struct mpls_te_link *lp;</a>
<a name="ln2301"> </a>
<a name="ln2302">  if (OspfMplsTE.status == disabled)</a>
<a name="ln2303">    return CMD_SUCCESS;</a>
<a name="ln2304"> </a>
<a name="ln2305">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2306">    zlog_debug (&quot;MPLS-TE: ON -&gt; OFF&quot;);</a>
<a name="ln2307"> </a>
<a name="ln2308">  OspfMplsTE.status = disabled;</a>
<a name="ln2309"> </a>
<a name="ln2310">  for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))</a>
<a name="ln2311">    if CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED)</a>
<a name="ln2312">        ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);</a>
<a name="ln2313"> </a>
<a name="ln2314">  return CMD_SUCCESS;</a>
<a name="ln2315">}</a>
<a name="ln2316"> </a>
<a name="ln2317">DEFUN (ospf_mpls_te_router_addr,</a>
<a name="ln2318">       ospf_mpls_te_router_addr_cmd,</a>
<a name="ln2319">       &quot;mpls-te router-address A.B.C.D&quot;,</a>
<a name="ln2320">       MPLS_TE_STR</a>
<a name="ln2321">       &quot;Stable IP address of the advertising router\n&quot;</a>
<a name="ln2322">       &quot;MPLS-TE router address in IPv4 address format\n&quot;)</a>
<a name="ln2323">{</a>
<a name="ln2324">  struct te_tlv_router_addr *ra = &amp;OspfMplsTE.router_addr;</a>
<a name="ln2325">  struct in_addr value;</a>
<a name="ln2326"> </a>
<a name="ln2327">  if (! inet_aton (argv[0], &amp;value))</a>
<a name="ln2328">    {</a>
<a name="ln2329">      vty_out (vty, &quot;Please specify Router-Addr by A.B.C.D%s&quot;, VTY_NEWLINE);</a>
<a name="ln2330">      return CMD_WARNING;</a>
<a name="ln2331">    }</a>
<a name="ln2332"> </a>
<a name="ln2333">  if (ntohs (ra-&gt;header.type) == 0</a>
<a name="ln2334">      || ntohl (ra-&gt;value.s_addr) != ntohl (value.s_addr))</a>
<a name="ln2335">    {</a>
<a name="ln2336">      struct listnode *node, *nnode;</a>
<a name="ln2337">      struct mpls_te_link *lp;</a>
<a name="ln2338">      int need_to_reoriginate = 0;</a>
<a name="ln2339"> </a>
<a name="ln2340">      set_mpls_te_router_addr (value);</a>
<a name="ln2341"> </a>
<a name="ln2342">      if (OspfMplsTE.status == disabled)</a>
<a name="ln2343">        goto out;</a>
<a name="ln2344"> </a>
<a name="ln2345">      for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))</a>
<a name="ln2346">        {</a>
<a name="ln2347">          if ((lp-&gt;area == NULL) || IS_FLOOD_AS (lp-&gt;type))</a>
<a name="ln2348">            continue;</a>
<a name="ln2349"> </a>
<a name="ln2350">          if (!CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED))</a>
<a name="ln2351">            {</a>
<a name="ln2352">              need_to_reoriginate = 1;</a>
<a name="ln2353">              break;</a>
<a name="ln2354">            }</a>
<a name="ln2355">        }</a>
<a name="ln2356">      </a>
<a name="ln2357">      for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))</a>
<a name="ln2358">        {</a>
<a name="ln2359">          if ((lp-&gt;area == NULL) || IS_FLOOD_AS (lp-&gt;type))</a>
<a name="ln2360">            continue;</a>
<a name="ln2361"> </a>
<a name="ln2362">          if (need_to_reoriginate)</a>
<a name="ln2363">            SET_FLAG (lp-&gt;flags, LPFLG_LSA_FORCED_REFRESH);</a>
<a name="ln2364">          else</a>
<a name="ln2365">            ospf_mpls_te_lsa_schedule (lp, REFRESH_THIS_LSA);</a>
<a name="ln2366">        }</a>
<a name="ln2367"> </a>
<a name="ln2368">      if (need_to_reoriginate)</a>
<a name="ln2369">        ospf_mpls_te_foreach_area (ospf_mpls_te_lsa_schedule, REORIGINATE_THIS_LSA);</a>
<a name="ln2370">    }</a>
<a name="ln2371">out:</a>
<a name="ln2372">  return CMD_SUCCESS;</a>
<a name="ln2373">}</a>
<a name="ln2374"> </a>
<a name="ln2375">static int</a>
<a name="ln2376">set_inter_as_mode (struct vty *vty, const char *mode_name,</a>
<a name="ln2377">                   const char *area_id)</a>
<a name="ln2378">{</a>
<a name="ln2379">  enum inter_as_mode mode;</a>
<a name="ln2380">  struct listnode *node;</a>
<a name="ln2381">  struct mpls_te_link *lp;</a>
<a name="ln2382">  int format;</a>
<a name="ln2383"> </a>
<a name="ln2384">  if (OspfMplsTE.status == enabled)</a>
<a name="ln2385">    {</a>
<a name="ln2386"> </a>
<a name="ln2387">      /* Read and Check inter_as mode */</a>
<a name="ln2388">      if (strcmp (mode_name, &quot;as&quot;) == 0)</a>
<a name="ln2389">        mode = AS;</a>
<a name="ln2390">      else if (strcmp (mode_name, &quot;area&quot;) == 0)</a>
<a name="ln2391">        {</a>
<a name="ln2392">          mode = Area;</a>
<a name="ln2393">          VTY_GET_OSPF_AREA_ID (OspfMplsTE.interas_areaid, format, area_id);</a>
<a name="ln2394">        }</a>
<a name="ln2395">      else</a>
<a name="ln2396">        {</a>
<a name="ln2397">          vty_out (vty, &quot;Unknown mode. Please choose between as or area%s&quot;,</a>
<a name="ln2398">                   VTY_NEWLINE);</a>
<a name="ln2399">          return CMD_WARNING;</a>
<a name="ln2400">        }</a>
<a name="ln2401"> </a>
<a name="ln2402">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2403">        zlog_debug (&quot;MPLS-TE: Inter-AS enable with %s flooding support&quot;,</a>
<a name="ln2404">                    mode2text[mode]);</a>
<a name="ln2405"> </a>
<a name="ln2406">      /* Register new callbacks regarding the flooding scope (AS or Area) */</a>
<a name="ln2407">      if (ospf_mpls_te_register (mode) &lt; 0)</a>
<a name="ln2408">        {</a>
<a name="ln2409">          vty_out (vty, &quot;Internal error: Unable to register Inter-AS functions%s&quot;,</a>
<a name="ln2410">                   VTY_NEWLINE);</a>
<a name="ln2411">          return CMD_WARNING;</a>
<a name="ln2412">        }</a>
<a name="ln2413"> </a>
<a name="ln2414">      /* Enable mode and re-originate LSA if needed */</a>
<a name="ln2415">      if ((OspfMplsTE.inter_as == Disable) &amp;&amp; (mode != OspfMplsTE.inter_as))</a>
<a name="ln2416">        {</a>
<a name="ln2417">          OspfMplsTE.inter_as = mode;</a>
<a name="ln2418">          /* Re-originate all InterAS-TEv2 LSA */</a>
<a name="ln2419">          for (ALL_LIST_ELEMENTS_RO (OspfMplsTE.iflist, node, lp))</a>
<a name="ln2420">            {</a>
<a name="ln2421">              if (IS_INTER_AS (lp-&gt;type))</a>
<a name="ln2422">                {</a>
<a name="ln2423">                  if (mode == AS)</a>
<a name="ln2424">                    lp-&gt;type |= FLOOD_AS;</a>
<a name="ln2425">                  else</a>
<a name="ln2426">                    lp-&gt;type |= FLOOD_AREA;</a>
<a name="ln2427">                  ospf_mpls_te_lsa_schedule (lp, REORIGINATE_THIS_LSA);</a>
<a name="ln2428">                }</a>
<a name="ln2429">            }</a>
<a name="ln2430">        }</a>
<a name="ln2431">      else</a>
<a name="ln2432">        {</a>
<a name="ln2433">          vty_out (vty, &quot;Please change Inter-AS support to disable first before going to mode %s%s&quot;,</a>
<a name="ln2434">                   mode2text[mode], VTY_NEWLINE);</a>
<a name="ln2435">          return CMD_WARNING;</a>
<a name="ln2436">        }</a>
<a name="ln2437">    }</a>
<a name="ln2438">  return CMD_SUCCESS;</a>
<a name="ln2439">}</a>
<a name="ln2440"> </a>
<a name="ln2441">DEFUN (ospf_mpls_te_inter_as_as,</a>
<a name="ln2442">       ospf_mpls_te_inter_as_cmd,</a>
<a name="ln2443">       &quot;mpls-te inter-as as&quot;,</a>
<a name="ln2444">       MPLS_TE_STR</a>
<a name="ln2445">       &quot;Configure MPLS-TE Inter-AS support\n&quot;</a>
<a name="ln2446">       &quot;AS native mode self originate INTER_AS LSA with Type 11 (as flooding scope)\n&quot;)</a>
<a name="ln2447">{</a>
<a name="ln2448">  return set_inter_as_mode (vty, &quot;as&quot;, &quot;&quot;);</a>
<a name="ln2449">}</a>
<a name="ln2450"> </a>
<a name="ln2451">DEFUN (ospf_mpls_te_inter_as_area,</a>
<a name="ln2452">       ospf_mpls_te_inter_as_area_cmd,</a>
<a name="ln2453">       &quot;mpls-te inter-as area (A.B.C.D|&lt;0-4294967295&gt;)&quot;,</a>
<a name="ln2454">       MPLS_TE_STR</a>
<a name="ln2455">       &quot;Configure MPLS-TE Inter-AS support\n&quot;</a>
<a name="ln2456">       &quot;AREA native mode self originate INTER_AS LSA with Type 10 (area flooding scope)\n&quot;</a>
<a name="ln2457">       &quot;OSPF area ID in IP format\n&quot;</a>
<a name="ln2458">       &quot;OSPF area ID as decimal value\n&quot;)</a>
<a name="ln2459">{</a>
<a name="ln2460">  return set_inter_as_mode (vty, &quot;area&quot;, argv[0]);</a>
<a name="ln2461">}</a>
<a name="ln2462"> </a>
<a name="ln2463">DEFUN (no_ospf_mpls_te_inter_as,</a>
<a name="ln2464">       no_ospf_mpls_te_inter_as_cmd,</a>
<a name="ln2465">       &quot;no mpls-te inter-as&quot;,</a>
<a name="ln2466">       NO_STR</a>
<a name="ln2467">       MPLS_TE_STR</a>
<a name="ln2468">       &quot;Disable MPLS-TE Inter-AS support\n&quot;)</a>
<a name="ln2469">{</a>
<a name="ln2470"> </a>
<a name="ln2471">  struct listnode *node, *nnode;</a>
<a name="ln2472">  struct mpls_te_link *lp;</a>
<a name="ln2473"> </a>
<a name="ln2474">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln2475">    zlog_debug (&quot;MPLS-TE: Inter-AS support OFF&quot;);</a>
<a name="ln2476"> </a>
<a name="ln2477">  if ((OspfMplsTE.status == enabled) &amp;&amp; (OspfMplsTE.inter_as != Disable))</a>
<a name="ln2478">    {</a>
<a name="ln2479">      OspfMplsTE.inter_as = Disable;</a>
<a name="ln2480">      /* Flush all Inter-AS LSA */</a>
<a name="ln2481">      for (ALL_LIST_ELEMENTS (OspfMplsTE.iflist, node, nnode, lp))</a>
<a name="ln2482">        if (IS_INTER_AS (lp-&gt;type) &amp;&amp; CHECK_FLAG (lp-&gt;flags, LPFLG_LSA_ENGAGED))</a>
<a name="ln2483">          ospf_mpls_te_lsa_schedule (lp, FLUSH_THIS_LSA);</a>
<a name="ln2484">    }</a>
<a name="ln2485"> </a>
<a name="ln2486">  /* Deregister the Callbacks for Inter-AS suport */</a>
<a name="ln2487">  ospf_mpls_te_unregister ();</a>
<a name="ln2488"> </a>
<a name="ln2489">  return CMD_SUCCESS;</a>
<a name="ln2490">}</a>
<a name="ln2491"> </a>
<a name="ln2492">DEFUN (show_ip_ospf_mpls_te_router,</a>
<a name="ln2493">       show_ip_ospf_mpls_te_router_cmd,</a>
<a name="ln2494">       &quot;show ip ospf mpls-te router&quot;,</a>
<a name="ln2495">       SHOW_STR</a>
<a name="ln2496">       IP_STR</a>
<a name="ln2497">       OSPF_STR</a>
<a name="ln2498">       &quot;MPLS-TE information\n&quot;</a>
<a name="ln2499">       &quot;MPLS-TE Router parameters\n&quot;)</a>
<a name="ln2500">{</a>
<a name="ln2501">  if (OspfMplsTE.status == enabled)</a>
<a name="ln2502">    {</a>
<a name="ln2503">      vty_out (vty, &quot;--- MPLS-TE router parameters ---%s&quot;, VTY_NEWLINE);</a>
<a name="ln2504"> </a>
<a name="ln2505">      if (ntohs (OspfMplsTE.router_addr.header.type) != 0)</a>
<a name="ln2506">        show_vty_router_addr (vty, &amp;OspfMplsTE.router_addr.header);</a>
<a name="ln2507">      else if (vty != NULL)</a>
<a name="ln2508">        vty_out (vty, &quot;  N/A%s&quot;, VTY_NEWLINE);</a>
<a name="ln2509">    }</a>
<a name="ln2510">  return CMD_SUCCESS;</a>
<a name="ln2511">}</a>
<a name="ln2512"> </a>
<a name="ln2513">static void</a>
<a name="ln2514">show_mpls_te_link_sub (struct vty *vty, struct interface *ifp)</a>
<a name="ln2515">{</a>
<a name="ln2516">  struct mpls_te_link *lp;</a>
<a name="ln2517"> </a>
<a name="ln2518">  if ((OspfMplsTE.status == enabled) </a>
<a name="ln2519">      &amp;&amp; HAS_LINK_PARAMS(ifp) </a>
<a name="ln2520">      &amp;&amp; !if_is_loopback (ifp) </a>
<a name="ln2521">      &amp;&amp; if_is_up (ifp)</a>
<a name="ln2522">      &amp;&amp; ((lp = lookup_linkparams_by_ifp (ifp)) != NULL))</a>
<a name="ln2523">    {</a>
<a name="ln2524">      /* Continue only if interface is not passive or support Inter-AS TEv2 */</a>
<a name="ln2525">      if (!(ospf_oi_count (ifp) &gt; 0))</a>
<a name="ln2526">        {</a>
<a name="ln2527">          if (IS_INTER_AS (lp-&gt;type))</a>
<a name="ln2528">            {</a>
<a name="ln2529">              vty_out (vty, &quot;-- Inter-AS TEv2 link parameters for %s --%s&quot;,</a>
<a name="ln2530">                       ifp-&gt;name, VTY_NEWLINE);</a>
<a name="ln2531">            }</a>
<a name="ln2532">          else</a>
<a name="ln2533">            {</a>
<a name="ln2534">              /* MPLS-TE is not activate on this interface */</a>
<a name="ln2535">              /* or this interface is passive and Inter-AS TEv2 is not activate */</a>
<a name="ln2536">              vty_out (vty, &quot;  %s: MPLS-TE is disabled on this interface%s&quot;,</a>
<a name="ln2537">                       ifp-&gt;name, VTY_NEWLINE);</a>
<a name="ln2538">              return;</a>
<a name="ln2539">            }</a>
<a name="ln2540">        }</a>
<a name="ln2541">      else</a>
<a name="ln2542">        {</a>
<a name="ln2543">      vty_out (vty, &quot;-- MPLS-TE link parameters for %s --%s&quot;,</a>
<a name="ln2544">               ifp-&gt;name, VTY_NEWLINE);</a>
<a name="ln2545">        }</a>
<a name="ln2546"> </a>
<a name="ln2547">      if (TLV_TYPE(lp-&gt;link_type) != 0)</a>
<a name="ln2548">        show_vty_link_subtlv_link_type (vty, &amp;lp-&gt;link_type.header);</a>
<a name="ln2549">      if (TLV_TYPE(lp-&gt;link_id) != 0)</a>
<a name="ln2550">        show_vty_link_subtlv_link_id (vty, &amp;lp-&gt;link_id.header);</a>
<a name="ln2551">      if (TLV_TYPE(lp-&gt;lclif_ipaddr) != 0)</a>
<a name="ln2552">        show_vty_link_subtlv_lclif_ipaddr (vty, &amp;lp-&gt;lclif_ipaddr.header);</a>
<a name="ln2553">      if (TLV_TYPE(lp-&gt;rmtif_ipaddr) != 0)</a>
<a name="ln2554">        show_vty_link_subtlv_rmtif_ipaddr (vty, &amp;lp-&gt;rmtif_ipaddr.header);</a>
<a name="ln2555">      if (TLV_TYPE(lp-&gt;rip) != 0)</a>
<a name="ln2556">        show_vty_link_subtlv_rip (vty, &amp;lp-&gt;rip.header);</a>
<a name="ln2557">      if (TLV_TYPE(lp-&gt;ras) != 0)</a>
<a name="ln2558">        show_vty_link_subtlv_ras (vty, &amp;lp-&gt;ras.header);</a>
<a name="ln2559">      if (TLV_TYPE(lp-&gt;te_metric) != 0)</a>
<a name="ln2560">        show_vty_link_subtlv_te_metric (vty, &amp;lp-&gt;te_metric.header);</a>
<a name="ln2561">      if (TLV_TYPE(lp-&gt;max_bw) != 0)</a>
<a name="ln2562">        show_vty_link_subtlv_max_bw (vty, &amp;lp-&gt;max_bw.header);</a>
<a name="ln2563">      if (TLV_TYPE(lp-&gt;max_rsv_bw) != 0)</a>
<a name="ln2564">        show_vty_link_subtlv_max_rsv_bw (vty, &amp;lp-&gt;max_rsv_bw.header);</a>
<a name="ln2565">      if (TLV_TYPE(lp-&gt;unrsv_bw) != 0)</a>
<a name="ln2566">        show_vty_link_subtlv_unrsv_bw (vty, &amp;lp-&gt;unrsv_bw.header);</a>
<a name="ln2567">      if (TLV_TYPE(lp-&gt;rsc_clsclr) != 0)</a>
<a name="ln2568">        show_vty_link_subtlv_rsc_clsclr (vty, &amp;lp-&gt;rsc_clsclr.header);</a>
<a name="ln2569">      if (TLV_TYPE(lp-&gt;av_delay) != 0)</a>
<a name="ln2570">        show_vty_link_subtlv_av_delay (vty, &amp;lp-&gt;av_delay.header);</a>
<a name="ln2571">      if (TLV_TYPE(lp-&gt;mm_delay) != 0)</a>
<a name="ln2572">        show_vty_link_subtlv_mm_delay (vty, &amp;lp-&gt;mm_delay.header);</a>
<a name="ln2573">      if (TLV_TYPE(lp-&gt;delay_var) != 0)</a>
<a name="ln2574">        show_vty_link_subtlv_delay_var (vty, &amp;lp-&gt;delay_var.header);</a>
<a name="ln2575">      if (TLV_TYPE(lp-&gt;pkt_loss) != 0)</a>
<a name="ln2576">        show_vty_link_subtlv_pkt_loss (vty, &amp;lp-&gt;pkt_loss.header);</a>
<a name="ln2577">      if (TLV_TYPE(lp-&gt;res_bw) != 0)</a>
<a name="ln2578">        show_vty_link_subtlv_res_bw (vty, &amp;lp-&gt;res_bw.header);</a>
<a name="ln2579">      if (TLV_TYPE(lp-&gt;ava_bw) != 0)</a>
<a name="ln2580">        show_vty_link_subtlv_ava_bw (vty, &amp;lp-&gt;ava_bw.header);</a>
<a name="ln2581">      if (TLV_TYPE(lp-&gt;use_bw) != 0)</a>
<a name="ln2582">        show_vty_link_subtlv_use_bw (vty, &amp;lp-&gt;use_bw.header);</a>
<a name="ln2583">      vty_out (vty, &quot;---------------%s%s&quot;, VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln2584">    }</a>
<a name="ln2585">  else</a>
<a name="ln2586">    {</a>
<a name="ln2587">      vty_out (vty, &quot;  %s: MPLS-TE is disabled on this interface%s&quot;,</a>
<a name="ln2588">               ifp-&gt;name, VTY_NEWLINE);</a>
<a name="ln2589">    }</a>
<a name="ln2590"> </a>
<a name="ln2591">  return;</a>
<a name="ln2592">}</a>
<a name="ln2593"> </a>
<a name="ln2594">DEFUN (show_ip_ospf_mpls_te_link,</a>
<a name="ln2595">       show_ip_ospf_mpls_te_link_cmd,</a>
<a name="ln2596">       &quot;show ip ospf mpls-te interface [INTERFACE]&quot;,</a>
<a name="ln2597">       SHOW_STR</a>
<a name="ln2598">       IP_STR</a>
<a name="ln2599">       OSPF_STR</a>
<a name="ln2600">       &quot;MPLS-TE information\n&quot;</a>
<a name="ln2601">       &quot;Interface information\n&quot;</a>
<a name="ln2602">       &quot;Interface name\n&quot;)</a>
<a name="ln2603">{</a>
<a name="ln2604">  struct interface *ifp;</a>
<a name="ln2605">  struct listnode *node, *nnode;</a>
<a name="ln2606"> </a>
<a name="ln2607">  /* Show All Interfaces. */</a>
<a name="ln2608">  if (argc == 0)</a>
<a name="ln2609">    {</a>
<a name="ln2610">      for (ALL_LIST_ELEMENTS (iflist, node, nnode, ifp))</a>
<a name="ln2611">        show_mpls_te_link_sub (vty, ifp);</a>
<a name="ln2612">    }</a>
<a name="ln2613">  /* Interface name is specified. */</a>
<a name="ln2614">  else</a>
<a name="ln2615">    {</a>
<a name="ln2616">      if ((ifp = if_lookup_by_name (argv[0])) == NULL)</a>
<a name="ln2617">        vty_out (vty, &quot;No such interface name%s&quot;, VTY_NEWLINE);</a>
<a name="ln2618">      else</a>
<a name="ln2619">        show_mpls_te_link_sub (vty, ifp);</a>
<a name="ln2620">    }</a>
<a name="ln2621"> </a>
<a name="ln2622">  return CMD_SUCCESS;</a>
<a name="ln2623">}</a>
<a name="ln2624"> </a>
<a name="ln2625">static void</a>
<a name="ln2626">ospf_mpls_te_register_vty (void)</a>
<a name="ln2627">{</a>
<a name="ln2628">  install_element (VIEW_NODE, &amp;show_ip_ospf_mpls_te_router_cmd);</a>
<a name="ln2629">  install_element (VIEW_NODE, &amp;show_ip_ospf_mpls_te_link_cmd);</a>
<a name="ln2630"> </a>
<a name="ln2631">  install_element (OSPF_NODE, &amp;ospf_mpls_te_on_cmd);</a>
<a name="ln2632">  install_element (OSPF_NODE, &amp;no_ospf_mpls_te_cmd);</a>
<a name="ln2633">  install_element (OSPF_NODE, &amp;ospf_mpls_te_router_addr_cmd);</a>
<a name="ln2634">  install_element (OSPF_NODE, &amp;ospf_mpls_te_inter_as_cmd);</a>
<a name="ln2635">  install_element (OSPF_NODE, &amp;ospf_mpls_te_inter_as_area_cmd);</a>
<a name="ln2636">  install_element (OSPF_NODE, &amp;no_ospf_mpls_te_inter_as_cmd);</a>
<a name="ln2637"> </a>
<a name="ln2638">  return;</a>
<a name="ln2639">}</a>

</code></pre>
<div class="balloon" rel="12"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="1519"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1004/" target="_blank">V1004</a> The 'lp' pointer was used unsafely after it was verified against nullptr. Check lines: 1512, 1519.</p></div>
<div class="balloon" rel="1519"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'lp' pointer was utilized before it was verified against nullptr. Check lines: 1519, 1528.</p></div>
<div class="balloon" rel="2119"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'next' is always false.</p></div>
<div class="balloon" rel="2415"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (mode != OspfMplsTE.inter_as).</p></div>
<div class="balloon" rel="2503"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'vty' pointer was utilized before it was verified against nullptr. Check lines: 2503, 2507.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
