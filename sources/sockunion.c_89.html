
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>sockunion.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Socket union related function.</a>
<a name="ln2"> * Copyright (c) 1997, 98 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;prefix.h&quot;</a>
<a name="ln25">#include &quot;vty.h&quot;</a>
<a name="ln26">#include &quot;sockunion.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;str.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;jhash.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#ifndef HAVE_INET_ATON</a>
<a name="ln33">int</a>
<a name="ln34">inet_aton (const char *cp, struct in_addr *inaddr)</a>
<a name="ln35">{</a>
<a name="ln36">  int dots = 0;</a>
<a name="ln37">  register u_long addr = 0;</a>
<a name="ln38">  register u_long val = 0, base = 10;</a>
<a name="ln39"> </a>
<a name="ln40">  do</a>
<a name="ln41">    {</a>
<a name="ln42">      register char c = *cp;</a>
<a name="ln43"> </a>
<a name="ln44">      switch (c)</a>
<a name="ln45">	{</a>
<a name="ln46">	case '0': case '1': case '2': case '3': case '4': case '5':</a>
<a name="ln47">	case '6': case '7': case '8': case '9':</a>
<a name="ln48">	  val = (val * base) + (c - '0');</a>
<a name="ln49">	  break;</a>
<a name="ln50">	case '.':</a>
<a name="ln51">	  if (++dots &gt; 3)</a>
<a name="ln52">	    return 0;</a>
<a name="ln53">	case '\0':</a>
<a name="ln54">	  if (val &gt; 255)</a>
<a name="ln55">	    return 0;</a>
<a name="ln56">	  addr = addr &lt;&lt; 8 | val;</a>
<a name="ln57">	  val = 0;</a>
<a name="ln58">	  break;</a>
<a name="ln59">	default:</a>
<a name="ln60">	  return 0;</a>
<a name="ln61">	}</a>
<a name="ln62">    } while (*cp++) ;</a>
<a name="ln63"> </a>
<a name="ln64">  if (dots &lt; 3)</a>
<a name="ln65">    addr &lt;&lt;= 8 * (3 - dots);</a>
<a name="ln66">  if (inaddr)</a>
<a name="ln67">    inaddr-&gt;s_addr = htonl (addr);</a>
<a name="ln68">  return 1;</a>
<a name="ln69">}</a>
<a name="ln70">#endif /* ! HAVE_INET_ATON */</a>
<a name="ln71"> </a>
<a name="ln72"> </a>
<a name="ln73">#ifndef HAVE_INET_PTON</a>
<a name="ln74">int</a>
<a name="ln75">inet_pton (int family, const char *strptr, void *addrptr)</a>
<a name="ln76">{</a>
<a name="ln77">  if (family == AF_INET)</a>
<a name="ln78">    {</a>
<a name="ln79">      struct in_addr in_val;</a>
<a name="ln80"> </a>
<a name="ln81">      if (inet_aton (strptr, &amp;in_val))</a>
<a name="ln82">	{</a>
<a name="ln83">	  memcpy (addrptr, &amp;in_val, sizeof (struct in_addr));</a>
<a name="ln84">	  return 1;</a>
<a name="ln85">	}</a>
<a name="ln86">      return 0;</a>
<a name="ln87">    }</a>
<a name="ln88">  errno = EAFNOSUPPORT;</a>
<a name="ln89">  return -1;</a>
<a name="ln90">}</a>
<a name="ln91">#endif /* ! HAVE_INET_PTON */</a>
<a name="ln92"> </a>
<a name="ln93">#ifndef HAVE_INET_NTOP</a>
<a name="ln94">const char *</a>
<a name="ln95">inet_ntop (int family, const void *addrptr, char *strptr, size_t len)</a>
<a name="ln96">{</a>
<a name="ln97">  unsigned char *p = (unsigned char *) addrptr;</a>
<a name="ln98"> </a>
<a name="ln99">  if (family == AF_INET) </a>
<a name="ln100">    {</a>
<a name="ln101">      char temp[INET_ADDRSTRLEN];</a>
<a name="ln102"> </a>
<a name="ln103">      snprintf(temp, sizeof(temp), &quot;%d.%d.%d.%d&quot;, p[0], p[1], p[2], p[3]);</a>
<a name="ln104"> </a>
<a name="ln105">      if (strlen(temp) &gt;= len) </a>
<a name="ln106">	{</a>
<a name="ln107">	  errno = ENOSPC;</a>
<a name="ln108">	  return NULL;</a>
<a name="ln109">	}</a>
<a name="ln110">      strcpy(strptr, temp);</a>
<a name="ln111">      return strptr;</a>
<a name="ln112">    }</a>
<a name="ln113"> </a>
<a name="ln114">  errno = EAFNOSUPPORT;</a>
<a name="ln115">  return NULL;</a>
<a name="ln116">}</a>
<a name="ln117">#endif /* ! HAVE_INET_NTOP */</a>
<a name="ln118"> </a>
<a name="ln119">const char *</a>
<a name="ln120">inet_sutop (const union sockunion *su, char *str)</a>
<a name="ln121">{</a>
<a name="ln122">  switch (su-&gt;sa.sa_family)</a>
<a name="ln123">    {</a>
<a name="ln124">    case AF_INET:</a>
<a name="ln125">      inet_ntop (AF_INET, &amp;su-&gt;sin.sin_addr, str, INET_ADDRSTRLEN);</a>
<a name="ln126">      break;</a>
<a name="ln127">#ifdef HAVE_IPV6</a>
<a name="ln128">    case AF_INET6:</a>
<a name="ln129">      inet_ntop (AF_INET6, &amp;su-&gt;sin6.sin6_addr, str, INET6_ADDRSTRLEN);</a>
<a name="ln130">      break;</a>
<a name="ln131">#endif /* HAVE_IPV6 */</a>
<a name="ln132">    }</a>
<a name="ln133">  return str;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">int</a>
<a name="ln137">str2sockunion (const char *str, union sockunion *su)</a>
<a name="ln138">{</a>
<a name="ln139">  int ret;</a>
<a name="ln140"> </a>
<a name="ln141">  memset (su, 0, sizeof (union sockunion));</a>
<a name="ln142"> </a>
<a name="ln143">  ret = inet_pton (AF_INET, str, &amp;su-&gt;sin.sin_addr);</a>
<a name="ln144">  if (ret &gt; 0)			/* Valid IPv4 address format. */</a>
<a name="ln145">    {</a>
<a name="ln146">      su-&gt;sin.sin_family = AF_INET;</a>
<a name="ln147">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln148">      su-&gt;sin.sin_len = sizeof(struct sockaddr_in);</a>
<a name="ln149">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln150">      return 0;</a>
<a name="ln151">    }</a>
<a name="ln152">#ifdef HAVE_IPV6</a>
<a name="ln153">  ret = inet_pton (AF_INET6, str, &amp;su-&gt;sin6.sin6_addr);</a>
<a name="ln154">  if (ret &gt; 0)			/* Valid IPv6 address format. */</a>
<a name="ln155">    {</a>
<a name="ln156">      su-&gt;sin6.sin6_family = AF_INET6;</a>
<a name="ln157">#ifdef SIN6_LEN</a>
<a name="ln158">      su-&gt;sin6.sin6_len = sizeof(struct sockaddr_in6);</a>
<a name="ln159">#endif /* SIN6_LEN */</a>
<a name="ln160">      return 0;</a>
<a name="ln161">    }</a>
<a name="ln162">#endif /* HAVE_IPV6 */</a>
<a name="ln163">  return -1;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">const char *</a>
<a name="ln167">sockunion2str (const union sockunion *su, char *buf, size_t len)</a>
<a name="ln168">{</a>
<a name="ln169">  switch (sockunion_family(su))</a>
<a name="ln170">    {</a>
<a name="ln171">    case AF_UNSPEC:</a>
<a name="ln172">      snprintf (buf, len, &quot;(unspec)&quot;);</a>
<a name="ln173">      return buf;</a>
<a name="ln174">    case AF_INET:</a>
<a name="ln175">      return inet_ntop (AF_INET, &amp;su-&gt;sin.sin_addr, buf, len);</a>
<a name="ln176">#ifdef HAVE_IPV6</a>
<a name="ln177">    case AF_INET6:</a>
<a name="ln178">      return inet_ntop (AF_INET6, &amp;su-&gt;sin6.sin6_addr, buf, len);</a>
<a name="ln179">#endif /* HAVE_IPV6 */</a>
<a name="ln180">    }</a>
<a name="ln181">  snprintf (buf, len, &quot;(af %d)&quot;, sockunion_family(su));</a>
<a name="ln182">  return buf;</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">union sockunion *</a>
<a name="ln186">sockunion_str2su (const char *str)</a>
<a name="ln187">{</a>
<a name="ln188">  union sockunion *su = XCALLOC (MTYPE_SOCKUNION, sizeof (union sockunion));</a>
<a name="ln189">  </a>
<a name="ln190">  if (!str2sockunion (str, su))</a>
<a name="ln191">    return su;</a>
<a name="ln192">  </a>
<a name="ln193">  XFREE (MTYPE_SOCKUNION, su);</a>
<a name="ln194">  return NULL;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">/* Convert IPv4 compatible IPv6 address to IPv4 address. */</a>
<a name="ln198">static void</a>
<a name="ln199">sockunion_normalise_mapped (union sockunion *su)</a>
<a name="ln200">{</a>
<a name="ln201">  struct sockaddr_in sin;</a>
<a name="ln202">  </a>
<a name="ln203">#ifdef HAVE_IPV6</a>
<a name="ln204">  if (su-&gt;sa.sa_family == AF_INET6 </a>
<a name="ln205">      &amp;&amp; IN6_IS_ADDR_V4MAPPED (&amp;su-&gt;sin6.sin6_addr))</a>
<a name="ln206">    {</a>
<a name="ln207">      memset (&amp;sin, 0, sizeof (struct sockaddr_in));</a>
<a name="ln208">      sin.sin_family = AF_INET;</a>
<a name="ln209">      sin.sin_port = su-&gt;sin6.sin6_port;</a>
<a name="ln210">      memcpy (&amp;sin.sin_addr, ((char *)&amp;su-&gt;sin6.sin6_addr) + 12, 4);</a>
<a name="ln211">      memcpy (su, &amp;sin, sizeof (struct sockaddr_in));</a>
<a name="ln212">    }</a>
<a name="ln213">#endif /* HAVE_IPV6 */</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">/* Return socket of sockunion. */</a>
<a name="ln217">int</a>
<a name="ln218">sockunion_socket (const union sockunion *su)</a>
<a name="ln219">{</a>
<a name="ln220">  int sock;</a>
<a name="ln221"> </a>
<a name="ln222">  sock = socket (su-&gt;sa.sa_family, SOCK_STREAM, 0);</a>
<a name="ln223">  if (sock &lt; 0)</a>
<a name="ln224">    {</a>
<a name="ln225">      zlog (NULL, LOG_WARNING, &quot;Can't make socket : %s&quot;, safe_strerror (errno));</a>
<a name="ln226">      return -1;</a>
<a name="ln227">    }</a>
<a name="ln228"> </a>
<a name="ln229">  return sock;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">/* Return accepted new socket file descriptor. */</a>
<a name="ln233">int</a>
<a name="ln234">sockunion_accept (int sock, union sockunion *su)</a>
<a name="ln235">{</a>
<a name="ln236">  socklen_t len;</a>
<a name="ln237">  int client_sock;</a>
<a name="ln238"> </a>
<a name="ln239">  len = sizeof (union sockunion);</a>
<a name="ln240">  client_sock = accept (sock, (struct sockaddr *) su, &amp;len);</a>
<a name="ln241">  </a>
<a name="ln242">  sockunion_normalise_mapped (su);</a>
<a name="ln243">  return client_sock;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">/* Return sizeof union sockunion.  */</a>
<a name="ln247">static int</a>
<a name="ln248">sockunion_sizeof (const union sockunion *su)</a>
<a name="ln249">{</a>
<a name="ln250">  int ret;</a>
<a name="ln251"> </a>
<a name="ln252">  ret = 0;</a>
<a name="ln253">  switch (su-&gt;sa.sa_family)</a>
<a name="ln254">    {</a>
<a name="ln255">    case AF_INET:</a>
<a name="ln256">      ret = sizeof (struct sockaddr_in);</a>
<a name="ln257">      break;</a>
<a name="ln258">#ifdef HAVE_IPV6</a>
<a name="ln259">    case AF_INET6:</a>
<a name="ln260">      ret = sizeof (struct sockaddr_in6);</a>
<a name="ln261">      break;</a>
<a name="ln262">#endif /* AF_INET6 */</a>
<a name="ln263">    }</a>
<a name="ln264">  return ret;</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">/* return sockunion structure : this function should be revised. */</a>
<a name="ln268">static const char *</a>
<a name="ln269">sockunion_log (const union sockunion *su, char *buf, size_t len)</a>
<a name="ln270">{</a>
<a name="ln271">  switch (su-&gt;sa.sa_family) </a>
<a name="ln272">    {</a>
<a name="ln273">    case AF_INET:</a>
<a name="ln274">      return inet_ntop(AF_INET, &amp;su-&gt;sin.sin_addr, buf, len);</a>
<a name="ln275"> </a>
<a name="ln276">#ifdef HAVE_IPV6</a>
<a name="ln277">    case AF_INET6:</a>
<a name="ln278">      return inet_ntop(AF_INET6, &amp;(su-&gt;sin6.sin6_addr), buf, len);</a>
<a name="ln279">      break;</a>
<a name="ln280">#endif /* HAVE_IPV6 */</a>
<a name="ln281"> </a>
<a name="ln282">    default:</a>
<a name="ln283">      snprintf (buf, len, &quot;af_unknown %d &quot;, su-&gt;sa.sa_family);</a>
<a name="ln284">      return buf;</a>
<a name="ln285">    }</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">/* sockunion_connect returns</a>
<a name="ln289">   -1 : error occurred</a>
<a name="ln290">   0 : connect success</a>
<a name="ln291">   1 : connect is in progress */</a>
<a name="ln292">enum connect_result</a>
<a name="ln293">sockunion_connect (int fd, const union sockunion *peersu, unsigned short port,</a>
<a name="ln294">		   ifindex_t ifindex)</a>
<a name="ln295">{</a>
<a name="ln296">  int ret;</a>
<a name="ln297">  int val;</a>
<a name="ln298">  union sockunion su;</a>
<a name="ln299"> </a>
<a name="ln300">  memcpy (&amp;su, peersu, sizeof (union sockunion));</a>
<a name="ln301"> </a>
<a name="ln302">  switch (su.sa.sa_family)</a>
<a name="ln303">    {</a>
<a name="ln304">    case AF_INET:</a>
<a name="ln305">      su.sin.sin_port = port;</a>
<a name="ln306">      break;</a>
<a name="ln307">#ifdef HAVE_IPV6</a>
<a name="ln308">    case AF_INET6:</a>
<a name="ln309">      su.sin6.sin6_port  = port;</a>
<a name="ln310">#ifdef KAME</a>
<a name="ln311">      if (IN6_IS_ADDR_LINKLOCAL(&amp;su.sin6.sin6_addr) &amp;&amp; ifindex)</a>
<a name="ln312">	{</a>
<a name="ln313">#ifdef HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID</a>
<a name="ln314">	  /* su.sin6.sin6_scope_id = ifindex; */</a>
<a name="ln315">#endif /* HAVE_STRUCT_SOCKADDR_IN6_SIN6_SCOPE_ID */</a>
<a name="ln316">	  SET_IN6_LINKLOCAL_IFINDEX (su.sin6.sin6_addr, ifindex);</a>
<a name="ln317">	}</a>
<a name="ln318">#endif /* KAME */</a>
<a name="ln319">      break;</a>
<a name="ln320">#endif /* HAVE_IPV6 */</a>
<a name="ln321">    }      </a>
<a name="ln322"> </a>
<a name="ln323">  /* Make socket non-block. */</a>
<a name="ln324">  val = fcntl (fd, F_GETFL, 0);</a>
<a name="ln325">  fcntl (fd, F_SETFL, val|O_NONBLOCK);</a>
<a name="ln326"> </a>
<a name="ln327">  /* Call connect function. */</a>
<a name="ln328">  ret = connect (fd, (struct sockaddr *) &amp;su, sockunion_sizeof (&amp;su));</a>
<a name="ln329"> </a>
<a name="ln330">  /* Immediate success */</a>
<a name="ln331">  if (ret == 0)</a>
<a name="ln332">    {</a>
<a name="ln333">      fcntl (fd, F_SETFL, val);</a>
<a name="ln334">      return connect_success;</a>
<a name="ln335">    }</a>
<a name="ln336"> </a>
<a name="ln337">  /* If connect is in progress then return 1 else it's real error. */</a>
<a name="ln338">  if (ret &lt; 0)</a>
<a name="ln339">    {</a>
<a name="ln340">      if (errno != EINPROGRESS)</a>
<a name="ln341">	{</a>
<a name="ln342">	  char str[SU_ADDRSTRLEN];</a>
<a name="ln343">	  zlog_info (&quot;can't connect to %s fd %d : %s&quot;,</a>
<a name="ln344">		     sockunion_log (&amp;su, str, sizeof str),</a>
<a name="ln345">		     fd, safe_strerror (errno));</a>
<a name="ln346">	  return connect_error;</a>
<a name="ln347">	}</a>
<a name="ln348">    }</a>
<a name="ln349"> </a>
<a name="ln350">  fcntl (fd, F_SETFL, val);</a>
<a name="ln351"> </a>
<a name="ln352">  return connect_in_progress;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">/* Make socket from sockunion union. */</a>
<a name="ln356">int</a>
<a name="ln357">sockunion_stream_socket (union sockunion *su)</a>
<a name="ln358">{</a>
<a name="ln359">  int sock;</a>
<a name="ln360"> </a>
<a name="ln361">  if (su-&gt;sa.sa_family == 0)</a>
<a name="ln362">    su-&gt;sa.sa_family = AF_INET_UNION;</a>
<a name="ln363"> </a>
<a name="ln364">  sock = socket (su-&gt;sa.sa_family, SOCK_STREAM, 0);</a>
<a name="ln365"> </a>
<a name="ln366">  if (sock &lt; 0)</a>
<a name="ln367">    zlog (NULL, LOG_WARNING, &quot;can't make socket sockunion_stream_socket&quot;);</a>
<a name="ln368"> </a>
<a name="ln369">  return sock;</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">/* Bind socket to specified address. */</a>
<a name="ln373">int</a>
<a name="ln374">sockunion_bind (int sock, union sockunion *su, unsigned short port, </a>
<a name="ln375">		union sockunion *su_addr)</a>
<a name="ln376">{</a>
<a name="ln377">  int size = 0;</a>
<a name="ln378">  int ret;</a>
<a name="ln379"> </a>
<a name="ln380">  if (su-&gt;sa.sa_family == AF_INET)</a>
<a name="ln381">    {</a>
<a name="ln382">      size = sizeof (struct sockaddr_in);</a>
<a name="ln383">      su-&gt;sin.sin_port = htons (port);</a>
<a name="ln384">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln385">      su-&gt;sin.sin_len = size;</a>
<a name="ln386">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln387">      if (su_addr == NULL)</a>
<a name="ln388">	sockunion2ip (su) = htonl (INADDR_ANY);</a>
<a name="ln389">    }</a>
<a name="ln390">#ifdef HAVE_IPV6</a>
<a name="ln391">  else if (su-&gt;sa.sa_family == AF_INET6)</a>
<a name="ln392">    {</a>
<a name="ln393">      size = sizeof (struct sockaddr_in6);</a>
<a name="ln394">      su-&gt;sin6.sin6_port = htons (port);</a>
<a name="ln395">#ifdef SIN6_LEN</a>
<a name="ln396">      su-&gt;sin6.sin6_len = size;</a>
<a name="ln397">#endif /* SIN6_LEN */</a>
<a name="ln398">      if (su_addr == NULL)</a>
<a name="ln399">	{</a>
<a name="ln400">#ifdef LINUX_IPV6</a>
<a name="ln401">	  memset (&amp;su-&gt;sin6.sin6_addr, 0, sizeof (struct in6_addr));</a>
<a name="ln402">#else</a>
<a name="ln403">	  su-&gt;sin6.sin6_addr = in6addr_any;</a>
<a name="ln404">#endif /* LINUX_IPV6 */</a>
<a name="ln405">	}</a>
<a name="ln406">    }</a>
<a name="ln407">#endif /* HAVE_IPV6 */</a>
<a name="ln408">  </a>
<a name="ln409"> </a>
<a name="ln410">  ret = bind (sock, (struct sockaddr *)su, size);</a>
<a name="ln411">  if (ret &lt; 0)</a>
<a name="ln412">    zlog (NULL, LOG_WARNING, &quot;can't bind socket : %s&quot;, safe_strerror (errno));</a>
<a name="ln413"> </a>
<a name="ln414">  return ret;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">int</a>
<a name="ln418">sockopt_reuseaddr (int sock)</a>
<a name="ln419">{</a>
<a name="ln420">  int ret;</a>
<a name="ln421">  int on = 1;</a>
<a name="ln422"> </a>
<a name="ln423">  ret = setsockopt (sock, SOL_SOCKET, SO_REUSEADDR, </a>
<a name="ln424">		    (void *) &amp;on, sizeof (on));</a>
<a name="ln425">  if (ret &lt; 0)</a>
<a name="ln426">    {</a>
<a name="ln427">      zlog (NULL, LOG_WARNING, &quot;can't set sockopt SO_REUSEADDR to socket %d&quot;, sock);</a>
<a name="ln428">      return -1;</a>
<a name="ln429">    }</a>
<a name="ln430">  return 0;</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433">#ifdef SO_REUSEPORT</a>
<a name="ln434">int</a>
<a name="ln435">sockopt_reuseport (int sock)</a>
<a name="ln436">{</a>
<a name="ln437">  int ret;</a>
<a name="ln438">  int on = 1;</a>
<a name="ln439"> </a>
<a name="ln440">  ret = setsockopt (sock, SOL_SOCKET, SO_REUSEPORT, </a>
<a name="ln441">		    (void *) &amp;on, sizeof (on));</a>
<a name="ln442">  if (ret &lt; 0)</a>
<a name="ln443">    {</a>
<a name="ln444">      zlog (NULL, LOG_WARNING, &quot;can't set sockopt SO_REUSEPORT to socket %d&quot;, sock);</a>
<a name="ln445">      return -1;</a>
<a name="ln446">    }</a>
<a name="ln447">  return 0;</a>
<a name="ln448">}</a>
<a name="ln449">#else</a>
<a name="ln450">int</a>
<a name="ln451">sockopt_reuseport (int sock)</a>
<a name="ln452">{</a>
<a name="ln453">  return 0;</a>
<a name="ln454">}</a>
<a name="ln455">#endif /* 0 */</a>
<a name="ln456"> </a>
<a name="ln457">int</a>
<a name="ln458">sockopt_ttl (int family, int sock, int ttl)</a>
<a name="ln459">{</a>
<a name="ln460">  int ret;</a>
<a name="ln461"> </a>
<a name="ln462">#ifdef IP_TTL</a>
<a name="ln463">  if (family == AF_INET)</a>
<a name="ln464">    {</a>
<a name="ln465">      ret = setsockopt (sock, IPPROTO_IP, IP_TTL, </a>
<a name="ln466">			(void *) &amp;ttl, sizeof (int));</a>
<a name="ln467">      if (ret &lt; 0)</a>
<a name="ln468">	{</a>
<a name="ln469">	  zlog (NULL, LOG_WARNING, &quot;can't set sockopt IP_TTL %d to socket %d&quot;, ttl, sock);</a>
<a name="ln470">	  return -1;</a>
<a name="ln471">	}</a>
<a name="ln472">      return 0;</a>
<a name="ln473">    }</a>
<a name="ln474">#endif /* IP_TTL */</a>
<a name="ln475">#ifdef HAVE_IPV6</a>
<a name="ln476">  if (family == AF_INET6)</a>
<a name="ln477">    {</a>
<a name="ln478">      ret = setsockopt (sock, IPPROTO_IPV6, IPV6_UNICAST_HOPS, </a>
<a name="ln479">			(void *) &amp;ttl, sizeof (int));</a>
<a name="ln480">      if (ret &lt; 0)</a>
<a name="ln481">	{</a>
<a name="ln482">	  zlog (NULL, LOG_WARNING, &quot;can't set sockopt IPV6_UNICAST_HOPS %d to socket %d&quot;,</a>
<a name="ln483">		    ttl, sock);</a>
<a name="ln484">	  return -1;</a>
<a name="ln485">	}</a>
<a name="ln486">      return 0;</a>
<a name="ln487">    }</a>
<a name="ln488">#endif /* HAVE_IPV6 */</a>
<a name="ln489">  return 0;</a>
<a name="ln490">}</a>
<a name="ln491"> </a>
<a name="ln492">int</a>
<a name="ln493">sockopt_cork (int sock, int onoff)</a>
<a name="ln494">{</a>
<a name="ln495">#ifdef TCP_CORK</a>
<a name="ln496">  return setsockopt (sock, IPPROTO_TCP, TCP_CORK, &amp;onoff, sizeof(onoff));</a>
<a name="ln497">#else</a>
<a name="ln498">  return 0;</a>
<a name="ln499">#endif</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">int</a>
<a name="ln503">sockopt_minttl (int family, int sock, int minttl)</a>
<a name="ln504">{</a>
<a name="ln505">#ifdef IP_MINTTL</a>
<a name="ln506">  if (family == AF_INET)</a>
<a name="ln507">    {</a>
<a name="ln508">      int ret = setsockopt (sock, IPPROTO_IP, IP_MINTTL, &amp;minttl, sizeof(minttl));</a>
<a name="ln509">      if (ret &lt; 0)</a>
<a name="ln510">	  zlog (NULL, LOG_WARNING,</a>
<a name="ln511">		&quot;can't set sockopt IP_MINTTL to %d on socket %d: %s&quot;,</a>
<a name="ln512">		minttl, sock, safe_strerror (errno));</a>
<a name="ln513">      return ret;</a>
<a name="ln514">    }</a>
<a name="ln515">#endif /* IP_MINTTL */</a>
<a name="ln516">#ifdef IPV6_MINHOPCNT</a>
<a name="ln517">  if (family == AF_INET6)</a>
<a name="ln518">    {</a>
<a name="ln519">      int ret = setsockopt (sock, IPPROTO_IPV6, IPV6_MINHOPCNT, &amp;minttl, sizeof(minttl));</a>
<a name="ln520">      if (ret &lt; 0)</a>
<a name="ln521">	  zlog (NULL, LOG_WARNING,</a>
<a name="ln522">		&quot;can't set sockopt IPV6_MINHOPCNT to %d on socket %d: %s&quot;,</a>
<a name="ln523">		minttl, sock, safe_strerror (errno));</a>
<a name="ln524">      return ret;</a>
<a name="ln525">    }</a>
<a name="ln526">#endif</a>
<a name="ln527"> </a>
<a name="ln528">  errno = EOPNOTSUPP;</a>
<a name="ln529">  return -1;</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">int</a>
<a name="ln533">sockopt_v6only (int family, int sock)</a>
<a name="ln534">{</a>
<a name="ln535">  int ret, on = 1;</a>
<a name="ln536"> </a>
<a name="ln537">#ifdef HAVE_IPV6</a>
<a name="ln538">#ifdef IPV6_V6ONLY</a>
<a name="ln539">  if (family == AF_INET6)</a>
<a name="ln540">    {</a>
<a name="ln541">      ret = setsockopt (sock, IPPROTO_IPV6, IPV6_V6ONLY,</a>
<a name="ln542">			(void *) &amp;on, sizeof (int));</a>
<a name="ln543">      if (ret &lt; 0)</a>
<a name="ln544">	{</a>
<a name="ln545">	  zlog (NULL, LOG_WARNING, &quot;can't set sockopt IPV6_V6ONLY &quot;</a>
<a name="ln546">		    &quot;to socket %d&quot;, sock);</a>
<a name="ln547">	  return -1;</a>
<a name="ln548">	}</a>
<a name="ln549">      return 0;</a>
<a name="ln550">    }</a>
<a name="ln551">#endif /* IPV6_V6ONLY */</a>
<a name="ln552">#endif /* HAVE_IPV6 */</a>
<a name="ln553">  return 0;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">/* If same family and same prefix return 1. */</a>
<a name="ln557">int</a>
<a name="ln558">sockunion_same (const union sockunion *su1, const union sockunion *su2)</a>
<a name="ln559">{</a>
<a name="ln560">  int ret = 0;</a>
<a name="ln561"> </a>
<a name="ln562">  if (su1-&gt;sa.sa_family != su2-&gt;sa.sa_family)</a>
<a name="ln563">    return 0;</a>
<a name="ln564"> </a>
<a name="ln565">  switch (su1-&gt;sa.sa_family)</a>
<a name="ln566">    {</a>
<a name="ln567">    case AF_INET:</a>
<a name="ln568">      ret = memcmp (&amp;su1-&gt;sin.sin_addr, &amp;su2-&gt;sin.sin_addr,</a>
<a name="ln569">		    sizeof (struct in_addr));</a>
<a name="ln570">      break;</a>
<a name="ln571">#ifdef HAVE_IPV6</a>
<a name="ln572">    case AF_INET6:</a>
<a name="ln573">      ret = memcmp (&amp;su1-&gt;sin6.sin6_addr, &amp;su2-&gt;sin6.sin6_addr,</a>
<a name="ln574">		    sizeof (struct in6_addr));</a>
<a name="ln575">      break;</a>
<a name="ln576">#endif /* HAVE_IPV6 */</a>
<a name="ln577">    }</a>
<a name="ln578">  if (ret == 0)</a>
<a name="ln579">    return 1;</a>
<a name="ln580">  else</a>
<a name="ln581">    return 0;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">unsigned int</a>
<a name="ln585">sockunion_hash (const union sockunion *su)</a>
<a name="ln586">{</a>
<a name="ln587">  switch (sockunion_family(su))</a>
<a name="ln588">    {</a>
<a name="ln589">    case AF_INET:</a>
<a name="ln590">      return jhash_1word(su-&gt;sin.sin_addr.s_addr, 0);</a>
<a name="ln591">#ifdef HAVE_IPV6</a>
<a name="ln592">    case AF_INET6:</a>
<a name="ln593">      return jhash2(su-&gt;sin6.sin6_addr.s6_addr32, ZEBRA_NUM_OF(su-&gt;sin6.sin6_addr.s6_addr32), 0);</a>
<a name="ln594">#endif /* HAVE_IPV6 */</a>
<a name="ln595">    }</a>
<a name="ln596">  return 0;</a>
<a name="ln597">}</a>
<a name="ln598"> </a>
<a name="ln599">size_t</a>
<a name="ln600">family2addrsize(int family)</a>
<a name="ln601">{</a>
<a name="ln602">  switch (family)</a>
<a name="ln603">    {</a>
<a name="ln604">    case AF_INET:</a>
<a name="ln605">      return sizeof(struct in_addr);</a>
<a name="ln606">#ifdef HAVE_IPV6</a>
<a name="ln607">    case AF_INET6:</a>
<a name="ln608">      return sizeof(struct in6_addr);</a>
<a name="ln609">#endif /* HAVE_IPV6 */</a>
<a name="ln610">    }</a>
<a name="ln611">  return 0;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">size_t</a>
<a name="ln615">sockunion_get_addrlen(const union sockunion *su)</a>
<a name="ln616">{</a>
<a name="ln617">  return family2addrsize(sockunion_family(su));</a>
<a name="ln618">}</a>
<a name="ln619"> </a>
<a name="ln620">const u_char *</a>
<a name="ln621">sockunion_get_addr(const union sockunion *su)</a>
<a name="ln622">{</a>
<a name="ln623">  switch (sockunion_family(su))</a>
<a name="ln624">    {</a>
<a name="ln625">    case AF_INET:</a>
<a name="ln626">      return (const u_char *) &amp;su-&gt;sin.sin_addr.s_addr;</a>
<a name="ln627">#ifdef HAVE_IPV6</a>
<a name="ln628">    case AF_INET6:</a>
<a name="ln629">      return (const u_char *) &amp;su-&gt;sin6.sin6_addr;</a>
<a name="ln630">#endif /* HAVE_IPV6 */</a>
<a name="ln631">    }</a>
<a name="ln632">  return NULL;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">unsigned short</a>
<a name="ln636">sockunion_get_port (const union sockunion *su)</a>
<a name="ln637">{</a>
<a name="ln638">  switch (sockunion_family (su))</a>
<a name="ln639">    {</a>
<a name="ln640">    case AF_INET:</a>
<a name="ln641">      return ntohs(su-&gt;sin.sin_port);</a>
<a name="ln642">#ifdef HAVE_IPV6</a>
<a name="ln643">    case AF_INET6:</a>
<a name="ln644">      return ntohs(su-&gt;sin6.sin6_port);</a>
<a name="ln645">#endif /* HAVE_IPV6 */</a>
<a name="ln646">    }</a>
<a name="ln647">  return 0;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">void</a>
<a name="ln651">sockunion_set(union sockunion *su, int family, const u_char *addr, size_t bytes)</a>
<a name="ln652">{</a>
<a name="ln653">  if (family2addrsize(family) != bytes)</a>
<a name="ln654">    return;</a>
<a name="ln655"> </a>
<a name="ln656">  sockunion_family(su) = family;</a>
<a name="ln657">  switch (family)</a>
<a name="ln658">    {</a>
<a name="ln659">    case AF_INET:</a>
<a name="ln660">      memcpy(&amp;su-&gt;sin.sin_addr.s_addr, addr, bytes);</a>
<a name="ln661">      break;</a>
<a name="ln662">#ifdef HAVE_IPV6</a>
<a name="ln663">    case AF_INET6:</a>
<a name="ln664">      memcpy(&amp;su-&gt;sin6.sin6_addr, addr, bytes);</a>
<a name="ln665">      break;</a>
<a name="ln666">#endif /* HAVE_IPV6 */</a>
<a name="ln667">    }</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">/* After TCP connection is established.  Get local address and port. */</a>
<a name="ln671">union sockunion *</a>
<a name="ln672">sockunion_getsockname (int fd)</a>
<a name="ln673">{</a>
<a name="ln674">  int ret;</a>
<a name="ln675">  socklen_t len;</a>
<a name="ln676">  union</a>
<a name="ln677">  {</a>
<a name="ln678">    struct sockaddr sa;</a>
<a name="ln679">    struct sockaddr_in sin;</a>
<a name="ln680">#ifdef HAVE_IPV6</a>
<a name="ln681">    struct sockaddr_in6 sin6;</a>
<a name="ln682">#endif /* HAVE_IPV6 */</a>
<a name="ln683">    char tmp_buffer[128];</a>
<a name="ln684">  } name;</a>
<a name="ln685">  union sockunion *su;</a>
<a name="ln686"> </a>
<a name="ln687">  memset (&amp;name, 0, sizeof name);</a>
<a name="ln688">  len = sizeof name;</a>
<a name="ln689"> </a>
<a name="ln690">  ret = getsockname (fd, (struct sockaddr *)&amp;name, &amp;len);</a>
<a name="ln691">  if (ret &lt; 0)</a>
<a name="ln692">    {</a>
<a name="ln693">      zlog_warn (&quot;Can't get local address and port by getsockname: %s&quot;,</a>
<a name="ln694">		 safe_strerror (errno));</a>
<a name="ln695">      return NULL;</a>
<a name="ln696">    }</a>
<a name="ln697"> </a>
<a name="ln698">  if (name.sa.sa_family == AF_INET)</a>
<a name="ln699">    {</a>
<a name="ln700">      su = XCALLOC (MTYPE_SOCKUNION, sizeof (union sockunion));</a>
<a name="ln701">      memcpy (su, &amp;name, sizeof (struct sockaddr_in));</a>
<a name="ln702">      return su;</a>
<a name="ln703">    }</a>
<a name="ln704">#ifdef HAVE_IPV6</a>
<a name="ln705">  if (name.sa.sa_family == AF_INET6)</a>
<a name="ln706">    {</a>
<a name="ln707">      su = XCALLOC (MTYPE_SOCKUNION, sizeof (union sockunion));</a>
<a name="ln708">      memcpy (su, &amp;name, sizeof (struct sockaddr_in6));</a>
<a name="ln709">      sockunion_normalise_mapped (su);</a>
<a name="ln710">      return su;</a>
<a name="ln711">    }</a>
<a name="ln712">#endif /* HAVE_IPV6 */</a>
<a name="ln713">  return NULL;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">/* After TCP connection is established.  Get remote address and port. */</a>
<a name="ln717">union sockunion *</a>
<a name="ln718">sockunion_getpeername (int fd)</a>
<a name="ln719">{</a>
<a name="ln720">  int ret;</a>
<a name="ln721">  socklen_t len;</a>
<a name="ln722">  union</a>
<a name="ln723">  {</a>
<a name="ln724">    struct sockaddr sa;</a>
<a name="ln725">    struct sockaddr_in sin;</a>
<a name="ln726">#ifdef HAVE_IPV6</a>
<a name="ln727">    struct sockaddr_in6 sin6;</a>
<a name="ln728">#endif /* HAVE_IPV6 */</a>
<a name="ln729">    char tmp_buffer[128];</a>
<a name="ln730">  } name;</a>
<a name="ln731">  union sockunion *su;</a>
<a name="ln732"> </a>
<a name="ln733">  memset (&amp;name, 0, sizeof name);</a>
<a name="ln734">  len = sizeof name;</a>
<a name="ln735">  ret = getpeername (fd, (struct sockaddr *)&amp;name, &amp;len);</a>
<a name="ln736">  if (ret &lt; 0)</a>
<a name="ln737">    {</a>
<a name="ln738">      zlog (NULL, LOG_WARNING, &quot;Can't get remote address and port: %s&quot;,</a>
<a name="ln739">	    safe_strerror (errno));</a>
<a name="ln740">      return NULL;</a>
<a name="ln741">    }</a>
<a name="ln742"> </a>
<a name="ln743">  if (name.sa.sa_family == AF_INET)</a>
<a name="ln744">    {</a>
<a name="ln745">      su = XCALLOC (MTYPE_SOCKUNION, sizeof (union sockunion));</a>
<a name="ln746">      memcpy (su, &amp;name, sizeof (struct sockaddr_in));</a>
<a name="ln747">      return su;</a>
<a name="ln748">    }</a>
<a name="ln749">#ifdef HAVE_IPV6</a>
<a name="ln750">  if (name.sa.sa_family == AF_INET6)</a>
<a name="ln751">    {</a>
<a name="ln752">      su = XCALLOC (MTYPE_SOCKUNION, sizeof (union sockunion));</a>
<a name="ln753">      memcpy (su, &amp;name, sizeof (struct sockaddr_in6));</a>
<a name="ln754">      sockunion_normalise_mapped (su);</a>
<a name="ln755">      return su;</a>
<a name="ln756">    }</a>
<a name="ln757">#endif /* HAVE_IPV6 */</a>
<a name="ln758">  return NULL;</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">/* Print sockunion structure */</a>
<a name="ln762">static void __attribute__ ((unused))</a>
<a name="ln763">sockunion_print (const union sockunion *su)</a>
<a name="ln764">{</a>
<a name="ln765">  if (su == NULL)</a>
<a name="ln766">    return;</a>
<a name="ln767"> </a>
<a name="ln768">  switch (su-&gt;sa.sa_family) </a>
<a name="ln769">    {</a>
<a name="ln770">    case AF_INET:</a>
<a name="ln771">      printf (&quot;%s\n&quot;, inet_ntoa (su-&gt;sin.sin_addr));</a>
<a name="ln772">      break;</a>
<a name="ln773">#ifdef HAVE_IPV6</a>
<a name="ln774">    case AF_INET6:</a>
<a name="ln775">      {</a>
<a name="ln776">	char buf [SU_ADDRSTRLEN];</a>
<a name="ln777"> </a>
<a name="ln778">	printf (&quot;%s\n&quot;, inet_ntop (AF_INET6, &amp;(su-&gt;sin6.sin6_addr),</a>
<a name="ln779">				 buf, sizeof (buf)));</a>
<a name="ln780">      }</a>
<a name="ln781">      break;</a>
<a name="ln782">#endif /* HAVE_IPV6 */</a>
<a name="ln783"> </a>
<a name="ln784">#ifdef AF_LINK</a>
<a name="ln785">    case AF_LINK:</a>
<a name="ln786">      {</a>
<a name="ln787">	struct sockaddr_dl *sdl;</a>
<a name="ln788"> </a>
<a name="ln789">	sdl = (struct sockaddr_dl *)&amp;(su-&gt;sa);</a>
<a name="ln790">	printf (&quot;link#%d\n&quot;, sdl-&gt;sdl_index);</a>
<a name="ln791">      }</a>
<a name="ln792">      break;</a>
<a name="ln793">#endif /* AF_LINK */</a>
<a name="ln794">    default:</a>
<a name="ln795">      printf (&quot;af_unknown %d\n&quot;, su-&gt;sa.sa_family);</a>
<a name="ln796">      break;</a>
<a name="ln797">    }</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">#ifdef HAVE_IPV6</a>
<a name="ln801">static int</a>
<a name="ln802">in6addr_cmp (const struct in6_addr *addr1, const struct in6_addr *addr2)</a>
<a name="ln803">{</a>
<a name="ln804">  unsigned int i;</a>
<a name="ln805">  u_char *p1, *p2;</a>
<a name="ln806"> </a>
<a name="ln807">  p1 = (u_char *)addr1;</a>
<a name="ln808">  p2 = (u_char *)addr2;</a>
<a name="ln809"> </a>
<a name="ln810">  for (i = 0; i &lt; sizeof (struct in6_addr); i++)</a>
<a name="ln811">    {</a>
<a name="ln812">      if (p1[i] &gt; p2[i])</a>
<a name="ln813">	return 1;</a>
<a name="ln814">      else if (p1[i] &lt; p2[i])</a>
<a name="ln815">	return -1;</a>
<a name="ln816">    }</a>
<a name="ln817">  return 0;</a>
<a name="ln818">}</a>
<a name="ln819">#endif /* HAVE_IPV6 */</a>
<a name="ln820"> </a>
<a name="ln821">int</a>
<a name="ln822">sockunion_cmp (const union sockunion *su1, const union sockunion *su2)</a>
<a name="ln823">{</a>
<a name="ln824">  if (su1-&gt;sa.sa_family &gt; su2-&gt;sa.sa_family)</a>
<a name="ln825">    return 1;</a>
<a name="ln826">  if (su1-&gt;sa.sa_family &lt; su2-&gt;sa.sa_family)</a>
<a name="ln827">    return -1;</a>
<a name="ln828"> </a>
<a name="ln829">  if (su1-&gt;sa.sa_family == AF_INET)</a>
<a name="ln830">    {</a>
<a name="ln831">      if (ntohl (sockunion2ip (su1)) == ntohl (sockunion2ip (su2)))</a>
<a name="ln832">	return 0;</a>
<a name="ln833">      if (ntohl (sockunion2ip (su1)) &gt; ntohl (sockunion2ip (su2)))</a>
<a name="ln834">	return 1;</a>
<a name="ln835">      else</a>
<a name="ln836">	return -1;</a>
<a name="ln837">    }</a>
<a name="ln838">#ifdef HAVE_IPV6</a>
<a name="ln839">  if (su1-&gt;sa.sa_family == AF_INET6)</a>
<a name="ln840">    return in6addr_cmp (&amp;su1-&gt;sin6.sin6_addr, &amp;su2-&gt;sin6.sin6_addr);</a>
<a name="ln841">#endif /* HAVE_IPV6 */</a>
<a name="ln842">  return 0;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">/* Duplicate sockunion. */</a>
<a name="ln846">union sockunion *</a>
<a name="ln847">sockunion_dup (const union sockunion *su)</a>
<a name="ln848">{</a>
<a name="ln849">  union sockunion *dup = XCALLOC (MTYPE_SOCKUNION, sizeof (union sockunion));</a>
<a name="ln850">  memcpy (dup, su, sizeof (union sockunion));</a>
<a name="ln851">  return dup;</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">void</a>
<a name="ln855">sockunion_free (union sockunion *su)</a>
<a name="ln856">{</a>
<a name="ln857">  XFREE (MTYPE_SOCKUNION, su);</a>
<a name="ln858">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="211"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'su'.</p></div>
<div class="balloon" rel="701"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'su'.</p></div>
<div class="balloon" rel="701"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer '& name'.</p></div>
<div class="balloon" rel="746"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer 'su'.</p></div>
<div class="balloon" rel="746"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memcpy' function will lead to underflow of the buffer '& name'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
