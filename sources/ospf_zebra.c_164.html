
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_zebra.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Zebra connect library for OSPFd</a>
<a name="ln3"> * Copyright (C) 1997, 98, 99, 2000 Kunihiro Ishiguro, Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln20"> * Boston, MA 02111-1307, USA. </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;network.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;routemap.h&quot;</a>
<a name="ln30">#include &quot;table.h&quot;</a>
<a name="ln31">#include &quot;stream.h&quot;</a>
<a name="ln32">#include &quot;memory.h&quot;</a>
<a name="ln33">#include &quot;zclient.h&quot;</a>
<a name="ln34">#include &quot;filter.h&quot;</a>
<a name="ln35">#include &quot;plist.h&quot;</a>
<a name="ln36">#include &quot;log.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_abr.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln48">#ifdef HAVE_SNMP</a>
<a name="ln49">#include &quot;ospfd/ospf_snmp.h&quot;</a>
<a name="ln50">#endif /* HAVE_SNMP */</a>
<a name="ln51">#include &quot;ospfd/ospf_te.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">/* Zebra structure to hold current status. */</a>
<a name="ln54">struct zclient *zclient = NULL;</a>
<a name="ln55"> </a>
<a name="ln56">/* For registering threads. */</a>
<a name="ln57">extern struct thread_master *master;</a>
<a name="ln58">struct in_addr router_id_zebra;</a>
<a name="ln59"> </a>
<a name="ln60">/* Router-id update message from zebra. */</a>
<a name="ln61">static int</a>
<a name="ln62">ospf_router_id_update_zebra (int command, struct zclient *zclient,</a>
<a name="ln63">			     zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln64">{</a>
<a name="ln65">  struct ospf *ospf;</a>
<a name="ln66">  struct prefix router_id;</a>
<a name="ln67">  zebra_router_id_update_read(zclient-&gt;ibuf,&amp;router_id);</a>
<a name="ln68"> </a>
<a name="ln69">  if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln70">    {</a>
<a name="ln71">      char buf[128];</a>
<a name="ln72">      prefix2str(&amp;router_id, buf, sizeof(buf));</a>
<a name="ln73">      zlog_debug(&quot;Zebra rcvd: router id update %s&quot;, buf);</a>
<a name="ln74">    }</a>
<a name="ln75"> </a>
<a name="ln76">  router_id_zebra = router_id.u.prefix4;</a>
<a name="ln77"> </a>
<a name="ln78">  ospf = ospf_lookup ();</a>
<a name="ln79">  </a>
<a name="ln80">  if (ospf != NULL)</a>
<a name="ln81">    ospf_router_id_update (ospf);</a>
<a name="ln82">  </a>
<a name="ln83">  return 0;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">/* Inteface addition message from zebra. */</a>
<a name="ln87">static int</a>
<a name="ln88">ospf_interface_add (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln89">    vrf_id_t vrf_id)</a>
<a name="ln90">{</a>
<a name="ln91">  struct interface *ifp;</a>
<a name="ln92"> </a>
<a name="ln93">  ifp = zebra_interface_add_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln94"> </a>
<a name="ln95">  if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln96">    zlog_debug (&quot;Zebra: interface add %s index %d flags %llx metric %d mtu %d&quot;,</a>
<a name="ln97">               ifp-&gt;name, ifp-&gt;ifindex, (unsigned long long)ifp-&gt;flags,</a>
<a name="ln98">               ifp-&gt;metric, ifp-&gt;mtu);</a>
<a name="ln99"> </a>
<a name="ln100">  assert (ifp-&gt;info);</a>
<a name="ln101"> </a>
<a name="ln102">  if (!OSPF_IF_PARAM_CONFIGURED (IF_DEF_PARAMS (ifp), type))</a>
<a name="ln103">    {</a>
<a name="ln104">      SET_IF_PARAM (IF_DEF_PARAMS (ifp), type);</a>
<a name="ln105">      IF_DEF_PARAMS (ifp)-&gt;type = ospf_default_iftype(ifp);</a>
<a name="ln106">    }</a>
<a name="ln107"> </a>
<a name="ln108">  ospf_if_update (NULL, ifp);</a>
<a name="ln109"> </a>
<a name="ln110">#ifdef HAVE_SNMP</a>
<a name="ln111">  ospf_snmp_if_update (ifp);</a>
<a name="ln112">#endif /* HAVE_SNMP */</a>
<a name="ln113"> </a>
<a name="ln114">  return 0;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">static int</a>
<a name="ln118">ospf_interface_delete (int command, struct zclient *zclient,</a>
<a name="ln119">                       zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln120">{</a>
<a name="ln121">  struct interface *ifp;</a>
<a name="ln122">  struct stream *s;</a>
<a name="ln123">  struct route_node *rn;</a>
<a name="ln124"> </a>
<a name="ln125">  s = zclient-&gt;ibuf;</a>
<a name="ln126">  /* zebra_interface_state_read() updates interface structure in iflist */</a>
<a name="ln127">  ifp = zebra_interface_state_read (s, vrf_id);</a>
<a name="ln128"> </a>
<a name="ln129">  if (ifp == NULL)</a>
<a name="ln130">    return 0;</a>
<a name="ln131"> </a>
<a name="ln132">  if (if_is_up (ifp))</a>
<a name="ln133">    zlog_warn (&quot;Zebra: got delete of %s, but interface is still up&quot;,</a>
<a name="ln134">               ifp-&gt;name);</a>
<a name="ln135"> </a>
<a name="ln136">  if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln137">    zlog_debug</a>
<a name="ln138">      (&quot;Zebra: interface delete %s index %d flags %llx metric %d mtu %d&quot;,</a>
<a name="ln139">       ifp-&gt;name, ifp-&gt;ifindex, (unsigned long long)ifp-&gt;flags, ifp-&gt;metric, ifp-&gt;mtu);</a>
<a name="ln140"> </a>
<a name="ln141">#ifdef HAVE_SNMP</a>
<a name="ln142">  ospf_snmp_if_delete (ifp);</a>
<a name="ln143">#endif /* HAVE_SNMP */</a>
<a name="ln144"> </a>
<a name="ln145">  for (rn = route_top (IF_OIFS (ifp)); rn; rn = route_next (rn))</a>
<a name="ln146">    if (rn-&gt;info)</a>
<a name="ln147">      ospf_if_free ((struct ospf_interface *) rn-&gt;info);</a>
<a name="ln148"> </a>
<a name="ln149">  ifp-&gt;ifindex = IFINDEX_INTERNAL;</a>
<a name="ln150">  return 0;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">static struct interface *</a>
<a name="ln154">zebra_interface_if_lookup (struct stream *s, vrf_id_t vrf_id)</a>
<a name="ln155">{</a>
<a name="ln156">  char ifname_tmp[INTERFACE_NAMSIZ];</a>
<a name="ln157"> </a>
<a name="ln158">  /* Read interface name. */</a>
<a name="ln159">  stream_get (ifname_tmp, s, INTERFACE_NAMSIZ);</a>
<a name="ln160"> </a>
<a name="ln161">  /* And look it up. */</a>
<a name="ln162">  return if_lookup_by_name_len(ifname_tmp,</a>
<a name="ln163">			       strnlen(ifname_tmp, INTERFACE_NAMSIZ));</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">static int</a>
<a name="ln167">ospf_interface_state_up (int command, struct zclient *zclient,</a>
<a name="ln168">                         zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln169">{</a>
<a name="ln170">  struct interface *ifp;</a>
<a name="ln171">  struct ospf_interface *oi;</a>
<a name="ln172">  struct route_node *rn;</a>
<a name="ln173"> </a>
<a name="ln174">  ifp = zebra_interface_if_lookup (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln175"> </a>
<a name="ln176">  if (ifp == NULL)</a>
<a name="ln177">    return 0;</a>
<a name="ln178"> </a>
<a name="ln179">  /* Interface is already up. */</a>
<a name="ln180">  if (if_is_operative (ifp))</a>
<a name="ln181">    {</a>
<a name="ln182">      /* Temporarily keep ifp values. */</a>
<a name="ln183">      struct interface if_tmp;</a>
<a name="ln184">      memcpy (&amp;if_tmp, ifp, sizeof (struct interface));</a>
<a name="ln185"> </a>
<a name="ln186">      zebra_interface_if_set_value (zclient-&gt;ibuf, ifp);</a>
<a name="ln187"> </a>
<a name="ln188">      if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln189">        zlog_debug (&quot;Zebra: Interface[%s] state update.&quot;, ifp-&gt;name);</a>
<a name="ln190"> </a>
<a name="ln191">      if (if_tmp.bandwidth != ifp-&gt;bandwidth)</a>
<a name="ln192">        {</a>
<a name="ln193">          if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln194">            zlog_debug (&quot;Zebra: Interface[%s] bandwidth change %d -&gt; %d.&quot;,</a>
<a name="ln195">                       ifp-&gt;name, if_tmp.bandwidth, ifp-&gt;bandwidth);</a>
<a name="ln196"> </a>
<a name="ln197">          ospf_if_recalculate_output_cost (ifp);</a>
<a name="ln198">        }</a>
<a name="ln199"> </a>
<a name="ln200">      if (if_tmp.mtu != ifp-&gt;mtu)</a>
<a name="ln201">        {</a>
<a name="ln202">          if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln203">            zlog_debug (&quot;Zebra: Interface[%s] MTU change %u -&gt; %u.&quot;,</a>
<a name="ln204">                       ifp-&gt;name, if_tmp.mtu, ifp-&gt;mtu);</a>
<a name="ln205"> </a>
<a name="ln206">	  /* Must reset the interface (simulate down/up) when MTU changes. */</a>
<a name="ln207">          ospf_if_reset(ifp);</a>
<a name="ln208">	}</a>
<a name="ln209">      return 0;</a>
<a name="ln210">    }</a>
<a name="ln211"> </a>
<a name="ln212">  zebra_interface_if_set_value (zclient-&gt;ibuf, ifp);</a>
<a name="ln213"> </a>
<a name="ln214">  if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln215">    zlog_debug (&quot;Zebra: Interface[%s] state change to up.&quot;, ifp-&gt;name);</a>
<a name="ln216"> </a>
<a name="ln217">  for (rn = route_top (IF_OIFS (ifp)); rn; rn = route_next (rn))</a>
<a name="ln218">    {</a>
<a name="ln219">      if ((oi = rn-&gt;info) == NULL)</a>
<a name="ln220">        continue;</a>
<a name="ln221"> </a>
<a name="ln222">      ospf_if_up (oi);</a>
<a name="ln223">    }</a>
<a name="ln224"> </a>
<a name="ln225">  return 0;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">static int</a>
<a name="ln229">ospf_interface_state_down (int command, struct zclient *zclient,</a>
<a name="ln230">                           zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln231">{</a>
<a name="ln232">  struct interface *ifp;</a>
<a name="ln233">  struct ospf_interface *oi;</a>
<a name="ln234">  struct route_node *node;</a>
<a name="ln235"> </a>
<a name="ln236">  ifp = zebra_interface_state_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln237"> </a>
<a name="ln238">  if (ifp == NULL)</a>
<a name="ln239">    return 0;</a>
<a name="ln240"> </a>
<a name="ln241">  if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln242">    zlog_debug (&quot;Zebra: Interface[%s] state change to down.&quot;, ifp-&gt;name);</a>
<a name="ln243"> </a>
<a name="ln244">  for (node = route_top (IF_OIFS (ifp)); node; node = route_next (node))</a>
<a name="ln245">    {</a>
<a name="ln246">      if ((oi = node-&gt;info) == NULL)</a>
<a name="ln247">        continue;</a>
<a name="ln248">      ospf_if_down (oi);</a>
<a name="ln249">    }</a>
<a name="ln250"> </a>
<a name="ln251">  return 0;</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">static int</a>
<a name="ln255">ospf_interface_address_add (int command, struct zclient *zclient,</a>
<a name="ln256">                            zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln257">{</a>
<a name="ln258">  struct connected *c;</a>
<a name="ln259"> </a>
<a name="ln260">  c = zebra_interface_address_read (command, zclient-&gt;ibuf, vrf_id);</a>
<a name="ln261"> </a>
<a name="ln262">  if (c == NULL)</a>
<a name="ln263">    return 0;</a>
<a name="ln264"> </a>
<a name="ln265">  if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln266">    {</a>
<a name="ln267">      char buf[128];</a>
<a name="ln268">      prefix2str(c-&gt;address, buf, sizeof(buf));</a>
<a name="ln269">      zlog_debug(&quot;Zebra: interface %s address add %s&quot;, c-&gt;ifp-&gt;name, buf);</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">  ospf_if_update (NULL, c-&gt;ifp);</a>
<a name="ln273"> </a>
<a name="ln274">#ifdef HAVE_SNMP</a>
<a name="ln275">  ospf_snmp_if_update (c-&gt;ifp);</a>
<a name="ln276">#endif /* HAVE_SNMP */</a>
<a name="ln277"> </a>
<a name="ln278">  return 0;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">static int</a>
<a name="ln282">ospf_interface_address_delete (int command, struct zclient *zclient,</a>
<a name="ln283">                               zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln284">{</a>
<a name="ln285">  struct connected *c;</a>
<a name="ln286">  struct interface *ifp;</a>
<a name="ln287">  struct ospf_interface *oi;</a>
<a name="ln288">  struct route_node *rn;</a>
<a name="ln289">  struct prefix p;</a>
<a name="ln290"> </a>
<a name="ln291">  c = zebra_interface_address_read (command, zclient-&gt;ibuf, vrf_id);</a>
<a name="ln292"> </a>
<a name="ln293">  if (c == NULL)</a>
<a name="ln294">    return 0;</a>
<a name="ln295"> </a>
<a name="ln296">  if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln297">    {</a>
<a name="ln298">      char buf[128];</a>
<a name="ln299">      prefix2str(c-&gt;address, buf, sizeof(buf));</a>
<a name="ln300">      zlog_debug(&quot;Zebra: interface %s address delete %s&quot;, c-&gt;ifp-&gt;name, buf);</a>
<a name="ln301">    }</a>
<a name="ln302"> </a>
<a name="ln303">  ifp = c-&gt;ifp;</a>
<a name="ln304">  p = *c-&gt;address;</a>
<a name="ln305">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln306"> </a>
<a name="ln307">  rn = route_node_lookup (IF_OIFS (ifp), &amp;p);</a>
<a name="ln308">  if (!rn)</a>
<a name="ln309">    {</a>
<a name="ln310">      connected_free (c);</a>
<a name="ln311">      return 0;</a>
<a name="ln312">    }</a>
<a name="ln313"> </a>
<a name="ln314">  assert (rn-&gt;info);</a>
<a name="ln315">  oi = rn-&gt;info;</a>
<a name="ln316">  route_unlock_node (rn);</a>
<a name="ln317"> </a>
<a name="ln318">  /* Call interface hook functions to clean up */</a>
<a name="ln319">  ospf_if_free (oi);</a>
<a name="ln320"> </a>
<a name="ln321">#ifdef HAVE_SNMP</a>
<a name="ln322">  ospf_snmp_if_update (c-&gt;ifp);</a>
<a name="ln323">#endif /* HAVE_SNMP */</a>
<a name="ln324"> </a>
<a name="ln325">  connected_free (c);</a>
<a name="ln326"> </a>
<a name="ln327">  return 0;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">static int</a>
<a name="ln331">ospf_interface_link_params (int command, struct zclient *zclient,</a>
<a name="ln332">                        zebra_size_t length)</a>
<a name="ln333">{</a>
<a name="ln334">  struct interface *ifp;</a>
<a name="ln335"> </a>
<a name="ln336">  ifp = zebra_interface_link_params_read (zclient-&gt;ibuf);</a>
<a name="ln337"> </a>
<a name="ln338">  if (ifp == NULL)</a>
<a name="ln339">    return 0;</a>
<a name="ln340"> </a>
<a name="ln341">  /* Update TE TLV */</a>
<a name="ln342">  ospf_mpls_te_update_if (ifp);</a>
<a name="ln343"> </a>
<a name="ln344">  return 0;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347"> </a>
<a name="ln348">void</a>
<a name="ln349">ospf_zebra_add (struct prefix_ipv4 *p, struct ospf_route *or)</a>
<a name="ln350">{</a>
<a name="ln351">  u_char message;</a>
<a name="ln352">  u_char distance;</a>
<a name="ln353">  u_char flags;</a>
<a name="ln354">  int psize;</a>
<a name="ln355">  struct stream *s;</a>
<a name="ln356">  struct ospf_path *path;</a>
<a name="ln357">  struct listnode *node;</a>
<a name="ln358"> </a>
<a name="ln359">  if (vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_OSPF], VRF_DEFAULT))</a>
<a name="ln360">    {</a>
<a name="ln361">      message = 0;</a>
<a name="ln362">      flags = 0;</a>
<a name="ln363"> </a>
<a name="ln364">      /* OSPF pass nexthop and metric */</a>
<a name="ln365">      SET_FLAG (message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln366">      SET_FLAG (message, ZAPI_MESSAGE_METRIC);</a>
<a name="ln367"> </a>
<a name="ln368">      /* Distance value. */</a>
<a name="ln369">      distance = ospf_distance_apply (p, or);</a>
<a name="ln370">      if (distance)</a>
<a name="ln371">        SET_FLAG (message, ZAPI_MESSAGE_DISTANCE);</a>
<a name="ln372"> </a>
<a name="ln373">      /* Check if path type is ASE */</a>
<a name="ln374">      if (((or-&gt;path_type == OSPF_PATH_TYPE1_EXTERNAL) ||</a>
<a name="ln375">          (or-&gt;path_type == OSPF_PATH_TYPE2_EXTERNAL)) &amp;&amp;</a>
<a name="ln376">           (or-&gt;u.ext.tag &gt; 0) &amp;&amp; (or-&gt;u.ext.tag &lt;= ROUTE_TAG_MAX))</a>
<a name="ln377">        SET_FLAG (message, ZAPI_MESSAGE_TAG);</a>
<a name="ln378"> </a>
<a name="ln379">      /* Make packet. */</a>
<a name="ln380">      s = zclient-&gt;obuf;</a>
<a name="ln381">      stream_reset (s);</a>
<a name="ln382"> </a>
<a name="ln383">      /* Put command, type, flags, message. */</a>
<a name="ln384">      zclient_create_header (s, ZEBRA_IPV4_ROUTE_ADD, VRF_DEFAULT);</a>
<a name="ln385">      stream_putc (s, ZEBRA_ROUTE_OSPF);</a>
<a name="ln386">      stream_putc (s, flags);</a>
<a name="ln387">      stream_putc (s, message);</a>
<a name="ln388">      stream_putw (s, SAFI_UNICAST);</a>
<a name="ln389"> </a>
<a name="ln390">      /* Put prefix information. */</a>
<a name="ln391">      psize = PSIZE (p-&gt;prefixlen);</a>
<a name="ln392">      stream_putc (s, p-&gt;prefixlen);</a>
<a name="ln393">      stream_write (s, (u_char *) &amp; p-&gt;prefix, psize);</a>
<a name="ln394"> </a>
<a name="ln395">      /* Nexthop count. */</a>
<a name="ln396">      stream_putc (s, or-&gt;paths-&gt;count);</a>
<a name="ln397"> </a>
<a name="ln398">      /* Nexthop, ifindex, distance and metric information. */</a>
<a name="ln399">      for (ALL_LIST_ELEMENTS_RO (or-&gt;paths, node, path))</a>
<a name="ln400">        {</a>
<a name="ln401">          if (path-&gt;nexthop.s_addr != INADDR_ANY &amp;&amp;</a>
<a name="ln402">	      path-&gt;ifindex != 0)</a>
<a name="ln403">            {</a>
<a name="ln404">              stream_putc (s, ZEBRA_NEXTHOP_IPV4_IFINDEX);</a>
<a name="ln405">              stream_put_in_addr (s, &amp;path-&gt;nexthop);</a>
<a name="ln406">	      stream_putl (s, path-&gt;ifindex);</a>
<a name="ln407">            }</a>
<a name="ln408">          else if (path-&gt;nexthop.s_addr != INADDR_ANY)</a>
<a name="ln409">            {</a>
<a name="ln410">              stream_putc (s, ZEBRA_NEXTHOP_IPV4);</a>
<a name="ln411">              stream_put_in_addr (s, &amp;path-&gt;nexthop);</a>
<a name="ln412">            }</a>
<a name="ln413">          else</a>
<a name="ln414">            {</a>
<a name="ln415">              stream_putc (s, ZEBRA_NEXTHOP_IFINDEX);</a>
<a name="ln416">              if (path-&gt;ifindex)</a>
<a name="ln417">                stream_putl (s, path-&gt;ifindex);</a>
<a name="ln418">              else</a>
<a name="ln419">                stream_putl (s, 0);</a>
<a name="ln420">            }</a>
<a name="ln421"> </a>
<a name="ln422">          if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln423">            {</a>
<a name="ln424">	      char buf[2][INET_ADDRSTRLEN];</a>
<a name="ln425">	      zlog_debug(&quot;Zebra: Route add %s/%d nexthop %s&quot;,</a>
<a name="ln426">			 inet_ntop(AF_INET, &amp;p-&gt;prefix,</a>
<a name="ln427">				   buf[0], sizeof(buf[0])),</a>
<a name="ln428">			 p-&gt;prefixlen,</a>
<a name="ln429">			 inet_ntop(AF_INET, &amp;path-&gt;nexthop,</a>
<a name="ln430">				   buf[1], sizeof(buf[1])));</a>
<a name="ln431">            }</a>
<a name="ln432">        }</a>
<a name="ln433"> </a>
<a name="ln434">      if (CHECK_FLAG (message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln435">        stream_putc (s, distance);</a>
<a name="ln436">      if (CHECK_FLAG (message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln437">        {</a>
<a name="ln438">          if (or-&gt;path_type == OSPF_PATH_TYPE1_EXTERNAL)</a>
<a name="ln439">            stream_putl (s, or-&gt;cost + or-&gt;u.ext.type2_cost);</a>
<a name="ln440">          else if (or-&gt;path_type == OSPF_PATH_TYPE2_EXTERNAL)</a>
<a name="ln441">            stream_putl (s, or-&gt;u.ext.type2_cost);</a>
<a name="ln442">          else</a>
<a name="ln443">            stream_putl (s, or-&gt;cost);</a>
<a name="ln444">        }</a>
<a name="ln445"> </a>
<a name="ln446">      if (CHECK_FLAG (message, ZAPI_MESSAGE_TAG))</a>
<a name="ln447">         stream_putl (s, or-&gt;u.ext.tag);</a>
<a name="ln448"> </a>
<a name="ln449">      stream_putw_at (s, 0, stream_get_endp (s));</a>
<a name="ln450"> </a>
<a name="ln451">      zclient_send_message(zclient);</a>
<a name="ln452">    }</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">void</a>
<a name="ln456">ospf_zebra_delete (struct prefix_ipv4 *p, struct ospf_route *or)</a>
<a name="ln457">{</a>
<a name="ln458">  u_char message;</a>
<a name="ln459">  u_char distance;</a>
<a name="ln460">  u_char flags;</a>
<a name="ln461">  int psize;</a>
<a name="ln462">  struct stream *s;</a>
<a name="ln463">  struct ospf_path *path;</a>
<a name="ln464">  struct listnode *node;</a>
<a name="ln465"> </a>
<a name="ln466">  if (vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_OSPF], VRF_DEFAULT))</a>
<a name="ln467">    {</a>
<a name="ln468">      message = 0;</a>
<a name="ln469">      flags = 0;</a>
<a name="ln470">      /* Distance value. */</a>
<a name="ln471">      distance = ospf_distance_apply (p, or);</a>
<a name="ln472">      /* Make packet. */</a>
<a name="ln473">      s = zclient-&gt;obuf;</a>
<a name="ln474">      stream_reset (s);</a>
<a name="ln475"> </a>
<a name="ln476">      /* Put command, type, flags, message. */</a>
<a name="ln477">      zclient_create_header (s, ZEBRA_IPV4_ROUTE_DELETE, VRF_DEFAULT);</a>
<a name="ln478">      stream_putc (s, ZEBRA_ROUTE_OSPF);</a>
<a name="ln479">      stream_putc (s, flags);</a>
<a name="ln480">      stream_putc (s, message);</a>
<a name="ln481">      stream_putw (s, SAFI_UNICAST);</a>
<a name="ln482"> </a>
<a name="ln483">      /* Put prefix information. */</a>
<a name="ln484">      psize = PSIZE (p-&gt;prefixlen);</a>
<a name="ln485">      stream_putc (s, p-&gt;prefixlen);</a>
<a name="ln486">      stream_write (s, (u_char *) &amp; p-&gt;prefix, psize);</a>
<a name="ln487"> </a>
<a name="ln488">      /* Nexthop count. */</a>
<a name="ln489">      stream_putc (s, or-&gt;paths-&gt;count);</a>
<a name="ln490"> </a>
<a name="ln491">      /* Nexthop, ifindex, distance and metric information. */</a>
<a name="ln492">      for (ALL_LIST_ELEMENTS_RO (or-&gt;paths, node, path))</a>
<a name="ln493">	{</a>
<a name="ln494">	  if (path-&gt;nexthop.s_addr != INADDR_ANY &amp;&amp;</a>
<a name="ln495">	      path-&gt;ifindex != 0)</a>
<a name="ln496">	    {</a>
<a name="ln497">	      stream_putc (s, ZEBRA_NEXTHOP_IPV4_IFINDEX);</a>
<a name="ln498">	      stream_put_in_addr (s, &amp;path-&gt;nexthop);</a>
<a name="ln499">	      stream_putl (s, path-&gt;ifindex);</a>
<a name="ln500">	    }</a>
<a name="ln501">	  else if (path-&gt;nexthop.s_addr != INADDR_ANY)</a>
<a name="ln502">	    {</a>
<a name="ln503">	      stream_putc (s, ZEBRA_NEXTHOP_IPV4);</a>
<a name="ln504">	      stream_put_in_addr (s, &amp;path-&gt;nexthop);</a>
<a name="ln505">	    }</a>
<a name="ln506">	  else</a>
<a name="ln507">	    {</a>
<a name="ln508">	      stream_putc (s, ZEBRA_NEXTHOP_IFINDEX);</a>
<a name="ln509">	      stream_putl (s, path-&gt;ifindex);</a>
<a name="ln510">	    }</a>
<a name="ln511"> </a>
<a name="ln512">	  if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln513">	    {</a>
<a name="ln514">	      char buf[2][INET_ADDRSTRLEN];</a>
<a name="ln515">	      zlog_debug(&quot;Zebra: Route delete %s/%d nexthop %s&quot;,</a>
<a name="ln516">			 inet_ntop(AF_INET, &amp;p-&gt;prefix,</a>
<a name="ln517">				   buf[0], sizeof(buf[0])),</a>
<a name="ln518">			 p-&gt;prefixlen,</a>
<a name="ln519">			 inet_ntop(AF_INET, &amp;path-&gt;nexthop,</a>
<a name="ln520">				   buf[1], sizeof(buf[1])));</a>
<a name="ln521">	    }</a>
<a name="ln522">	}</a>
<a name="ln523"> </a>
<a name="ln524">      if (CHECK_FLAG (message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln525">	stream_putc (s, distance);</a>
<a name="ln526">      if (CHECK_FLAG (message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln527">	{</a>
<a name="ln528">	  if (or-&gt;path_type == OSPF_PATH_TYPE1_EXTERNAL)</a>
<a name="ln529">	    stream_putl (s, or-&gt;cost + or-&gt;u.ext.type2_cost);</a>
<a name="ln530">	  else if (or-&gt;path_type == OSPF_PATH_TYPE2_EXTERNAL)</a>
<a name="ln531">	    stream_putl (s, or-&gt;u.ext.type2_cost);</a>
<a name="ln532">	  else</a>
<a name="ln533">	    stream_putl (s, or-&gt;cost);</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">      stream_putw_at (s, 0, stream_get_endp (s));</a>
<a name="ln537"> </a>
<a name="ln538">      zclient_send_message(zclient);</a>
<a name="ln539">    }</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">void</a>
<a name="ln543">ospf_zebra_add_discard (struct prefix_ipv4 *p)</a>
<a name="ln544">{</a>
<a name="ln545">  struct zapi_ipv4 api;</a>
<a name="ln546"> </a>
<a name="ln547">  if (vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_OSPF], VRF_DEFAULT))</a>
<a name="ln548">    {</a>
<a name="ln549">      api.vrf_id = VRF_DEFAULT;</a>
<a name="ln550">      api.type = ZEBRA_ROUTE_OSPF;</a>
<a name="ln551">      api.flags = ZEBRA_FLAG_BLACKHOLE;</a>
<a name="ln552">      api.message = 0;</a>
<a name="ln553">      api.safi = SAFI_UNICAST;</a>
<a name="ln554">      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln555">      api.nexthop_num = 0;</a>
<a name="ln556">      api.ifindex_num = 0;</a>
<a name="ln557">      api.tag = 0;</a>
<a name="ln558"> </a>
<a name="ln559">      zapi_ipv4_route (ZEBRA_IPV4_ROUTE_ADD, zclient, p, &amp;api);</a>
<a name="ln560"> </a>
<a name="ln561">      if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln562">        zlog_debug (&quot;Zebra: Route add discard %s/%d&quot;,</a>
<a name="ln563">                   inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln564">    }</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">void</a>
<a name="ln568">ospf_zebra_delete_discard (struct prefix_ipv4 *p)</a>
<a name="ln569">{</a>
<a name="ln570">  struct zapi_ipv4 api;</a>
<a name="ln571"> </a>
<a name="ln572">  if (vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_OSPF], VRF_DEFAULT))</a>
<a name="ln573">    {</a>
<a name="ln574">      api.vrf_id = VRF_DEFAULT;</a>
<a name="ln575">      api.type = ZEBRA_ROUTE_OSPF;</a>
<a name="ln576">      api.flags = ZEBRA_FLAG_BLACKHOLE;</a>
<a name="ln577">      api.message = 0;</a>
<a name="ln578">      api.safi = SAFI_UNICAST;</a>
<a name="ln579">      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln580">      api.nexthop_num = 0;</a>
<a name="ln581">      api.ifindex_num = 0;</a>
<a name="ln582">      api.tag = 0;</a>
<a name="ln583"> </a>
<a name="ln584">      zapi_ipv4_route (ZEBRA_IPV4_ROUTE_DELETE, zclient, p, &amp;api);</a>
<a name="ln585"> </a>
<a name="ln586">      if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln587">        zlog_debug (&quot;Zebra: Route delete discard %s/%d&quot;,</a>
<a name="ln588">                   inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln589"> </a>
<a name="ln590">    }</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">int</a>
<a name="ln594">ospf_is_type_redistributed (int type)</a>
<a name="ln595">{</a>
<a name="ln596">  return (DEFAULT_ROUTE_TYPE (type)) ?</a>
<a name="ln597">    vrf_bitmap_check (zclient-&gt;default_information, VRF_DEFAULT) : \</a>
<a name="ln598">    vrf_bitmap_check (zclient-&gt;redist[type], VRF_DEFAULT);</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">int</a>
<a name="ln602">ospf_redistribute_set (struct ospf *ospf, int type, int mtype, int mvalue)</a>
<a name="ln603">{</a>
<a name="ln604">  int force = 0;</a>
<a name="ln605"> </a>
<a name="ln606">  if (ospf_is_type_redistributed (type))</a>
<a name="ln607">    {</a>
<a name="ln608">      if (mtype != ospf-&gt;dmetric[type].type)</a>
<a name="ln609">        {</a>
<a name="ln610">          ospf-&gt;dmetric[type].type = mtype;</a>
<a name="ln611">          force = LSA_REFRESH_FORCE;</a>
<a name="ln612">        }</a>
<a name="ln613">      if (mvalue != ospf-&gt;dmetric[type].value)</a>
<a name="ln614">        {</a>
<a name="ln615">          ospf-&gt;dmetric[type].value = mvalue;</a>
<a name="ln616">          force = LSA_REFRESH_FORCE;</a>
<a name="ln617">        }</a>
<a name="ln618"> </a>
<a name="ln619">      ospf_external_lsa_refresh_type (ospf, type, force);</a>
<a name="ln620"> </a>
<a name="ln621">      if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln622">        zlog_debug (&quot;Redistribute[%s]: Refresh  Type[%d], Metric[%d]&quot;,</a>
<a name="ln623">                   ospf_redist_string(type),</a>
<a name="ln624">                   metric_type (ospf, type), metric_value (ospf, type));</a>
<a name="ln625"> </a>
<a name="ln626">      return CMD_SUCCESS;</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">  ospf-&gt;dmetric[type].type = mtype;</a>
<a name="ln630">  ospf-&gt;dmetric[type].value = mvalue;</a>
<a name="ln631"> </a>
<a name="ln632">  zclient_redistribute (ZEBRA_REDISTRIBUTE_ADD, zclient, type, VRF_DEFAULT);</a>
<a name="ln633"> </a>
<a name="ln634">  if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln635">    zlog_debug (&quot;Redistribute[%s]: Start  Type[%d], Metric[%d]&quot;,</a>
<a name="ln636">               ospf_redist_string(type),</a>
<a name="ln637">               metric_type (ospf, type), metric_value (ospf, type));</a>
<a name="ln638"> </a>
<a name="ln639">  ospf_asbr_status_update (ospf, ++ospf-&gt;redistribute);</a>
<a name="ln640"> </a>
<a name="ln641">  return CMD_SUCCESS;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">int</a>
<a name="ln645">ospf_redistribute_unset (struct ospf *ospf, int type)</a>
<a name="ln646">{</a>
<a name="ln647">  if (type == zclient-&gt;redist_default)</a>
<a name="ln648">    return CMD_SUCCESS;</a>
<a name="ln649"> </a>
<a name="ln650">  if (!ospf_is_type_redistributed (type))</a>
<a name="ln651">    return CMD_SUCCESS;</a>
<a name="ln652"> </a>
<a name="ln653">  zclient_redistribute (ZEBRA_REDISTRIBUTE_DELETE, zclient, type, VRF_DEFAULT);</a>
<a name="ln654"> </a>
<a name="ln655">  if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln656">    zlog_debug (&quot;Redistribute[%s]: Stop&quot;,</a>
<a name="ln657">               ospf_redist_string(type));</a>
<a name="ln658"> </a>
<a name="ln659">  ospf-&gt;dmetric[type].type = -1;</a>
<a name="ln660">  ospf-&gt;dmetric[type].value = -1;</a>
<a name="ln661"> </a>
<a name="ln662">  /* Remove the routes from OSPF table. */</a>
<a name="ln663">  ospf_redistribute_withdraw (ospf, type);</a>
<a name="ln664"> </a>
<a name="ln665">  ospf_asbr_status_update (ospf, --ospf-&gt;redistribute);</a>
<a name="ln666"> </a>
<a name="ln667">  return CMD_SUCCESS;</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">int</a>
<a name="ln671">ospf_redistribute_default_set (struct ospf *ospf, int originate,</a>
<a name="ln672">                               int mtype, int mvalue)</a>
<a name="ln673">{</a>
<a name="ln674">  ospf-&gt;default_originate = originate;</a>
<a name="ln675">  ospf-&gt;dmetric[DEFAULT_ROUTE].type = mtype;</a>
<a name="ln676">  ospf-&gt;dmetric[DEFAULT_ROUTE].value = mvalue;</a>
<a name="ln677"> </a>
<a name="ln678">  if (ospf_is_type_redistributed (DEFAULT_ROUTE))</a>
<a name="ln679">    {</a>
<a name="ln680">      /* if ospf-&gt;default_originate changes value, is calling</a>
<a name="ln681">	 ospf_external_lsa_refresh_default sufficient to implement</a>
<a name="ln682">	 the change? */</a>
<a name="ln683">      ospf_external_lsa_refresh_default (ospf);</a>
<a name="ln684"> </a>
<a name="ln685">      if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln686">        zlog_debug (&quot;Redistribute[%s]: Refresh  Type[%d], Metric[%d]&quot;,</a>
<a name="ln687">                   ospf_redist_string(DEFAULT_ROUTE),</a>
<a name="ln688">                   metric_type (ospf, DEFAULT_ROUTE),</a>
<a name="ln689">                   metric_value (ospf, DEFAULT_ROUTE));</a>
<a name="ln690">      return CMD_SUCCESS;</a>
<a name="ln691">    }</a>
<a name="ln692"> </a>
<a name="ln693">  zclient_redistribute_default (ZEBRA_REDISTRIBUTE_DEFAULT_ADD, zclient,</a>
<a name="ln694">                                VRF_DEFAULT);</a>
<a name="ln695"> </a>
<a name="ln696">  if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln697">    zlog_debug (&quot;Redistribute[DEFAULT]: Start  Type[%d], Metric[%d]&quot;,</a>
<a name="ln698">               metric_type (ospf, DEFAULT_ROUTE),</a>
<a name="ln699">               metric_value (ospf, DEFAULT_ROUTE));</a>
<a name="ln700"> </a>
<a name="ln701">  if (ospf-&gt;router_id.s_addr == 0)</a>
<a name="ln702">    ospf-&gt;external_origin |= (1 &lt;&lt; DEFAULT_ROUTE);</a>
<a name="ln703">  else</a>
<a name="ln704">    thread_add_timer (master, ospf_default_originate_timer, ospf, 1);</a>
<a name="ln705"> </a>
<a name="ln706">  ospf_asbr_status_update (ospf, ++ospf-&gt;redistribute);</a>
<a name="ln707"> </a>
<a name="ln708">  return CMD_SUCCESS;</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">int</a>
<a name="ln712">ospf_redistribute_default_unset (struct ospf *ospf)</a>
<a name="ln713">{</a>
<a name="ln714">  if (!ospf_is_type_redistributed (DEFAULT_ROUTE))</a>
<a name="ln715">    return CMD_SUCCESS;</a>
<a name="ln716"> </a>
<a name="ln717">  ospf-&gt;default_originate = DEFAULT_ORIGINATE_NONE;</a>
<a name="ln718">  ospf-&gt;dmetric[DEFAULT_ROUTE].type = -1;</a>
<a name="ln719">  ospf-&gt;dmetric[DEFAULT_ROUTE].value = -1;</a>
<a name="ln720"> </a>
<a name="ln721">  zclient_redistribute_default (ZEBRA_REDISTRIBUTE_DEFAULT_DELETE, zclient,</a>
<a name="ln722">                                VRF_DEFAULT);</a>
<a name="ln723"> </a>
<a name="ln724">  if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln725">    zlog_debug (&quot;Redistribute[DEFAULT]: Stop&quot;);</a>
<a name="ln726"> </a>
<a name="ln727">  ospf_asbr_status_update (ospf, --ospf-&gt;redistribute);</a>
<a name="ln728"> </a>
<a name="ln729">  return CMD_SUCCESS;</a>
<a name="ln730">}</a>
<a name="ln731"> </a>
<a name="ln732">static int</a>
<a name="ln733">ospf_external_lsa_originate_check (struct ospf *ospf,</a>
<a name="ln734">                                   struct external_info *ei)</a>
<a name="ln735">{</a>
<a name="ln736">  /* If prefix is multicast, then do not originate LSA. */</a>
<a name="ln737">  if (IN_MULTICAST (htonl (ei-&gt;p.prefix.s_addr)))</a>
<a name="ln738">    {</a>
<a name="ln739">      zlog_info (&quot;LSA[Type5:%s]: Not originate AS-external-LSA, &quot;</a>
<a name="ln740">                 &quot;Prefix belongs multicast&quot;, inet_ntoa (ei-&gt;p.prefix));</a>
<a name="ln741">      return 0;</a>
<a name="ln742">    }</a>
<a name="ln743"> </a>
<a name="ln744">  /* Take care of default-originate. */</a>
<a name="ln745">  if (is_prefix_default (&amp;ei-&gt;p))</a>
<a name="ln746">    if (ospf-&gt;default_originate == DEFAULT_ORIGINATE_NONE)</a>
<a name="ln747">      {</a>
<a name="ln748">        zlog_info (&quot;LSA[Type5:0.0.0.0]: Not originate AS-external-LSA &quot;</a>
<a name="ln749">                   &quot;for default&quot;);</a>
<a name="ln750">        return 0;</a>
<a name="ln751">      }</a>
<a name="ln752"> </a>
<a name="ln753">  return 1;</a>
<a name="ln754">}</a>
<a name="ln755"> </a>
<a name="ln756">/* If connected prefix is OSPF enable interface, then do not announce. */</a>
<a name="ln757">int</a>
<a name="ln758">ospf_distribute_check_connected (struct ospf *ospf, struct external_info *ei)</a>
<a name="ln759">{</a>
<a name="ln760">  struct listnode *node;</a>
<a name="ln761">  struct ospf_interface *oi;</a>
<a name="ln762"> </a>
<a name="ln763"> </a>
<a name="ln764">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, node, oi))</a>
<a name="ln765">      if (prefix_match (oi-&gt;address, (struct prefix *) &amp;ei-&gt;p))</a>
<a name="ln766">          return 0;</a>
<a name="ln767">  return 1;</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">/* return 1 if external LSA must be originated, 0 otherwise */</a>
<a name="ln771">int</a>
<a name="ln772">ospf_redistribute_check (struct ospf *ospf,</a>
<a name="ln773">                         struct external_info *ei, int *changed)</a>
<a name="ln774">{</a>
<a name="ln775">  struct route_map_set_values save_values;</a>
<a name="ln776">  struct prefix_ipv4 *p = &amp;ei-&gt;p;</a>
<a name="ln777">  u_char type = is_prefix_default (&amp;ei-&gt;p) ? DEFAULT_ROUTE : ei-&gt;type;</a>
<a name="ln778"> </a>
<a name="ln779">  if (changed)</a>
<a name="ln780">    *changed = 0;</a>
<a name="ln781"> </a>
<a name="ln782">  if (!ospf_external_lsa_originate_check (ospf, ei))</a>
<a name="ln783">    return 0;</a>
<a name="ln784"> </a>
<a name="ln785">  /* Take care connected route. */</a>
<a name="ln786">  if (type == ZEBRA_ROUTE_CONNECT &amp;&amp;</a>
<a name="ln787">      !ospf_distribute_check_connected (ospf, ei))</a>
<a name="ln788">    return 0;</a>
<a name="ln789"> </a>
<a name="ln790">  if (!DEFAULT_ROUTE_TYPE (type) &amp;&amp; DISTRIBUTE_NAME (ospf, type))</a>
<a name="ln791">    /* distirbute-list exists, but access-list may not? */</a>
<a name="ln792">    if (DISTRIBUTE_LIST (ospf, type))</a>
<a name="ln793">      if (access_list_apply (DISTRIBUTE_LIST (ospf, type), p) == FILTER_DENY)</a>
<a name="ln794">        {</a>
<a name="ln795">          if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln796">            zlog_debug (&quot;Redistribute[%s]: %s/%d filtered by ditribute-list.&quot;,</a>
<a name="ln797">                       ospf_redist_string(type),</a>
<a name="ln798">                       inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln799">          return 0;</a>
<a name="ln800">        }</a>
<a name="ln801"> </a>
<a name="ln802">  save_values = ei-&gt;route_map_set;</a>
<a name="ln803">  ospf_reset_route_map_set_values (&amp;ei-&gt;route_map_set);</a>
<a name="ln804"> </a>
<a name="ln805">  /* apply route-map if needed */</a>
<a name="ln806">  if (ROUTEMAP_NAME (ospf, type))</a>
<a name="ln807">    {</a>
<a name="ln808">      int ret;</a>
<a name="ln809"> </a>
<a name="ln810">      ret = route_map_apply (ROUTEMAP (ospf, type), (struct prefix *) p,</a>
<a name="ln811">                             RMAP_OSPF, ei);</a>
<a name="ln812"> </a>
<a name="ln813">      if (ret == RMAP_DENYMATCH)</a>
<a name="ln814">        {</a>
<a name="ln815">          ei-&gt;route_map_set = save_values;</a>
<a name="ln816">          if (IS_DEBUG_OSPF (zebra, ZEBRA_REDISTRIBUTE))</a>
<a name="ln817">            zlog_debug (&quot;Redistribute[%s]: %s/%d filtered by route-map.&quot;,</a>
<a name="ln818">                       ospf_redist_string(type),</a>
<a name="ln819">                       inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln820">          return 0;</a>
<a name="ln821">        }</a>
<a name="ln822"> </a>
<a name="ln823">      /* check if 'route-map set' changed something */</a>
<a name="ln824">      if (changed)</a>
<a name="ln825">        *changed = !ospf_route_map_set_compare (&amp;ei-&gt;route_map_set,</a>
<a name="ln826">                                                &amp;save_values);</a>
<a name="ln827">    }</a>
<a name="ln828"> </a>
<a name="ln829">  return 1;</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">/* OSPF route-map set for redistribution */</a>
<a name="ln833">void</a>
<a name="ln834">ospf_routemap_set (struct ospf *ospf, int type, const char *name)</a>
<a name="ln835">{</a>
<a name="ln836">  if (ROUTEMAP_NAME (ospf, type))</a>
<a name="ln837">    free (ROUTEMAP_NAME (ospf, type));</a>
<a name="ln838"> </a>
<a name="ln839">  ROUTEMAP_NAME (ospf, type) = strdup (name);</a>
<a name="ln840">  ROUTEMAP (ospf, type) = route_map_lookup_by_name (name);</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843">void</a>
<a name="ln844">ospf_routemap_unset (struct ospf *ospf, int type)</a>
<a name="ln845">{</a>
<a name="ln846">  if (ROUTEMAP_NAME (ospf, type))</a>
<a name="ln847">    free (ROUTEMAP_NAME (ospf, type));</a>
<a name="ln848"> </a>
<a name="ln849">  ROUTEMAP_NAME (ospf, type) = NULL;</a>
<a name="ln850">  ROUTEMAP (ospf, type) = NULL;</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853">/* Zebra route add and delete treatment. */</a>
<a name="ln854">static int</a>
<a name="ln855">ospf_zebra_read_ipv4 (int command, struct zclient *zclient,</a>
<a name="ln856">                      zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln857">{</a>
<a name="ln858">  struct stream *s;</a>
<a name="ln859">  struct zapi_ipv4 api;</a>
<a name="ln860">  unsigned long ifindex;</a>
<a name="ln861">  struct in_addr nexthop;</a>
<a name="ln862">  struct prefix_ipv4 p;</a>
<a name="ln863">  struct external_info *ei;</a>
<a name="ln864">  struct ospf *ospf;</a>
<a name="ln865">  unsigned char plength = 0;</a>
<a name="ln866"> </a>
<a name="ln867">  s = zclient-&gt;ibuf;</a>
<a name="ln868">  ifindex = 0;</a>
<a name="ln869">  nexthop.s_addr = 0;</a>
<a name="ln870"> </a>
<a name="ln871">  /* Type, flags, message. */</a>
<a name="ln872">  api.type = stream_getc (s);</a>
<a name="ln873">  api.flags = stream_getc (s);</a>
<a name="ln874">  api.message = stream_getc (s);</a>
<a name="ln875"> </a>
<a name="ln876">  /* IPv4 prefix. */</a>
<a name="ln877">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln878">  p.family = AF_INET;</a>
<a name="ln879">  plength = stream_getc (s);</a>
<a name="ln880">  p.prefixlen = MIN(IPV4_MAX_PREFIXLEN, plength);</a>
<a name="ln881">  stream_get (&amp;p.prefix, s, PSIZE (p.prefixlen));</a>
<a name="ln882"> </a>
<a name="ln883">  if (IPV4_NET127(ntohl(p.prefix.s_addr)))</a>
<a name="ln884">    return 0;</a>
<a name="ln885"> </a>
<a name="ln886">  /* Nexthop, ifindex, distance, metric. */</a>
<a name="ln887">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln888">    {</a>
<a name="ln889">      api.nexthop_num = stream_getc (s);</a>
<a name="ln890">      nexthop.s_addr = stream_get_ipv4 (s);</a>
<a name="ln891">    }</a>
<a name="ln892">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))</a>
<a name="ln893">    {</a>
<a name="ln894">      api.ifindex_num = stream_getc (s);</a>
<a name="ln895">      /* XXX assert(api.ifindex_num == 1); */</a>
<a name="ln896">      ifindex = stream_getl (s);</a>
<a name="ln897">    }</a>
<a name="ln898">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln899">    api.distance = stream_getc (s);</a>
<a name="ln900">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln901">    api.metric = stream_getl (s);</a>
<a name="ln902">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_TAG))</a>
<a name="ln903">    api.tag = stream_getl (s);</a>
<a name="ln904">  else</a>
<a name="ln905">    api.tag = 0;</a>
<a name="ln906"> </a>
<a name="ln907">  ospf = ospf_lookup ();</a>
<a name="ln908">  if (ospf == NULL)</a>
<a name="ln909">    return 0;</a>
<a name="ln910"> </a>
<a name="ln911">  if (command == ZEBRA_IPV4_ROUTE_ADD)</a>
<a name="ln912">    {</a>
<a name="ln913">      /* XXX|HACK|TODO|FIXME:</a>
<a name="ln914">       * Maybe we should ignore reject/blackhole routes? Testing shows that</a>
<a name="ln915">       * there is no problems though and this is only way to &quot;summarize&quot;</a>
<a name="ln916">       * routes in ASBR at the moment. Maybe we need just a better generalised</a>
<a name="ln917">       * solution for these types?</a>
<a name="ln918">       *</a>
<a name="ln919">       * if ( CHECK_FLAG (api.flags, ZEBRA_FLAG_BLACKHOLE)</a>
<a name="ln920">       *     || CHECK_FLAG (api.flags, ZEBRA_FLAG_REJECT))</a>
<a name="ln921">       * return 0;</a>
<a name="ln922">       */</a>
<a name="ln923"> </a>
<a name="ln924">      /* Protocol tag overwrites all other tag value send by zebra */</a>
<a name="ln925">      if (ospf-&gt;dtag[api.type] &gt; 0)</a>
<a name="ln926">       api.tag = ospf-&gt;dtag[api.type];</a>
<a name="ln927"> </a>
<a name="ln928">      ei = ospf_external_info_add (api.type, p, ifindex, nexthop, api.tag);</a>
<a name="ln929"> </a>
<a name="ln930">      if (ospf-&gt;router_id.s_addr == 0)</a>
<a name="ln931">        /* Set flags to generate AS-external-LSA originate event</a>
<a name="ln932">           for each redistributed protocols later. */</a>
<a name="ln933">        ospf-&gt;external_origin |= (1 &lt;&lt; api.type);</a>
<a name="ln934">      else</a>
<a name="ln935">        {</a>
<a name="ln936">          if (ei)</a>
<a name="ln937">            {</a>
<a name="ln938">              if (is_prefix_default (&amp;p))</a>
<a name="ln939">                ospf_external_lsa_refresh_default (ospf);</a>
<a name="ln940">              else</a>
<a name="ln941">                {</a>
<a name="ln942">                  struct ospf_lsa *current;</a>
<a name="ln943"> </a>
<a name="ln944">                  current = ospf_external_info_find_lsa (ospf, &amp;ei-&gt;p);</a>
<a name="ln945">                  if (!current)</a>
<a name="ln946">                    ospf_external_lsa_originate (ospf, ei);</a>
<a name="ln947">                  else if (IS_LSA_MAXAGE (current))</a>
<a name="ln948">                    ospf_external_lsa_refresh (ospf, current,</a>
<a name="ln949">                                               ei, LSA_REFRESH_FORCE);</a>
<a name="ln950">                  else</a>
<a name="ln951">                    zlog_warn (&quot;ospf_zebra_read_ipv4() : %s already exists&quot;,</a>
<a name="ln952">                               inet_ntoa (p.prefix));</a>
<a name="ln953">                }</a>
<a name="ln954">            }</a>
<a name="ln955">        }</a>
<a name="ln956">    }</a>
<a name="ln957">  else                          /* if (command == ZEBRA_IPV4_ROUTE_DELETE) */</a>
<a name="ln958">    {</a>
<a name="ln959">      ospf_external_info_delete (api.type, p);</a>
<a name="ln960">      if (is_prefix_default (&amp;p))</a>
<a name="ln961">        ospf_external_lsa_refresh_default (ospf);</a>
<a name="ln962">      else</a>
<a name="ln963">        ospf_external_lsa_flush (ospf, api.type, &amp;p, ifindex /*, nexthop */);</a>
<a name="ln964">    }</a>
<a name="ln965"> </a>
<a name="ln966">  return 0;</a>
<a name="ln967">}</a>
<a name="ln968"> </a>
<a name="ln969"> </a>
<a name="ln970">int</a>
<a name="ln971">ospf_distribute_list_out_set (struct ospf *ospf, int type, const char *name)</a>
<a name="ln972">{</a>
<a name="ln973">  /* Lookup access-list for distribute-list. */</a>
<a name="ln974">  DISTRIBUTE_LIST (ospf, type) = access_list_lookup (AFI_IP, name);</a>
<a name="ln975"> </a>
<a name="ln976">  /* Clear previous distribute-name. */</a>
<a name="ln977">  if (DISTRIBUTE_NAME (ospf, type))</a>
<a name="ln978">    free (DISTRIBUTE_NAME (ospf, type));</a>
<a name="ln979"> </a>
<a name="ln980">  /* Set distribute-name. */</a>
<a name="ln981">  DISTRIBUTE_NAME (ospf, type) = strdup (name);</a>
<a name="ln982"> </a>
<a name="ln983">  /* If access-list have been set, schedule update timer. */</a>
<a name="ln984">  if (DISTRIBUTE_LIST (ospf, type))</a>
<a name="ln985">    ospf_distribute_list_update (ospf, type);</a>
<a name="ln986"> </a>
<a name="ln987">  return CMD_SUCCESS;</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990">int</a>
<a name="ln991">ospf_distribute_list_out_unset (struct ospf *ospf, int type, const char *name)</a>
<a name="ln992">{</a>
<a name="ln993">  /* Schedule update timer. */</a>
<a name="ln994">  if (DISTRIBUTE_LIST (ospf, type))</a>
<a name="ln995">    ospf_distribute_list_update (ospf, type);</a>
<a name="ln996"> </a>
<a name="ln997">  /* Unset distribute-list. */</a>
<a name="ln998">  DISTRIBUTE_LIST (ospf, type) = NULL;</a>
<a name="ln999"> </a>
<a name="ln1000">  /* Clear distribute-name. */</a>
<a name="ln1001">  if (DISTRIBUTE_NAME (ospf, type))</a>
<a name="ln1002">    free (DISTRIBUTE_NAME (ospf, type));</a>
<a name="ln1003"> </a>
<a name="ln1004">  DISTRIBUTE_NAME (ospf, type) = NULL;</a>
<a name="ln1005"> </a>
<a name="ln1006">  return CMD_SUCCESS;</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009">/* distribute-list update timer. */</a>
<a name="ln1010">static int</a>
<a name="ln1011">ospf_distribute_list_update_timer (struct thread *thread)</a>
<a name="ln1012">{</a>
<a name="ln1013">  struct route_node *rn;</a>
<a name="ln1014">  struct external_info *ei;</a>
<a name="ln1015">  struct route_table *rt;</a>
<a name="ln1016">  struct ospf_lsa *lsa;</a>
<a name="ln1017">  int type, default_refresh = 0;</a>
<a name="ln1018">  struct ospf *ospf;</a>
<a name="ln1019"> </a>
<a name="ln1020">  ospf = ospf_lookup ();</a>
<a name="ln1021">  if (ospf == NULL)</a>
<a name="ln1022">    return 0;</a>
<a name="ln1023"> </a>
<a name="ln1024">  ospf-&gt;t_distribute_update = NULL;</a>
<a name="ln1025"> </a>
<a name="ln1026">  zlog_info (&quot;Zebra[Redistribute]: distribute-list update timer fired!&quot;);</a>
<a name="ln1027"> </a>
<a name="ln1028">  /* foreach all external info. */</a>
<a name="ln1029">  for (type = 0; type &lt;= ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln1030">    {</a>
<a name="ln1031">      rt = EXTERNAL_INFO (type);</a>
<a name="ln1032">      if (!rt)</a>
<a name="ln1033">	continue;</a>
<a name="ln1034">      for (rn = route_top (rt); rn; rn = route_next (rn))</a>
<a name="ln1035">	if ((ei = rn-&gt;info) != NULL)</a>
<a name="ln1036">	  {</a>
<a name="ln1037">	    if (is_prefix_default (&amp;ei-&gt;p))</a>
<a name="ln1038">	      default_refresh = 1;</a>
<a name="ln1039">	    else if ((lsa = ospf_external_info_find_lsa (ospf, &amp;ei-&gt;p)))</a>
<a name="ln1040">	      ospf_external_lsa_refresh (ospf, lsa, ei, LSA_REFRESH_IF_CHANGED);</a>
<a name="ln1041">	    else</a>
<a name="ln1042">	      ospf_external_lsa_originate (ospf, ei);</a>
<a name="ln1043">	  }</a>
<a name="ln1044">    }</a>
<a name="ln1045">  if (default_refresh)</a>
<a name="ln1046">    ospf_external_lsa_refresh_default (ospf);</a>
<a name="ln1047">  return 0;</a>
<a name="ln1048">}</a>
<a name="ln1049"> </a>
<a name="ln1050">/* Update distribute-list and set timer to apply access-list. */</a>
<a name="ln1051">void</a>
<a name="ln1052">ospf_distribute_list_update (struct ospf *ospf, uintptr_t type)</a>
<a name="ln1053">{</a>
<a name="ln1054">  struct route_table *rt;</a>
<a name="ln1055"> </a>
<a name="ln1056">  /* External info does not exist. */</a>
<a name="ln1057">  if (!(rt = EXTERNAL_INFO (type)))</a>
<a name="ln1058">    return;</a>
<a name="ln1059"> </a>
<a name="ln1060">  /* If exists previously invoked thread, then let it continue. */</a>
<a name="ln1061">  if (ospf-&gt;t_distribute_update)</a>
<a name="ln1062">    return;</a>
<a name="ln1063"> </a>
<a name="ln1064">  /* Set timer. */</a>
<a name="ln1065">  ospf-&gt;t_distribute_update =</a>
<a name="ln1066">    thread_add_timer_msec (master, ospf_distribute_list_update_timer,</a>
<a name="ln1067">                      (void *) type, ospf-&gt;min_ls_interval);</a>
<a name="ln1068">}</a>
<a name="ln1069"> </a>
<a name="ln1070">/* If access-list is updated, apply some check. */</a>
<a name="ln1071">static void</a>
<a name="ln1072">ospf_filter_update (const char *name)</a>
<a name="ln1073">{</a>
<a name="ln1074">  struct ospf *ospf;</a>
<a name="ln1075">  int type;</a>
<a name="ln1076">  int abr_inv = 0;</a>
<a name="ln1077">  struct ospf_area *area;</a>
<a name="ln1078">  struct listnode *node;</a>
<a name="ln1079"> </a>
<a name="ln1080">  /* If OSPF instatnce does not exist, return right now. */</a>
<a name="ln1081">  ospf = ospf_lookup ();</a>
<a name="ln1082">  if (ospf == NULL)</a>
<a name="ln1083">    return;</a>
<a name="ln1084"> </a>
<a name="ln1085">  /* Update distribute-list, and apply filter. */</a>
<a name="ln1086">  for (type = 0; type &lt;= ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln1087">    {</a>
<a name="ln1088">      if (ROUTEMAP (ospf, type) != NULL)</a>
<a name="ln1089">        {</a>
<a name="ln1090">          /* if route-map is not NULL it may be using this access list */</a>
<a name="ln1091">          ospf_distribute_list_update (ospf, type);</a>
<a name="ln1092">          continue;</a>
<a name="ln1093">        }</a>
<a name="ln1094"> </a>
<a name="ln1095">      /* There is place for route-map for default-information (ZEBRA_ROUTE_MAX),</a>
<a name="ln1096">       * but no distribute list. */</a>
<a name="ln1097">      if (type == ZEBRA_ROUTE_MAX)</a>
<a name="ln1098">	break;</a>
<a name="ln1099"> </a>
<a name="ln1100">      if (DISTRIBUTE_NAME (ospf, type))</a>
<a name="ln1101">        {</a>
<a name="ln1102">          /* Keep old access-list for distribute-list. */</a>
<a name="ln1103">          struct access_list *old = DISTRIBUTE_LIST (ospf, type);</a>
<a name="ln1104"> </a>
<a name="ln1105">          /* Update access-list for distribute-list. */</a>
<a name="ln1106">          DISTRIBUTE_LIST (ospf, type) =</a>
<a name="ln1107">            access_list_lookup (AFI_IP, DISTRIBUTE_NAME (ospf, type));</a>
<a name="ln1108"> </a>
<a name="ln1109">          /* No update for this distribute type. */</a>
<a name="ln1110">          if (old == NULL &amp;&amp; DISTRIBUTE_LIST (ospf, type) == NULL)</a>
<a name="ln1111">            continue;</a>
<a name="ln1112"> </a>
<a name="ln1113">          /* Schedule distribute-list update timer. */</a>
<a name="ln1114">          if (DISTRIBUTE_LIST (ospf, type) == NULL ||</a>
<a name="ln1115">              strcmp (DISTRIBUTE_NAME (ospf, type), name) == 0)</a>
<a name="ln1116">            ospf_distribute_list_update (ospf, type);</a>
<a name="ln1117">        }</a>
<a name="ln1118">    }</a>
<a name="ln1119"> </a>
<a name="ln1120">  /* Update Area access-list. */</a>
<a name="ln1121">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln1122">    {</a>
<a name="ln1123">      if (EXPORT_NAME (area))</a>
<a name="ln1124">        {</a>
<a name="ln1125">          EXPORT_LIST (area) = NULL;</a>
<a name="ln1126">          abr_inv++;</a>
<a name="ln1127">        }</a>
<a name="ln1128"> </a>
<a name="ln1129">      if (IMPORT_NAME (area))</a>
<a name="ln1130">        {</a>
<a name="ln1131">          IMPORT_LIST (area) = NULL;</a>
<a name="ln1132">          abr_inv++;</a>
<a name="ln1133">        }</a>
<a name="ln1134">    }</a>
<a name="ln1135"> </a>
<a name="ln1136">  /* Schedule ABR tasks -- this will be changed -- takada. */</a>
<a name="ln1137">  if (IS_OSPF_ABR (ospf) &amp;&amp; abr_inv)</a>
<a name="ln1138">    ospf_schedule_abr_task (ospf);</a>
<a name="ln1139">}</a>
<a name="ln1140"> </a>
<a name="ln1141">/* If prefix-list is updated, do some updates. */</a>
<a name="ln1142">void</a>
<a name="ln1143">ospf_prefix_list_update (struct prefix_list *plist)</a>
<a name="ln1144">{</a>
<a name="ln1145">  struct ospf *ospf;</a>
<a name="ln1146">  int type;</a>
<a name="ln1147">  int abr_inv = 0;</a>
<a name="ln1148">  struct ospf_area *area;</a>
<a name="ln1149">  struct listnode *node;</a>
<a name="ln1150"> </a>
<a name="ln1151">  /* If OSPF instatnce does not exist, return right now. */</a>
<a name="ln1152">  ospf = ospf_lookup ();</a>
<a name="ln1153">  if (ospf == NULL)</a>
<a name="ln1154">    return;</a>
<a name="ln1155"> </a>
<a name="ln1156">  /* Update all route-maps which are used as redistribution filters.</a>
<a name="ln1157">   * They might use prefix-list.</a>
<a name="ln1158">   */</a>
<a name="ln1159">  for (type = 0; type &lt;= ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln1160">    {</a>
<a name="ln1161">      if (ROUTEMAP (ospf, type) != NULL)</a>
<a name="ln1162">        {</a>
<a name="ln1163">          /* If route-map is not NULL it may be using this prefix list */</a>
<a name="ln1164">          ospf_distribute_list_update (ospf, type);</a>
<a name="ln1165">          continue;</a>
<a name="ln1166">        }</a>
<a name="ln1167">    }</a>
<a name="ln1168"> </a>
<a name="ln1169">  /* Update area filter-lists. */</a>
<a name="ln1170">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln1171">    {</a>
<a name="ln1172">      /* Update filter-list in. */</a>
<a name="ln1173">      if (PREFIX_NAME_IN (area))</a>
<a name="ln1174">        if (strcmp (PREFIX_NAME_IN (area), prefix_list_name (plist)) == 0)</a>
<a name="ln1175">          {</a>
<a name="ln1176">            PREFIX_LIST_IN (area) =</a>
<a name="ln1177">              prefix_list_lookup (AFI_IP, PREFIX_NAME_IN (area));</a>
<a name="ln1178">            abr_inv++;</a>
<a name="ln1179">          }</a>
<a name="ln1180"> </a>
<a name="ln1181">      /* Update filter-list out. */</a>
<a name="ln1182">      if (PREFIX_NAME_OUT (area))</a>
<a name="ln1183">        if (strcmp (PREFIX_NAME_OUT (area), prefix_list_name (plist)) == 0)</a>
<a name="ln1184">          {</a>
<a name="ln1185">            PREFIX_LIST_IN (area) =</a>
<a name="ln1186">              prefix_list_lookup (AFI_IP, PREFIX_NAME_OUT (area));</a>
<a name="ln1187">            abr_inv++;</a>
<a name="ln1188">          }</a>
<a name="ln1189">    }</a>
<a name="ln1190"> </a>
<a name="ln1191">  /* Schedule ABR task. */</a>
<a name="ln1192">  if (IS_OSPF_ABR (ospf) &amp;&amp; abr_inv)</a>
<a name="ln1193">    ospf_schedule_abr_task (ospf);</a>
<a name="ln1194">}</a>
<a name="ln1195"> </a>
<a name="ln1196">static struct ospf_distance *</a>
<a name="ln1197">ospf_distance_new (void)</a>
<a name="ln1198">{</a>
<a name="ln1199">  return XCALLOC (MTYPE_OSPF_DISTANCE, sizeof (struct ospf_distance));</a>
<a name="ln1200">}</a>
<a name="ln1201"> </a>
<a name="ln1202">static void</a>
<a name="ln1203">ospf_distance_free (struct ospf_distance *odistance)</a>
<a name="ln1204">{</a>
<a name="ln1205">  XFREE (MTYPE_OSPF_DISTANCE, odistance);</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">int</a>
<a name="ln1209">ospf_distance_set (struct vty *vty, struct ospf *ospf, </a>
<a name="ln1210">                   const char *distance_str,</a>
<a name="ln1211">                   const char *ip_str, </a>
<a name="ln1212">                   const char *access_list_str)</a>
<a name="ln1213">{</a>
<a name="ln1214">  int ret;</a>
<a name="ln1215">  struct prefix_ipv4 p;</a>
<a name="ln1216">  u_char distance;</a>
<a name="ln1217">  struct route_node *rn;</a>
<a name="ln1218">  struct ospf_distance *odistance;</a>
<a name="ln1219"> </a>
<a name="ln1220">  ret = str2prefix_ipv4 (ip_str, &amp;p);</a>
<a name="ln1221">  if (ret == 0)</a>
<a name="ln1222">    {</a>
<a name="ln1223">      vty_out (vty, &quot;Malformed prefix%s&quot;, VTY_NEWLINE);</a>
<a name="ln1224">      return CMD_WARNING;</a>
<a name="ln1225">    }</a>
<a name="ln1226"> </a>
<a name="ln1227">  distance = atoi (distance_str);</a>
<a name="ln1228"> </a>
<a name="ln1229">  /* Get OSPF distance node. */</a>
<a name="ln1230">  rn = route_node_get (ospf-&gt;distance_table, (struct prefix *) &amp;p);</a>
<a name="ln1231">  if (rn-&gt;info)</a>
<a name="ln1232">    {</a>
<a name="ln1233">      odistance = rn-&gt;info;</a>
<a name="ln1234">      route_unlock_node (rn);</a>
<a name="ln1235">    }</a>
<a name="ln1236">  else</a>
<a name="ln1237">    {</a>
<a name="ln1238">      odistance = ospf_distance_new ();</a>
<a name="ln1239">      rn-&gt;info = odistance;</a>
<a name="ln1240">    }</a>
<a name="ln1241"> </a>
<a name="ln1242">  /* Set distance value. */</a>
<a name="ln1243">  odistance-&gt;distance = distance;</a>
<a name="ln1244"> </a>
<a name="ln1245">  /* Reset access-list configuration. */</a>
<a name="ln1246">  if (odistance-&gt;access_list)</a>
<a name="ln1247">    {</a>
<a name="ln1248">      free (odistance-&gt;access_list);</a>
<a name="ln1249">      odistance-&gt;access_list = NULL;</a>
<a name="ln1250">    }</a>
<a name="ln1251">  if (access_list_str)</a>
<a name="ln1252">    odistance-&gt;access_list = strdup (access_list_str);</a>
<a name="ln1253"> </a>
<a name="ln1254">  return CMD_SUCCESS;</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">int</a>
<a name="ln1258">ospf_distance_unset (struct vty *vty, struct ospf *ospf, </a>
<a name="ln1259">                     const char *distance_str,</a>
<a name="ln1260">                     const char *ip_str, char </a>
<a name="ln1261">                     const *access_list_str)</a>
<a name="ln1262">{</a>
<a name="ln1263">  int ret;</a>
<a name="ln1264">  struct prefix_ipv4 p;</a>
<a name="ln1265">  struct route_node *rn;</a>
<a name="ln1266">  struct ospf_distance *odistance;</a>
<a name="ln1267"> </a>
<a name="ln1268">  ret = str2prefix_ipv4 (ip_str, &amp;p);</a>
<a name="ln1269">  if (ret == 0)</a>
<a name="ln1270">    {</a>
<a name="ln1271">      vty_out (vty, &quot;Malformed prefix%s&quot;, VTY_NEWLINE);</a>
<a name="ln1272">      return CMD_WARNING;</a>
<a name="ln1273">    }</a>
<a name="ln1274"> </a>
<a name="ln1275">  rn = route_node_lookup (ospf-&gt;distance_table, (struct prefix *) &amp;p);</a>
<a name="ln1276">  if (!rn)</a>
<a name="ln1277">    {</a>
<a name="ln1278">      vty_out (vty, &quot;Can't find specified prefix%s&quot;, VTY_NEWLINE);</a>
<a name="ln1279">      return CMD_WARNING;</a>
<a name="ln1280">    }</a>
<a name="ln1281"> </a>
<a name="ln1282">  odistance = rn-&gt;info;</a>
<a name="ln1283"> </a>
<a name="ln1284">  if (odistance-&gt;access_list)</a>
<a name="ln1285">    free (odistance-&gt;access_list);</a>
<a name="ln1286">  ospf_distance_free (odistance);</a>
<a name="ln1287"> </a>
<a name="ln1288">  rn-&gt;info = NULL;</a>
<a name="ln1289">  route_unlock_node (rn);</a>
<a name="ln1290">  route_unlock_node (rn);</a>
<a name="ln1291"> </a>
<a name="ln1292">  return CMD_SUCCESS;</a>
<a name="ln1293">}</a>
<a name="ln1294"> </a>
<a name="ln1295">void</a>
<a name="ln1296">ospf_distance_reset (struct ospf *ospf)</a>
<a name="ln1297">{</a>
<a name="ln1298">  struct route_node *rn;</a>
<a name="ln1299">  struct ospf_distance *odistance;</a>
<a name="ln1300"> </a>
<a name="ln1301">  for (rn = route_top (ospf-&gt;distance_table); rn; rn = route_next (rn))</a>
<a name="ln1302">    if ((odistance = rn-&gt;info) != NULL)</a>
<a name="ln1303">      {</a>
<a name="ln1304">        if (odistance-&gt;access_list)</a>
<a name="ln1305">          free (odistance-&gt;access_list);</a>
<a name="ln1306">        ospf_distance_free (odistance);</a>
<a name="ln1307">        rn-&gt;info = NULL;</a>
<a name="ln1308">        route_unlock_node (rn);</a>
<a name="ln1309">      }</a>
<a name="ln1310">}</a>
<a name="ln1311"> </a>
<a name="ln1312">u_char</a>
<a name="ln1313">ospf_distance_apply (struct prefix_ipv4 *p, struct ospf_route *or)</a>
<a name="ln1314">{</a>
<a name="ln1315">  struct ospf *ospf;</a>
<a name="ln1316"> </a>
<a name="ln1317">  ospf = ospf_lookup ();</a>
<a name="ln1318">  if (ospf == NULL)</a>
<a name="ln1319">    return 0;</a>
<a name="ln1320"> </a>
<a name="ln1321">  if (ospf-&gt;distance_intra)</a>
<a name="ln1322">    if (or-&gt;path_type == OSPF_PATH_INTRA_AREA)</a>
<a name="ln1323">      return ospf-&gt;distance_intra;</a>
<a name="ln1324"> </a>
<a name="ln1325">  if (ospf-&gt;distance_inter)</a>
<a name="ln1326">    if (or-&gt;path_type == OSPF_PATH_INTER_AREA)</a>
<a name="ln1327">      return ospf-&gt;distance_inter;</a>
<a name="ln1328"> </a>
<a name="ln1329">  if (ospf-&gt;distance_external)</a>
<a name="ln1330">    if (or-&gt;path_type == OSPF_PATH_TYPE1_EXTERNAL</a>
<a name="ln1331">        || or-&gt;path_type == OSPF_PATH_TYPE2_EXTERNAL)</a>
<a name="ln1332">      return ospf-&gt;distance_external;</a>
<a name="ln1333"> </a>
<a name="ln1334">  if (ospf-&gt;distance_all)</a>
<a name="ln1335">    return ospf-&gt;distance_all;</a>
<a name="ln1336"> </a>
<a name="ln1337">  return 0;</a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340">static void</a>
<a name="ln1341">ospf_zebra_connected (struct zclient *zclient)</a>
<a name="ln1342">{</a>
<a name="ln1343">  zclient_send_requests (zclient, VRF_DEFAULT);</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">void</a>
<a name="ln1347">ospf_zebra_init (struct thread_master *master)</a>
<a name="ln1348">{</a>
<a name="ln1349">  /* Allocate zebra structure. */</a>
<a name="ln1350">  zclient = zclient_new (master);</a>
<a name="ln1351">  zclient_init (zclient, ZEBRA_ROUTE_OSPF);</a>
<a name="ln1352">  zclient-&gt;zebra_connected = ospf_zebra_connected;</a>
<a name="ln1353">  zclient-&gt;router_id_update = ospf_router_id_update_zebra;</a>
<a name="ln1354">  zclient-&gt;interface_add = ospf_interface_add;</a>
<a name="ln1355">  zclient-&gt;interface_delete = ospf_interface_delete;</a>
<a name="ln1356">  zclient-&gt;interface_up = ospf_interface_state_up;</a>
<a name="ln1357">  zclient-&gt;interface_down = ospf_interface_state_down;</a>
<a name="ln1358">  zclient-&gt;interface_address_add = ospf_interface_address_add;</a>
<a name="ln1359">  zclient-&gt;interface_address_delete = ospf_interface_address_delete;</a>
<a name="ln1360">  zclient-&gt;interface_link_params = ospf_interface_link_params;</a>
<a name="ln1361"> </a>
<a name="ln1362">  zclient-&gt;ipv4_route_add = ospf_zebra_read_ipv4;</a>
<a name="ln1363">  zclient-&gt;ipv4_route_delete = ospf_zebra_read_ipv4;</a>
<a name="ln1364"> </a>
<a name="ln1365">  access_list_add_hook (ospf_filter_update);</a>
<a name="ln1366">  access_list_delete_hook (ospf_filter_update);</a>
<a name="ln1367">  prefix_list_add_hook (ospf_prefix_list_update);</a>
<a name="ln1368">  prefix_list_delete_hook (ospf_prefix_list_update);</a>
<a name="ln1369">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="376"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (or->u.ext.tag <= (4294967295U)).</p></div>
<div class="balloon" rel="396"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'or->paths' pointer was utilized before it was verified against nullptr. Check lines: 396, 399.</p></div>
<div class="balloon" rel="489"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'or->paths' pointer was utilized before it was verified against nullptr. Check lines: 489, 492.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
