
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_main.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol - isis_main.c</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2001,2002   Sampo Saaristo</a>
<a name="ln5"> *                           Tampere University of Technology      </a>
<a name="ln6"> *                           Institute of Communications Engineering</a>
<a name="ln7"> *</a>
<a name="ln8"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln9"> * under the terms of the GNU General Public Licenseas published by the Free </a>
<a name="ln10"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln11"> * any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln14"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln15"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln16"> * more details.</a>
<a name="ln17"> </a>
<a name="ln18"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln19"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln20"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;getopt.h&quot;</a>
<a name="ln26">#include &quot;thread.h&quot;</a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &lt;lib/version.h&gt;</a>
<a name="ln29">#include &quot;command.h&quot;</a>
<a name="ln30">#include &quot;vty.h&quot;</a>
<a name="ln31">#include &quot;memory.h&quot;</a>
<a name="ln32">#include &quot;stream.h&quot;</a>
<a name="ln33">#include &quot;if.h&quot;</a>
<a name="ln34">#include &quot;privs.h&quot;</a>
<a name="ln35">#include &quot;sigevent.h&quot;</a>
<a name="ln36">#include &quot;filter.h&quot;</a>
<a name="ln37">#include &quot;plist.h&quot;</a>
<a name="ln38">#include &quot;zclient.h&quot;</a>
<a name="ln39">#include &quot;vrf.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;isisd/dict.h&quot;</a>
<a name="ln42">#include &quot;include-netbsd/iso.h&quot;</a>
<a name="ln43">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln44">#include &quot;isisd/isis_common.h&quot;</a>
<a name="ln45">#include &quot;isisd/isis_flags.h&quot;</a>
<a name="ln46">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln47">#include &quot;isisd/isisd.h&quot;</a>
<a name="ln48">#include &quot;isisd/isis_dynhn.h&quot;</a>
<a name="ln49">#include &quot;isisd/isis_spf.h&quot;</a>
<a name="ln50">#include &quot;isisd/isis_route.h&quot;</a>
<a name="ln51">#include &quot;isisd/isis_routemap.h&quot;</a>
<a name="ln52">#include &quot;isisd/isis_zebra.h&quot;</a>
<a name="ln53">#include &quot;isisd/isis_tlv.h&quot;</a>
<a name="ln54">#include &quot;isisd/isis_te.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56">/* Default configuration file name */</a>
<a name="ln57">#define ISISD_DEFAULT_CONFIG &quot;isisd.conf&quot;</a>
<a name="ln58">/* Default vty port */</a>
<a name="ln59">#define ISISD_VTY_PORT       2608</a>
<a name="ln60"> </a>
<a name="ln61">/* isisd privileges */</a>
<a name="ln62">zebra_capabilities_t _caps_p[] = {</a>
<a name="ln63">  ZCAP_NET_RAW,</a>
<a name="ln64">  ZCAP_BIND</a>
<a name="ln65">};</a>
<a name="ln66"> </a>
<a name="ln67">struct zebra_privs_t isisd_privs = {</a>
<a name="ln68">#if defined(QUAGGA_USER)</a>
<a name="ln69">  .user = QUAGGA_USER,</a>
<a name="ln70">#endif</a>
<a name="ln71">#if defined QUAGGA_GROUP</a>
<a name="ln72">  .group = QUAGGA_GROUP,</a>
<a name="ln73">#endif</a>
<a name="ln74">#ifdef VTY_GROUP</a>
<a name="ln75">  .vty_group = VTY_GROUP,</a>
<a name="ln76">#endif</a>
<a name="ln77">  .caps_p = _caps_p,</a>
<a name="ln78">  .cap_num_p = sizeof (_caps_p) / sizeof (*_caps_p),</a>
<a name="ln79">  .cap_num_i = 0</a>
<a name="ln80">};</a>
<a name="ln81"> </a>
<a name="ln82">/* isisd options */</a>
<a name="ln83">struct option longopts[] = {</a>
<a name="ln84">  {&quot;daemon&quot;,      no_argument,       NULL, 'd'},</a>
<a name="ln85">  {&quot;config_file&quot;, required_argument, NULL, 'f'},</a>
<a name="ln86">  {&quot;pid_file&quot;,    required_argument, NULL, 'i'},</a>
<a name="ln87">  {&quot;socket&quot;,      required_argument, NULL, 'z'},</a>
<a name="ln88">  {&quot;vty_addr&quot;,    required_argument, NULL, 'A'},</a>
<a name="ln89">  {&quot;vty_port&quot;,    required_argument, NULL, 'P'},</a>
<a name="ln90">  {&quot;user&quot;,        required_argument, NULL, 'u'},</a>
<a name="ln91">  {&quot;group&quot;,       required_argument, NULL, 'g'},</a>
<a name="ln92">  {&quot;version&quot;,     no_argument,       NULL, 'v'},</a>
<a name="ln93">  {&quot;dryrun&quot;,      no_argument,       NULL, 'C'},</a>
<a name="ln94">  {&quot;help&quot;,        no_argument,       NULL, 'h'},</a>
<a name="ln95">  {0}</a>
<a name="ln96">};</a>
<a name="ln97"> </a>
<a name="ln98">/* Configuration file and directory. */</a>
<a name="ln99">char config_default[] = SYSCONFDIR ISISD_DEFAULT_CONFIG;</a>
<a name="ln100">char *config_file = NULL;</a>
<a name="ln101"> </a>
<a name="ln102">/* isisd program name. */</a>
<a name="ln103">char *progname;</a>
<a name="ln104"> </a>
<a name="ln105">int daemon_mode = 0;</a>
<a name="ln106"> </a>
<a name="ln107">/* Master of threads. */</a>
<a name="ln108">struct thread_master *master;</a>
<a name="ln109"> </a>
<a name="ln110">/* Process ID saved for use by init system */</a>
<a name="ln111">const char *pid_file = PATH_ISISD_PID;</a>
<a name="ln112"> </a>
<a name="ln113">/* for reload */</a>
<a name="ln114">char _cwd[MAXPATHLEN];</a>
<a name="ln115">char _progpath[MAXPATHLEN];</a>
<a name="ln116">int _argc;</a>
<a name="ln117">char **_argv;</a>
<a name="ln118">char **_envp;</a>
<a name="ln119"> </a>
<a name="ln120">/*</a>
<a name="ln121"> * Prototypes.</a>
<a name="ln122"> */</a>
<a name="ln123">void reload(void);</a>
<a name="ln124">void sighup(void);</a>
<a name="ln125">void sigint(void);</a>
<a name="ln126">void sigterm(void);</a>
<a name="ln127">void sigusr1(void);</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">/* Help information display. */</a>
<a name="ln131">static void</a>
<a name="ln132">usage (int status)</a>
<a name="ln133">{</a>
<a name="ln134">  if (status != 0)</a>
<a name="ln135">    fprintf (stderr, &quot;Try `%s --help' for more information.\n&quot;, progname);</a>
<a name="ln136">  else</a>
<a name="ln137">    {</a>
<a name="ln138">      printf (&quot;Usage : %s [OPTION...]\n\n\</a>
<a name="ln139">Daemon which manages IS-IS routing\n\n\</a>
<a name="ln140">-d, --daemon       Runs in daemon mode\n\</a>
<a name="ln141">-f, --config_file  Set configuration file name\n\</a>
<a name="ln142">-i, --pid_file     Set process identifier file name\n\</a>
<a name="ln143">-z, --socket       Set path of zebra socket\n\</a>
<a name="ln144">-A, --vty_addr     Set vty's bind address\n\</a>
<a name="ln145">-P, --vty_port     Set vty's port number\n\</a>
<a name="ln146">-u, --user         User to run as\n\</a>
<a name="ln147">-g, --group        Group to run as\n\</a>
<a name="ln148">-v, --version      Print program version\n\</a>
<a name="ln149">-C, --dryrun       Check configuration for validity and exit\n\</a>
<a name="ln150">-h, --help         Display this help and exit\n\</a>
<a name="ln151">\n\</a>
<a name="ln152">Report bugs to %s\n&quot;, progname, ZEBRA_BUG_ADDRESS);</a>
<a name="ln153">    }</a>
<a name="ln154"> </a>
<a name="ln155">  exit (status);</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158"> </a>
<a name="ln159">void</a>
<a name="ln160">reload ()</a>
<a name="ln161">{</a>
<a name="ln162">  zlog_debug (&quot;Reload&quot;);</a>
<a name="ln163">  /* FIXME: Clean up func call here */</a>
<a name="ln164">  vty_reset ();</a>
<a name="ln165">  (void) isisd_privs.change (ZPRIVS_RAISE);</a>
<a name="ln166">  execve (_progpath, _argv, _envp);</a>
<a name="ln167">  zlog_err (&quot;Reload failed: cannot exec %s: %s&quot;, _progpath,</a>
<a name="ln168">      safe_strerror (errno));</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">static void</a>
<a name="ln172">terminate (int i)</a>
<a name="ln173">{</a>
<a name="ln174">  exit (i);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">/*</a>
<a name="ln178"> * Signal handlers</a>
<a name="ln179"> */</a>
<a name="ln180"> </a>
<a name="ln181">void</a>
<a name="ln182">sighup (void)</a>
<a name="ln183">{</a>
<a name="ln184">  zlog_debug (&quot;SIGHUP received&quot;);</a>
<a name="ln185">  reload ();</a>
<a name="ln186"> </a>
<a name="ln187">  return;</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">void</a>
<a name="ln191">sigint (void)</a>
<a name="ln192">{</a>
<a name="ln193">  zlog_notice (&quot;Terminating on signal SIGINT&quot;);</a>
<a name="ln194">  terminate (0);</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">void</a>
<a name="ln198">sigterm (void)</a>
<a name="ln199">{</a>
<a name="ln200">  zlog_notice (&quot;Terminating on signal SIGTERM&quot;);</a>
<a name="ln201">  terminate (0);</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">void</a>
<a name="ln205">sigusr1 (void)</a>
<a name="ln206">{</a>
<a name="ln207">  zlog_debug (&quot;SIGUSR1 received&quot;);</a>
<a name="ln208">  zlog_rotate (NULL);</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">struct quagga_signal_t isisd_signals[] =</a>
<a name="ln212">{</a>
<a name="ln213">  {</a>
<a name="ln214">   .signal = SIGHUP,</a>
<a name="ln215">   .handler = &amp;sighup,</a>
<a name="ln216">   },</a>
<a name="ln217">  {</a>
<a name="ln218">   .signal = SIGUSR1,</a>
<a name="ln219">   .handler = &amp;sigusr1,</a>
<a name="ln220">   },</a>
<a name="ln221">  {</a>
<a name="ln222">   .signal = SIGINT,</a>
<a name="ln223">   .handler = &amp;sigint,</a>
<a name="ln224">   },</a>
<a name="ln225">  {</a>
<a name="ln226">   .signal = SIGTERM,</a>
<a name="ln227">   .handler = &amp;sigterm,</a>
<a name="ln228">   },</a>
<a name="ln229">};</a>
<a name="ln230"> </a>
<a name="ln231">/*</a>
<a name="ln232"> * Main routine of isisd. Parse arguments and handle IS-IS state machine.</a>
<a name="ln233"> */</a>
<a name="ln234">int</a>
<a name="ln235">main (int argc, char **argv, char **envp)</a>
<a name="ln236">{</a>
<a name="ln237">  char *p;</a>
<a name="ln238">  int opt, vty_port = ISISD_VTY_PORT;</a>
<a name="ln239">  char *config_file = NULL;</a>
<a name="ln240">  char *vty_addr = NULL;</a>
<a name="ln241">  int dryrun = 0;</a>
<a name="ln242"> </a>
<a name="ln243">  /* Get the programname without the preceding path. */</a>
<a name="ln244">  progname = ((p = strrchr (argv[0], '/')) ? ++p : argv[0]);</a>
<a name="ln245"> </a>
<a name="ln246">  zlog_default = openzlog (progname, ZLOG_ISIS,</a>
<a name="ln247">			   LOG_CONS | LOG_NDELAY | LOG_PID, LOG_DAEMON);</a>
<a name="ln248"> </a>
<a name="ln249">  /* for reload */</a>
<a name="ln250">  _argc = argc;</a>
<a name="ln251">  _argv = argv;</a>
<a name="ln252">  _envp = envp;</a>
<a name="ln253">  getcwd (_cwd, sizeof (_cwd));</a>
<a name="ln254">  if (*argv[0] == '.')</a>
<a name="ln255">    snprintf (_progpath, sizeof (_progpath), &quot;%s/%s&quot;, _cwd, _argv[0]);</a>
<a name="ln256">  else</a>
<a name="ln257">    snprintf (_progpath, sizeof (_progpath), &quot;%s&quot;, argv[0]);</a>
<a name="ln258"> </a>
<a name="ln259">  /* Command line argument treatment. */</a>
<a name="ln260">  while (1)</a>
<a name="ln261">    {</a>
<a name="ln262">      opt = getopt_long (argc, argv, &quot;df:i:z:hA:p:P:u:g:vC&quot;, longopts, 0);</a>
<a name="ln263"> </a>
<a name="ln264">      if (opt == EOF)</a>
<a name="ln265">	break;</a>
<a name="ln266"> </a>
<a name="ln267">      switch (opt)</a>
<a name="ln268">	{</a>
<a name="ln269">	case 0:</a>
<a name="ln270">	  break;</a>
<a name="ln271">	case 'd':</a>
<a name="ln272">	  daemon_mode = 1;</a>
<a name="ln273">	  break;</a>
<a name="ln274">	case 'f':</a>
<a name="ln275">	  config_file = optarg;</a>
<a name="ln276">	  break;</a>
<a name="ln277">	case 'i':</a>
<a name="ln278">	  pid_file = optarg;</a>
<a name="ln279">	  break;</a>
<a name="ln280">	case 'z':</a>
<a name="ln281">	  zclient_serv_path_set (optarg);</a>
<a name="ln282">	  break;</a>
<a name="ln283">	case 'A':</a>
<a name="ln284">	  vty_addr = optarg;</a>
<a name="ln285">	  break;</a>
<a name="ln286">	case 'P':</a>
<a name="ln287">	  /* Deal with atoi() returning 0 on failure, and isisd not</a>
<a name="ln288">	     listening on isisd port... */</a>
<a name="ln289">	  if (strcmp (optarg, &quot;0&quot;) == 0)</a>
<a name="ln290">	    {</a>
<a name="ln291">	      vty_port = 0;</a>
<a name="ln292">	      break;</a>
<a name="ln293">	    }</a>
<a name="ln294">	  vty_port = atoi (optarg);</a>
<a name="ln295">	  vty_port = (vty_port ? vty_port : ISISD_VTY_PORT);</a>
<a name="ln296">	  break;</a>
<a name="ln297">	case 'u':</a>
<a name="ln298">	  isisd_privs.user = optarg;</a>
<a name="ln299">	  break;</a>
<a name="ln300">	case 'g':</a>
<a name="ln301">	  isisd_privs.group = optarg;</a>
<a name="ln302">	  break;</a>
<a name="ln303">	case 'v':</a>
<a name="ln304">	  printf (&quot;ISISd version %s\n&quot;, ISISD_VERSION);</a>
<a name="ln305">	  printf (&quot;Copyright (c) 2001-2002 Sampo Saaristo,&quot;</a>
<a name="ln306">		  &quot; Ofer Wald and Hannes Gredler\n&quot;);</a>
<a name="ln307">	  print_version (&quot;Zebra&quot;);</a>
<a name="ln308">	  exit (0);</a>
<a name="ln309">	  break;</a>
<a name="ln310">	case 'C':</a>
<a name="ln311">	  dryrun = 1;</a>
<a name="ln312">	  break;</a>
<a name="ln313">	case 'h':</a>
<a name="ln314">	  usage (0);</a>
<a name="ln315">	  break;</a>
<a name="ln316">	default:</a>
<a name="ln317">	  usage (1);</a>
<a name="ln318">	  break;</a>
<a name="ln319">	}</a>
<a name="ln320">    }</a>
<a name="ln321"> </a>
<a name="ln322">  /* thread master */</a>
<a name="ln323">  master = thread_master_create ();</a>
<a name="ln324"> </a>
<a name="ln325">  /* random seed from time */</a>
<a name="ln326">  srandom (time (NULL));</a>
<a name="ln327"> </a>
<a name="ln328">  /*</a>
<a name="ln329">   *  initializations</a>
<a name="ln330">   */</a>
<a name="ln331">  zprivs_init (&amp;isisd_privs);</a>
<a name="ln332">  signal_init (master, array_size (isisd_signals), isisd_signals);</a>
<a name="ln333">  cmd_init (1);</a>
<a name="ln334">  vty_init (master);</a>
<a name="ln335">  memory_init ();</a>
<a name="ln336">  access_list_init();</a>
<a name="ln337">  vrf_init ();</a>
<a name="ln338">  prefix_list_init();</a>
<a name="ln339">  isis_init ();</a>
<a name="ln340">  isis_circuit_init ();</a>
<a name="ln341">  isis_spf_cmds_init ();</a>
<a name="ln342">  isis_redist_init ();</a>
<a name="ln343">  isis_route_map_init();</a>
<a name="ln344">  isis_mpls_te_init();</a>
<a name="ln345"> </a>
<a name="ln346">  /* create the global 'isis' instance */</a>
<a name="ln347">  isis_new (1);</a>
<a name="ln348"> </a>
<a name="ln349">  isis_zebra_init (master);</a>
<a name="ln350"> </a>
<a name="ln351">  /* parse config file */</a>
<a name="ln352">  /* this is needed three times! because we have interfaces before the areas */</a>
<a name="ln353">  vty_read_config (config_file, config_default);</a>
<a name="ln354"> </a>
<a name="ln355">  /* Start execution only if not in dry-run mode */</a>
<a name="ln356">  if (dryrun)</a>
<a name="ln357">    return(0);</a>
<a name="ln358">  </a>
<a name="ln359">  /* demonize */</a>
<a name="ln360">  if (daemon_mode &amp;&amp; daemon (0, 0) &lt; 0)</a>
<a name="ln361">    {</a>
<a name="ln362">      zlog_err(&quot;IS-IS daemon failed: %s&quot;, strerror(errno));</a>
<a name="ln363">      exit (1);</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">  /* Process ID file creation. */</a>
<a name="ln367">  if (pid_file[0] != '\0')</a>
<a name="ln368">    pid_output (pid_file);</a>
<a name="ln369"> </a>
<a name="ln370">  /* Make isis vty socket. */</a>
<a name="ln371">  vty_serv_sock (vty_addr, vty_port, ISIS_VTYSH_PATH);</a>
<a name="ln372"> </a>
<a name="ln373">  /* Print banner. */</a>
<a name="ln374">  zlog_notice (&quot;Quagga-ISISd %s starting: vty@%d&quot;, QUAGGA_VERSION, vty_port);</a>
<a name="ln375"> </a>
<a name="ln376">  /* Start finite state machine. */</a>
<a name="ln377">  thread_main (master);</a>
<a name="ln378"> </a>
<a name="ln379">  /* Not reached. */</a>
<a name="ln380">  exit (0);</a>
<a name="ln381">}</a>

</code></pre>
<div class="balloon" rel="15"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
