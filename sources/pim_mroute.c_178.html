
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_mroute.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24">#include &quot;log.h&quot;</a>
<a name="ln25">#include &quot;privs.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;pimd.h&quot;</a>
<a name="ln28">#include &quot;pim_mroute.h&quot;</a>
<a name="ln29">#include &quot;pim_str.h&quot;</a>
<a name="ln30">#include &quot;pim_time.h&quot;</a>
<a name="ln31">#include &quot;pim_iface.h&quot;</a>
<a name="ln32">#include &quot;pim_macro.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">/* GLOBAL VARS */</a>
<a name="ln35">extern struct zebra_privs_t pimd_privs;</a>
<a name="ln36"> </a>
<a name="ln37">static void mroute_read_on(void);</a>
<a name="ln38"> </a>
<a name="ln39">static int pim_mroute_set(int fd, int enable)</a>
<a name="ln40">{</a>
<a name="ln41">  int err;</a>
<a name="ln42">  int opt = enable ? MRT_INIT : MRT_DONE;</a>
<a name="ln43">  socklen_t opt_len = sizeof(opt);</a>
<a name="ln44"> </a>
<a name="ln45">  err = setsockopt(fd, IPPROTO_IP, opt, &amp;opt, opt_len);</a>
<a name="ln46">  if (err) {</a>
<a name="ln47">    int e = errno;</a>
<a name="ln48">    zlog_warn(&quot;%s %s: failure: setsockopt(fd=%d,IPPROTO_IP,%s=%d): errno=%d: %s&quot;,</a>
<a name="ln49">	      __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln50">	      fd, enable ? &quot;MRT_INIT&quot; : &quot;MRT_DONE&quot;, opt, e, safe_strerror(e));</a>
<a name="ln51">    errno = e;</a>
<a name="ln52">    return -1;</a>
<a name="ln53">  }</a>
<a name="ln54"> </a>
<a name="ln55">#if 0</a>
<a name="ln56">  zlog_info(&quot;%s %s: setsockopt(fd=%d,IPPROTO_IP,MRT_INIT,opt=%d): ok&quot;,</a>
<a name="ln57">	    __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln58">	    fd, opt);</a>
<a name="ln59">#endif</a>
<a name="ln60"> </a>
<a name="ln61">  return 0;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">int pim_mroute_msg(int fd, const char *buf, int buf_size)</a>
<a name="ln65">{</a>
<a name="ln66">  struct interface     *ifp;</a>
<a name="ln67">  const struct ip      *ip_hdr;</a>
<a name="ln68">  const struct igmpmsg *msg;</a>
<a name="ln69">  const char *upcall;</a>
<a name="ln70">  char src_str[100];</a>
<a name="ln71">  char grp_str[100];</a>
<a name="ln72"> </a>
<a name="ln73">  ip_hdr = (const struct ip *) buf;</a>
<a name="ln74"> </a>
<a name="ln75">  /* kernel upcall must have protocol=0 */</a>
<a name="ln76">  if (ip_hdr-&gt;ip_p) {</a>
<a name="ln77">    /* this is not a kernel upcall */</a>
<a name="ln78">#ifdef PIM_UNEXPECTED_KERNEL_UPCALL</a>
<a name="ln79">    zlog_warn(&quot;%s: not a kernel upcall proto=%d msg_size=%d&quot;,</a>
<a name="ln80">	      __PRETTY_FUNCTION__, ip_hdr-&gt;ip_p, buf_size);</a>
<a name="ln81">#endif</a>
<a name="ln82">    return 0;</a>
<a name="ln83">  }</a>
<a name="ln84"> </a>
<a name="ln85">  msg = (const struct igmpmsg *) buf;</a>
<a name="ln86"> </a>
<a name="ln87">  switch (msg-&gt;im_msgtype) {</a>
<a name="ln88">  case IGMPMSG_NOCACHE:  upcall = &quot;NOCACHE&quot;;  break;</a>
<a name="ln89">  case IGMPMSG_WRONGVIF: upcall = &quot;WRONGVIF&quot;; break;</a>
<a name="ln90">  case IGMPMSG_WHOLEPKT: upcall = &quot;WHOLEPKT&quot;; break;</a>
<a name="ln91">  default: upcall = &quot;&lt;unknown_upcall?&gt;&quot;;</a>
<a name="ln92">  }</a>
<a name="ln93">  ifp = pim_if_find_by_vif_index(msg-&gt;im_vif);</a>
<a name="ln94">  pim_inet4_dump(&quot;&lt;src?&gt;&quot;, msg-&gt;im_src, src_str, sizeof(src_str));</a>
<a name="ln95">  pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, msg-&gt;im_dst, grp_str, sizeof(grp_str));</a>
<a name="ln96">    </a>
<a name="ln97">  if (msg-&gt;im_msgtype == IGMPMSG_WRONGVIF) {</a>
<a name="ln98">    struct pim_ifchannel *ch;</a>
<a name="ln99">    struct pim_interface *pim_ifp;</a>
<a name="ln100"> </a>
<a name="ln101">    /*</a>
<a name="ln102">      Send Assert(S,G) on iif as response to WRONGVIF kernel upcall.</a>
<a name="ln103">      </a>
<a name="ln104">      RFC 4601 4.8.2.  PIM-SSM-Only Routers</a>
<a name="ln105">      </a>
<a name="ln106">      iif is the incoming interface of the packet.</a>
<a name="ln107">      if (iif is in inherited_olist(S,G)) {</a>
<a name="ln108">      send Assert(S,G) on iif</a>
<a name="ln109">      }</a>
<a name="ln110">    */</a>
<a name="ln111"> </a>
<a name="ln112">    if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln113">      zlog_debug(&quot;%s: WRONGVIF from fd=%d for (S,G)=(%s,%s) on %s vifi=%d&quot;,</a>
<a name="ln114">		 __PRETTY_FUNCTION__,</a>
<a name="ln115">		 fd,</a>
<a name="ln116">		 src_str,</a>
<a name="ln117">		 grp_str,</a>
<a name="ln118">		 ifp ? ifp-&gt;name : &quot;&lt;ifname?&gt;&quot;,</a>
<a name="ln119">		 msg-&gt;im_vif);</a>
<a name="ln120">    }</a>
<a name="ln121"> </a>
<a name="ln122">    if (!ifp) {</a>
<a name="ln123">      zlog_warn(&quot;%s: WRONGVIF (S,G)=(%s,%s) could not find input interface for input_vif_index=%d&quot;,</a>
<a name="ln124">		__PRETTY_FUNCTION__,</a>
<a name="ln125">		src_str, grp_str, msg-&gt;im_vif);</a>
<a name="ln126">      return -1;</a>
<a name="ln127">    }</a>
<a name="ln128"> </a>
<a name="ln129">    pim_ifp = ifp-&gt;info;</a>
<a name="ln130">    if (!pim_ifp) {</a>
<a name="ln131">      zlog_warn(&quot;%s: WRONGVIF (S,G)=(%s,%s) multicast not enabled on interface %s&quot;,</a>
<a name="ln132">		__PRETTY_FUNCTION__,</a>
<a name="ln133">		src_str, grp_str, ifp-&gt;name);</a>
<a name="ln134">      return -2;</a>
<a name="ln135">    }</a>
<a name="ln136"> </a>
<a name="ln137">    ch = pim_ifchannel_find(ifp, msg-&gt;im_src, msg-&gt;im_dst);</a>
<a name="ln138">    if (!ch) {</a>
<a name="ln139">      zlog_warn(&quot;%s: WRONGVIF (S,G)=(%s,%s) could not find channel on interface %s&quot;,</a>
<a name="ln140">		__PRETTY_FUNCTION__,</a>
<a name="ln141">		src_str, grp_str, ifp-&gt;name);</a>
<a name="ln142">      return -3;</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    /*</a>
<a name="ln146">      RFC 4601: 4.6.1.  (S,G) Assert Message State Machine</a>
<a name="ln147"> </a>
<a name="ln148">      Transitions from NoInfo State</a>
<a name="ln149"> </a>
<a name="ln150">      An (S,G) data packet arrives on interface I, AND</a>
<a name="ln151">      CouldAssert(S,G,I)==TRUE An (S,G) data packet arrived on an</a>
<a name="ln152">      downstream interface that is in our (S,G) outgoing interface</a>
<a name="ln153">      list.  We optimistically assume that we will be the assert</a>
<a name="ln154">      winner for this (S,G), and so we transition to the &quot;I am Assert</a>
<a name="ln155">      Winner&quot; state and perform Actions A1 (below), which will</a>
<a name="ln156">      initiate the assert negotiation for (S,G).</a>
<a name="ln157">    */</a>
<a name="ln158"> </a>
<a name="ln159">    if (ch-&gt;ifassert_state != PIM_IFASSERT_NOINFO) {</a>
<a name="ln160">      zlog_warn(&quot;%s: WRONGVIF (S,G)=(%s,%s) channel is not on Assert NoInfo state for interface %s&quot;,</a>
<a name="ln161">		__PRETTY_FUNCTION__,</a>
<a name="ln162">		src_str, grp_str, ifp-&gt;name);</a>
<a name="ln163">      return -4;</a>
<a name="ln164">    }</a>
<a name="ln165"> </a>
<a name="ln166">    if (!PIM_IF_FLAG_TEST_COULD_ASSERT(ch-&gt;flags)) {</a>
<a name="ln167">      zlog_warn(&quot;%s: WRONGVIF (S,G)=(%s,%s) interface %s is not downstream for channel&quot;,</a>
<a name="ln168">		__PRETTY_FUNCTION__,</a>
<a name="ln169">		src_str, grp_str, ifp-&gt;name);</a>
<a name="ln170">      return -5;</a>
<a name="ln171">    }</a>
<a name="ln172"> </a>
<a name="ln173">    if (assert_action_a1(ch)) {</a>
<a name="ln174">      zlog_warn(&quot;%s: WRONGVIF (S,G)=(%s,%s) assert_action_a1 failure on interface %s&quot;,</a>
<a name="ln175">		__PRETTY_FUNCTION__,</a>
<a name="ln176">		src_str, grp_str, ifp-&gt;name);</a>
<a name="ln177">      return -6;</a>
<a name="ln178">    }</a>
<a name="ln179"> </a>
<a name="ln180">    return 0;</a>
<a name="ln181">  } /* IGMPMSG_WRONGVIF */</a>
<a name="ln182"> </a>
<a name="ln183">  zlog_warn(&quot;%s: kernel upcall %s type=%d ip_p=%d from fd=%d for (S,G)=(%s,%s) on %s vifi=%d&quot;,</a>
<a name="ln184">	    __PRETTY_FUNCTION__,</a>
<a name="ln185">	    upcall,</a>
<a name="ln186">	    msg-&gt;im_msgtype,</a>
<a name="ln187">	    ip_hdr-&gt;ip_p,</a>
<a name="ln188">	    fd,</a>
<a name="ln189">	    src_str,</a>
<a name="ln190">	    grp_str,</a>
<a name="ln191">	    ifp ? ifp-&gt;name : &quot;&lt;ifname?&gt;&quot;,</a>
<a name="ln192">	    msg-&gt;im_vif);</a>
<a name="ln193"> </a>
<a name="ln194">  return 0;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">static int mroute_read_msg(int fd)</a>
<a name="ln198">{</a>
<a name="ln199">  const int msg_min_size = MAX(sizeof(struct ip), sizeof(struct igmpmsg));</a>
<a name="ln200">  char buf[1000];</a>
<a name="ln201">  int rd;</a>
<a name="ln202"> </a>
<a name="ln203">  if (((int) sizeof(buf)) &lt; msg_min_size) {</a>
<a name="ln204">    zlog_err(&quot;%s: fd=%d: buf size=%zu lower than msg_min=%d&quot;,</a>
<a name="ln205">	     __PRETTY_FUNCTION__, fd, sizeof(buf), msg_min_size);</a>
<a name="ln206">    return -1;</a>
<a name="ln207">  }</a>
<a name="ln208"> </a>
<a name="ln209">  rd = read(fd, buf, sizeof(buf));</a>
<a name="ln210">  if (rd &lt; 0) {</a>
<a name="ln211">    zlog_warn(&quot;%s: failure reading fd=%d: errno=%d: %s&quot;,</a>
<a name="ln212">	      __PRETTY_FUNCTION__, fd, errno, safe_strerror(errno));</a>
<a name="ln213">    return -2;</a>
<a name="ln214">  }</a>
<a name="ln215"> </a>
<a name="ln216">  if (rd &lt; msg_min_size) {</a>
<a name="ln217">    zlog_warn(&quot;%s: short message reading fd=%d: read=%d msg_min=%d&quot;,</a>
<a name="ln218">	      __PRETTY_FUNCTION__, fd, rd, msg_min_size);</a>
<a name="ln219">    return -3;</a>
<a name="ln220">  }</a>
<a name="ln221"> </a>
<a name="ln222">  return pim_mroute_msg(fd, buf, rd);</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">static int mroute_read(struct thread *t)</a>
<a name="ln226">{</a>
<a name="ln227">  int fd;</a>
<a name="ln228">  int result;</a>
<a name="ln229"> </a>
<a name="ln230">  zassert(t);</a>
<a name="ln231">  zassert(!THREAD_ARG(t));</a>
<a name="ln232"> </a>
<a name="ln233">  fd = THREAD_FD(t);</a>
<a name="ln234">  zassert(fd == qpim_mroute_socket_fd);</a>
<a name="ln235"> </a>
<a name="ln236">  result = mroute_read_msg(fd);</a>
<a name="ln237"> </a>
<a name="ln238">  /* Keep reading */</a>
<a name="ln239">  qpim_mroute_socket_reader = 0;</a>
<a name="ln240">  mroute_read_on();</a>
<a name="ln241"> </a>
<a name="ln242">  return result;</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">static void mroute_read_on()</a>
<a name="ln246">{</a>
<a name="ln247">  zassert(!qpim_mroute_socket_reader);</a>
<a name="ln248">  zassert(PIM_MROUTE_IS_ENABLED);</a>
<a name="ln249"> </a>
<a name="ln250">  THREAD_READ_ON(master, qpim_mroute_socket_reader,</a>
<a name="ln251">		 mroute_read, 0, qpim_mroute_socket_fd);</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">static void mroute_read_off()</a>
<a name="ln255">{</a>
<a name="ln256">  THREAD_OFF(qpim_mroute_socket_reader);</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">int pim_mroute_socket_enable()</a>
<a name="ln260">{</a>
<a name="ln261">  int fd;</a>
<a name="ln262"> </a>
<a name="ln263">  if (PIM_MROUTE_IS_ENABLED)</a>
<a name="ln264">    return -1;</a>
<a name="ln265"> </a>
<a name="ln266">  if ( pimd_privs.change (ZPRIVS_RAISE) )</a>
<a name="ln267">    zlog_err (&quot;pim_mroute_socket_enable: could not raise privs, %s&quot;,</a>
<a name="ln268">              safe_strerror (errno) );</a>
<a name="ln269"> </a>
<a name="ln270">  fd = socket(AF_INET, SOCK_RAW, IPPROTO_IGMP);</a>
<a name="ln271"> </a>
<a name="ln272">  if ( pimd_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln273">    zlog_err (&quot;pim_mroute_socket_enable: could not lower privs, %s&quot;,</a>
<a name="ln274">	      safe_strerror (errno) );</a>
<a name="ln275"> </a>
<a name="ln276">  if (fd &lt; 0) {</a>
<a name="ln277">    zlog_warn(&quot;Could not create mroute socket: errno=%d: %s&quot;,</a>
<a name="ln278">	      errno, safe_strerror(errno));</a>
<a name="ln279">    return -2;</a>
<a name="ln280">  }</a>
<a name="ln281"> </a>
<a name="ln282">  if (pim_mroute_set(fd, 1)) {</a>
<a name="ln283">    zlog_warn(&quot;Could not enable mroute on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln284">	      fd, errno, safe_strerror(errno));</a>
<a name="ln285">    close(fd);</a>
<a name="ln286">    return -3;</a>
<a name="ln287">  }</a>
<a name="ln288"> </a>
<a name="ln289">  qpim_mroute_socket_fd       = fd;</a>
<a name="ln290">  qpim_mroute_socket_creation = pim_time_monotonic_sec();</a>
<a name="ln291">  mroute_read_on();</a>
<a name="ln292"> </a>
<a name="ln293">  zassert(PIM_MROUTE_IS_ENABLED);</a>
<a name="ln294"> </a>
<a name="ln295">  return 0;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">int pim_mroute_socket_disable()</a>
<a name="ln299">{</a>
<a name="ln300">  if (PIM_MROUTE_IS_DISABLED)</a>
<a name="ln301">    return -1;</a>
<a name="ln302"> </a>
<a name="ln303">  if (pim_mroute_set(qpim_mroute_socket_fd, 0)) {</a>
<a name="ln304">    zlog_warn(&quot;Could not disable mroute on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln305">	      qpim_mroute_socket_fd, errno, safe_strerror(errno));</a>
<a name="ln306">    return -2;</a>
<a name="ln307">  }</a>
<a name="ln308"> </a>
<a name="ln309">  if (close(qpim_mroute_socket_fd)) {</a>
<a name="ln310">    zlog_warn(&quot;Failure closing mroute socket: fd=%d errno=%d: %s&quot;,</a>
<a name="ln311">	      qpim_mroute_socket_fd, errno, safe_strerror(errno));</a>
<a name="ln312">    return -3;</a>
<a name="ln313">  }</a>
<a name="ln314"> </a>
<a name="ln315">  mroute_read_off();</a>
<a name="ln316">  qpim_mroute_socket_fd = -1;</a>
<a name="ln317"> </a>
<a name="ln318">  zassert(PIM_MROUTE_IS_DISABLED);</a>
<a name="ln319"> </a>
<a name="ln320">  return 0;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">/*</a>
<a name="ln324">  For each network interface (e.g., physical or a virtual tunnel) that</a>
<a name="ln325">  would be used for multicast forwarding, a corresponding multicast</a>
<a name="ln326">  interface must be added to the kernel.</a>
<a name="ln327"> */</a>
<a name="ln328">int pim_mroute_add_vif(int vif_index, struct in_addr ifaddr)</a>
<a name="ln329">{</a>
<a name="ln330">  struct vifctl vc;</a>
<a name="ln331">  int err;</a>
<a name="ln332"> </a>
<a name="ln333">  if (PIM_MROUTE_IS_DISABLED) {</a>
<a name="ln334">    zlog_warn(&quot;%s: global multicast is disabled&quot;,</a>
<a name="ln335">	      __PRETTY_FUNCTION__);</a>
<a name="ln336">    return -1;</a>
<a name="ln337">  }</a>
<a name="ln338"> </a>
<a name="ln339">  memset(&amp;vc, 0, sizeof(vc));</a>
<a name="ln340">  vc.vifc_vifi = vif_index;</a>
<a name="ln341">  vc.vifc_flags = 0;</a>
<a name="ln342">  vc.vifc_threshold = PIM_MROUTE_MIN_TTL;</a>
<a name="ln343">  vc.vifc_rate_limit = 0;</a>
<a name="ln344">  memcpy(&amp;vc.vifc_lcl_addr, &amp;ifaddr, sizeof(vc.vifc_lcl_addr));</a>
<a name="ln345"> </a>
<a name="ln346">#ifdef PIM_DVMRP_TUNNEL  </a>
<a name="ln347">  if (vc.vifc_flags &amp; VIFF_TUNNEL) {</a>
<a name="ln348">    memcpy(&amp;vc.vifc_rmt_addr, &amp;vif_remote_addr, sizeof(vc.vifc_rmt_addr));</a>
<a name="ln349">  }</a>
<a name="ln350">#endif</a>
<a name="ln351"> </a>
<a name="ln352">  err = setsockopt(qpim_mroute_socket_fd, IPPROTO_IP, MRT_ADD_VIF, (void*) &amp;vc, sizeof(vc)); </a>
<a name="ln353">  if (err) {</a>
<a name="ln354">    char ifaddr_str[100];</a>
<a name="ln355">    int e = errno;</a>
<a name="ln356"> </a>
<a name="ln357">    pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, ifaddr, ifaddr_str, sizeof(ifaddr_str));</a>
<a name="ln358"> </a>
<a name="ln359">    zlog_warn(&quot;%s %s: failure: setsockopt(fd=%d,IPPROTO_IP,MRT_ADD_VIF,vif_index=%d,ifaddr=%s): errno=%d: %s&quot;,</a>
<a name="ln360">	      __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln361">	      qpim_mroute_socket_fd, vif_index, ifaddr_str,</a>
<a name="ln362">	      e, safe_strerror(e));</a>
<a name="ln363">    errno = e;</a>
<a name="ln364">    return -2;</a>
<a name="ln365">  }</a>
<a name="ln366"> </a>
<a name="ln367">  return 0;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">int pim_mroute_del_vif(int vif_index)</a>
<a name="ln371">{</a>
<a name="ln372">  struct vifctl vc;</a>
<a name="ln373">  int err;</a>
<a name="ln374"> </a>
<a name="ln375">  if (PIM_MROUTE_IS_DISABLED) {</a>
<a name="ln376">    zlog_warn(&quot;%s: global multicast is disabled&quot;,</a>
<a name="ln377">	      __PRETTY_FUNCTION__);</a>
<a name="ln378">    return -1;</a>
<a name="ln379">  }</a>
<a name="ln380"> </a>
<a name="ln381">  memset(&amp;vc, 0, sizeof(vc));</a>
<a name="ln382">  vc.vifc_vifi = vif_index;</a>
<a name="ln383"> </a>
<a name="ln384">  err = setsockopt(qpim_mroute_socket_fd, IPPROTO_IP, MRT_DEL_VIF, (void*) &amp;vc, sizeof(vc)); </a>
<a name="ln385">  if (err) {</a>
<a name="ln386">    int e = errno;</a>
<a name="ln387">    zlog_warn(&quot;%s %s: failure: setsockopt(fd=%d,IPPROTO_IP,MRT_DEL_VIF,vif_index=%d): errno=%d: %s&quot;,</a>
<a name="ln388">	      __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln389">	      qpim_mroute_socket_fd, vif_index,</a>
<a name="ln390">	      e, safe_strerror(e));</a>
<a name="ln391">    errno = e;</a>
<a name="ln392">    return -2;</a>
<a name="ln393">  }</a>
<a name="ln394"> </a>
<a name="ln395">  return 0;</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">int pim_mroute_add(struct mfcctl *mc)</a>
<a name="ln399">{</a>
<a name="ln400">  int err;</a>
<a name="ln401"> </a>
<a name="ln402">  qpim_mroute_add_last = pim_time_monotonic_sec();</a>
<a name="ln403">  ++qpim_mroute_add_events;</a>
<a name="ln404"> </a>
<a name="ln405">  if (PIM_MROUTE_IS_DISABLED) {</a>
<a name="ln406">    zlog_warn(&quot;%s: global multicast is disabled&quot;,</a>
<a name="ln407">	      __PRETTY_FUNCTION__);</a>
<a name="ln408">    return -1;</a>
<a name="ln409">  }</a>
<a name="ln410"> </a>
<a name="ln411">  err = setsockopt(qpim_mroute_socket_fd, IPPROTO_IP, MRT_ADD_MFC,</a>
<a name="ln412">		   mc, sizeof(*mc));</a>
<a name="ln413">  if (err) {</a>
<a name="ln414">    int e = errno;</a>
<a name="ln415">    zlog_warn(&quot;%s %s: failure: setsockopt(fd=%d,IPPROTO_IP,MRT_ADD_MFC): errno=%d: %s&quot;,</a>
<a name="ln416">	      __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln417">	      qpim_mroute_socket_fd,</a>
<a name="ln418">	      e, safe_strerror(e));</a>
<a name="ln419">    errno = e;</a>
<a name="ln420">    return -2;</a>
<a name="ln421">  }</a>
<a name="ln422"> </a>
<a name="ln423">  return 0;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">int pim_mroute_del(struct mfcctl *mc)</a>
<a name="ln427">{</a>
<a name="ln428">  int err;</a>
<a name="ln429"> </a>
<a name="ln430">  qpim_mroute_del_last = pim_time_monotonic_sec();</a>
<a name="ln431">  ++qpim_mroute_del_events;</a>
<a name="ln432"> </a>
<a name="ln433">  if (PIM_MROUTE_IS_DISABLED) {</a>
<a name="ln434">    zlog_warn(&quot;%s: global multicast is disabled&quot;,</a>
<a name="ln435">	      __PRETTY_FUNCTION__);</a>
<a name="ln436">    return -1;</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  err = setsockopt(qpim_mroute_socket_fd, IPPROTO_IP, MRT_DEL_MFC, mc, sizeof(*mc));</a>
<a name="ln440">  if (err) {</a>
<a name="ln441">    int e = errno;</a>
<a name="ln442">    zlog_warn(&quot;%s %s: failure: setsockopt(fd=%d,IPPROTO_IP,MRT_DEL_MFC): errno=%d: %s&quot;,</a>
<a name="ln443">	      __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln444">	      qpim_mroute_socket_fd,</a>
<a name="ln445">	      e, safe_strerror(e));</a>
<a name="ln446">    errno = e;</a>
<a name="ln447">    return -2;</a>
<a name="ln448">  }</a>
<a name="ln449"> </a>
<a name="ln450">  return 0;</a>
<a name="ln451">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
