
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_route.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol               - isis_route.c</a>
<a name="ln3"> * Copyright (C) 2001,2002   Sampo Saaristo</a>
<a name="ln4"> *                           Tampere University of Technology      </a>
<a name="ln5"> *                           Institute of Communications Engineering</a>
<a name="ln6"> *</a>
<a name="ln7"> *                                         based on ../ospf6d/ospf6_route.[ch]</a>
<a name="ln8"> *                                         by Yasuhiro Ohara</a>
<a name="ln9"> *</a>
<a name="ln10"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln11"> * under the terms of the GNU General Public Licenseas published by the Free </a>
<a name="ln12"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln13"> * any later version.</a>
<a name="ln14"> *</a>
<a name="ln15"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln16"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln17"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln18"> * more details.</a>
<a name="ln19"> </a>
<a name="ln20"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln21"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln22"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln23"> */</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;zebra.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;thread.h&quot;</a>
<a name="ln28">#include &quot;linklist.h&quot;</a>
<a name="ln29">#include &quot;vty.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31">#include &quot;memory.h&quot;</a>
<a name="ln32">#include &quot;prefix.h&quot;</a>
<a name="ln33">#include &quot;hash.h&quot;</a>
<a name="ln34">#include &quot;if.h&quot;</a>
<a name="ln35">#include &quot;table.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;isis_constants.h&quot;</a>
<a name="ln38">#include &quot;isis_common.h&quot;</a>
<a name="ln39">#include &quot;isis_flags.h&quot;</a>
<a name="ln40">#include &quot;dict.h&quot;</a>
<a name="ln41">#include &quot;isisd.h&quot;</a>
<a name="ln42">#include &quot;isis_misc.h&quot;</a>
<a name="ln43">#include &quot;isis_adjacency.h&quot;</a>
<a name="ln44">#include &quot;isis_circuit.h&quot;</a>
<a name="ln45">#include &quot;isis_tlv.h&quot;</a>
<a name="ln46">#include &quot;isis_pdu.h&quot;</a>
<a name="ln47">#include &quot;isis_lsp.h&quot;</a>
<a name="ln48">#include &quot;isis_spf.h&quot;</a>
<a name="ln49">#include &quot;isis_route.h&quot;</a>
<a name="ln50">#include &quot;isis_zebra.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">static struct isis_nexthop *</a>
<a name="ln53">isis_nexthop_create (struct in_addr *ip, ifindex_t ifindex)</a>
<a name="ln54">{</a>
<a name="ln55">  struct listnode *node;</a>
<a name="ln56">  struct isis_nexthop *nexthop;</a>
<a name="ln57"> </a>
<a name="ln58">  for (ALL_LIST_ELEMENTS_RO (isis-&gt;nexthops, node, nexthop))</a>
<a name="ln59">    {</a>
<a name="ln60">      if (nexthop-&gt;ifindex != ifindex)</a>
<a name="ln61">	continue;</a>
<a name="ln62">      if (ip &amp;&amp; memcmp (&amp;nexthop-&gt;ip, ip, sizeof (struct in_addr)) != 0)</a>
<a name="ln63">	continue;</a>
<a name="ln64"> </a>
<a name="ln65">      nexthop-&gt;lock++;</a>
<a name="ln66">      return nexthop;</a>
<a name="ln67">    }</a>
<a name="ln68"> </a>
<a name="ln69">  nexthop = XCALLOC (MTYPE_ISIS_NEXTHOP, sizeof (struct isis_nexthop));</a>
<a name="ln70"> </a>
<a name="ln71">  nexthop-&gt;ifindex = ifindex;</a>
<a name="ln72">  memcpy (&amp;nexthop-&gt;ip, ip, sizeof (struct in_addr));</a>
<a name="ln73">  listnode_add (isis-&gt;nexthops, nexthop);</a>
<a name="ln74">  nexthop-&gt;lock++;</a>
<a name="ln75"> </a>
<a name="ln76">  return nexthop;</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">static void</a>
<a name="ln80">isis_nexthop_delete (struct isis_nexthop *nexthop)</a>
<a name="ln81">{</a>
<a name="ln82">  nexthop-&gt;lock--;</a>
<a name="ln83">  if (nexthop-&gt;lock == 0)</a>
<a name="ln84">    {</a>
<a name="ln85">      listnode_delete (isis-&gt;nexthops, nexthop);</a>
<a name="ln86">      XFREE (MTYPE_ISIS_NEXTHOP, nexthop);</a>
<a name="ln87">    }</a>
<a name="ln88"> </a>
<a name="ln89">  return;</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">static int</a>
<a name="ln93">nexthoplookup (struct list *nexthops, struct in_addr *ip,</a>
<a name="ln94">	       ifindex_t ifindex)</a>
<a name="ln95">{</a>
<a name="ln96">  struct listnode *node;</a>
<a name="ln97">  struct isis_nexthop *nh;</a>
<a name="ln98"> </a>
<a name="ln99">  for (ALL_LIST_ELEMENTS_RO (nexthops, node, nh))</a>
<a name="ln100">    {</a>
<a name="ln101">      if (!(memcmp (ip, &amp;nh-&gt;ip, sizeof (struct in_addr))) &amp;&amp;</a>
<a name="ln102">	  ifindex == nh-&gt;ifindex)</a>
<a name="ln103">	return 1;</a>
<a name="ln104">    }</a>
<a name="ln105"> </a>
<a name="ln106">  return 0;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">#ifdef EXTREME_DEBUG</a>
<a name="ln110">static void</a>
<a name="ln111">nexthop_print (struct isis_nexthop *nh)</a>
<a name="ln112">{</a>
<a name="ln113">  u_char buf[BUFSIZ];</a>
<a name="ln114"> </a>
<a name="ln115">  inet_ntop (AF_INET, &amp;nh-&gt;ip, (char *) buf, BUFSIZ);</a>
<a name="ln116"> </a>
<a name="ln117">  zlog_debug (&quot;      %s %u&quot;, buf, nh-&gt;ifindex);</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">static void</a>
<a name="ln121">nexthops_print (struct list *nhs)</a>
<a name="ln122">{</a>
<a name="ln123">  struct listnode *node;</a>
<a name="ln124">  struct isis_nexthop *nh;</a>
<a name="ln125"> </a>
<a name="ln126">  for (ALL_LIST_ELEMENTS_RO (nhs, node, nh))</a>
<a name="ln127">    nexthop_print (nh);</a>
<a name="ln128">}</a>
<a name="ln129">#endif /* EXTREME_DEBUG */</a>
<a name="ln130"> </a>
<a name="ln131">#ifdef HAVE_IPV6</a>
<a name="ln132">static struct isis_nexthop6 *</a>
<a name="ln133">isis_nexthop6_new (struct in6_addr *ip6, ifindex_t ifindex)</a>
<a name="ln134">{</a>
<a name="ln135">  struct isis_nexthop6 *nexthop6;</a>
<a name="ln136"> </a>
<a name="ln137">  nexthop6 = XCALLOC (MTYPE_ISIS_NEXTHOP6, sizeof (struct isis_nexthop6));</a>
<a name="ln138"> </a>
<a name="ln139">  nexthop6-&gt;ifindex = ifindex;</a>
<a name="ln140">  memcpy (&amp;nexthop6-&gt;ip6, ip6, sizeof (struct in6_addr));</a>
<a name="ln141">  nexthop6-&gt;lock++;</a>
<a name="ln142"> </a>
<a name="ln143">  return nexthop6;</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">static struct isis_nexthop6 *</a>
<a name="ln147">isis_nexthop6_create (struct in6_addr *ip6, ifindex_t ifindex)</a>
<a name="ln148">{</a>
<a name="ln149">  struct listnode *node;</a>
<a name="ln150">  struct isis_nexthop6 *nexthop6;</a>
<a name="ln151"> </a>
<a name="ln152">  for (ALL_LIST_ELEMENTS_RO (isis-&gt;nexthops6, node, nexthop6))</a>
<a name="ln153">    {</a>
<a name="ln154">      if (nexthop6-&gt;ifindex != ifindex)</a>
<a name="ln155">	continue;</a>
<a name="ln156">      if (ip6 &amp;&amp; memcmp (&amp;nexthop6-&gt;ip6, ip6, sizeof (struct in6_addr)) != 0)</a>
<a name="ln157">	continue;</a>
<a name="ln158"> </a>
<a name="ln159">      nexthop6-&gt;lock++;</a>
<a name="ln160">      return nexthop6;</a>
<a name="ln161">    }</a>
<a name="ln162"> </a>
<a name="ln163">  nexthop6 = isis_nexthop6_new (ip6, ifindex);</a>
<a name="ln164"> </a>
<a name="ln165">  return nexthop6;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">static void</a>
<a name="ln169">isis_nexthop6_delete (struct isis_nexthop6 *nexthop6)</a>
<a name="ln170">{</a>
<a name="ln171"> </a>
<a name="ln172">  nexthop6-&gt;lock--;</a>
<a name="ln173">  if (nexthop6-&gt;lock == 0)</a>
<a name="ln174">    {</a>
<a name="ln175">      listnode_delete (isis-&gt;nexthops6, nexthop6);</a>
<a name="ln176">      XFREE (MTYPE_ISIS_NEXTHOP6, nexthop6);</a>
<a name="ln177">    }</a>
<a name="ln178"> </a>
<a name="ln179">  return;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">static int</a>
<a name="ln183">nexthop6lookup (struct list *nexthops6, struct in6_addr *ip6,</a>
<a name="ln184">		ifindex_t ifindex)</a>
<a name="ln185">{</a>
<a name="ln186">  struct listnode *node;</a>
<a name="ln187">  struct isis_nexthop6 *nh6;</a>
<a name="ln188"> </a>
<a name="ln189">  for (ALL_LIST_ELEMENTS_RO (nexthops6, node, nh6))</a>
<a name="ln190">    {</a>
<a name="ln191">      if (!(memcmp (ip6, &amp;nh6-&gt;ip6, sizeof (struct in6_addr))) &amp;&amp;</a>
<a name="ln192">	  ifindex == nh6-&gt;ifindex)</a>
<a name="ln193">	return 1;</a>
<a name="ln194">    }</a>
<a name="ln195"> </a>
<a name="ln196">  return 0;</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">#ifdef EXTREME_DEBUG</a>
<a name="ln200">static void</a>
<a name="ln201">nexthop6_print (struct isis_nexthop6 *nh6)</a>
<a name="ln202">{</a>
<a name="ln203">  u_char buf[BUFSIZ];</a>
<a name="ln204"> </a>
<a name="ln205">  inet_ntop (AF_INET6, &amp;nh6-&gt;ip6, (char *) buf, BUFSIZ);</a>
<a name="ln206"> </a>
<a name="ln207">  zlog_debug (&quot;      %s %u&quot;, buf, nh6-&gt;ifindex);</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">static void</a>
<a name="ln211">nexthops6_print (struct list *nhs6)</a>
<a name="ln212">{</a>
<a name="ln213">  struct listnode *node;</a>
<a name="ln214">  struct isis_nexthop6 *nh6;</a>
<a name="ln215"> </a>
<a name="ln216">  for (ALL_LIST_ELEMENTS_RO (nhs6, node, nh6))</a>
<a name="ln217">    nexthop6_print (nh6);</a>
<a name="ln218">}</a>
<a name="ln219">#endif /* EXTREME_DEBUG */</a>
<a name="ln220">#endif /* HAVE_IPV6 */</a>
<a name="ln221"> </a>
<a name="ln222">static void</a>
<a name="ln223">adjinfo2nexthop (struct list *nexthops, struct isis_adjacency *adj)</a>
<a name="ln224">{</a>
<a name="ln225">  struct isis_nexthop *nh;</a>
<a name="ln226">  struct listnode *node;</a>
<a name="ln227">  struct in_addr *ipv4_addr;</a>
<a name="ln228"> </a>
<a name="ln229">  if (adj-&gt;ipv4_addrs == NULL)</a>
<a name="ln230">    return;</a>
<a name="ln231"> </a>
<a name="ln232">  for (ALL_LIST_ELEMENTS_RO (adj-&gt;ipv4_addrs, node, ipv4_addr))</a>
<a name="ln233">    {</a>
<a name="ln234">      if (!nexthoplookup (nexthops, ipv4_addr,</a>
<a name="ln235">			  adj-&gt;circuit-&gt;interface-&gt;ifindex))</a>
<a name="ln236">	{</a>
<a name="ln237">	  nh = isis_nexthop_create (ipv4_addr,</a>
<a name="ln238">				    adj-&gt;circuit-&gt;interface-&gt;ifindex);</a>
<a name="ln239">          nh-&gt;router_address = adj-&gt;router_address;</a>
<a name="ln240">	  listnode_add (nexthops, nh);</a>
<a name="ln241">	}</a>
<a name="ln242">    }</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">#ifdef HAVE_IPV6</a>
<a name="ln246">static void</a>
<a name="ln247">adjinfo2nexthop6 (struct list *nexthops6, struct isis_adjacency *adj)</a>
<a name="ln248">{</a>
<a name="ln249">  struct listnode *node;</a>
<a name="ln250">  struct in6_addr *ipv6_addr;</a>
<a name="ln251">  struct isis_nexthop6 *nh6;</a>
<a name="ln252"> </a>
<a name="ln253">  if (!adj-&gt;ipv6_addrs)</a>
<a name="ln254">    return;</a>
<a name="ln255"> </a>
<a name="ln256">  for (ALL_LIST_ELEMENTS_RO (adj-&gt;ipv6_addrs, node, ipv6_addr))</a>
<a name="ln257">    {</a>
<a name="ln258">      if (!nexthop6lookup (nexthops6, ipv6_addr,</a>
<a name="ln259">			   adj-&gt;circuit-&gt;interface-&gt;ifindex))</a>
<a name="ln260">	{</a>
<a name="ln261">	  nh6 = isis_nexthop6_create (ipv6_addr,</a>
<a name="ln262">				      adj-&gt;circuit-&gt;interface-&gt;ifindex);</a>
<a name="ln263">          nh6-&gt;router_address6 = adj-&gt;router_address6;</a>
<a name="ln264">	  listnode_add (nexthops6, nh6);</a>
<a name="ln265">	}</a>
<a name="ln266">    }</a>
<a name="ln267">}</a>
<a name="ln268">#endif /* HAVE_IPV6 */</a>
<a name="ln269"> </a>
<a name="ln270">static struct isis_route_info *</a>
<a name="ln271">isis_route_info_new (struct prefix *prefix, uint32_t cost, uint32_t depth,</a>
<a name="ln272">                     struct list *adjacencies)</a>
<a name="ln273">{</a>
<a name="ln274">  struct isis_route_info *rinfo;</a>
<a name="ln275">  struct isis_adjacency *adj;</a>
<a name="ln276">  struct listnode *node;</a>
<a name="ln277"> </a>
<a name="ln278">  rinfo = XCALLOC (MTYPE_ISIS_ROUTE_INFO, sizeof (struct isis_route_info));</a>
<a name="ln279"> </a>
<a name="ln280">  if (prefix-&gt;family == AF_INET)</a>
<a name="ln281">    {</a>
<a name="ln282">      rinfo-&gt;nexthops = list_new ();</a>
<a name="ln283">      for (ALL_LIST_ELEMENTS_RO (adjacencies, node, adj))</a>
<a name="ln284">        {</a>
<a name="ln285">          /* check for force resync this route */</a>
<a name="ln286">          if (CHECK_FLAG (adj-&gt;circuit-&gt;flags, ISIS_CIRCUIT_FLAPPED_AFTER_SPF))</a>
<a name="ln287">            SET_FLAG (rinfo-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_RESYNC);</a>
<a name="ln288">          /* update neighbor router address */</a>
<a name="ln289">          if (depth == 2 &amp;&amp; prefix-&gt;prefixlen == 32)</a>
<a name="ln290">            adj-&gt;router_address = prefix-&gt;u.prefix4;</a>
<a name="ln291">          adjinfo2nexthop (rinfo-&gt;nexthops, adj);</a>
<a name="ln292">        }</a>
<a name="ln293">    }</a>
<a name="ln294">#ifdef HAVE_IPV6</a>
<a name="ln295">  if (prefix-&gt;family == AF_INET6)</a>
<a name="ln296">    {</a>
<a name="ln297">      rinfo-&gt;nexthops6 = list_new ();</a>
<a name="ln298">      for (ALL_LIST_ELEMENTS_RO (adjacencies, node, adj))</a>
<a name="ln299">        {</a>
<a name="ln300">          /* check for force resync this route */</a>
<a name="ln301">          if (CHECK_FLAG (adj-&gt;circuit-&gt;flags, ISIS_CIRCUIT_FLAPPED_AFTER_SPF))</a>
<a name="ln302">            SET_FLAG (rinfo-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_RESYNC);</a>
<a name="ln303">          /* update neighbor router address */</a>
<a name="ln304">          if (depth == 2 &amp;&amp; prefix-&gt;prefixlen == 128)</a>
<a name="ln305">            adj-&gt;router_address6 = prefix-&gt;u.prefix6;</a>
<a name="ln306">          adjinfo2nexthop6 (rinfo-&gt;nexthops6, adj);</a>
<a name="ln307">        }</a>
<a name="ln308">    }</a>
<a name="ln309"> </a>
<a name="ln310">#endif /* HAVE_IPV6 */</a>
<a name="ln311"> </a>
<a name="ln312">  rinfo-&gt;cost = cost;</a>
<a name="ln313">  rinfo-&gt;depth = depth;</a>
<a name="ln314"> </a>
<a name="ln315">  return rinfo;</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">static void</a>
<a name="ln319">isis_route_info_delete (struct isis_route_info *route_info)</a>
<a name="ln320">{</a>
<a name="ln321">  if (route_info-&gt;nexthops)</a>
<a name="ln322">    {</a>
<a name="ln323">      route_info-&gt;nexthops-&gt;del = (void (*)(void *)) isis_nexthop_delete;</a>
<a name="ln324">      list_delete (route_info-&gt;nexthops);</a>
<a name="ln325">    }</a>
<a name="ln326"> </a>
<a name="ln327">#ifdef HAVE_IPV6</a>
<a name="ln328">  if (route_info-&gt;nexthops6)</a>
<a name="ln329">    {</a>
<a name="ln330">      route_info-&gt;nexthops6-&gt;del = (void (*)(void *)) isis_nexthop6_delete;</a>
<a name="ln331">      list_delete (route_info-&gt;nexthops6);</a>
<a name="ln332">    }</a>
<a name="ln333">#endif /* HAVE_IPV6 */</a>
<a name="ln334"> </a>
<a name="ln335">  XFREE (MTYPE_ISIS_ROUTE_INFO, route_info);</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">static int</a>
<a name="ln339">isis_route_info_same_attrib (struct isis_route_info *new,</a>
<a name="ln340">			     struct isis_route_info *old)</a>
<a name="ln341">{</a>
<a name="ln342">  if (new-&gt;cost != old-&gt;cost)</a>
<a name="ln343">    return 0;</a>
<a name="ln344">  if (new-&gt;depth != old-&gt;depth)</a>
<a name="ln345">    return 0;</a>
<a name="ln346"> </a>
<a name="ln347">  return 1;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">static int</a>
<a name="ln351">isis_route_info_same (struct isis_route_info *new,</a>
<a name="ln352">		      struct isis_route_info *old, u_char family)</a>
<a name="ln353">{</a>
<a name="ln354">  struct listnode *node;</a>
<a name="ln355">  struct isis_nexthop *nexthop;</a>
<a name="ln356">#ifdef HAVE_IPV6</a>
<a name="ln357">  struct isis_nexthop6 *nexthop6;</a>
<a name="ln358">#endif /* HAVE_IPV6 */</a>
<a name="ln359"> </a>
<a name="ln360">  if (!CHECK_FLAG (old-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED))</a>
<a name="ln361">    return 0;</a>
<a name="ln362"> </a>
<a name="ln363">  if (CHECK_FLAG (new-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_RESYNC))</a>
<a name="ln364">    return 0;</a>
<a name="ln365"> </a>
<a name="ln366">  if (!isis_route_info_same_attrib (new, old))</a>
<a name="ln367">    return 0;</a>
<a name="ln368"> </a>
<a name="ln369">  if (family == AF_INET)</a>
<a name="ln370">    {</a>
<a name="ln371">      for (ALL_LIST_ELEMENTS_RO (new-&gt;nexthops, node, nexthop))</a>
<a name="ln372">        if (nexthoplookup (old-&gt;nexthops, &amp;nexthop-&gt;ip, nexthop-&gt;ifindex)</a>
<a name="ln373">              == 0)</a>
<a name="ln374">          return 0;</a>
<a name="ln375"> </a>
<a name="ln376">      for (ALL_LIST_ELEMENTS_RO (old-&gt;nexthops, node, nexthop))</a>
<a name="ln377">        if (nexthoplookup (new-&gt;nexthops, &amp;nexthop-&gt;ip, nexthop-&gt;ifindex)</a>
<a name="ln378">             == 0)</a>
<a name="ln379">          return 0;</a>
<a name="ln380">    }</a>
<a name="ln381">#ifdef HAVE_IPV6</a>
<a name="ln382">  else if (family == AF_INET6)</a>
<a name="ln383">    {</a>
<a name="ln384">      for (ALL_LIST_ELEMENTS_RO (new-&gt;nexthops6, node, nexthop6))</a>
<a name="ln385">        if (nexthop6lookup (old-&gt;nexthops6, &amp;nexthop6-&gt;ip6,</a>
<a name="ln386">                            nexthop6-&gt;ifindex) == 0)</a>
<a name="ln387">          return 0;</a>
<a name="ln388"> </a>
<a name="ln389">      for (ALL_LIST_ELEMENTS_RO (old-&gt;nexthops6, node, nexthop6))</a>
<a name="ln390">        if (nexthop6lookup (new-&gt;nexthops6, &amp;nexthop6-&gt;ip6,</a>
<a name="ln391">                            nexthop6-&gt;ifindex) == 0)</a>
<a name="ln392">          return 0;</a>
<a name="ln393">    }</a>
<a name="ln394">#endif /* HAVE_IPV6 */</a>
<a name="ln395"> </a>
<a name="ln396">  return 1;</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399">struct isis_route_info *</a>
<a name="ln400">isis_route_create (struct prefix *prefix, u_int32_t cost, u_int32_t depth,</a>
<a name="ln401">		   struct list *adjacencies, struct isis_area *area,</a>
<a name="ln402">		   int level)</a>
<a name="ln403">{</a>
<a name="ln404">  struct route_node *route_node;</a>
<a name="ln405">  struct isis_route_info *rinfo_new, *rinfo_old, *route_info = NULL;</a>
<a name="ln406">  u_char buff[BUFSIZ];</a>
<a name="ln407">  u_char family;</a>
<a name="ln408"> </a>
<a name="ln409">  family = prefix-&gt;family;</a>
<a name="ln410">  /* for debugs */</a>
<a name="ln411">  prefix2str (prefix, (char *) buff, BUFSIZ);</a>
<a name="ln412"> </a>
<a name="ln413">  rinfo_new = isis_route_info_new (prefix, cost, depth, adjacencies);</a>
<a name="ln414"> </a>
<a name="ln415">  if (family == AF_INET)</a>
<a name="ln416">    route_node = route_node_get (area-&gt;route_table[level - 1], prefix);</a>
<a name="ln417">#ifdef HAVE_IPV6</a>
<a name="ln418">  else if (family == AF_INET6)</a>
<a name="ln419">    route_node = route_node_get (area-&gt;route_table6[level - 1], prefix);</a>
<a name="ln420">#endif /* HAVE_IPV6 */</a>
<a name="ln421">  else</a>
<a name="ln422">    {</a>
<a name="ln423">      isis_route_info_delete (rinfo_new);</a>
<a name="ln424">      return NULL;</a>
<a name="ln425">    }</a>
<a name="ln426"> </a>
<a name="ln427">  rinfo_old = route_node-&gt;info;</a>
<a name="ln428">  if (!rinfo_old)</a>
<a name="ln429">    {</a>
<a name="ln430">      if (isis-&gt;debugs &amp; DEBUG_RTE_EVENTS)</a>
<a name="ln431">        zlog_debug (&quot;ISIS-Rte (%s) route created: %s&quot;, area-&gt;area_tag, buff);</a>
<a name="ln432">      route_info = rinfo_new;</a>
<a name="ln433">      UNSET_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);</a>
<a name="ln434">    }</a>
<a name="ln435">  else</a>
<a name="ln436">    {</a>
<a name="ln437">      if (isis-&gt;debugs &amp; DEBUG_RTE_EVENTS)</a>
<a name="ln438">        zlog_debug (&quot;ISIS-Rte (%s) route already exists: %s&quot;, area-&gt;area_tag,</a>
<a name="ln439">                   buff);</a>
<a name="ln440">      if (isis_route_info_same (rinfo_new, rinfo_old, family))</a>
<a name="ln441">        {</a>
<a name="ln442">          if (isis-&gt;debugs &amp; DEBUG_RTE_EVENTS)</a>
<a name="ln443">            zlog_debug (&quot;ISIS-Rte (%s) route unchanged: %s&quot;, area-&gt;area_tag,</a>
<a name="ln444">                        buff);</a>
<a name="ln445">          isis_route_info_delete (rinfo_new);</a>
<a name="ln446">          route_info = rinfo_old;</a>
<a name="ln447">        }</a>
<a name="ln448">      else</a>
<a name="ln449">        {</a>
<a name="ln450">          if (isis-&gt;debugs &amp; DEBUG_RTE_EVENTS)</a>
<a name="ln451">            zlog_debug (&quot;ISIS-Rte (%s) route changed: %s&quot;, area-&gt;area_tag,</a>
<a name="ln452">                        buff);</a>
<a name="ln453">          isis_route_info_delete (rinfo_old);</a>
<a name="ln454">          route_info = rinfo_new;</a>
<a name="ln455">          UNSET_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);</a>
<a name="ln456">        }</a>
<a name="ln457">    }</a>
<a name="ln458"> </a>
<a name="ln459">  SET_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ACTIVE);</a>
<a name="ln460">  route_node-&gt;info = route_info;</a>
<a name="ln461"> </a>
<a name="ln462">  return route_info;</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">static void</a>
<a name="ln466">isis_route_delete (struct prefix *prefix, struct route_table *table)</a>
<a name="ln467">{</a>
<a name="ln468">  struct route_node *rode;</a>
<a name="ln469">  struct isis_route_info *rinfo;</a>
<a name="ln470">  char buff[BUFSIZ];</a>
<a name="ln471"> </a>
<a name="ln472">  /* for log */</a>
<a name="ln473">  prefix2str (prefix, buff, BUFSIZ);</a>
<a name="ln474"> </a>
<a name="ln475"> </a>
<a name="ln476">  rode = route_node_get (table, prefix);</a>
<a name="ln477">  rinfo = rode-&gt;info;</a>
<a name="ln478"> </a>
<a name="ln479">  if (rinfo == NULL)</a>
<a name="ln480">    {</a>
<a name="ln481">      if (isis-&gt;debugs &amp; DEBUG_RTE_EVENTS)</a>
<a name="ln482">	zlog_debug (&quot;ISIS-Rte: tried to delete non-existant route %s&quot;, buff);</a>
<a name="ln483">      return;</a>
<a name="ln484">    }</a>
<a name="ln485"> </a>
<a name="ln486">  if (CHECK_FLAG (rinfo-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED))</a>
<a name="ln487">    {</a>
<a name="ln488">      UNSET_FLAG (rinfo-&gt;flag, ISIS_ROUTE_FLAG_ACTIVE);</a>
<a name="ln489">      if (isis-&gt;debugs &amp; DEBUG_RTE_EVENTS)</a>
<a name="ln490">	zlog_debug (&quot;ISIS-Rte: route delete  %s&quot;, buff);</a>
<a name="ln491">      isis_zebra_route_update (prefix, rinfo);</a>
<a name="ln492">    }</a>
<a name="ln493">  isis_route_info_delete (rinfo);</a>
<a name="ln494">  rode-&gt;info = NULL;</a>
<a name="ln495"> </a>
<a name="ln496">  return;</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">/* Validating routes in particular table. */</a>
<a name="ln500">static void</a>
<a name="ln501">isis_route_validate_table (struct isis_area *area, struct route_table *table)</a>
<a name="ln502">{</a>
<a name="ln503">  struct route_node *rnode, *drnode;</a>
<a name="ln504">  struct isis_route_info *rinfo;</a>
<a name="ln505">  u_char buff[BUFSIZ];</a>
<a name="ln506"> </a>
<a name="ln507">  for (rnode = route_top (table); rnode; rnode = route_next (rnode))</a>
<a name="ln508">    {</a>
<a name="ln509">      if (rnode-&gt;info == NULL)</a>
<a name="ln510">	continue;</a>
<a name="ln511">      rinfo = rnode-&gt;info;</a>
<a name="ln512"> </a>
<a name="ln513">      if (isis-&gt;debugs &amp; DEBUG_RTE_EVENTS)</a>
<a name="ln514">	{</a>
<a name="ln515">	  prefix2str (&amp;rnode-&gt;p, (char *) buff, BUFSIZ);</a>
<a name="ln516">	  zlog_debug (&quot;ISIS-Rte (%s): route validate: %s %s %s %s&quot;,</a>
<a name="ln517">		      area-&gt;area_tag,</a>
<a name="ln518">		      (CHECK_FLAG (rinfo-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED) ?</a>
<a name="ln519">		      &quot;synced&quot; : &quot;not-synced&quot;),</a>
<a name="ln520">		      (CHECK_FLAG (rinfo-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_RESYNC) ?</a>
<a name="ln521">		      &quot;resync&quot; : &quot;not-resync&quot;),</a>
<a name="ln522">		      (CHECK_FLAG (rinfo-&gt;flag, ISIS_ROUTE_FLAG_ACTIVE) ?</a>
<a name="ln523">		      &quot;active&quot; : &quot;inactive&quot;), buff);</a>
<a name="ln524">	}</a>
<a name="ln525"> </a>
<a name="ln526">      isis_zebra_route_update (&amp;rnode-&gt;p, rinfo);</a>
<a name="ln527">      if (!CHECK_FLAG (rinfo-&gt;flag, ISIS_ROUTE_FLAG_ACTIVE))</a>
<a name="ln528">	{</a>
<a name="ln529">	  /* Area is either L1 or L2 =&gt; we use level route tables directly for</a>
<a name="ln530">	   * validating =&gt; no problems with deleting routes. */</a>
<a name="ln531">	  if (area-&gt;is_type != IS_LEVEL_1_AND_2)</a>
<a name="ln532">	    {</a>
<a name="ln533">	      isis_route_delete (&amp;rnode-&gt;p, table);</a>
<a name="ln534">	      continue;</a>
<a name="ln535">	    }</a>
<a name="ln536">	  /* If area is L1L2, we work with merge table and therefore must</a>
<a name="ln537">	   * delete node from level tables as well before deleting route info.</a>
<a name="ln538">	   * FIXME: Is it performance problem? There has to be the better way.</a>
<a name="ln539">	   * Like not to deal with it here at all (see the next comment)? */</a>
<a name="ln540">	  if (rnode-&gt;p.family == AF_INET)</a>
<a name="ln541">	    {</a>
<a name="ln542">	      drnode = route_node_get (area-&gt;route_table[0], &amp;rnode-&gt;p);</a>
<a name="ln543">	      if (drnode-&gt;info == rnode-&gt;info)</a>
<a name="ln544">		drnode-&gt;info = NULL;</a>
<a name="ln545">	      drnode = route_node_get (area-&gt;route_table[1], &amp;rnode-&gt;p);</a>
<a name="ln546">	      if (drnode-&gt;info == rnode-&gt;info)</a>
<a name="ln547">		drnode-&gt;info = NULL;</a>
<a name="ln548">	    }</a>
<a name="ln549"> </a>
<a name="ln550">#ifdef HAVE_IPV6</a>
<a name="ln551">	  if (rnode-&gt;p.family == AF_INET6)</a>
<a name="ln552">	    {</a>
<a name="ln553">	      drnode = route_node_get (area-&gt;route_table6[0], &amp;rnode-&gt;p);</a>
<a name="ln554">	      if (drnode-&gt;info == rnode-&gt;info)</a>
<a name="ln555">		drnode-&gt;info = NULL;</a>
<a name="ln556">	      drnode = route_node_get (area-&gt;route_table6[1], &amp;rnode-&gt;p);</a>
<a name="ln557">	      if (drnode-&gt;info == rnode-&gt;info)</a>
<a name="ln558">		drnode-&gt;info = NULL;</a>
<a name="ln559">	    }</a>
<a name="ln560">#endif</a>
<a name="ln561">	      </a>
<a name="ln562">	  isis_route_delete (&amp;rnode-&gt;p, table);</a>
<a name="ln563">	}</a>
<a name="ln564">    }</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">/* Function to validate route tables for L1L2 areas. In this case we can't use</a>
<a name="ln568"> * level route tables directly, we have to merge them at first. L1 routes are</a>
<a name="ln569"> * preferred over the L2 ones.</a>
<a name="ln570"> *</a>
<a name="ln571"> * Merge algorithm is trivial (at least for now). All L1 paths are copied into</a>
<a name="ln572"> * merge table at first, then L2 paths are added if L1 path for same prefix</a>
<a name="ln573"> * doesn't already exists there.</a>
<a name="ln574"> *</a>
<a name="ln575"> * FIXME: Is it right place to do it at all? Maybe we should push both levels</a>
<a name="ln576"> * to the RIB with different zebra route types and let RIB handle this? */</a>
<a name="ln577">static void</a>
<a name="ln578">isis_route_validate_merge (struct isis_area *area, int family)</a>
<a name="ln579">{</a>
<a name="ln580">  struct route_table *table = NULL;</a>
<a name="ln581">  struct route_table *merge;</a>
<a name="ln582">  struct route_node *rnode, *mrnode;</a>
<a name="ln583"> </a>
<a name="ln584">  merge = route_table_init ();</a>
<a name="ln585"> </a>
<a name="ln586">  if (family == AF_INET)</a>
<a name="ln587">    table = area-&gt;route_table[0];</a>
<a name="ln588">#ifdef HAVE_IPV6</a>
<a name="ln589">  else if (family == AF_INET6)</a>
<a name="ln590">    table = area-&gt;route_table6[0];</a>
<a name="ln591">#endif</a>
<a name="ln592"> </a>
<a name="ln593">  for (rnode = route_top (table); rnode; rnode = route_next (rnode))</a>
<a name="ln594">    {</a>
<a name="ln595">      if (rnode-&gt;info == NULL)</a>
<a name="ln596">        continue;</a>
<a name="ln597">      mrnode = route_node_get (merge, &amp;rnode-&gt;p);</a>
<a name="ln598">      mrnode-&gt;info = rnode-&gt;info;</a>
<a name="ln599">    }</a>
<a name="ln600"> </a>
<a name="ln601">  if (family == AF_INET)</a>
<a name="ln602">    table = area-&gt;route_table[1];</a>
<a name="ln603">#ifdef HAVE_IPV6</a>
<a name="ln604">  else if (family == AF_INET6)</a>
<a name="ln605">    table = area-&gt;route_table6[1];</a>
<a name="ln606">#endif</a>
<a name="ln607"> </a>
<a name="ln608">  for (rnode = route_top (table); rnode; rnode = route_next (rnode))</a>
<a name="ln609">    {</a>
<a name="ln610">      if (rnode-&gt;info == NULL)</a>
<a name="ln611">        continue;</a>
<a name="ln612">      mrnode = route_node_get (merge, &amp;rnode-&gt;p);</a>
<a name="ln613">      if (mrnode-&gt;info != NULL)</a>
<a name="ln614">        continue;</a>
<a name="ln615">      mrnode-&gt;info = rnode-&gt;info;</a>
<a name="ln616">    }</a>
<a name="ln617"> </a>
<a name="ln618">  isis_route_validate_table (area, merge);</a>
<a name="ln619">  route_table_finish (merge);</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">/* Walk through route tables and propagate necessary changes into RIB. In case</a>
<a name="ln623"> * of L1L2 area, level tables have to be merged at first. */</a>
<a name="ln624">void</a>
<a name="ln625">isis_route_validate (struct isis_area *area)</a>
<a name="ln626">{</a>
<a name="ln627">  struct listnode *node;</a>
<a name="ln628">  struct isis_circuit *circuit;</a>
<a name="ln629"> </a>
<a name="ln630">  if (area-&gt;is_type == IS_LEVEL_1)</a>
<a name="ln631">    isis_route_validate_table (area, area-&gt;route_table[0]);</a>
<a name="ln632">  else if (area-&gt;is_type == IS_LEVEL_2)</a>
<a name="ln633">    isis_route_validate_table (area, area-&gt;route_table[1]);</a>
<a name="ln634">  else</a>
<a name="ln635">    isis_route_validate_merge (area, AF_INET);</a>
<a name="ln636"> </a>
<a name="ln637">#ifdef HAVE_IPV6</a>
<a name="ln638">  if (area-&gt;is_type == IS_LEVEL_1)</a>
<a name="ln639">    isis_route_validate_table (area, area-&gt;route_table6[0]);</a>
<a name="ln640">  else if (area-&gt;is_type == IS_LEVEL_2)</a>
<a name="ln641">    isis_route_validate_table (area, area-&gt;route_table6[1]);</a>
<a name="ln642">  else</a>
<a name="ln643">    isis_route_validate_merge (area, AF_INET6);</a>
<a name="ln644">#endif</a>
<a name="ln645"> </a>
<a name="ln646">  if (!area-&gt;circuit_list) {</a>
<a name="ln647">    return;</a>
<a name="ln648">  }</a>
<a name="ln649">  /* walk all circuits and reset any spf specific flags */</a>
<a name="ln650">  for (ALL_LIST_ELEMENTS_RO (area-&gt;circuit_list, node, circuit))</a>
<a name="ln651">    UNSET_FLAG(circuit-&gt;flags, ISIS_CIRCUIT_FLAPPED_AFTER_SPF);</a>
<a name="ln652"> </a>
<a name="ln653">  return;</a>
<a name="ln654">}</a>
<a name="ln655"> </a>
<a name="ln656">void</a>
<a name="ln657">isis_route_invalidate_table (struct isis_area *area, struct route_table *table)</a>
<a name="ln658">{</a>
<a name="ln659">  struct route_node *rode;</a>
<a name="ln660">  struct isis_route_info *rinfo;</a>
<a name="ln661">  for (rode = route_top (table); rode; rode = route_next (rode))</a>
<a name="ln662">    {</a>
<a name="ln663">      if (rode-&gt;info == NULL)</a>
<a name="ln664">        continue;</a>
<a name="ln665">      rinfo = rode-&gt;info;</a>
<a name="ln666"> </a>
<a name="ln667">      UNSET_FLAG (rinfo-&gt;flag, ISIS_ROUTE_FLAG_ACTIVE);</a>
<a name="ln668">    }</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">void</a>
<a name="ln672">isis_route_invalidate (struct isis_area *area)</a>
<a name="ln673">{</a>
<a name="ln674">  if (area-&gt;is_type &amp; IS_LEVEL_1)</a>
<a name="ln675">    isis_route_invalidate_table (area, area-&gt;route_table[0]);</a>
<a name="ln676">  if (area-&gt;is_type &amp; IS_LEVEL_2)</a>
<a name="ln677">    isis_route_invalidate_table (area, area-&gt;route_table[1]);</a>
<a name="ln678">}</a>

</code></pre>
<div class="balloon" rel="17"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
