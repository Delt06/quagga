
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ripngd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* RIPng daemon</a>
<a name="ln2"> * Copyright (C) 1998, 1999 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;prefix.h&quot;</a>
<a name="ln25">#include &quot;filter.h&quot;</a>
<a name="ln26">#include &quot;log.h&quot;</a>
<a name="ln27">#include &quot;thread.h&quot;</a>
<a name="ln28">#include &quot;memory.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;stream.h&quot;</a>
<a name="ln31">#include &quot;table.h&quot;</a>
<a name="ln32">#include &quot;command.h&quot;</a>
<a name="ln33">#include &quot;sockopt.h&quot;</a>
<a name="ln34">#include &quot;distribute.h&quot;</a>
<a name="ln35">#include &quot;plist.h&quot;</a>
<a name="ln36">#include &quot;routemap.h&quot;</a>
<a name="ln37">#include &quot;if_rmap.h&quot;</a>
<a name="ln38">#include &quot;privs.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;ripngd/ripngd.h&quot;</a>
<a name="ln41">#include &quot;ripngd/ripng_route.h&quot;</a>
<a name="ln42">#include &quot;ripngd/ripng_debug.h&quot;</a>
<a name="ln43">#include &quot;ripngd/ripng_nexthop.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">/* RIPng structure which includes many parameters related to RIPng</a>
<a name="ln46">   protocol. If ripng couldn't active or ripng doesn't configured,</a>
<a name="ln47">   ripng-&gt;fd must be negative value. */</a>
<a name="ln48">struct ripng *ripng = NULL;</a>
<a name="ln49"> </a>
<a name="ln50">enum</a>
<a name="ln51">{</a>
<a name="ln52">  ripng_all_route,</a>
<a name="ln53">  ripng_changed_route,</a>
<a name="ln54">};</a>
<a name="ln55"> </a>
<a name="ln56">extern struct zebra_privs_t ripngd_privs;</a>
<a name="ln57"> </a>
<a name="ln58">/* Prototypes. */</a>
<a name="ln59">void</a>
<a name="ln60">ripng_output_process (struct interface *, struct sockaddr_in6 *, int);</a>
<a name="ln61"> </a>
<a name="ln62">int</a>
<a name="ln63">ripng_triggered_update (struct thread *);</a>
<a name="ln64"> </a>
<a name="ln65">/* RIPng next hop specification. */</a>
<a name="ln66">struct ripng_nexthop</a>
<a name="ln67">{</a>
<a name="ln68">  enum ripng_nexthop_type</a>
<a name="ln69">  {</a>
<a name="ln70">    RIPNG_NEXTHOP_UNSPEC,</a>
<a name="ln71">    RIPNG_NEXTHOP_ADDRESS</a>
<a name="ln72">  } flag;</a>
<a name="ln73">  struct in6_addr address;</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">static int</a>
<a name="ln77">ripng_route_rte (struct ripng_info *rinfo)</a>
<a name="ln78">{</a>
<a name="ln79">  return (rinfo-&gt;type == ZEBRA_ROUTE_RIPNG &amp;&amp; rinfo-&gt;sub_type == RIPNG_ROUTE_RTE);</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">/* Allocate new ripng information. */</a>
<a name="ln83">struct ripng_info *</a>
<a name="ln84">ripng_info_new ()</a>
<a name="ln85">{</a>
<a name="ln86">  struct ripng_info *new;</a>
<a name="ln87"> </a>
<a name="ln88">  new = XCALLOC (MTYPE_RIPNG_ROUTE, sizeof (struct ripng_info));</a>
<a name="ln89">  return new;</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">/* Free ripng information. */</a>
<a name="ln93">void</a>
<a name="ln94">ripng_info_free (struct ripng_info *rinfo)</a>
<a name="ln95">{</a>
<a name="ln96">  XFREE (MTYPE_RIPNG_ROUTE, rinfo);</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">/* Create ripng socket. */</a>
<a name="ln100">static int </a>
<a name="ln101">ripng_make_socket (void)</a>
<a name="ln102">{</a>
<a name="ln103">  int ret;</a>
<a name="ln104">  int sock;</a>
<a name="ln105">  struct sockaddr_in6 ripaddr;</a>
<a name="ln106"> </a>
<a name="ln107">  sock = socket (AF_INET6, SOCK_DGRAM, 0);</a>
<a name="ln108">  if (sock &lt; 0)</a>
<a name="ln109">    {</a>
<a name="ln110">      zlog (NULL, LOG_ERR, &quot;Can't make ripng socket&quot;);</a>
<a name="ln111">      return sock;</a>
<a name="ln112">    }</a>
<a name="ln113"> </a>
<a name="ln114">  ret = setsockopt_so_recvbuf (sock, 8096);</a>
<a name="ln115">  if (ret &lt; 0)</a>
<a name="ln116">    return ret;</a>
<a name="ln117">  ret = setsockopt_ipv6_pktinfo (sock, 1);</a>
<a name="ln118">  if (ret &lt; 0)</a>
<a name="ln119">    return ret;</a>
<a name="ln120">#ifdef IPTOS_PREC_INTERNETCONTROL</a>
<a name="ln121">  ret = setsockopt_ipv6_tclass (sock, IPTOS_PREC_INTERNETCONTROL);</a>
<a name="ln122">  if (ret &lt; 0)</a>
<a name="ln123">    return ret;</a>
<a name="ln124">#endif</a>
<a name="ln125">  ret = setsockopt_ipv6_multicast_hops (sock, 255);</a>
<a name="ln126">  if (ret &lt; 0)</a>
<a name="ln127">    return ret;</a>
<a name="ln128">  ret = setsockopt_ipv6_multicast_loop (sock, 0);</a>
<a name="ln129">  if (ret &lt; 0)</a>
<a name="ln130">    return ret;</a>
<a name="ln131">  ret = setsockopt_ipv6_hoplimit (sock, 1);</a>
<a name="ln132">  if (ret &lt; 0)</a>
<a name="ln133">    return ret;</a>
<a name="ln134"> </a>
<a name="ln135">  memset (&amp;ripaddr, 0, sizeof (ripaddr));</a>
<a name="ln136">  ripaddr.sin6_family = AF_INET6;</a>
<a name="ln137">#ifdef SIN6_LEN</a>
<a name="ln138">  ripaddr.sin6_len = sizeof (struct sockaddr_in6);</a>
<a name="ln139">#endif /* SIN6_LEN */</a>
<a name="ln140">  ripaddr.sin6_port = htons (RIPNG_PORT_DEFAULT);</a>
<a name="ln141"> </a>
<a name="ln142">  if (ripngd_privs.change (ZPRIVS_RAISE))</a>
<a name="ln143">    zlog_err (&quot;ripng_make_socket: could not raise privs&quot;);</a>
<a name="ln144">  </a>
<a name="ln145">  ret = bind (sock, (struct sockaddr *) &amp;ripaddr, sizeof (ripaddr));</a>
<a name="ln146">  if (ret &lt; 0)</a>
<a name="ln147">  {</a>
<a name="ln148">    zlog (NULL, LOG_ERR, &quot;Can't bind ripng socket: %s.&quot;, safe_strerror (errno));</a>
<a name="ln149">    if (ripngd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln150">      zlog_err (&quot;ripng_make_socket: could not lower privs&quot;);</a>
<a name="ln151">    return ret;</a>
<a name="ln152">  }</a>
<a name="ln153">  if (ripngd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln154">    zlog_err (&quot;ripng_make_socket: could not lower privs&quot;);</a>
<a name="ln155">  return sock;</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">/* Send RIPng packet. */</a>
<a name="ln159">int</a>
<a name="ln160">ripng_send_packet (caddr_t buf, int bufsize, struct sockaddr_in6 *to, </a>
<a name="ln161">		   struct interface *ifp)</a>
<a name="ln162">{</a>
<a name="ln163">  int ret;</a>
<a name="ln164">  struct msghdr msg;</a>
<a name="ln165">  struct iovec iov;</a>
<a name="ln166">  struct cmsghdr  *cmsgptr;</a>
<a name="ln167">  char adata [256];</a>
<a name="ln168">  struct in6_pktinfo *pkt;</a>
<a name="ln169">  struct sockaddr_in6 addr;</a>
<a name="ln170"> </a>
<a name="ln171">  if (IS_RIPNG_DEBUG_SEND) {</a>
<a name="ln172">    if (to)</a>
<a name="ln173">      zlog_debug (&quot;send to %s&quot;, inet6_ntoa (to-&gt;sin6_addr));</a>
<a name="ln174">    zlog_debug (&quot;  send interface %s&quot;, ifp-&gt;name);</a>
<a name="ln175">    zlog_debug (&quot;  send packet size %d&quot;, bufsize);</a>
<a name="ln176">  }</a>
<a name="ln177"> </a>
<a name="ln178">  memset (&amp;addr, 0, sizeof (struct sockaddr_in6));</a>
<a name="ln179">  addr.sin6_family = AF_INET6;</a>
<a name="ln180">#ifdef SIN6_LEN</a>
<a name="ln181">  addr.sin6_len = sizeof (struct sockaddr_in6);</a>
<a name="ln182">#endif /* SIN6_LEN */</a>
<a name="ln183">  addr.sin6_flowinfo = htonl (RIPNG_PRIORITY_DEFAULT);</a>
<a name="ln184"> </a>
<a name="ln185">  /* When destination is specified. */</a>
<a name="ln186">  if (to != NULL)</a>
<a name="ln187">    {</a>
<a name="ln188">      addr.sin6_addr = to-&gt;sin6_addr;</a>
<a name="ln189">      addr.sin6_port = to-&gt;sin6_port;</a>
<a name="ln190">    }</a>
<a name="ln191">  else</a>
<a name="ln192">    {</a>
<a name="ln193">      inet_pton(AF_INET6, RIPNG_GROUP, &amp;addr.sin6_addr);</a>
<a name="ln194">      addr.sin6_port = htons (RIPNG_PORT_DEFAULT);</a>
<a name="ln195">    }</a>
<a name="ln196"> </a>
<a name="ln197">  msg.msg_name = (void *) &amp;addr;</a>
<a name="ln198">  msg.msg_namelen = sizeof (struct sockaddr_in6);</a>
<a name="ln199">  msg.msg_iov = &amp;iov;</a>
<a name="ln200">  msg.msg_iovlen = 1;</a>
<a name="ln201">  msg.msg_control = (void *) adata;</a>
<a name="ln202">  msg.msg_controllen = CMSG_SPACE(sizeof(struct in6_pktinfo));</a>
<a name="ln203"> </a>
<a name="ln204">  iov.iov_base = buf;</a>
<a name="ln205">  iov.iov_len = bufsize;</a>
<a name="ln206"> </a>
<a name="ln207">  cmsgptr = (struct cmsghdr *)adata;</a>
<a name="ln208">  cmsgptr-&gt;cmsg_len = CMSG_LEN(sizeof (struct in6_pktinfo));</a>
<a name="ln209">  cmsgptr-&gt;cmsg_level = IPPROTO_IPV6;</a>
<a name="ln210">  cmsgptr-&gt;cmsg_type = IPV6_PKTINFO;</a>
<a name="ln211"> </a>
<a name="ln212">  pkt = (struct in6_pktinfo *) CMSG_DATA (cmsgptr);</a>
<a name="ln213">  memset (&amp;pkt-&gt;ipi6_addr, 0, sizeof (struct in6_addr));</a>
<a name="ln214">  pkt-&gt;ipi6_ifindex = ifp-&gt;ifindex;</a>
<a name="ln215"> </a>
<a name="ln216">  ret = sendmsg (ripng-&gt;sock, &amp;msg, 0);</a>
<a name="ln217"> </a>
<a name="ln218">  if (ret &lt; 0) {</a>
<a name="ln219">    if (to)</a>
<a name="ln220">      zlog_err (&quot;RIPng send fail on %s to %s: %s&quot;, ifp-&gt;name, </a>
<a name="ln221">                inet6_ntoa (to-&gt;sin6_addr), safe_strerror (errno));</a>
<a name="ln222">    else</a>
<a name="ln223">      zlog_err (&quot;RIPng send fail on %s: %s&quot;, ifp-&gt;name, safe_strerror (errno));</a>
<a name="ln224">  }</a>
<a name="ln225"> </a>
<a name="ln226">  return ret;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">/* Receive UDP RIPng packet from socket. */</a>
<a name="ln230">static int</a>
<a name="ln231">ripng_recv_packet (int sock, u_char *buf, int bufsize,</a>
<a name="ln232">		   struct sockaddr_in6 *from, ifindex_t *ifindex, </a>
<a name="ln233">		   int *hoplimit)</a>
<a name="ln234">{</a>
<a name="ln235">  int ret;</a>
<a name="ln236">  struct msghdr msg;</a>
<a name="ln237">  struct iovec iov;</a>
<a name="ln238">  struct cmsghdr  *cmsgptr;</a>
<a name="ln239">  struct in6_addr dst = { .s6_addr = { 0 } };</a>
<a name="ln240"> </a>
<a name="ln241">  /* Ancillary data.  This store cmsghdr and in6_pktinfo.  But at this</a>
<a name="ln242">     point I can't determine size of cmsghdr */</a>
<a name="ln243">  char adata[1024];</a>
<a name="ln244"> </a>
<a name="ln245">  /* Fill in message and iovec. */</a>
<a name="ln246">  msg.msg_name = (void *) from;</a>
<a name="ln247">  msg.msg_namelen = sizeof (struct sockaddr_in6);</a>
<a name="ln248">  msg.msg_iov = &amp;iov;</a>
<a name="ln249">  msg.msg_iovlen = 1;</a>
<a name="ln250">  msg.msg_control = (void *) adata;</a>
<a name="ln251">  msg.msg_controllen = sizeof adata;</a>
<a name="ln252">  iov.iov_base = buf;</a>
<a name="ln253">  iov.iov_len = bufsize;</a>
<a name="ln254"> </a>
<a name="ln255">  /* If recvmsg fail return minus value. */</a>
<a name="ln256">  ret = recvmsg (sock, &amp;msg, 0);</a>
<a name="ln257">  if (ret &lt; 0)</a>
<a name="ln258">    return ret;</a>
<a name="ln259"> </a>
<a name="ln260">  for (cmsgptr = ZCMSG_FIRSTHDR(&amp;msg); cmsgptr != NULL;</a>
<a name="ln261">       cmsgptr = CMSG_NXTHDR(&amp;msg, cmsgptr)) </a>
<a name="ln262">    {</a>
<a name="ln263">      /* I want interface index which this packet comes from. */</a>
<a name="ln264">      if (cmsgptr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;</a>
<a name="ln265">	  cmsgptr-&gt;cmsg_type == IPV6_PKTINFO) </a>
<a name="ln266">	{</a>
<a name="ln267">	  struct in6_pktinfo *ptr;</a>
<a name="ln268">	  </a>
<a name="ln269">	  ptr = (struct in6_pktinfo *) CMSG_DATA (cmsgptr);</a>
<a name="ln270">	  *ifindex = ptr-&gt;ipi6_ifindex;</a>
<a name="ln271">	  dst = ptr-&gt;ipi6_addr;</a>
<a name="ln272"> </a>
<a name="ln273">	  if (*ifindex == 0)</a>
<a name="ln274">	    zlog_warn (&quot;Interface index returned by IPV6_PKTINFO is zero&quot;);</a>
<a name="ln275">        }</a>
<a name="ln276"> </a>
<a name="ln277">      /* Incoming packet's multicast hop limit. */</a>
<a name="ln278">      if (cmsgptr-&gt;cmsg_level == IPPROTO_IPV6 &amp;&amp;</a>
<a name="ln279">	  cmsgptr-&gt;cmsg_type == IPV6_HOPLIMIT)</a>
<a name="ln280">	{</a>
<a name="ln281">	  int *phoplimit = (int *) CMSG_DATA (cmsgptr);</a>
<a name="ln282">	  *hoplimit = *phoplimit;</a>
<a name="ln283">	}</a>
<a name="ln284">    }</a>
<a name="ln285"> </a>
<a name="ln286">  /* Hoplimit check shold be done when destination address is</a>
<a name="ln287">     multicast address. */</a>
<a name="ln288">  if (! IN6_IS_ADDR_MULTICAST (&amp;dst))</a>
<a name="ln289">    *hoplimit = -1;</a>
<a name="ln290"> </a>
<a name="ln291">  return ret;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">/* Dump rip packet */</a>
<a name="ln295">void</a>
<a name="ln296">ripng_packet_dump (struct ripng_packet *packet, int size, const char *sndrcv)</a>
<a name="ln297">{</a>
<a name="ln298">  caddr_t lim;</a>
<a name="ln299">  struct rte *rte;</a>
<a name="ln300">  const char *command_str;</a>
<a name="ln301"> </a>
<a name="ln302">  /* Set command string. */</a>
<a name="ln303">  if (packet-&gt;command == RIPNG_REQUEST)</a>
<a name="ln304">    command_str = &quot;request&quot;;</a>
<a name="ln305">  else if (packet-&gt;command == RIPNG_RESPONSE)</a>
<a name="ln306">    command_str = &quot;response&quot;;</a>
<a name="ln307">  else</a>
<a name="ln308">    command_str = &quot;unknown&quot;;</a>
<a name="ln309"> </a>
<a name="ln310">  /* Dump packet header. */</a>
<a name="ln311">  zlog_debug (&quot;%s %s version %d packet size %d&quot;, </a>
<a name="ln312">	     sndrcv, command_str, packet-&gt;version, size);</a>
<a name="ln313"> </a>
<a name="ln314">  /* Dump each routing table entry. */</a>
<a name="ln315">  rte = packet-&gt;rte;</a>
<a name="ln316"> </a>
<a name="ln317">  for (lim = (caddr_t) packet + size; (caddr_t) rte &lt; lim; rte++)</a>
<a name="ln318">    {</a>
<a name="ln319">      if (rte-&gt;metric == RIPNG_METRIC_NEXTHOP)</a>
<a name="ln320">	zlog_debug (&quot;  nexthop %s/%d&quot;, inet6_ntoa (rte-&gt;addr), rte-&gt;prefixlen);</a>
<a name="ln321">      else</a>
<a name="ln322">	zlog_debug (&quot;  %s/%d metric %d tag %d&quot;, </a>
<a name="ln323">		   inet6_ntoa (rte-&gt;addr), rte-&gt;prefixlen, </a>
<a name="ln324">		   rte-&gt;metric, ntohs (rte-&gt;tag));</a>
<a name="ln325">    }</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">/* RIPng next hop address RTE (Route Table Entry). */</a>
<a name="ln329">static void</a>
<a name="ln330">ripng_nexthop_rte (struct rte *rte,</a>
<a name="ln331">		   struct sockaddr_in6 *from,</a>
<a name="ln332">		   struct ripng_nexthop *nexthop)</a>
<a name="ln333">{</a>
<a name="ln334">  char buf[INET6_BUFSIZ];</a>
<a name="ln335"> </a>
<a name="ln336">  /* Logging before checking RTE. */</a>
<a name="ln337">  if (IS_RIPNG_DEBUG_RECV)</a>
<a name="ln338">    zlog_debug (&quot;RIPng nexthop RTE address %s tag %d prefixlen %d&quot;,</a>
<a name="ln339">	       inet6_ntoa (rte-&gt;addr), ntohs (rte-&gt;tag), rte-&gt;prefixlen);</a>
<a name="ln340"> </a>
<a name="ln341">  /* RFC2080 2.1.1 Next Hop: </a>
<a name="ln342">   The route tag and prefix length in the next hop RTE must be</a>
<a name="ln343">   set to zero on sending and ignored on receiption.  */</a>
<a name="ln344">  if (ntohs (rte-&gt;tag) != 0)</a>
<a name="ln345">    zlog_warn (&quot;RIPng nexthop RTE with non zero tag value %d from %s&quot;,</a>
<a name="ln346">	       ntohs (rte-&gt;tag), inet6_ntoa (from-&gt;sin6_addr));</a>
<a name="ln347"> </a>
<a name="ln348">  if (rte-&gt;prefixlen != 0)</a>
<a name="ln349">    zlog_warn (&quot;RIPng nexthop RTE with non zero prefixlen value %d from %s&quot;,</a>
<a name="ln350">	       rte-&gt;prefixlen, inet6_ntoa (from-&gt;sin6_addr));</a>
<a name="ln351"> </a>
<a name="ln352">  /* Specifying a value of 0:0:0:0:0:0:0:0 in the prefix field of a</a>
<a name="ln353">   next hop RTE indicates that the next hop address should be the</a>
<a name="ln354">   originator of the RIPng advertisement.  An address specified as a</a>
<a name="ln355">   next hop must be a link-local address.  */</a>
<a name="ln356">  if (IN6_IS_ADDR_UNSPECIFIED (&amp;rte-&gt;addr))</a>
<a name="ln357">    {</a>
<a name="ln358">      nexthop-&gt;flag = RIPNG_NEXTHOP_UNSPEC;</a>
<a name="ln359">      memset (&amp;nexthop-&gt;address, 0, sizeof (struct in6_addr));</a>
<a name="ln360">      return;</a>
<a name="ln361">    }</a>
<a name="ln362"> </a>
<a name="ln363">  if (IN6_IS_ADDR_LINKLOCAL (&amp;rte-&gt;addr))</a>
<a name="ln364">    {</a>
<a name="ln365">      nexthop-&gt;flag = RIPNG_NEXTHOP_ADDRESS;</a>
<a name="ln366">      IPV6_ADDR_COPY (&amp;nexthop-&gt;address, &amp;rte-&gt;addr);</a>
<a name="ln367">      return;</a>
<a name="ln368">    }</a>
<a name="ln369"> </a>
<a name="ln370">  /* The purpose of the next hop RTE is to eliminate packets being</a>
<a name="ln371">   routed through extra hops in the system.  It is particularly useful</a>
<a name="ln372">   when RIPng is not being run on all of the routers on a network.</a>
<a name="ln373">   Note that next hop RTE is &quot;advisory&quot;.  That is, if the provided</a>
<a name="ln374">   information is ignored, a possibly sub-optimal, but absolutely</a>
<a name="ln375">   valid, route may be taken.  If the received next hop address is not</a>
<a name="ln376">   a link-local address, it should be treated as 0:0:0:0:0:0:0:0.  */</a>
<a name="ln377">  zlog_warn (&quot;RIPng nexthop RTE with non link-local address %s from %s&quot;,</a>
<a name="ln378">	     inet6_ntoa (rte-&gt;addr),</a>
<a name="ln379">	     inet_ntop (AF_INET6, &amp;from-&gt;sin6_addr, buf, INET6_BUFSIZ));</a>
<a name="ln380"> </a>
<a name="ln381">  nexthop-&gt;flag = RIPNG_NEXTHOP_UNSPEC;</a>
<a name="ln382">  memset (&amp;nexthop-&gt;address, 0, sizeof (struct in6_addr));</a>
<a name="ln383"> </a>
<a name="ln384">  return;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">/* If ifp has same link-local address then return 1. */</a>
<a name="ln388">static int</a>
<a name="ln389">ripng_lladdr_check (struct interface *ifp, struct in6_addr *addr)</a>
<a name="ln390">{</a>
<a name="ln391">  struct listnode *node;</a>
<a name="ln392">  struct connected *connected;</a>
<a name="ln393">  struct prefix *p;</a>
<a name="ln394"> </a>
<a name="ln395">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, node, connected))</a>
<a name="ln396">    {</a>
<a name="ln397">      p = connected-&gt;address;</a>
<a name="ln398"> </a>
<a name="ln399">      if (p-&gt;family == AF_INET6 &amp;&amp;</a>
<a name="ln400">          IN6_IS_ADDR_LINKLOCAL (&amp;p-&gt;u.prefix6) &amp;&amp;</a>
<a name="ln401">          IN6_ARE_ADDR_EQUAL (&amp;p-&gt;u.prefix6, addr))</a>
<a name="ln402">        return 1;</a>
<a name="ln403">    }</a>
<a name="ln404">  return 0;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">/* RIPng route garbage collect timer. */</a>
<a name="ln408">static int</a>
<a name="ln409">ripng_garbage_collect (struct thread *t)</a>
<a name="ln410">{</a>
<a name="ln411">  struct ripng_info *rinfo;</a>
<a name="ln412">  struct route_node *rp;</a>
<a name="ln413"> </a>
<a name="ln414">  rinfo = THREAD_ARG (t);</a>
<a name="ln415">  rinfo-&gt;t_garbage_collect = NULL;</a>
<a name="ln416"> </a>
<a name="ln417">  /* Off timeout timer. */</a>
<a name="ln418">  RIPNG_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln419">  </a>
<a name="ln420">  /* Get route_node pointer. */</a>
<a name="ln421">  rp = rinfo-&gt;rp;</a>
<a name="ln422"> </a>
<a name="ln423">  /* Unlock route_node. */</a>
<a name="ln424">  listnode_delete (rp-&gt;info, rinfo);</a>
<a name="ln425">  if (list_isempty ((struct list *)rp-&gt;info))</a>
<a name="ln426">    {</a>
<a name="ln427">      list_free (rp-&gt;info);</a>
<a name="ln428">      rp-&gt;info = NULL;</a>
<a name="ln429">      route_unlock_node (rp);</a>
<a name="ln430">    }</a>
<a name="ln431"> </a>
<a name="ln432">  /* Free RIPng routing information. */</a>
<a name="ln433">  ripng_info_free (rinfo);</a>
<a name="ln434"> </a>
<a name="ln435">  return 0;</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">static void ripng_timeout_update (struct ripng_info *rinfo);</a>
<a name="ln439"> </a>
<a name="ln440">/* Add new route to the ECMP list.</a>
<a name="ln441"> * RETURN: the new entry added in the list, or NULL if it is not the first</a>
<a name="ln442"> *         entry and ECMP is not allowed.</a>
<a name="ln443"> */</a>
<a name="ln444">struct ripng_info *</a>
<a name="ln445">ripng_ecmp_add (struct ripng_info *rinfo_new)</a>
<a name="ln446">{</a>
<a name="ln447">  struct route_node *rp = rinfo_new-&gt;rp;</a>
<a name="ln448">  struct ripng_info *rinfo = NULL;</a>
<a name="ln449">  struct list *list = NULL;</a>
<a name="ln450"> </a>
<a name="ln451">  if (rp-&gt;info == NULL)</a>
<a name="ln452">    rp-&gt;info = list_new ();</a>
<a name="ln453">  list = (struct list *)rp-&gt;info;</a>
<a name="ln454"> </a>
<a name="ln455">  /* If ECMP is not allowed and some entry already exists in the list,</a>
<a name="ln456">   * do nothing. */</a>
<a name="ln457">  if (listcount (list) &amp;&amp; !ripng-&gt;ecmp)</a>
<a name="ln458">    return NULL;</a>
<a name="ln459"> </a>
<a name="ln460">  rinfo = ripng_info_new ();</a>
<a name="ln461">  memcpy (rinfo, rinfo_new, sizeof (struct ripng_info));</a>
<a name="ln462">  listnode_add (list, rinfo);</a>
<a name="ln463"> </a>
<a name="ln464">  if (ripng_route_rte (rinfo))</a>
<a name="ln465">    {</a>
<a name="ln466">      ripng_timeout_update (rinfo);</a>
<a name="ln467">      ripng_zebra_ipv6_add (rp);</a>
<a name="ln468">    }</a>
<a name="ln469"> </a>
<a name="ln470">  ripng_aggregate_increment (rp, rinfo);</a>
<a name="ln471"> </a>
<a name="ln472">  /* Set the route change flag on the first entry. */</a>
<a name="ln473">  rinfo = listgetdata (listhead (list));</a>
<a name="ln474">  SET_FLAG (rinfo-&gt;flags, RIPNG_RTF_CHANGED);</a>
<a name="ln475"> </a>
<a name="ln476">  /* Signal the output process to trigger an update. */</a>
<a name="ln477">  ripng_event (RIPNG_TRIGGERED_UPDATE, 0);</a>
<a name="ln478"> </a>
<a name="ln479">  return rinfo;</a>
<a name="ln480">}</a>
<a name="ln481"> </a>
<a name="ln482">/* Replace the ECMP list with the new route.</a>
<a name="ln483"> * RETURN: the new entry added in the list</a>
<a name="ln484"> */</a>
<a name="ln485">struct ripng_info *</a>
<a name="ln486">ripng_ecmp_replace (struct ripng_info *rinfo_new)</a>
<a name="ln487">{</a>
<a name="ln488">  struct route_node *rp = rinfo_new-&gt;rp;</a>
<a name="ln489">  struct list *list = (struct list *)rp-&gt;info;</a>
<a name="ln490">  struct ripng_info *rinfo = NULL, *tmp_rinfo = NULL;</a>
<a name="ln491">  struct listnode *node = NULL, *nextnode = NULL;</a>
<a name="ln492"> </a>
<a name="ln493">  if (list == NULL || listcount (list) == 0)</a>
<a name="ln494">    return ripng_ecmp_add (rinfo_new);</a>
<a name="ln495"> </a>
<a name="ln496">  /* Get the first entry */</a>
<a name="ln497">  rinfo = listgetdata (listhead (list));</a>
<a name="ln498"> </a>
<a name="ln499">  /* Learnt route replaced by a local one. Delete it from zebra. */</a>
<a name="ln500">  if (ripng_route_rte (rinfo) &amp;&amp; !ripng_route_rte (rinfo_new))</a>
<a name="ln501">    if (CHECK_FLAG (rinfo-&gt;flags, RIPNG_RTF_FIB))</a>
<a name="ln502">      ripng_zebra_ipv6_delete (rp);</a>
<a name="ln503"> </a>
<a name="ln504">  if (rinfo-&gt;metric != RIPNG_METRIC_INFINITY)</a>
<a name="ln505">    ripng_aggregate_decrement_list (rp, list);</a>
<a name="ln506"> </a>
<a name="ln507">  /* Re-use the first entry, and delete the others. */</a>
<a name="ln508">  for (ALL_LIST_ELEMENTS (list, node, nextnode, tmp_rinfo))</a>
<a name="ln509">    if (tmp_rinfo != rinfo)</a>
<a name="ln510">      {</a>
<a name="ln511">        RIPNG_TIMER_OFF (tmp_rinfo-&gt;t_timeout);</a>
<a name="ln512">        RIPNG_TIMER_OFF (tmp_rinfo-&gt;t_garbage_collect);</a>
<a name="ln513">        list_delete_node (list, node);</a>
<a name="ln514">        ripng_info_free (tmp_rinfo);</a>
<a name="ln515">      }</a>
<a name="ln516"> </a>
<a name="ln517">  RIPNG_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln518">  RIPNG_TIMER_OFF (rinfo-&gt;t_garbage_collect);</a>
<a name="ln519">  memcpy (rinfo, rinfo_new, sizeof (struct ripng_info));</a>
<a name="ln520"> </a>
<a name="ln521">  if (ripng_route_rte (rinfo))</a>
<a name="ln522">    {</a>
<a name="ln523">      ripng_timeout_update (rinfo);</a>
<a name="ln524">      /* The ADD message implies an update. */</a>
<a name="ln525">      ripng_zebra_ipv6_add (rp);</a>
<a name="ln526">    }</a>
<a name="ln527"> </a>
<a name="ln528">  ripng_aggregate_increment (rp, rinfo);</a>
<a name="ln529"> </a>
<a name="ln530">  /* Set the route change flag. */</a>
<a name="ln531">  SET_FLAG (rinfo-&gt;flags, RIPNG_RTF_CHANGED);</a>
<a name="ln532"> </a>
<a name="ln533">  /* Signal the output process to trigger an update. */</a>
<a name="ln534">  ripng_event (RIPNG_TRIGGERED_UPDATE, 0);</a>
<a name="ln535"> </a>
<a name="ln536">  return rinfo;</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">/* Delete one route from the ECMP list.</a>
<a name="ln540"> * RETURN:</a>
<a name="ln541"> *  null - the entry is freed, and other entries exist in the list</a>
<a name="ln542"> *  the entry - the entry is the last one in the list; its metric is set</a>
<a name="ln543"> *              to INFINITY, and the garbage collector is started for it</a>
<a name="ln544"> */</a>
<a name="ln545">struct ripng_info *</a>
<a name="ln546">ripng_ecmp_delete (struct ripng_info *rinfo)</a>
<a name="ln547">{</a>
<a name="ln548">  struct route_node *rp = rinfo-&gt;rp;</a>
<a name="ln549">  struct list *list = (struct list *)rp-&gt;info;</a>
<a name="ln550"> </a>
<a name="ln551">  RIPNG_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln552"> </a>
<a name="ln553">  if (rinfo-&gt;metric != RIPNG_METRIC_INFINITY)</a>
<a name="ln554">    ripng_aggregate_decrement (rp, rinfo);</a>
<a name="ln555"> </a>
<a name="ln556">  if (listcount (list) &gt; 1)</a>
<a name="ln557">    {</a>
<a name="ln558">      /* Some other ECMP entries still exist. Just delete this entry. */</a>
<a name="ln559">      RIPNG_TIMER_OFF (rinfo-&gt;t_garbage_collect);</a>
<a name="ln560">      listnode_delete (list, rinfo);</a>
<a name="ln561">      if (ripng_route_rte (rinfo) &amp;&amp; CHECK_FLAG (rinfo-&gt;flags, RIPNG_RTF_FIB))</a>
<a name="ln562">        /* The ADD message implies the update. */</a>
<a name="ln563">        ripng_zebra_ipv6_add (rp);</a>
<a name="ln564">      ripng_info_free (rinfo);</a>
<a name="ln565">      rinfo = NULL;</a>
<a name="ln566">    }</a>
<a name="ln567">  else</a>
<a name="ln568">    {</a>
<a name="ln569">      assert (rinfo == listgetdata (listhead (list)));</a>
<a name="ln570"> </a>
<a name="ln571">      /* This is the only entry left in the list. We must keep it in</a>
<a name="ln572">       * the list for garbage collection time, with INFINITY metric. */</a>
<a name="ln573"> </a>
<a name="ln574">      rinfo-&gt;metric = RIPNG_METRIC_INFINITY;</a>
<a name="ln575">      RIPNG_TIMER_ON (rinfo-&gt;t_garbage_collect,</a>
<a name="ln576">                      ripng_garbage_collect, ripng-&gt;garbage_time);</a>
<a name="ln577"> </a>
<a name="ln578">      if (ripng_route_rte (rinfo) &amp;&amp; CHECK_FLAG (rinfo-&gt;flags, RIPNG_RTF_FIB))</a>
<a name="ln579">        ripng_zebra_ipv6_delete (rp);</a>
<a name="ln580">    }</a>
<a name="ln581"> </a>
<a name="ln582">  /* Set the route change flag on the first entry. */</a>
<a name="ln583">  rinfo = listgetdata (listhead (list));</a>
<a name="ln584">  SET_FLAG (rinfo-&gt;flags, RIPNG_RTF_CHANGED);</a>
<a name="ln585"> </a>
<a name="ln586">  /* Signal the output process to trigger an update. */</a>
<a name="ln587">  ripng_event (RIPNG_TRIGGERED_UPDATE, 0);</a>
<a name="ln588"> </a>
<a name="ln589">  return rinfo;</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">/* Timeout RIPng routes. */</a>
<a name="ln593">static int</a>
<a name="ln594">ripng_timeout (struct thread *t)</a>
<a name="ln595">{</a>
<a name="ln596">  ripng_ecmp_delete ((struct ripng_info *)THREAD_ARG (t));</a>
<a name="ln597">  return 0;</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">static void</a>
<a name="ln601">ripng_timeout_update (struct ripng_info *rinfo)</a>
<a name="ln602">{</a>
<a name="ln603">  if (rinfo-&gt;metric != RIPNG_METRIC_INFINITY)</a>
<a name="ln604">    {</a>
<a name="ln605">      RIPNG_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln606">      RIPNG_TIMER_ON (rinfo-&gt;t_timeout, ripng_timeout, ripng-&gt;timeout_time);</a>
<a name="ln607">    }</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">static int</a>
<a name="ln611">ripng_filter (int ripng_distribute, struct prefix_ipv6 *p,</a>
<a name="ln612">              struct ripng_interface *ri)</a>
<a name="ln613">{</a>
<a name="ln614">  struct distribute *dist;</a>
<a name="ln615">  struct access_list *alist;</a>
<a name="ln616">  struct prefix_list *plist;</a>
<a name="ln617">  int distribute = ripng_distribute == RIPNG_FILTER_OUT ?</a>
<a name="ln618">      DISTRIBUTE_V6_OUT : DISTRIBUTE_V6_IN;</a>
<a name="ln619">  const char *inout = ripng_distribute == RIPNG_FILTER_OUT ? &quot;out&quot; : &quot;in&quot;;</a>
<a name="ln620"> </a>
<a name="ln621">  /* Input distribute-list filtering. */</a>
<a name="ln622">  if (ri-&gt;list[ripng_distribute])</a>
<a name="ln623">    {</a>
<a name="ln624">      if (access_list_apply (ri-&gt;list[ripng_distribute],</a>
<a name="ln625">			     (struct prefix *) p) == FILTER_DENY)</a>
<a name="ln626">	{</a>
<a name="ln627">	  if (IS_RIPNG_DEBUG_PACKET)</a>
<a name="ln628">	    zlog_debug (&quot;%s/%d filtered by distribute %s&quot;,</a>
<a name="ln629">                        inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen, inout);</a>
<a name="ln630">	  return -1;</a>
<a name="ln631">	}</a>
<a name="ln632">    }</a>
<a name="ln633">  if (ri-&gt;prefix[ripng_distribute])</a>
<a name="ln634">    {</a>
<a name="ln635">      if (prefix_list_apply (ri-&gt;prefix[ripng_distribute],</a>
<a name="ln636">			     (struct prefix *) p) == PREFIX_DENY)</a>
<a name="ln637">	{</a>
<a name="ln638">	  if (IS_RIPNG_DEBUG_PACKET)</a>
<a name="ln639">	    zlog_debug (&quot;%s/%d filtered by prefix-list %s&quot;,</a>
<a name="ln640">                        inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen, inout);</a>
<a name="ln641">	  return -1;</a>
<a name="ln642">	}</a>
<a name="ln643">    }</a>
<a name="ln644"> </a>
<a name="ln645">  /* All interface filter check. */</a>
<a name="ln646">  dist = distribute_lookup (NULL);</a>
<a name="ln647">  if (dist)</a>
<a name="ln648">    {</a>
<a name="ln649">      if (dist-&gt;list[distribute])</a>
<a name="ln650">	{</a>
<a name="ln651">	  alist = access_list_lookup (AFI_IP6, dist-&gt;list[distribute]);</a>
<a name="ln652"> </a>
<a name="ln653">	  if (alist)</a>
<a name="ln654">	    {</a>
<a name="ln655">	      if (access_list_apply (alist,</a>
<a name="ln656">				     (struct prefix *) p) == FILTER_DENY)</a>
<a name="ln657">		{</a>
<a name="ln658">		  if (IS_RIPNG_DEBUG_PACKET)</a>
<a name="ln659">		    zlog_debug (&quot;%s/%d filtered by distribute %s&quot;,</a>
<a name="ln660">                                inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen, inout);</a>
<a name="ln661">		  return -1;</a>
<a name="ln662">		}</a>
<a name="ln663">	    }</a>
<a name="ln664">	}</a>
<a name="ln665">      if (dist-&gt;prefix[distribute])</a>
<a name="ln666">	{</a>
<a name="ln667">	  plist = prefix_list_lookup (AFI_IP6, dist-&gt;prefix[distribute]);</a>
<a name="ln668"> </a>
<a name="ln669">	  if (plist)</a>
<a name="ln670">	    {</a>
<a name="ln671">	      if (prefix_list_apply (plist,</a>
<a name="ln672">				     (struct prefix *) p) == PREFIX_DENY)</a>
<a name="ln673">		{</a>
<a name="ln674">		  if (IS_RIPNG_DEBUG_PACKET)</a>
<a name="ln675">		    zlog_debug (&quot;%s/%d filtered by prefix-list %s&quot;,</a>
<a name="ln676">                                inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen, inout);</a>
<a name="ln677">		  return -1;</a>
<a name="ln678">		}</a>
<a name="ln679">	    }</a>
<a name="ln680">	}</a>
<a name="ln681">    }</a>
<a name="ln682">  return 0;</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">/* Process RIPng route according to RFC2080. */</a>
<a name="ln686">static void</a>
<a name="ln687">ripng_route_process (struct rte *rte, struct sockaddr_in6 *from,</a>
<a name="ln688">		     struct ripng_nexthop *ripng_nexthop,</a>
<a name="ln689">		     struct interface *ifp)</a>
<a name="ln690">{</a>
<a name="ln691">  int ret;</a>
<a name="ln692">  struct prefix_ipv6 p;</a>
<a name="ln693">  struct route_node *rp;</a>
<a name="ln694">  struct ripng_info *rinfo = NULL, newinfo;</a>
<a name="ln695">  struct ripng_interface *ri;</a>
<a name="ln696">  struct in6_addr *nexthop;</a>
<a name="ln697">  int same = 0;</a>
<a name="ln698">  struct list *list = NULL;</a>
<a name="ln699">  struct listnode *node = NULL;</a>
<a name="ln700"> </a>
<a name="ln701">  /* Make prefix structure. */</a>
<a name="ln702">  memset (&amp;p, 0, sizeof (struct prefix_ipv6));</a>
<a name="ln703">  p.family = AF_INET6;</a>
<a name="ln704">  /* p.prefix = rte-&gt;addr; */</a>
<a name="ln705">  IPV6_ADDR_COPY (&amp;p.prefix, &amp;rte-&gt;addr);</a>
<a name="ln706">  p.prefixlen = rte-&gt;prefixlen;</a>
<a name="ln707"> </a>
<a name="ln708">  /* Make sure mask is applied. */</a>
<a name="ln709">  /* XXX We have to check the prefix is valid or not before call</a>
<a name="ln710">     apply_mask_ipv6. */</a>
<a name="ln711">  apply_mask_ipv6 (&amp;p);</a>
<a name="ln712"> </a>
<a name="ln713">  /* Apply input filters. */</a>
<a name="ln714">  ri = ifp-&gt;info;</a>
<a name="ln715"> </a>
<a name="ln716">  ret = ripng_filter (RIPNG_FILTER_IN, &amp;p, ri);</a>
<a name="ln717">  if (ret &lt; 0)</a>
<a name="ln718">    return;</a>
<a name="ln719"> </a>
<a name="ln720">  memset (&amp;newinfo, 0, sizeof (newinfo));</a>
<a name="ln721">  newinfo.type = ZEBRA_ROUTE_RIPNG;</a>
<a name="ln722">  newinfo.sub_type = RIPNG_ROUTE_RTE;</a>
<a name="ln723">  if (ripng_nexthop-&gt;flag == RIPNG_NEXTHOP_ADDRESS)</a>
<a name="ln724">    newinfo.nexthop = ripng_nexthop-&gt;address;</a>
<a name="ln725">  else</a>
<a name="ln726">    newinfo.nexthop = from-&gt;sin6_addr;</a>
<a name="ln727">  newinfo.from = from-&gt;sin6_addr;</a>
<a name="ln728">  newinfo.ifindex = ifp-&gt;ifindex;</a>
<a name="ln729">  newinfo.metric = rte-&gt;metric;</a>
<a name="ln730">  newinfo.metric_out = rte-&gt;metric; /* XXX */</a>
<a name="ln731">  newinfo.tag = ntohs (rte-&gt;tag);   /* XXX */</a>
<a name="ln732"> </a>
<a name="ln733">  /* Modify entry. */</a>
<a name="ln734">  if (ri-&gt;routemap[RIPNG_FILTER_IN])</a>
<a name="ln735">    {</a>
<a name="ln736">      int ret;</a>
<a name="ln737"> </a>
<a name="ln738">      ret = route_map_apply (ri-&gt;routemap[RIPNG_FILTER_IN], </a>
<a name="ln739">			     (struct prefix *)&amp;p, RMAP_RIPNG, &amp;newinfo);</a>
<a name="ln740"> </a>
<a name="ln741">      if (ret == RMAP_DENYMATCH)</a>
<a name="ln742">	{</a>
<a name="ln743">	  if (IS_RIPNG_DEBUG_PACKET)</a>
<a name="ln744">	    zlog_debug (&quot;RIPng %s/%d is filtered by route-map in&quot;,</a>
<a name="ln745">		       inet6_ntoa (p.prefix), p.prefixlen);</a>
<a name="ln746">	  return;</a>
<a name="ln747">	}</a>
<a name="ln748"> </a>
<a name="ln749">      /* Get back the object */</a>
<a name="ln750">      if (ripng_nexthop-&gt;flag == RIPNG_NEXTHOP_ADDRESS) {</a>
<a name="ln751">	if (! IPV6_ADDR_SAME(&amp;newinfo.nexthop, &amp;ripng_nexthop-&gt;address) ) {</a>
<a name="ln752">	  /* the nexthop get changed by the routemap */</a>
<a name="ln753">	  if (IN6_IS_ADDR_LINKLOCAL(&amp;newinfo.nexthop))</a>
<a name="ln754">	    ripng_nexthop-&gt;address = newinfo.nexthop;</a>
<a name="ln755">	  else</a>
<a name="ln756">	    ripng_nexthop-&gt;address = in6addr_any;</a>
<a name="ln757">	}</a>
<a name="ln758">      } else {</a>
<a name="ln759">	if (! IPV6_ADDR_SAME(&amp;newinfo.nexthop, &amp;from-&gt;sin6_addr) ) {</a>
<a name="ln760">	  /* the nexthop get changed by the routemap */</a>
<a name="ln761">	  if (IN6_IS_ADDR_LINKLOCAL(&amp;newinfo.nexthop)) {</a>
<a name="ln762">	    ripng_nexthop-&gt;flag = RIPNG_NEXTHOP_ADDRESS;</a>
<a name="ln763">	    ripng_nexthop-&gt;address = newinfo.nexthop;</a>
<a name="ln764">	  }</a>
<a name="ln765">	}</a>
<a name="ln766">      }</a>
<a name="ln767">      rte-&gt;tag     = htons(newinfo.tag_out); /* XXX */</a>
<a name="ln768">      rte-&gt;metric  = newinfo.metric_out; /* XXX: the routemap uses the metric_out field */</a>
<a name="ln769">    }</a>
<a name="ln770"> </a>
<a name="ln771">  /* Once the entry has been validated, update the metric by</a>
<a name="ln772">   * adding the cost of the network on wich the message</a>
<a name="ln773">   * arrived. If the result is greater than infinity, use infinity</a>
<a name="ln774">   * (RFC2453 Sec. 3.9.2)</a>
<a name="ln775">   **/</a>
<a name="ln776"> </a>
<a name="ln777">  /* Zebra ripngd can handle offset-list in. */</a>
<a name="ln778">  ret = ripng_offset_list_apply_in (&amp;p, ifp, &amp;rte-&gt;metric);</a>
<a name="ln779"> </a>
<a name="ln780">  /* If offset-list does not modify the metric use interface's</a>
<a name="ln781">   * one. */</a>
<a name="ln782">  if (! ret)</a>
<a name="ln783">    rte-&gt;metric += ifp-&gt;metric ? ifp-&gt;metric : 1;</a>
<a name="ln784"> </a>
<a name="ln785">  if (rte-&gt;metric &gt; RIPNG_METRIC_INFINITY)</a>
<a name="ln786">    rte-&gt;metric = RIPNG_METRIC_INFINITY;</a>
<a name="ln787"> </a>
<a name="ln788">  /* Set nexthop pointer. */</a>
<a name="ln789">  if (ripng_nexthop-&gt;flag == RIPNG_NEXTHOP_ADDRESS)</a>
<a name="ln790">    nexthop = &amp;ripng_nexthop-&gt;address;</a>
<a name="ln791">  else</a>
<a name="ln792">    nexthop = &amp;from-&gt;sin6_addr;</a>
<a name="ln793"> </a>
<a name="ln794">  /* Lookup RIPng routing table. */</a>
<a name="ln795">  rp = route_node_get (ripng-&gt;table, (struct prefix *) &amp;p);</a>
<a name="ln796"> </a>
<a name="ln797">  newinfo.rp = rp;</a>
<a name="ln798">  newinfo.nexthop = *nexthop;</a>
<a name="ln799">  newinfo.metric = rte-&gt;metric;</a>
<a name="ln800">  newinfo.tag = ntohs (rte-&gt;tag);</a>
<a name="ln801"> </a>
<a name="ln802">  /* Check to see whether there is already RIPng route on the table. */</a>
<a name="ln803">  if ((list = rp-&gt;info) != NULL)</a>
<a name="ln804">    for (ALL_LIST_ELEMENTS_RO (list, node, rinfo))</a>
<a name="ln805">      {</a>
<a name="ln806">        /* Need to compare with redistributed entry or local entry */</a>
<a name="ln807">        if (!ripng_route_rte (rinfo))</a>
<a name="ln808">          break;</a>
<a name="ln809"> </a>
<a name="ln810">        if (IPV6_ADDR_SAME (&amp;rinfo-&gt;from, &amp;from-&gt;sin6_addr) &amp;&amp;</a>
<a name="ln811">            IPV6_ADDR_SAME (&amp;rinfo-&gt;nexthop, nexthop))</a>
<a name="ln812">          break;</a>
<a name="ln813"> </a>
<a name="ln814">        if (!listnextnode (node))</a>
<a name="ln815">          {</a>
<a name="ln816">            /* Not found in the list */</a>
<a name="ln817"> </a>
<a name="ln818">            if (rte-&gt;metric &gt; rinfo-&gt;metric)</a>
<a name="ln819">              {</a>
<a name="ln820">                /* New route has a greater metric. Discard it. */</a>
<a name="ln821">                route_unlock_node (rp);</a>
<a name="ln822">                return;</a>
<a name="ln823">              }</a>
<a name="ln824"> </a>
<a name="ln825">            if (rte-&gt;metric &lt; rinfo-&gt;metric)</a>
<a name="ln826">              /* New route has a smaller metric. Replace the ECMP list</a>
<a name="ln827">               * with the new one in below. */</a>
<a name="ln828">              break;</a>
<a name="ln829"> </a>
<a name="ln830">            /* Metrics are same. Keep &quot;rinfo&quot; null and the new route</a>
<a name="ln831">             * is added in the ECMP list in below. */</a>
<a name="ln832">          }</a>
<a name="ln833">      }</a>
<a name="ln834"> </a>
<a name="ln835">  if (rinfo)</a>
<a name="ln836">    {</a>
<a name="ln837">      /* Redistributed route check. */</a>
<a name="ln838">      if (rinfo-&gt;type != ZEBRA_ROUTE_RIPNG</a>
<a name="ln839">	  &amp;&amp; rinfo-&gt;metric != RIPNG_METRIC_INFINITY)</a>
<a name="ln840">        {</a>
<a name="ln841">          route_unlock_node (rp);</a>
<a name="ln842">          return;</a>
<a name="ln843">        }</a>
<a name="ln844"> </a>
<a name="ln845">      /* Local static route. */</a>
<a name="ln846">      if (rinfo-&gt;type == ZEBRA_ROUTE_RIPNG</a>
<a name="ln847">	  &amp;&amp; ((rinfo-&gt;sub_type == RIPNG_ROUTE_STATIC) ||</a>
<a name="ln848">	      (rinfo-&gt;sub_type == RIPNG_ROUTE_DEFAULT))</a>
<a name="ln849">	  &amp;&amp; rinfo-&gt;metric != RIPNG_METRIC_INFINITY)</a>
<a name="ln850">        {</a>
<a name="ln851">          route_unlock_node (rp);</a>
<a name="ln852">          return;</a>
<a name="ln853">        }</a>
<a name="ln854">    }</a>
<a name="ln855"> </a>
<a name="ln856">  if (!rinfo)</a>
<a name="ln857">    {</a>
<a name="ln858">      /* Now, check to see whether there is already an explicit route</a>
<a name="ln859">	 for the destination prefix.  If there is no such route, add</a>
<a name="ln860">	 this route to the routing table, unless the metric is</a>
<a name="ln861">	 infinity (there is no point in adding a route which</a>
<a name="ln862">	 unusable). */</a>
<a name="ln863">      if (rte-&gt;metric != RIPNG_METRIC_INFINITY)</a>
<a name="ln864">        ripng_ecmp_add (&amp;newinfo);</a>
<a name="ln865">    }</a>
<a name="ln866">  else</a>
<a name="ln867">    {</a>
<a name="ln868">      /* If there is an existing route, compare the next hop address</a>
<a name="ln869">	 to the address of the router from which the datagram came.</a>
<a name="ln870">	 If this datagram is from the same router as the existing</a>
<a name="ln871">	 route, reinitialize the timeout.  */</a>
<a name="ln872">      same = (IN6_ARE_ADDR_EQUAL (&amp;rinfo-&gt;from, &amp;from-&gt;sin6_addr) </a>
<a name="ln873">	      &amp;&amp; (rinfo-&gt;ifindex == ifp-&gt;ifindex));</a>
<a name="ln874"> </a>
<a name="ln875">      /* Next, compare the metrics.  If the datagram is from the same</a>
<a name="ln876">	 router as the existing route, and the new metric is different</a>
<a name="ln877">	 than the old one; or, if the new metric is lower than the old</a>
<a name="ln878">	 one; do the following actions: */</a>
<a name="ln879">      if ((same &amp;&amp; rinfo-&gt;metric != rte-&gt;metric) ||</a>
<a name="ln880">	  rte-&gt;metric &lt; rinfo-&gt;metric)</a>
<a name="ln881">	{</a>
<a name="ln882">          if (listcount (list) == 1)</a>
<a name="ln883">            {</a>
<a name="ln884">              if (newinfo.metric != RIPNG_METRIC_INFINITY)</a>
<a name="ln885">                ripng_ecmp_replace (&amp;newinfo);</a>
<a name="ln886">              else</a>
<a name="ln887">                ripng_ecmp_delete (rinfo);</a>
<a name="ln888">            }</a>
<a name="ln889">          else</a>
<a name="ln890">            {</a>
<a name="ln891">              if (newinfo.metric &lt; rinfo-&gt;metric)</a>
<a name="ln892">                ripng_ecmp_replace (&amp;newinfo);</a>
<a name="ln893">              else /* newinfo.metric &gt; rinfo-&gt;metric */</a>
<a name="ln894">                ripng_ecmp_delete (rinfo);</a>
<a name="ln895">            }</a>
<a name="ln896">	}</a>
<a name="ln897">      else /* same &amp; no change */</a>
<a name="ln898">        ripng_timeout_update (rinfo);</a>
<a name="ln899"> </a>
<a name="ln900">      /* Unlock tempolary lock of the route. */</a>
<a name="ln901">      route_unlock_node (rp);</a>
<a name="ln902">    }</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">/* Add redistributed route to RIPng table. */</a>
<a name="ln906">void</a>
<a name="ln907">ripng_redistribute_add (int type, int sub_type, struct prefix_ipv6 *p, </a>
<a name="ln908">			ifindex_t ifindex, struct in6_addr *nexthop,</a>
<a name="ln909">			route_tag_t tag)</a>
<a name="ln910">{</a>
<a name="ln911">  struct route_node *rp;</a>
<a name="ln912">  struct ripng_info *rinfo = NULL, newinfo;</a>
<a name="ln913">  struct list *list = NULL;</a>
<a name="ln914"> </a>
<a name="ln915">  /* Redistribute route  */</a>
<a name="ln916">  if (IN6_IS_ADDR_LINKLOCAL (&amp;p-&gt;prefix))</a>
<a name="ln917">    return;</a>
<a name="ln918">  if (IN6_IS_ADDR_LOOPBACK (&amp;p-&gt;prefix))</a>
<a name="ln919">    return;</a>
<a name="ln920"> </a>
<a name="ln921">  rp = route_node_get (ripng-&gt;table, (struct prefix *) p);</a>
<a name="ln922"> </a>
<a name="ln923">  memset (&amp;newinfo, 0, sizeof (struct ripng_info));</a>
<a name="ln924">  newinfo.type = type;</a>
<a name="ln925">  newinfo.sub_type = sub_type;</a>
<a name="ln926">  newinfo.ifindex = ifindex;</a>
<a name="ln927">  newinfo.metric = 1;</a>
<a name="ln928">  if (tag &lt;= UINT16_MAX) /* RIPng only supports 16 bit tags */</a>
<a name="ln929">    newinfo.tag = tag;</a>
<a name="ln930">  newinfo.rp = rp;</a>
<a name="ln931">  if (nexthop &amp;&amp; IN6_IS_ADDR_LINKLOCAL(nexthop))</a>
<a name="ln932">    newinfo.nexthop = *nexthop;</a>
<a name="ln933"> </a>
<a name="ln934">  if ((list = rp-&gt;info) != NULL &amp;&amp; listcount (list) != 0)</a>
<a name="ln935">    {</a>
<a name="ln936">      rinfo = listgetdata (listhead (list));</a>
<a name="ln937"> </a>
<a name="ln938">      if (rinfo-&gt;type == ZEBRA_ROUTE_CONNECT</a>
<a name="ln939">          &amp;&amp; rinfo-&gt;sub_type == RIPNG_ROUTE_INTERFACE</a>
<a name="ln940">	  &amp;&amp; rinfo-&gt;metric != RIPNG_METRIC_INFINITY) {</a>
<a name="ln941">        route_unlock_node (rp);</a>
<a name="ln942">	   return;</a>
<a name="ln943">      }</a>
<a name="ln944"> </a>
<a name="ln945">      /* Manually configured RIPng route check.</a>
<a name="ln946">       * They have the precedence on all the other entries.</a>
<a name="ln947">       **/</a>
<a name="ln948">      if (rinfo-&gt;type == ZEBRA_ROUTE_RIPNG</a>
<a name="ln949">          &amp;&amp; ((rinfo-&gt;sub_type == RIPNG_ROUTE_STATIC) ||</a>
<a name="ln950">              (rinfo-&gt;sub_type == RIPNG_ROUTE_DEFAULT)) ) {</a>
<a name="ln951">        if (type != ZEBRA_ROUTE_RIPNG || ((sub_type != RIPNG_ROUTE_STATIC) &amp;&amp;</a>
<a name="ln952">                                          (sub_type != RIPNG_ROUTE_DEFAULT))) {</a>
<a name="ln953">	  route_unlock_node (rp);</a>
<a name="ln954">	  return;</a>
<a name="ln955">	}</a>
<a name="ln956">      }</a>
<a name="ln957"> </a>
<a name="ln958">      rinfo = ripng_ecmp_replace (&amp;newinfo);</a>
<a name="ln959">      route_unlock_node (rp);</a>
<a name="ln960">    }</a>
<a name="ln961">  else</a>
<a name="ln962">    rinfo = ripng_ecmp_add (&amp;newinfo);</a>
<a name="ln963"> </a>
<a name="ln964">  if (IS_RIPNG_DEBUG_EVENT) {</a>
<a name="ln965">    if (!nexthop)</a>
<a name="ln966">      zlog_debug (&quot;Redistribute new prefix %s/%d on the interface %s&quot;,</a>
<a name="ln967">                 inet6_ntoa(p-&gt;prefix), p-&gt;prefixlen,</a>
<a name="ln968">                 ifindex2ifname(ifindex));</a>
<a name="ln969">    else</a>
<a name="ln970">      zlog_debug (&quot;Redistribute new prefix %s/%d with nexthop %s on the interface %s&quot;,</a>
<a name="ln971">                 inet6_ntoa(p-&gt;prefix), p-&gt;prefixlen, inet6_ntoa(*nexthop),</a>
<a name="ln972">                 ifindex2ifname(ifindex));</a>
<a name="ln973">  }</a>
<a name="ln974"> </a>
<a name="ln975">  ripng_event (RIPNG_TRIGGERED_UPDATE, 0);</a>
<a name="ln976">}</a>
<a name="ln977"> </a>
<a name="ln978">/* Delete redistributed route to RIPng table. */</a>
<a name="ln979">void</a>
<a name="ln980">ripng_redistribute_delete (int type, int sub_type, struct prefix_ipv6 *p, </a>
<a name="ln981">			   ifindex_t ifindex)</a>
<a name="ln982">{</a>
<a name="ln983">  struct route_node *rp;</a>
<a name="ln984">  struct ripng_info *rinfo;</a>
<a name="ln985"> </a>
<a name="ln986">  if (IN6_IS_ADDR_LINKLOCAL (&amp;p-&gt;prefix))</a>
<a name="ln987">    return;</a>
<a name="ln988">  if (IN6_IS_ADDR_LOOPBACK (&amp;p-&gt;prefix))</a>
<a name="ln989">    return;</a>
<a name="ln990"> </a>
<a name="ln991">  rp = route_node_lookup (ripng-&gt;table, (struct prefix *) p);</a>
<a name="ln992"> </a>
<a name="ln993">  if (rp)</a>
<a name="ln994">    {</a>
<a name="ln995">      struct list *list = rp-&gt;info;</a>
<a name="ln996"> </a>
<a name="ln997">      if (list != NULL &amp;&amp; listcount (list) != 0)</a>
<a name="ln998">        {</a>
<a name="ln999">          rinfo = listgetdata (listhead (list));</a>
<a name="ln1000">          if (rinfo != NULL</a>
<a name="ln1001">              &amp;&amp; rinfo-&gt;type == type</a>
<a name="ln1002">              &amp;&amp; rinfo-&gt;sub_type == sub_type</a>
<a name="ln1003">              &amp;&amp; rinfo-&gt;ifindex == ifindex)</a>
<a name="ln1004">            {</a>
<a name="ln1005">              /* Perform poisoned reverse. */</a>
<a name="ln1006">              rinfo-&gt;metric = RIPNG_METRIC_INFINITY;</a>
<a name="ln1007">              RIPNG_TIMER_ON (rinfo-&gt;t_garbage_collect,</a>
<a name="ln1008">                              ripng_garbage_collect, ripng-&gt;garbage_time);</a>
<a name="ln1009">              RIPNG_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln1010"> </a>
<a name="ln1011">              /* Aggregate count decrement. */</a>
<a name="ln1012">              ripng_aggregate_decrement (rp, rinfo);</a>
<a name="ln1013"> </a>
<a name="ln1014">              rinfo-&gt;flags |= RIPNG_RTF_CHANGED;</a>
<a name="ln1015"> </a>
<a name="ln1016">              if (IS_RIPNG_DEBUG_EVENT)</a>
<a name="ln1017">                zlog_debug (&quot;Poisone %s/%d on the interface %s with an &quot;</a>
<a name="ln1018">                            &quot;infinity metric [delete]&quot;,</a>
<a name="ln1019">                            inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen,</a>
<a name="ln1020">                            ifindex2ifname (ifindex));</a>
<a name="ln1021"> </a>
<a name="ln1022">              ripng_event (RIPNG_TRIGGERED_UPDATE, 0);</a>
<a name="ln1023">            }</a>
<a name="ln1024">        }</a>
<a name="ln1025">      route_unlock_node (rp);</a>
<a name="ln1026">    }</a>
<a name="ln1027">}</a>
<a name="ln1028"> </a>
<a name="ln1029">/* Withdraw redistributed route. */</a>
<a name="ln1030">void</a>
<a name="ln1031">ripng_redistribute_withdraw (int type)</a>
<a name="ln1032">{</a>
<a name="ln1033">  struct route_node *rp;</a>
<a name="ln1034">  struct ripng_info *rinfo = NULL;</a>
<a name="ln1035">  struct list *list = NULL;</a>
<a name="ln1036"> </a>
<a name="ln1037">  if (!ripng)</a>
<a name="ln1038">    return;</a>
<a name="ln1039">  </a>
<a name="ln1040">  for (rp = route_top (ripng-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln1041">    if ((list = rp-&gt;info) != NULL)</a>
<a name="ln1042">      {</a>
<a name="ln1043">	rinfo = listgetdata (listhead (list));</a>
<a name="ln1044">	if ((rinfo-&gt;type == type)</a>
<a name="ln1045">	    &amp;&amp; (rinfo-&gt;sub_type != RIPNG_ROUTE_INTERFACE))</a>
<a name="ln1046">	  {</a>
<a name="ln1047">	    /* Perform poisoned reverse. */</a>
<a name="ln1048">	    rinfo-&gt;metric = RIPNG_METRIC_INFINITY;</a>
<a name="ln1049">	    RIPNG_TIMER_ON (rinfo-&gt;t_garbage_collect, </a>
<a name="ln1050">			  ripng_garbage_collect, ripng-&gt;garbage_time);</a>
<a name="ln1051">	    RIPNG_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln1052"> </a>
<a name="ln1053">	    /* Aggregate count decrement. */</a>
<a name="ln1054">	    ripng_aggregate_decrement (rp, rinfo);</a>
<a name="ln1055"> </a>
<a name="ln1056">	    rinfo-&gt;flags |= RIPNG_RTF_CHANGED;</a>
<a name="ln1057"> </a>
<a name="ln1058">	    if (IS_RIPNG_DEBUG_EVENT) {</a>
<a name="ln1059">	      struct prefix_ipv6 *p = (struct prefix_ipv6 *) &amp;rp-&gt;p;</a>
<a name="ln1060"> </a>
<a name="ln1061">	      zlog_debug (&quot;Poisone %s/%d on the interface %s [withdraw]&quot;,</a>
<a name="ln1062">	                 inet6_ntoa(p-&gt;prefix), p-&gt;prefixlen,</a>
<a name="ln1063">	                 ifindex2ifname(rinfo-&gt;ifindex));</a>
<a name="ln1064">	    }</a>
<a name="ln1065"> </a>
<a name="ln1066">	    ripng_event (RIPNG_TRIGGERED_UPDATE, 0);</a>
<a name="ln1067">	  }</a>
<a name="ln1068">      }</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">/* RIP routing information. */</a>
<a name="ln1072">static void</a>
<a name="ln1073">ripng_response_process (struct ripng_packet *packet, int size, </a>
<a name="ln1074">			struct sockaddr_in6 *from, struct interface *ifp,</a>
<a name="ln1075">			int hoplimit)</a>
<a name="ln1076">{</a>
<a name="ln1077">  caddr_t lim;</a>
<a name="ln1078">  struct rte *rte;</a>
<a name="ln1079">  struct ripng_nexthop nexthop;</a>
<a name="ln1080"> </a>
<a name="ln1081">  /* RFC2080 2.4.2  Response Messages:</a>
<a name="ln1082">   The Response must be ignored if it is not from the RIPng port.  */</a>
<a name="ln1083">  if (ntohs (from-&gt;sin6_port) != RIPNG_PORT_DEFAULT)</a>
<a name="ln1084">    {</a>
<a name="ln1085">      zlog_warn (&quot;RIPng packet comes from non RIPng port %d from %s&quot;,</a>
<a name="ln1086">		 ntohs (from-&gt;sin6_port), inet6_ntoa (from-&gt;sin6_addr));</a>
<a name="ln1087">      ripng_peer_bad_packet (from);</a>
<a name="ln1088">      return;</a>
<a name="ln1089">    }</a>
<a name="ln1090"> </a>
<a name="ln1091">  /* The datagram's IPv6 source address should be checked to see</a>
<a name="ln1092">   whether the datagram is from a valid neighbor; the source of the</a>
<a name="ln1093">   datagram must be a link-local address.  */</a>
<a name="ln1094">  if (! IN6_IS_ADDR_LINKLOCAL(&amp;from-&gt;sin6_addr))</a>
<a name="ln1095">   {</a>
<a name="ln1096">      zlog_warn (&quot;RIPng packet comes from non link local address %s&quot;,</a>
<a name="ln1097">		 inet6_ntoa (from-&gt;sin6_addr));</a>
<a name="ln1098">      ripng_peer_bad_packet (from);</a>
<a name="ln1099">      return;</a>
<a name="ln1100">    }</a>
<a name="ln1101"> </a>
<a name="ln1102">  /* It is also worth checking to see whether the response is from one</a>
<a name="ln1103">   of the router's own addresses.  Interfaces on broadcast networks</a>
<a name="ln1104">   may receive copies of their own multicasts immediately.  If a</a>
<a name="ln1105">   router processes its own output as new input, confusion is likely,</a>
<a name="ln1106">   and such datagrams must be ignored. */</a>
<a name="ln1107">  if (ripng_lladdr_check (ifp, &amp;from-&gt;sin6_addr))</a>
<a name="ln1108">    {</a>
<a name="ln1109">      zlog_warn (&quot;RIPng packet comes from my own link local address %s&quot;,</a>
<a name="ln1110">		 inet6_ntoa (from-&gt;sin6_addr));</a>
<a name="ln1111">      ripng_peer_bad_packet (from);</a>
<a name="ln1112">      return;</a>
<a name="ln1113">    }</a>
<a name="ln1114"> </a>
<a name="ln1115">  /* As an additional check, periodic advertisements must have their</a>
<a name="ln1116">   hop counts set to 255, and inbound, multicast packets sent from the</a>
<a name="ln1117">   RIPng port (i.e. periodic advertisement or triggered update</a>
<a name="ln1118">   packets) must be examined to ensure that the hop count is 255. */</a>
<a name="ln1119">  if (hoplimit &gt;= 0 &amp;&amp; hoplimit != 255)</a>
<a name="ln1120">    {</a>
<a name="ln1121">      zlog_warn (&quot;RIPng packet comes with non 255 hop count %d from %s&quot;,</a>
<a name="ln1122">		 hoplimit, inet6_ntoa (from-&gt;sin6_addr));</a>
<a name="ln1123">      ripng_peer_bad_packet (from);</a>
<a name="ln1124">      return;</a>
<a name="ln1125">    }</a>
<a name="ln1126"> </a>
<a name="ln1127">  /* Update RIPng peer. */</a>
<a name="ln1128">  ripng_peer_update (from, packet-&gt;version);</a>
<a name="ln1129">  </a>
<a name="ln1130">  /* Reset nexthop. */</a>
<a name="ln1131">  memset (&amp;nexthop, 0, sizeof (struct ripng_nexthop));</a>
<a name="ln1132">  nexthop.flag = RIPNG_NEXTHOP_UNSPEC;</a>
<a name="ln1133"> </a>
<a name="ln1134">  /* Set RTE pointer. */</a>
<a name="ln1135">  rte = packet-&gt;rte;</a>
<a name="ln1136"> </a>
<a name="ln1137">  for (lim = ((caddr_t) packet) + size; (caddr_t) rte &lt; lim; rte++) </a>
<a name="ln1138">    {</a>
<a name="ln1139">      /* First of all, we have to check this RTE is next hop RTE or</a>
<a name="ln1140">         not.  Next hop RTE is completely different with normal RTE so</a>
<a name="ln1141">         we need special treatment. */</a>
<a name="ln1142">      if (rte-&gt;metric == RIPNG_METRIC_NEXTHOP)</a>
<a name="ln1143">	{</a>
<a name="ln1144">	  ripng_nexthop_rte (rte, from, &amp;nexthop);</a>
<a name="ln1145">	  continue;</a>
<a name="ln1146">	}</a>
<a name="ln1147"> </a>
<a name="ln1148">      /* RTE information validation. */</a>
<a name="ln1149"> </a>
<a name="ln1150">      /* - is the destination prefix valid (e.g., not a multicast</a>
<a name="ln1151">         prefix and not a link-local address) A link-local address</a>
<a name="ln1152">         should never be present in an RTE. */</a>
<a name="ln1153">      if (IN6_IS_ADDR_MULTICAST (&amp;rte-&gt;addr))</a>
<a name="ln1154">	{</a>
<a name="ln1155">	  zlog_warn (&quot;Destination prefix is a multicast address %s/%d [%d]&quot;,</a>
<a name="ln1156">		     inet6_ntoa (rte-&gt;addr), rte-&gt;prefixlen, rte-&gt;metric);</a>
<a name="ln1157">	  ripng_peer_bad_route (from);</a>
<a name="ln1158">	  continue;</a>
<a name="ln1159">	}</a>
<a name="ln1160">      if (IN6_IS_ADDR_LINKLOCAL (&amp;rte-&gt;addr))</a>
<a name="ln1161">	{</a>
<a name="ln1162">	  zlog_warn (&quot;Destination prefix is a link-local address %s/%d [%d]&quot;,</a>
<a name="ln1163">		     inet6_ntoa (rte-&gt;addr), rte-&gt;prefixlen, rte-&gt;metric);</a>
<a name="ln1164">	  ripng_peer_bad_route (from);</a>
<a name="ln1165">	  continue;</a>
<a name="ln1166">	}</a>
<a name="ln1167">      if (IN6_IS_ADDR_LOOPBACK (&amp;rte-&gt;addr))</a>
<a name="ln1168">	{</a>
<a name="ln1169">	  zlog_warn (&quot;Destination prefix is a loopback address %s/%d [%d]&quot;,</a>
<a name="ln1170">		     inet6_ntoa (rte-&gt;addr), rte-&gt;prefixlen, rte-&gt;metric);</a>
<a name="ln1171">	  ripng_peer_bad_route (from);</a>
<a name="ln1172">	  continue;</a>
<a name="ln1173">	}</a>
<a name="ln1174"> </a>
<a name="ln1175">      /* - is the prefix length valid (i.e., between 0 and 128,</a>
<a name="ln1176">         inclusive) */</a>
<a name="ln1177">      if (rte-&gt;prefixlen &gt; 128)</a>
<a name="ln1178">	{</a>
<a name="ln1179">	  zlog_warn (&quot;Invalid prefix length %s/%d from %s%%%s&quot;,</a>
<a name="ln1180">		     inet6_ntoa (rte-&gt;addr), rte-&gt;prefixlen,</a>
<a name="ln1181">		     inet6_ntoa (from-&gt;sin6_addr), ifp-&gt;name);</a>
<a name="ln1182">	  ripng_peer_bad_route (from);</a>
<a name="ln1183">	  continue;</a>
<a name="ln1184">	}</a>
<a name="ln1185"> </a>
<a name="ln1186">      /* - is the metric valid (i.e., between 1 and 16, inclusive) */</a>
<a name="ln1187">      if (! (rte-&gt;metric &gt;= 1 &amp;&amp; rte-&gt;metric &lt;= 16))</a>
<a name="ln1188">	{</a>
<a name="ln1189">	  zlog_warn (&quot;Invalid metric %d from %s%%%s&quot;, rte-&gt;metric,</a>
<a name="ln1190">		     inet6_ntoa (from-&gt;sin6_addr), ifp-&gt;name);</a>
<a name="ln1191">	  ripng_peer_bad_route (from);</a>
<a name="ln1192">	  continue;</a>
<a name="ln1193">	}</a>
<a name="ln1194"> </a>
<a name="ln1195">      /* Vincent: XXX Should we compute the direclty reachable nexthop</a>
<a name="ln1196">       * for our RIPng network ?</a>
<a name="ln1197">       **/</a>
<a name="ln1198"> </a>
<a name="ln1199">      /* Routing table updates. */</a>
<a name="ln1200">      ripng_route_process (rte, from, &amp;nexthop, ifp);</a>
<a name="ln1201">    }</a>
<a name="ln1202">}</a>
<a name="ln1203"> </a>
<a name="ln1204">/* Response to request message. */</a>
<a name="ln1205">static void</a>
<a name="ln1206">ripng_request_process (struct ripng_packet *packet,int size, </a>
<a name="ln1207">		       struct sockaddr_in6 *from, struct interface *ifp)</a>
<a name="ln1208">{</a>
<a name="ln1209">  caddr_t lim;</a>
<a name="ln1210">  struct rte *rte;</a>
<a name="ln1211">  struct prefix_ipv6 p;</a>
<a name="ln1212">  struct route_node *rp;</a>
<a name="ln1213">  struct ripng_info *rinfo;</a>
<a name="ln1214">  struct ripng_interface *ri;</a>
<a name="ln1215"> </a>
<a name="ln1216">  /* Does not reponse to the requests on the loopback interfaces */</a>
<a name="ln1217">  if (if_is_loopback (ifp))</a>
<a name="ln1218">    return;</a>
<a name="ln1219"> </a>
<a name="ln1220">  /* Check RIPng process is enabled on this interface. */</a>
<a name="ln1221">  ri = ifp-&gt;info;</a>
<a name="ln1222">  if (! ri-&gt;running)</a>
<a name="ln1223">    return;</a>
<a name="ln1224"> </a>
<a name="ln1225">  /* When passive interface is specified, suppress responses */</a>
<a name="ln1226">  if (ri-&gt;passive)</a>
<a name="ln1227">    return;</a>
<a name="ln1228"> </a>
<a name="ln1229">  /* RIPng peer update. */</a>
<a name="ln1230">  ripng_peer_update (from, packet-&gt;version);</a>
<a name="ln1231"> </a>
<a name="ln1232">  lim = ((caddr_t) packet) + size;</a>
<a name="ln1233">  rte = packet-&gt;rte;</a>
<a name="ln1234"> </a>
<a name="ln1235">  /* The Request is processed entry by entry.  If there are no</a>
<a name="ln1236">     entries, no response is given. */</a>
<a name="ln1237">  if (lim == (caddr_t) rte)</a>
<a name="ln1238">    return;</a>
<a name="ln1239"> </a>
<a name="ln1240">  /* There is one special case.  If there is exactly one entry in the</a>
<a name="ln1241">     request, and it has a destination prefix of zero, a prefix length</a>
<a name="ln1242">     of zero, and a metric of infinity (i.e., 16), then this is a</a>
<a name="ln1243">     request to send the entire routing table.  In that case, a call</a>
<a name="ln1244">     is made to the output process to send the routing table to the</a>
<a name="ln1245">     requesting address/port. */</a>
<a name="ln1246">  if (lim == ((caddr_t) (rte + 1)) &amp;&amp;</a>
<a name="ln1247">      IN6_IS_ADDR_UNSPECIFIED (&amp;rte-&gt;addr) &amp;&amp;</a>
<a name="ln1248">      rte-&gt;prefixlen == 0 &amp;&amp;</a>
<a name="ln1249">      rte-&gt;metric == RIPNG_METRIC_INFINITY)</a>
<a name="ln1250">    {	</a>
<a name="ln1251">      /* All route with split horizon */</a>
<a name="ln1252">      ripng_output_process (ifp, from, ripng_all_route);</a>
<a name="ln1253">    }</a>
<a name="ln1254">  else</a>
<a name="ln1255">    {</a>
<a name="ln1256">      /* Except for this special case, processing is quite simple.</a>
<a name="ln1257">	 Examine the list of RTEs in the Request one by one.  For each</a>
<a name="ln1258">	 entry, look up the destination in the router's routing</a>
<a name="ln1259">	 database and, if there is a route, put that route's metric in</a>
<a name="ln1260">	 the metric field of the RTE.  If there is no explicit route</a>
<a name="ln1261">	 to the specified destination, put infinity in the metric</a>
<a name="ln1262">	 field.  Once all the entries have been filled in, change the</a>
<a name="ln1263">	 command from Request to Response and send the datagram back</a>
<a name="ln1264">	 to the requestor. */</a>
<a name="ln1265">      memset (&amp;p, 0, sizeof (struct prefix_ipv6));</a>
<a name="ln1266">      p.family = AF_INET6;</a>
<a name="ln1267"> </a>
<a name="ln1268">      for (; ((caddr_t) rte) &lt; lim; rte++)</a>
<a name="ln1269">	{</a>
<a name="ln1270">	  p.prefix = rte-&gt;addr;</a>
<a name="ln1271">	  p.prefixlen = rte-&gt;prefixlen;</a>
<a name="ln1272">	  apply_mask_ipv6 (&amp;p);</a>
<a name="ln1273">	  </a>
<a name="ln1274">	  rp = route_node_lookup (ripng-&gt;table, (struct prefix *) &amp;p);</a>
<a name="ln1275"> </a>
<a name="ln1276">	  if (rp)</a>
<a name="ln1277">	    {</a>
<a name="ln1278">	      rinfo = listgetdata (listhead ((struct list *)rp-&gt;info));</a>
<a name="ln1279">	      rte-&gt;metric = rinfo-&gt;metric;</a>
<a name="ln1280">	      route_unlock_node (rp);</a>
<a name="ln1281">	    }</a>
<a name="ln1282">	  else</a>
<a name="ln1283">	    rte-&gt;metric = RIPNG_METRIC_INFINITY;</a>
<a name="ln1284">	}</a>
<a name="ln1285">      packet-&gt;command = RIPNG_RESPONSE;</a>
<a name="ln1286"> </a>
<a name="ln1287">      ripng_send_packet ((caddr_t) packet, size, from, ifp);</a>
<a name="ln1288">    }</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291">/* First entry point of reading RIPng packet. */</a>
<a name="ln1292">static int</a>
<a name="ln1293">ripng_read (struct thread *thread)</a>
<a name="ln1294">{</a>
<a name="ln1295">  int len;</a>
<a name="ln1296">  int sock;</a>
<a name="ln1297">  struct sockaddr_in6 from;</a>
<a name="ln1298">  struct ripng_packet *packet;</a>
<a name="ln1299">  ifindex_t ifindex = 0;</a>
<a name="ln1300">  struct interface *ifp;</a>
<a name="ln1301">  int hoplimit = -1;</a>
<a name="ln1302"> </a>
<a name="ln1303">  /* Check ripng is active and alive. */</a>
<a name="ln1304">  assert (ripng != NULL);</a>
<a name="ln1305">  assert (ripng-&gt;sock &gt;= 0);</a>
<a name="ln1306"> </a>
<a name="ln1307">  /* Fetch thread data and set read pointer to empty for event</a>
<a name="ln1308">     managing.  `sock' sould be same as ripng-&gt;sock. */</a>
<a name="ln1309">  sock = THREAD_FD (thread);</a>
<a name="ln1310">  ripng-&gt;t_read = NULL;</a>
<a name="ln1311"> </a>
<a name="ln1312">  /* Add myself to the next event. */</a>
<a name="ln1313">  ripng_event (RIPNG_READ, sock);</a>
<a name="ln1314"> </a>
<a name="ln1315">  /* Read RIPng packet. */</a>
<a name="ln1316">  len = ripng_recv_packet (sock, STREAM_DATA (ripng-&gt;ibuf), </a>
<a name="ln1317">			   STREAM_SIZE (ripng-&gt;ibuf), &amp;from, &amp;ifindex,</a>
<a name="ln1318">			   &amp;hoplimit);</a>
<a name="ln1319">  if (len &lt; 0) </a>
<a name="ln1320">    {</a>
<a name="ln1321">      zlog_warn (&quot;RIPng recvfrom failed: %s.&quot;, safe_strerror (errno));</a>
<a name="ln1322">      return len;</a>
<a name="ln1323">    }</a>
<a name="ln1324"> </a>
<a name="ln1325">  /* Check RTE boundary.  RTE size (Packet length - RIPng header size</a>
<a name="ln1326">     (4)) must be multiple size of one RTE size (20). */</a>
<a name="ln1327">  if (((len - 4) % 20) != 0)</a>
<a name="ln1328">    {</a>
<a name="ln1329">      zlog_warn (&quot;RIPng invalid packet size %d from %s&quot;, len,</a>
<a name="ln1330">		 inet6_ntoa (from.sin6_addr));</a>
<a name="ln1331">      ripng_peer_bad_packet (&amp;from);</a>
<a name="ln1332">      return 0;</a>
<a name="ln1333">    }</a>
<a name="ln1334"> </a>
<a name="ln1335">  packet = (struct ripng_packet *) STREAM_DATA (ripng-&gt;ibuf);</a>
<a name="ln1336">  ifp = if_lookup_by_index (ifindex);</a>
<a name="ln1337"> </a>
<a name="ln1338">  /* RIPng packet received. */</a>
<a name="ln1339">  if (IS_RIPNG_DEBUG_EVENT)</a>
<a name="ln1340">    zlog_debug (&quot;RIPng packet received from %s port %d on %s&quot;,</a>
<a name="ln1341">	       inet6_ntoa (from.sin6_addr), ntohs (from.sin6_port), </a>
<a name="ln1342">	       ifp ? ifp-&gt;name : &quot;unknown&quot;);</a>
<a name="ln1343"> </a>
<a name="ln1344">  /* Logging before packet checking. */</a>
<a name="ln1345">  if (IS_RIPNG_DEBUG_RECV)</a>
<a name="ln1346">    ripng_packet_dump (packet, len, &quot;RECV&quot;);</a>
<a name="ln1347"> </a>
<a name="ln1348">  /* Packet comes from unknown interface. */</a>
<a name="ln1349">  if (ifp == NULL)</a>
<a name="ln1350">    {</a>
<a name="ln1351">      zlog_warn (&quot;RIPng packet comes from unknown interface %d&quot;, ifindex);</a>
<a name="ln1352">      return 0;</a>
<a name="ln1353">    }</a>
<a name="ln1354"> </a>
<a name="ln1355">  /* Packet version mismatch checking. */</a>
<a name="ln1356">  if (packet-&gt;version != ripng-&gt;version) </a>
<a name="ln1357">    {</a>
<a name="ln1358">      zlog_warn (&quot;RIPng packet version %d doesn't fit to my version %d&quot;, </a>
<a name="ln1359">		 packet-&gt;version, ripng-&gt;version);</a>
<a name="ln1360">      ripng_peer_bad_packet (&amp;from);</a>
<a name="ln1361">      return 0;</a>
<a name="ln1362">    }</a>
<a name="ln1363"> </a>
<a name="ln1364">  /* Process RIPng packet. */</a>
<a name="ln1365">  switch (packet-&gt;command)</a>
<a name="ln1366">    {</a>
<a name="ln1367">    case RIPNG_REQUEST:</a>
<a name="ln1368">      ripng_request_process (packet, len, &amp;from, ifp);</a>
<a name="ln1369">      break;</a>
<a name="ln1370">    case RIPNG_RESPONSE:</a>
<a name="ln1371">      ripng_response_process (packet, len, &amp;from, ifp, hoplimit);</a>
<a name="ln1372">      break;</a>
<a name="ln1373">    default:</a>
<a name="ln1374">      zlog_warn (&quot;Invalid RIPng command %d&quot;, packet-&gt;command);</a>
<a name="ln1375">      ripng_peer_bad_packet (&amp;from);</a>
<a name="ln1376">      break;</a>
<a name="ln1377">    }</a>
<a name="ln1378">  return 0;</a>
<a name="ln1379">}</a>
<a name="ln1380"> </a>
<a name="ln1381">/* Walk down the RIPng routing table then clear changed flag. */</a>
<a name="ln1382">static void</a>
<a name="ln1383">ripng_clear_changed_flag (void)</a>
<a name="ln1384">{</a>
<a name="ln1385">  struct route_node *rp;</a>
<a name="ln1386">  struct ripng_info *rinfo = NULL;</a>
<a name="ln1387">  struct list *list = NULL;</a>
<a name="ln1388">  struct listnode *listnode = NULL;</a>
<a name="ln1389"> </a>
<a name="ln1390">  for (rp = route_top (ripng-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln1391">    if ((list = rp-&gt;info) != NULL)</a>
<a name="ln1392">      for (ALL_LIST_ELEMENTS_RO (list, listnode, rinfo))</a>
<a name="ln1393">        {</a>
<a name="ln1394">          UNSET_FLAG (rinfo-&gt;flags, RIPNG_RTF_CHANGED);</a>
<a name="ln1395">          /* This flag can be set only on the first entry. */</a>
<a name="ln1396">          break;</a>
<a name="ln1397">        }</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400">/* Regular update of RIPng route.  Send all routing formation to RIPng</a>
<a name="ln1401">   enabled interface. */</a>
<a name="ln1402">static int</a>
<a name="ln1403">ripng_update (struct thread *t)</a>
<a name="ln1404">{</a>
<a name="ln1405">  struct listnode *node;</a>
<a name="ln1406">  struct interface *ifp;</a>
<a name="ln1407">  struct ripng_interface *ri;</a>
<a name="ln1408"> </a>
<a name="ln1409">  /* Clear update timer thread. */</a>
<a name="ln1410">  ripng-&gt;t_update = NULL;</a>
<a name="ln1411"> </a>
<a name="ln1412">  /* Logging update event. */</a>
<a name="ln1413">  if (IS_RIPNG_DEBUG_EVENT)</a>
<a name="ln1414">    zlog_debug (&quot;RIPng update timer expired!&quot;);</a>
<a name="ln1415"> </a>
<a name="ln1416">  /* Supply routes to each interface. */</a>
<a name="ln1417">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln1418">    {</a>
<a name="ln1419">      ri = ifp-&gt;info;</a>
<a name="ln1420"> </a>
<a name="ln1421">      if (if_is_loopback (ifp) || ! if_is_up (ifp))</a>
<a name="ln1422">	continue;</a>
<a name="ln1423"> </a>
<a name="ln1424">      if (! ri-&gt;running)</a>
<a name="ln1425">	continue;</a>
<a name="ln1426"> </a>
<a name="ln1427">      /* When passive interface is specified, suppress announce to the</a>
<a name="ln1428">         interface. */</a>
<a name="ln1429">      if (ri-&gt;passive)</a>
<a name="ln1430">	continue;</a>
<a name="ln1431"> </a>
<a name="ln1432">#if RIPNG_ADVANCED</a>
<a name="ln1433">      if (ri-&gt;ri_send == RIPNG_SEND_OFF)</a>
<a name="ln1434">	{</a>
<a name="ln1435">	  if (IS_RIPNG_DEBUG_EVENT)</a>
<a name="ln1436">	    zlog (NULL, LOG_DEBUG, </a>
<a name="ln1437">		  &quot;[Event] RIPng send to if %d is suppressed by config&quot;,</a>
<a name="ln1438">		 ifp-&gt;ifindex);</a>
<a name="ln1439">	  continue;</a>
<a name="ln1440">	}</a>
<a name="ln1441">#endif /* RIPNG_ADVANCED */</a>
<a name="ln1442"> </a>
<a name="ln1443">      ripng_output_process (ifp, NULL, ripng_all_route);</a>
<a name="ln1444">    }</a>
<a name="ln1445"> </a>
<a name="ln1446">  /* Triggered updates may be suppressed if a regular update is due by</a>
<a name="ln1447">     the time the triggered update would be sent. */</a>
<a name="ln1448">  if (ripng-&gt;t_triggered_interval)</a>
<a name="ln1449">    {</a>
<a name="ln1450">      thread_cancel (ripng-&gt;t_triggered_interval);</a>
<a name="ln1451">      ripng-&gt;t_triggered_interval = NULL;</a>
<a name="ln1452">    }</a>
<a name="ln1453">  ripng-&gt;trigger = 0;</a>
<a name="ln1454"> </a>
<a name="ln1455">  /* Reset flush event. */</a>
<a name="ln1456">  ripng_event (RIPNG_UPDATE_EVENT, 0);</a>
<a name="ln1457"> </a>
<a name="ln1458">  return 0;</a>
<a name="ln1459">}</a>
<a name="ln1460"> </a>
<a name="ln1461">/* Triggered update interval timer. */</a>
<a name="ln1462">static int</a>
<a name="ln1463">ripng_triggered_interval (struct thread *t)</a>
<a name="ln1464">{</a>
<a name="ln1465">  ripng-&gt;t_triggered_interval = NULL;</a>
<a name="ln1466"> </a>
<a name="ln1467">  if (ripng-&gt;trigger)</a>
<a name="ln1468">    {</a>
<a name="ln1469">      ripng-&gt;trigger = 0;</a>
<a name="ln1470">      ripng_triggered_update (t);</a>
<a name="ln1471">    }</a>
<a name="ln1472">  return 0;</a>
<a name="ln1473">}     </a>
<a name="ln1474"> </a>
<a name="ln1475">/* Execute triggered update. */</a>
<a name="ln1476">int</a>
<a name="ln1477">ripng_triggered_update (struct thread *t)</a>
<a name="ln1478">{</a>
<a name="ln1479">  struct listnode *node;</a>
<a name="ln1480">  struct interface *ifp;</a>
<a name="ln1481">  struct ripng_interface *ri;</a>
<a name="ln1482">  int interval;</a>
<a name="ln1483"> </a>
<a name="ln1484">  ripng-&gt;t_triggered_update = NULL;</a>
<a name="ln1485"> </a>
<a name="ln1486">  /* Cancel interval timer. */</a>
<a name="ln1487">  if (ripng-&gt;t_triggered_interval)</a>
<a name="ln1488">    {</a>
<a name="ln1489">      thread_cancel (ripng-&gt;t_triggered_interval);</a>
<a name="ln1490">      ripng-&gt;t_triggered_interval = NULL;</a>
<a name="ln1491">    }</a>
<a name="ln1492">  ripng-&gt;trigger = 0;</a>
<a name="ln1493"> </a>
<a name="ln1494">  /* Logging triggered update. */</a>
<a name="ln1495">  if (IS_RIPNG_DEBUG_EVENT)</a>
<a name="ln1496">    zlog_debug (&quot;RIPng triggered update!&quot;);</a>
<a name="ln1497"> </a>
<a name="ln1498">  /* Split Horizon processing is done when generating triggered</a>
<a name="ln1499">     updates as well as normal updates (see section 2.6). */</a>
<a name="ln1500">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln1501">    {</a>
<a name="ln1502">      ri = ifp-&gt;info;</a>
<a name="ln1503"> </a>
<a name="ln1504">      if (if_is_loopback (ifp) || ! if_is_up (ifp))</a>
<a name="ln1505">	continue;</a>
<a name="ln1506"> </a>
<a name="ln1507">      if (! ri-&gt;running)</a>
<a name="ln1508">	continue;</a>
<a name="ln1509"> </a>
<a name="ln1510">      /* When passive interface is specified, suppress announce to the</a>
<a name="ln1511">         interface. */</a>
<a name="ln1512">      if (ri-&gt;passive)</a>
<a name="ln1513">	continue;</a>
<a name="ln1514"> </a>
<a name="ln1515">      ripng_output_process (ifp, NULL, ripng_changed_route);</a>
<a name="ln1516">    }</a>
<a name="ln1517"> </a>
<a name="ln1518">  /* Once all of the triggered updates have been generated, the route</a>
<a name="ln1519">     change flags should be cleared. */</a>
<a name="ln1520">  ripng_clear_changed_flag ();</a>
<a name="ln1521"> </a>
<a name="ln1522">  /* After a triggered update is sent, a timer should be set for a</a>
<a name="ln1523">     random interval between 1 and 5 seconds.  If other changes that</a>
<a name="ln1524">     would trigger updates occur before the timer expires, a single</a>
<a name="ln1525">     update is triggered when the timer expires. */</a>
<a name="ln1526">  interval = (random () % 5) + 1;</a>
<a name="ln1527"> </a>
<a name="ln1528">  ripng-&gt;t_triggered_interval = </a>
<a name="ln1529">    thread_add_timer (master, ripng_triggered_interval, NULL, interval);</a>
<a name="ln1530"> </a>
<a name="ln1531">  return 0;</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">/* Write routing table entry to the stream and return next index of</a>
<a name="ln1535">   the routing table entry in the stream. */</a>
<a name="ln1536">int</a>
<a name="ln1537">ripng_write_rte (int num, struct stream *s, struct prefix_ipv6 *p,</a>
<a name="ln1538">		 struct in6_addr *nexthop, u_int16_t tag, u_char metric)</a>
<a name="ln1539">{</a>
<a name="ln1540">  /* RIPng packet header. */</a>
<a name="ln1541">  if (num == 0)</a>
<a name="ln1542">    {</a>
<a name="ln1543">      stream_putc (s, RIPNG_RESPONSE);</a>
<a name="ln1544">      stream_putc (s, RIPNG_V1);</a>
<a name="ln1545">      stream_putw (s, 0);</a>
<a name="ln1546">    }</a>
<a name="ln1547"> </a>
<a name="ln1548">  /* Write routing table entry. */</a>
<a name="ln1549">  if (!nexthop)</a>
<a name="ln1550">    stream_write (s, (u_char *) &amp;p-&gt;prefix, sizeof (struct in6_addr));</a>
<a name="ln1551">  else</a>
<a name="ln1552">    stream_write (s, (u_char *) nexthop, sizeof (struct in6_addr));</a>
<a name="ln1553">  stream_putw (s, tag);</a>
<a name="ln1554">  if (p)</a>
<a name="ln1555">    stream_putc (s, p-&gt;prefixlen);</a>
<a name="ln1556">  else</a>
<a name="ln1557">    stream_putc (s, 0);</a>
<a name="ln1558">  stream_putc (s, metric);</a>
<a name="ln1559"> </a>
<a name="ln1560">  return ++num;</a>
<a name="ln1561">}</a>
<a name="ln1562"> </a>
<a name="ln1563">/* Send RESPONSE message to specified destination. */</a>
<a name="ln1564">void</a>
<a name="ln1565">ripng_output_process (struct interface *ifp, struct sockaddr_in6 *to,</a>
<a name="ln1566">		      int route_type)</a>
<a name="ln1567">{</a>
<a name="ln1568">  int ret;</a>
<a name="ln1569">  struct route_node *rp;</a>
<a name="ln1570">  struct ripng_info *rinfo;</a>
<a name="ln1571">  struct ripng_interface *ri;</a>
<a name="ln1572">  struct ripng_aggregate *aggregate;</a>
<a name="ln1573">  struct prefix_ipv6 *p;</a>
<a name="ln1574">  struct list * ripng_rte_list;</a>
<a name="ln1575">  struct list *list = NULL;</a>
<a name="ln1576">  struct listnode *listnode = NULL;</a>
<a name="ln1577"> </a>
<a name="ln1578">  if (IS_RIPNG_DEBUG_EVENT) {</a>
<a name="ln1579">    if (to)</a>
<a name="ln1580">      zlog_debug (&quot;RIPng update routes to neighbor %s&quot;,</a>
<a name="ln1581">                 inet6_ntoa(to-&gt;sin6_addr));</a>
<a name="ln1582">    else</a>
<a name="ln1583">      zlog_debug (&quot;RIPng update routes on interface %s&quot;, ifp-&gt;name);</a>
<a name="ln1584">  }</a>
<a name="ln1585"> </a>
<a name="ln1586">  /* Get RIPng interface. */</a>
<a name="ln1587">  ri = ifp-&gt;info;</a>
<a name="ln1588"> </a>
<a name="ln1589">  ripng_rte_list = ripng_rte_new();</a>
<a name="ln1590"> </a>
<a name="ln1591">  for (rp = route_top (ripng-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln1592">    {</a>
<a name="ln1593">      if ((list = rp-&gt;info) != NULL &amp;&amp;</a>
<a name="ln1594">          (rinfo = listgetdata (listhead (list))) != NULL &amp;&amp;</a>
<a name="ln1595">          rinfo-&gt;suppress == 0)</a>
<a name="ln1596">	{</a>
<a name="ln1597">	  /* If no route-map are applied, the RTE will be these following</a>
<a name="ln1598">	   * informations.</a>
<a name="ln1599">	   */</a>
<a name="ln1600">	  p = (struct prefix_ipv6 *) &amp;rp-&gt;p;</a>
<a name="ln1601">	  rinfo-&gt;metric_out = rinfo-&gt;metric;</a>
<a name="ln1602">	  rinfo-&gt;tag_out    = rinfo-&gt;tag;</a>
<a name="ln1603">	  memset(&amp;rinfo-&gt;nexthop_out, 0, sizeof(rinfo-&gt;nexthop_out));</a>
<a name="ln1604">	  /* In order to avoid some local loops,</a>
<a name="ln1605">	   * if the RIPng route has a nexthop via this interface, keep the nexthop,</a>
<a name="ln1606">	   * otherwise set it to 0. The nexthop should not be propagated</a>
<a name="ln1607">	   * beyond the local broadcast/multicast area in order</a>
<a name="ln1608">	   * to avoid an IGP multi-level recursive look-up.</a>
<a name="ln1609">	   */</a>
<a name="ln1610">	  if (rinfo-&gt;ifindex == ifp-&gt;ifindex)</a>
<a name="ln1611">	    rinfo-&gt;nexthop_out = rinfo-&gt;nexthop;</a>
<a name="ln1612"> </a>
<a name="ln1613">	  /* Apply output filters. */</a>
<a name="ln1614">	  ret = ripng_filter (RIPNG_FILTER_OUT, p, ri);</a>
<a name="ln1615">	  if (ret &lt; 0)</a>
<a name="ln1616">	    continue;</a>
<a name="ln1617"> </a>
<a name="ln1618">	  /* Changed route only output. */</a>
<a name="ln1619">	  if (route_type == ripng_changed_route &amp;&amp;</a>
<a name="ln1620">	      (! (rinfo-&gt;flags &amp; RIPNG_RTF_CHANGED)))</a>
<a name="ln1621">	    continue;</a>
<a name="ln1622"> </a>
<a name="ln1623">	  /* Split horizon. */</a>
<a name="ln1624">	  if (ri-&gt;split_horizon == RIPNG_SPLIT_HORIZON)</a>
<a name="ln1625">	  {</a>
<a name="ln1626">	    /* We perform split horizon for RIPng routes. */</a>
<a name="ln1627">	    int suppress = 0;</a>
<a name="ln1628">	    struct ripng_info *tmp_rinfo = NULL;</a>
<a name="ln1629"> </a>
<a name="ln1630">	    for (ALL_LIST_ELEMENTS_RO (list, listnode, tmp_rinfo))</a>
<a name="ln1631">	      if (tmp_rinfo-&gt;type == ZEBRA_ROUTE_RIPNG &amp;&amp;</a>
<a name="ln1632">	          tmp_rinfo-&gt;ifindex == ifp-&gt;ifindex)</a>
<a name="ln1633">	        {</a>
<a name="ln1634">	          suppress = 1;</a>
<a name="ln1635">	          break;</a>
<a name="ln1636">	        }</a>
<a name="ln1637">	    if (suppress)</a>
<a name="ln1638">	      continue;</a>
<a name="ln1639">	  }</a>
<a name="ln1640"> </a>
<a name="ln1641">	  /* Preparation for route-map. */</a>
<a name="ln1642">	  rinfo-&gt;metric_set = 0;</a>
<a name="ln1643">	  /* nexthop_out,</a>
<a name="ln1644">	   * metric_out</a>
<a name="ln1645">	   * and tag_out are already initialized.</a>
<a name="ln1646">	   */</a>
<a name="ln1647"> </a>
<a name="ln1648">	  /* Interface route-map */</a>
<a name="ln1649">	  if (ri-&gt;routemap[RIPNG_FILTER_OUT])</a>
<a name="ln1650">	    {</a>
<a name="ln1651">	      int ret;</a>
<a name="ln1652"> </a>
<a name="ln1653">	      ret = route_map_apply (ri-&gt;routemap[RIPNG_FILTER_OUT], </a>
<a name="ln1654">				     (struct prefix *) p, RMAP_RIPNG, </a>
<a name="ln1655">				     rinfo);</a>
<a name="ln1656"> </a>
<a name="ln1657">	      if (ret == RMAP_DENYMATCH)</a>
<a name="ln1658">		{</a>
<a name="ln1659">		  if (IS_RIPNG_DEBUG_PACKET)</a>
<a name="ln1660">		    zlog_debug (&quot;RIPng %s/%d is filtered by route-map out&quot;,</a>
<a name="ln1661">			       inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln1662">		  continue;</a>
<a name="ln1663">		}</a>
<a name="ln1664"> </a>
<a name="ln1665">	    }</a>
<a name="ln1666"> </a>
<a name="ln1667">	  /* Redistribute route-map. */</a>
<a name="ln1668">	  if (ripng-&gt;route_map[rinfo-&gt;type].name)</a>
<a name="ln1669">	    {</a>
<a name="ln1670">	      int ret;</a>
<a name="ln1671"> </a>
<a name="ln1672">	      ret = route_map_apply (ripng-&gt;route_map[rinfo-&gt;type].map,</a>
<a name="ln1673">				     (struct prefix *) p, RMAP_RIPNG,</a>
<a name="ln1674">				     rinfo);</a>
<a name="ln1675"> </a>
<a name="ln1676">	      if (ret == RMAP_DENYMATCH)</a>
<a name="ln1677">		{</a>
<a name="ln1678">		  if (IS_RIPNG_DEBUG_PACKET)</a>
<a name="ln1679">		    zlog_debug (&quot;RIPng %s/%d is filtered by route-map&quot;,</a>
<a name="ln1680">			       inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln1681">		  continue;</a>
<a name="ln1682">		}</a>
<a name="ln1683">	    }</a>
<a name="ln1684"> </a>
<a name="ln1685">	  /* When the route-map does not set metric. */</a>
<a name="ln1686">	  if (! rinfo-&gt;metric_set)</a>
<a name="ln1687">	    {</a>
<a name="ln1688">	      /* If the redistribute metric is set. */</a>
<a name="ln1689">	      if (ripng-&gt;route_map[rinfo-&gt;type].metric_config</a>
<a name="ln1690">		  &amp;&amp; rinfo-&gt;metric != RIPNG_METRIC_INFINITY)</a>
<a name="ln1691">		{</a>
<a name="ln1692">		  rinfo-&gt;metric_out = ripng-&gt;route_map[rinfo-&gt;type].metric;</a>
<a name="ln1693">		}</a>
<a name="ln1694">	      else</a>
<a name="ln1695">		{</a>
<a name="ln1696">		  /* If the route is not connected or localy generated</a>
<a name="ln1697">		     one, use default-metric value */</a>
<a name="ln1698">		  if (rinfo-&gt;type != ZEBRA_ROUTE_RIPNG</a>
<a name="ln1699">		      &amp;&amp; rinfo-&gt;type != ZEBRA_ROUTE_CONNECT</a>
<a name="ln1700">		      &amp;&amp; rinfo-&gt;metric != RIPNG_METRIC_INFINITY)</a>
<a name="ln1701">		    rinfo-&gt;metric_out = ripng-&gt;default_metric;</a>
<a name="ln1702">		}</a>
<a name="ln1703">	    }</a>
<a name="ln1704"> </a>
<a name="ln1705">          /* Apply offset-list */</a>
<a name="ln1706">	  if (rinfo-&gt;metric_out != RIPNG_METRIC_INFINITY)</a>
<a name="ln1707">            ripng_offset_list_apply_out (p, ifp, &amp;rinfo-&gt;metric_out);</a>
<a name="ln1708"> </a>
<a name="ln1709">          if (rinfo-&gt;metric_out &gt; RIPNG_METRIC_INFINITY)</a>
<a name="ln1710">            rinfo-&gt;metric_out = RIPNG_METRIC_INFINITY;</a>
<a name="ln1711"> </a>
<a name="ln1712">	  /* Perform split-horizon with poisoned reverse </a>
<a name="ln1713">	   * for RIPng routes.</a>
<a name="ln1714">	   **/</a>
<a name="ln1715">	  if (ri-&gt;split_horizon == RIPNG_SPLIT_HORIZON_POISONED_REVERSE) {</a>
<a name="ln1716">	    struct ripng_info *tmp_rinfo = NULL;</a>
<a name="ln1717"> </a>
<a name="ln1718">	    for (ALL_LIST_ELEMENTS_RO (list, listnode, tmp_rinfo))</a>
<a name="ln1719">	      if ((tmp_rinfo-&gt;type == ZEBRA_ROUTE_RIPNG) &amp;&amp;</a>
<a name="ln1720">	           tmp_rinfo-&gt;ifindex == ifp-&gt;ifindex)</a>
<a name="ln1721">	        rinfo-&gt;metric_out = RIPNG_METRIC_INFINITY;</a>
<a name="ln1722">	  }</a>
<a name="ln1723"> </a>
<a name="ln1724">	  /* Add RTE to the list */</a>
<a name="ln1725">	  ripng_rte_add(ripng_rte_list, p, rinfo, NULL);</a>
<a name="ln1726">	}</a>
<a name="ln1727"> </a>
<a name="ln1728">      /* Process the aggregated RTE entry */</a>
<a name="ln1729">      if ((aggregate = rp-&gt;aggregate) != NULL &amp;&amp; </a>
<a name="ln1730">	  aggregate-&gt;count &gt; 0 &amp;&amp; </a>
<a name="ln1731">	  aggregate-&gt;suppress == 0)</a>
<a name="ln1732">	{</a>
<a name="ln1733">	  /* If no route-map are applied, the RTE will be these following</a>
<a name="ln1734">	   * informations.</a>
<a name="ln1735">	   */</a>
<a name="ln1736">	  p = (struct prefix_ipv6 *) &amp;rp-&gt;p;</a>
<a name="ln1737">	  aggregate-&gt;metric_set = 0;</a>
<a name="ln1738">	  aggregate-&gt;metric_out = aggregate-&gt;metric;</a>
<a name="ln1739">	  aggregate-&gt;tag_out    = aggregate-&gt;tag;</a>
<a name="ln1740">	  memset(&amp;aggregate-&gt;nexthop_out, 0, sizeof(aggregate-&gt;nexthop_out));</a>
<a name="ln1741"> </a>
<a name="ln1742">	  /* Apply output filters.*/</a>
<a name="ln1743">	  ret = ripng_filter (RIPNG_FILTER_OUT, p, ri);</a>
<a name="ln1744">	  if (ret &lt; 0)</a>
<a name="ln1745">	    continue;</a>
<a name="ln1746"> </a>
<a name="ln1747">	  /* Interface route-map */</a>
<a name="ln1748">	  if (ri-&gt;routemap[RIPNG_FILTER_OUT])</a>
<a name="ln1749">	    {</a>
<a name="ln1750">	      int ret;</a>
<a name="ln1751">	      struct ripng_info newinfo;</a>
<a name="ln1752"> </a>
<a name="ln1753">	      /* let's cast the aggregate structure to ripng_info */</a>
<a name="ln1754">	      memset (&amp;newinfo, 0, sizeof (struct ripng_info));</a>
<a name="ln1755">	      /* the nexthop is :: */</a>
<a name="ln1756">	      newinfo.metric = aggregate-&gt;metric;</a>
<a name="ln1757">	      newinfo.metric_out = aggregate-&gt;metric_out;</a>
<a name="ln1758">	      newinfo.tag = aggregate-&gt;tag;</a>
<a name="ln1759">	      newinfo.tag_out = aggregate-&gt;tag_out;</a>
<a name="ln1760"> </a>
<a name="ln1761">	      ret = route_map_apply (ri-&gt;routemap[RIPNG_FILTER_OUT], </a>
<a name="ln1762">				     (struct prefix *) p, RMAP_RIPNG, </a>
<a name="ln1763">				     &amp;newinfo);</a>
<a name="ln1764"> </a>
<a name="ln1765">	      if (ret == RMAP_DENYMATCH)</a>
<a name="ln1766">		{</a>
<a name="ln1767">		  if (IS_RIPNG_DEBUG_PACKET)</a>
<a name="ln1768">		    zlog_debug (&quot;RIPng %s/%d is filtered by route-map out&quot;,</a>
<a name="ln1769">			       inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln1770">		  continue;</a>
<a name="ln1771">		}</a>
<a name="ln1772"> </a>
<a name="ln1773">	      aggregate-&gt;metric_out = newinfo.metric_out;</a>
<a name="ln1774">	      aggregate-&gt;tag_out = newinfo.tag_out;</a>
<a name="ln1775">	      if (IN6_IS_ADDR_LINKLOCAL(&amp;newinfo.nexthop_out))</a>
<a name="ln1776">		aggregate-&gt;nexthop_out = newinfo.nexthop_out;</a>
<a name="ln1777">	    }</a>
<a name="ln1778"> </a>
<a name="ln1779">	  /* There is no redistribute routemap for the aggregated RTE */</a>
<a name="ln1780"> </a>
<a name="ln1781">	  /* Changed route only output. */</a>
<a name="ln1782">	  /* XXX, vincent, in order to increase time convergence,</a>
<a name="ln1783">	   * it should be announced if a child has changed.</a>
<a name="ln1784">	   */</a>
<a name="ln1785">	  if (route_type == ripng_changed_route)</a>
<a name="ln1786">	    continue;</a>
<a name="ln1787"> </a>
<a name="ln1788">	  /* Apply offset-list */</a>
<a name="ln1789">	  if (aggregate-&gt;metric_out != RIPNG_METRIC_INFINITY)</a>
<a name="ln1790">	    ripng_offset_list_apply_out (p, ifp, &amp;aggregate-&gt;metric_out);</a>
<a name="ln1791"> </a>
<a name="ln1792">	  if (aggregate-&gt;metric_out &gt; RIPNG_METRIC_INFINITY)</a>
<a name="ln1793">	    aggregate-&gt;metric_out = RIPNG_METRIC_INFINITY;</a>
<a name="ln1794"> </a>
<a name="ln1795">	  /* Add RTE to the list */</a>
<a name="ln1796">	  ripng_rte_add(ripng_rte_list, p, NULL, aggregate);</a>
<a name="ln1797">	}</a>
<a name="ln1798"> </a>
<a name="ln1799">    }</a>
<a name="ln1800"> </a>
<a name="ln1801">  /* Flush the list */</a>
<a name="ln1802">  ripng_rte_send(ripng_rte_list, ifp, to);</a>
<a name="ln1803">  ripng_rte_free(ripng_rte_list);</a>
<a name="ln1804">}</a>
<a name="ln1805"> </a>
<a name="ln1806">/* Create new RIPng instance and set it to global variable. */</a>
<a name="ln1807">static int</a>
<a name="ln1808">ripng_create (void)</a>
<a name="ln1809">{</a>
<a name="ln1810">  /* ripng should be NULL. */</a>
<a name="ln1811">  assert (ripng == NULL);</a>
<a name="ln1812"> </a>
<a name="ln1813">  /* Allocaste RIPng instance. */</a>
<a name="ln1814">  ripng = XCALLOC (MTYPE_RIPNG, sizeof (struct ripng));</a>
<a name="ln1815"> </a>
<a name="ln1816">  /* Default version and timer values. */</a>
<a name="ln1817">  ripng-&gt;version = RIPNG_V1;</a>
<a name="ln1818">  ripng-&gt;update_time = RIPNG_UPDATE_TIMER_DEFAULT;</a>
<a name="ln1819">  ripng-&gt;timeout_time = RIPNG_TIMEOUT_TIMER_DEFAULT;</a>
<a name="ln1820">  ripng-&gt;garbage_time = RIPNG_GARBAGE_TIMER_DEFAULT;</a>
<a name="ln1821">  ripng-&gt;default_metric = RIPNG_DEFAULT_METRIC_DEFAULT;</a>
<a name="ln1822">  </a>
<a name="ln1823">  /* Make buffer.  */</a>
<a name="ln1824">  ripng-&gt;ibuf = stream_new (RIPNG_MAX_PACKET_SIZE * 5);</a>
<a name="ln1825">  ripng-&gt;obuf = stream_new (RIPNG_MAX_PACKET_SIZE);</a>
<a name="ln1826"> </a>
<a name="ln1827">  /* Initialize RIPng routig table. */</a>
<a name="ln1828">  ripng-&gt;table = route_table_init ();</a>
<a name="ln1829">  ripng-&gt;route = route_table_init ();</a>
<a name="ln1830">  ripng-&gt;aggregate = route_table_init ();</a>
<a name="ln1831"> </a>
<a name="ln1832">  /* Make socket. */</a>
<a name="ln1833">  ripng-&gt;sock = ripng_make_socket ();</a>
<a name="ln1834">  if (ripng-&gt;sock &lt; 0)</a>
<a name="ln1835">    return ripng-&gt;sock;</a>
<a name="ln1836"> </a>
<a name="ln1837">  /* Threads. */</a>
<a name="ln1838">  ripng_event (RIPNG_READ, ripng-&gt;sock);</a>
<a name="ln1839">  ripng_event (RIPNG_UPDATE_EVENT, 1);</a>
<a name="ln1840"> </a>
<a name="ln1841">  return 0;</a>
<a name="ln1842">}</a>
<a name="ln1843"> </a>
<a name="ln1844">/* Send RIPng request to the interface. */</a>
<a name="ln1845">int</a>
<a name="ln1846">ripng_request (struct interface *ifp)</a>
<a name="ln1847">{</a>
<a name="ln1848">  struct rte *rte;</a>
<a name="ln1849">  struct ripng_packet ripng_packet;</a>
<a name="ln1850"> </a>
<a name="ln1851">  /* In default ripd doesn't send RIP_REQUEST to the loopback interface. */</a>
<a name="ln1852">  if (if_is_loopback(ifp))</a>
<a name="ln1853">    return 0;</a>
<a name="ln1854"> </a>
<a name="ln1855">  /* If interface is down, don't send RIP packet. */</a>
<a name="ln1856">  if (! if_is_up (ifp))</a>
<a name="ln1857">    return 0;</a>
<a name="ln1858"> </a>
<a name="ln1859">  if (IS_RIPNG_DEBUG_EVENT)</a>
<a name="ln1860">    zlog_debug (&quot;RIPng send request to %s&quot;, ifp-&gt;name);</a>
<a name="ln1861"> </a>
<a name="ln1862">  memset (&amp;ripng_packet, 0, sizeof (ripng_packet));</a>
<a name="ln1863">  ripng_packet.command = RIPNG_REQUEST;</a>
<a name="ln1864">  ripng_packet.version = RIPNG_V1;</a>
<a name="ln1865">  rte = ripng_packet.rte;</a>
<a name="ln1866">  rte-&gt;metric = RIPNG_METRIC_INFINITY;</a>
<a name="ln1867"> </a>
<a name="ln1868">  return ripng_send_packet ((caddr_t) &amp;ripng_packet, sizeof (ripng_packet), </a>
<a name="ln1869">			    NULL, ifp);</a>
<a name="ln1870">}</a>
<a name="ln1871"> </a>
<a name="ln1872"> </a>
<a name="ln1873">static int</a>
<a name="ln1874">ripng_update_jitter (int time)</a>
<a name="ln1875">{</a>
<a name="ln1876">  return ((random () % (time + 1)) - (time / 2));</a>
<a name="ln1877">}</a>
<a name="ln1878"> </a>
<a name="ln1879">void</a>
<a name="ln1880">ripng_event (enum ripng_event event, int sock)</a>
<a name="ln1881">{</a>
<a name="ln1882">  int jitter = 0;</a>
<a name="ln1883"> </a>
<a name="ln1884">  switch (event)</a>
<a name="ln1885">    {</a>
<a name="ln1886">    case RIPNG_READ:</a>
<a name="ln1887">      if (!ripng-&gt;t_read)</a>
<a name="ln1888">	ripng-&gt;t_read = thread_add_read (master, ripng_read, NULL, sock);</a>
<a name="ln1889">      break;</a>
<a name="ln1890">    case RIPNG_UPDATE_EVENT:</a>
<a name="ln1891">      if (ripng-&gt;t_update)</a>
<a name="ln1892">	{</a>
<a name="ln1893">	  thread_cancel (ripng-&gt;t_update);</a>
<a name="ln1894">	  ripng-&gt;t_update = NULL;</a>
<a name="ln1895">	}</a>
<a name="ln1896">      /* Update timer jitter. */</a>
<a name="ln1897">      jitter = ripng_update_jitter (ripng-&gt;update_time);</a>
<a name="ln1898"> </a>
<a name="ln1899">      ripng-&gt;t_update = </a>
<a name="ln1900">	thread_add_timer (master, ripng_update, NULL, </a>
<a name="ln1901">			  sock ? 2 : ripng-&gt;update_time + jitter);</a>
<a name="ln1902">      break;</a>
<a name="ln1903">    case RIPNG_TRIGGERED_UPDATE:</a>
<a name="ln1904">      if (ripng-&gt;t_triggered_interval)</a>
<a name="ln1905">	ripng-&gt;trigger = 1;</a>
<a name="ln1906">      else if (! ripng-&gt;t_triggered_update)</a>
<a name="ln1907">	ripng-&gt;t_triggered_update = </a>
<a name="ln1908">	  thread_add_event (master, ripng_triggered_update, NULL, 0);</a>
<a name="ln1909">      break;</a>
<a name="ln1910">    default:</a>
<a name="ln1911">      break;</a>
<a name="ln1912">    }</a>
<a name="ln1913">}</a>
<a name="ln1914"> </a>
<a name="ln1915"> </a>
<a name="ln1916">/* Print out routes update time. */</a>
<a name="ln1917">static void</a>
<a name="ln1918">ripng_vty_out_uptime (struct vty *vty, struct ripng_info *rinfo)</a>
<a name="ln1919">{</a>
<a name="ln1920">  time_t clock;</a>
<a name="ln1921">  struct tm *tm;</a>
<a name="ln1922">#define TIME_BUF 25</a>
<a name="ln1923">  char timebuf [TIME_BUF];</a>
<a name="ln1924">  struct thread *thread;</a>
<a name="ln1925">  </a>
<a name="ln1926">  if ((thread = rinfo-&gt;t_timeout) != NULL)</a>
<a name="ln1927">    {</a>
<a name="ln1928">      clock = thread_timer_remain_second (thread);</a>
<a name="ln1929">      tm = gmtime (&amp;clock);</a>
<a name="ln1930">      strftime (timebuf, TIME_BUF, &quot;%M:%S&quot;, tm);</a>
<a name="ln1931">      vty_out (vty, &quot;%5s&quot;, timebuf);</a>
<a name="ln1932">    }</a>
<a name="ln1933">  else if ((thread = rinfo-&gt;t_garbage_collect) != NULL)</a>
<a name="ln1934">    {</a>
<a name="ln1935">      clock = thread_timer_remain_second (thread);</a>
<a name="ln1936">      tm = gmtime (&amp;clock);</a>
<a name="ln1937">      strftime (timebuf, TIME_BUF, &quot;%M:%S&quot;, tm);</a>
<a name="ln1938">      vty_out (vty, &quot;%5s&quot;, timebuf);</a>
<a name="ln1939">    }</a>
<a name="ln1940">}</a>
<a name="ln1941"> </a>
<a name="ln1942">static char *</a>
<a name="ln1943">ripng_route_subtype_print (struct ripng_info *rinfo)</a>
<a name="ln1944">{</a>
<a name="ln1945">  static char str[3];</a>
<a name="ln1946">  memset(str, 0, 3);</a>
<a name="ln1947"> </a>
<a name="ln1948">  if (rinfo-&gt;suppress)</a>
<a name="ln1949">    strcat(str, &quot;S&quot;);</a>
<a name="ln1950"> </a>
<a name="ln1951">  switch (rinfo-&gt;sub_type)</a>
<a name="ln1952">    {</a>
<a name="ln1953">       case RIPNG_ROUTE_RTE:</a>
<a name="ln1954">         strcat(str, &quot;n&quot;);</a>
<a name="ln1955">         break;</a>
<a name="ln1956">       case RIPNG_ROUTE_STATIC:</a>
<a name="ln1957">         strcat(str, &quot;s&quot;);</a>
<a name="ln1958">         break;</a>
<a name="ln1959">       case RIPNG_ROUTE_DEFAULT:</a>
<a name="ln1960">         strcat(str, &quot;d&quot;);</a>
<a name="ln1961">         break;</a>
<a name="ln1962">       case RIPNG_ROUTE_REDISTRIBUTE:</a>
<a name="ln1963">         strcat(str, &quot;r&quot;);</a>
<a name="ln1964">         break;</a>
<a name="ln1965">       case RIPNG_ROUTE_INTERFACE:</a>
<a name="ln1966">         strcat(str, &quot;i&quot;);</a>
<a name="ln1967">         break;</a>
<a name="ln1968">       default:</a>
<a name="ln1969">         strcat(str, &quot;?&quot;);</a>
<a name="ln1970">         break;</a>
<a name="ln1971">    }</a>
<a name="ln1972"> </a>
<a name="ln1973">  return str;</a>
<a name="ln1974">}</a>
<a name="ln1975"> </a>
<a name="ln1976">DEFUN (show_ipv6_ripng,</a>
<a name="ln1977">       show_ipv6_ripng_cmd,</a>
<a name="ln1978">       &quot;show ipv6 ripng&quot;,</a>
<a name="ln1979">       SHOW_STR</a>
<a name="ln1980">       IPV6_STR</a>
<a name="ln1981">       &quot;Show RIPng routes\n&quot;)</a>
<a name="ln1982">{</a>
<a name="ln1983">  struct route_node *rp;</a>
<a name="ln1984">  struct ripng_info *rinfo;</a>
<a name="ln1985">  struct ripng_aggregate *aggregate;</a>
<a name="ln1986">  struct prefix_ipv6 *p;</a>
<a name="ln1987">  struct list *list = NULL;</a>
<a name="ln1988">  struct listnode *listnode = NULL;</a>
<a name="ln1989">  int len;</a>
<a name="ln1990"> </a>
<a name="ln1991">  if (! ripng)</a>
<a name="ln1992">    return CMD_SUCCESS;</a>
<a name="ln1993"> </a>
<a name="ln1994">  /* Header of display. */ </a>
<a name="ln1995">  vty_out (vty, &quot;Codes: R - RIPng, C - connected, S - Static, O - OSPF, B - BGP%s&quot;</a>
<a name="ln1996">	   &quot;Sub-codes:%s&quot;</a>
<a name="ln1997">	   &quot;      (n) - normal, (s) - static, (d) - default, (r) - redistribute,%s&quot;</a>
<a name="ln1998">	   &quot;      (i) - interface, (a/S) - aggregated/Suppressed%s%s&quot;</a>
<a name="ln1999">	   &quot;   Network      Next Hop                      Via     Metric Tag Time%s&quot;,</a>
<a name="ln2000">	   VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE,</a>
<a name="ln2001">	   VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln2002">  </a>
<a name="ln2003">  for (rp = route_top (ripng-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln2004">    {</a>
<a name="ln2005">      if ((aggregate = rp-&gt;aggregate) != NULL)</a>
<a name="ln2006">	{</a>
<a name="ln2007">	  p = (struct prefix_ipv6 *) &amp;rp-&gt;p;</a>
<a name="ln2008"> </a>
<a name="ln2009">#ifdef DEBUG</a>
<a name="ln2010">	  len = vty_out (vty, &quot;R(a) %d/%d %s/%d &quot;,</a>
<a name="ln2011">			 aggregate-&gt;count, aggregate-&gt;suppress,</a>
<a name="ln2012">			 inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln2013">#else</a>
<a name="ln2014">	  len = vty_out (vty, &quot;R(a) %s/%d &quot;, </a>
<a name="ln2015">			 inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln2016">#endif /* DEBUG */</a>
<a name="ln2017">	  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln2018">	  vty_out (vty, &quot;%*s&quot;, 18, &quot; &quot;);</a>
<a name="ln2019"> </a>
<a name="ln2020">	  vty_out (vty, &quot;%*s&quot;, 28, &quot; &quot;);</a>
<a name="ln2021">	  vty_out (vty, &quot;self      %2d  %3d%s&quot;, aggregate-&gt;metric,</a>
<a name="ln2022">		   aggregate-&gt;tag,</a>
<a name="ln2023">		   VTY_NEWLINE);</a>
<a name="ln2024">	}</a>
<a name="ln2025"> </a>
<a name="ln2026">      if ((list = rp-&gt;info) != NULL)</a>
<a name="ln2027">        for (ALL_LIST_ELEMENTS_RO (list, listnode, rinfo))</a>
<a name="ln2028">	{</a>
<a name="ln2029">	  p = (struct prefix_ipv6 *) &amp;rp-&gt;p;</a>
<a name="ln2030"> </a>
<a name="ln2031">#ifdef DEBUG</a>
<a name="ln2032">	  len = vty_out (vty, &quot;%c(%s) 0/%d %s/%d &quot;,</a>
<a name="ln2033">			 zebra_route_char(rinfo-&gt;type),</a>
<a name="ln2034">			 ripng_route_subtype_print(rinfo),</a>
<a name="ln2035">			 rinfo-&gt;suppress,</a>
<a name="ln2036">			 inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln2037">#else</a>
<a name="ln2038">	  len = vty_out (vty, &quot;%c(%s) %s/%d &quot;,</a>
<a name="ln2039">			 zebra_route_char(rinfo-&gt;type),</a>
<a name="ln2040">			 ripng_route_subtype_print(rinfo),</a>
<a name="ln2041">			 inet6_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln2042">#endif /* DEBUG */</a>
<a name="ln2043">	  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln2044">	  vty_out (vty, &quot;%*s&quot;, 18, &quot; &quot;);</a>
<a name="ln2045">	  len = vty_out (vty, &quot;%s&quot;, inet6_ntoa (rinfo-&gt;nexthop));</a>
<a name="ln2046"> </a>
<a name="ln2047">	  len = 28 - len;</a>
<a name="ln2048">	  if (len &gt; 0)</a>
<a name="ln2049">	    len = vty_out (vty, &quot;%*s&quot;, len, &quot; &quot;);</a>
<a name="ln2050"> </a>
<a name="ln2051">	  /* from */</a>
<a name="ln2052">	  if ((rinfo-&gt;type == ZEBRA_ROUTE_RIPNG) &amp;&amp; </a>
<a name="ln2053">	    (rinfo-&gt;sub_type == RIPNG_ROUTE_RTE))</a>
<a name="ln2054">	  {</a>
<a name="ln2055">	    len = vty_out (vty, &quot;%s&quot;, ifindex2ifname(rinfo-&gt;ifindex));</a>
<a name="ln2056">	  } else if (rinfo-&gt;metric == RIPNG_METRIC_INFINITY)</a>
<a name="ln2057">	  {</a>
<a name="ln2058">	    len = vty_out (vty, &quot;kill&quot;);</a>
<a name="ln2059">	  } else</a>
<a name="ln2060">	    len = vty_out (vty, &quot;self&quot;);</a>
<a name="ln2061"> </a>
<a name="ln2062">	  len = 9 - len;</a>
<a name="ln2063">	  if (len &gt; 0)</a>
<a name="ln2064">	    vty_out (vty, &quot;%*s&quot;, len, &quot; &quot;);</a>
<a name="ln2065"> </a>
<a name="ln2066">	  vty_out (vty, &quot; %2d  %3d  &quot;,</a>
<a name="ln2067">		   rinfo-&gt;metric, rinfo-&gt;tag);</a>
<a name="ln2068"> </a>
<a name="ln2069">	  /* time */</a>
<a name="ln2070">	  if ((rinfo-&gt;type == ZEBRA_ROUTE_RIPNG) &amp;&amp; </a>
<a name="ln2071">	    (rinfo-&gt;sub_type == RIPNG_ROUTE_RTE))</a>
<a name="ln2072">	  {</a>
<a name="ln2073">	    /* RTE from remote RIP routers */</a>
<a name="ln2074">	    ripng_vty_out_uptime (vty, rinfo);</a>
<a name="ln2075">	  } else if (rinfo-&gt;metric == RIPNG_METRIC_INFINITY)</a>
<a name="ln2076">	  {</a>
<a name="ln2077">	    /* poisonous reversed routes (gc) */</a>
<a name="ln2078">	    ripng_vty_out_uptime (vty, rinfo);</a>
<a name="ln2079">	  }</a>
<a name="ln2080"> </a>
<a name="ln2081">	  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln2082">	}</a>
<a name="ln2083">    }</a>
<a name="ln2084"> </a>
<a name="ln2085">  return CMD_SUCCESS;</a>
<a name="ln2086">}</a>
<a name="ln2087"> </a>
<a name="ln2088">DEFUN (show_ipv6_ripng_status,</a>
<a name="ln2089">       show_ipv6_ripng_status_cmd,</a>
<a name="ln2090">       &quot;show ipv6 ripng status&quot;,</a>
<a name="ln2091">       SHOW_STR</a>
<a name="ln2092">       IPV6_STR</a>
<a name="ln2093">       &quot;Show RIPng routes\n&quot;</a>
<a name="ln2094">       &quot;IPv6 routing protocol process parameters and statistics\n&quot;)</a>
<a name="ln2095">{</a>
<a name="ln2096">  struct listnode *node;</a>
<a name="ln2097">  struct interface *ifp;</a>
<a name="ln2098"> </a>
<a name="ln2099">  if (! ripng)</a>
<a name="ln2100">    return CMD_SUCCESS;</a>
<a name="ln2101"> </a>
<a name="ln2102">  vty_out (vty, &quot;Routing Protocol is \&quot;RIPng\&quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln2103">  vty_out (vty, &quot;  Sending updates every %ld seconds with +/-50%%,&quot;,</a>
<a name="ln2104">           ripng-&gt;update_time);</a>
<a name="ln2105">  vty_out (vty, &quot; next due in %lu seconds%s&quot;,</a>
<a name="ln2106">           thread_timer_remain_second (ripng-&gt;t_update),</a>
<a name="ln2107">           VTY_NEWLINE);</a>
<a name="ln2108">  vty_out (vty, &quot;  Timeout after %ld seconds,&quot;, ripng-&gt;timeout_time);</a>
<a name="ln2109">  vty_out (vty, &quot; garbage collect after %ld seconds%s&quot;, ripng-&gt;garbage_time,</a>
<a name="ln2110">           VTY_NEWLINE);</a>
<a name="ln2111"> </a>
<a name="ln2112">  /* Filtering status show. */</a>
<a name="ln2113">  config_show_distribute (vty);</a>
<a name="ln2114"> </a>
<a name="ln2115">  /* Default metric information. */</a>
<a name="ln2116">  vty_out (vty, &quot;  Default redistribution metric is %d%s&quot;,</a>
<a name="ln2117">           ripng-&gt;default_metric, VTY_NEWLINE);</a>
<a name="ln2118"> </a>
<a name="ln2119">  /* Redistribute information. */</a>
<a name="ln2120">  vty_out (vty, &quot;  Redistributing:&quot;);</a>
<a name="ln2121">  ripng_redistribute_write (vty, 0);</a>
<a name="ln2122">  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln2123"> </a>
<a name="ln2124">  vty_out (vty, &quot;  Default version control: send version %d,&quot;, ripng-&gt;version);</a>
<a name="ln2125">  vty_out (vty, &quot; receive version %d %s&quot;, ripng-&gt;version,</a>
<a name="ln2126">           VTY_NEWLINE);</a>
<a name="ln2127"> </a>
<a name="ln2128">  vty_out (vty, &quot;    Interface        Send  Recv%s&quot;, VTY_NEWLINE);</a>
<a name="ln2129"> </a>
<a name="ln2130">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln2131">    {</a>
<a name="ln2132">      struct ripng_interface *ri;</a>
<a name="ln2133">      </a>
<a name="ln2134">      ri = ifp-&gt;info;</a>
<a name="ln2135"> </a>
<a name="ln2136">      if (ri-&gt;enable_network || ri-&gt;enable_interface)</a>
<a name="ln2137">	{</a>
<a name="ln2138"> </a>
<a name="ln2139">	  vty_out (vty, &quot;    %-17s%-3d   %-3d%s&quot;, ifp-&gt;name,</a>
<a name="ln2140">		   ripng-&gt;version,</a>
<a name="ln2141">		   ripng-&gt;version,</a>
<a name="ln2142">		   VTY_NEWLINE);</a>
<a name="ln2143">	}</a>
<a name="ln2144">    }</a>
<a name="ln2145"> </a>
<a name="ln2146">  vty_out (vty, &quot;  Routing for Networks:%s&quot;, VTY_NEWLINE);</a>
<a name="ln2147">  ripng_network_write (vty, 0);</a>
<a name="ln2148"> </a>
<a name="ln2149">  vty_out (vty, &quot;  Routing Information Sources:%s&quot;, VTY_NEWLINE);</a>
<a name="ln2150">  vty_out (vty, &quot;    Gateway          BadPackets BadRoutes  Distance Last Update%s&quot;, VTY_NEWLINE);</a>
<a name="ln2151">  ripng_peer_display (vty);</a>
<a name="ln2152"> </a>
<a name="ln2153">  return CMD_SUCCESS;  </a>
<a name="ln2154">}</a>
<a name="ln2155"> </a>
<a name="ln2156">DEFUN (router_ripng,</a>
<a name="ln2157">       router_ripng_cmd,</a>
<a name="ln2158">       &quot;router ripng&quot;,</a>
<a name="ln2159">       &quot;Enable a routing process\n&quot;</a>
<a name="ln2160">       &quot;Make RIPng instance command\n&quot;)</a>
<a name="ln2161">{</a>
<a name="ln2162">  int ret;</a>
<a name="ln2163"> </a>
<a name="ln2164">  vty-&gt;node = RIPNG_NODE;</a>
<a name="ln2165"> </a>
<a name="ln2166">  if (!ripng)</a>
<a name="ln2167">    {</a>
<a name="ln2168">      ret = ripng_create ();</a>
<a name="ln2169"> </a>
<a name="ln2170">      /* Notice to user we couldn't create RIPng. */</a>
<a name="ln2171">      if (ret &lt; 0)</a>
<a name="ln2172">	{</a>
<a name="ln2173">	  zlog_warn (&quot;can't create RIPng&quot;);</a>
<a name="ln2174">	  return CMD_WARNING;</a>
<a name="ln2175">	}</a>
<a name="ln2176">    }</a>
<a name="ln2177"> </a>
<a name="ln2178">  return CMD_SUCCESS;</a>
<a name="ln2179">}</a>
<a name="ln2180"> </a>
<a name="ln2181">DEFUN (no_router_ripng,</a>
<a name="ln2182">       no_router_ripng_cmd,</a>
<a name="ln2183">       &quot;no router ripng&quot;,</a>
<a name="ln2184">       NO_STR</a>
<a name="ln2185">       &quot;Enable a routing process\n&quot;</a>
<a name="ln2186">       &quot;Make RIPng instance command\n&quot;)</a>
<a name="ln2187">{</a>
<a name="ln2188">  if(ripng)</a>
<a name="ln2189">    ripng_clean();</a>
<a name="ln2190">  return CMD_SUCCESS;</a>
<a name="ln2191">}</a>
<a name="ln2192"> </a>
<a name="ln2193">DEFUN (ripng_route,</a>
<a name="ln2194">       ripng_route_cmd,</a>
<a name="ln2195">       &quot;route IPV6ADDR&quot;,</a>
<a name="ln2196">       &quot;Static route setup\n&quot;</a>
<a name="ln2197">       &quot;Set static RIPng route announcement\n&quot;)</a>
<a name="ln2198">{</a>
<a name="ln2199">  int ret;</a>
<a name="ln2200">  struct prefix_ipv6 p;</a>
<a name="ln2201">  struct route_node *rp;</a>
<a name="ln2202"> </a>
<a name="ln2203">  ret = str2prefix_ipv6 (argv[0], (struct prefix_ipv6 *)&amp;p);</a>
<a name="ln2204">  if (ret &lt;= 0)</a>
<a name="ln2205">    {</a>
<a name="ln2206">      vty_out (vty, &quot;Malformed address%s&quot;, VTY_NEWLINE);</a>
<a name="ln2207">      return CMD_WARNING;</a>
<a name="ln2208">    }</a>
<a name="ln2209">  apply_mask_ipv6 (&amp;p);</a>
<a name="ln2210"> </a>
<a name="ln2211">  rp = route_node_get (ripng-&gt;route, (struct prefix *) &amp;p);</a>
<a name="ln2212">  if (rp-&gt;info)</a>
<a name="ln2213">    {</a>
<a name="ln2214">      vty_out (vty, &quot;There is already same static route.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2215">      route_unlock_node (rp);</a>
<a name="ln2216">      return CMD_WARNING;</a>
<a name="ln2217">    }</a>
<a name="ln2218">  rp-&gt;info = (void *)1;</a>
<a name="ln2219"> </a>
<a name="ln2220">  ripng_redistribute_add (ZEBRA_ROUTE_RIPNG, RIPNG_ROUTE_STATIC, &amp;p, 0, NULL, 0);</a>
<a name="ln2221"> </a>
<a name="ln2222">  return CMD_SUCCESS;</a>
<a name="ln2223">}</a>
<a name="ln2224"> </a>
<a name="ln2225">DEFUN (no_ripng_route,</a>
<a name="ln2226">       no_ripng_route_cmd,</a>
<a name="ln2227">       &quot;no route IPV6ADDR&quot;,</a>
<a name="ln2228">       NO_STR</a>
<a name="ln2229">       &quot;Static route setup\n&quot;</a>
<a name="ln2230">       &quot;Delete static RIPng route announcement\n&quot;)</a>
<a name="ln2231">{</a>
<a name="ln2232">  int ret;</a>
<a name="ln2233">  struct prefix_ipv6 p;</a>
<a name="ln2234">  struct route_node *rp;</a>
<a name="ln2235"> </a>
<a name="ln2236">  ret = str2prefix_ipv6 (argv[0], (struct prefix_ipv6 *)&amp;p);</a>
<a name="ln2237">  if (ret &lt;= 0)</a>
<a name="ln2238">    {</a>
<a name="ln2239">      vty_out (vty, &quot;Malformed address%s&quot;, VTY_NEWLINE);</a>
<a name="ln2240">      return CMD_WARNING;</a>
<a name="ln2241">    }</a>
<a name="ln2242">  apply_mask_ipv6 (&amp;p);</a>
<a name="ln2243"> </a>
<a name="ln2244">  rp = route_node_lookup (ripng-&gt;route, (struct prefix *) &amp;p);</a>
<a name="ln2245">  if (! rp)</a>
<a name="ln2246">    {</a>
<a name="ln2247">      vty_out (vty, &quot;Can't find static route.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2248">      return CMD_WARNING;</a>
<a name="ln2249">    }</a>
<a name="ln2250"> </a>
<a name="ln2251">  ripng_redistribute_delete (ZEBRA_ROUTE_RIPNG, RIPNG_ROUTE_STATIC, &amp;p, 0);</a>
<a name="ln2252">  route_unlock_node (rp);</a>
<a name="ln2253"> </a>
<a name="ln2254">  rp-&gt;info = NULL;</a>
<a name="ln2255">  route_unlock_node (rp);</a>
<a name="ln2256"> </a>
<a name="ln2257">  return CMD_SUCCESS;</a>
<a name="ln2258">}</a>
<a name="ln2259"> </a>
<a name="ln2260">DEFUN (ripng_aggregate_address,</a>
<a name="ln2261">       ripng_aggregate_address_cmd,</a>
<a name="ln2262">       &quot;aggregate-address X:X::X:X/M&quot;,</a>
<a name="ln2263">       &quot;Set aggregate RIPng route announcement\n&quot;</a>
<a name="ln2264">       &quot;Aggregate network\n&quot;)</a>
<a name="ln2265">{</a>
<a name="ln2266">  int ret;</a>
<a name="ln2267">  struct prefix p;</a>
<a name="ln2268">  struct route_node *node;</a>
<a name="ln2269"> </a>
<a name="ln2270">  ret = str2prefix_ipv6 (argv[0], (struct prefix_ipv6 *)&amp;p);</a>
<a name="ln2271">  if (ret &lt;= 0)</a>
<a name="ln2272">    {</a>
<a name="ln2273">      vty_out (vty, &quot;Malformed address%s&quot;, VTY_NEWLINE);</a>
<a name="ln2274">      return CMD_WARNING;</a>
<a name="ln2275">    }</a>
<a name="ln2276"> </a>
<a name="ln2277">  /* Check aggregate alredy exist or not. */</a>
<a name="ln2278">  node = route_node_get (ripng-&gt;aggregate, &amp;p);</a>
<a name="ln2279">  if (node-&gt;info)</a>
<a name="ln2280">    {</a>
<a name="ln2281">      vty_out (vty, &quot;There is already same aggregate route.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2282">      route_unlock_node (node);</a>
<a name="ln2283">      return CMD_WARNING;</a>
<a name="ln2284">    }</a>
<a name="ln2285">  node-&gt;info = (void *)1;</a>
<a name="ln2286"> </a>
<a name="ln2287">  ripng_aggregate_add (&amp;p);</a>
<a name="ln2288"> </a>
<a name="ln2289">  return CMD_SUCCESS;</a>
<a name="ln2290">}</a>
<a name="ln2291"> </a>
<a name="ln2292">DEFUN (no_ripng_aggregate_address,</a>
<a name="ln2293">       no_ripng_aggregate_address_cmd,</a>
<a name="ln2294">       &quot;no aggregate-address X:X::X:X/M&quot;,</a>
<a name="ln2295">       NO_STR</a>
<a name="ln2296">       &quot;Delete aggregate RIPng route announcement\n&quot;</a>
<a name="ln2297">       &quot;Aggregate network&quot;)</a>
<a name="ln2298">{</a>
<a name="ln2299">  int ret;</a>
<a name="ln2300">  struct prefix p;</a>
<a name="ln2301">  struct route_node *rn;</a>
<a name="ln2302"> </a>
<a name="ln2303">  ret = str2prefix_ipv6 (argv[0], (struct prefix_ipv6 *) &amp;p);</a>
<a name="ln2304">  if (ret &lt;= 0)</a>
<a name="ln2305">    {</a>
<a name="ln2306">      vty_out (vty, &quot;Malformed address%s&quot;, VTY_NEWLINE);</a>
<a name="ln2307">      return CMD_WARNING;</a>
<a name="ln2308">    }</a>
<a name="ln2309"> </a>
<a name="ln2310">  rn = route_node_lookup (ripng-&gt;aggregate, &amp;p);</a>
<a name="ln2311">  if (! rn)</a>
<a name="ln2312">    {</a>
<a name="ln2313">      vty_out (vty, &quot;Can't find aggregate route.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2314">      return CMD_WARNING;</a>
<a name="ln2315">    }</a>
<a name="ln2316">  route_unlock_node (rn);</a>
<a name="ln2317">  rn-&gt;info = NULL;</a>
<a name="ln2318">  route_unlock_node (rn);</a>
<a name="ln2319"> </a>
<a name="ln2320">  ripng_aggregate_delete (&amp;p);</a>
<a name="ln2321"> </a>
<a name="ln2322">  return CMD_SUCCESS;</a>
<a name="ln2323">}</a>
<a name="ln2324"> </a>
<a name="ln2325">DEFUN (ripng_default_metric,</a>
<a name="ln2326">       ripng_default_metric_cmd,</a>
<a name="ln2327">       &quot;default-metric &lt;1-16&gt;&quot;,</a>
<a name="ln2328">       &quot;Set a metric of redistribute routes\n&quot;</a>
<a name="ln2329">       &quot;Default metric\n&quot;)</a>
<a name="ln2330">{</a>
<a name="ln2331">  if (ripng)</a>
<a name="ln2332">    {</a>
<a name="ln2333">      ripng-&gt;default_metric = atoi (argv[0]);</a>
<a name="ln2334">    }</a>
<a name="ln2335">  return CMD_SUCCESS;</a>
<a name="ln2336">}</a>
<a name="ln2337"> </a>
<a name="ln2338">DEFUN (no_ripng_default_metric,</a>
<a name="ln2339">       no_ripng_default_metric_cmd,</a>
<a name="ln2340">       &quot;no default-metric&quot;,</a>
<a name="ln2341">       NO_STR</a>
<a name="ln2342">       &quot;Set a metric of redistribute routes\n&quot;</a>
<a name="ln2343">       &quot;Default metric\n&quot;)</a>
<a name="ln2344">{</a>
<a name="ln2345">  if (ripng)</a>
<a name="ln2346">    {</a>
<a name="ln2347">      ripng-&gt;default_metric = RIPNG_DEFAULT_METRIC_DEFAULT;</a>
<a name="ln2348">    }</a>
<a name="ln2349">  return CMD_SUCCESS;</a>
<a name="ln2350">}</a>
<a name="ln2351"> </a>
<a name="ln2352">ALIAS (no_ripng_default_metric,</a>
<a name="ln2353">       no_ripng_default_metric_val_cmd,</a>
<a name="ln2354">       &quot;no default-metric &lt;1-16&gt;&quot;,</a>
<a name="ln2355">       NO_STR</a>
<a name="ln2356">       &quot;Set a metric of redistribute routes\n&quot;</a>
<a name="ln2357">       &quot;Default metric\n&quot;)</a>
<a name="ln2358"> </a>
<a name="ln2359">#if 0</a>
<a name="ln2360">/* RIPng update timer setup. */</a>
<a name="ln2361">DEFUN (ripng_update_timer,</a>
<a name="ln2362">       ripng_update_timer_cmd,</a>
<a name="ln2363">       &quot;update-timer SECOND&quot;,</a>
<a name="ln2364">       &quot;Set RIPng update timer in seconds\n&quot;</a>
<a name="ln2365">       &quot;Seconds\n&quot;)</a>
<a name="ln2366">{</a>
<a name="ln2367">  unsigned long update;</a>
<a name="ln2368">  char *endptr = NULL;</a>
<a name="ln2369"> </a>
<a name="ln2370">  update = strtoul (argv[0], &amp;endptr, 10);</a>
<a name="ln2371">  if (update == ULONG_MAX || *endptr != '\0')</a>
<a name="ln2372">    {</a>
<a name="ln2373">      vty_out (vty, &quot;update timer value error%s&quot;, VTY_NEWLINE);</a>
<a name="ln2374">      return CMD_WARNING;</a>
<a name="ln2375">    }</a>
<a name="ln2376"> </a>
<a name="ln2377">  ripng-&gt;update_time = update;</a>
<a name="ln2378"> </a>
<a name="ln2379">  ripng_event (RIPNG_UPDATE_EVENT, 0);</a>
<a name="ln2380">  return CMD_SUCCESS;</a>
<a name="ln2381">}</a>
<a name="ln2382"> </a>
<a name="ln2383">DEFUN (no_ripng_update_timer,</a>
<a name="ln2384">       no_ripng_update_timer_cmd,</a>
<a name="ln2385">       &quot;no update-timer SECOND&quot;,</a>
<a name="ln2386">       NO_STR</a>
<a name="ln2387">       &quot;Unset RIPng update timer in seconds\n&quot;</a>
<a name="ln2388">       &quot;Seconds\n&quot;)</a>
<a name="ln2389">{</a>
<a name="ln2390">  ripng-&gt;update_time = RIPNG_UPDATE_TIMER_DEFAULT;</a>
<a name="ln2391">  ripng_event (RIPNG_UPDATE_EVENT, 0);</a>
<a name="ln2392">  return CMD_SUCCESS;</a>
<a name="ln2393">}</a>
<a name="ln2394"> </a>
<a name="ln2395">/* RIPng timeout timer setup. */</a>
<a name="ln2396">DEFUN (ripng_timeout_timer,</a>
<a name="ln2397">       ripng_timeout_timer_cmd,</a>
<a name="ln2398">       &quot;timeout-timer SECOND&quot;,</a>
<a name="ln2399">       &quot;Set RIPng timeout timer in seconds\n&quot;</a>
<a name="ln2400">       &quot;Seconds\n&quot;)</a>
<a name="ln2401">{</a>
<a name="ln2402">  unsigned long timeout;</a>
<a name="ln2403">  char *endptr = NULL;</a>
<a name="ln2404"> </a>
<a name="ln2405">  timeout = strtoul (argv[0], &amp;endptr, 10);</a>
<a name="ln2406">  if (timeout == ULONG_MAX || *endptr != '\0')</a>
<a name="ln2407">    {</a>
<a name="ln2408">      vty_out (vty, &quot;timeout timer value error%s&quot;, VTY_NEWLINE);</a>
<a name="ln2409">      return CMD_WARNING;</a>
<a name="ln2410">    }</a>
<a name="ln2411"> </a>
<a name="ln2412">  ripng-&gt;timeout_time = timeout;</a>
<a name="ln2413"> </a>
<a name="ln2414">  return CMD_SUCCESS;</a>
<a name="ln2415">}</a>
<a name="ln2416"> </a>
<a name="ln2417">DEFUN (no_ripng_timeout_timer,</a>
<a name="ln2418">       no_ripng_timeout_timer_cmd,</a>
<a name="ln2419">       &quot;no timeout-timer SECOND&quot;,</a>
<a name="ln2420">       NO_STR</a>
<a name="ln2421">       &quot;Unset RIPng timeout timer in seconds\n&quot;</a>
<a name="ln2422">       &quot;Seconds\n&quot;)</a>
<a name="ln2423">{</a>
<a name="ln2424">  ripng-&gt;timeout_time = RIPNG_TIMEOUT_TIMER_DEFAULT;</a>
<a name="ln2425">  return CMD_SUCCESS;</a>
<a name="ln2426">}</a>
<a name="ln2427"> </a>
<a name="ln2428">/* RIPng garbage timer setup. */</a>
<a name="ln2429">DEFUN (ripng_garbage_timer,</a>
<a name="ln2430">       ripng_garbage_timer_cmd,</a>
<a name="ln2431">       &quot;garbage-timer SECOND&quot;,</a>
<a name="ln2432">       &quot;Set RIPng garbage timer in seconds\n&quot;</a>
<a name="ln2433">       &quot;Seconds\n&quot;)</a>
<a name="ln2434">{</a>
<a name="ln2435">  unsigned long garbage;</a>
<a name="ln2436">  char *endptr = NULL;</a>
<a name="ln2437"> </a>
<a name="ln2438">  garbage = strtoul (argv[0], &amp;endptr, 10);</a>
<a name="ln2439">  if (garbage == ULONG_MAX || *endptr != '\0')</a>
<a name="ln2440">    {</a>
<a name="ln2441">      vty_out (vty, &quot;garbage timer value error%s&quot;, VTY_NEWLINE);</a>
<a name="ln2442">      return CMD_WARNING;</a>
<a name="ln2443">    }</a>
<a name="ln2444"> </a>
<a name="ln2445">  ripng-&gt;garbage_time = garbage;</a>
<a name="ln2446"> </a>
<a name="ln2447">  return CMD_SUCCESS;</a>
<a name="ln2448">}</a>
<a name="ln2449"> </a>
<a name="ln2450">DEFUN (no_ripng_garbage_timer,</a>
<a name="ln2451">       no_ripng_garbage_timer_cmd,</a>
<a name="ln2452">       &quot;no garbage-timer SECOND&quot;,</a>
<a name="ln2453">       NO_STR</a>
<a name="ln2454">       &quot;Unset RIPng garbage timer in seconds\n&quot;</a>
<a name="ln2455">       &quot;Seconds\n&quot;)</a>
<a name="ln2456">{</a>
<a name="ln2457">  ripng-&gt;garbage_time = RIPNG_GARBAGE_TIMER_DEFAULT;</a>
<a name="ln2458">  return CMD_SUCCESS;</a>
<a name="ln2459">}</a>
<a name="ln2460">#endif /* 0 */</a>
<a name="ln2461"> </a>
<a name="ln2462">DEFUN (ripng_timers,</a>
<a name="ln2463">       ripng_timers_cmd,</a>
<a name="ln2464">       &quot;timers basic &lt;0-65535&gt; &lt;0-65535&gt; &lt;0-65535&gt;&quot;,</a>
<a name="ln2465">       &quot;RIPng timers setup\n&quot;</a>
<a name="ln2466">       &quot;Basic timer\n&quot;</a>
<a name="ln2467">       &quot;Routing table update timer value in second. Default is 30.\n&quot;</a>
<a name="ln2468">       &quot;Routing information timeout timer. Default is 180.\n&quot;</a>
<a name="ln2469">       &quot;Garbage collection timer. Default is 120.\n&quot;)</a>
<a name="ln2470">{</a>
<a name="ln2471">  unsigned long update;</a>
<a name="ln2472">  unsigned long timeout;</a>
<a name="ln2473">  unsigned long garbage;</a>
<a name="ln2474"> </a>
<a name="ln2475">  VTY_GET_INTEGER_RANGE(&quot;update timer&quot;, update, argv[0], 0, 65535);</a>
<a name="ln2476">  VTY_GET_INTEGER_RANGE(&quot;timeout timer&quot;, timeout, argv[1], 0, 65535);</a>
<a name="ln2477">  VTY_GET_INTEGER_RANGE(&quot;garbage timer&quot;, garbage, argv[2], 0, 65535);</a>
<a name="ln2478"> </a>
<a name="ln2479">  /* Set each timer value. */</a>
<a name="ln2480">  ripng-&gt;update_time = update;</a>
<a name="ln2481">  ripng-&gt;timeout_time = timeout;</a>
<a name="ln2482">  ripng-&gt;garbage_time = garbage;</a>
<a name="ln2483"> </a>
<a name="ln2484">  /* Reset update timer thread. */</a>
<a name="ln2485">  ripng_event (RIPNG_UPDATE_EVENT, 0);</a>
<a name="ln2486"> </a>
<a name="ln2487">  return CMD_SUCCESS;</a>
<a name="ln2488">}</a>
<a name="ln2489"> </a>
<a name="ln2490">DEFUN (no_ripng_timers,</a>
<a name="ln2491">       no_ripng_timers_cmd,</a>
<a name="ln2492">       &quot;no timers basic&quot;,</a>
<a name="ln2493">       NO_STR</a>
<a name="ln2494">       &quot;RIPng timers setup\n&quot;</a>
<a name="ln2495">       &quot;Basic timer\n&quot;)</a>
<a name="ln2496">{</a>
<a name="ln2497">  /* Set each timer value to the default. */</a>
<a name="ln2498">  ripng-&gt;update_time = RIPNG_UPDATE_TIMER_DEFAULT;</a>
<a name="ln2499">  ripng-&gt;timeout_time = RIPNG_TIMEOUT_TIMER_DEFAULT;</a>
<a name="ln2500">  ripng-&gt;garbage_time = RIPNG_GARBAGE_TIMER_DEFAULT;</a>
<a name="ln2501"> </a>
<a name="ln2502">  /* Reset update timer thread. */</a>
<a name="ln2503">  ripng_event (RIPNG_UPDATE_EVENT, 0);</a>
<a name="ln2504"> </a>
<a name="ln2505">  return CMD_SUCCESS;</a>
<a name="ln2506">}</a>
<a name="ln2507"> </a>
<a name="ln2508">ALIAS (no_ripng_timers,</a>
<a name="ln2509">       no_ripng_timers_val_cmd,</a>
<a name="ln2510">       &quot;no timers basic &lt;0-65535&gt; &lt;0-65535&gt; &lt;0-65535&gt;&quot;,</a>
<a name="ln2511">       NO_STR</a>
<a name="ln2512">       &quot;RIPng timers setup\n&quot;</a>
<a name="ln2513">       &quot;Basic timer\n&quot;</a>
<a name="ln2514">       &quot;Routing table update timer value in second. Default is 30.\n&quot;</a>
<a name="ln2515">       &quot;Routing information timeout timer. Default is 180.\n&quot;</a>
<a name="ln2516">       &quot;Garbage collection timer. Default is 120.\n&quot;)</a>
<a name="ln2517"> </a>
<a name="ln2518">DEFUN (show_ipv6_protocols, show_ipv6_protocols_cmd,</a>
<a name="ln2519">       &quot;show ipv6 protocols&quot;,</a>
<a name="ln2520">       SHOW_STR</a>
<a name="ln2521">       IPV6_STR</a>
<a name="ln2522">       &quot;Routing protocol information&quot;)</a>
<a name="ln2523">{</a>
<a name="ln2524">  if (! ripng)</a>
<a name="ln2525">    return CMD_SUCCESS;</a>
<a name="ln2526"> </a>
<a name="ln2527">  vty_out (vty, &quot;Routing Protocol is \&quot;ripng\&quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln2528">  </a>
<a name="ln2529">  vty_out (vty, &quot;Sending updates every %ld seconds, next due in %d seconds%s&quot;,</a>
<a name="ln2530">	   ripng-&gt;update_time, 0,</a>
<a name="ln2531">	   VTY_NEWLINE);</a>
<a name="ln2532"> </a>
<a name="ln2533">  vty_out (vty, &quot;Timerout after %ld seconds, garbage correct %ld%s&quot;,</a>
<a name="ln2534">	   ripng-&gt;timeout_time,</a>
<a name="ln2535">	   ripng-&gt;garbage_time,</a>
<a name="ln2536">	   VTY_NEWLINE);</a>
<a name="ln2537"> </a>
<a name="ln2538">  vty_out (vty, &quot;Outgoing update filter list for all interfaces is not set&quot;);</a>
<a name="ln2539">  vty_out (vty, &quot;Incoming update filter list for all interfaces is not set&quot;);</a>
<a name="ln2540"> </a>
<a name="ln2541">  return CMD_SUCCESS;</a>
<a name="ln2542">}</a>
<a name="ln2543"> </a>
<a name="ln2544">/* Please be carefull to use this command. */</a>
<a name="ln2545">DEFUN (ripng_default_information_originate,</a>
<a name="ln2546">       ripng_default_information_originate_cmd,</a>
<a name="ln2547">       &quot;default-information originate&quot;,</a>
<a name="ln2548">       &quot;Default route information\n&quot;</a>
<a name="ln2549">       &quot;Distribute default route\n&quot;)</a>
<a name="ln2550">{</a>
<a name="ln2551">  struct prefix_ipv6 p;</a>
<a name="ln2552"> </a>
<a name="ln2553">  if (! ripng -&gt;default_information) {</a>
<a name="ln2554">    ripng-&gt;default_information = 1;</a>
<a name="ln2555"> </a>
<a name="ln2556">    str2prefix_ipv6 (&quot;::/0&quot;, &amp;p);</a>
<a name="ln2557">    ripng_redistribute_add (ZEBRA_ROUTE_RIPNG, RIPNG_ROUTE_DEFAULT, &amp;p, 0, NULL, 0);</a>
<a name="ln2558">  }</a>
<a name="ln2559"> </a>
<a name="ln2560">  return CMD_SUCCESS;</a>
<a name="ln2561">}</a>
<a name="ln2562"> </a>
<a name="ln2563">DEFUN (no_ripng_default_information_originate,</a>
<a name="ln2564">       no_ripng_default_information_originate_cmd,</a>
<a name="ln2565">       &quot;no default-information originate&quot;,</a>
<a name="ln2566">       NO_STR</a>
<a name="ln2567">       &quot;Default route information\n&quot;</a>
<a name="ln2568">       &quot;Distribute default route\n&quot;)</a>
<a name="ln2569">{</a>
<a name="ln2570">  struct prefix_ipv6 p;</a>
<a name="ln2571"> </a>
<a name="ln2572">  if (ripng-&gt;default_information) {</a>
<a name="ln2573">    ripng-&gt;default_information = 0;</a>
<a name="ln2574"> </a>
<a name="ln2575">    str2prefix_ipv6 (&quot;::/0&quot;, &amp;p);</a>
<a name="ln2576">    ripng_redistribute_delete (ZEBRA_ROUTE_RIPNG, RIPNG_ROUTE_DEFAULT, &amp;p, 0);</a>
<a name="ln2577">  }</a>
<a name="ln2578"> </a>
<a name="ln2579">  return CMD_SUCCESS;</a>
<a name="ln2580">}</a>
<a name="ln2581"> </a>
<a name="ln2582">/* Update ECMP routes to zebra when ECMP is disabled. */</a>
<a name="ln2583">static void</a>
<a name="ln2584">ripng_ecmp_disable (void)</a>
<a name="ln2585">{</a>
<a name="ln2586">  struct route_node *rp;</a>
<a name="ln2587">  struct ripng_info *rinfo, *tmp_rinfo;</a>
<a name="ln2588">  struct list *list;</a>
<a name="ln2589">  struct listnode *node, *nextnode;</a>
<a name="ln2590"> </a>
<a name="ln2591">  if (!ripng)</a>
<a name="ln2592">    return;</a>
<a name="ln2593"> </a>
<a name="ln2594">  for (rp = route_top (ripng-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln2595">    if ((list = rp-&gt;info) != NULL &amp;&amp; listcount (list) &gt; 1)</a>
<a name="ln2596">      {</a>
<a name="ln2597">        rinfo = listgetdata (listhead (list));</a>
<a name="ln2598">        if (!ripng_route_rte (rinfo))</a>
<a name="ln2599">          continue;</a>
<a name="ln2600"> </a>
<a name="ln2601">        /* Drop all other entries, except the first one. */</a>
<a name="ln2602">        for (ALL_LIST_ELEMENTS (list, node, nextnode, tmp_rinfo))</a>
<a name="ln2603">          if (tmp_rinfo != rinfo)</a>
<a name="ln2604">            {</a>
<a name="ln2605">              RIPNG_TIMER_OFF (tmp_rinfo-&gt;t_timeout);</a>
<a name="ln2606">              RIPNG_TIMER_OFF (tmp_rinfo-&gt;t_garbage_collect);</a>
<a name="ln2607">              list_delete_node (list, node);</a>
<a name="ln2608">              ripng_info_free (tmp_rinfo);</a>
<a name="ln2609">            }</a>
<a name="ln2610"> </a>
<a name="ln2611">        /* Update zebra. */</a>
<a name="ln2612">        ripng_zebra_ipv6_add (rp);</a>
<a name="ln2613"> </a>
<a name="ln2614">        /* Set the route change flag. */</a>
<a name="ln2615">        SET_FLAG (rinfo-&gt;flags, RIPNG_RTF_CHANGED);</a>
<a name="ln2616"> </a>
<a name="ln2617">        /* Signal the output process to trigger an update. */</a>
<a name="ln2618">        ripng_event (RIPNG_TRIGGERED_UPDATE, 0);</a>
<a name="ln2619">      }</a>
<a name="ln2620">}</a>
<a name="ln2621"> </a>
<a name="ln2622">DEFUN (ripng_allow_ecmp,</a>
<a name="ln2623">       ripng_allow_ecmp_cmd,</a>
<a name="ln2624">       &quot;allow-ecmp&quot;,</a>
<a name="ln2625">       &quot;Allow Equal Cost MultiPath\n&quot;)</a>
<a name="ln2626">{</a>
<a name="ln2627">  if (ripng-&gt;ecmp)</a>
<a name="ln2628">    {</a>
<a name="ln2629">      vty_out (vty, &quot;ECMP is already enabled.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2630">      return CMD_WARNING;</a>
<a name="ln2631">    }</a>
<a name="ln2632"> </a>
<a name="ln2633">  ripng-&gt;ecmp = 1;</a>
<a name="ln2634">  zlog_info (&quot;ECMP is enabled.&quot;);</a>
<a name="ln2635">  return CMD_SUCCESS;</a>
<a name="ln2636">}</a>
<a name="ln2637"> </a>
<a name="ln2638">DEFUN (no_ripng_allow_ecmp,</a>
<a name="ln2639">       no_ripng_allow_ecmp_cmd,</a>
<a name="ln2640">       &quot;no allow-ecmp&quot;,</a>
<a name="ln2641">       NO_STR</a>
<a name="ln2642">       &quot;Allow Equal Cost MultiPath\n&quot;)</a>
<a name="ln2643">{</a>
<a name="ln2644">  if (!ripng-&gt;ecmp)</a>
<a name="ln2645">    {</a>
<a name="ln2646">      vty_out (vty, &quot;ECMP is already disabled.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2647">      return CMD_WARNING;</a>
<a name="ln2648">    }</a>
<a name="ln2649"> </a>
<a name="ln2650">  ripng-&gt;ecmp = 0;</a>
<a name="ln2651">  zlog_info (&quot;ECMP is disabled.&quot;);</a>
<a name="ln2652">  ripng_ecmp_disable ();</a>
<a name="ln2653">  return CMD_SUCCESS;</a>
<a name="ln2654">}</a>
<a name="ln2655"> </a>
<a name="ln2656">/* RIPng configuration write function. */</a>
<a name="ln2657">static int</a>
<a name="ln2658">ripng_config_write (struct vty *vty)</a>
<a name="ln2659">{</a>
<a name="ln2660">  int ripng_network_write (struct vty *, int);</a>
<a name="ln2661">  void ripng_redistribute_write (struct vty *, int);</a>
<a name="ln2662">  int write = 0;</a>
<a name="ln2663">  struct route_node *rp;</a>
<a name="ln2664"> </a>
<a name="ln2665">  if (ripng)</a>
<a name="ln2666">    {</a>
<a name="ln2667"> </a>
<a name="ln2668">      /* RIPng router. */</a>
<a name="ln2669">      vty_out (vty, &quot;router ripng%s&quot;, VTY_NEWLINE);</a>
<a name="ln2670"> </a>
<a name="ln2671">      if (ripng-&gt;default_information)</a>
<a name="ln2672">	vty_out (vty, &quot; default-information originate%s&quot;, VTY_NEWLINE);</a>
<a name="ln2673"> </a>
<a name="ln2674">      ripng_network_write (vty, 1);</a>
<a name="ln2675"> </a>
<a name="ln2676">      /* RIPng default metric configuration */</a>
<a name="ln2677">      if (ripng-&gt;default_metric != RIPNG_DEFAULT_METRIC_DEFAULT)</a>
<a name="ln2678">        vty_out (vty, &quot; default-metric %d%s&quot;,</a>
<a name="ln2679">		 ripng-&gt;default_metric, VTY_NEWLINE);</a>
<a name="ln2680"> </a>
<a name="ln2681">      ripng_redistribute_write (vty, 1);</a>
<a name="ln2682"> </a>
<a name="ln2683">      /* RIP offset-list configuration. */</a>
<a name="ln2684">      config_write_ripng_offset_list (vty);</a>
<a name="ln2685">      </a>
<a name="ln2686">      /* RIPng aggregate routes. */</a>
<a name="ln2687">      for (rp = route_top (ripng-&gt;aggregate); rp; rp = route_next (rp))</a>
<a name="ln2688">	if (rp-&gt;info != NULL)</a>
<a name="ln2689">	  vty_out (vty, &quot; aggregate-address %s/%d%s&quot;, </a>
<a name="ln2690">		   inet6_ntoa (rp-&gt;p.u.prefix6),</a>
<a name="ln2691">		   rp-&gt;p.prefixlen, </a>
<a name="ln2692"> </a>
<a name="ln2693">		   VTY_NEWLINE);</a>
<a name="ln2694"> </a>
<a name="ln2695">      /* ECMP configuration. */</a>
<a name="ln2696">      if (ripng-&gt;ecmp)</a>
<a name="ln2697">        vty_out (vty, &quot; allow-ecmp%s&quot;, VTY_NEWLINE);</a>
<a name="ln2698"> </a>
<a name="ln2699">      /* RIPng static routes. */</a>
<a name="ln2700">      for (rp = route_top (ripng-&gt;route); rp; rp = route_next (rp))</a>
<a name="ln2701">	if (rp-&gt;info != NULL)</a>
<a name="ln2702">	  vty_out (vty, &quot; route %s/%d%s&quot;, inet6_ntoa (rp-&gt;p.u.prefix6),</a>
<a name="ln2703">		   rp-&gt;p.prefixlen,</a>
<a name="ln2704">		   VTY_NEWLINE);</a>
<a name="ln2705"> </a>
<a name="ln2706">      /* RIPng timers configuration. */</a>
<a name="ln2707">      if (ripng-&gt;update_time != RIPNG_UPDATE_TIMER_DEFAULT ||</a>
<a name="ln2708">	  ripng-&gt;timeout_time != RIPNG_TIMEOUT_TIMER_DEFAULT ||</a>
<a name="ln2709">	  ripng-&gt;garbage_time != RIPNG_GARBAGE_TIMER_DEFAULT)</a>
<a name="ln2710">	{</a>
<a name="ln2711">	  vty_out (vty, &quot; timers basic %ld %ld %ld%s&quot;,</a>
<a name="ln2712">		   ripng-&gt;update_time,</a>
<a name="ln2713">		   ripng-&gt;timeout_time,</a>
<a name="ln2714">		   ripng-&gt;garbage_time,</a>
<a name="ln2715">		   VTY_NEWLINE);</a>
<a name="ln2716">	}</a>
<a name="ln2717">#if 0</a>
<a name="ln2718">      if (ripng-&gt;update_time != RIPNG_UPDATE_TIMER_DEFAULT)</a>
<a name="ln2719">	vty_out (vty, &quot; update-timer %d%s&quot;, ripng-&gt;update_time,</a>
<a name="ln2720">		 VTY_NEWLINE);</a>
<a name="ln2721">      if (ripng-&gt;timeout_time != RIPNG_TIMEOUT_TIMER_DEFAULT)</a>
<a name="ln2722">	vty_out (vty, &quot; timeout-timer %d%s&quot;, ripng-&gt;timeout_time,</a>
<a name="ln2723">		 VTY_NEWLINE);</a>
<a name="ln2724">      if (ripng-&gt;garbage_time != RIPNG_GARBAGE_TIMER_DEFAULT)</a>
<a name="ln2725">	vty_out (vty, &quot; garbage-timer %d%s&quot;, ripng-&gt;garbage_time,</a>
<a name="ln2726">		 VTY_NEWLINE);</a>
<a name="ln2727">#endif /* 0 */</a>
<a name="ln2728"> </a>
<a name="ln2729">      write += config_write_distribute (vty);</a>
<a name="ln2730"> </a>
<a name="ln2731">      write += config_write_if_rmap (vty);</a>
<a name="ln2732"> </a>
<a name="ln2733">      write++;</a>
<a name="ln2734">    }</a>
<a name="ln2735">  return write;</a>
<a name="ln2736">}</a>
<a name="ln2737"> </a>
<a name="ln2738">/* RIPng node structure. */</a>
<a name="ln2739">static struct cmd_node cmd_ripng_node =</a>
<a name="ln2740">{</a>
<a name="ln2741">  RIPNG_NODE,</a>
<a name="ln2742">  &quot;%s(config-router)# &quot;,</a>
<a name="ln2743">  1,</a>
<a name="ln2744">};</a>
<a name="ln2745"> </a>
<a name="ln2746">static void</a>
<a name="ln2747">ripng_distribute_update (struct distribute *dist)</a>
<a name="ln2748">{</a>
<a name="ln2749">  struct interface *ifp;</a>
<a name="ln2750">  struct ripng_interface *ri;</a>
<a name="ln2751">  struct access_list *alist;</a>
<a name="ln2752">  struct prefix_list *plist;</a>
<a name="ln2753"> </a>
<a name="ln2754">  if (! dist-&gt;ifname)</a>
<a name="ln2755">    return;</a>
<a name="ln2756"> </a>
<a name="ln2757">  ifp = if_lookup_by_name (dist-&gt;ifname);</a>
<a name="ln2758">  if (ifp == NULL)</a>
<a name="ln2759">    return;</a>
<a name="ln2760"> </a>
<a name="ln2761">  ri = ifp-&gt;info;</a>
<a name="ln2762"> </a>
<a name="ln2763">  if (dist-&gt;list[DISTRIBUTE_V6_IN])</a>
<a name="ln2764">    {</a>
<a name="ln2765">      alist = access_list_lookup (AFI_IP6, dist-&gt;list[DISTRIBUTE_V6_IN]);</a>
<a name="ln2766">      if (alist)</a>
<a name="ln2767">	ri-&gt;list[RIPNG_FILTER_IN] = alist;</a>
<a name="ln2768">      else</a>
<a name="ln2769">	ri-&gt;list[RIPNG_FILTER_IN] = NULL;</a>
<a name="ln2770">    }</a>
<a name="ln2771">  else</a>
<a name="ln2772">    ri-&gt;list[RIPNG_FILTER_IN] = NULL;</a>
<a name="ln2773"> </a>
<a name="ln2774">  if (dist-&gt;list[DISTRIBUTE_V6_OUT])</a>
<a name="ln2775">    {</a>
<a name="ln2776">      alist = access_list_lookup (AFI_IP6, dist-&gt;list[DISTRIBUTE_V6_OUT]);</a>
<a name="ln2777">      if (alist)</a>
<a name="ln2778">	ri-&gt;list[RIPNG_FILTER_OUT] = alist;</a>
<a name="ln2779">      else</a>
<a name="ln2780">	ri-&gt;list[RIPNG_FILTER_OUT] = NULL;</a>
<a name="ln2781">    }</a>
<a name="ln2782">  else</a>
<a name="ln2783">    ri-&gt;list[RIPNG_FILTER_OUT] = NULL;</a>
<a name="ln2784"> </a>
<a name="ln2785">  if (dist-&gt;prefix[DISTRIBUTE_V6_IN])</a>
<a name="ln2786">    {</a>
<a name="ln2787">      plist = prefix_list_lookup (AFI_IP6, dist-&gt;prefix[DISTRIBUTE_V6_IN]);</a>
<a name="ln2788">      if (plist)</a>
<a name="ln2789">	ri-&gt;prefix[RIPNG_FILTER_IN] = plist;</a>
<a name="ln2790">      else</a>
<a name="ln2791">	ri-&gt;prefix[RIPNG_FILTER_IN] = NULL;</a>
<a name="ln2792">    }</a>
<a name="ln2793">  else</a>
<a name="ln2794">    ri-&gt;prefix[RIPNG_FILTER_IN] = NULL;</a>
<a name="ln2795"> </a>
<a name="ln2796">  if (dist-&gt;prefix[DISTRIBUTE_V6_OUT])</a>
<a name="ln2797">    {</a>
<a name="ln2798">      plist = prefix_list_lookup (AFI_IP6, dist-&gt;prefix[DISTRIBUTE_V6_OUT]);</a>
<a name="ln2799">      if (plist)</a>
<a name="ln2800">	ri-&gt;prefix[RIPNG_FILTER_OUT] = plist;</a>
<a name="ln2801">      else</a>
<a name="ln2802">	ri-&gt;prefix[RIPNG_FILTER_OUT] = NULL;</a>
<a name="ln2803">    }</a>
<a name="ln2804">  else</a>
<a name="ln2805">    ri-&gt;prefix[RIPNG_FILTER_OUT] = NULL;</a>
<a name="ln2806">}</a>
<a name="ln2807"> </a>
<a name="ln2808">void</a>
<a name="ln2809">ripng_distribute_update_interface (struct interface *ifp)</a>
<a name="ln2810">{</a>
<a name="ln2811">  struct distribute *dist;</a>
<a name="ln2812"> </a>
<a name="ln2813">  dist = distribute_lookup (ifp-&gt;name);</a>
<a name="ln2814">  if (dist)</a>
<a name="ln2815">    ripng_distribute_update (dist);</a>
<a name="ln2816">}</a>
<a name="ln2817"> </a>
<a name="ln2818">/* Update all interface's distribute list. */</a>
<a name="ln2819">static void</a>
<a name="ln2820">ripng_distribute_update_all (struct prefix_list *notused)</a>
<a name="ln2821">{</a>
<a name="ln2822">  struct interface *ifp;</a>
<a name="ln2823">  struct listnode *node;</a>
<a name="ln2824"> </a>
<a name="ln2825">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln2826">    ripng_distribute_update_interface (ifp);</a>
<a name="ln2827">}</a>
<a name="ln2828"> </a>
<a name="ln2829">static void</a>
<a name="ln2830">ripng_distribute_update_all_wrapper (const char *notused)</a>
<a name="ln2831">{</a>
<a name="ln2832">  ripng_distribute_update_all(NULL);</a>
<a name="ln2833">}</a>
<a name="ln2834"> </a>
<a name="ln2835">/* delete all the added ripng routes. */</a>
<a name="ln2836">void</a>
<a name="ln2837">ripng_clean()</a>
<a name="ln2838">{</a>
<a name="ln2839">  int i;</a>
<a name="ln2840">  struct route_node *rp;</a>
<a name="ln2841">  struct ripng_info *rinfo;</a>
<a name="ln2842">  struct ripng_aggregate *aggregate;</a>
<a name="ln2843">  struct list *list = NULL;</a>
<a name="ln2844">  struct listnode *listnode = NULL;</a>
<a name="ln2845"> </a>
<a name="ln2846">  if (ripng) {</a>
<a name="ln2847">    /* Clear RIPng routes */</a>
<a name="ln2848">    for (rp = route_top (ripng-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln2849">      {</a>
<a name="ln2850">        if ((list = rp-&gt;info) != NULL)</a>
<a name="ln2851">          {</a>
<a name="ln2852">            rinfo = listgetdata (listhead (list));</a>
<a name="ln2853">            if (ripng_route_rte (rinfo))</a>
<a name="ln2854">              ripng_zebra_ipv6_delete (rp);</a>
<a name="ln2855"> </a>
<a name="ln2856">            for (ALL_LIST_ELEMENTS_RO (list, listnode, rinfo))</a>
<a name="ln2857">              {</a>
<a name="ln2858">                RIPNG_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln2859">                RIPNG_TIMER_OFF (rinfo-&gt;t_garbage_collect);</a>
<a name="ln2860">                ripng_info_free (rinfo);</a>
<a name="ln2861">              }</a>
<a name="ln2862">            list_delete (list);</a>
<a name="ln2863">            rp-&gt;info = NULL;</a>
<a name="ln2864">            route_unlock_node (rp);</a>
<a name="ln2865">          }</a>
<a name="ln2866"> </a>
<a name="ln2867">        if ((aggregate = rp-&gt;aggregate) != NULL)</a>
<a name="ln2868">          {</a>
<a name="ln2869">            ripng_aggregate_free (aggregate);</a>
<a name="ln2870">            rp-&gt;aggregate = NULL;</a>
<a name="ln2871">            route_unlock_node (rp);</a>
<a name="ln2872">          }</a>
<a name="ln2873">    }</a>
<a name="ln2874"> </a>
<a name="ln2875">    /* Cancel the RIPng timers */</a>
<a name="ln2876">    RIPNG_TIMER_OFF (ripng-&gt;t_update);</a>
<a name="ln2877">    RIPNG_TIMER_OFF (ripng-&gt;t_triggered_update);</a>
<a name="ln2878">    RIPNG_TIMER_OFF (ripng-&gt;t_triggered_interval);</a>
<a name="ln2879"> </a>
<a name="ln2880">    /* Cancel the read thread */</a>
<a name="ln2881">    if (ripng-&gt;t_read) {</a>
<a name="ln2882">      thread_cancel (ripng-&gt;t_read);</a>
<a name="ln2883">      ripng-&gt;t_read = NULL;</a>
<a name="ln2884">    }</a>
<a name="ln2885"> </a>
<a name="ln2886">    /* Close the RIPng socket */</a>
<a name="ln2887">    if (ripng-&gt;sock &gt;= 0) {</a>
<a name="ln2888">      close(ripng-&gt;sock);</a>
<a name="ln2889">      ripng-&gt;sock = -1;</a>
<a name="ln2890">    }</a>
<a name="ln2891"> </a>
<a name="ln2892">    /* Static RIPng route configuration. */</a>
<a name="ln2893">    for (rp = route_top (ripng-&gt;route); rp; rp = route_next (rp))</a>
<a name="ln2894">      if (rp-&gt;info) {</a>
<a name="ln2895">        rp-&gt;info = NULL;</a>
<a name="ln2896">        route_unlock_node (rp);</a>
<a name="ln2897">    }</a>
<a name="ln2898"> </a>
<a name="ln2899">    /* RIPng aggregated prefixes */</a>
<a name="ln2900">    for (rp = route_top (ripng-&gt;aggregate); rp; rp = route_next (rp))</a>
<a name="ln2901">      if (rp-&gt;info) {</a>
<a name="ln2902">          rp-&gt;info = NULL;</a>
<a name="ln2903">          route_unlock_node (rp);</a>
<a name="ln2904">    }</a>
<a name="ln2905"> </a>
<a name="ln2906">    for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln2907">      if (ripng-&gt;route_map[i].name)</a>
<a name="ln2908">        free (ripng-&gt;route_map[i].name);</a>
<a name="ln2909"> </a>
<a name="ln2910">    XFREE (MTYPE_ROUTE_TABLE, ripng-&gt;table);</a>
<a name="ln2911">    XFREE (MTYPE_ROUTE_TABLE, ripng-&gt;route);</a>
<a name="ln2912">    XFREE (MTYPE_ROUTE_TABLE, ripng-&gt;aggregate);</a>
<a name="ln2913"> </a>
<a name="ln2914">    XFREE (MTYPE_RIPNG, ripng);</a>
<a name="ln2915">    ripng = NULL;</a>
<a name="ln2916">  } /* if (ripng) */</a>
<a name="ln2917"> </a>
<a name="ln2918">  ripng_clean_network();</a>
<a name="ln2919">  ripng_passive_interface_clean ();</a>
<a name="ln2920">  ripng_offset_clean ();</a>
<a name="ln2921">  ripng_interface_clean ();</a>
<a name="ln2922">  ripng_redistribute_clean ();</a>
<a name="ln2923">}</a>
<a name="ln2924"> </a>
<a name="ln2925">/* Reset all values to the default settings. */</a>
<a name="ln2926">void</a>
<a name="ln2927">ripng_reset ()</a>
<a name="ln2928">{</a>
<a name="ln2929">  /* Call ripd related reset functions. */</a>
<a name="ln2930">  ripng_debug_reset ();</a>
<a name="ln2931">  ripng_route_map_reset ();</a>
<a name="ln2932"> </a>
<a name="ln2933">  /* Call library reset functions. */</a>
<a name="ln2934">  vty_reset ();</a>
<a name="ln2935">  access_list_reset ();</a>
<a name="ln2936">  prefix_list_reset ();</a>
<a name="ln2937"> </a>
<a name="ln2938">  distribute_list_reset ();</a>
<a name="ln2939"> </a>
<a name="ln2940">  ripng_interface_reset ();</a>
<a name="ln2941"> </a>
<a name="ln2942">  ripng_zclient_reset ();</a>
<a name="ln2943">}</a>
<a name="ln2944"> </a>
<a name="ln2945">static void</a>
<a name="ln2946">ripng_if_rmap_update (struct if_rmap *if_rmap)</a>
<a name="ln2947">{</a>
<a name="ln2948">  struct interface *ifp;</a>
<a name="ln2949">  struct ripng_interface *ri;</a>
<a name="ln2950">  struct route_map *rmap;</a>
<a name="ln2951"> </a>
<a name="ln2952">  ifp = if_lookup_by_name (if_rmap-&gt;ifname);</a>
<a name="ln2953">  if (ifp == NULL)</a>
<a name="ln2954">    return;</a>
<a name="ln2955"> </a>
<a name="ln2956">  ri = ifp-&gt;info;</a>
<a name="ln2957"> </a>
<a name="ln2958">  if (if_rmap-&gt;routemap[IF_RMAP_IN])</a>
<a name="ln2959">    {</a>
<a name="ln2960">      rmap = route_map_lookup_by_name (if_rmap-&gt;routemap[IF_RMAP_IN]);</a>
<a name="ln2961">      if (rmap)</a>
<a name="ln2962">	ri-&gt;routemap[IF_RMAP_IN] = rmap;</a>
<a name="ln2963">      else</a>
<a name="ln2964">	ri-&gt;routemap[IF_RMAP_IN] = NULL;</a>
<a name="ln2965">    }</a>
<a name="ln2966">  else</a>
<a name="ln2967">    ri-&gt;routemap[RIPNG_FILTER_IN] = NULL;</a>
<a name="ln2968"> </a>
<a name="ln2969">  if (if_rmap-&gt;routemap[IF_RMAP_OUT])</a>
<a name="ln2970">    {</a>
<a name="ln2971">      rmap = route_map_lookup_by_name (if_rmap-&gt;routemap[IF_RMAP_OUT]);</a>
<a name="ln2972">      if (rmap)</a>
<a name="ln2973">	ri-&gt;routemap[IF_RMAP_OUT] = rmap;</a>
<a name="ln2974">      else</a>
<a name="ln2975">	ri-&gt;routemap[IF_RMAP_OUT] = NULL;</a>
<a name="ln2976">    }</a>
<a name="ln2977">  else</a>
<a name="ln2978">    ri-&gt;routemap[RIPNG_FILTER_OUT] = NULL;</a>
<a name="ln2979">}</a>
<a name="ln2980"> </a>
<a name="ln2981">void</a>
<a name="ln2982">ripng_if_rmap_update_interface (struct interface *ifp)</a>
<a name="ln2983">{</a>
<a name="ln2984">  struct if_rmap *if_rmap;</a>
<a name="ln2985"> </a>
<a name="ln2986">  if_rmap = if_rmap_lookup (ifp-&gt;name);</a>
<a name="ln2987">  if (if_rmap)</a>
<a name="ln2988">    ripng_if_rmap_update (if_rmap);</a>
<a name="ln2989">}</a>
<a name="ln2990"> </a>
<a name="ln2991">static void</a>
<a name="ln2992">ripng_routemap_update_redistribute (void)</a>
<a name="ln2993">{</a>
<a name="ln2994">  int i;</a>
<a name="ln2995"> </a>
<a name="ln2996">  if (ripng)</a>
<a name="ln2997">    {</a>
<a name="ln2998">      for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++) </a>
<a name="ln2999">	{</a>
<a name="ln3000">	  if (ripng-&gt;route_map[i].name)</a>
<a name="ln3001">	    ripng-&gt;route_map[i].map = </a>
<a name="ln3002">	      route_map_lookup_by_name (ripng-&gt;route_map[i].name);</a>
<a name="ln3003">	}</a>
<a name="ln3004">    }</a>
<a name="ln3005">}</a>
<a name="ln3006"> </a>
<a name="ln3007">static void</a>
<a name="ln3008">ripng_routemap_update (const char *unused)</a>
<a name="ln3009">{</a>
<a name="ln3010">  struct interface *ifp;</a>
<a name="ln3011">  struct listnode *node;</a>
<a name="ln3012"> </a>
<a name="ln3013">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln3014">    ripng_if_rmap_update_interface (ifp);</a>
<a name="ln3015"> </a>
<a name="ln3016">  ripng_routemap_update_redistribute ();</a>
<a name="ln3017">}</a>
<a name="ln3018"> </a>
<a name="ln3019">/* Initialize ripng structure and set commands. */</a>
<a name="ln3020">void</a>
<a name="ln3021">ripng_init ()</a>
<a name="ln3022">{</a>
<a name="ln3023">  /* Randomize. */</a>
<a name="ln3024">  srandom (time (NULL));</a>
<a name="ln3025"> </a>
<a name="ln3026">  /* Install RIPNG_NODE. */</a>
<a name="ln3027">  install_node (&amp;cmd_ripng_node, ripng_config_write);</a>
<a name="ln3028"> </a>
<a name="ln3029">  /* Install ripng commands. */</a>
<a name="ln3030">  install_element (VIEW_NODE, &amp;show_ipv6_ripng_cmd);</a>
<a name="ln3031">  install_element (VIEW_NODE, &amp;show_ipv6_ripng_status_cmd);</a>
<a name="ln3032"> </a>
<a name="ln3033">  install_element (CONFIG_NODE, &amp;router_ripng_cmd);</a>
<a name="ln3034">  install_element (CONFIG_NODE, &amp;no_router_ripng_cmd);</a>
<a name="ln3035"> </a>
<a name="ln3036">  install_default (RIPNG_NODE);</a>
<a name="ln3037">  install_element (RIPNG_NODE, &amp;ripng_route_cmd);</a>
<a name="ln3038">  install_element (RIPNG_NODE, &amp;no_ripng_route_cmd);</a>
<a name="ln3039">  install_element (RIPNG_NODE, &amp;ripng_aggregate_address_cmd);</a>
<a name="ln3040">  install_element (RIPNG_NODE, &amp;no_ripng_aggregate_address_cmd);</a>
<a name="ln3041"> </a>
<a name="ln3042">  install_element (RIPNG_NODE, &amp;ripng_default_metric_cmd);</a>
<a name="ln3043">  install_element (RIPNG_NODE, &amp;no_ripng_default_metric_cmd);</a>
<a name="ln3044">  install_element (RIPNG_NODE, &amp;no_ripng_default_metric_val_cmd);</a>
<a name="ln3045"> </a>
<a name="ln3046">  install_element (RIPNG_NODE, &amp;ripng_timers_cmd);</a>
<a name="ln3047">  install_element (RIPNG_NODE, &amp;no_ripng_timers_cmd);</a>
<a name="ln3048">  install_element (RIPNG_NODE, &amp;no_ripng_timers_val_cmd);</a>
<a name="ln3049">#if 0</a>
<a name="ln3050">  install_element (RIPNG_NODE, &amp;ripng_update_timer_cmd);</a>
<a name="ln3051">  install_element (RIPNG_NODE, &amp;no_ripng_update_timer_cmd);</a>
<a name="ln3052">  install_element (RIPNG_NODE, &amp;ripng_timeout_timer_cmd);</a>
<a name="ln3053">  install_element (RIPNG_NODE, &amp;no_ripng_timeout_timer_cmd);</a>
<a name="ln3054">  install_element (RIPNG_NODE, &amp;ripng_garbage_timer_cmd);</a>
<a name="ln3055">  install_element (RIPNG_NODE, &amp;no_ripng_garbage_timer_cmd);</a>
<a name="ln3056">#endif /* 0 */</a>
<a name="ln3057"> </a>
<a name="ln3058">  install_element (RIPNG_NODE, &amp;ripng_default_information_originate_cmd);</a>
<a name="ln3059">  install_element (RIPNG_NODE, &amp;no_ripng_default_information_originate_cmd);</a>
<a name="ln3060"> </a>
<a name="ln3061">  install_element (RIPNG_NODE, &amp;ripng_allow_ecmp_cmd);</a>
<a name="ln3062">  install_element (RIPNG_NODE, &amp;no_ripng_allow_ecmp_cmd);</a>
<a name="ln3063"> </a>
<a name="ln3064">  ripng_if_init ();</a>
<a name="ln3065">  ripng_debug_init ();</a>
<a name="ln3066"> </a>
<a name="ln3067">  /* Access list install. */</a>
<a name="ln3068">  access_list_init ();</a>
<a name="ln3069">  access_list_add_hook (ripng_distribute_update_all_wrapper);</a>
<a name="ln3070">  access_list_delete_hook (ripng_distribute_update_all_wrapper);</a>
<a name="ln3071"> </a>
<a name="ln3072">  /* Prefix list initialize.*/</a>
<a name="ln3073">  prefix_list_init ();</a>
<a name="ln3074">  prefix_list_add_hook (ripng_distribute_update_all);</a>
<a name="ln3075">  prefix_list_delete_hook (ripng_distribute_update_all);</a>
<a name="ln3076"> </a>
<a name="ln3077">  /* Distribute list install. */</a>
<a name="ln3078">  distribute_list_init (RIPNG_NODE);</a>
<a name="ln3079">  distribute_list_add_hook (ripng_distribute_update);</a>
<a name="ln3080">  distribute_list_delete_hook (ripng_distribute_update);</a>
<a name="ln3081"> </a>
<a name="ln3082">  /* Route-map for interface. */</a>
<a name="ln3083">  ripng_route_map_init ();</a>
<a name="ln3084">  ripng_offset_init ();</a>
<a name="ln3085"> </a>
<a name="ln3086">  route_map_add_hook (ripng_routemap_update);</a>
<a name="ln3087">  route_map_delete_hook (ripng_routemap_update);</a>
<a name="ln3088"> </a>
<a name="ln3089">  if_rmap_init (RIPNG_NODE);</a>
<a name="ln3090">  if_rmap_hook_add (ripng_if_rmap_update);</a>
<a name="ln3091">  if_rmap_hook_delete (ripng_if_rmap_update);</a>
<a name="ln3092">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="145"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& ripaddr' buffer is not a multiple of the element size of the type 'struct sockaddr'.</p></div>
<div class="balloon" rel="1396"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v612/" target="_blank">V612</a> An unconditional 'break' within a loop.</p></div>
<div class="balloon" rel="1550"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'p' pointer was utilized before it was verified against nullptr. Check lines: 1550, 1554.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
