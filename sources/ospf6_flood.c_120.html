
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf6_flood.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (C) 2003 Yasuhiro Ohara</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the </a>
<a name="ln18"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330, </a>
<a name="ln19"> * Boston, MA 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;log.h&quot;</a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;linklist.h&quot;</a>
<a name="ln27">#include &quot;vty.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;ospf6d.h&quot;</a>
<a name="ln31">#include &quot;ospf6_proto.h&quot;</a>
<a name="ln32">#include &quot;ospf6_lsa.h&quot;</a>
<a name="ln33">#include &quot;ospf6_lsdb.h&quot;</a>
<a name="ln34">#include &quot;ospf6_message.h&quot;</a>
<a name="ln35">#include &quot;ospf6_route.h&quot;</a>
<a name="ln36">#include &quot;ospf6_spf.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;ospf6_top.h&quot;</a>
<a name="ln39">#include &quot;ospf6_area.h&quot;</a>
<a name="ln40">#include &quot;ospf6_interface.h&quot;</a>
<a name="ln41">#include &quot;ospf6_neighbor.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;ospf6_flood.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">unsigned char conf_debug_ospf6_flooding;</a>
<a name="ln46"> </a>
<a name="ln47">struct ospf6_lsdb *</a>
<a name="ln48">ospf6_get_scoped_lsdb (struct ospf6_lsa *lsa)</a>
<a name="ln49">{</a>
<a name="ln50">  struct ospf6_lsdb *lsdb = NULL;</a>
<a name="ln51">  switch (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type))</a>
<a name="ln52">    {</a>
<a name="ln53">    case OSPF6_SCOPE_LINKLOCAL:</a>
<a name="ln54">      lsdb = OSPF6_INTERFACE (lsa-&gt;lsdb-&gt;data)-&gt;lsdb;</a>
<a name="ln55">      break;</a>
<a name="ln56">    case OSPF6_SCOPE_AREA:</a>
<a name="ln57">      lsdb = OSPF6_AREA (lsa-&gt;lsdb-&gt;data)-&gt;lsdb;</a>
<a name="ln58">      break;</a>
<a name="ln59">    case OSPF6_SCOPE_AS:</a>
<a name="ln60">      lsdb = OSPF6_PROCESS (lsa-&gt;lsdb-&gt;data)-&gt;lsdb;</a>
<a name="ln61">      break;</a>
<a name="ln62">    default:</a>
<a name="ln63">      assert (0);</a>
<a name="ln64">      break;</a>
<a name="ln65">    }</a>
<a name="ln66">  return lsdb;</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">struct ospf6_lsdb *</a>
<a name="ln70">ospf6_get_scoped_lsdb_self (struct ospf6_lsa *lsa)</a>
<a name="ln71">{</a>
<a name="ln72">  struct ospf6_lsdb *lsdb_self = NULL;</a>
<a name="ln73">  switch (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type))</a>
<a name="ln74">    {</a>
<a name="ln75">    case OSPF6_SCOPE_LINKLOCAL:</a>
<a name="ln76">      lsdb_self = OSPF6_INTERFACE (lsa-&gt;lsdb-&gt;data)-&gt;lsdb_self;</a>
<a name="ln77">      break;</a>
<a name="ln78">    case OSPF6_SCOPE_AREA:</a>
<a name="ln79">      lsdb_self = OSPF6_AREA (lsa-&gt;lsdb-&gt;data)-&gt;lsdb_self;</a>
<a name="ln80">      break;</a>
<a name="ln81">    case OSPF6_SCOPE_AS:</a>
<a name="ln82">      lsdb_self = OSPF6_PROCESS (lsa-&gt;lsdb-&gt;data)-&gt;lsdb_self;</a>
<a name="ln83">      break;</a>
<a name="ln84">    default:</a>
<a name="ln85">      assert (0);</a>
<a name="ln86">      break;</a>
<a name="ln87">    }</a>
<a name="ln88">  return lsdb_self;</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">void</a>
<a name="ln92">ospf6_lsa_originate (struct ospf6_lsa *lsa)</a>
<a name="ln93">{</a>
<a name="ln94">  struct ospf6_lsa *old;</a>
<a name="ln95">  struct ospf6_lsdb *lsdb_self;</a>
<a name="ln96"> </a>
<a name="ln97">  /* find previous LSA */</a>
<a name="ln98">  old = ospf6_lsdb_lookup (lsa-&gt;header-&gt;type, lsa-&gt;header-&gt;id,</a>
<a name="ln99">                           lsa-&gt;header-&gt;adv_router, lsa-&gt;lsdb);</a>
<a name="ln100"> </a>
<a name="ln101">  /* if the new LSA does not differ from previous,</a>
<a name="ln102">     suppress this update of the LSA */</a>
<a name="ln103">  if (old &amp;&amp; ! OSPF6_LSA_IS_DIFFER (lsa, old))</a>
<a name="ln104">    {</a>
<a name="ln105">      if (IS_OSPF6_DEBUG_ORIGINATE_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln106">        zlog_debug (&quot;Suppress updating LSA: %s&quot;, lsa-&gt;name);</a>
<a name="ln107">      ospf6_lsa_delete (lsa);</a>
<a name="ln108">      return;</a>
<a name="ln109">    }</a>
<a name="ln110"> </a>
<a name="ln111">  /* store it in the LSDB for self-originated LSAs */</a>
<a name="ln112">  lsdb_self = ospf6_get_scoped_lsdb_self (lsa);</a>
<a name="ln113">  ospf6_lsdb_add (ospf6_lsa_copy (lsa), lsdb_self);</a>
<a name="ln114"> </a>
<a name="ln115">  lsa-&gt;refresh = thread_add_timer (master, ospf6_lsa_refresh, lsa,</a>
<a name="ln116">                                   OSPF_LS_REFRESH_TIME);</a>
<a name="ln117"> </a>
<a name="ln118">  if (IS_OSPF6_DEBUG_LSA_TYPE (lsa-&gt;header-&gt;type) ||</a>
<a name="ln119">      IS_OSPF6_DEBUG_ORIGINATE_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln120">    {</a>
<a name="ln121">      zlog_debug (&quot;LSA Originate:&quot;);</a>
<a name="ln122">      ospf6_lsa_header_print (lsa);</a>
<a name="ln123">    }</a>
<a name="ln124"> </a>
<a name="ln125">  ospf6_install_lsa (lsa);</a>
<a name="ln126">  ospf6_flood (NULL, lsa);</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">void</a>
<a name="ln130">ospf6_lsa_originate_process (struct ospf6_lsa *lsa,</a>
<a name="ln131">                             struct ospf6 *process)</a>
<a name="ln132">{</a>
<a name="ln133">  lsa-&gt;lsdb = process-&gt;lsdb;</a>
<a name="ln134">  ospf6_lsa_originate (lsa);</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">void</a>
<a name="ln138">ospf6_lsa_originate_area (struct ospf6_lsa *lsa,</a>
<a name="ln139">                          struct ospf6_area *oa)</a>
<a name="ln140">{</a>
<a name="ln141">  lsa-&gt;lsdb = oa-&gt;lsdb;</a>
<a name="ln142">  ospf6_lsa_originate (lsa);</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">void</a>
<a name="ln146">ospf6_lsa_originate_interface (struct ospf6_lsa *lsa,</a>
<a name="ln147">                               struct ospf6_interface *oi)</a>
<a name="ln148">{</a>
<a name="ln149">  lsa-&gt;lsdb = oi-&gt;lsdb;</a>
<a name="ln150">  ospf6_lsa_originate (lsa);</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">void</a>
<a name="ln154">ospf6_lsa_purge (struct ospf6_lsa *lsa)</a>
<a name="ln155">{</a>
<a name="ln156">  struct ospf6_lsa *self;</a>
<a name="ln157">  struct ospf6_lsdb *lsdb_self;</a>
<a name="ln158"> </a>
<a name="ln159">  /* remove it from the LSDB for self-originated LSAs */</a>
<a name="ln160">  lsdb_self = ospf6_get_scoped_lsdb_self (lsa);</a>
<a name="ln161">  self = ospf6_lsdb_lookup (lsa-&gt;header-&gt;type, lsa-&gt;header-&gt;id,</a>
<a name="ln162">                            lsa-&gt;header-&gt;adv_router, lsdb_self);</a>
<a name="ln163">  if (self)</a>
<a name="ln164">    {</a>
<a name="ln165">      THREAD_OFF (self-&gt;expire);</a>
<a name="ln166">      THREAD_OFF (self-&gt;refresh);</a>
<a name="ln167">      ospf6_lsdb_remove (self, lsdb_self);</a>
<a name="ln168">    }</a>
<a name="ln169"> </a>
<a name="ln170">  ospf6_lsa_premature_aging (lsa);</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">void</a>
<a name="ln175">ospf6_increment_retrans_count (struct ospf6_lsa *lsa)</a>
<a name="ln176">{</a>
<a name="ln177">  /* The LSA must be the original one (see the description</a>
<a name="ln178">     in ospf6_decrement_retrans_count () below) */</a>
<a name="ln179">  lsa-&gt;retrans_count++;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">void</a>
<a name="ln183">ospf6_decrement_retrans_count (struct ospf6_lsa *lsa)</a>
<a name="ln184">{</a>
<a name="ln185">  struct ospf6_lsdb *lsdb;</a>
<a name="ln186">  struct ospf6_lsa *orig;</a>
<a name="ln187"> </a>
<a name="ln188">  /* The LSA must be on the retrans-list of a neighbor. It means</a>
<a name="ln189">     the &quot;lsa&quot; is a copied one, and we have to decrement the</a>
<a name="ln190">     retransmission count of the original one (instead of this &quot;lsa&quot;'s).</a>
<a name="ln191">     In order to find the original LSA, first we have to find</a>
<a name="ln192">     appropriate LSDB that have the original LSA. */</a>
<a name="ln193">  lsdb = ospf6_get_scoped_lsdb (lsa);</a>
<a name="ln194"> </a>
<a name="ln195">  /* Find the original LSA of which the retrans_count should be decremented */</a>
<a name="ln196">  orig = ospf6_lsdb_lookup (lsa-&gt;header-&gt;type, lsa-&gt;header-&gt;id,</a>
<a name="ln197">                            lsa-&gt;header-&gt;adv_router, lsdb);</a>
<a name="ln198">  if (orig)</a>
<a name="ln199">    {</a>
<a name="ln200">      orig-&gt;retrans_count--;</a>
<a name="ln201">      assert (orig-&gt;retrans_count &gt;= 0);</a>
<a name="ln202">    }</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">/* RFC2328 section 13.2 Installing LSAs in the database */</a>
<a name="ln206">void</a>
<a name="ln207">ospf6_install_lsa (struct ospf6_lsa *lsa)</a>
<a name="ln208">{</a>
<a name="ln209">  struct timeval now;</a>
<a name="ln210">  struct ospf6_lsa *old;</a>
<a name="ln211"> </a>
<a name="ln212">  if (IS_OSPF6_DEBUG_LSA_TYPE (lsa-&gt;header-&gt;type) ||</a>
<a name="ln213">      IS_OSPF6_DEBUG_EXAMIN_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln214">    zlog_debug (&quot;Install LSA: %s&quot;, lsa-&gt;name);</a>
<a name="ln215"> </a>
<a name="ln216">  /* Remove the old instance from all neighbors' Link state</a>
<a name="ln217">     retransmission list (RFC2328 13.2 last paragraph) */</a>
<a name="ln218">  old = ospf6_lsdb_lookup (lsa-&gt;header-&gt;type, lsa-&gt;header-&gt;id,</a>
<a name="ln219">                           lsa-&gt;header-&gt;adv_router, lsa-&gt;lsdb);</a>
<a name="ln220">  if (old)</a>
<a name="ln221">    {</a>
<a name="ln222">      THREAD_OFF (old-&gt;expire);</a>
<a name="ln223">      THREAD_OFF (old-&gt;refresh);</a>
<a name="ln224">      ospf6_flood_clear (old);</a>
<a name="ln225">    }</a>
<a name="ln226"> </a>
<a name="ln227">  quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now);</a>
<a name="ln228">  if (! OSPF6_LSA_IS_MAXAGE (lsa))</a>
<a name="ln229">    lsa-&gt;expire = thread_add_timer (master, ospf6_lsa_expire, lsa,</a>
<a name="ln230">                                    OSPF_LSA_MAXAGE + lsa-&gt;birth.tv_sec - now.tv_sec);</a>
<a name="ln231">  else</a>
<a name="ln232">    lsa-&gt;expire = NULL;</a>
<a name="ln233"> </a>
<a name="ln234">  if (OSPF6_LSA_IS_SEQWRAP(lsa) &amp;&amp;</a>
<a name="ln235">      ! (CHECK_FLAG(lsa-&gt;flag,OSPF6_LSA_SEQWRAPPED) &amp;&amp;</a>
<a name="ln236">         lsa-&gt;header-&gt;seqnum == htonl(OSPF_MAX_SEQUENCE_NUMBER)))</a>
<a name="ln237">   {</a>
<a name="ln238">     if (IS_OSPF6_DEBUG_EXAMIN_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln239">       zlog_debug(&quot;lsa install wrapping: sequence 0x%x&quot;,</a>
<a name="ln240">                  ntohl(lsa-&gt;header-&gt;seqnum));</a>
<a name="ln241">     SET_FLAG(lsa-&gt;flag, OSPF6_LSA_SEQWRAPPED);</a>
<a name="ln242">     /* in lieu of premature_aging, since we do not want to recreate this lsa</a>
<a name="ln243">      * and/or mess with timers etc, we just want to wrap the sequence number</a>
<a name="ln244">      * and reflood the lsa before continuing.</a>
<a name="ln245">      * NOTE: Flood needs to be called right after this function call, by the</a>
<a name="ln246">      * caller</a>
<a name="ln247">      */</a>
<a name="ln248">     lsa-&gt;header-&gt;seqnum = htonl (OSPF_MAX_SEQUENCE_NUMBER);</a>
<a name="ln249">     lsa-&gt;header-&gt;age = htons (OSPF_LSA_MAXAGE);</a>
<a name="ln250">     ospf6_lsa_checksum (lsa-&gt;header);</a>
<a name="ln251">   }</a>
<a name="ln252"> </a>
<a name="ln253">  /* actually install */</a>
<a name="ln254">  lsa-&gt;installed = now;</a>
<a name="ln255">  ospf6_lsdb_add (lsa, lsa-&gt;lsdb);</a>
<a name="ln256"> </a>
<a name="ln257">  return;</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">/* RFC2740 section 3.5.2. Sending Link State Update packets */</a>
<a name="ln261">/* RFC2328 section 13.3 Next step in the flooding procedure */</a>
<a name="ln262">static void</a>
<a name="ln263">ospf6_flood_interface (struct ospf6_neighbor *from,</a>
<a name="ln264">                       struct ospf6_lsa *lsa, struct ospf6_interface *oi)</a>
<a name="ln265">{</a>
<a name="ln266">  struct listnode *node, *nnode;</a>
<a name="ln267">  struct ospf6_neighbor *on;</a>
<a name="ln268">  struct ospf6_lsa *req;</a>
<a name="ln269">  int retrans_added = 0;</a>
<a name="ln270">  int is_debug = 0;</a>
<a name="ln271"> </a>
<a name="ln272">  if (IS_OSPF6_DEBUG_FLOODING ||</a>
<a name="ln273">      IS_OSPF6_DEBUG_FLOOD_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln274">    {</a>
<a name="ln275">      is_debug++;</a>
<a name="ln276">      zlog_debug (&quot;Flooding on %s: %s&quot;, oi-&gt;interface-&gt;name, lsa-&gt;name);</a>
<a name="ln277">    }</a>
<a name="ln278"> </a>
<a name="ln279">  /* (1) For each neighbor */</a>
<a name="ln280">  for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln281">    {</a>
<a name="ln282">      if (is_debug)</a>
<a name="ln283">        zlog_debug (&quot;To neighbor %s&quot;, on-&gt;name);</a>
<a name="ln284"> </a>
<a name="ln285">      /* (a) if neighbor state &lt; Exchange, examin next */</a>
<a name="ln286">      if (on-&gt;state &lt; OSPF6_NEIGHBOR_EXCHANGE)</a>
<a name="ln287">        {</a>
<a name="ln288">          if (is_debug)</a>
<a name="ln289">            zlog_debug (&quot;Neighbor state less than ExChange, next neighbor&quot;);</a>
<a name="ln290">          continue;</a>
<a name="ln291">        }</a>
<a name="ln292"> </a>
<a name="ln293">      /* (b) if neighbor not yet Full, check request-list */</a>
<a name="ln294">      if (on-&gt;state != OSPF6_NEIGHBOR_FULL)</a>
<a name="ln295">        {</a>
<a name="ln296">          if (is_debug)</a>
<a name="ln297">            zlog_debug (&quot;Neighbor not yet Full&quot;);</a>
<a name="ln298"> </a>
<a name="ln299">          req = ospf6_lsdb_lookup (lsa-&gt;header-&gt;type, lsa-&gt;header-&gt;id,</a>
<a name="ln300">                                   lsa-&gt;header-&gt;adv_router, on-&gt;request_list);</a>
<a name="ln301">          if (req == NULL)</a>
<a name="ln302">            {</a>
<a name="ln303">              if (is_debug)</a>
<a name="ln304">                zlog_debug (&quot;Not on request-list for this neighbor&quot;);</a>
<a name="ln305">              /* fall through */</a>
<a name="ln306">            }</a>
<a name="ln307">          else</a>
<a name="ln308">            {</a>
<a name="ln309">              /* If new LSA less recent, examin next neighbor */</a>
<a name="ln310">              if (ospf6_lsa_compare (lsa, req) &gt; 0)</a>
<a name="ln311">                {</a>
<a name="ln312">                  if (is_debug)</a>
<a name="ln313">                    zlog_debug (&quot;Requesting is older, next neighbor&quot;);</a>
<a name="ln314">                  continue;</a>
<a name="ln315">                }</a>
<a name="ln316"> </a>
<a name="ln317">              /* If the same instance, delete from request-list and</a>
<a name="ln318">                 examin next neighbor */</a>
<a name="ln319">              if (ospf6_lsa_compare (lsa, req) == 0)</a>
<a name="ln320">                {</a>
<a name="ln321">		  if (is_debug)</a>
<a name="ln322">		    zlog_debug (&quot;Requesting the same, remove it, next neighbor&quot;);</a>
<a name="ln323">		  if (req == on-&gt;last_ls_req)</a>
<a name="ln324">		    {</a>
<a name="ln325">		      ospf6_lsa_unlock (req);</a>
<a name="ln326">		      on-&gt;last_ls_req = NULL;</a>
<a name="ln327">		    }</a>
<a name="ln328">                  ospf6_lsdb_remove (req, on-&gt;request_list);</a>
<a name="ln329">		  ospf6_check_nbr_loading (on);</a>
<a name="ln330">                  continue;</a>
<a name="ln331">                }</a>
<a name="ln332"> </a>
<a name="ln333">              /* If the new LSA is more recent, delete from request-list */</a>
<a name="ln334">              if (ospf6_lsa_compare (lsa, req) &lt; 0)</a>
<a name="ln335">                {</a>
<a name="ln336">		  if (is_debug)</a>
<a name="ln337">		    zlog_debug (&quot;Received is newer, remove requesting&quot;);</a>
<a name="ln338">		  if (req == on-&gt;last_ls_req)</a>
<a name="ln339">		    {</a>
<a name="ln340">		      ospf6_lsa_unlock (req);</a>
<a name="ln341">		      on-&gt;last_ls_req = NULL;</a>
<a name="ln342">		    }</a>
<a name="ln343">                  ospf6_lsdb_remove (req, on-&gt;request_list);</a>
<a name="ln344">		  ospf6_check_nbr_loading (on);</a>
<a name="ln345">                  /* fall through */</a>
<a name="ln346">                }</a>
<a name="ln347">            }</a>
<a name="ln348">        }</a>
<a name="ln349"> </a>
<a name="ln350">      /* (c) If the new LSA was received from this neighbor,</a>
<a name="ln351">         examin next neighbor */</a>
<a name="ln352">      if (from == on)</a>
<a name="ln353">        {</a>
<a name="ln354">          if (is_debug)</a>
<a name="ln355">            zlog_debug (&quot;Received is from the neighbor, next neighbor&quot;);</a>
<a name="ln356">          continue;</a>
<a name="ln357">        }</a>
<a name="ln358"> </a>
<a name="ln359">      /* (d) add retrans-list, schedule retransmission */</a>
<a name="ln360">      if (is_debug)</a>
<a name="ln361">        zlog_debug (&quot;Add retrans-list of this neighbor&quot;);</a>
<a name="ln362">      ospf6_increment_retrans_count (lsa);</a>
<a name="ln363">      ospf6_lsdb_add (ospf6_lsa_copy (lsa), on-&gt;retrans_list);</a>
<a name="ln364">      if (on-&gt;thread_send_lsupdate == NULL)</a>
<a name="ln365">        on-&gt;thread_send_lsupdate =</a>
<a name="ln366">          thread_add_timer (master, ospf6_lsupdate_send_neighbor,</a>
<a name="ln367">                            on, on-&gt;ospf6_if-&gt;rxmt_interval);</a>
<a name="ln368">      retrans_added++;</a>
<a name="ln369">    }</a>
<a name="ln370"> </a>
<a name="ln371">  /* (2) examin next interface if not added to retrans-list */</a>
<a name="ln372">  if (retrans_added == 0)</a>
<a name="ln373">    {</a>
<a name="ln374">      if (is_debug)</a>
<a name="ln375">        zlog_debug (&quot;No retransmission scheduled, next interface&quot;);</a>
<a name="ln376">      return;</a>
<a name="ln377">    }</a>
<a name="ln378"> </a>
<a name="ln379">  /* (3) If the new LSA was received on this interface,</a>
<a name="ln380">     and it was from DR or BDR, examin next interface */</a>
<a name="ln381">  if (from &amp;&amp; from-&gt;ospf6_if == oi &amp;&amp;</a>
<a name="ln382">      (from-&gt;router_id == oi-&gt;drouter || from-&gt;router_id == oi-&gt;bdrouter))</a>
<a name="ln383">    {</a>
<a name="ln384">      if (is_debug)</a>
<a name="ln385">        zlog_debug (&quot;Received is from the I/F's DR or BDR, next interface&quot;);</a>
<a name="ln386">      return;</a>
<a name="ln387">    }</a>
<a name="ln388"> </a>
<a name="ln389">  /* (4) If the new LSA was received on this interface,</a>
<a name="ln390">     and the interface state is BDR, examin next interface */</a>
<a name="ln391">  if (from &amp;&amp; from-&gt;ospf6_if == oi)</a>
<a name="ln392">    {</a>
<a name="ln393">      if (oi-&gt;state == OSPF6_INTERFACE_BDR)</a>
<a name="ln394">	{</a>
<a name="ln395">	  if (is_debug)</a>
<a name="ln396">	    zlog_debug (&quot;Received is from the I/F, itself BDR, next interface&quot;);</a>
<a name="ln397">	  return;</a>
<a name="ln398">	}</a>
<a name="ln399">      SET_FLAG(lsa-&gt;flag, OSPF6_LSA_FLOODBACK);</a>
<a name="ln400">    }</a>
<a name="ln401"> </a>
<a name="ln402">  /* (5) flood the LSA out the interface. */</a>
<a name="ln403">  if (is_debug)</a>
<a name="ln404">    zlog_debug (&quot;Schedule flooding for the interface&quot;);</a>
<a name="ln405">  if ((oi-&gt;type == OSPF_IFTYPE_BROADCAST) ||</a>
<a name="ln406">      (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT))</a>
<a name="ln407">    {</a>
<a name="ln408">      ospf6_lsdb_add (ospf6_lsa_copy (lsa), oi-&gt;lsupdate_list);</a>
<a name="ln409">      if (oi-&gt;thread_send_lsupdate == NULL)</a>
<a name="ln410">        oi-&gt;thread_send_lsupdate =</a>
<a name="ln411">          thread_add_event (master, ospf6_lsupdate_send_interface, oi, 0);</a>
<a name="ln412">    }</a>
<a name="ln413">  else</a>
<a name="ln414">    {</a>
<a name="ln415">      /* reschedule retransmissions to all neighbors */</a>
<a name="ln416">      for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln417">        {</a>
<a name="ln418">          THREAD_OFF (on-&gt;thread_send_lsupdate);</a>
<a name="ln419">          on-&gt;thread_send_lsupdate =</a>
<a name="ln420">            thread_add_event (master, ospf6_lsupdate_send_neighbor, on, 0);</a>
<a name="ln421">        }</a>
<a name="ln422">    }</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">static void</a>
<a name="ln426">ospf6_flood_area (struct ospf6_neighbor *from,</a>
<a name="ln427">                  struct ospf6_lsa *lsa, struct ospf6_area *oa)</a>
<a name="ln428">{</a>
<a name="ln429">  struct listnode *node, *nnode;</a>
<a name="ln430">  struct ospf6_interface *oi;</a>
<a name="ln431"> </a>
<a name="ln432">  for (ALL_LIST_ELEMENTS (oa-&gt;if_list, node, nnode, oi))</a>
<a name="ln433">    {</a>
<a name="ln434">      if (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type) == OSPF6_SCOPE_LINKLOCAL &amp;&amp;</a>
<a name="ln435">          oi != OSPF6_INTERFACE (lsa-&gt;lsdb-&gt;data))</a>
<a name="ln436">        continue;</a>
<a name="ln437"> </a>
<a name="ln438">#if 0</a>
<a name="ln439">      if (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type) == OSPF6_SCOPE_AS &amp;&amp;</a>
<a name="ln440">          ospf6_is_interface_virtual_link (oi))</a>
<a name="ln441">        continue;</a>
<a name="ln442">#endif/*0*/</a>
<a name="ln443"> </a>
<a name="ln444">      ospf6_flood_interface (from, lsa, oi);</a>
<a name="ln445">    }</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">static void</a>
<a name="ln449">ospf6_flood_process (struct ospf6_neighbor *from,</a>
<a name="ln450">                     struct ospf6_lsa *lsa, struct ospf6 *process)</a>
<a name="ln451">{</a>
<a name="ln452">  struct listnode *node, *nnode;</a>
<a name="ln453">  struct ospf6_area *oa;</a>
<a name="ln454"> </a>
<a name="ln455">  for (ALL_LIST_ELEMENTS (process-&gt;area_list, node, nnode, oa))</a>
<a name="ln456">    {</a>
<a name="ln457">      if (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type) == OSPF6_SCOPE_AREA &amp;&amp;</a>
<a name="ln458">          oa != OSPF6_AREA (lsa-&gt;lsdb-&gt;data))</a>
<a name="ln459">        continue;</a>
<a name="ln460">      if (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type) == OSPF6_SCOPE_LINKLOCAL &amp;&amp;</a>
<a name="ln461">          oa != OSPF6_INTERFACE (lsa-&gt;lsdb-&gt;data)-&gt;area)</a>
<a name="ln462">        continue;</a>
<a name="ln463"> </a>
<a name="ln464">      if (ntohs (lsa-&gt;header-&gt;type) == OSPF6_LSTYPE_AS_EXTERNAL &amp;&amp;</a>
<a name="ln465">          IS_AREA_STUB (oa))</a>
<a name="ln466">        continue;</a>
<a name="ln467"> </a>
<a name="ln468">      ospf6_flood_area (from, lsa, oa);</a>
<a name="ln469">    }</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">void</a>
<a name="ln473">ospf6_flood (struct ospf6_neighbor *from, struct ospf6_lsa *lsa)</a>
<a name="ln474">{</a>
<a name="ln475">  ospf6_flood_process (from, lsa, ospf6);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">static void</a>
<a name="ln479">ospf6_flood_clear_interface (struct ospf6_lsa *lsa, struct ospf6_interface *oi)</a>
<a name="ln480">{</a>
<a name="ln481">  struct listnode *node, *nnode;</a>
<a name="ln482">  struct ospf6_neighbor *on;</a>
<a name="ln483">  struct ospf6_lsa *rem;</a>
<a name="ln484"> </a>
<a name="ln485">  for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln486">    {</a>
<a name="ln487">      rem = ospf6_lsdb_lookup (lsa-&gt;header-&gt;type, lsa-&gt;header-&gt;id,</a>
<a name="ln488">                               lsa-&gt;header-&gt;adv_router, on-&gt;retrans_list);</a>
<a name="ln489">      if (rem &amp;&amp; ! ospf6_lsa_compare (rem, lsa))</a>
<a name="ln490">        {</a>
<a name="ln491">          if (IS_OSPF6_DEBUG_FLOODING ||</a>
<a name="ln492">              IS_OSPF6_DEBUG_FLOOD_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln493">            zlog_debug (&quot;Remove %s from retrans_list of %s&quot;,</a>
<a name="ln494">                       rem-&gt;name, on-&gt;name);</a>
<a name="ln495">          ospf6_decrement_retrans_count (rem);</a>
<a name="ln496">          ospf6_lsdb_remove (rem, on-&gt;retrans_list);</a>
<a name="ln497">        }</a>
<a name="ln498">    }</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">static void</a>
<a name="ln502">ospf6_flood_clear_area (struct ospf6_lsa *lsa, struct ospf6_area *oa)</a>
<a name="ln503">{</a>
<a name="ln504">  struct listnode *node, *nnode;</a>
<a name="ln505">  struct ospf6_interface *oi;</a>
<a name="ln506"> </a>
<a name="ln507">  for (ALL_LIST_ELEMENTS (oa-&gt;if_list, node, nnode, oi))</a>
<a name="ln508">    {</a>
<a name="ln509">      if (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type) == OSPF6_SCOPE_LINKLOCAL &amp;&amp;</a>
<a name="ln510">          oi != OSPF6_INTERFACE (lsa-&gt;lsdb-&gt;data))</a>
<a name="ln511">        continue;</a>
<a name="ln512"> </a>
<a name="ln513">#if 0</a>
<a name="ln514">      if (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type) == OSPF6_SCOPE_AS &amp;&amp;</a>
<a name="ln515">          ospf6_is_interface_virtual_link (oi))</a>
<a name="ln516">        continue;</a>
<a name="ln517">#endif/*0*/</a>
<a name="ln518"> </a>
<a name="ln519">      ospf6_flood_clear_interface (lsa, oi);</a>
<a name="ln520">    }</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">static void</a>
<a name="ln524">ospf6_flood_clear_process (struct ospf6_lsa *lsa, struct ospf6 *process)</a>
<a name="ln525">{</a>
<a name="ln526">  struct listnode *node, *nnode;</a>
<a name="ln527">  struct ospf6_area *oa;</a>
<a name="ln528"> </a>
<a name="ln529">  for (ALL_LIST_ELEMENTS (process-&gt;area_list, node, nnode, oa))</a>
<a name="ln530">    {</a>
<a name="ln531">      if (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type) == OSPF6_SCOPE_AREA &amp;&amp;</a>
<a name="ln532">          oa != OSPF6_AREA (lsa-&gt;lsdb-&gt;data))</a>
<a name="ln533">        continue;</a>
<a name="ln534">      if (OSPF6_LSA_SCOPE (lsa-&gt;header-&gt;type) == OSPF6_SCOPE_LINKLOCAL &amp;&amp;</a>
<a name="ln535">          oa != OSPF6_INTERFACE (lsa-&gt;lsdb-&gt;data)-&gt;area)</a>
<a name="ln536">        continue;</a>
<a name="ln537"> </a>
<a name="ln538">      if (ntohs (lsa-&gt;header-&gt;type) == OSPF6_LSTYPE_AS_EXTERNAL &amp;&amp;</a>
<a name="ln539">          IS_AREA_STUB (oa))</a>
<a name="ln540">        continue;</a>
<a name="ln541"> </a>
<a name="ln542">      ospf6_flood_clear_area (lsa, oa);</a>
<a name="ln543">    }</a>
<a name="ln544">}</a>
<a name="ln545"> </a>
<a name="ln546">void</a>
<a name="ln547">ospf6_flood_clear (struct ospf6_lsa *lsa)</a>
<a name="ln548">{</a>
<a name="ln549">  ospf6_flood_clear_process (lsa, ospf6);</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552"> </a>
<a name="ln553">/* RFC2328 13.5 (Table 19): Sending link state acknowledgements. */</a>
<a name="ln554">static void</a>
<a name="ln555">ospf6_acknowledge_lsa_bdrouter (struct ospf6_lsa *lsa, int ismore_recent,</a>
<a name="ln556">                                struct ospf6_neighbor *from)</a>
<a name="ln557">{</a>
<a name="ln558">  struct ospf6_interface *oi;</a>
<a name="ln559">  int is_debug = 0;</a>
<a name="ln560"> </a>
<a name="ln561">  if (IS_OSPF6_DEBUG_FLOODING ||</a>
<a name="ln562">      IS_OSPF6_DEBUG_FLOOD_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln563">    is_debug++;</a>
<a name="ln564"> </a>
<a name="ln565">  assert (from &amp;&amp; from-&gt;ospf6_if);</a>
<a name="ln566">  oi = from-&gt;ospf6_if;</a>
<a name="ln567"> </a>
<a name="ln568">  /* LSA is more recent than database copy, but was not flooded</a>
<a name="ln569">     back out receiving interface. Delayed acknowledgement sent</a>
<a name="ln570">     if advertisement received from Designated Router,</a>
<a name="ln571">     otherwide do nothing. */</a>
<a name="ln572">  if (ismore_recent &lt; 0)</a>
<a name="ln573">    {</a>
<a name="ln574">      if (oi-&gt;drouter == from-&gt;router_id)</a>
<a name="ln575">        {</a>
<a name="ln576">          if (is_debug)</a>
<a name="ln577">            zlog_debug (&quot;Delayed acknowledgement (BDR &amp; MoreRecent &amp; from DR)&quot;);</a>
<a name="ln578">          /* Delayed acknowledgement */</a>
<a name="ln579">          ospf6_lsdb_add (ospf6_lsa_copy (lsa), oi-&gt;lsack_list);</a>
<a name="ln580">          if (oi-&gt;thread_send_lsack == NULL)</a>
<a name="ln581">            oi-&gt;thread_send_lsack =</a>
<a name="ln582">              thread_add_timer (master, ospf6_lsack_send_interface, oi, 3);</a>
<a name="ln583">        }</a>
<a name="ln584">      else</a>
<a name="ln585">        {</a>
<a name="ln586">          if (is_debug)</a>
<a name="ln587">            zlog_debug (&quot;No acknowledgement (BDR &amp; MoreRecent &amp; ! from DR)&quot;);</a>
<a name="ln588">        }</a>
<a name="ln589">      return;</a>
<a name="ln590">    }</a>
<a name="ln591"> </a>
<a name="ln592">  /* LSA is a duplicate, and was treated as an implied acknowledgement.</a>
<a name="ln593">     Delayed acknowledgement sent if advertisement received from</a>
<a name="ln594">     Designated Router, otherwise do nothing */</a>
<a name="ln595">  if (CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_DUPLICATE) &amp;&amp;</a>
<a name="ln596">      CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_IMPLIEDACK))</a>
<a name="ln597">    {</a>
<a name="ln598">      if (oi-&gt;drouter == from-&gt;router_id)</a>
<a name="ln599">        {</a>
<a name="ln600">          if (is_debug)</a>
<a name="ln601">            zlog_debug (&quot;Delayed acknowledgement (BDR &amp; Duplicate &amp; ImpliedAck &amp; from DR)&quot;);</a>
<a name="ln602">          /* Delayed acknowledgement */</a>
<a name="ln603">          ospf6_lsdb_add (ospf6_lsa_copy (lsa), oi-&gt;lsack_list);</a>
<a name="ln604">          if (oi-&gt;thread_send_lsack == NULL)</a>
<a name="ln605">            oi-&gt;thread_send_lsack =</a>
<a name="ln606">              thread_add_timer (master, ospf6_lsack_send_interface, oi, 3);</a>
<a name="ln607">        }</a>
<a name="ln608">      else</a>
<a name="ln609">        {</a>
<a name="ln610">          if (is_debug)</a>
<a name="ln611">            zlog_debug (&quot;No acknowledgement (BDR &amp; Duplicate &amp; ImpliedAck &amp; ! from DR)&quot;);</a>
<a name="ln612">        }</a>
<a name="ln613">      return;</a>
<a name="ln614">    }</a>
<a name="ln615"> </a>
<a name="ln616">  /* LSA is a duplicate, and was not treated as an implied acknowledgement.</a>
<a name="ln617">     Direct acknowledgement sent */</a>
<a name="ln618">  if (CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_DUPLICATE) &amp;&amp;</a>
<a name="ln619">      ! CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_IMPLIEDACK))</a>
<a name="ln620">    {</a>
<a name="ln621">      if (is_debug)</a>
<a name="ln622">        zlog_debug (&quot;Direct acknowledgement (BDR &amp; Duplicate)&quot;);</a>
<a name="ln623">      ospf6_lsdb_add (ospf6_lsa_copy (lsa), from-&gt;lsack_list);</a>
<a name="ln624">      if (from-&gt;thread_send_lsack == NULL)</a>
<a name="ln625">        from-&gt;thread_send_lsack =</a>
<a name="ln626">          thread_add_event (master, ospf6_lsack_send_neighbor, from, 0);</a>
<a name="ln627">      return;</a>
<a name="ln628">    }</a>
<a name="ln629"> </a>
<a name="ln630">  /* LSA's LS age is equal to Maxage, and there is no current instance</a>
<a name="ln631">     of the LSA in the link state database, and none of router's</a>
<a name="ln632">     neighbors are in states Exchange or Loading */</a>
<a name="ln633">  /* Direct acknowledgement sent, but this case is handled in</a>
<a name="ln634">     early of ospf6_receive_lsa () */</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">static void</a>
<a name="ln638">ospf6_acknowledge_lsa_allother (struct ospf6_lsa *lsa, int ismore_recent,</a>
<a name="ln639">                                struct ospf6_neighbor *from)</a>
<a name="ln640">{</a>
<a name="ln641">  struct ospf6_interface *oi;</a>
<a name="ln642">  int is_debug = 0;</a>
<a name="ln643"> </a>
<a name="ln644">  if (IS_OSPF6_DEBUG_FLOODING ||</a>
<a name="ln645">      IS_OSPF6_DEBUG_FLOOD_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln646">    is_debug++;</a>
<a name="ln647"> </a>
<a name="ln648">  assert (from &amp;&amp; from-&gt;ospf6_if);</a>
<a name="ln649">  oi = from-&gt;ospf6_if;</a>
<a name="ln650"> </a>
<a name="ln651">  /* LSA has been flood back out receiving interface.</a>
<a name="ln652">     No acknowledgement sent. */</a>
<a name="ln653">  if (CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_FLOODBACK))</a>
<a name="ln654">    {</a>
<a name="ln655">      if (is_debug)</a>
<a name="ln656">        zlog_debug (&quot;No acknowledgement (AllOther &amp; FloodBack)&quot;);</a>
<a name="ln657">      return;</a>
<a name="ln658">    }</a>
<a name="ln659"> </a>
<a name="ln660">  /* LSA is more recent than database copy, but was not flooded</a>
<a name="ln661">     back out receiving interface. Delayed acknowledgement sent. */</a>
<a name="ln662">  if (ismore_recent &lt; 0)</a>
<a name="ln663">    {</a>
<a name="ln664">      if (is_debug)</a>
<a name="ln665">        zlog_debug (&quot;Delayed acknowledgement (AllOther &amp; MoreRecent)&quot;);</a>
<a name="ln666">      /* Delayed acknowledgement */</a>
<a name="ln667">      ospf6_lsdb_add (ospf6_lsa_copy (lsa), oi-&gt;lsack_list);</a>
<a name="ln668">      if (oi-&gt;thread_send_lsack == NULL)</a>
<a name="ln669">        oi-&gt;thread_send_lsack =</a>
<a name="ln670">          thread_add_timer (master, ospf6_lsack_send_interface, oi, 3);</a>
<a name="ln671">      return;</a>
<a name="ln672">    }</a>
<a name="ln673"> </a>
<a name="ln674">  /* LSA is a duplicate, and was treated as an implied acknowledgement.</a>
<a name="ln675">     No acknowledgement sent. */</a>
<a name="ln676">  if (CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_DUPLICATE) &amp;&amp;</a>
<a name="ln677">      CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_IMPLIEDACK))</a>
<a name="ln678">    {</a>
<a name="ln679">      if (is_debug)</a>
<a name="ln680">        zlog_debug (&quot;No acknowledgement (AllOther &amp; Duplicate &amp; ImpliedAck)&quot;);</a>
<a name="ln681">      return;</a>
<a name="ln682">    }</a>
<a name="ln683"> </a>
<a name="ln684">  /* LSA is a duplicate, and was not treated as an implied acknowledgement.</a>
<a name="ln685">     Direct acknowledgement sent */</a>
<a name="ln686">  if (CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_DUPLICATE) &amp;&amp;</a>
<a name="ln687">      ! CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_IMPLIEDACK))</a>
<a name="ln688">    {</a>
<a name="ln689">      if (is_debug)</a>
<a name="ln690">        zlog_debug (&quot;Direct acknowledgement (AllOther &amp; Duplicate)&quot;);</a>
<a name="ln691">      ospf6_lsdb_add (ospf6_lsa_copy (lsa), from-&gt;lsack_list);</a>
<a name="ln692">      if (from-&gt;thread_send_lsack == NULL)</a>
<a name="ln693">        from-&gt;thread_send_lsack =</a>
<a name="ln694">          thread_add_event (master, ospf6_lsack_send_neighbor, from, 0);</a>
<a name="ln695">      return;</a>
<a name="ln696">    }</a>
<a name="ln697"> </a>
<a name="ln698">  /* LSA's LS age is equal to Maxage, and there is no current instance</a>
<a name="ln699">     of the LSA in the link state database, and none of router's</a>
<a name="ln700">     neighbors are in states Exchange or Loading */</a>
<a name="ln701">  /* Direct acknowledgement sent, but this case is handled in</a>
<a name="ln702">     early of ospf6_receive_lsa () */</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">static void</a>
<a name="ln706">ospf6_acknowledge_lsa (struct ospf6_lsa *lsa, int ismore_recent,</a>
<a name="ln707">                       struct ospf6_neighbor *from)</a>
<a name="ln708">{</a>
<a name="ln709">  struct ospf6_interface *oi;</a>
<a name="ln710"> </a>
<a name="ln711">  assert (from &amp;&amp; from-&gt;ospf6_if);</a>
<a name="ln712">  oi = from-&gt;ospf6_if;</a>
<a name="ln713"> </a>
<a name="ln714">  if (oi-&gt;state == OSPF6_INTERFACE_BDR)</a>
<a name="ln715">    ospf6_acknowledge_lsa_bdrouter (lsa, ismore_recent, from);</a>
<a name="ln716">  else</a>
<a name="ln717">    ospf6_acknowledge_lsa_allother (lsa, ismore_recent, from);</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">/* RFC2328 section 13 (4):</a>
<a name="ln721">   if MaxAge LSA and if we have no instance, and no neighbor</a>
<a name="ln722">   is in states Exchange or Loading</a>
<a name="ln723">   returns 1 if match this case, else returns 0 */</a>
<a name="ln724">static int</a>
<a name="ln725">ospf6_is_maxage_lsa_drop (struct ospf6_lsa *lsa, struct ospf6_neighbor *from)</a>
<a name="ln726">{</a>
<a name="ln727">  struct ospf6_neighbor *on;</a>
<a name="ln728">  struct ospf6_interface *oi;</a>
<a name="ln729">  struct ospf6_area *oa;</a>
<a name="ln730">  struct ospf6 *process = NULL;</a>
<a name="ln731">  struct listnode *i, *j, *k;</a>
<a name="ln732">  int count = 0;</a>
<a name="ln733"> </a>
<a name="ln734">  if (! OSPF6_LSA_IS_MAXAGE (lsa))</a>
<a name="ln735">    return 0;</a>
<a name="ln736"> </a>
<a name="ln737">  if (ospf6_lsdb_lookup (lsa-&gt;header-&gt;type, lsa-&gt;header-&gt;id,</a>
<a name="ln738">                         lsa-&gt;header-&gt;adv_router, lsa-&gt;lsdb))</a>
<a name="ln739">    return 0;</a>
<a name="ln740"> </a>
<a name="ln741">  process = from-&gt;ospf6_if-&gt;area-&gt;ospf6;</a>
<a name="ln742"> </a>
<a name="ln743">  for (ALL_LIST_ELEMENTS_RO (process-&gt;area_list, i, oa))</a>
<a name="ln744">    for (ALL_LIST_ELEMENTS_RO (oa-&gt;if_list, j, oi))</a>
<a name="ln745">      for (ALL_LIST_ELEMENTS_RO (oi-&gt;neighbor_list, k, on))</a>
<a name="ln746">        if (on-&gt;state == OSPF6_NEIGHBOR_EXCHANGE ||</a>
<a name="ln747">            on-&gt;state == OSPF6_NEIGHBOR_LOADING)</a>
<a name="ln748">          count++;</a>
<a name="ln749"> </a>
<a name="ln750">  if (count == 0)</a>
<a name="ln751">    return 1;</a>
<a name="ln752">  return 0;</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">/* RFC2328 section 13 The Flooding Procedure */</a>
<a name="ln756">void</a>
<a name="ln757">ospf6_receive_lsa (struct ospf6_neighbor *from,</a>
<a name="ln758">                   struct ospf6_lsa_header *lsa_header)</a>
<a name="ln759">{</a>
<a name="ln760">  struct ospf6_lsa *new = NULL, *old = NULL, *rem = NULL;</a>
<a name="ln761">  int ismore_recent;</a>
<a name="ln762">  int is_debug = 0;</a>
<a name="ln763"> </a>
<a name="ln764">  ismore_recent = 1;</a>
<a name="ln765">  assert (from);</a>
<a name="ln766"> </a>
<a name="ln767">  /* make lsa structure for received lsa */</a>
<a name="ln768">  new = ospf6_lsa_create (lsa_header);</a>
<a name="ln769"> </a>
<a name="ln770">  if (IS_OSPF6_DEBUG_FLOODING ||</a>
<a name="ln771">      IS_OSPF6_DEBUG_FLOOD_TYPE (new-&gt;header-&gt;type))</a>
<a name="ln772">    {</a>
<a name="ln773">      is_debug++;</a>
<a name="ln774">      zlog_debug (&quot;LSA Receive from %s&quot;, from-&gt;name);</a>
<a name="ln775">      ospf6_lsa_header_print (new);</a>
<a name="ln776">    }</a>
<a name="ln777"> </a>
<a name="ln778">  /* (1) LSA Checksum */</a>
<a name="ln779">  if (! ospf6_lsa_checksum_valid (new-&gt;header))</a>
<a name="ln780">    {</a>
<a name="ln781">      if (is_debug)</a>
<a name="ln782">        zlog_debug (&quot;Wrong LSA Checksum, discard&quot;);</a>
<a name="ln783">      ospf6_lsa_delete (new);</a>
<a name="ln784">      return;</a>
<a name="ln785">    }</a>
<a name="ln786"> </a>
<a name="ln787">  /* (2) Examine the LSA's LS type. </a>
<a name="ln788">     RFC2470 3.5.1. Receiving Link State Update packets  */</a>
<a name="ln789">  if (IS_AREA_STUB (from-&gt;ospf6_if-&gt;area) &amp;&amp;</a>
<a name="ln790">      OSPF6_LSA_SCOPE (new-&gt;header-&gt;type) == OSPF6_SCOPE_AS)</a>
<a name="ln791">    {</a>
<a name="ln792">      if (is_debug)</a>
<a name="ln793">        zlog_debug (&quot;AS-External-LSA (or AS-scope LSA) in stub area, discard&quot;);</a>
<a name="ln794">      ospf6_lsa_delete (new);</a>
<a name="ln795">      return;</a>
<a name="ln796">    }</a>
<a name="ln797"> </a>
<a name="ln798">  /* (3) LSA which have reserved scope is discarded</a>
<a name="ln799">     RFC2470 3.5.1. Receiving Link State Update packets  */</a>
<a name="ln800">  /* Flooding scope check. LSAs with unknown scope are discarded here.</a>
<a name="ln801">     Set appropriate LSDB for the LSA */</a>
<a name="ln802">  switch (OSPF6_LSA_SCOPE (new-&gt;header-&gt;type))</a>
<a name="ln803">    {</a>
<a name="ln804">    case OSPF6_SCOPE_LINKLOCAL:</a>
<a name="ln805">      new-&gt;lsdb = from-&gt;ospf6_if-&gt;lsdb;</a>
<a name="ln806">      break;</a>
<a name="ln807">    case OSPF6_SCOPE_AREA:</a>
<a name="ln808">      new-&gt;lsdb = from-&gt;ospf6_if-&gt;area-&gt;lsdb;</a>
<a name="ln809">      break;</a>
<a name="ln810">    case OSPF6_SCOPE_AS:</a>
<a name="ln811">      new-&gt;lsdb = from-&gt;ospf6_if-&gt;area-&gt;ospf6-&gt;lsdb;</a>
<a name="ln812">      break;</a>
<a name="ln813">    default:</a>
<a name="ln814">      if (is_debug)</a>
<a name="ln815">        zlog_debug (&quot;LSA has reserved scope, discard&quot;);</a>
<a name="ln816">      ospf6_lsa_delete (new);</a>
<a name="ln817">      return;</a>
<a name="ln818">    }</a>
<a name="ln819"> </a>
<a name="ln820">  /* (4) if MaxAge LSA and if we have no instance, and no neighbor</a>
<a name="ln821">         is in states Exchange or Loading */</a>
<a name="ln822">  if (ospf6_is_maxage_lsa_drop (new, from))</a>
<a name="ln823">    {</a>
<a name="ln824">      /* log */</a>
<a name="ln825">      if (is_debug)</a>
<a name="ln826">	zlog_debug (&quot;Drop MaxAge LSA with direct acknowledgement.&quot;);</a>
<a name="ln827"> </a>
<a name="ln828">      /* a) Acknowledge back to neighbor (Direct acknowledgement, 13.5) */</a>
<a name="ln829">      ospf6_lsdb_add (ospf6_lsa_copy (new), from-&gt;lsack_list);</a>
<a name="ln830">      if (from-&gt;thread_send_lsack == NULL)</a>
<a name="ln831">        from-&gt;thread_send_lsack =</a>
<a name="ln832">          thread_add_event (master, ospf6_lsack_send_neighbor, from, 0);</a>
<a name="ln833"> </a>
<a name="ln834">      /* b) Discard */</a>
<a name="ln835">      ospf6_lsa_delete (new);</a>
<a name="ln836">      return;</a>
<a name="ln837">    }</a>
<a name="ln838"> </a>
<a name="ln839">  /* (5) */</a>
<a name="ln840">  /* lookup the same database copy in lsdb */</a>
<a name="ln841">  old = ospf6_lsdb_lookup (new-&gt;header-&gt;type, new-&gt;header-&gt;id,</a>
<a name="ln842">                           new-&gt;header-&gt;adv_router, new-&gt;lsdb);</a>
<a name="ln843">  if (old)</a>
<a name="ln844">    {</a>
<a name="ln845">      ismore_recent = ospf6_lsa_compare (new, old);</a>
<a name="ln846">      if (ntohl (new-&gt;header-&gt;seqnum) == ntohl (old-&gt;header-&gt;seqnum))</a>
<a name="ln847">        {</a>
<a name="ln848">          if (is_debug)</a>
<a name="ln849">            zlog_debug (&quot;Received is duplicated LSA&quot;);</a>
<a name="ln850">          SET_FLAG (new-&gt;flag, OSPF6_LSA_DUPLICATE);</a>
<a name="ln851">        }</a>
<a name="ln852">    }</a>
<a name="ln853"> </a>
<a name="ln854">  /* if no database copy or received is more recent */</a>
<a name="ln855">  if (old == NULL || ismore_recent &lt; 0)</a>
<a name="ln856">    {</a>
<a name="ln857">      /* in case we have no database copy */</a>
<a name="ln858">      ismore_recent = -1;</a>
<a name="ln859"> </a>
<a name="ln860">      /* (a) MinLSArrival check */</a>
<a name="ln861">      if (old)</a>
<a name="ln862">        {</a>
<a name="ln863">          struct timeval now, res;</a>
<a name="ln864">          quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now);</a>
<a name="ln865">          timersub (&amp;now, &amp;old-&gt;installed, &amp;res);</a>
<a name="ln866">          if (res.tv_sec &lt; (OSPF_MIN_LS_ARRIVAL / 1000))</a>
<a name="ln867">            {</a>
<a name="ln868">              if (is_debug)</a>
<a name="ln869">                zlog_debug (&quot;LSA can't be updated within MinLSArrival, discard&quot;);</a>
<a name="ln870">              ospf6_lsa_delete (new);</a>
<a name="ln871">              return;   /* examin next lsa */</a>
<a name="ln872">            }</a>
<a name="ln873">        }</a>
<a name="ln874"> </a>
<a name="ln875">      quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;new-&gt;received);</a>
<a name="ln876"> </a>
<a name="ln877">      if (is_debug)</a>
<a name="ln878">        zlog_debug (&quot;Install, Flood, Possibly acknowledge the received LSA&quot;);</a>
<a name="ln879"> </a>
<a name="ln880">      /* Remove older copies of this LSA from retx lists */</a>
<a name="ln881">      if (old)</a>
<a name="ln882">	ospf6_flood_clear (old);</a>
<a name="ln883"> </a>
<a name="ln884">      /* (b) immediately flood and (c) remove from all retrans-list */</a>
<a name="ln885">      /* Prevent self-originated LSA to be flooded. this is to make</a>
<a name="ln886">      reoriginated instance of the LSA not to be rejected by other routers</a>
<a name="ln887">      due to MinLSArrival. */</a>
<a name="ln888">      if (new-&gt;header-&gt;adv_router != from-&gt;ospf6_if-&gt;area-&gt;ospf6-&gt;router_id)</a>
<a name="ln889">        ospf6_flood (from, new);</a>
<a name="ln890"> </a>
<a name="ln891">      /* (d), installing lsdb, which may cause routing</a>
<a name="ln892">              table calculation (replacing database copy) */</a>
<a name="ln893">      ospf6_install_lsa (new);</a>
<a name="ln894"> </a>
<a name="ln895">      /* (e) possibly acknowledge */</a>
<a name="ln896">      ospf6_acknowledge_lsa (new, ismore_recent, from);</a>
<a name="ln897"> </a>
<a name="ln898">      /* (f) Self Originated LSA, section 13.4 */</a>
<a name="ln899">      if (new-&gt;header-&gt;adv_router == from-&gt;ospf6_if-&gt;area-&gt;ospf6-&gt;router_id)</a>
<a name="ln900">        {</a>
<a name="ln901">          /* Self-originated LSA (newer than ours) is received from</a>
<a name="ln902">             another router. We have to make a new instance of the LSA</a>
<a name="ln903">             or have to flush this LSA. */</a>
<a name="ln904">          if (is_debug)</a>
<a name="ln905">            {</a>
<a name="ln906">              zlog_debug (&quot;Newer instance of the self-originated LSA&quot;);</a>
<a name="ln907">              zlog_debug (&quot;Schedule reorigination&quot;);</a>
<a name="ln908">            }</a>
<a name="ln909">          new-&gt;refresh = thread_add_event (master, ospf6_lsa_refresh, new, 0);</a>
<a name="ln910">        }</a>
<a name="ln911"> </a>
<a name="ln912">      return;</a>
<a name="ln913">    }</a>
<a name="ln914"> </a>
<a name="ln915">  /* (6) if there is instance on sending neighbor's request list */</a>
<a name="ln916">  if (ospf6_lsdb_lookup (new-&gt;header-&gt;type, new-&gt;header-&gt;id,</a>
<a name="ln917">                         new-&gt;header-&gt;adv_router, from-&gt;request_list))</a>
<a name="ln918">    {</a>
<a name="ln919">      /* if no database copy, should go above state (5) */</a>
<a name="ln920">      assert (old);</a>
<a name="ln921"> </a>
<a name="ln922">      if (is_debug)</a>
<a name="ln923">        {</a>
<a name="ln924">          zlog_debug (&quot;Received is not newer, on the neighbor's request-list&quot;);</a>
<a name="ln925">          zlog_debug (&quot;BadLSReq, discard the received LSA&quot;);</a>
<a name="ln926">        }</a>
<a name="ln927"> </a>
<a name="ln928">      /* BadLSReq */</a>
<a name="ln929">      thread_add_event (master, bad_lsreq, from, 0);</a>
<a name="ln930"> </a>
<a name="ln931">      ospf6_lsa_delete (new);</a>
<a name="ln932">      return;</a>
<a name="ln933">    }</a>
<a name="ln934"> </a>
<a name="ln935">  /* (7) if neither one is more recent */</a>
<a name="ln936">  if (ismore_recent == 0)</a>
<a name="ln937">    {</a>
<a name="ln938">      if (is_debug)</a>
<a name="ln939">        zlog_debug (&quot;The same instance as database copy (neither recent)&quot;);</a>
<a name="ln940"> </a>
<a name="ln941">      /* (a) if on retrans-list, Treat this LSA as an Ack: Implied Ack */</a>
<a name="ln942">      rem = ospf6_lsdb_lookup (new-&gt;header-&gt;type, new-&gt;header-&gt;id,</a>
<a name="ln943">                               new-&gt;header-&gt;adv_router, from-&gt;retrans_list);</a>
<a name="ln944">      if (rem)</a>
<a name="ln945">        {</a>
<a name="ln946">          if (is_debug)</a>
<a name="ln947">            {</a>
<a name="ln948">              zlog_debug (&quot;It is on the neighbor's retrans-list.&quot;);</a>
<a name="ln949">              zlog_debug (&quot;Treat as an Implied acknowledgement&quot;);</a>
<a name="ln950">            }</a>
<a name="ln951">          SET_FLAG (new-&gt;flag, OSPF6_LSA_IMPLIEDACK);</a>
<a name="ln952">          ospf6_decrement_retrans_count (rem);</a>
<a name="ln953">          ospf6_lsdb_remove (rem, from-&gt;retrans_list);</a>
<a name="ln954">        }</a>
<a name="ln955"> </a>
<a name="ln956">      if (is_debug)</a>
<a name="ln957">        zlog_debug (&quot;Possibly acknowledge and then discard&quot;);</a>
<a name="ln958"> </a>
<a name="ln959">      /* (b) possibly acknowledge */</a>
<a name="ln960">      ospf6_acknowledge_lsa (new, ismore_recent, from);</a>
<a name="ln961"> </a>
<a name="ln962">      ospf6_lsa_delete (new);</a>
<a name="ln963">      return;</a>
<a name="ln964">    }</a>
<a name="ln965"> </a>
<a name="ln966">  /* (8) previous database copy is more recent */</a>
<a name="ln967">    {</a>
<a name="ln968">      assert (old);</a>
<a name="ln969"> </a>
<a name="ln970">      /* If database copy is in 'Seqnumber Wrapping',</a>
<a name="ln971">         simply discard the received LSA */</a>
<a name="ln972">      if (OSPF6_LSA_IS_MAXAGE (old) &amp;&amp;</a>
<a name="ln973">          old-&gt;header-&gt;seqnum == htonl (OSPF_MAX_SEQUENCE_NUMBER))</a>
<a name="ln974">        {</a>
<a name="ln975">          if (is_debug)</a>
<a name="ln976">            {</a>
<a name="ln977">              zlog_debug (&quot;The LSA is in Seqnumber Wrapping&quot;);</a>
<a name="ln978">              zlog_debug (&quot;MaxAge &amp; MaxSeqNum, discard&quot;);</a>
<a name="ln979">            }</a>
<a name="ln980">	  ospf6_lsa_delete (new);</a>
<a name="ln981">	  return;</a>
<a name="ln982">        }</a>
<a name="ln983"> </a>
<a name="ln984">      /* Otherwise, Send database copy of this LSA to this neighbor */</a>
<a name="ln985">        {</a>
<a name="ln986">          if (is_debug)</a>
<a name="ln987">            {</a>
<a name="ln988">              zlog_debug (&quot;Database copy is more recent.&quot;);</a>
<a name="ln989">              zlog_debug (&quot;Send back directly and then discard&quot;);</a>
<a name="ln990">            }</a>
<a name="ln991"> </a>
<a name="ln992">          /* XXX, MinLSArrival check !? RFC 2328 13 (8) */</a>
<a name="ln993"> </a>
<a name="ln994">          ospf6_lsdb_add (ospf6_lsa_copy (old), from-&gt;lsupdate_list);</a>
<a name="ln995">          if (from-&gt;thread_send_lsupdate == NULL)</a>
<a name="ln996">            from-&gt;thread_send_lsupdate =</a>
<a name="ln997">              thread_add_event (master, ospf6_lsupdate_send_neighbor, from, 0);</a>
<a name="ln998">	  ospf6_lsa_delete (new);</a>
<a name="ln999">	  return;</a>
<a name="ln1000">        }</a>
<a name="ln1001">      return;</a>
<a name="ln1002">    }</a>
<a name="ln1003">}</a>
<a name="ln1004"> </a>
<a name="ln1005"> </a>
<a name="ln1006">DEFUN (debug_ospf6_flooding,</a>
<a name="ln1007">       debug_ospf6_flooding_cmd,</a>
<a name="ln1008">       &quot;debug ospf6 flooding&quot;,</a>
<a name="ln1009">       DEBUG_STR</a>
<a name="ln1010">       OSPF6_STR</a>
<a name="ln1011">       &quot;Debug OSPFv3 flooding function\n&quot;</a>
<a name="ln1012">      )</a>
<a name="ln1013">{</a>
<a name="ln1014">  OSPF6_DEBUG_FLOODING_ON ();</a>
<a name="ln1015">  return CMD_SUCCESS;</a>
<a name="ln1016">}</a>
<a name="ln1017"> </a>
<a name="ln1018">DEFUN (no_debug_ospf6_flooding,</a>
<a name="ln1019">       no_debug_ospf6_flooding_cmd,</a>
<a name="ln1020">       &quot;no debug ospf6 flooding&quot;,</a>
<a name="ln1021">       NO_STR</a>
<a name="ln1022">       DEBUG_STR</a>
<a name="ln1023">       OSPF6_STR</a>
<a name="ln1024">       &quot;Debug OSPFv3 flooding function\n&quot;</a>
<a name="ln1025">      )</a>
<a name="ln1026">{</a>
<a name="ln1027">  OSPF6_DEBUG_FLOODING_OFF ();</a>
<a name="ln1028">  return CMD_SUCCESS;</a>
<a name="ln1029">}</a>
<a name="ln1030"> </a>
<a name="ln1031">int</a>
<a name="ln1032">config_write_ospf6_debug_flood (struct vty *vty)</a>
<a name="ln1033">{</a>
<a name="ln1034">  if (IS_OSPF6_DEBUG_FLOODING)</a>
<a name="ln1035">    vty_out (vty, &quot;debug ospf6 flooding%s&quot;, VNL);</a>
<a name="ln1036">  return 0;</a>
<a name="ln1037">}</a>
<a name="ln1038"> </a>
<a name="ln1039">void</a>
<a name="ln1040">install_element_ospf6_debug_flood (void)</a>
<a name="ln1041">{</a>
<a name="ln1042">  install_element (ENABLE_NODE, &amp;debug_ospf6_flooding_cmd);</a>
<a name="ln1043">  install_element (ENABLE_NODE, &amp;no_debug_ospf6_flooding_cmd);</a>
<a name="ln1044">  install_element (CONFIG_NODE, &amp;debug_ospf6_flooding_cmd);</a>
<a name="ln1045">  install_element (CONFIG_NODE, &amp;no_debug_ospf6_flooding_cmd);</a>
<a name="ln1046">}</a>
<a name="ln1047"> </a>
<a name="ln1048"> </a>
<a name="ln1049"> </a>
<a name="ln1050"> </a>
<a name="ln1051"> </a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
