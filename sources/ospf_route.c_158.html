
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_route.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF routing table.</a>
<a name="ln3"> * Copyright (C) 1999, 2000 Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;table.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;linklist.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;if.h&quot;</a>
<a name="ln31">#include &quot;command.h&quot;</a>
<a name="ln32">#include &quot;sockunion.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln35">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln36">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">struct ospf_route *</a>
<a name="ln44">ospf_route_new ()</a>
<a name="ln45">{</a>
<a name="ln46">  struct ospf_route *new;</a>
<a name="ln47"> </a>
<a name="ln48">  new = XCALLOC (MTYPE_OSPF_ROUTE, sizeof (struct ospf_route));</a>
<a name="ln49"> </a>
<a name="ln50">  new-&gt;ctime = quagga_time (NULL);</a>
<a name="ln51">  new-&gt;mtime = new-&gt;ctime;</a>
<a name="ln52">  new-&gt;paths = list_new ();</a>
<a name="ln53">  new-&gt;paths-&gt;del = (void (*) (void *))ospf_path_free;</a>
<a name="ln54"> </a>
<a name="ln55">  return new;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">void</a>
<a name="ln59">ospf_route_free (struct ospf_route *or)</a>
<a name="ln60">{</a>
<a name="ln61">  if (or-&gt;paths)</a>
<a name="ln62">      list_delete (or-&gt;paths);</a>
<a name="ln63"> </a>
<a name="ln64">  XFREE (MTYPE_OSPF_ROUTE, or);</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">struct ospf_path *</a>
<a name="ln68">ospf_path_new ()</a>
<a name="ln69">{</a>
<a name="ln70">  struct ospf_path *new;</a>
<a name="ln71"> </a>
<a name="ln72">  new = XCALLOC (MTYPE_OSPF_PATH, sizeof (struct ospf_path));</a>
<a name="ln73"> </a>
<a name="ln74">  return new;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">static struct ospf_path *</a>
<a name="ln78">ospf_path_dup (struct ospf_path *path)</a>
<a name="ln79">{</a>
<a name="ln80">  struct ospf_path *new;</a>
<a name="ln81"> </a>
<a name="ln82">  new = ospf_path_new ();</a>
<a name="ln83">  memcpy (new, path, sizeof (struct ospf_path));</a>
<a name="ln84"> </a>
<a name="ln85">  return new;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">void</a>
<a name="ln89">ospf_path_free (struct ospf_path *op)</a>
<a name="ln90">{</a>
<a name="ln91">  XFREE (MTYPE_OSPF_PATH, op);</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">void</a>
<a name="ln95">ospf_route_delete (struct route_table *rt)</a>
<a name="ln96">{</a>
<a name="ln97">  struct route_node *rn;</a>
<a name="ln98">  struct ospf_route *or;</a>
<a name="ln99"> </a>
<a name="ln100">  for (rn = route_top (rt); rn; rn = route_next (rn))</a>
<a name="ln101">    if ((or = rn-&gt;info) != NULL)</a>
<a name="ln102">      {</a>
<a name="ln103">	if (or-&gt;type == OSPF_DESTINATION_NETWORK)</a>
<a name="ln104">	  ospf_zebra_delete ((struct prefix_ipv4 *) &amp;rn-&gt;p,</a>
<a name="ln105">				       or);</a>
<a name="ln106">	else if (or-&gt;type == OSPF_DESTINATION_DISCARD)</a>
<a name="ln107">	  ospf_zebra_delete_discard ((struct prefix_ipv4 *) &amp;rn-&gt;p);</a>
<a name="ln108">      }</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">void</a>
<a name="ln112">ospf_route_table_free (struct route_table *rt)</a>
<a name="ln113">{</a>
<a name="ln114">  struct route_node *rn;</a>
<a name="ln115">  struct ospf_route *or;</a>
<a name="ln116"> </a>
<a name="ln117">  for (rn = route_top (rt); rn; rn = route_next (rn))</a>
<a name="ln118">    if ((or = rn-&gt;info) != NULL)</a>
<a name="ln119">      {</a>
<a name="ln120">	ospf_route_free (or);</a>
<a name="ln121"> </a>
<a name="ln122">	rn-&gt;info = NULL;</a>
<a name="ln123">	route_unlock_node (rn);</a>
<a name="ln124">      }</a>
<a name="ln125"> </a>
<a name="ln126">   route_table_finish (rt);</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">/* If a prefix exists in the new routing table, then return 1,</a>
<a name="ln130">   otherwise return 0. Since the ZEBRA-RIB does an implicit</a>
<a name="ln131">   withdraw, it is not necessary to send a delete, an add later</a>
<a name="ln132">   will act like an implicit delete. */</a>
<a name="ln133">static int</a>
<a name="ln134">ospf_route_exist_new_table (struct route_table *rt, struct prefix_ipv4 *prefix)</a>
<a name="ln135">{</a>
<a name="ln136">  struct route_node *rn;</a>
<a name="ln137"> </a>
<a name="ln138">  assert (rt);</a>
<a name="ln139">  assert (prefix);</a>
<a name="ln140"> </a>
<a name="ln141">  rn = route_node_lookup (rt, (struct prefix *) prefix);</a>
<a name="ln142">  if (!rn) {</a>
<a name="ln143">    return 0;</a>
<a name="ln144">  }</a>
<a name="ln145">  route_unlock_node (rn);</a>
<a name="ln146"> </a>
<a name="ln147">  if (!rn-&gt;info) {</a>
<a name="ln148">    return 0;</a>
<a name="ln149">  }</a>
<a name="ln150"> </a>
<a name="ln151">  return 1;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">/* If a prefix and a nexthop match any route in the routing table,</a>
<a name="ln155">   then return 1, otherwise return 0. */</a>
<a name="ln156">int</a>
<a name="ln157">ospf_route_match_same (struct route_table *rt, struct prefix_ipv4 *prefix,</a>
<a name="ln158">		       struct ospf_route *newor)</a>
<a name="ln159">{</a>
<a name="ln160">  struct route_node *rn;</a>
<a name="ln161">  struct ospf_route *or;</a>
<a name="ln162">  struct ospf_path *op;</a>
<a name="ln163">  struct ospf_path *newop;</a>
<a name="ln164">  struct listnode *n1;</a>
<a name="ln165">  struct listnode *n2;</a>
<a name="ln166"> </a>
<a name="ln167">  if (! rt || ! prefix)</a>
<a name="ln168">    return 0;</a>
<a name="ln169"> </a>
<a name="ln170">   rn = route_node_lookup (rt, (struct prefix *) prefix);</a>
<a name="ln171">   if (! rn || ! rn-&gt;info)</a>
<a name="ln172">     return 0;</a>
<a name="ln173"> </a>
<a name="ln174">   route_unlock_node (rn);</a>
<a name="ln175"> </a>
<a name="ln176">   or = rn-&gt;info;</a>
<a name="ln177">   if (or-&gt;type == newor-&gt;type &amp;&amp; or-&gt;cost == newor-&gt;cost)</a>
<a name="ln178">     {</a>
<a name="ln179">       if (or-&gt;type == OSPF_DESTINATION_NETWORK)</a>
<a name="ln180">	 {</a>
<a name="ln181">	   if (or-&gt;paths-&gt;count != newor-&gt;paths-&gt;count)</a>
<a name="ln182">	     return 0;</a>
<a name="ln183"> </a>
<a name="ln184">	   /* Check each path. */</a>
<a name="ln185">	   for (n1 = listhead (or-&gt;paths), n2 = listhead (newor-&gt;paths);</a>
<a name="ln186">		n1 &amp;&amp; n2; n1 = listnextnode (n1), n2 = listnextnode (n2))</a>
<a name="ln187">	     { </a>
<a name="ln188">	       op = listgetdata (n1);</a>
<a name="ln189">	       newop = listgetdata (n2);</a>
<a name="ln190"> </a>
<a name="ln191">	       if (! IPV4_ADDR_SAME (&amp;op-&gt;nexthop, &amp;newop-&gt;nexthop))</a>
<a name="ln192">		 return 0;</a>
<a name="ln193">	       if (op-&gt;ifindex != newop-&gt;ifindex)</a>
<a name="ln194">		 return 0;</a>
<a name="ln195">	     }</a>
<a name="ln196">	   return 1;</a>
<a name="ln197">	 }</a>
<a name="ln198">       else if (prefix_same (&amp;rn-&gt;p, (struct prefix *) prefix))</a>
<a name="ln199">	 return 1;</a>
<a name="ln200">     }</a>
<a name="ln201">  return 0;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">/* delete routes generated from AS-External routes if there is a inter/intra</a>
<a name="ln205"> * area route</a>
<a name="ln206"> */</a>
<a name="ln207">static void </a>
<a name="ln208">ospf_route_delete_same_ext(struct route_table *external_routes,</a>
<a name="ln209">                     struct route_table *routes)</a>
<a name="ln210">{</a>
<a name="ln211">  struct route_node *rn,</a>
<a name="ln212">                    *ext_rn;</a>
<a name="ln213">  </a>
<a name="ln214">  if ( (external_routes == NULL) || (routes == NULL) )</a>
<a name="ln215">    return;</a>
<a name="ln216">  </a>
<a name="ln217">  /* Remove deleted routes */</a>
<a name="ln218">  for ( rn = route_top (routes); rn; rn = route_next (rn) )</a>
<a name="ln219">    {</a>
<a name="ln220">      if (rn &amp;&amp; rn-&gt;info)</a>
<a name="ln221">        {</a>
<a name="ln222">          struct prefix_ipv4 *p = (struct prefix_ipv4 *)(&amp;rn-&gt;p);</a>
<a name="ln223">          if ( (ext_rn = route_node_lookup (external_routes, (struct prefix *)p)) )</a>
<a name="ln224">            {</a>
<a name="ln225">              if (ext_rn-&gt;info)</a>
<a name="ln226">                {</a>
<a name="ln227">                  ospf_zebra_delete (p, ext_rn-&gt;info);</a>
<a name="ln228">                  ospf_route_free( ext_rn-&gt;info);</a>
<a name="ln229">                  ext_rn-&gt;info = NULL;</a>
<a name="ln230">                }</a>
<a name="ln231">              route_unlock_node (ext_rn);</a>
<a name="ln232">            }</a>
<a name="ln233">        }</a>
<a name="ln234">    }</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">/* rt: Old, cmprt: New */</a>
<a name="ln238">static void</a>
<a name="ln239">ospf_route_delete_uniq (struct route_table *rt, struct route_table *cmprt)</a>
<a name="ln240">{</a>
<a name="ln241">  struct route_node *rn;</a>
<a name="ln242">  struct ospf_route *or;</a>
<a name="ln243"> </a>
<a name="ln244">  for (rn = route_top (rt); rn; rn = route_next (rn))</a>
<a name="ln245">    if ((or = rn-&gt;info) != NULL) </a>
<a name="ln246">      if (or-&gt;path_type == OSPF_PATH_INTRA_AREA ||</a>
<a name="ln247">	  or-&gt;path_type == OSPF_PATH_INTER_AREA)</a>
<a name="ln248">	{</a>
<a name="ln249">	  if (or-&gt;type == OSPF_DESTINATION_NETWORK)</a>
<a name="ln250">	    {</a>
<a name="ln251">	      if (! ospf_route_exist_new_table (cmprt,</a>
<a name="ln252">					   (struct prefix_ipv4 *) &amp;rn-&gt;p))</a>
<a name="ln253">		ospf_zebra_delete ((struct prefix_ipv4 *) &amp;rn-&gt;p, or);</a>
<a name="ln254">	    }</a>
<a name="ln255">	  else if (or-&gt;type == OSPF_DESTINATION_DISCARD)</a>
<a name="ln256">	    if (! ospf_route_exist_new_table (cmprt,</a>
<a name="ln257">					 (struct prefix_ipv4 *) &amp;rn-&gt;p))</a>
<a name="ln258">	      ospf_zebra_delete_discard ((struct prefix_ipv4 *) &amp;rn-&gt;p);</a>
<a name="ln259">	}</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">/* Install routes to table. */</a>
<a name="ln263">void</a>
<a name="ln264">ospf_route_install (struct ospf *ospf, struct route_table *rt)</a>
<a name="ln265">{</a>
<a name="ln266">  struct route_node *rn;</a>
<a name="ln267">  struct ospf_route *or;</a>
<a name="ln268"> </a>
<a name="ln269">  /* rt contains new routing table, new_table contains an old one.</a>
<a name="ln270">     updating pointers */</a>
<a name="ln271">  if (ospf-&gt;old_table)</a>
<a name="ln272">    ospf_route_table_free (ospf-&gt;old_table);</a>
<a name="ln273"> </a>
<a name="ln274">  ospf-&gt;old_table = ospf-&gt;new_table;</a>
<a name="ln275">  ospf-&gt;new_table = rt;</a>
<a name="ln276"> </a>
<a name="ln277">  /* Delete old routes. */</a>
<a name="ln278">  if (ospf-&gt;old_table)</a>
<a name="ln279">    ospf_route_delete_uniq (ospf-&gt;old_table, rt);</a>
<a name="ln280">  if (ospf-&gt;old_external_route)</a>
<a name="ln281">    ospf_route_delete_same_ext (ospf-&gt;old_external_route, rt);</a>
<a name="ln282"> </a>
<a name="ln283">  /* Install new routes. */</a>
<a name="ln284">  for (rn = route_top (rt); rn; rn = route_next (rn))</a>
<a name="ln285">    if ((or = rn-&gt;info) != NULL)</a>
<a name="ln286">      {</a>
<a name="ln287">	if (or-&gt;type == OSPF_DESTINATION_NETWORK)</a>
<a name="ln288">	  {</a>
<a name="ln289">	    if (! ospf_route_match_same (ospf-&gt;old_table,</a>
<a name="ln290">					 (struct prefix_ipv4 *)&amp;rn-&gt;p, or))</a>
<a name="ln291">	      ospf_zebra_add ((struct prefix_ipv4 *) &amp;rn-&gt;p, or);</a>
<a name="ln292">	  }</a>
<a name="ln293">	else if (or-&gt;type == OSPF_DESTINATION_DISCARD)</a>
<a name="ln294">	  if (! ospf_route_match_same (ospf-&gt;old_table,</a>
<a name="ln295">				       (struct prefix_ipv4 *) &amp;rn-&gt;p, or))</a>
<a name="ln296">	    ospf_zebra_add_discard ((struct prefix_ipv4 *) &amp;rn-&gt;p);</a>
<a name="ln297">      }</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">/* RFC2328 16.1. (4). For &quot;router&quot;. */</a>
<a name="ln301">void</a>
<a name="ln302">ospf_intra_add_router (struct route_table *rt, struct vertex *v,</a>
<a name="ln303">		       struct ospf_area *area)</a>
<a name="ln304">{</a>
<a name="ln305">  struct route_node *rn;</a>
<a name="ln306">  struct ospf_route *or;</a>
<a name="ln307">  struct prefix_ipv4 p;</a>
<a name="ln308">  struct router_lsa *lsa;</a>
<a name="ln309"> </a>
<a name="ln310">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln311">    zlog_debug (&quot;ospf_intra_add_router: Start&quot;);</a>
<a name="ln312"> </a>
<a name="ln313">  lsa = (struct router_lsa *) v-&gt;lsa;</a>
<a name="ln314"> </a>
<a name="ln315">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln316">    zlog_debug (&quot;ospf_intra_add_router: LS ID: %s&quot;,</a>
<a name="ln317">	       inet_ntoa (lsa-&gt;header.id));</a>
<a name="ln318">  </a>
<a name="ln319">  if (!OSPF_IS_AREA_BACKBONE(area))</a>
<a name="ln320">    ospf_vl_up_check (area, lsa-&gt;header.id, v);</a>
<a name="ln321"> </a>
<a name="ln322">  if (!CHECK_FLAG (lsa-&gt;flags, ROUTER_LSA_SHORTCUT))</a>
<a name="ln323">    area-&gt;shortcut_capability = 0;</a>
<a name="ln324"> </a>
<a name="ln325">  /* If the newly added vertex is an area border router or AS boundary</a>
<a name="ln326">     router, a routing table entry is added whose destination type is</a>
<a name="ln327">     &quot;router&quot;. */</a>
<a name="ln328">  if (! IS_ROUTER_LSA_BORDER (lsa) &amp;&amp; ! IS_ROUTER_LSA_EXTERNAL (lsa))</a>
<a name="ln329">    {</a>
<a name="ln330">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln331">	zlog_debug (&quot;ospf_intra_add_router: &quot;</a>
<a name="ln332">		   &quot;this router is neither ASBR nor ABR, skipping it&quot;);</a>
<a name="ln333">      return;</a>
<a name="ln334">    }</a>
<a name="ln335"> </a>
<a name="ln336">  /* Update ABR and ASBR count in this area. */</a>
<a name="ln337">  if (IS_ROUTER_LSA_BORDER (lsa))</a>
<a name="ln338">    area-&gt;abr_count++;</a>
<a name="ln339">  if (IS_ROUTER_LSA_EXTERNAL (lsa))</a>
<a name="ln340">    area-&gt;asbr_count++;</a>
<a name="ln341"> </a>
<a name="ln342">  /* The Options field found in the associated router-LSA is copied</a>
<a name="ln343">     into the routing table entry's Optional capabilities field. Call</a>
<a name="ln344">     the newly added vertex Router X. */</a>
<a name="ln345">  or = ospf_route_new ();</a>
<a name="ln346"> </a>
<a name="ln347">  or-&gt;id = v-&gt;id;</a>
<a name="ln348">  or-&gt;u.std.area_id = area-&gt;area_id;</a>
<a name="ln349">  or-&gt;u.std.external_routing = area-&gt;external_routing;</a>
<a name="ln350">  or-&gt;path_type = OSPF_PATH_INTRA_AREA;</a>
<a name="ln351">  or-&gt;cost = v-&gt;distance;</a>
<a name="ln352">  or-&gt;type = OSPF_DESTINATION_ROUTER;</a>
<a name="ln353">  or-&gt;u.std.origin = (struct lsa_header *) lsa;</a>
<a name="ln354">  or-&gt;u.std.options = lsa-&gt;header.options;</a>
<a name="ln355">  or-&gt;u.std.flags = lsa-&gt;flags;</a>
<a name="ln356"> </a>
<a name="ln357">  /* If Router X is the endpoint of one of the calculating router's</a>
<a name="ln358">     virtual links, and the virtual link uses Area A as Transit area:</a>
<a name="ln359">     the virtual link is declared up, the IP address of the virtual</a>
<a name="ln360">     interface is set to the IP address of the outgoing interface</a>
<a name="ln361">     calculated above for Router X, and the virtual neighbor's IP</a>
<a name="ln362">     address is set to Router X's interface address (contained in</a>
<a name="ln363">     Router X's router-LSA) that points back to the root of the</a>
<a name="ln364">     shortest- path tree; equivalently, this is the interface that</a>
<a name="ln365">     points back to Router X's parent vertex on the shortest-path tree</a>
<a name="ln366">     (similar to the calculation in Section 16.1.1). */</a>
<a name="ln367"> </a>
<a name="ln368">  p.family = AF_INET;</a>
<a name="ln369">  p.prefix = v-&gt;id;</a>
<a name="ln370">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln371"> </a>
<a name="ln372">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln373">    zlog_debug (&quot;ospf_intra_add_router: talking about %s/%d&quot;,</a>
<a name="ln374">	       inet_ntoa (p.prefix), p.prefixlen);</a>
<a name="ln375"> </a>
<a name="ln376">  rn = route_node_get (rt, (struct prefix *) &amp;p);</a>
<a name="ln377"> </a>
<a name="ln378">  /* Note that we keep all routes to ABRs and ASBRs, not only the best */</a>
<a name="ln379">  if (rn-&gt;info == NULL)</a>
<a name="ln380">    rn-&gt;info = list_new ();</a>
<a name="ln381">  else</a>
<a name="ln382">    route_unlock_node (rn);</a>
<a name="ln383"> </a>
<a name="ln384">  ospf_route_copy_nexthops_from_vertex (or, v);</a>
<a name="ln385"> </a>
<a name="ln386">  listnode_add (rn-&gt;info, or);</a>
<a name="ln387"> </a>
<a name="ln388">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln389">    zlog_debug (&quot;ospf_intra_add_router: Stop&quot;);</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">/* RFC2328 16.1. (4).  For transit network. */</a>
<a name="ln393">void</a>
<a name="ln394">ospf_intra_add_transit (struct route_table *rt, struct vertex *v,</a>
<a name="ln395">			struct ospf_area *area)</a>
<a name="ln396">{</a>
<a name="ln397">  struct route_node *rn;</a>
<a name="ln398">  struct ospf_route *or;</a>
<a name="ln399">  struct prefix_ipv4 p;</a>
<a name="ln400">  struct network_lsa *lsa;</a>
<a name="ln401"> </a>
<a name="ln402">  lsa = (struct network_lsa*) v-&gt;lsa;</a>
<a name="ln403"> </a>
<a name="ln404">  /* If the newly added vertex is a transit network, the routing table</a>
<a name="ln405">     entry for the network is located.  The entry's Destination ID is</a>
<a name="ln406">     the IP network number, which can be obtained by masking the</a>
<a name="ln407">     Vertex ID (Link State ID) with its associated subnet mask (found</a>
<a name="ln408">     in the body of the associated network-LSA). */</a>
<a name="ln409">  p.family = AF_INET;</a>
<a name="ln410">  p.prefix = v-&gt;id;</a>
<a name="ln411">  p.prefixlen = ip_masklen (lsa-&gt;mask);</a>
<a name="ln412">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln413"> </a>
<a name="ln414">  rn = route_node_get (rt, (struct prefix *) &amp;p);</a>
<a name="ln415"> </a>
<a name="ln416">  /* If the routing table entry already exists (i.e., there is already</a>
<a name="ln417">     an intra-area route to the destination installed in the routing</a>
<a name="ln418">     table), multiple vertices have mapped to the same IP network.</a>
<a name="ln419">     For example, this can occur when a new Designated Router is being</a>
<a name="ln420">     established.  In this case, the current routing table entry</a>
<a name="ln421">     should be overwritten if and only if the newly found path is just</a>
<a name="ln422">     as short and the current routing table entry's Link State Origin</a>
<a name="ln423">     has a smaller Link State ID than the newly added vertex' LSA. */</a>
<a name="ln424">  if (rn-&gt;info)</a>
<a name="ln425">    {</a>
<a name="ln426">      struct ospf_route *cur_or;</a>
<a name="ln427"> </a>
<a name="ln428">      route_unlock_node (rn);</a>
<a name="ln429">      cur_or = rn-&gt;info;</a>
<a name="ln430"> </a>
<a name="ln431">      if (v-&gt;distance &gt; cur_or-&gt;cost ||</a>
<a name="ln432">          IPV4_ADDR_CMP (&amp;cur_or-&gt;u.std.origin-&gt;id, &amp;lsa-&gt;header.id) &gt; 0)</a>
<a name="ln433">	return;</a>
<a name="ln434">      </a>
<a name="ln435">      ospf_route_free (rn-&gt;info);</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">  or = ospf_route_new ();</a>
<a name="ln439"> </a>
<a name="ln440">  or-&gt;id = v-&gt;id;</a>
<a name="ln441">  or-&gt;u.std.area_id = area-&gt;area_id;</a>
<a name="ln442">  or-&gt;u.std.external_routing = area-&gt;external_routing;</a>
<a name="ln443">  or-&gt;path_type = OSPF_PATH_INTRA_AREA;</a>
<a name="ln444">  or-&gt;cost = v-&gt;distance;</a>
<a name="ln445">  or-&gt;type = OSPF_DESTINATION_NETWORK;</a>
<a name="ln446">  or-&gt;u.std.origin = (struct lsa_header *) lsa;</a>
<a name="ln447"> </a>
<a name="ln448">  ospf_route_copy_nexthops_from_vertex (or, v);</a>
<a name="ln449">  </a>
<a name="ln450">  rn-&gt;info = or;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">/* RFC2328 16.1. second stage. */</a>
<a name="ln454">void</a>
<a name="ln455">ospf_intra_add_stub (struct route_table *rt, struct router_lsa_link *link,</a>
<a name="ln456">		     struct vertex *v, struct ospf_area *area,</a>
<a name="ln457">		     int parent_is_root, int lsa_pos)</a>
<a name="ln458">{</a>
<a name="ln459">  u_int32_t cost;</a>
<a name="ln460">  struct route_node *rn;</a>
<a name="ln461">  struct ospf_route *or;</a>
<a name="ln462">  struct prefix_ipv4 p;</a>
<a name="ln463">  struct router_lsa *lsa;</a>
<a name="ln464">  struct ospf_interface *oi;</a>
<a name="ln465">  struct ospf_path *path;</a>
<a name="ln466"> </a>
<a name="ln467">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln468">    zlog_debug (&quot;ospf_intra_add_stub(): Start&quot;);</a>
<a name="ln469"> </a>
<a name="ln470">  lsa = (struct router_lsa *) v-&gt;lsa;</a>
<a name="ln471"> </a>
<a name="ln472">  p.family = AF_INET;</a>
<a name="ln473">  p.prefix = link-&gt;link_id;</a>
<a name="ln474">  p.prefixlen = ip_masklen (link-&gt;link_data);</a>
<a name="ln475">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln476"> </a>
<a name="ln477">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln478">    zlog_debug (&quot;ospf_intra_add_stub(): processing route to %s/%d&quot;,  </a>
<a name="ln479">	       inet_ntoa (p.prefix), p.prefixlen);</a>
<a name="ln480"> </a>
<a name="ln481">  /* (1) Calculate the distance D of stub network from the root.  D is</a>
<a name="ln482">     equal to the distance from the root to the router vertex</a>
<a name="ln483">     (calculated in stage 1), plus the stub network link's advertised</a>
<a name="ln484">     cost. */</a>
<a name="ln485">  cost = v-&gt;distance + ntohs (link-&gt;m[0].metric);</a>
<a name="ln486"> </a>
<a name="ln487">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln488">    zlog_debug (&quot;ospf_intra_add_stub(): calculated cost is %d + %d = %d&quot;, </a>
<a name="ln489">	       v-&gt;distance, ntohs(link-&gt;m[0].metric), cost);</a>
<a name="ln490">  </a>
<a name="ln491">  /* PtP links with /32 masks adds host routes to remote, directly</a>
<a name="ln492">   * connected hosts, see RFC 2328, 12.4.1.1, Option 1.</a>
<a name="ln493">   * Such routes can just be ignored for the sake of tidyness.</a>
<a name="ln494">   */</a>
<a name="ln495">  if (parent_is_root &amp;&amp; link-&gt;link_data.s_addr == 0xffffffff &amp;&amp;</a>
<a name="ln496">      ospf_if_lookup_by_local_addr (area-&gt;ospf, NULL, link-&gt;link_id))</a>
<a name="ln497">    {</a>
<a name="ln498">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln499">        zlog_debug (&quot;%s: ignoring host route %s/32 to self.&quot;,</a>
<a name="ln500">                    __func__, inet_ntoa (link-&gt;link_id));</a>
<a name="ln501">      return;</a>
<a name="ln502">    }</a>
<a name="ln503">  </a>
<a name="ln504">  rn = route_node_get (rt, (struct prefix *) &amp;p);</a>
<a name="ln505"> </a>
<a name="ln506">  /* Lookup current routing table. */</a>
<a name="ln507">  if (rn-&gt;info)</a>
<a name="ln508">    {</a>
<a name="ln509">      struct ospf_route *cur_or;</a>
<a name="ln510"> </a>
<a name="ln511">      route_unlock_node (rn);</a>
<a name="ln512"> </a>
<a name="ln513">      cur_or = rn-&gt;info;</a>
<a name="ln514"> </a>
<a name="ln515">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln516">	zlog_debug (&quot;ospf_intra_add_stub(): &quot;</a>
<a name="ln517">		   &quot;another route to the same prefix found with cost %u&quot;,</a>
<a name="ln518">		   cur_or-&gt;cost);</a>
<a name="ln519"> </a>
<a name="ln520">      /* Compare this distance to the current best cost to the stub</a>
<a name="ln521">	 network.  This is done by looking up the stub network's</a>
<a name="ln522">	 current routing table entry.  If the calculated distance D is</a>
<a name="ln523">	 larger, go on to examine the next stub network link in the</a>
<a name="ln524">	 LSA. */</a>
<a name="ln525">      if (cost &gt; cur_or-&gt;cost)</a>
<a name="ln526">	{</a>
<a name="ln527">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln528">	    zlog_debug (&quot;ospf_intra_add_stub(): old route is better, exit&quot;);</a>
<a name="ln529">	  return;</a>
<a name="ln530">	}</a>
<a name="ln531"> </a>
<a name="ln532">      /* (2) If this step is reached, the stub network's routing table</a>
<a name="ln533">	 entry must be updated.  Calculate the set of next hops that</a>
<a name="ln534">	 would result from using the stub network link.  This</a>
<a name="ln535">	 calculation is shown in Section 16.1.1; input to this</a>
<a name="ln536">	 calculation is the destination (the stub network) and the</a>
<a name="ln537">	 parent vertex (the router vertex). If the distance D is the</a>
<a name="ln538">	 same as the current routing table cost, simply add this set</a>
<a name="ln539">	 of next hops to the routing table entry's list of next hops.</a>
<a name="ln540">	 In this case, the routing table already has a Link State</a>
<a name="ln541">	 Origin.  If this Link State Origin is a router-LSA whose Link</a>
<a name="ln542">	 State ID is smaller than V's Router ID, reset the Link State</a>
<a name="ln543">	 Origin to V's router-LSA. */</a>
<a name="ln544"> </a>
<a name="ln545">      if (cost == cur_or-&gt;cost)</a>
<a name="ln546">	{</a>
<a name="ln547">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln548">	    zlog_debug (&quot;ospf_intra_add_stub(): routes are equal, merge&quot;);</a>
<a name="ln549"> </a>
<a name="ln550">	  ospf_route_copy_nexthops_from_vertex (cur_or, v);</a>
<a name="ln551"> </a>
<a name="ln552">	  if (IPV4_ADDR_CMP (&amp;cur_or-&gt;u.std.origin-&gt;id, &amp;lsa-&gt;header.id) &lt; 0)</a>
<a name="ln553">	    cur_or-&gt;u.std.origin = (struct lsa_header *) lsa;</a>
<a name="ln554">	  return;</a>
<a name="ln555">	}</a>
<a name="ln556"> </a>
<a name="ln557">      /* Otherwise D is smaller than the routing table cost.</a>
<a name="ln558">	 Overwrite the current routing table entry by setting the</a>
<a name="ln559">	 routing table entry's cost to D, and by setting the entry's</a>
<a name="ln560">	 list of next hops to the newly calculated set.  Set the</a>
<a name="ln561">	 routing table entry's Link State Origin to V's router-LSA.</a>
<a name="ln562">	 Then go on to examine the next stub network link. */</a>
<a name="ln563"> </a>
<a name="ln564">      if (cost &lt; cur_or-&gt;cost)</a>
<a name="ln565">	{</a>
<a name="ln566">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln567">	    zlog_debug (&quot;ospf_intra_add_stub(): new route is better, set it&quot;);</a>
<a name="ln568"> </a>
<a name="ln569">	  cur_or-&gt;cost = cost;</a>
<a name="ln570"> </a>
<a name="ln571">	  list_delete_all_node (cur_or-&gt;paths);</a>
<a name="ln572"> </a>
<a name="ln573">	  ospf_route_copy_nexthops_from_vertex (cur_or, v);</a>
<a name="ln574"> </a>
<a name="ln575">	  cur_or-&gt;u.std.origin = (struct lsa_header *) lsa;</a>
<a name="ln576">	  return;</a>
<a name="ln577">	}</a>
<a name="ln578">    }</a>
<a name="ln579"> </a>
<a name="ln580">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln581">    zlog_debug (&quot;ospf_intra_add_stub(): installing new route&quot;);</a>
<a name="ln582"> </a>
<a name="ln583">  or = ospf_route_new ();</a>
<a name="ln584"> </a>
<a name="ln585">  or-&gt;id = v-&gt;id;</a>
<a name="ln586">  or-&gt;u.std.area_id = area-&gt;area_id;</a>
<a name="ln587">  or-&gt;u.std.external_routing = area-&gt;external_routing;</a>
<a name="ln588">  or-&gt;path_type = OSPF_PATH_INTRA_AREA;</a>
<a name="ln589">  or-&gt;cost = cost;</a>
<a name="ln590">  or-&gt;type = OSPF_DESTINATION_NETWORK;</a>
<a name="ln591">  or-&gt;u.std.origin = (struct lsa_header *) lsa;</a>
<a name="ln592"> </a>
<a name="ln593">  /* Nexthop is depend on connection type. */</a>
<a name="ln594">  if (v != area-&gt;spf)</a>
<a name="ln595">    {</a>
<a name="ln596">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln597">	zlog_debug (&quot;ospf_intra_add_stub(): this network is on remote router&quot;);</a>
<a name="ln598">      ospf_route_copy_nexthops_from_vertex (or, v);</a>
<a name="ln599">    }</a>
<a name="ln600">  else</a>
<a name="ln601">    {</a>
<a name="ln602">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln603">	zlog_debug (&quot;ospf_intra_add_stub(): this network is on this router&quot;);</a>
<a name="ln604"> </a>
<a name="ln605">      if ((oi = ospf_if_lookup_by_lsa_pos (area, lsa_pos)))</a>
<a name="ln606">	{</a>
<a name="ln607">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln608">	    zlog_debug (&quot;ospf_intra_add_stub(): the interface is %s&quot;,</a>
<a name="ln609">		       IF_NAME (oi));</a>
<a name="ln610"> </a>
<a name="ln611">	  path = ospf_path_new ();</a>
<a name="ln612">	  path-&gt;nexthop.s_addr = 0;</a>
<a name="ln613">	  path-&gt;ifindex = oi-&gt;ifp-&gt;ifindex;</a>
<a name="ln614">	  listnode_add (or-&gt;paths, path);</a>
<a name="ln615">	}</a>
<a name="ln616">      else</a>
<a name="ln617">	{</a>
<a name="ln618">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln619">	    zlog_debug (&quot;ospf_intra_add_stub(): where's the interface ?&quot;);</a>
<a name="ln620">	}</a>
<a name="ln621">    }</a>
<a name="ln622"> </a>
<a name="ln623">  rn-&gt;info = or;</a>
<a name="ln624"> </a>
<a name="ln625">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln626">    zlog_debug(&quot;ospf_intra_add_stub(): Stop&quot;);</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">const char *ospf_path_type_str[] =</a>
<a name="ln630">{</a>
<a name="ln631">  &quot;unknown-type&quot;,</a>
<a name="ln632">  &quot;intra-area&quot;,</a>
<a name="ln633">  &quot;inter-area&quot;,</a>
<a name="ln634">  &quot;type1-external&quot;,</a>
<a name="ln635">  &quot;type2-external&quot;</a>
<a name="ln636">};</a>
<a name="ln637"> </a>
<a name="ln638">void</a>
<a name="ln639">ospf_route_table_dump (struct route_table *rt)</a>
<a name="ln640">{</a>
<a name="ln641">  struct route_node *rn;</a>
<a name="ln642">  struct ospf_route *or;</a>
<a name="ln643">  char buf1[BUFSIZ];</a>
<a name="ln644">  char buf2[BUFSIZ];</a>
<a name="ln645">  struct listnode *pnode;</a>
<a name="ln646">  struct ospf_path *path;</a>
<a name="ln647"> </a>
<a name="ln648">#if 0</a>
<a name="ln649">  zlog_debug (&quot;Type   Dest   Area   Path	 Type	 Cost	Next	 Adv.&quot;);</a>
<a name="ln650">  zlog_debug (&quot;					Hop(s)	 Router(s)&quot;);</a>
<a name="ln651">#endif /* 0 */</a>
<a name="ln652"> </a>
<a name="ln653">  zlog_debug (&quot;========== OSPF routing table ==========&quot;);</a>
<a name="ln654">  for (rn = route_top (rt); rn; rn = route_next (rn))</a>
<a name="ln655">    if ((or = rn-&gt;info) != NULL)</a>
<a name="ln656">      {</a>
<a name="ln657">        if (or-&gt;type == OSPF_DESTINATION_NETWORK)</a>
<a name="ln658">	  {</a>
<a name="ln659">	    zlog_debug (&quot;N %s/%d\t%s\t%s\t%d&quot;, </a>
<a name="ln660">		       inet_ntop (AF_INET, &amp;rn-&gt;p.u.prefix4, buf1, BUFSIZ),</a>
<a name="ln661">		       rn-&gt;p.prefixlen,</a>
<a name="ln662">		       inet_ntop (AF_INET, &amp;or-&gt;u.std.area_id, buf2,</a>
<a name="ln663">				  BUFSIZ),</a>
<a name="ln664">		       ospf_path_type_str[or-&gt;path_type],</a>
<a name="ln665">		       or-&gt;cost);</a>
<a name="ln666">	    for (ALL_LIST_ELEMENTS_RO (or-&gt;paths, pnode, path))</a>
<a name="ln667">              zlog_debug (&quot;  -&gt; %s&quot;, inet_ntoa (path-&gt;nexthop));</a>
<a name="ln668">	  }</a>
<a name="ln669">        else</a>
<a name="ln670">	  zlog_debug (&quot;R %s\t%s\t%s\t%d&quot;, </a>
<a name="ln671">		     inet_ntop (AF_INET, &amp;rn-&gt;p.u.prefix4, buf1, BUFSIZ),</a>
<a name="ln672">		     inet_ntop (AF_INET, &amp;or-&gt;u.std.area_id, buf2,</a>
<a name="ln673">				BUFSIZ),</a>
<a name="ln674">		     ospf_path_type_str[or-&gt;path_type],</a>
<a name="ln675">		     or-&gt;cost);</a>
<a name="ln676">      }</a>
<a name="ln677">  zlog_debug (&quot;========================================&quot;);</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">/* This is 16.4.1 implementation.</a>
<a name="ln681">   o Intra-area paths using non-backbone areas are always the most preferred.</a>
<a name="ln682">   o The other paths, intra-area backbone paths and inter-area paths,</a>
<a name="ln683">     are of equal preference. */</a>
<a name="ln684">static int</a>
<a name="ln685">ospf_asbr_route_cmp (struct ospf *ospf, struct ospf_route *r1,</a>
<a name="ln686">		     struct ospf_route *r2)</a>
<a name="ln687">{</a>
<a name="ln688">  u_char r1_type, r2_type;</a>
<a name="ln689"> </a>
<a name="ln690">  r1_type = r1-&gt;path_type;</a>
<a name="ln691">  r2_type = r2-&gt;path_type;</a>
<a name="ln692"> </a>
<a name="ln693">  /* r1/r2 itself is backbone, and it's Inter-area path. */</a>
<a name="ln694">  if (OSPF_IS_AREA_ID_BACKBONE (r1-&gt;u.std.area_id))</a>
<a name="ln695">    r1_type = OSPF_PATH_INTER_AREA;</a>
<a name="ln696">  if (OSPF_IS_AREA_ID_BACKBONE (r2-&gt;u.std.area_id))</a>
<a name="ln697">    r2_type = OSPF_PATH_INTER_AREA;</a>
<a name="ln698"> </a>
<a name="ln699">  return (r1_type - r2_type);</a>
<a name="ln700">}</a>
<a name="ln701"> </a>
<a name="ln702">/* Compare two routes.</a>
<a name="ln703"> ret &lt;  0 -- r1 is better.</a>
<a name="ln704"> ret == 0 -- r1 and r2 are the same.</a>
<a name="ln705"> ret &gt;  0 -- r2 is better. */</a>
<a name="ln706">int</a>
<a name="ln707">ospf_route_cmp (struct ospf *ospf, struct ospf_route *r1,</a>
<a name="ln708">		struct ospf_route *r2)</a>
<a name="ln709">{</a>
<a name="ln710">  int ret = 0;</a>
<a name="ln711"> </a>
<a name="ln712">  /* Path types of r1 and r2 are not the same. */</a>
<a name="ln713">  if ((ret = (r1-&gt;path_type - r2-&gt;path_type)))</a>
<a name="ln714">    return ret;</a>
<a name="ln715"> </a>
<a name="ln716">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln717">    zlog_debug (&quot;Route[Compare]: Path types are the same.&quot;);</a>
<a name="ln718">  /* Path types are the same, compare any cost. */</a>
<a name="ln719">  switch (r1-&gt;path_type)</a>
<a name="ln720">    {</a>
<a name="ln721">    case OSPF_PATH_INTRA_AREA:</a>
<a name="ln722">    case OSPF_PATH_INTER_AREA:</a>
<a name="ln723">      break;</a>
<a name="ln724">    case OSPF_PATH_TYPE1_EXTERNAL:</a>
<a name="ln725">      if (!CHECK_FLAG (ospf-&gt;config, OSPF_RFC1583_COMPATIBLE))</a>
<a name="ln726">	{</a>
<a name="ln727">	  ret = ospf_asbr_route_cmp (ospf, r1-&gt;u.ext.asbr, r2-&gt;u.ext.asbr);</a>
<a name="ln728">	  if (ret != 0)</a>
<a name="ln729">	    return ret;</a>
<a name="ln730">	}</a>
<a name="ln731">      break;</a>
<a name="ln732">    case OSPF_PATH_TYPE2_EXTERNAL:</a>
<a name="ln733">      if ((ret = (r1-&gt;u.ext.type2_cost - r2-&gt;u.ext.type2_cost)))</a>
<a name="ln734">	return ret;</a>
<a name="ln735"> </a>
<a name="ln736">      if (!CHECK_FLAG (ospf-&gt;config, OSPF_RFC1583_COMPATIBLE))</a>
<a name="ln737">	{</a>
<a name="ln738">	  ret = ospf_asbr_route_cmp (ospf, r1-&gt;u.ext.asbr, r2-&gt;u.ext.asbr);</a>
<a name="ln739">	  if (ret != 0)</a>
<a name="ln740">	    return ret;</a>
<a name="ln741">	}</a>
<a name="ln742">      break;</a>
<a name="ln743">    }      </a>
<a name="ln744"> </a>
<a name="ln745">  /* Anyway, compare the costs. */</a>
<a name="ln746">  return (r1-&gt;cost - r2-&gt;cost);</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">static int</a>
<a name="ln750">ospf_path_exist (struct list *plist, struct in_addr nexthop,</a>
<a name="ln751">		 struct ospf_interface *oi)</a>
<a name="ln752">{</a>
<a name="ln753">  struct listnode *node, *nnode;</a>
<a name="ln754">  struct ospf_path *path;</a>
<a name="ln755"> </a>
<a name="ln756">  for (ALL_LIST_ELEMENTS (plist, node, nnode, path))</a>
<a name="ln757">    if (IPV4_ADDR_SAME (&amp;path-&gt;nexthop, &amp;nexthop) &amp;&amp;</a>
<a name="ln758">	path-&gt;ifindex == oi-&gt;ifp-&gt;ifindex)</a>
<a name="ln759">      return 1;</a>
<a name="ln760"> </a>
<a name="ln761">  return 0;</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">void</a>
<a name="ln765">ospf_route_copy_nexthops_from_vertex (struct ospf_route *to,</a>
<a name="ln766">				      struct vertex *v)</a>
<a name="ln767">{</a>
<a name="ln768">  struct listnode *node;</a>
<a name="ln769">  struct ospf_path *path;</a>
<a name="ln770">  struct vertex_nexthop *nexthop;</a>
<a name="ln771">  struct vertex_parent *vp;</a>
<a name="ln772"> </a>
<a name="ln773">  assert (to-&gt;paths);</a>
<a name="ln774"> </a>
<a name="ln775">  for (ALL_LIST_ELEMENTS_RO (v-&gt;parents, node, vp))</a>
<a name="ln776">    {</a>
<a name="ln777">      nexthop = vp-&gt;nexthop;</a>
<a name="ln778">      </a>
<a name="ln779">      if (nexthop-&gt;oi != NULL) </a>
<a name="ln780">	{</a>
<a name="ln781">	  if (! ospf_path_exist (to-&gt;paths, nexthop-&gt;router, nexthop-&gt;oi))</a>
<a name="ln782">	    {</a>
<a name="ln783">	      path = ospf_path_new ();</a>
<a name="ln784">	      path-&gt;nexthop = nexthop-&gt;router;</a>
<a name="ln785">	      path-&gt;ifindex = nexthop-&gt;oi-&gt;ifp-&gt;ifindex;</a>
<a name="ln786">	      listnode_add (to-&gt;paths, path);</a>
<a name="ln787">	    }</a>
<a name="ln788">	}</a>
<a name="ln789">    }</a>
<a name="ln790">}</a>
<a name="ln791"> </a>
<a name="ln792">struct ospf_path *</a>
<a name="ln793">ospf_path_lookup (struct list *plist, struct ospf_path *path)</a>
<a name="ln794">{</a>
<a name="ln795">  struct listnode *node;</a>
<a name="ln796">  struct ospf_path *op;</a>
<a name="ln797"> </a>
<a name="ln798">  for (ALL_LIST_ELEMENTS_RO (plist, node, op))</a>
<a name="ln799">  {</a>
<a name="ln800">    if (!IPV4_ADDR_SAME (&amp;op-&gt;nexthop, &amp;path-&gt;nexthop))</a>
<a name="ln801">      continue;</a>
<a name="ln802">    if (!IPV4_ADDR_SAME (&amp;op-&gt;adv_router, &amp;path-&gt;adv_router))</a>
<a name="ln803">      continue;</a>
<a name="ln804">    if (op-&gt;ifindex != path-&gt;ifindex)</a>
<a name="ln805">      continue;</a>
<a name="ln806">    return op;</a>
<a name="ln807">  }</a>
<a name="ln808">  return NULL;</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">void</a>
<a name="ln812">ospf_route_copy_nexthops (struct ospf_route *to, struct list *from)</a>
<a name="ln813">{</a>
<a name="ln814">  struct listnode *node, *nnode;</a>
<a name="ln815">  struct ospf_path *path;</a>
<a name="ln816"> </a>
<a name="ln817">  assert (to-&gt;paths);</a>
<a name="ln818"> </a>
<a name="ln819">  for (ALL_LIST_ELEMENTS (from, node, nnode, path))</a>
<a name="ln820">    /* The same routes are just discarded. */</a>
<a name="ln821">    if (!ospf_path_lookup (to-&gt;paths, path))</a>
<a name="ln822">      listnode_add (to-&gt;paths, ospf_path_dup (path));</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">void</a>
<a name="ln826">ospf_route_subst_nexthops (struct ospf_route *to, struct list *from)</a>
<a name="ln827">{</a>
<a name="ln828"> </a>
<a name="ln829">  list_delete_all_node (to-&gt;paths);</a>
<a name="ln830">  ospf_route_copy_nexthops (to, from);</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">void</a>
<a name="ln834">ospf_route_subst (struct route_node *rn, struct ospf_route *new_or,</a>
<a name="ln835">		  struct ospf_route *over)</a>
<a name="ln836">{</a>
<a name="ln837">  route_lock_node (rn);</a>
<a name="ln838">  ospf_route_free (rn-&gt;info);</a>
<a name="ln839"> </a>
<a name="ln840">  ospf_route_copy_nexthops (new_or, over-&gt;paths);</a>
<a name="ln841">  rn-&gt;info = new_or;</a>
<a name="ln842">  route_unlock_node (rn);</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">void</a>
<a name="ln846">ospf_route_add (struct route_table *rt, struct prefix_ipv4 *p,</a>
<a name="ln847">		struct ospf_route *new_or, struct ospf_route *over)</a>
<a name="ln848">{</a>
<a name="ln849">  struct route_node *rn;</a>
<a name="ln850"> </a>
<a name="ln851">  rn = route_node_get (rt, (struct prefix *) p);</a>
<a name="ln852"> </a>
<a name="ln853">  ospf_route_copy_nexthops (new_or, over-&gt;paths);</a>
<a name="ln854"> </a>
<a name="ln855">  if (rn-&gt;info)</a>
<a name="ln856">    {</a>
<a name="ln857">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln858">	zlog_debug (&quot;ospf_route_add(): something's wrong !&quot;);</a>
<a name="ln859">      route_unlock_node (rn);</a>
<a name="ln860">      return;</a>
<a name="ln861">    }</a>
<a name="ln862"> </a>
<a name="ln863">  rn-&gt;info = new_or;</a>
<a name="ln864">}</a>
<a name="ln865"> </a>
<a name="ln866">void</a>
<a name="ln867">ospf_prune_unreachable_networks (struct route_table *rt)</a>
<a name="ln868">{</a>
<a name="ln869">  struct route_node *rn, *next;</a>
<a name="ln870">  struct ospf_route *or;</a>
<a name="ln871"> </a>
<a name="ln872">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln873">    zlog_debug (&quot;Pruning unreachable networks&quot;);</a>
<a name="ln874"> </a>
<a name="ln875">  for (rn = route_top (rt); rn; rn = next)</a>
<a name="ln876">    {</a>
<a name="ln877">      next = route_next (rn);</a>
<a name="ln878">      if (rn-&gt;info != NULL)</a>
<a name="ln879">	{</a>
<a name="ln880">	  or = rn-&gt;info;</a>
<a name="ln881">	  if (listcount (or-&gt;paths) == 0)</a>
<a name="ln882">	    {</a>
<a name="ln883">	      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln884">		zlog_debug (&quot;Pruning route to %s/%d&quot;,</a>
<a name="ln885">			   inet_ntoa (rn-&gt;p.u.prefix4), rn-&gt;p.prefixlen);</a>
<a name="ln886"> </a>
<a name="ln887">	      ospf_route_free (or);</a>
<a name="ln888">	      rn-&gt;info = NULL;</a>
<a name="ln889">	      route_unlock_node (rn);</a>
<a name="ln890">	    }</a>
<a name="ln891">	}</a>
<a name="ln892">    }</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">void</a>
<a name="ln896">ospf_prune_unreachable_routers (struct route_table *rtrs)</a>
<a name="ln897">{</a>
<a name="ln898">  struct route_node *rn, *next;</a>
<a name="ln899">  struct ospf_route *or;</a>
<a name="ln900">  struct listnode *node, *nnode;</a>
<a name="ln901">  struct list *paths;</a>
<a name="ln902"> </a>
<a name="ln903">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln904">    zlog_debug (&quot;Pruning unreachable routers&quot;);</a>
<a name="ln905"> </a>
<a name="ln906">  for (rn = route_top (rtrs); rn; rn = next)</a>
<a name="ln907">    {</a>
<a name="ln908">      next = route_next (rn);</a>
<a name="ln909">      if ((paths = rn-&gt;info) == NULL)</a>
<a name="ln910">	continue;</a>
<a name="ln911"> </a>
<a name="ln912">      for (ALL_LIST_ELEMENTS (paths, node, nnode, or))</a>
<a name="ln913">	{</a>
<a name="ln914">	  if (listcount (or-&gt;paths) == 0)</a>
<a name="ln915">	    {</a>
<a name="ln916">	      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln917">		{</a>
<a name="ln918">		  zlog_debug (&quot;Pruning route to rtr %s&quot;,</a>
<a name="ln919">			     inet_ntoa (rn-&gt;p.u.prefix4));</a>
<a name="ln920">		  zlog_debug (&quot;               via area %s&quot;,</a>
<a name="ln921">			     inet_ntoa (or-&gt;u.std.area_id));</a>
<a name="ln922">		}</a>
<a name="ln923"> </a>
<a name="ln924">	      listnode_delete (paths, or);</a>
<a name="ln925">	      ospf_route_free (or);</a>
<a name="ln926">	    }</a>
<a name="ln927">	}</a>
<a name="ln928"> </a>
<a name="ln929">      if (listcount (paths) == 0)</a>
<a name="ln930">	{</a>
<a name="ln931">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln932">	    zlog_debug (&quot;Pruning router node %s&quot;, inet_ntoa (rn-&gt;p.u.prefix4));</a>
<a name="ln933"> </a>
<a name="ln934">	  list_delete (paths);</a>
<a name="ln935">	  rn-&gt;info = NULL;</a>
<a name="ln936">	  route_unlock_node (rn);</a>
<a name="ln937">	}</a>
<a name="ln938">    }</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">int</a>
<a name="ln942">ospf_add_discard_route (struct route_table *rt, struct ospf_area *area,</a>
<a name="ln943">			struct prefix_ipv4 *p)</a>
<a name="ln944">{</a>
<a name="ln945">  struct route_node *rn;</a>
<a name="ln946">  struct ospf_route *or, *new_or;</a>
<a name="ln947"> </a>
<a name="ln948">  rn = route_node_get (rt, (struct prefix *) p);</a>
<a name="ln949"> </a>
<a name="ln950">  if (rn == NULL)</a>
<a name="ln951">    {</a>
<a name="ln952">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln953">	zlog_debug (&quot;ospf_add_discard_route(): router installation error&quot;);</a>
<a name="ln954">      return 0;</a>
<a name="ln955">    }</a>
<a name="ln956"> </a>
<a name="ln957">  if (rn-&gt;info) /* If the route to the same destination is found */</a>
<a name="ln958">    {</a>
<a name="ln959">      route_unlock_node (rn);</a>
<a name="ln960"> </a>
<a name="ln961">      or = rn-&gt;info;</a>
<a name="ln962"> </a>
<a name="ln963">      if (or-&gt;path_type == OSPF_PATH_INTRA_AREA)</a>
<a name="ln964">	{</a>
<a name="ln965">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln966">	    zlog_debug (&quot;ospf_add_discard_route(): &quot;</a>
<a name="ln967">		       &quot;an intra-area route exists&quot;);</a>
<a name="ln968">	  return 0;</a>
<a name="ln969">	}</a>
<a name="ln970"> </a>
<a name="ln971">      if (or-&gt;type == OSPF_DESTINATION_DISCARD)</a>
<a name="ln972">	{</a>
<a name="ln973">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln974">	    zlog_debug (&quot;ospf_add_discard_route(): &quot;</a>
<a name="ln975">		       &quot;discard entry already installed&quot;);</a>
<a name="ln976">	  return 0;</a>
<a name="ln977">	}</a>
<a name="ln978"> </a>
<a name="ln979">      ospf_route_free (rn-&gt;info);</a>
<a name="ln980">  }</a>
<a name="ln981"> </a>
<a name="ln982">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln983">    zlog_debug (&quot;ospf_add_discard_route(): &quot;</a>
<a name="ln984">		&quot;adding %s/%d&quot;, inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln985"> </a>
<a name="ln986">  new_or = ospf_route_new ();</a>
<a name="ln987">  new_or-&gt;type = OSPF_DESTINATION_DISCARD;</a>
<a name="ln988">  new_or-&gt;id.s_addr = 0;</a>
<a name="ln989">  new_or-&gt;cost = 0;</a>
<a name="ln990">  new_or-&gt;u.std.area_id = area-&gt;area_id;</a>
<a name="ln991">  new_or-&gt;u.std.external_routing = area-&gt;external_routing;</a>
<a name="ln992">  new_or-&gt;path_type = OSPF_PATH_INTER_AREA;</a>
<a name="ln993">  rn-&gt;info = new_or;</a>
<a name="ln994"> </a>
<a name="ln995">  ospf_zebra_add_discard (p);</a>
<a name="ln996"> </a>
<a name="ln997">  return 1;</a>
<a name="ln998">}</a>
<a name="ln999"> </a>
<a name="ln1000">void</a>
<a name="ln1001">ospf_delete_discard_route (struct route_table *rt, struct prefix_ipv4 *p)</a>
<a name="ln1002">{</a>
<a name="ln1003">  struct route_node *rn;</a>
<a name="ln1004">  struct ospf_route *or;</a>
<a name="ln1005"> </a>
<a name="ln1006">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1007">    zlog_debug (&quot;ospf_delete_discard_route(): &quot;</a>
<a name="ln1008">		&quot;deleting %s/%d&quot;, inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln1009"> </a>
<a name="ln1010">  rn = route_node_lookup (rt, (struct prefix*)p);</a>
<a name="ln1011"> </a>
<a name="ln1012">  if (rn == NULL)</a>
<a name="ln1013">    {</a>
<a name="ln1014">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1015">	zlog_debug(&quot;ospf_delete_discard_route(): no route found&quot;);</a>
<a name="ln1016">      return;</a>
<a name="ln1017">    }</a>
<a name="ln1018"> </a>
<a name="ln1019">  or = rn-&gt;info;</a>
<a name="ln1020"> </a>
<a name="ln1021">  if (or-&gt;path_type == OSPF_PATH_INTRA_AREA)</a>
<a name="ln1022">    {</a>
<a name="ln1023">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1024">	zlog_debug (&quot;ospf_delete_discard_route(): &quot;</a>
<a name="ln1025">		    &quot;an intra-area route exists&quot;);</a>
<a name="ln1026">      return;</a>
<a name="ln1027">    }</a>
<a name="ln1028"> </a>
<a name="ln1029">  if (or-&gt;type != OSPF_DESTINATION_DISCARD)</a>
<a name="ln1030">    {</a>
<a name="ln1031">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1032">	zlog_debug (&quot;ospf_delete_discard_route(): &quot;</a>
<a name="ln1033">		    &quot;not a discard entry&quot;);</a>
<a name="ln1034">      return;</a>
<a name="ln1035">    }</a>
<a name="ln1036"> </a>
<a name="ln1037">  /* free the route entry and the route node */</a>
<a name="ln1038">  ospf_route_free (rn-&gt;info);</a>
<a name="ln1039"> </a>
<a name="ln1040">  rn-&gt;info = NULL;</a>
<a name="ln1041">  route_unlock_node (rn);</a>
<a name="ln1042">  route_unlock_node (rn);</a>
<a name="ln1043"> </a>
<a name="ln1044">  /* remove the discard entry from the rib */</a>
<a name="ln1045">  ospf_zebra_delete_discard(p);</a>
<a name="ln1046"> </a>
<a name="ln1047">  return;</a>
<a name="ln1048">}</a>
<a name="ln1049"> </a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="181"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'or->paths' pointer was utilized before it was verified against nullptr. Check lines: 181, 185.</p></div>
<div class="balloon" rel="220"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: rn.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
