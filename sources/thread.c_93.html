
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>thread.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Thread management routine</a>
<a name="ln2"> * Copyright (C) 1998, 2000 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">/* #define DEBUG */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25">#include &lt;sys/resource.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;thread.h&quot;</a>
<a name="ln28">#include &quot;memory.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;hash.h&quot;</a>
<a name="ln31">#include &quot;pqueue.h&quot;</a>
<a name="ln32">#include &quot;command.h&quot;</a>
<a name="ln33">#include &quot;sigevent.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#if defined(__APPLE__)</a>
<a name="ln36">#include &lt;mach/mach.h&gt;</a>
<a name="ln37">#include &lt;mach/mach_time.h&gt;</a>
<a name="ln38">#endif</a>
<a name="ln39"> </a>
<a name="ln40">/* Recent absolute time of day */</a>
<a name="ln41">struct timeval recent_time;</a>
<a name="ln42">static struct timeval last_recent_time;</a>
<a name="ln43">/* Relative time, since startup */</a>
<a name="ln44">static struct timeval relative_time;</a>
<a name="ln45">static struct timeval relative_time_base;</a>
<a name="ln46">/* init flag */</a>
<a name="ln47">static unsigned short timers_inited;</a>
<a name="ln48"> </a>
<a name="ln49">static struct hash *cpu_record = NULL;</a>
<a name="ln50"> </a>
<a name="ln51">/* Struct timeval's tv_usec one second value.  */</a>
<a name="ln52">#define TIMER_SECOND_MICRO 1000000L</a>
<a name="ln53"> </a>
<a name="ln54">/* Adjust so that tv_usec is in the range [0,TIMER_SECOND_MICRO).</a>
<a name="ln55">   And change negative values to 0. */</a>
<a name="ln56">static struct timeval</a>
<a name="ln57">timeval_adjust (struct timeval a)</a>
<a name="ln58">{</a>
<a name="ln59">  while (a.tv_usec &gt;= TIMER_SECOND_MICRO)</a>
<a name="ln60">    {</a>
<a name="ln61">      a.tv_usec -= TIMER_SECOND_MICRO;</a>
<a name="ln62">      a.tv_sec++;</a>
<a name="ln63">    }</a>
<a name="ln64"> </a>
<a name="ln65">  while (a.tv_usec &lt; 0)</a>
<a name="ln66">    {</a>
<a name="ln67">      a.tv_usec += TIMER_SECOND_MICRO;</a>
<a name="ln68">      a.tv_sec--;</a>
<a name="ln69">    }</a>
<a name="ln70"> </a>
<a name="ln71">  if (a.tv_sec &lt; 0)</a>
<a name="ln72">      /* Change negative timeouts to 0. */</a>
<a name="ln73">      a.tv_sec = a.tv_usec = 0;</a>
<a name="ln74"> </a>
<a name="ln75">  return a;</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">static struct timeval</a>
<a name="ln79">timeval_subtract (struct timeval a, struct timeval b)</a>
<a name="ln80">{</a>
<a name="ln81">  struct timeval ret;</a>
<a name="ln82"> </a>
<a name="ln83">  ret.tv_usec = a.tv_usec - b.tv_usec;</a>
<a name="ln84">  ret.tv_sec = a.tv_sec - b.tv_sec;</a>
<a name="ln85"> </a>
<a name="ln86">  return timeval_adjust (ret);</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">static long</a>
<a name="ln90">timeval_cmp (struct timeval a, struct timeval b)</a>
<a name="ln91">{</a>
<a name="ln92">  return (a.tv_sec == b.tv_sec</a>
<a name="ln93">	  ? a.tv_usec - b.tv_usec : a.tv_sec - b.tv_sec);</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">unsigned long</a>
<a name="ln97">timeval_elapsed (struct timeval a, struct timeval b)</a>
<a name="ln98">{</a>
<a name="ln99">  return (((a.tv_sec - b.tv_sec) * TIMER_SECOND_MICRO)</a>
<a name="ln100">	  + (a.tv_usec - b.tv_usec));</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">#if !defined(HAVE_CLOCK_MONOTONIC) &amp;&amp; !defined(__APPLE__)</a>
<a name="ln104">static void</a>
<a name="ln105">quagga_gettimeofday_relative_adjust (void)</a>
<a name="ln106">{</a>
<a name="ln107">  struct timeval diff;</a>
<a name="ln108">  if (timeval_cmp (recent_time, last_recent_time) &lt; 0)</a>
<a name="ln109">    {</a>
<a name="ln110">      relative_time.tv_sec++;</a>
<a name="ln111">      relative_time.tv_usec = 0;</a>
<a name="ln112">    }</a>
<a name="ln113">  else</a>
<a name="ln114">    {</a>
<a name="ln115">      diff = timeval_subtract (recent_time, last_recent_time);</a>
<a name="ln116">      relative_time.tv_sec += diff.tv_sec;</a>
<a name="ln117">      relative_time.tv_usec += diff.tv_usec;</a>
<a name="ln118">      relative_time = timeval_adjust (relative_time);</a>
<a name="ln119">    }</a>
<a name="ln120">  last_recent_time = recent_time;</a>
<a name="ln121">}</a>
<a name="ln122">#endif /* !HAVE_CLOCK_MONOTONIC &amp;&amp; !__APPLE__ */</a>
<a name="ln123"> </a>
<a name="ln124">/* gettimeofday wrapper, to keep recent_time updated */</a>
<a name="ln125">static int</a>
<a name="ln126">quagga_gettimeofday (struct timeval *tv)</a>
<a name="ln127">{</a>
<a name="ln128">  int ret;</a>
<a name="ln129">  </a>
<a name="ln130">  assert (tv);</a>
<a name="ln131">  </a>
<a name="ln132">  if (!(ret = gettimeofday (&amp;recent_time, NULL)))</a>
<a name="ln133">    {</a>
<a name="ln134">      /* init... */</a>
<a name="ln135">      if (!timers_inited)</a>
<a name="ln136">        {</a>
<a name="ln137">          relative_time_base = last_recent_time = recent_time;</a>
<a name="ln138">          timers_inited = 1;</a>
<a name="ln139">        }</a>
<a name="ln140">      /* avoid copy if user passed recent_time pointer.. */</a>
<a name="ln141">      if (tv != &amp;recent_time)</a>
<a name="ln142">        *tv = recent_time;</a>
<a name="ln143">      return 0;</a>
<a name="ln144">    }</a>
<a name="ln145">  return ret;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">static int</a>
<a name="ln149">quagga_get_relative (struct timeval *tv)</a>
<a name="ln150">{</a>
<a name="ln151">  int ret;</a>
<a name="ln152"> </a>
<a name="ln153">#ifdef HAVE_CLOCK_MONOTONIC</a>
<a name="ln154">  {</a>
<a name="ln155">    struct timespec tp;</a>
<a name="ln156">    if (!(ret = clock_gettime (CLOCK_MONOTONIC, &amp;tp)))</a>
<a name="ln157">      {</a>
<a name="ln158">        relative_time.tv_sec = tp.tv_sec;</a>
<a name="ln159">        relative_time.tv_usec = tp.tv_nsec / 1000;</a>
<a name="ln160">      }</a>
<a name="ln161">  }</a>
<a name="ln162">#elif defined(__APPLE__)</a>
<a name="ln163">  {</a>
<a name="ln164">    uint64_t ticks;</a>
<a name="ln165">    uint64_t useconds;</a>
<a name="ln166">    static mach_timebase_info_data_t timebase_info;</a>
<a name="ln167"> </a>
<a name="ln168">    ticks = mach_absolute_time();</a>
<a name="ln169">    if (timebase_info.denom == 0)</a>
<a name="ln170">      mach_timebase_info(&amp;timebase_info);</a>
<a name="ln171"> </a>
<a name="ln172">    useconds = ticks * timebase_info.numer / timebase_info.denom / 1000;</a>
<a name="ln173">    relative_time.tv_sec = useconds / 1000000;</a>
<a name="ln174">    relative_time.tv_usec = useconds % 1000000;</a>
<a name="ln175"> </a>
<a name="ln176">    return 0;</a>
<a name="ln177">  }</a>
<a name="ln178">#else /* !HAVE_CLOCK_MONOTONIC &amp;&amp; !__APPLE__ */</a>
<a name="ln179">  if (!(ret = quagga_gettimeofday (&amp;recent_time)))</a>
<a name="ln180">    quagga_gettimeofday_relative_adjust();</a>
<a name="ln181">#endif /* HAVE_CLOCK_MONOTONIC */</a>
<a name="ln182"> </a>
<a name="ln183">  if (tv)</a>
<a name="ln184">    *tv = relative_time;</a>
<a name="ln185"> </a>
<a name="ln186">  return ret;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">/* Get absolute time stamp, but in terms of the internal timer</a>
<a name="ln190"> * Could be wrong, but at least won't go back.</a>
<a name="ln191"> */</a>
<a name="ln192">static void</a>
<a name="ln193">quagga_real_stabilised (struct timeval *tv)</a>
<a name="ln194">{</a>
<a name="ln195">  *tv = relative_time_base;</a>
<a name="ln196">  tv-&gt;tv_sec += relative_time.tv_sec;</a>
<a name="ln197">  tv-&gt;tv_usec += relative_time.tv_usec;</a>
<a name="ln198">  *tv = timeval_adjust (*tv);</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">/* Exported Quagga timestamp function.</a>
<a name="ln202"> * Modelled on POSIX clock_gettime.</a>
<a name="ln203"> */</a>
<a name="ln204">int</a>
<a name="ln205">quagga_gettime (enum quagga_clkid clkid, struct timeval *tv)</a>
<a name="ln206">{</a>
<a name="ln207">  switch (clkid)</a>
<a name="ln208">    {</a>
<a name="ln209">      case QUAGGA_CLK_REALTIME:</a>
<a name="ln210">        return quagga_gettimeofday (tv);</a>
<a name="ln211">      case QUAGGA_CLK_MONOTONIC:</a>
<a name="ln212">        return quagga_get_relative (tv);</a>
<a name="ln213">      case QUAGGA_CLK_REALTIME_STABILISED:</a>
<a name="ln214">        quagga_real_stabilised (tv);</a>
<a name="ln215">        return 0;</a>
<a name="ln216">      default:</a>
<a name="ln217">        errno = EINVAL;</a>
<a name="ln218">        return -1;</a>
<a name="ln219">    }</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">/* time_t value in terms of stabilised absolute time. </a>
<a name="ln223"> * replacement for POSIX time()</a>
<a name="ln224"> */</a>
<a name="ln225">time_t</a>
<a name="ln226">quagga_time (time_t *t)</a>
<a name="ln227">{</a>
<a name="ln228">  struct timeval tv;</a>
<a name="ln229">  quagga_real_stabilised (&amp;tv);</a>
<a name="ln230">  if (t)</a>
<a name="ln231">    *t = tv.tv_sec;</a>
<a name="ln232">  return tv.tv_sec;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">/* Public export of recent_relative_time by value */</a>
<a name="ln236">struct timeval</a>
<a name="ln237">recent_relative_time (void)</a>
<a name="ln238">{</a>
<a name="ln239">  return relative_time;</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">static unsigned int</a>
<a name="ln243">cpu_record_hash_key (struct cpu_thread_history *a)</a>
<a name="ln244">{</a>
<a name="ln245">  return (uintptr_t) a-&gt;func;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">static int </a>
<a name="ln249">cpu_record_hash_cmp (const struct cpu_thread_history *a,</a>
<a name="ln250">		     const struct cpu_thread_history *b)</a>
<a name="ln251">{</a>
<a name="ln252">  return a-&gt;func == b-&gt;func;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">static void *</a>
<a name="ln256">cpu_record_hash_alloc (struct cpu_thread_history *a)</a>
<a name="ln257">{</a>
<a name="ln258">  struct cpu_thread_history *new;</a>
<a name="ln259">  new = XCALLOC (MTYPE_THREAD_STATS, sizeof (struct cpu_thread_history));</a>
<a name="ln260">  new-&gt;func = a-&gt;func;</a>
<a name="ln261">  new-&gt;funcname = a-&gt;funcname;</a>
<a name="ln262">  return new;</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">static void</a>
<a name="ln266">cpu_record_hash_free (void *a)</a>
<a name="ln267">{</a>
<a name="ln268">  struct cpu_thread_history *hist = a;</a>
<a name="ln269"> </a>
<a name="ln270">  XFREE (MTYPE_THREAD_STATS, hist);</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">static void </a>
<a name="ln274">vty_out_cpu_thread_history(struct vty* vty,</a>
<a name="ln275">			   struct cpu_thread_history *a)</a>
<a name="ln276">{</a>
<a name="ln277">#ifdef HAVE_RUSAGE</a>
<a name="ln278">  vty_out(vty, &quot;%7ld.%03ld %9d %8ld %9ld %8ld %9ld&quot;,</a>
<a name="ln279">	  a-&gt;cpu.total/1000, a-&gt;cpu.total%1000, a-&gt;total_calls,</a>
<a name="ln280">	  a-&gt;cpu.total/a-&gt;total_calls, a-&gt;cpu.max,</a>
<a name="ln281">	  a-&gt;real.total/a-&gt;total_calls, a-&gt;real.max);</a>
<a name="ln282">#else</a>
<a name="ln283">  vty_out(vty, &quot;%7ld.%03ld %9d %8ld %9ld&quot;,</a>
<a name="ln284">	  a-&gt;real.total/1000, a-&gt;real.total%1000, a-&gt;total_calls,</a>
<a name="ln285">	  a-&gt;real.total/a-&gt;total_calls, a-&gt;real.max);</a>
<a name="ln286">#endif</a>
<a name="ln287">  vty_out(vty, &quot; %c%c%c%c%c%c %s%s&quot;,</a>
<a name="ln288">	  a-&gt;types &amp; (1 &lt;&lt; THREAD_READ) ? 'R':' ',</a>
<a name="ln289">	  a-&gt;types &amp; (1 &lt;&lt; THREAD_WRITE) ? 'W':' ',</a>
<a name="ln290">	  a-&gt;types &amp; (1 &lt;&lt; THREAD_TIMER) ? 'T':' ',</a>
<a name="ln291">	  a-&gt;types &amp; (1 &lt;&lt; THREAD_EVENT) ? 'E':' ',</a>
<a name="ln292">	  a-&gt;types &amp; (1 &lt;&lt; THREAD_EXECUTE) ? 'X':' ',</a>
<a name="ln293">	  a-&gt;types &amp; (1 &lt;&lt; THREAD_BACKGROUND) ? 'B' : ' ',</a>
<a name="ln294">	  a-&gt;funcname, VTY_NEWLINE);</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">static void</a>
<a name="ln298">cpu_record_hash_print(struct hash_backet *bucket, </a>
<a name="ln299">		      void *args[])</a>
<a name="ln300">{</a>
<a name="ln301">  struct cpu_thread_history *totals = args[0];</a>
<a name="ln302">  struct vty *vty = args[1];</a>
<a name="ln303">  thread_type *filter = args[2];</a>
<a name="ln304">  struct cpu_thread_history *a = bucket-&gt;data;</a>
<a name="ln305">  </a>
<a name="ln306">  a = bucket-&gt;data;</a>
<a name="ln307">  if ( !(a-&gt;types &amp; *filter) )</a>
<a name="ln308">       return;</a>
<a name="ln309">  vty_out_cpu_thread_history(vty,a);</a>
<a name="ln310">  totals-&gt;total_calls += a-&gt;total_calls;</a>
<a name="ln311">  totals-&gt;real.total += a-&gt;real.total;</a>
<a name="ln312">  if (totals-&gt;real.max &lt; a-&gt;real.max)</a>
<a name="ln313">    totals-&gt;real.max = a-&gt;real.max;</a>
<a name="ln314">#ifdef HAVE_RUSAGE</a>
<a name="ln315">  totals-&gt;cpu.total += a-&gt;cpu.total;</a>
<a name="ln316">  if (totals-&gt;cpu.max &lt; a-&gt;cpu.max)</a>
<a name="ln317">    totals-&gt;cpu.max = a-&gt;cpu.max;</a>
<a name="ln318">#endif</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">static void</a>
<a name="ln322">cpu_record_print(struct vty *vty, thread_type filter)</a>
<a name="ln323">{</a>
<a name="ln324">  struct cpu_thread_history tmp;</a>
<a name="ln325">  void *args[3] = {&amp;tmp, vty, &amp;filter};</a>
<a name="ln326"> </a>
<a name="ln327">  memset(&amp;tmp, 0, sizeof tmp);</a>
<a name="ln328">  tmp.funcname = &quot;TOTAL&quot;;</a>
<a name="ln329">  tmp.types = filter;</a>
<a name="ln330"> </a>
<a name="ln331">#ifdef HAVE_RUSAGE</a>
<a name="ln332">  vty_out(vty, &quot;%21s %18s %18s%s&quot;,</a>
<a name="ln333">  	  &quot;&quot;, &quot;CPU (user+system):&quot;, &quot;Real (wall-clock):&quot;, VTY_NEWLINE);</a>
<a name="ln334">#endif</a>
<a name="ln335">  vty_out(vty, &quot;Runtime(ms)   Invoked Avg uSec Max uSecs&quot;);</a>
<a name="ln336">#ifdef HAVE_RUSAGE</a>
<a name="ln337">  vty_out(vty, &quot; Avg uSec Max uSecs&quot;);</a>
<a name="ln338">#endif</a>
<a name="ln339">  vty_out(vty, &quot;  Type  Thread%s&quot;, VTY_NEWLINE);</a>
<a name="ln340">  hash_iterate(cpu_record,</a>
<a name="ln341">	       (void(*)(struct hash_backet*,void*))cpu_record_hash_print,</a>
<a name="ln342">	       args);</a>
<a name="ln343"> </a>
<a name="ln344">  if (tmp.total_calls &gt; 0)</a>
<a name="ln345">    vty_out_cpu_thread_history(vty, &amp;tmp);</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">DEFUN(show_thread_cpu,</a>
<a name="ln349">      show_thread_cpu_cmd,</a>
<a name="ln350">      &quot;show thread cpu [FILTER]&quot;,</a>
<a name="ln351">      SHOW_STR</a>
<a name="ln352">      &quot;Thread information\n&quot;</a>
<a name="ln353">      &quot;Thread CPU usage\n&quot;</a>
<a name="ln354">      &quot;Display filter (rwtexb)\n&quot;)</a>
<a name="ln355">{</a>
<a name="ln356">  int i = 0;</a>
<a name="ln357">  thread_type filter = (thread_type) -1U;</a>
<a name="ln358"> </a>
<a name="ln359">  if (argc &gt; 0)</a>
<a name="ln360">    {</a>
<a name="ln361">      filter = 0;</a>
<a name="ln362">      while (argv[0][i] != '\0')</a>
<a name="ln363">	{</a>
<a name="ln364">	  switch ( argv[0][i] )</a>
<a name="ln365">	    {</a>
<a name="ln366">	    case 'r':</a>
<a name="ln367">	    case 'R':</a>
<a name="ln368">	      filter |= (1 &lt;&lt; THREAD_READ);</a>
<a name="ln369">	      break;</a>
<a name="ln370">	    case 'w':</a>
<a name="ln371">	    case 'W':</a>
<a name="ln372">	      filter |= (1 &lt;&lt; THREAD_WRITE);</a>
<a name="ln373">	      break;</a>
<a name="ln374">	    case 't':</a>
<a name="ln375">	    case 'T':</a>
<a name="ln376">	      filter |= (1 &lt;&lt; THREAD_TIMER);</a>
<a name="ln377">	      break;</a>
<a name="ln378">	    case 'e':</a>
<a name="ln379">	    case 'E':</a>
<a name="ln380">	      filter |= (1 &lt;&lt; THREAD_EVENT);</a>
<a name="ln381">	      break;</a>
<a name="ln382">	    case 'x':</a>
<a name="ln383">	    case 'X':</a>
<a name="ln384">	      filter |= (1 &lt;&lt; THREAD_EXECUTE);</a>
<a name="ln385">	      break;</a>
<a name="ln386">	    case 'b':</a>
<a name="ln387">	    case 'B':</a>
<a name="ln388">	      filter |= (1 &lt;&lt; THREAD_BACKGROUND);</a>
<a name="ln389">	      break;</a>
<a name="ln390">	    default:</a>
<a name="ln391">	      break;</a>
<a name="ln392">	    }</a>
<a name="ln393">	  ++i;</a>
<a name="ln394">	}</a>
<a name="ln395">      if (filter == 0)</a>
<a name="ln396">	{</a>
<a name="ln397">	  vty_out(vty, &quot;Invalid filter \&quot;%s\&quot; specified,&quot;</a>
<a name="ln398">                  &quot; must contain at least one of 'RWTEXB'%s&quot;,</a>
<a name="ln399">		  argv[0], VTY_NEWLINE);</a>
<a name="ln400">	  return CMD_WARNING;</a>
<a name="ln401">	}</a>
<a name="ln402">    }</a>
<a name="ln403"> </a>
<a name="ln404">  cpu_record_print(vty, filter);</a>
<a name="ln405">  return CMD_SUCCESS;</a>
<a name="ln406">}</a>
<a name="ln407"> </a>
<a name="ln408">static void</a>
<a name="ln409">cpu_record_hash_clear (struct hash_backet *bucket, </a>
<a name="ln410">		      void *args)</a>
<a name="ln411">{</a>
<a name="ln412">  thread_type *filter = args;</a>
<a name="ln413">  struct cpu_thread_history *a = bucket-&gt;data;</a>
<a name="ln414">  </a>
<a name="ln415">  a = bucket-&gt;data;</a>
<a name="ln416">  if ( !(a-&gt;types &amp; *filter) )</a>
<a name="ln417">       return;</a>
<a name="ln418">  </a>
<a name="ln419">  hash_release (cpu_record, bucket-&gt;data);</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">static void</a>
<a name="ln423">cpu_record_clear (thread_type filter)</a>
<a name="ln424">{</a>
<a name="ln425">  thread_type *tmp = &amp;filter;</a>
<a name="ln426">  hash_iterate (cpu_record,</a>
<a name="ln427">	        (void (*) (struct hash_backet*,void*)) cpu_record_hash_clear,</a>
<a name="ln428">	        tmp);</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">DEFUN(clear_thread_cpu,</a>
<a name="ln432">      clear_thread_cpu_cmd,</a>
<a name="ln433">      &quot;clear thread cpu [FILTER]&quot;,</a>
<a name="ln434">      &quot;Clear stored data\n&quot;</a>
<a name="ln435">      &quot;Thread information\n&quot;</a>
<a name="ln436">      &quot;Thread CPU usage\n&quot;</a>
<a name="ln437">      &quot;Display filter (rwtexb)\n&quot;)</a>
<a name="ln438">{</a>
<a name="ln439">  int i = 0;</a>
<a name="ln440">  thread_type filter = (thread_type) -1U;</a>
<a name="ln441"> </a>
<a name="ln442">  if (argc &gt; 0)</a>
<a name="ln443">    {</a>
<a name="ln444">      filter = 0;</a>
<a name="ln445">      while (argv[0][i] != '\0')</a>
<a name="ln446">	{</a>
<a name="ln447">	  switch ( argv[0][i] )</a>
<a name="ln448">	    {</a>
<a name="ln449">	    case 'r':</a>
<a name="ln450">	    case 'R':</a>
<a name="ln451">	      filter |= (1 &lt;&lt; THREAD_READ);</a>
<a name="ln452">	      break;</a>
<a name="ln453">	    case 'w':</a>
<a name="ln454">	    case 'W':</a>
<a name="ln455">	      filter |= (1 &lt;&lt; THREAD_WRITE);</a>
<a name="ln456">	      break;</a>
<a name="ln457">	    case 't':</a>
<a name="ln458">	    case 'T':</a>
<a name="ln459">	      filter |= (1 &lt;&lt; THREAD_TIMER);</a>
<a name="ln460">	      break;</a>
<a name="ln461">	    case 'e':</a>
<a name="ln462">	    case 'E':</a>
<a name="ln463">	      filter |= (1 &lt;&lt; THREAD_EVENT);</a>
<a name="ln464">	      break;</a>
<a name="ln465">	    case 'x':</a>
<a name="ln466">	    case 'X':</a>
<a name="ln467">	      filter |= (1 &lt;&lt; THREAD_EXECUTE);</a>
<a name="ln468">	      break;</a>
<a name="ln469">	    case 'b':</a>
<a name="ln470">	    case 'B':</a>
<a name="ln471">	      filter |= (1 &lt;&lt; THREAD_BACKGROUND);</a>
<a name="ln472">	      break;</a>
<a name="ln473">	    default:</a>
<a name="ln474">	      break;</a>
<a name="ln475">	    }</a>
<a name="ln476">	  ++i;</a>
<a name="ln477">	}</a>
<a name="ln478">      if (filter == 0)</a>
<a name="ln479">	{</a>
<a name="ln480">	  vty_out(vty, &quot;Invalid filter \&quot;%s\&quot; specified,&quot;</a>
<a name="ln481">                  &quot; must contain at least one of 'RWTEXB'%s&quot;,</a>
<a name="ln482">		  argv[0], VTY_NEWLINE);</a>
<a name="ln483">	  return CMD_WARNING;</a>
<a name="ln484">	}</a>
<a name="ln485">    }</a>
<a name="ln486"> </a>
<a name="ln487">  cpu_record_clear (filter);</a>
<a name="ln488">  return CMD_SUCCESS;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">static int</a>
<a name="ln492">thread_timer_cmp(void *a, void *b)</a>
<a name="ln493">{</a>
<a name="ln494">  struct thread *thread_a = a;</a>
<a name="ln495">  struct thread *thread_b = b;</a>
<a name="ln496"> </a>
<a name="ln497">  long cmp = timeval_cmp(thread_a-&gt;u.sands, thread_b-&gt;u.sands);</a>
<a name="ln498"> </a>
<a name="ln499">  if (cmp &lt; 0)</a>
<a name="ln500">    return -1;</a>
<a name="ln501">  if (cmp &gt; 0)</a>
<a name="ln502">    return 1;</a>
<a name="ln503">  return 0;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">static void</a>
<a name="ln507">thread_timer_update(void *node, int actual_position)</a>
<a name="ln508">{</a>
<a name="ln509">  struct thread *thread = node;</a>
<a name="ln510"> </a>
<a name="ln511">  thread-&gt;index = actual_position;</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">/* Allocate new thread master.  */</a>
<a name="ln515">struct thread_master *</a>
<a name="ln516">thread_master_create ()</a>
<a name="ln517">{</a>
<a name="ln518">  struct thread_master *rv;</a>
<a name="ln519">  struct rlimit limit;</a>
<a name="ln520"> </a>
<a name="ln521">  getrlimit(RLIMIT_NOFILE, &amp;limit);</a>
<a name="ln522"> </a>
<a name="ln523">  if (cpu_record == NULL) </a>
<a name="ln524">    cpu_record </a>
<a name="ln525">      = hash_create ((unsigned int (*) (void *))cpu_record_hash_key,</a>
<a name="ln526">		     (int (*) (const void *, const void *))cpu_record_hash_cmp);</a>
<a name="ln527"> </a>
<a name="ln528">  rv = XCALLOC (MTYPE_THREAD_MASTER, sizeof (struct thread_master));</a>
<a name="ln529">  if (rv == NULL)</a>
<a name="ln530">    {</a>
<a name="ln531">      return NULL;</a>
<a name="ln532">    }</a>
<a name="ln533"> </a>
<a name="ln534">  rv-&gt;fd_limit = (int)limit.rlim_cur;</a>
<a name="ln535">  rv-&gt;read = XCALLOC (MTYPE_THREAD, sizeof (struct thread *) * rv-&gt;fd_limit);</a>
<a name="ln536">  if (rv-&gt;read == NULL)</a>
<a name="ln537">    {</a>
<a name="ln538">      XFREE (MTYPE_THREAD_MASTER, rv);</a>
<a name="ln539">      return NULL;</a>
<a name="ln540">    }</a>
<a name="ln541"> </a>
<a name="ln542">  rv-&gt;write = XCALLOC (MTYPE_THREAD, sizeof (struct thread *) * rv-&gt;fd_limit);</a>
<a name="ln543">  if (rv-&gt;write == NULL)</a>
<a name="ln544">    {</a>
<a name="ln545">      XFREE (MTYPE_THREAD, rv-&gt;read);</a>
<a name="ln546">      XFREE (MTYPE_THREAD_MASTER, rv);</a>
<a name="ln547">      return NULL;</a>
<a name="ln548">    }</a>
<a name="ln549"> </a>
<a name="ln550">  /* Initialize the timer queues */</a>
<a name="ln551">  rv-&gt;timer = pqueue_create();</a>
<a name="ln552">  rv-&gt;background = pqueue_create();</a>
<a name="ln553">  rv-&gt;timer-&gt;cmp = rv-&gt;background-&gt;cmp = thread_timer_cmp;</a>
<a name="ln554">  rv-&gt;timer-&gt;update = rv-&gt;background-&gt;update = thread_timer_update;</a>
<a name="ln555"> </a>
<a name="ln556">  return rv;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">/* Add a new thread to the list.  */</a>
<a name="ln560">static void</a>
<a name="ln561">thread_list_add (struct thread_list *list, struct thread *thread)</a>
<a name="ln562">{</a>
<a name="ln563">  thread-&gt;next = NULL;</a>
<a name="ln564">  thread-&gt;prev = list-&gt;tail;</a>
<a name="ln565">  if (list-&gt;tail)</a>
<a name="ln566">    list-&gt;tail-&gt;next = thread;</a>
<a name="ln567">  else</a>
<a name="ln568">    list-&gt;head = thread;</a>
<a name="ln569">  list-&gt;tail = thread;</a>
<a name="ln570">  list-&gt;count++;</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573">/* Delete a thread from the list. */</a>
<a name="ln574">static struct thread *</a>
<a name="ln575">thread_list_delete (struct thread_list *list, struct thread *thread)</a>
<a name="ln576">{</a>
<a name="ln577">  if (thread-&gt;next)</a>
<a name="ln578">    thread-&gt;next-&gt;prev = thread-&gt;prev;</a>
<a name="ln579">  else</a>
<a name="ln580">    list-&gt;tail = thread-&gt;prev;</a>
<a name="ln581">  if (thread-&gt;prev)</a>
<a name="ln582">    thread-&gt;prev-&gt;next = thread-&gt;next;</a>
<a name="ln583">  else</a>
<a name="ln584">    list-&gt;head = thread-&gt;next;</a>
<a name="ln585">  thread-&gt;next = thread-&gt;prev = NULL;</a>
<a name="ln586">  list-&gt;count--;</a>
<a name="ln587">  return thread;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">static void</a>
<a name="ln591">thread_delete_fd (struct thread **thread_array, struct thread *thread)</a>
<a name="ln592">{</a>
<a name="ln593">  thread_array[thread-&gt;u.fd] = NULL;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">static void</a>
<a name="ln597">thread_add_fd (struct thread **thread_array, struct thread *thread)</a>
<a name="ln598">{</a>
<a name="ln599">  thread_array[thread-&gt;u.fd] = thread;</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">/* Move thread to unuse list. */</a>
<a name="ln603">static void</a>
<a name="ln604">thread_add_unuse (struct thread *thread)</a>
<a name="ln605">{</a>
<a name="ln606">  thread-&gt;type = THREAD_UNUSED;</a>
<a name="ln607">  assert (thread-&gt;master != NULL &amp;&amp; thread != NULL);</a>
<a name="ln608">  assert (thread-&gt;next == NULL);</a>
<a name="ln609">  assert (thread-&gt;prev == NULL);</a>
<a name="ln610">  thread_list_add (&amp;thread-&gt;master-&gt;unuse, thread);</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">/* Free all unused thread. */</a>
<a name="ln614">static void</a>
<a name="ln615">thread_list_free (struct thread_master *m, struct thread_list *list)</a>
<a name="ln616">{</a>
<a name="ln617">  struct thread *t;</a>
<a name="ln618">  struct thread *next;</a>
<a name="ln619"> </a>
<a name="ln620">  for (t = list-&gt;head; t; t = next)</a>
<a name="ln621">    {</a>
<a name="ln622">      next = t-&gt;next;</a>
<a name="ln623">      XFREE (MTYPE_THREAD, t);</a>
<a name="ln624">      list-&gt;count--;</a>
<a name="ln625">      m-&gt;alloc--;</a>
<a name="ln626">    }</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">static void</a>
<a name="ln630">thread_array_free (struct thread_master *m, struct thread **thread_array)</a>
<a name="ln631">{</a>
<a name="ln632">  struct thread *t;</a>
<a name="ln633">  int index;</a>
<a name="ln634"> </a>
<a name="ln635">  for (index = 0; index &lt; m-&gt;fd_limit; ++index)</a>
<a name="ln636">    {</a>
<a name="ln637">      t = thread_array[index];</a>
<a name="ln638">      if (t)</a>
<a name="ln639">        {</a>
<a name="ln640">          thread_array[index] = NULL;</a>
<a name="ln641">          XFREE (MTYPE_THREAD, t);</a>
<a name="ln642">          m-&gt;alloc--;</a>
<a name="ln643">        }</a>
<a name="ln644">    }</a>
<a name="ln645">  XFREE (MTYPE_THREAD, thread_array);</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">static void</a>
<a name="ln649">thread_queue_free (struct thread_master *m, struct pqueue *queue)</a>
<a name="ln650">{</a>
<a name="ln651">  int i;</a>
<a name="ln652"> </a>
<a name="ln653">  for (i = 0; i &lt; queue-&gt;size; i++)</a>
<a name="ln654">    XFREE(MTYPE_THREAD, queue-&gt;array[i]);</a>
<a name="ln655"> </a>
<a name="ln656">  m-&gt;alloc -= queue-&gt;size;</a>
<a name="ln657">  pqueue_delete(queue);</a>
<a name="ln658">}</a>
<a name="ln659"> </a>
<a name="ln660">/* Stop thread scheduler. */</a>
<a name="ln661">void</a>
<a name="ln662">thread_master_free (struct thread_master *m)</a>
<a name="ln663">{</a>
<a name="ln664">  thread_array_free (m, m-&gt;read);</a>
<a name="ln665">  thread_array_free (m, m-&gt;write);</a>
<a name="ln666">  thread_queue_free (m, m-&gt;timer);</a>
<a name="ln667">  thread_list_free (m, &amp;m-&gt;event);</a>
<a name="ln668">  thread_list_free (m, &amp;m-&gt;ready);</a>
<a name="ln669">  thread_list_free (m, &amp;m-&gt;unuse);</a>
<a name="ln670">  thread_queue_free (m, m-&gt;background);</a>
<a name="ln671">  </a>
<a name="ln672">  XFREE (MTYPE_THREAD_MASTER, m);</a>
<a name="ln673"> </a>
<a name="ln674">  if (cpu_record)</a>
<a name="ln675">    {</a>
<a name="ln676">      hash_clean (cpu_record, cpu_record_hash_free);</a>
<a name="ln677">      hash_free (cpu_record);</a>
<a name="ln678">      cpu_record = NULL;</a>
<a name="ln679">    }</a>
<a name="ln680">}</a>
<a name="ln681"> </a>
<a name="ln682">/* Thread list is empty or not.  */</a>
<a name="ln683">static int</a>
<a name="ln684">thread_empty (struct thread_list *list)</a>
<a name="ln685">{</a>
<a name="ln686">  return  list-&gt;head ? 0 : 1;</a>
<a name="ln687">}</a>
<a name="ln688"> </a>
<a name="ln689">/* Delete top of the list and return it. */</a>
<a name="ln690">static struct thread *</a>
<a name="ln691">thread_trim_head (struct thread_list *list)</a>
<a name="ln692">{</a>
<a name="ln693">  if (!thread_empty (list))</a>
<a name="ln694">    return thread_list_delete (list, list-&gt;head);</a>
<a name="ln695">  return NULL;</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">/* Return remain time in second. */</a>
<a name="ln699">unsigned long</a>
<a name="ln700">thread_timer_remain_second (struct thread *thread)</a>
<a name="ln701">{</a>
<a name="ln702">  quagga_get_relative (NULL);</a>
<a name="ln703">  </a>
<a name="ln704">  if (thread-&gt;u.sands.tv_sec - relative_time.tv_sec &gt; 0)</a>
<a name="ln705">    return thread-&gt;u.sands.tv_sec - relative_time.tv_sec;</a>
<a name="ln706">  else</a>
<a name="ln707">    return 0;</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">struct timeval</a>
<a name="ln711">thread_timer_remain(struct thread *thread)</a>
<a name="ln712">{</a>
<a name="ln713">  quagga_get_relative(NULL);</a>
<a name="ln714"> </a>
<a name="ln715">  return timeval_subtract(thread-&gt;u.sands, relative_time);</a>
<a name="ln716">}</a>
<a name="ln717"> </a>
<a name="ln718">#define debugargdef  const char *funcname, const char *schedfrom, int fromln</a>
<a name="ln719">#define debugargpass funcname, schedfrom, fromln</a>
<a name="ln720"> </a>
<a name="ln721">/* Get new thread.  */</a>
<a name="ln722">static struct thread *</a>
<a name="ln723">thread_get (struct thread_master *m, u_char type,</a>
<a name="ln724">	    int (*func) (struct thread *), void *arg, debugargdef)</a>
<a name="ln725">{</a>
<a name="ln726">  struct thread *thread = thread_trim_head (&amp;m-&gt;unuse);</a>
<a name="ln727"> </a>
<a name="ln728">  if (! thread)</a>
<a name="ln729">    {</a>
<a name="ln730">      thread = XCALLOC (MTYPE_THREAD, sizeof (struct thread));</a>
<a name="ln731">      m-&gt;alloc++;</a>
<a name="ln732">    }</a>
<a name="ln733">  thread-&gt;type = type;</a>
<a name="ln734">  thread-&gt;add_type = type;</a>
<a name="ln735">  thread-&gt;master = m;</a>
<a name="ln736">  thread-&gt;func = func;</a>
<a name="ln737">  thread-&gt;arg = arg;</a>
<a name="ln738">  thread-&gt;index = -1;</a>
<a name="ln739"> </a>
<a name="ln740">  thread-&gt;funcname = funcname;</a>
<a name="ln741">  thread-&gt;schedfrom = schedfrom;</a>
<a name="ln742">  thread-&gt;schedfrom_line = fromln;</a>
<a name="ln743"> </a>
<a name="ln744">  return thread;</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">#define fd_copy_fd_set(X) (X)</a>
<a name="ln748"> </a>
<a name="ln749">static int</a>
<a name="ln750">fd_select (int size, thread_fd_set *read, thread_fd_set *write, thread_fd_set *except, struct timeval *t)</a>
<a name="ln751">{</a>
<a name="ln752">  return(select(size, read, write, except, t));</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">static int</a>
<a name="ln756">fd_is_set (int fd, thread_fd_set *fdset)</a>
<a name="ln757">{</a>
<a name="ln758">  return FD_ISSET (fd, fdset);</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">static int</a>
<a name="ln762">fd_clear_read_write (int fd, thread_fd_set *fdset)</a>
<a name="ln763">{</a>
<a name="ln764">  if (!FD_ISSET (fd, fdset))</a>
<a name="ln765">    return 0;</a>
<a name="ln766"> </a>
<a name="ln767">  FD_CLR (fd, fdset);</a>
<a name="ln768">  return 1;</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">static struct thread *</a>
<a name="ln772">funcname_thread_add_read_write (int dir, struct thread_master *m, </a>
<a name="ln773">		 int (*func) (struct thread *), void *arg, int fd,</a>
<a name="ln774">		 debugargdef)</a>
<a name="ln775">{</a>
<a name="ln776">  struct thread *thread = NULL;</a>
<a name="ln777">  thread_fd_set *fdset = NULL;</a>
<a name="ln778"> </a>
<a name="ln779">  if (dir == THREAD_READ)</a>
<a name="ln780">    fdset = &amp;m-&gt;readfd;</a>
<a name="ln781">  else</a>
<a name="ln782">    fdset = &amp;m-&gt;writefd;</a>
<a name="ln783"> </a>
<a name="ln784">  if (FD_ISSET (fd, fdset))</a>
<a name="ln785">    {</a>
<a name="ln786">      zlog (NULL, LOG_WARNING, &quot;There is already %s fd [%d]&quot;,</a>
<a name="ln787">	    (dir = THREAD_READ) ? &quot;read&quot; : &quot;write&quot;, fd);</a>
<a name="ln788">      return NULL;</a>
<a name="ln789">    }</a>
<a name="ln790"> </a>
<a name="ln791">  FD_SET (fd, fdset);</a>
<a name="ln792"> </a>
<a name="ln793">  thread = thread_get (m, dir, func, arg, debugargpass);</a>
<a name="ln794">  thread-&gt;u.fd = fd;</a>
<a name="ln795">  if (dir == THREAD_READ)</a>
<a name="ln796">    thread_add_fd (m-&gt;read, thread);</a>
<a name="ln797">  else</a>
<a name="ln798">    thread_add_fd (m-&gt;write, thread);</a>
<a name="ln799"> </a>
<a name="ln800">  return thread;</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">/* Add new read thread. */</a>
<a name="ln804">struct thread *</a>
<a name="ln805">funcname_thread_add_read (struct thread_master *m, </a>
<a name="ln806">		 int (*func) (struct thread *), void *arg, int fd,</a>
<a name="ln807">		 debugargdef)</a>
<a name="ln808">{</a>
<a name="ln809">  return funcname_thread_add_read_write (THREAD_READ, m, func,</a>
<a name="ln810">                                         arg, fd, debugargpass);</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">/* Add new write thread. */</a>
<a name="ln814">struct thread *</a>
<a name="ln815">funcname_thread_add_write (struct thread_master *m,</a>
<a name="ln816">		 int (*func) (struct thread *), void *arg, int fd,</a>
<a name="ln817">		 debugargdef)</a>
<a name="ln818">{</a>
<a name="ln819">  return funcname_thread_add_read_write (THREAD_WRITE, m, func, </a>
<a name="ln820">                                         arg, fd, debugargpass);</a>
<a name="ln821">}</a>
<a name="ln822"> </a>
<a name="ln823">static struct thread *</a>
<a name="ln824">funcname_thread_add_timer_timeval (struct thread_master *m,</a>
<a name="ln825">                                   int (*func) (struct thread *), </a>
<a name="ln826">                                  int type,</a>
<a name="ln827">                                  void *arg, </a>
<a name="ln828">                                  struct timeval *time_relative,</a>
<a name="ln829">				  debugargdef)</a>
<a name="ln830">{</a>
<a name="ln831">  struct thread *thread;</a>
<a name="ln832">  struct pqueue *queue;</a>
<a name="ln833">  struct timeval alarm_time;</a>
<a name="ln834"> </a>
<a name="ln835">  assert (m != NULL);</a>
<a name="ln836"> </a>
<a name="ln837">  assert (type == THREAD_TIMER || type == THREAD_BACKGROUND);</a>
<a name="ln838">  assert (time_relative);</a>
<a name="ln839">  </a>
<a name="ln840">  queue = ((type == THREAD_TIMER) ? m-&gt;timer : m-&gt;background);</a>
<a name="ln841">  thread = thread_get (m, type, func, arg, debugargpass);</a>
<a name="ln842"> </a>
<a name="ln843">  /* Do we need jitter here? */</a>
<a name="ln844">  quagga_get_relative (NULL);</a>
<a name="ln845">  alarm_time.tv_sec = relative_time.tv_sec + time_relative-&gt;tv_sec;</a>
<a name="ln846">  alarm_time.tv_usec = relative_time.tv_usec + time_relative-&gt;tv_usec;</a>
<a name="ln847">  thread-&gt;u.sands = timeval_adjust(alarm_time);</a>
<a name="ln848"> </a>
<a name="ln849">  pqueue_enqueue(thread, queue);</a>
<a name="ln850">  return thread;</a>
<a name="ln851">}</a>
<a name="ln852"> </a>
<a name="ln853"> </a>
<a name="ln854">/* Add timer event thread. */</a>
<a name="ln855">struct thread *</a>
<a name="ln856">funcname_thread_add_timer (struct thread_master *m,</a>
<a name="ln857">		           int (*func) (struct thread *), </a>
<a name="ln858">		           void *arg, long timer,</a>
<a name="ln859">			   debugargdef)</a>
<a name="ln860">{</a>
<a name="ln861">  struct timeval trel;</a>
<a name="ln862"> </a>
<a name="ln863">  assert (m != NULL);</a>
<a name="ln864"> </a>
<a name="ln865">  trel.tv_sec = timer;</a>
<a name="ln866">  trel.tv_usec = 0;</a>
<a name="ln867"> </a>
<a name="ln868">  return funcname_thread_add_timer_timeval (m, func, THREAD_TIMER, arg, </a>
<a name="ln869">                                            &amp;trel, debugargpass);</a>
<a name="ln870">}</a>
<a name="ln871"> </a>
<a name="ln872">/* Add timer event thread with &quot;millisecond&quot; resolution */</a>
<a name="ln873">struct thread *</a>
<a name="ln874">funcname_thread_add_timer_msec (struct thread_master *m,</a>
<a name="ln875">                                int (*func) (struct thread *), </a>
<a name="ln876">                                void *arg, long timer,</a>
<a name="ln877">				debugargdef)</a>
<a name="ln878">{</a>
<a name="ln879">  struct timeval trel;</a>
<a name="ln880"> </a>
<a name="ln881">  assert (m != NULL);</a>
<a name="ln882"> </a>
<a name="ln883">  trel.tv_sec = timer / 1000;</a>
<a name="ln884">  trel.tv_usec = 1000*(timer % 1000);</a>
<a name="ln885"> </a>
<a name="ln886">  return funcname_thread_add_timer_timeval (m, func, THREAD_TIMER, </a>
<a name="ln887">                                            arg, &amp;trel, debugargpass);</a>
<a name="ln888">}</a>
<a name="ln889"> </a>
<a name="ln890">/* Add timer event thread with &quot;millisecond&quot; resolution */</a>
<a name="ln891">struct thread *</a>
<a name="ln892">funcname_thread_add_timer_tv (struct thread_master *m,</a>
<a name="ln893">                              int (*func) (struct thread *),</a>
<a name="ln894">                              void *arg, struct timeval *tv,</a>
<a name="ln895">                              debugargdef)</a>
<a name="ln896">{</a>
<a name="ln897">  return funcname_thread_add_timer_timeval (m, func, THREAD_TIMER,</a>
<a name="ln898">                                            arg, tv, debugargpass);</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">/* Add a background thread, with an optional millisec delay */</a>
<a name="ln902">struct thread *</a>
<a name="ln903">funcname_thread_add_background (struct thread_master *m,</a>
<a name="ln904">                                int (*func) (struct thread *),</a>
<a name="ln905">                                void *arg, long delay,</a>
<a name="ln906">				debugargdef)</a>
<a name="ln907">{</a>
<a name="ln908">  struct timeval trel;</a>
<a name="ln909">  </a>
<a name="ln910">  assert (m != NULL);</a>
<a name="ln911">  </a>
<a name="ln912">  if (delay)</a>
<a name="ln913">    {</a>
<a name="ln914">      trel.tv_sec = delay / 1000;</a>
<a name="ln915">      trel.tv_usec = 1000*(delay % 1000);</a>
<a name="ln916">    }</a>
<a name="ln917">  else</a>
<a name="ln918">    {</a>
<a name="ln919">      trel.tv_sec = 0;</a>
<a name="ln920">      trel.tv_usec = 0;</a>
<a name="ln921">    }</a>
<a name="ln922"> </a>
<a name="ln923">  return funcname_thread_add_timer_timeval (m, func, THREAD_BACKGROUND,</a>
<a name="ln924">                                            arg, &amp;trel, debugargpass);</a>
<a name="ln925">}</a>
<a name="ln926"> </a>
<a name="ln927">/* Add simple event thread. */</a>
<a name="ln928">struct thread *</a>
<a name="ln929">funcname_thread_add_event (struct thread_master *m,</a>
<a name="ln930">		  int (*func) (struct thread *), void *arg, int val,</a>
<a name="ln931">		  debugargdef)</a>
<a name="ln932">{</a>
<a name="ln933">  struct thread *thread;</a>
<a name="ln934"> </a>
<a name="ln935">  assert (m != NULL);</a>
<a name="ln936"> </a>
<a name="ln937">  thread = thread_get (m, THREAD_EVENT, func, arg, debugargpass);</a>
<a name="ln938">  thread-&gt;u.val = val;</a>
<a name="ln939">  thread_list_add (&amp;m-&gt;event, thread);</a>
<a name="ln940"> </a>
<a name="ln941">  return thread;</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">/* Cancel thread from scheduler. */</a>
<a name="ln945">void</a>
<a name="ln946">thread_cancel (struct thread *thread)</a>
<a name="ln947">{</a>
<a name="ln948">  struct thread_list *list = NULL;</a>
<a name="ln949">  struct pqueue *queue = NULL;</a>
<a name="ln950">  struct thread **thread_array = NULL;</a>
<a name="ln951">  </a>
<a name="ln952">  switch (thread-&gt;type)</a>
<a name="ln953">    {</a>
<a name="ln954">    case THREAD_READ:</a>
<a name="ln955">      assert (fd_clear_read_write (thread-&gt;u.fd, &amp;thread-&gt;master-&gt;readfd));</a>
<a name="ln956">      thread_array = thread-&gt;master-&gt;read;</a>
<a name="ln957">      break;</a>
<a name="ln958">    case THREAD_WRITE:</a>
<a name="ln959">      assert (fd_clear_read_write (thread-&gt;u.fd, &amp;thread-&gt;master-&gt;writefd));</a>
<a name="ln960">      thread_array = thread-&gt;master-&gt;write;</a>
<a name="ln961">      break;</a>
<a name="ln962">    case THREAD_TIMER:</a>
<a name="ln963">      queue = thread-&gt;master-&gt;timer;</a>
<a name="ln964">      break;</a>
<a name="ln965">    case THREAD_EVENT:</a>
<a name="ln966">      list = &amp;thread-&gt;master-&gt;event;</a>
<a name="ln967">      break;</a>
<a name="ln968">    case THREAD_READY:</a>
<a name="ln969">      list = &amp;thread-&gt;master-&gt;ready;</a>
<a name="ln970">      break;</a>
<a name="ln971">    case THREAD_BACKGROUND:</a>
<a name="ln972">      queue = thread-&gt;master-&gt;background;</a>
<a name="ln973">      break;</a>
<a name="ln974">    default:</a>
<a name="ln975">      return;</a>
<a name="ln976">      break;</a>
<a name="ln977">    }</a>
<a name="ln978"> </a>
<a name="ln979">  if (queue)</a>
<a name="ln980">    {</a>
<a name="ln981">      assert(thread-&gt;index &gt;= 0);</a>
<a name="ln982">      assert(thread == queue-&gt;array[thread-&gt;index]);</a>
<a name="ln983">      pqueue_remove_at(thread-&gt;index, queue);</a>
<a name="ln984">    }</a>
<a name="ln985">  else if (list)</a>
<a name="ln986">    {</a>
<a name="ln987">      thread_list_delete (list, thread);</a>
<a name="ln988">    }</a>
<a name="ln989">  else if (thread_array)</a>
<a name="ln990">    {</a>
<a name="ln991">      thread_delete_fd (thread_array, thread);</a>
<a name="ln992">    }</a>
<a name="ln993">  else</a>
<a name="ln994">    {</a>
<a name="ln995">      assert(!&quot;Thread should be either in queue or list or array!&quot;);</a>
<a name="ln996">    }</a>
<a name="ln997"> </a>
<a name="ln998">  thread_add_unuse (thread);</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001">/* Delete all events which has argument value arg. */</a>
<a name="ln1002">unsigned int</a>
<a name="ln1003">thread_cancel_event (struct thread_master *m, void *arg)</a>
<a name="ln1004">{</a>
<a name="ln1005">  unsigned int ret = 0;</a>
<a name="ln1006">  struct thread *thread;</a>
<a name="ln1007"> </a>
<a name="ln1008">  thread = m-&gt;event.head;</a>
<a name="ln1009">  while (thread)</a>
<a name="ln1010">    {</a>
<a name="ln1011">      struct thread *t;</a>
<a name="ln1012"> </a>
<a name="ln1013">      t = thread;</a>
<a name="ln1014">      thread = t-&gt;next;</a>
<a name="ln1015"> </a>
<a name="ln1016">      if (t-&gt;arg == arg)</a>
<a name="ln1017">        {</a>
<a name="ln1018">          ret++;</a>
<a name="ln1019">          thread_list_delete (&amp;m-&gt;event, t);</a>
<a name="ln1020">          thread_add_unuse (t);</a>
<a name="ln1021">        }</a>
<a name="ln1022">    }</a>
<a name="ln1023"> </a>
<a name="ln1024">  /* thread can be on the ready list too */</a>
<a name="ln1025">  thread = m-&gt;ready.head;</a>
<a name="ln1026">  while (thread)</a>
<a name="ln1027">    {</a>
<a name="ln1028">      struct thread *t;</a>
<a name="ln1029"> </a>
<a name="ln1030">      t = thread;</a>
<a name="ln1031">      thread = t-&gt;next;</a>
<a name="ln1032"> </a>
<a name="ln1033">      if (t-&gt;arg == arg)</a>
<a name="ln1034">        {</a>
<a name="ln1035">          ret++;</a>
<a name="ln1036">          thread_list_delete (&amp;m-&gt;ready, t);</a>
<a name="ln1037">          thread_add_unuse (t);</a>
<a name="ln1038">        }</a>
<a name="ln1039">    }</a>
<a name="ln1040">  return ret;</a>
<a name="ln1041">}</a>
<a name="ln1042"> </a>
<a name="ln1043">static struct timeval *</a>
<a name="ln1044">thread_timer_wait (struct pqueue *queue, struct timeval *timer_val)</a>
<a name="ln1045">{</a>
<a name="ln1046">  if (queue-&gt;size)</a>
<a name="ln1047">    {</a>
<a name="ln1048">      struct thread *next_timer = queue-&gt;array[0];</a>
<a name="ln1049">      *timer_val = timeval_subtract (next_timer-&gt;u.sands, relative_time);</a>
<a name="ln1050">      return timer_val;</a>
<a name="ln1051">    }</a>
<a name="ln1052">  return NULL;</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">static int</a>
<a name="ln1056">thread_process_fds_helper (struct thread_master *m, struct thread *thread, thread_fd_set *fdset)</a>
<a name="ln1057">{</a>
<a name="ln1058">  thread_fd_set *mfdset = NULL;</a>
<a name="ln1059">  struct thread **thread_array;</a>
<a name="ln1060"> </a>
<a name="ln1061">  if (!thread)</a>
<a name="ln1062">    return 0;</a>
<a name="ln1063"> </a>
<a name="ln1064">  if (thread-&gt;type == THREAD_READ)</a>
<a name="ln1065">    {</a>
<a name="ln1066">      mfdset = &amp;m-&gt;readfd;</a>
<a name="ln1067">      thread_array = m-&gt;read;</a>
<a name="ln1068">    }</a>
<a name="ln1069">  else</a>
<a name="ln1070">    {</a>
<a name="ln1071">      mfdset = &amp;m-&gt;writefd;</a>
<a name="ln1072">      thread_array = m-&gt;write;</a>
<a name="ln1073">    }</a>
<a name="ln1074"> </a>
<a name="ln1075">  if (fd_is_set (THREAD_FD (thread), fdset))</a>
<a name="ln1076">    {</a>
<a name="ln1077">      fd_clear_read_write (THREAD_FD (thread), mfdset);</a>
<a name="ln1078">      thread_delete_fd (thread_array, thread);</a>
<a name="ln1079">      thread_list_add (&amp;m-&gt;ready, thread);</a>
<a name="ln1080">      thread-&gt;type = THREAD_READY;</a>
<a name="ln1081">      return 1;</a>
<a name="ln1082">    }</a>
<a name="ln1083">  return 0;</a>
<a name="ln1084">}</a>
<a name="ln1085"> </a>
<a name="ln1086">static int</a>
<a name="ln1087">thread_process_fds (struct thread_master *m, thread_fd_set *rset, thread_fd_set *wset, int num)</a>
<a name="ln1088">{</a>
<a name="ln1089">  int ready = 0, index;</a>
<a name="ln1090"> </a>
<a name="ln1091">  for (index = 0; index &lt; m-&gt;fd_limit &amp;&amp; ready &lt; num; ++index)</a>
<a name="ln1092">    {</a>
<a name="ln1093">      ready += thread_process_fds_helper (m, m-&gt;read[index], rset);</a>
<a name="ln1094">      ready += thread_process_fds_helper (m, m-&gt;write[index], wset);</a>
<a name="ln1095">    }</a>
<a name="ln1096">  return num - ready;</a>
<a name="ln1097">}</a>
<a name="ln1098"> </a>
<a name="ln1099">/* Add all timers that have popped to the ready list. */</a>
<a name="ln1100">static unsigned int</a>
<a name="ln1101">thread_timer_process (struct pqueue *queue, struct timeval *timenow)</a>
<a name="ln1102">{</a>
<a name="ln1103">  struct thread *thread;</a>
<a name="ln1104">  unsigned int ready = 0;</a>
<a name="ln1105">  </a>
<a name="ln1106">  while (queue-&gt;size)</a>
<a name="ln1107">    {</a>
<a name="ln1108">      thread = queue-&gt;array[0];</a>
<a name="ln1109">      if (timeval_cmp (*timenow, thread-&gt;u.sands) &lt; 0)</a>
<a name="ln1110">        return ready;</a>
<a name="ln1111">      pqueue_dequeue(queue);</a>
<a name="ln1112">      thread-&gt;type = THREAD_READY;</a>
<a name="ln1113">      thread_list_add (&amp;thread-&gt;master-&gt;ready, thread);</a>
<a name="ln1114">      ready++;</a>
<a name="ln1115">    }</a>
<a name="ln1116">  return ready;</a>
<a name="ln1117">}</a>
<a name="ln1118"> </a>
<a name="ln1119">/* process a list en masse, e.g. for event thread lists */</a>
<a name="ln1120">static unsigned int</a>
<a name="ln1121">thread_process (struct thread_list *list)</a>
<a name="ln1122">{</a>
<a name="ln1123">  struct thread *thread;</a>
<a name="ln1124">  struct thread *next;</a>
<a name="ln1125">  unsigned int ready = 0;</a>
<a name="ln1126">  </a>
<a name="ln1127">  for (thread = list-&gt;head; thread; thread = next)</a>
<a name="ln1128">    {</a>
<a name="ln1129">      next = thread-&gt;next;</a>
<a name="ln1130">      thread_list_delete (list, thread);</a>
<a name="ln1131">      thread-&gt;type = THREAD_READY;</a>
<a name="ln1132">      thread_list_add (&amp;thread-&gt;master-&gt;ready, thread);</a>
<a name="ln1133">      ready++;</a>
<a name="ln1134">    }</a>
<a name="ln1135">  return ready;</a>
<a name="ln1136">}</a>
<a name="ln1137"> </a>
<a name="ln1138">/* Fetch next ready thread. */</a>
<a name="ln1139">static struct thread *</a>
<a name="ln1140">thread_fetch (struct thread_master *m)</a>
<a name="ln1141">{</a>
<a name="ln1142">  struct thread *thread;</a>
<a name="ln1143">  thread_fd_set readfd;</a>
<a name="ln1144">  thread_fd_set writefd;</a>
<a name="ln1145">  thread_fd_set exceptfd;</a>
<a name="ln1146">  struct timeval timer_val = { .tv_sec = 0, .tv_usec = 0 };</a>
<a name="ln1147">  struct timeval timer_val_bg;</a>
<a name="ln1148">  struct timeval *timer_wait = &amp;timer_val;</a>
<a name="ln1149">  struct timeval *timer_wait_bg;</a>
<a name="ln1150"> </a>
<a name="ln1151">  while (1)</a>
<a name="ln1152">    {</a>
<a name="ln1153">      int num = 0;</a>
<a name="ln1154"> </a>
<a name="ln1155">      /* Signals pre-empt everything */</a>
<a name="ln1156">      quagga_sigevent_process ();</a>
<a name="ln1157">       </a>
<a name="ln1158">      /* Drain the ready queue of already scheduled jobs, before scheduling</a>
<a name="ln1159">       * more.</a>
<a name="ln1160">       */</a>
<a name="ln1161">      if ((thread = thread_trim_head (&amp;m-&gt;ready)) != NULL)</a>
<a name="ln1162">        return thread;</a>
<a name="ln1163">      </a>
<a name="ln1164">      /* To be fair to all kinds of threads, and avoid starvation, we</a>
<a name="ln1165">       * need to be careful to consider all thread types for scheduling</a>
<a name="ln1166">       * in each quanta. I.e. we should not return early from here on.</a>
<a name="ln1167">       */</a>
<a name="ln1168">       </a>
<a name="ln1169">      /* Normal event are the next highest priority.  */</a>
<a name="ln1170">      thread_process (&amp;m-&gt;event);</a>
<a name="ln1171">      </a>
<a name="ln1172">      /* Structure copy.  */</a>
<a name="ln1173">      readfd = fd_copy_fd_set(m-&gt;readfd);</a>
<a name="ln1174">      writefd = fd_copy_fd_set(m-&gt;writefd);</a>
<a name="ln1175">      exceptfd = fd_copy_fd_set(m-&gt;exceptfd);</a>
<a name="ln1176">      </a>
<a name="ln1177">      /* Calculate select wait timer if nothing else to do */</a>
<a name="ln1178">      if (m-&gt;ready.count == 0)</a>
<a name="ln1179">        {</a>
<a name="ln1180">          quagga_get_relative (NULL);</a>
<a name="ln1181">          timer_wait = thread_timer_wait (m-&gt;timer, &amp;timer_val);</a>
<a name="ln1182">          timer_wait_bg = thread_timer_wait (m-&gt;background, &amp;timer_val_bg);</a>
<a name="ln1183">          </a>
<a name="ln1184">          if (timer_wait_bg &amp;&amp;</a>
<a name="ln1185">              (!timer_wait || (timeval_cmp (*timer_wait, *timer_wait_bg) &gt; 0)))</a>
<a name="ln1186">            timer_wait = timer_wait_bg;</a>
<a name="ln1187">        }</a>
<a name="ln1188">      </a>
<a name="ln1189">      num = fd_select (FD_SETSIZE, &amp;readfd, &amp;writefd, &amp;exceptfd, timer_wait);</a>
<a name="ln1190">      </a>
<a name="ln1191">      /* Signals should get quick treatment */</a>
<a name="ln1192">      if (num &lt; 0)</a>
<a name="ln1193">        {</a>
<a name="ln1194">          if (errno == EINTR)</a>
<a name="ln1195">            continue; /* signal received - process it */</a>
<a name="ln1196">          zlog_warn (&quot;select() error: %s&quot;, safe_strerror (errno));</a>
<a name="ln1197">          return NULL;</a>
<a name="ln1198">        }</a>
<a name="ln1199"> </a>
<a name="ln1200">      /* Check foreground timers.  Historically, they have had higher</a>
<a name="ln1201">         priority than I/O threads, so let's push them onto the ready</a>
<a name="ln1202">	 list in front of the I/O threads. */</a>
<a name="ln1203">      quagga_get_relative (NULL);</a>
<a name="ln1204">      thread_timer_process (m-&gt;timer, &amp;relative_time);</a>
<a name="ln1205">      </a>
<a name="ln1206">      /* Got IO, process it */</a>
<a name="ln1207">      if (num &gt; 0)</a>
<a name="ln1208">        thread_process_fds (m, &amp;readfd, &amp;writefd, num);</a>
<a name="ln1209"> </a>
<a name="ln1210">#if 0</a>
<a name="ln1211">      /* If any threads were made ready above (I/O or foreground timer),</a>
<a name="ln1212">         perhaps we should avoid adding background timers to the ready</a>
<a name="ln1213">	 list at this time.  If this is code is uncommented, then background</a>
<a name="ln1214">	 timer threads will not run unless there is nothing else to do. */</a>
<a name="ln1215">      if ((thread = thread_trim_head (&amp;m-&gt;ready)) != NULL)</a>
<a name="ln1216">        return thread;</a>
<a name="ln1217">#endif</a>
<a name="ln1218"> </a>
<a name="ln1219">      /* Background timer/events, lowest priority */</a>
<a name="ln1220">      thread_timer_process (m-&gt;background, &amp;relative_time);</a>
<a name="ln1221">      </a>
<a name="ln1222">      if ((thread = thread_trim_head (&amp;m-&gt;ready)) != NULL)</a>
<a name="ln1223">        return thread;</a>
<a name="ln1224">    }</a>
<a name="ln1225">}</a>
<a name="ln1226"> </a>
<a name="ln1227">unsigned long</a>
<a name="ln1228">thread_consumed_time (RUSAGE_T *now, RUSAGE_T *start, unsigned long *cputime)</a>
<a name="ln1229">{</a>
<a name="ln1230">#ifdef HAVE_RUSAGE</a>
<a name="ln1231">  /* This is 'user + sys' time.  */</a>
<a name="ln1232">  *cputime = timeval_elapsed (now-&gt;cpu.ru_utime, start-&gt;cpu.ru_utime) +</a>
<a name="ln1233">	     timeval_elapsed (now-&gt;cpu.ru_stime, start-&gt;cpu.ru_stime);</a>
<a name="ln1234">#else</a>
<a name="ln1235">  *cputime = 0;</a>
<a name="ln1236">#endif /* HAVE_RUSAGE */</a>
<a name="ln1237">  return timeval_elapsed (now-&gt;real, start-&gt;real);</a>
<a name="ln1238">}</a>
<a name="ln1239"> </a>
<a name="ln1240">/* We should aim to yield after THREAD_YIELD_TIME_SLOT milliseconds. </a>
<a name="ln1241">   Note: we are using real (wall clock) time for this calculation.</a>
<a name="ln1242">   It could be argued that CPU time may make more sense in certain</a>
<a name="ln1243">   contexts.  The things to consider are whether the thread may have</a>
<a name="ln1244">   blocked (in which case wall time increases, but CPU time does not),</a>
<a name="ln1245">   or whether the system is heavily loaded with other processes competing</a>
<a name="ln1246">   for CPU time.  On balance, wall clock time seems to make sense. </a>
<a name="ln1247">   Plus it has the added benefit that gettimeofday should be faster</a>
<a name="ln1248">   than calling getrusage. */</a>
<a name="ln1249">int</a>
<a name="ln1250">thread_should_yield (struct thread *thread)</a>
<a name="ln1251">{</a>
<a name="ln1252">  quagga_get_relative (NULL);</a>
<a name="ln1253">  unsigned long t = timeval_elapsed(relative_time, thread-&gt;real);</a>
<a name="ln1254">  return ((t &gt; THREAD_YIELD_TIME_SLOT) ? t : 0);</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">void</a>
<a name="ln1258">thread_getrusage (RUSAGE_T *r)</a>
<a name="ln1259">{</a>
<a name="ln1260">  quagga_get_relative (NULL);</a>
<a name="ln1261">#ifdef HAVE_RUSAGE</a>
<a name="ln1262">  getrusage(RUSAGE_SELF, &amp;(r-&gt;cpu));</a>
<a name="ln1263">#endif</a>
<a name="ln1264">  r-&gt;real = relative_time;</a>
<a name="ln1265"> </a>
<a name="ln1266">#ifdef HAVE_CLOCK_MONOTONIC</a>
<a name="ln1267">  /* quagga_get_relative() only updates recent_time if gettimeofday</a>
<a name="ln1268">   * based, not when using CLOCK_MONOTONIC. As we export recent_time</a>
<a name="ln1269">   * and guarantee to update it before threads are run...</a>
<a name="ln1270">   */</a>
<a name="ln1271">  quagga_gettimeofday(&amp;recent_time);</a>
<a name="ln1272">#endif /* HAVE_CLOCK_MONOTONIC */</a>
<a name="ln1273">}</a>
<a name="ln1274"> </a>
<a name="ln1275">struct thread *thread_current = NULL;</a>
<a name="ln1276"> </a>
<a name="ln1277">/* We check thread consumed time. If the system has getrusage, we'll</a>
<a name="ln1278">   use that to get in-depth stats on the performance of the thread in addition</a>
<a name="ln1279">   to wall clock time stats from gettimeofday. */</a>
<a name="ln1280">static void</a>
<a name="ln1281">thread_call (struct thread *thread)</a>
<a name="ln1282">{</a>
<a name="ln1283">  unsigned long realtime, cputime;</a>
<a name="ln1284">  RUSAGE_T before, after;</a>
<a name="ln1285"> </a>
<a name="ln1286"> /* Cache a pointer to the relevant cpu history thread, if the thread</a>
<a name="ln1287">  * does not have it yet.</a>
<a name="ln1288">  *</a>
<a name="ln1289">  * Callers submitting 'dummy threads' hence must take care that</a>
<a name="ln1290">  * thread-&gt;cpu is NULL</a>
<a name="ln1291">  */</a>
<a name="ln1292">  if (!thread-&gt;hist)</a>
<a name="ln1293">    {</a>
<a name="ln1294">      struct cpu_thread_history tmp;</a>
<a name="ln1295">      </a>
<a name="ln1296">      tmp.func = thread-&gt;func;</a>
<a name="ln1297">      tmp.funcname = thread-&gt;funcname;</a>
<a name="ln1298">      </a>
<a name="ln1299">      thread-&gt;hist = hash_get (cpu_record, &amp;tmp, </a>
<a name="ln1300">                    (void * (*) (void *))cpu_record_hash_alloc);</a>
<a name="ln1301">    }</a>
<a name="ln1302"> </a>
<a name="ln1303">  GETRUSAGE (&amp;before);</a>
<a name="ln1304">  thread-&gt;real = before.real;</a>
<a name="ln1305"> </a>
<a name="ln1306">  thread_current = thread;</a>
<a name="ln1307">  (*thread-&gt;func) (thread);</a>
<a name="ln1308">  thread_current = NULL;</a>
<a name="ln1309"> </a>
<a name="ln1310">  GETRUSAGE (&amp;after);</a>
<a name="ln1311"> </a>
<a name="ln1312">  realtime = thread_consumed_time (&amp;after, &amp;before, &amp;cputime);</a>
<a name="ln1313">  thread-&gt;hist-&gt;real.total += realtime;</a>
<a name="ln1314">  if (thread-&gt;hist-&gt;real.max &lt; realtime)</a>
<a name="ln1315">    thread-&gt;hist-&gt;real.max = realtime;</a>
<a name="ln1316">#ifdef HAVE_RUSAGE</a>
<a name="ln1317">  thread-&gt;hist-&gt;cpu.total += cputime;</a>
<a name="ln1318">  if (thread-&gt;hist-&gt;cpu.max &lt; cputime)</a>
<a name="ln1319">    thread-&gt;hist-&gt;cpu.max = cputime;</a>
<a name="ln1320">#endif</a>
<a name="ln1321"> </a>
<a name="ln1322">  ++(thread-&gt;hist-&gt;total_calls);</a>
<a name="ln1323">  thread-&gt;hist-&gt;types |= (1 &lt;&lt; thread-&gt;add_type);</a>
<a name="ln1324"> </a>
<a name="ln1325">#ifdef CONSUMED_TIME_CHECK</a>
<a name="ln1326">  if (realtime &gt; CONSUMED_TIME_CHECK)</a>
<a name="ln1327">    {</a>
<a name="ln1328">      /*</a>
<a name="ln1329">       * We have a CPU Hog on our hands.</a>
<a name="ln1330">       * Whinge about it now, so we're aware this is yet another task</a>
<a name="ln1331">       * to fix.</a>
<a name="ln1332">       */</a>
<a name="ln1333">      zlog_warn (&quot;SLOW THREAD: task %s (%lx) ran for %lums (cpu time %lums)&quot;,</a>
<a name="ln1334">		 thread-&gt;funcname,</a>
<a name="ln1335">		 (unsigned long) thread-&gt;func,</a>
<a name="ln1336">		 realtime/1000, cputime/1000);</a>
<a name="ln1337">    }</a>
<a name="ln1338">#endif /* CONSUMED_TIME_CHECK */</a>
<a name="ln1339">  </a>
<a name="ln1340">  thread_add_unuse (thread);</a>
<a name="ln1341">}</a>
<a name="ln1342"> </a>
<a name="ln1343">/* Execute thread */</a>
<a name="ln1344">struct thread *</a>
<a name="ln1345">funcname_thread_execute (struct thread_master *m,</a>
<a name="ln1346">                int (*func)(struct thread *), </a>
<a name="ln1347">                void *arg,</a>
<a name="ln1348">                int val,</a>
<a name="ln1349">		debugargdef)</a>
<a name="ln1350">{</a>
<a name="ln1351">  struct thread dummy; </a>
<a name="ln1352"> </a>
<a name="ln1353">  memset (&amp;dummy, 0, sizeof (struct thread));</a>
<a name="ln1354"> </a>
<a name="ln1355">  dummy.type = THREAD_EVENT;</a>
<a name="ln1356">  dummy.add_type = THREAD_EXECUTE;</a>
<a name="ln1357">  dummy.master = NULL;</a>
<a name="ln1358">  dummy.func = func;</a>
<a name="ln1359">  dummy.arg = arg;</a>
<a name="ln1360">  dummy.u.val = val;</a>
<a name="ln1361"> </a>
<a name="ln1362">  dummy.funcname = funcname;</a>
<a name="ln1363">  dummy.schedfrom = schedfrom;</a>
<a name="ln1364">  dummy.schedfrom_line = fromln;</a>
<a name="ln1365"> </a>
<a name="ln1366">  thread_call (&amp;dummy);</a>
<a name="ln1367"> </a>
<a name="ln1368">  return NULL;</a>
<a name="ln1369">}</a>
<a name="ln1370"> </a>
<a name="ln1371">/* Co-operative thread main loop */</a>
<a name="ln1372">void</a>
<a name="ln1373">thread_main (struct thread_master *master)</a>
<a name="ln1374">{</a>
<a name="ln1375">  struct thread *t;</a>
<a name="ln1376">  while ((t = thread_fetch (master)))</a>
<a name="ln1377">    thread_call (t);</a>
<a name="ln1378">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="607"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v713/" target="_blank">V713</a> The pointer 'thread' was utilized in the logical expression before it was verified against nullptr in the same logical expression.</p></div>
<div class="balloon" rel="606"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'thread' pointer was utilized before it was verified against nullptr. Check lines: 606, 607.</p></div>
<div class="balloon" rel="787"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'dir = 0' is always false.</p></div>
<div class="balloon" rel="787"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v559/" target="_blank">V559</a> Suspicious assignment inside the conditional expression of ternary operator: dir = 0.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
