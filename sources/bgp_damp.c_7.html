
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_damp.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP flap dampening</a>
<a name="ln2">   Copyright (C) 2001 IP Infusion Inc.</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22">#include &lt;math.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;prefix.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &quot;thread.h&quot;</a>
<a name="ln29">#include &quot;filter.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln32">#include &quot;bgpd/bgp_damp.h&quot;</a>
<a name="ln33">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln34">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln35">#include &quot;bgpd/bgp_attr.h&quot; </a>
<a name="ln36">#include &quot;bgpd/bgp_advertise.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">/* Global variable to access damping configuration */</a>
<a name="ln39">struct bgp_damp_config bgp_damp_cfg;</a>
<a name="ln40">static struct bgp_damp_config *damp = &amp;bgp_damp_cfg;</a>
<a name="ln41"> </a>
<a name="ln42">/* Utility macro to add and delete BGP dampening information to no</a>
<a name="ln43">   used list.  */</a>
<a name="ln44">#define BGP_DAMP_LIST_ADD(N,A)  BGP_INFO_ADD(N,A,no_reuse_list)</a>
<a name="ln45">#define BGP_DAMP_LIST_DEL(N,A)  BGP_INFO_DEL(N,A,no_reuse_list)</a>
<a name="ln46"> </a>
<a name="ln47">/* Calculate reuse list index by penalty value.  */</a>
<a name="ln48">static int</a>
<a name="ln49">bgp_reuse_index (int penalty)</a>
<a name="ln50">{</a>
<a name="ln51">  unsigned int i;</a>
<a name="ln52">  int index;</a>
<a name="ln53"> </a>
<a name="ln54">  i = (int)(((double) penalty / damp-&gt;reuse_limit - 1.0) * damp-&gt;scale_factor);</a>
<a name="ln55">  </a>
<a name="ln56">  if ( i &gt;= damp-&gt;reuse_index_size )</a>
<a name="ln57">    i = damp-&gt;reuse_index_size - 1;</a>
<a name="ln58"> </a>
<a name="ln59">  index = damp-&gt;reuse_index[i] - damp-&gt;reuse_index[0];</a>
<a name="ln60"> </a>
<a name="ln61">  return (damp-&gt;reuse_offset + index) % damp-&gt;reuse_list_size;  </a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">/* Add BGP dampening information to reuse list.  */</a>
<a name="ln65">static void </a>
<a name="ln66">bgp_reuse_list_add (struct bgp_damp_info *bdi)</a>
<a name="ln67">{</a>
<a name="ln68">  int index;</a>
<a name="ln69"> </a>
<a name="ln70">  index = bdi-&gt;index = bgp_reuse_index (bdi-&gt;penalty);</a>
<a name="ln71"> </a>
<a name="ln72">  bdi-&gt;prev = NULL;</a>
<a name="ln73">  bdi-&gt;next = damp-&gt;reuse_list[index];</a>
<a name="ln74">  if (damp-&gt;reuse_list[index])</a>
<a name="ln75">    damp-&gt;reuse_list[index]-&gt;prev = bdi;</a>
<a name="ln76">  damp-&gt;reuse_list[index] = bdi;</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">/* Delete BGP dampening information from reuse list.  */</a>
<a name="ln80">static void</a>
<a name="ln81">bgp_reuse_list_delete (struct bgp_damp_info *bdi)</a>
<a name="ln82">{</a>
<a name="ln83">  if (bdi-&gt;next)</a>
<a name="ln84">    bdi-&gt;next-&gt;prev = bdi-&gt;prev;</a>
<a name="ln85">  if (bdi-&gt;prev)</a>
<a name="ln86">    bdi-&gt;prev-&gt;next = bdi-&gt;next;</a>
<a name="ln87">  else</a>
<a name="ln88">    damp-&gt;reuse_list[bdi-&gt;index] = bdi-&gt;next;</a>
<a name="ln89">}   </a>
<a name="ln90"> </a>
<a name="ln91">/* Return decayed penalty value.  */</a>
<a name="ln92">int </a>
<a name="ln93">bgp_damp_decay (time_t tdiff, int penalty)</a>
<a name="ln94">{</a>
<a name="ln95">  unsigned int i;</a>
<a name="ln96"> </a>
<a name="ln97">  i = (int) ((double) tdiff / DELTA_T);</a>
<a name="ln98"> </a>
<a name="ln99">  if (i == 0)</a>
<a name="ln100">    return penalty; </a>
<a name="ln101">  </a>
<a name="ln102">  if (i &gt;= damp-&gt;decay_array_size)</a>
<a name="ln103">    return 0;</a>
<a name="ln104"> </a>
<a name="ln105">  return (int) (penalty * damp-&gt;decay_array[i]);</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">/* Handler of reuse timer event.  Each route in the current reuse-list</a>
<a name="ln109">   is evaluated.  RFC2439 Section 4.8.7.  */</a>
<a name="ln110">static int</a>
<a name="ln111">bgp_reuse_timer (struct thread *t)</a>
<a name="ln112">{</a>
<a name="ln113">  struct bgp_damp_info *bdi;</a>
<a name="ln114">  struct bgp_damp_info *next;</a>
<a name="ln115">  time_t t_now, t_diff;</a>
<a name="ln116">    </a>
<a name="ln117">  damp-&gt;t_reuse = NULL;</a>
<a name="ln118">  damp-&gt;t_reuse =</a>
<a name="ln119">    thread_add_timer (bm-&gt;master, bgp_reuse_timer, NULL, DELTA_REUSE);</a>
<a name="ln120"> </a>
<a name="ln121">  t_now = bgp_clock ();</a>
<a name="ln122"> </a>
<a name="ln123">  /* 1.  save a pointer to the current zeroth queue head and zero the</a>
<a name="ln124">     list head entry.  */</a>
<a name="ln125">  bdi = damp-&gt;reuse_list[damp-&gt;reuse_offset];</a>
<a name="ln126">  damp-&gt;reuse_list[damp-&gt;reuse_offset] = NULL;</a>
<a name="ln127"> </a>
<a name="ln128">  /* 2.  set offset = modulo reuse-list-size ( offset + 1 ), thereby</a>
<a name="ln129">     rotating the circular queue of list-heads.  */</a>
<a name="ln130">  damp-&gt;reuse_offset = (damp-&gt;reuse_offset + 1) % damp-&gt;reuse_list_size;</a>
<a name="ln131"> </a>
<a name="ln132">  /* 3. if ( the saved list head pointer is non-empty ) */</a>
<a name="ln133">  for (; bdi; bdi = next)</a>
<a name="ln134">    {</a>
<a name="ln135">      struct bgp *bgp = bdi-&gt;binfo-&gt;peer-&gt;bgp;</a>
<a name="ln136">      </a>
<a name="ln137">      next = bdi-&gt;next;</a>
<a name="ln138"> </a>
<a name="ln139">      /* Set t-diff = t-now - t-updated.  */</a>
<a name="ln140">      t_diff = t_now - bdi-&gt;t_updated;</a>
<a name="ln141"> </a>
<a name="ln142">      /* Set figure-of-merit = figure-of-merit * decay-array-ok [t-diff] */</a>
<a name="ln143">      bdi-&gt;penalty = bgp_damp_decay (t_diff, bdi-&gt;penalty);   </a>
<a name="ln144"> </a>
<a name="ln145">      /* Set t-updated = t-now.  */</a>
<a name="ln146">      bdi-&gt;t_updated = t_now;</a>
<a name="ln147"> </a>
<a name="ln148">      /* if (figure-of-merit &lt; reuse).  */</a>
<a name="ln149">      if (bdi-&gt;penalty &lt; damp-&gt;reuse_limit)</a>
<a name="ln150">	{</a>
<a name="ln151">	  /* Reuse the route.  */</a>
<a name="ln152">	  bgp_info_unset_flag (bdi-&gt;rn, bdi-&gt;binfo, BGP_INFO_DAMPED);</a>
<a name="ln153">	  bdi-&gt;suppress_time = 0;</a>
<a name="ln154"> </a>
<a name="ln155">	  if (bdi-&gt;lastrecord == BGP_RECORD_UPDATE)</a>
<a name="ln156">	    {</a>
<a name="ln157">	      bgp_info_unset_flag (bdi-&gt;rn, bdi-&gt;binfo, BGP_INFO_HISTORY);</a>
<a name="ln158">	      bgp_aggregate_increment (bgp, &amp;bdi-&gt;rn-&gt;p, bdi-&gt;binfo,</a>
<a name="ln159">				       bdi-&gt;afi, bdi-&gt;safi);   </a>
<a name="ln160">	      bgp_process (bgp, bdi-&gt;rn, bdi-&gt;afi, bdi-&gt;safi);</a>
<a name="ln161">	    }</a>
<a name="ln162"> </a>
<a name="ln163">	  if (bdi-&gt;penalty &lt;= damp-&gt;reuse_limit / 2.0)</a>
<a name="ln164">	    bgp_damp_info_free (bdi, 1);</a>
<a name="ln165">	  else</a>
<a name="ln166">	    BGP_DAMP_LIST_ADD (damp, bdi);</a>
<a name="ln167">	}</a>
<a name="ln168">      else</a>
<a name="ln169">	/* Re-insert into another list (See RFC2439 Section 4.8.6).  */</a>
<a name="ln170">	bgp_reuse_list_add (bdi);</a>
<a name="ln171">    }</a>
<a name="ln172"> </a>
<a name="ln173">  return 0;</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">/* A route becomes unreachable (RFC2439 Section 4.8.2).  */</a>
<a name="ln177">int</a>
<a name="ln178">bgp_damp_withdraw (struct bgp_info *binfo, struct bgp_node *rn,</a>
<a name="ln179">		   afi_t afi, safi_t safi, int attr_change)</a>
<a name="ln180">{</a>
<a name="ln181">  time_t t_now;</a>
<a name="ln182">  struct bgp_damp_info *bdi = NULL;</a>
<a name="ln183">  double last_penalty = 0;</a>
<a name="ln184">  </a>
<a name="ln185">  t_now = bgp_clock ();</a>
<a name="ln186"> </a>
<a name="ln187">  /* Processing Unreachable Messages.  */</a>
<a name="ln188">  if (binfo-&gt;extra)</a>
<a name="ln189">    bdi = binfo-&gt;extra-&gt;damp_info;</a>
<a name="ln190">  </a>
<a name="ln191">  if (bdi == NULL)</a>
<a name="ln192">    {</a>
<a name="ln193">      /* If there is no previous stability history. */</a>
<a name="ln194"> </a>
<a name="ln195">      /* RFC2439 said:</a>
<a name="ln196">	 1. allocate a damping structure.</a>
<a name="ln197">         2. set figure-of-merit = 1.</a>
<a name="ln198">         3. withdraw the route.  */</a>
<a name="ln199"> </a>
<a name="ln200">      bdi =  XCALLOC (MTYPE_BGP_DAMP_INFO, sizeof (struct bgp_damp_info));</a>
<a name="ln201">      bdi-&gt;binfo = binfo;</a>
<a name="ln202">      bdi-&gt;rn = rn;</a>
<a name="ln203">      bdi-&gt;penalty = (attr_change ? DEFAULT_PENALTY / 2 : DEFAULT_PENALTY);</a>
<a name="ln204">      bdi-&gt;flap = 1;</a>
<a name="ln205">      bdi-&gt;start_time = t_now;</a>
<a name="ln206">      bdi-&gt;suppress_time = 0;</a>
<a name="ln207">      bdi-&gt;index = -1;</a>
<a name="ln208">      bdi-&gt;afi = afi;</a>
<a name="ln209">      bdi-&gt;safi = safi;</a>
<a name="ln210">      (bgp_info_extra_get (binfo))-&gt;damp_info = bdi;</a>
<a name="ln211">      BGP_DAMP_LIST_ADD (damp, bdi);</a>
<a name="ln212">    }</a>
<a name="ln213">  else</a>
<a name="ln214">    {</a>
<a name="ln215">      last_penalty = bdi-&gt;penalty;</a>
<a name="ln216"> </a>
<a name="ln217">      /* 1. Set t-diff = t-now - t-updated.  */</a>
<a name="ln218">      bdi-&gt;penalty = </a>
<a name="ln219">	(bgp_damp_decay (t_now - bdi-&gt;t_updated, bdi-&gt;penalty) </a>
<a name="ln220">	 + (attr_change ? DEFAULT_PENALTY / 2 : DEFAULT_PENALTY));</a>
<a name="ln221"> </a>
<a name="ln222">      if (bdi-&gt;penalty &gt; damp-&gt;ceiling)</a>
<a name="ln223">	bdi-&gt;penalty = damp-&gt;ceiling;</a>
<a name="ln224"> </a>
<a name="ln225">      bdi-&gt;flap++;</a>
<a name="ln226">    }</a>
<a name="ln227">  </a>
<a name="ln228">  assert ((rn == bdi-&gt;rn) &amp;&amp; (binfo == bdi-&gt;binfo));</a>
<a name="ln229">  </a>
<a name="ln230">  bdi-&gt;lastrecord = BGP_RECORD_WITHDRAW;</a>
<a name="ln231">  bdi-&gt;t_updated = t_now;</a>
<a name="ln232"> </a>
<a name="ln233">  /* Make this route as historical status.  */</a>
<a name="ln234">  bgp_info_set_flag (rn, binfo, BGP_INFO_HISTORY);</a>
<a name="ln235"> </a>
<a name="ln236">  /* Remove the route from a reuse list if it is on one.  */</a>
<a name="ln237">  if (CHECK_FLAG (bdi-&gt;binfo-&gt;flags, BGP_INFO_DAMPED))</a>
<a name="ln238">    {</a>
<a name="ln239">      /* If decay rate isn't equal to 0, reinsert brn. */  </a>
<a name="ln240">      if (bdi-&gt;penalty != last_penalty)</a>
<a name="ln241">	{</a>
<a name="ln242">	  bgp_reuse_list_delete (bdi);</a>
<a name="ln243">	  bgp_reuse_list_add (bdi);  </a>
<a name="ln244">	}</a>
<a name="ln245">      return BGP_DAMP_SUPPRESSED; </a>
<a name="ln246">    }</a>
<a name="ln247"> </a>
<a name="ln248">  /* If not suppressed before, do annonunce this withdraw and</a>
<a name="ln249">     insert into reuse_list.  */</a>
<a name="ln250">  if (bdi-&gt;penalty &gt;= damp-&gt;suppress_value)</a>
<a name="ln251">    {</a>
<a name="ln252">      bgp_info_set_flag (rn, binfo, BGP_INFO_DAMPED);</a>
<a name="ln253">      bdi-&gt;suppress_time = t_now;</a>
<a name="ln254">      BGP_DAMP_LIST_DEL (damp, bdi);</a>
<a name="ln255">      bgp_reuse_list_add (bdi);</a>
<a name="ln256">    }</a>
<a name="ln257"> </a>
<a name="ln258">  return BGP_DAMP_USED;</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">int</a>
<a name="ln262">bgp_damp_update (struct bgp_info *binfo, struct bgp_node *rn, </a>
<a name="ln263">		 afi_t afi, safi_t safi)</a>
<a name="ln264">{</a>
<a name="ln265">  time_t t_now;</a>
<a name="ln266">  struct bgp_damp_info *bdi;</a>
<a name="ln267">  int status;</a>
<a name="ln268"> </a>
<a name="ln269">  if (!binfo-&gt;extra || !((bdi = binfo-&gt;extra-&gt;damp_info)))</a>
<a name="ln270">    return BGP_DAMP_USED;</a>
<a name="ln271"> </a>
<a name="ln272">  t_now = bgp_clock ();</a>
<a name="ln273">  bgp_info_unset_flag (rn, binfo, BGP_INFO_HISTORY);</a>
<a name="ln274"> </a>
<a name="ln275">  bdi-&gt;lastrecord = BGP_RECORD_UPDATE;</a>
<a name="ln276">  bdi-&gt;penalty = bgp_damp_decay (t_now - bdi-&gt;t_updated, bdi-&gt;penalty);</a>
<a name="ln277"> </a>
<a name="ln278">  if (! CHECK_FLAG (bdi-&gt;binfo-&gt;flags, BGP_INFO_DAMPED)</a>
<a name="ln279">      &amp;&amp; (bdi-&gt;penalty &lt; damp-&gt;suppress_value))</a>
<a name="ln280">    status = BGP_DAMP_USED;</a>
<a name="ln281">  else if (CHECK_FLAG (bdi-&gt;binfo-&gt;flags, BGP_INFO_DAMPED)</a>
<a name="ln282">	   &amp;&amp; (bdi-&gt;penalty &lt; damp-&gt;reuse_limit) )</a>
<a name="ln283">    {</a>
<a name="ln284">      bgp_info_unset_flag (rn, binfo, BGP_INFO_DAMPED);</a>
<a name="ln285">      bgp_reuse_list_delete (bdi);</a>
<a name="ln286">      BGP_DAMP_LIST_ADD (damp, bdi);</a>
<a name="ln287">      bdi-&gt;suppress_time = 0;</a>
<a name="ln288">      status = BGP_DAMP_USED;</a>
<a name="ln289">    }</a>
<a name="ln290">  else</a>
<a name="ln291">    status = BGP_DAMP_SUPPRESSED;  </a>
<a name="ln292"> </a>
<a name="ln293">  if (bdi-&gt;penalty &gt; damp-&gt;reuse_limit / 2.0)</a>
<a name="ln294">    bdi-&gt;t_updated = t_now;</a>
<a name="ln295">  else</a>
<a name="ln296">    bgp_damp_info_free (bdi, 0);</a>
<a name="ln297">	</a>
<a name="ln298">  return status;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">/* Remove dampening information and history route.  */</a>
<a name="ln302">int </a>
<a name="ln303">bgp_damp_scan (struct bgp_info *binfo, afi_t afi, safi_t safi)</a>
<a name="ln304">{</a>
<a name="ln305">  time_t t_now, t_diff;</a>
<a name="ln306">  struct bgp_damp_info *bdi;</a>
<a name="ln307">  </a>
<a name="ln308">  assert (binfo-&gt;extra &amp;&amp; binfo-&gt;extra-&gt;damp_info);</a>
<a name="ln309">  </a>
<a name="ln310">  t_now = bgp_clock ();</a>
<a name="ln311">  bdi = binfo-&gt;extra-&gt;damp_info;</a>
<a name="ln312"> </a>
<a name="ln313">  if (CHECK_FLAG (binfo-&gt;flags, BGP_INFO_DAMPED))</a>
<a name="ln314">    {</a>
<a name="ln315">      t_diff = t_now - bdi-&gt;suppress_time;</a>
<a name="ln316"> </a>
<a name="ln317">      if (t_diff &gt;= damp-&gt;max_suppress_time)</a>
<a name="ln318">        {</a>
<a name="ln319">          bgp_info_unset_flag (bdi-&gt;rn, binfo, BGP_INFO_DAMPED);</a>
<a name="ln320">          bgp_reuse_list_delete (bdi);</a>
<a name="ln321">	  BGP_DAMP_LIST_ADD (damp, bdi);</a>
<a name="ln322">          bdi-&gt;penalty = damp-&gt;reuse_limit;</a>
<a name="ln323">          bdi-&gt;suppress_time = 0;</a>
<a name="ln324">          bdi-&gt;t_updated = t_now;</a>
<a name="ln325">          </a>
<a name="ln326">          /* Need to announce UPDATE once this binfo is usable again. */</a>
<a name="ln327">          if (bdi-&gt;lastrecord == BGP_RECORD_UPDATE)</a>
<a name="ln328">            return 1;</a>
<a name="ln329">          else</a>
<a name="ln330">            return 0;</a>
<a name="ln331">        }</a>
<a name="ln332">    }</a>
<a name="ln333">  else</a>
<a name="ln334">    {</a>
<a name="ln335">      t_diff = t_now - bdi-&gt;t_updated;</a>
<a name="ln336">      bdi-&gt;penalty = bgp_damp_decay (t_diff, bdi-&gt;penalty);</a>
<a name="ln337"> </a>
<a name="ln338">      if (bdi-&gt;penalty &lt;= damp-&gt;reuse_limit / 2.0)</a>
<a name="ln339">        {</a>
<a name="ln340">          /* release the bdi, bdi-&gt;binfo. */  </a>
<a name="ln341">          bgp_damp_info_free (bdi, 1);</a>
<a name="ln342">          return 0;</a>
<a name="ln343">        }            </a>
<a name="ln344">      else</a>
<a name="ln345">        bdi-&gt;t_updated = t_now;</a>
<a name="ln346">    }       </a>
<a name="ln347">  return 0;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">void</a>
<a name="ln351">bgp_damp_info_free (struct bgp_damp_info *bdi, int withdraw)</a>
<a name="ln352">{</a>
<a name="ln353">  struct bgp_info *binfo;</a>
<a name="ln354"> </a>
<a name="ln355">  if (! bdi)</a>
<a name="ln356">    return;</a>
<a name="ln357"> </a>
<a name="ln358">  binfo = bdi-&gt;binfo;</a>
<a name="ln359">  binfo-&gt;extra-&gt;damp_info = NULL;</a>
<a name="ln360"> </a>
<a name="ln361">  if (CHECK_FLAG (binfo-&gt;flags, BGP_INFO_DAMPED))</a>
<a name="ln362">    bgp_reuse_list_delete (bdi);</a>
<a name="ln363">  else</a>
<a name="ln364">    BGP_DAMP_LIST_DEL (damp, bdi);</a>
<a name="ln365"> </a>
<a name="ln366">  bgp_info_unset_flag (bdi-&gt;rn, binfo, BGP_INFO_HISTORY|BGP_INFO_DAMPED);</a>
<a name="ln367"> </a>
<a name="ln368">  if (bdi-&gt;lastrecord == BGP_RECORD_WITHDRAW &amp;&amp; withdraw)</a>
<a name="ln369">    bgp_info_delete (bdi-&gt;rn, binfo);</a>
<a name="ln370">  </a>
<a name="ln371">  XFREE (MTYPE_BGP_DAMP_INFO, bdi);</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">static void</a>
<a name="ln375">bgp_damp_parameter_set (int hlife, int reuse, int sup, int maxsup)</a>
<a name="ln376">{</a>
<a name="ln377">  double reuse_max_ratio;</a>
<a name="ln378">  unsigned int i;</a>
<a name="ln379">  double j;</a>
<a name="ln380">	</a>
<a name="ln381">  damp-&gt;suppress_value = sup;</a>
<a name="ln382">  damp-&gt;half_life = hlife;</a>
<a name="ln383">  damp-&gt;reuse_limit = reuse;</a>
<a name="ln384">  damp-&gt;max_suppress_time = maxsup;</a>
<a name="ln385"> </a>
<a name="ln386">  /* Initialize params per bgp_damp_config. */</a>
<a name="ln387">  damp-&gt;reuse_index_size = REUSE_ARRAY_SIZE;</a>
<a name="ln388"> </a>
<a name="ln389">  damp-&gt;ceiling = (int)(damp-&gt;reuse_limit * (pow(2, (double)damp-&gt;max_suppress_time/damp-&gt;half_life))); </a>
<a name="ln390"> </a>
<a name="ln391">  /* Decay-array computations */</a>
<a name="ln392">  damp-&gt;decay_array_size = ceil ((double) damp-&gt;max_suppress_time / DELTA_T);</a>
<a name="ln393">  damp-&gt;decay_array = XMALLOC (MTYPE_BGP_DAMP_ARRAY,</a>
<a name="ln394">			       sizeof(double) * (damp-&gt;decay_array_size));</a>
<a name="ln395">  damp-&gt;decay_array[0] = 1.0;</a>
<a name="ln396">  damp-&gt;decay_array[1] = exp ((1.0/((double)damp-&gt;half_life/DELTA_T)) * log(0.5));</a>
<a name="ln397"> </a>
<a name="ln398">  /* Calculate decay values for all possible times */</a>
<a name="ln399">  for (i = 2; i &lt; damp-&gt;decay_array_size; i++)</a>
<a name="ln400">    damp-&gt;decay_array[i] = damp-&gt;decay_array[i-1] * damp-&gt;decay_array[1];</a>
<a name="ln401">	</a>
<a name="ln402">  /* Reuse-list computations */</a>
<a name="ln403">  i = ceil ((double)damp-&gt;max_suppress_time / DELTA_REUSE) + 1;</a>
<a name="ln404">  if (i &gt; REUSE_LIST_SIZE || i == 0)</a>
<a name="ln405">    i = REUSE_LIST_SIZE;</a>
<a name="ln406">  damp-&gt;reuse_list_size = i; </a>
<a name="ln407"> </a>
<a name="ln408">  damp-&gt;reuse_list = XCALLOC (MTYPE_BGP_DAMP_ARRAY, </a>
<a name="ln409">			      damp-&gt;reuse_list_size </a>
<a name="ln410">			      * sizeof (struct bgp_reuse_node *));</a>
<a name="ln411"> </a>
<a name="ln412">  /* Reuse-array computations */</a>
<a name="ln413">  damp-&gt;reuse_index = XCALLOC (MTYPE_BGP_DAMP_ARRAY,</a>
<a name="ln414">			       sizeof(int) * damp-&gt;reuse_index_size);</a>
<a name="ln415"> </a>
<a name="ln416">  reuse_max_ratio = (double)damp-&gt;ceiling/damp-&gt;reuse_limit;</a>
<a name="ln417">  j = (exp((double)damp-&gt;max_suppress_time/damp-&gt;half_life) * log10(2.0));</a>
<a name="ln418">  if ( reuse_max_ratio &gt; j &amp;&amp; j != 0 )</a>
<a name="ln419">    reuse_max_ratio = j;</a>
<a name="ln420"> </a>
<a name="ln421">  damp-&gt;scale_factor = (double)damp-&gt;reuse_index_size/(reuse_max_ratio - 1);</a>
<a name="ln422"> </a>
<a name="ln423">  for (i = 0; i &lt; damp-&gt;reuse_index_size; i++)</a>
<a name="ln424">    {</a>
<a name="ln425">      damp-&gt;reuse_index[i] = </a>
<a name="ln426">	(int)(((double)damp-&gt;half_life / DELTA_REUSE)</a>
<a name="ln427">	      * log10 (1.0 / (damp-&gt;reuse_limit * ( 1.0 + ((double)i/damp-&gt;scale_factor)))) / log10(0.5));</a>
<a name="ln428">    }</a>
<a name="ln429">}</a>
<a name="ln430"> </a>
<a name="ln431">int</a>
<a name="ln432">bgp_damp_enable (struct bgp *bgp, afi_t afi, safi_t safi, time_t half,</a>
<a name="ln433">		 unsigned int reuse, unsigned int suppress, time_t max)</a>
<a name="ln434">{</a>
<a name="ln435">  if (CHECK_FLAG (bgp-&gt;af_flags[afi][safi], BGP_CONFIG_DAMPENING))</a>
<a name="ln436">    {</a>
<a name="ln437">      if (damp-&gt;half_life == half</a>
<a name="ln438">	  &amp;&amp; damp-&gt;reuse_limit == reuse</a>
<a name="ln439">	  &amp;&amp; damp-&gt;suppress_value == suppress</a>
<a name="ln440">	  &amp;&amp; damp-&gt;max_suppress_time == max)</a>
<a name="ln441">	return 0;</a>
<a name="ln442">      bgp_damp_disable (bgp, afi, safi);</a>
<a name="ln443">    }</a>
<a name="ln444"> </a>
<a name="ln445">  SET_FLAG (bgp-&gt;af_flags[afi][safi], BGP_CONFIG_DAMPENING);</a>
<a name="ln446">  bgp_damp_parameter_set (half, reuse, suppress, max);</a>
<a name="ln447"> </a>
<a name="ln448">  /* Register reuse timer.  */</a>
<a name="ln449">  if (! damp-&gt;t_reuse)</a>
<a name="ln450">    damp-&gt;t_reuse = </a>
<a name="ln451">      thread_add_timer (bm-&gt;master, bgp_reuse_timer, NULL, DELTA_REUSE);</a>
<a name="ln452"> </a>
<a name="ln453">  return 0;</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">static void</a>
<a name="ln457">bgp_damp_config_clean (struct bgp_damp_config *damp)</a>
<a name="ln458">{</a>
<a name="ln459">  /* Free decay array */</a>
<a name="ln460">  XFREE (MTYPE_BGP_DAMP_ARRAY, damp-&gt;decay_array);</a>
<a name="ln461"> </a>
<a name="ln462">  /* Free reuse index array */</a>
<a name="ln463">  XFREE (MTYPE_BGP_DAMP_ARRAY, damp-&gt;reuse_index);</a>
<a name="ln464"> </a>
<a name="ln465">  /* Free reuse list array. */</a>
<a name="ln466">  XFREE (MTYPE_BGP_DAMP_ARRAY, damp-&gt;reuse_list);</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469">/* Clean all the bgp_damp_info stored in reuse_list. */</a>
<a name="ln470">void</a>
<a name="ln471">bgp_damp_info_clean (void)</a>
<a name="ln472">{</a>
<a name="ln473">  unsigned int i;</a>
<a name="ln474">  struct bgp_damp_info *bdi, *next;</a>
<a name="ln475"> </a>
<a name="ln476">  damp-&gt;reuse_offset = 0;</a>
<a name="ln477"> </a>
<a name="ln478">  for (i = 0; i &lt; damp-&gt;reuse_list_size; i++)</a>
<a name="ln479">    {</a>
<a name="ln480">      if (! damp-&gt;reuse_list[i])</a>
<a name="ln481">	continue;</a>
<a name="ln482"> </a>
<a name="ln483">      for (bdi = damp-&gt;reuse_list[i]; bdi; bdi = next)</a>
<a name="ln484">	{</a>
<a name="ln485">	  next = bdi-&gt;next;</a>
<a name="ln486">	  bgp_damp_info_free (bdi, 1);</a>
<a name="ln487">	}</a>
<a name="ln488">      damp-&gt;reuse_list[i] = NULL;</a>
<a name="ln489">    }</a>
<a name="ln490"> </a>
<a name="ln491">  for (bdi = damp-&gt;no_reuse_list; bdi; bdi = next)</a>
<a name="ln492">    {</a>
<a name="ln493">      next = bdi-&gt;next;</a>
<a name="ln494">      bgp_damp_info_free (bdi, 1);</a>
<a name="ln495">    }</a>
<a name="ln496">  damp-&gt;no_reuse_list = NULL;</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">int</a>
<a name="ln500">bgp_damp_disable (struct bgp *bgp, afi_t afi, safi_t safi)</a>
<a name="ln501">{</a>
<a name="ln502">  /* If it wasn't enabled, there's nothing to do. */</a>
<a name="ln503">  if (! CHECK_FLAG (bgp-&gt;af_flags[afi][safi], BGP_CONFIG_DAMPENING))</a>
<a name="ln504">    return 0;</a>
<a name="ln505"> </a>
<a name="ln506">  /* Cancel reuse thread. */</a>
<a name="ln507">  if (damp-&gt;t_reuse )</a>
<a name="ln508">    thread_cancel (damp-&gt;t_reuse);</a>
<a name="ln509">  damp-&gt;t_reuse = NULL;</a>
<a name="ln510"> </a>
<a name="ln511">  /* Clean BGP dampening information.  */</a>
<a name="ln512">  bgp_damp_info_clean ();</a>
<a name="ln513"> </a>
<a name="ln514">  /* Clear configuration */</a>
<a name="ln515">  bgp_damp_config_clean (&amp;bgp_damp_cfg);</a>
<a name="ln516"> </a>
<a name="ln517">  UNSET_FLAG (bgp-&gt;af_flags[afi][safi], BGP_CONFIG_DAMPENING);</a>
<a name="ln518">  return 0;</a>
<a name="ln519">}</a>
<a name="ln520"> </a>
<a name="ln521">void</a>
<a name="ln522">bgp_config_write_damp (struct vty *vty)</a>
<a name="ln523">{</a>
<a name="ln524">  if (bgp_damp_cfg.half_life == DEFAULT_HALF_LIFE*60</a>
<a name="ln525">      &amp;&amp; bgp_damp_cfg.reuse_limit == DEFAULT_REUSE</a>
<a name="ln526">      &amp;&amp; bgp_damp_cfg.suppress_value == DEFAULT_SUPPRESS</a>
<a name="ln527">      &amp;&amp; bgp_damp_cfg.max_suppress_time == bgp_damp_cfg.half_life*4)</a>
<a name="ln528">    vty_out (vty, &quot; bgp dampening%s&quot;, VTY_NEWLINE);</a>
<a name="ln529">  else if (bgp_damp_cfg.half_life != DEFAULT_HALF_LIFE*60</a>
<a name="ln530">	   &amp;&amp; bgp_damp_cfg.reuse_limit == DEFAULT_REUSE</a>
<a name="ln531">	   &amp;&amp; bgp_damp_cfg.suppress_value == DEFAULT_SUPPRESS</a>
<a name="ln532">	   &amp;&amp; bgp_damp_cfg.max_suppress_time == bgp_damp_cfg.half_life*4)</a>
<a name="ln533">    vty_out (vty, &quot; bgp dampening %lld%s&quot;,</a>
<a name="ln534">	     bgp_damp_cfg.half_life/60LL,</a>
<a name="ln535">	     VTY_NEWLINE);</a>
<a name="ln536">  else</a>
<a name="ln537">    vty_out (vty, &quot; bgp dampening %lld %d %d %lld%s&quot;,</a>
<a name="ln538">	     bgp_damp_cfg.half_life/60LL,</a>
<a name="ln539">	     bgp_damp_cfg.reuse_limit,</a>
<a name="ln540">	     bgp_damp_cfg.suppress_value,</a>
<a name="ln541">	     bgp_damp_cfg.max_suppress_time/60LL,</a>
<a name="ln542">	     VTY_NEWLINE);</a>
<a name="ln543">}</a>
<a name="ln544"> </a>
<a name="ln545">static const char *</a>
<a name="ln546">bgp_get_reuse_time (unsigned int penalty, char *buf, size_t len)</a>
<a name="ln547">{</a>
<a name="ln548">  time_t reuse_time = 0;</a>
<a name="ln549">  struct tm *tm = NULL;</a>
<a name="ln550"> </a>
<a name="ln551">  if (penalty &gt; damp-&gt;reuse_limit)</a>
<a name="ln552">    {</a>
<a name="ln553">      reuse_time = (int) (DELTA_T * ((log((double)damp-&gt;reuse_limit/penalty))/(log(damp-&gt;decay_array[1])))); </a>
<a name="ln554"> </a>
<a name="ln555">      if (reuse_time &gt; damp-&gt;max_suppress_time)</a>
<a name="ln556">	reuse_time = damp-&gt;max_suppress_time;</a>
<a name="ln557"> </a>
<a name="ln558">      tm = gmtime (&amp;reuse_time);</a>
<a name="ln559">    }</a>
<a name="ln560">  else </a>
<a name="ln561">    reuse_time = 0;</a>
<a name="ln562"> </a>
<a name="ln563">  /* Making formatted timer strings. */</a>
<a name="ln564">#define ONE_DAY_SECOND 60*60*24</a>
<a name="ln565">#define ONE_WEEK_SECOND 60*60*24*7</a>
<a name="ln566">  if (reuse_time == 0)</a>
<a name="ln567">    snprintf (buf, len, &quot;00:00:00&quot;);</a>
<a name="ln568">  else if (reuse_time &lt; ONE_DAY_SECOND)</a>
<a name="ln569">    snprintf (buf, len, &quot;%02d:%02d:%02d&quot;, </a>
<a name="ln570">              tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);</a>
<a name="ln571">  else if (reuse_time &lt; ONE_WEEK_SECOND)</a>
<a name="ln572">    snprintf (buf, len, &quot;%dd%02dh%02dm&quot;, </a>
<a name="ln573">              tm-&gt;tm_yday, tm-&gt;tm_hour, tm-&gt;tm_min);</a>
<a name="ln574">  else</a>
<a name="ln575">    snprintf (buf, len, &quot;%02dw%dd%02dh&quot;, </a>
<a name="ln576">              tm-&gt;tm_yday/7, tm-&gt;tm_yday - ((tm-&gt;tm_yday/7) * 7), tm-&gt;tm_hour); </a>
<a name="ln577"> </a>
<a name="ln578">  return buf;</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">void</a>
<a name="ln582">bgp_damp_info_vty (struct vty *vty, struct bgp_info *binfo)  </a>
<a name="ln583">{</a>
<a name="ln584">  struct bgp_damp_info *bdi;</a>
<a name="ln585">  time_t t_now, t_diff;</a>
<a name="ln586">  char timebuf[BGP_UPTIME_LEN];</a>
<a name="ln587">  int penalty;</a>
<a name="ln588"> </a>
<a name="ln589">  if (!binfo-&gt;extra)</a>
<a name="ln590">    return;</a>
<a name="ln591">  </a>
<a name="ln592">  /* BGP dampening information.  */</a>
<a name="ln593">  bdi = binfo-&gt;extra-&gt;damp_info;</a>
<a name="ln594"> </a>
<a name="ln595">  /* If dampening is not enabled or there is no dampening information,</a>
<a name="ln596">     return immediately.  */</a>
<a name="ln597">  if (! damp || ! bdi)</a>
<a name="ln598">    return;</a>
<a name="ln599"> </a>
<a name="ln600">  /* Calculate new penalty.  */</a>
<a name="ln601">  t_now = bgp_clock ();</a>
<a name="ln602">  t_diff = t_now - bdi-&gt;t_updated;</a>
<a name="ln603">  penalty = bgp_damp_decay (t_diff, bdi-&gt;penalty);</a>
<a name="ln604"> </a>
<a name="ln605">  vty_out (vty, &quot;      Dampinfo: penalty %d, flapped %d times in %s&quot;,</a>
<a name="ln606">           penalty, bdi-&gt;flap,</a>
<a name="ln607">	   peer_uptime (bdi-&gt;start_time, timebuf, BGP_UPTIME_LEN));</a>
<a name="ln608"> </a>
<a name="ln609">  if (CHECK_FLAG (binfo-&gt;flags, BGP_INFO_DAMPED)</a>
<a name="ln610">      &amp;&amp; ! CHECK_FLAG (binfo-&gt;flags, BGP_INFO_HISTORY))</a>
<a name="ln611">    vty_out (vty, &quot;, reuse in %s&quot;,</a>
<a name="ln612">	     bgp_get_reuse_time (penalty, timebuf, BGP_UPTIME_LEN));</a>
<a name="ln613"> </a>
<a name="ln614">  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">const char *</a>
<a name="ln618">bgp_damp_reuse_time_vty (struct vty *vty, struct bgp_info *binfo,</a>
<a name="ln619">                         char *timebuf, size_t len)</a>
<a name="ln620">{</a>
<a name="ln621">  struct bgp_damp_info *bdi;</a>
<a name="ln622">  time_t t_now, t_diff;</a>
<a name="ln623">  int penalty;</a>
<a name="ln624">  </a>
<a name="ln625">  if (!binfo-&gt;extra)</a>
<a name="ln626">    return NULL;</a>
<a name="ln627">  </a>
<a name="ln628">  /* BGP dampening information.  */</a>
<a name="ln629">  bdi = binfo-&gt;extra-&gt;damp_info;</a>
<a name="ln630"> </a>
<a name="ln631">  /* If dampening is not enabled or there is no dampening information,</a>
<a name="ln632">     return immediately.  */</a>
<a name="ln633">  if (! damp || ! bdi)</a>
<a name="ln634">    return NULL;</a>
<a name="ln635"> </a>
<a name="ln636">  /* Calculate new penalty.  */</a>
<a name="ln637">  t_now = bgp_clock ();</a>
<a name="ln638">  t_diff = t_now - bdi-&gt;t_updated;</a>
<a name="ln639">  penalty = bgp_damp_decay (t_diff, bdi-&gt;penalty);</a>
<a name="ln640"> </a>
<a name="ln641">  return  bgp_get_reuse_time (penalty, timebuf, len);</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">int</a>
<a name="ln645">bgp_show_dampening_parameters (struct vty *vty, afi_t afi, safi_t safi)</a>
<a name="ln646">{</a>
<a name="ln647">  struct bgp *bgp;</a>
<a name="ln648">  bgp = bgp_get_default();</a>
<a name="ln649"> </a>
<a name="ln650">  if (bgp == NULL)</a>
<a name="ln651">    {</a>
<a name="ln652">      vty_out (vty, &quot;No BGP process is configured%s&quot;, VTY_NEWLINE);</a>
<a name="ln653">      return CMD_WARNING;</a>
<a name="ln654">    }</a>
<a name="ln655"> </a>
<a name="ln656">  if (CHECK_FLAG (bgp-&gt;af_flags[afi][safi], BGP_CONFIG_DAMPENING))</a>
<a name="ln657">    {</a>
<a name="ln658">      vty_out (vty, &quot;Half-life time: %ld min%s&quot;,</a>
<a name="ln659">                    damp-&gt;half_life / 60, VTY_NEWLINE);</a>
<a name="ln660">      vty_out (vty, &quot;Reuse penalty: %d%s&quot;,</a>
<a name="ln661">                    damp-&gt;reuse_limit, VTY_NEWLINE);</a>
<a name="ln662">      vty_out (vty, &quot;Suppress penalty: %d%s&quot;,</a>
<a name="ln663">                    damp-&gt;suppress_value, VTY_NEWLINE);</a>
<a name="ln664">      vty_out (vty, &quot;Max suppress time: %ld min%s&quot;,</a>
<a name="ln665">                    damp-&gt;max_suppress_time / 60, VTY_NEWLINE);</a>
<a name="ln666">      vty_out (vty, &quot;Max suppress penalty: %u%s&quot;,</a>
<a name="ln667">                    damp-&gt;ceiling, VTY_NEWLINE);</a>
<a name="ln668">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln669">    }</a>
<a name="ln670">  else</a>
<a name="ln671">    vty_out (vty, &quot;dampening not enabled for %s%s&quot;,</a>
<a name="ln672">                  afi == AFI_IP ? &quot;IPv4&quot; : &quot;IPv6&quot;, VTY_NEWLINE);</a>
<a name="ln673"> </a>
<a name="ln674">  return CMD_SUCCESS;</a>
<a name="ln675">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
