
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_oil.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;log.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;pimd.h&quot;</a>
<a name="ln30">#include &quot;pim_oil.h&quot;</a>
<a name="ln31">#include &quot;pim_str.h&quot;</a>
<a name="ln32">#include &quot;pim_iface.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">void pim_channel_oil_free(struct channel_oil *c_oil)</a>
<a name="ln35">{</a>
<a name="ln36">  XFREE(MTYPE_PIM_CHANNEL_OIL, c_oil);</a>
<a name="ln37">}</a>
<a name="ln38"> </a>
<a name="ln39">static void pim_channel_oil_delete(struct channel_oil *c_oil)</a>
<a name="ln40">{</a>
<a name="ln41">  /*</a>
<a name="ln42">    notice that listnode_delete() can't be moved</a>
<a name="ln43">    into pim_channel_oil_free() because the later is</a>
<a name="ln44">    called by list_delete_all_node()</a>
<a name="ln45">  */</a>
<a name="ln46">  listnode_delete(qpim_channel_oil_list, c_oil);</a>
<a name="ln47"> </a>
<a name="ln48">  pim_channel_oil_free(c_oil);</a>
<a name="ln49">}</a>
<a name="ln50"> </a>
<a name="ln51">static struct channel_oil *channel_oil_new(struct in_addr group_addr,</a>
<a name="ln52">					   struct in_addr source_addr,</a>
<a name="ln53">					   int input_vif_index)</a>
<a name="ln54">{</a>
<a name="ln55">  struct channel_oil *c_oil;</a>
<a name="ln56">  struct interface *ifp_in;</a>
<a name="ln57"> </a>
<a name="ln58">  ifp_in = pim_if_find_by_vif_index(input_vif_index);</a>
<a name="ln59">  if (!ifp_in) {</a>
<a name="ln60">    /* warning only */</a>
<a name="ln61">    char group_str[100]; </a>
<a name="ln62">    char source_str[100];</a>
<a name="ln63">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln64">    pim_inet4_dump(&quot;&lt;source?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln65">    zlog_warn(&quot;%s: (S,G)=(%s,%s) could not find input interface for input_vif_index=%d&quot;,</a>
<a name="ln66">	      __PRETTY_FUNCTION__,</a>
<a name="ln67">	      source_str, group_str, input_vif_index);</a>
<a name="ln68">  }</a>
<a name="ln69"> </a>
<a name="ln70">  c_oil = XCALLOC(MTYPE_PIM_CHANNEL_OIL, sizeof(*c_oil));</a>
<a name="ln71">  if (!c_oil) {</a>
<a name="ln72">    zlog_err(&quot;PIM XCALLOC(%zu) failure&quot;, sizeof(*c_oil));</a>
<a name="ln73">    return 0;</a>
<a name="ln74">  }</a>
<a name="ln75"> </a>
<a name="ln76">  c_oil-&gt;oil.mfcc_mcastgrp = group_addr;</a>
<a name="ln77">  c_oil-&gt;oil.mfcc_origin   = source_addr;</a>
<a name="ln78">  c_oil-&gt;oil.mfcc_parent   = input_vif_index;</a>
<a name="ln79">  c_oil-&gt;oil_ref_count     = 1;</a>
<a name="ln80"> </a>
<a name="ln81">  zassert(c_oil-&gt;oil_size == 0);</a>
<a name="ln82"> </a>
<a name="ln83">  return c_oil;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">static struct channel_oil *pim_add_channel_oil(struct in_addr group_addr,</a>
<a name="ln87">					       struct in_addr source_addr,</a>
<a name="ln88">					       int input_vif_index)</a>
<a name="ln89">{</a>
<a name="ln90">  struct channel_oil *c_oil;</a>
<a name="ln91"> </a>
<a name="ln92">  c_oil = channel_oil_new(group_addr, source_addr, input_vif_index);</a>
<a name="ln93">  if (!c_oil) {</a>
<a name="ln94">    zlog_warn(&quot;PIM XCALLOC(%zu) failure&quot;, sizeof(*c_oil));</a>
<a name="ln95">    return 0;</a>
<a name="ln96">  }</a>
<a name="ln97"> </a>
<a name="ln98">  listnode_add(qpim_channel_oil_list, c_oil);</a>
<a name="ln99"> </a>
<a name="ln100">  return c_oil;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">static struct channel_oil *pim_find_channel_oil(struct in_addr group_addr,</a>
<a name="ln104">						struct in_addr source_addr)</a>
<a name="ln105">{</a>
<a name="ln106">  struct listnode    *node;</a>
<a name="ln107">  struct channel_oil *c_oil;</a>
<a name="ln108"> </a>
<a name="ln109">  for (ALL_LIST_ELEMENTS_RO(qpim_channel_oil_list, node, c_oil)) {</a>
<a name="ln110">    if ((group_addr.s_addr == c_oil-&gt;oil.mfcc_mcastgrp.s_addr) &amp;&amp;</a>
<a name="ln111">	(source_addr.s_addr == c_oil-&gt;oil.mfcc_origin.s_addr))</a>
<a name="ln112">      return c_oil;</a>
<a name="ln113">  }</a>
<a name="ln114">  </a>
<a name="ln115">  return 0;</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">struct channel_oil *pim_channel_oil_add(struct in_addr group_addr,</a>
<a name="ln119">					struct in_addr source_addr,</a>
<a name="ln120">					int input_vif_index)</a>
<a name="ln121">{</a>
<a name="ln122">  struct channel_oil *c_oil;</a>
<a name="ln123"> </a>
<a name="ln124">  c_oil = pim_find_channel_oil(group_addr, source_addr);</a>
<a name="ln125">  if (c_oil) {</a>
<a name="ln126">    ++c_oil-&gt;oil_ref_count;</a>
<a name="ln127">    return c_oil;</a>
<a name="ln128">  }</a>
<a name="ln129"> </a>
<a name="ln130">  return pim_add_channel_oil(group_addr, source_addr, input_vif_index);</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">void pim_channel_oil_del(struct channel_oil *c_oil)</a>
<a name="ln134">{</a>
<a name="ln135">  --c_oil-&gt;oil_ref_count;</a>
<a name="ln136"> </a>
<a name="ln137">  if (c_oil-&gt;oil_ref_count &lt; 1) {</a>
<a name="ln138">    pim_channel_oil_delete(c_oil);</a>
<a name="ln139">  }</a>
<a name="ln140">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
