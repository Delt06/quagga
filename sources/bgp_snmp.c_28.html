
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_snmp.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP4 SNMP support</a>
<a name="ln2">   Copyright (C) 1999, 2000 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#ifdef HAVE_SNMP</a>
<a name="ln24">#include &lt;net-snmp/net-snmp-config.h&gt;</a>
<a name="ln25">#include &lt;net-snmp/net-snmp-includes.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;if.h&quot;</a>
<a name="ln28">#include &quot;log.h&quot;</a>
<a name="ln29">#include &quot;prefix.h&quot;</a>
<a name="ln30">#include &quot;command.h&quot;</a>
<a name="ln31">#include &quot;thread.h&quot;</a>
<a name="ln32">#include &quot;smux.h&quot;</a>
<a name="ln33">#include &quot;filter.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln38">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln39">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln40">#include &quot;bgpd/bgp_fsm.h&quot;</a>
<a name="ln41">#include &quot;bgpd/bgp_snmp.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">/* BGP4-MIB described in RFC1657. */</a>
<a name="ln44">#define BGP4MIB 1,3,6,1,2,1,15</a>
<a name="ln45"> </a>
<a name="ln46">/* BGP TRAP. */</a>
<a name="ln47">#define BGPESTABLISHED			1</a>
<a name="ln48">#define BGPBACKWARDTRANSITION		2	</a>
<a name="ln49"> </a>
<a name="ln50">/* BGP MIB bgpVersion. */</a>
<a name="ln51">#define BGPVERSION			      0</a>
<a name="ln52"> </a>
<a name="ln53">/* BGP MIB bgpLocalAs. */</a>
<a name="ln54">#define BGPLOCALAS			      0</a>
<a name="ln55"> </a>
<a name="ln56">/* BGP MIB bgpPeerTable. */</a>
<a name="ln57">#define BGPPEERIDENTIFIER                     1</a>
<a name="ln58">#define BGPPEERSTATE                          2</a>
<a name="ln59">#define BGPPEERADMINSTATUS                    3</a>
<a name="ln60">#define BGPPEERNEGOTIATEDVERSION              4</a>
<a name="ln61">#define BGPPEERLOCALADDR                      5</a>
<a name="ln62">#define BGPPEERLOCALPORT                      6</a>
<a name="ln63">#define BGPPEERREMOTEADDR                     7</a>
<a name="ln64">#define BGPPEERREMOTEPORT                     8</a>
<a name="ln65">#define BGPPEERREMOTEAS                       9</a>
<a name="ln66">#define BGPPEERINUPDATES                     10</a>
<a name="ln67">#define BGPPEEROUTUPDATES                    11</a>
<a name="ln68">#define BGPPEERINTOTALMESSAGES               12</a>
<a name="ln69">#define BGPPEEROUTTOTALMESSAGES              13</a>
<a name="ln70">#define BGPPEERLASTERROR                     14</a>
<a name="ln71">#define BGPPEERFSMESTABLISHEDTRANSITIONS     15</a>
<a name="ln72">#define BGPPEERFSMESTABLISHEDTIME            16</a>
<a name="ln73">#define BGPPEERCONNECTRETRYINTERVAL          17</a>
<a name="ln74">#define BGPPEERHOLDTIME                      18</a>
<a name="ln75">#define BGPPEERKEEPALIVE                     19</a>
<a name="ln76">#define BGPPEERHOLDTIMECONFIGURED            20</a>
<a name="ln77">#define BGPPEERKEEPALIVECONFIGURED           21</a>
<a name="ln78">#define BGPPEERMINROUTEADVERTISEMENTINTERVAL 22</a>
<a name="ln79">#define BGPPEERINUPDATEELAPSEDTIME           23</a>
<a name="ln80"> </a>
<a name="ln81">/* BGP MIB bgpIdentifier. */</a>
<a name="ln82">#define BGPIDENTIFIER                         0</a>
<a name="ln83"> </a>
<a name="ln84">/* BGP MIB bgpRcvdPathAttrTable */</a>
<a name="ln85">#define BGPPATHATTRPEER                       1</a>
<a name="ln86">#define BGPPATHATTRDESTNETWORK                2</a>
<a name="ln87">#define BGPPATHATTRORIGIN                     3</a>
<a name="ln88">#define BGPPATHATTRASPATH                     4</a>
<a name="ln89">#define BGPPATHATTRNEXTHOP                    5</a>
<a name="ln90">#define BGPPATHATTRINTERASMETRIC              6</a>
<a name="ln91"> </a>
<a name="ln92">/* BGP MIB bgp4PathAttrTable. */</a>
<a name="ln93">#define BGP4PATHATTRPEER                      1</a>
<a name="ln94">#define BGP4PATHATTRIPADDRPREFIXLEN           2</a>
<a name="ln95">#define BGP4PATHATTRIPADDRPREFIX              3</a>
<a name="ln96">#define BGP4PATHATTRORIGIN                    4</a>
<a name="ln97">#define BGP4PATHATTRASPATHSEGMENT             5</a>
<a name="ln98">#define BGP4PATHATTRNEXTHOP                   6</a>
<a name="ln99">#define BGP4PATHATTRMULTIEXITDISC             7</a>
<a name="ln100">#define BGP4PATHATTRLOCALPREF                 8</a>
<a name="ln101">#define BGP4PATHATTRATOMICAGGREGATE           9</a>
<a name="ln102">#define BGP4PATHATTRAGGREGATORAS             10</a>
<a name="ln103">#define BGP4PATHATTRAGGREGATORADDR           11</a>
<a name="ln104">#define BGP4PATHATTRCALCLOCALPREF            12</a>
<a name="ln105">#define BGP4PATHATTRBEST                     13</a>
<a name="ln106">#define BGP4PATHATTRUNKNOWN                  14</a>
<a name="ln107"> </a>
<a name="ln108">/* SNMP value hack. */</a>
<a name="ln109">#define INTEGER ASN_INTEGER</a>
<a name="ln110">#define INTEGER32 ASN_INTEGER</a>
<a name="ln111">#define COUNTER32 ASN_COUNTER</a>
<a name="ln112">#define OCTET_STRING ASN_OCTET_STR</a>
<a name="ln113">#define IPADDRESS ASN_IPADDRESS</a>
<a name="ln114">#define GAUGE32 ASN_UNSIGNED</a>
<a name="ln115"> </a>
<a name="ln116">/* Declare static local variables for convenience. */</a>
<a name="ln117">SNMP_LOCAL_VARIABLES</a>
<a name="ln118"> </a>
<a name="ln119">/* BGP-MIB instances. */</a>
<a name="ln120">oid bgp_oid [] = { BGP4MIB };</a>
<a name="ln121">oid bgp_trap_oid [] = { BGP4MIB, 0 };</a>
<a name="ln122"> </a>
<a name="ln123">/* IP address 0.0.0.0. */</a>
<a name="ln124">static struct in_addr bgp_empty_addr = { .s_addr = 0 };</a>
<a name="ln125"> </a>
<a name="ln126">/* Hook functions. */</a>
<a name="ln127">static u_char *bgpVersion (struct variable *, oid [], size_t *, int,</a>
<a name="ln128">			   size_t *, WriteMethod **);</a>
<a name="ln129">static u_char *bgpLocalAs (struct variable *, oid [], size_t *,</a>
<a name="ln130">			   int, size_t *, WriteMethod **);</a>
<a name="ln131">static u_char *bgpPeerTable (struct variable *, oid [], size_t *,</a>
<a name="ln132">			     int, size_t *, WriteMethod **);</a>
<a name="ln133">static u_char *bgpRcvdPathAttrTable (struct variable *, oid [], size_t *,</a>
<a name="ln134">				     int, size_t *, WriteMethod **);</a>
<a name="ln135">static u_char *bgpIdentifier (struct variable *, oid [], size_t *,</a>
<a name="ln136">			      int, size_t *, WriteMethod **);</a>
<a name="ln137">static u_char *bgp4PathAttrTable (struct variable *, oid [], size_t *,</a>
<a name="ln138">				  int, size_t *, WriteMethod **);</a>
<a name="ln139">/* static u_char *bgpTraps (); */</a>
<a name="ln140"> </a>
<a name="ln141">struct variable bgp_variables[] = </a>
<a name="ln142">{</a>
<a name="ln143">  /* BGP version. */</a>
<a name="ln144">  {BGPVERSION,                OCTET_STRING, RONLY, bgpVersion,</a>
<a name="ln145">   1, {1}},</a>
<a name="ln146">  /* BGP local AS. */</a>
<a name="ln147">  {BGPLOCALAS,                INTEGER, RONLY, bgpLocalAs,</a>
<a name="ln148">   1, {2}},</a>
<a name="ln149">  /* BGP peer table. */</a>
<a name="ln150">  {BGPPEERIDENTIFIER,         IPADDRESS, RONLY, bgpPeerTable,</a>
<a name="ln151">   3, {3, 1, 1}},</a>
<a name="ln152">  {BGPPEERSTATE,              INTEGER, RONLY, bgpPeerTable,</a>
<a name="ln153">   3, {3, 1, 2}},</a>
<a name="ln154">  {BGPPEERADMINSTATUS,        INTEGER, RWRITE, bgpPeerTable,</a>
<a name="ln155">   3, {3, 1, 3}},</a>
<a name="ln156">  {BGPPEERNEGOTIATEDVERSION,  INTEGER32, RONLY, bgpPeerTable,</a>
<a name="ln157">   3, {3, 1, 4}},</a>
<a name="ln158">  {BGPPEERLOCALADDR,          IPADDRESS, RONLY, bgpPeerTable,</a>
<a name="ln159">   3, {3, 1, 5}},</a>
<a name="ln160">  {BGPPEERLOCALPORT,          INTEGER, RONLY, bgpPeerTable,</a>
<a name="ln161">   3, {3, 1, 6}},</a>
<a name="ln162">  {BGPPEERREMOTEADDR,         IPADDRESS, RONLY, bgpPeerTable,</a>
<a name="ln163">   3, {3, 1, 7}},</a>
<a name="ln164">  {BGPPEERREMOTEPORT,         INTEGER, RONLY, bgpPeerTable,</a>
<a name="ln165">   3, {3, 1, 8}},</a>
<a name="ln166">  {BGPPEERREMOTEAS,           INTEGER, RONLY, bgpPeerTable,</a>
<a name="ln167">   3, {3, 1, 9}},</a>
<a name="ln168">  {BGPPEERINUPDATES,          COUNTER32, RONLY, bgpPeerTable,</a>
<a name="ln169">   3, {3, 1, 10}},</a>
<a name="ln170">  {BGPPEEROUTUPDATES,         COUNTER32, RONLY, bgpPeerTable,</a>
<a name="ln171">   3, {3, 1, 11}},</a>
<a name="ln172">  {BGPPEERINTOTALMESSAGES,    COUNTER32, RONLY, bgpPeerTable,</a>
<a name="ln173">   3, {3, 1, 12}},</a>
<a name="ln174">  {BGPPEEROUTTOTALMESSAGES,   COUNTER32, RONLY, bgpPeerTable,</a>
<a name="ln175">   3, {3, 1, 13}},</a>
<a name="ln176">  {BGPPEERLASTERROR,          OCTET_STRING, RONLY, bgpPeerTable,</a>
<a name="ln177">   3, {3, 1, 14}},</a>
<a name="ln178">  {BGPPEERFSMESTABLISHEDTRANSITIONS, COUNTER32, RONLY, bgpPeerTable,</a>
<a name="ln179">   3, {3, 1, 15}},</a>
<a name="ln180">  {BGPPEERFSMESTABLISHEDTIME, GAUGE32, RONLY, bgpPeerTable,</a>
<a name="ln181">   3, {3, 1, 16}},</a>
<a name="ln182">  {BGPPEERCONNECTRETRYINTERVAL, INTEGER, RWRITE, bgpPeerTable,</a>
<a name="ln183">   3, {3, 1, 17}},</a>
<a name="ln184">  {BGPPEERHOLDTIME,           INTEGER, RONLY, bgpPeerTable,</a>
<a name="ln185">   3, {3, 1, 18}},</a>
<a name="ln186">  {BGPPEERKEEPALIVE,          INTEGER, RONLY, bgpPeerTable,</a>
<a name="ln187">   3, {3, 1, 19}},</a>
<a name="ln188">  {BGPPEERHOLDTIMECONFIGURED, INTEGER, RWRITE, bgpPeerTable,</a>
<a name="ln189">   3, {3, 1, 20}},</a>
<a name="ln190">  {BGPPEERKEEPALIVECONFIGURED, INTEGER, RWRITE, bgpPeerTable,</a>
<a name="ln191">   3, {3, 1, 21}},</a>
<a name="ln192">  {BGPPEERMINROUTEADVERTISEMENTINTERVAL, INTEGER, RWRITE, bgpPeerTable,</a>
<a name="ln193">   3, {3, 1, 23}},</a>
<a name="ln194">  {BGPPEERINUPDATEELAPSEDTIME, GAUGE32, RONLY, bgpPeerTable,</a>
<a name="ln195">   3, {3, 1, 24}},</a>
<a name="ln196">  /* BGP identifier. */</a>
<a name="ln197">  {BGPIDENTIFIER,             IPADDRESS, RONLY, bgpIdentifier,</a>
<a name="ln198">   1, {4}},</a>
<a name="ln199">  /* BGP received path attribute table. */</a>
<a name="ln200">  {BGPPATHATTRPEER,           IPADDRESS, RONLY, bgpRcvdPathAttrTable,</a>
<a name="ln201">   3, {5, 1, 1}},</a>
<a name="ln202">  {BGPPATHATTRDESTNETWORK,    IPADDRESS, RONLY, bgpRcvdPathAttrTable,</a>
<a name="ln203">   3, {5, 1, 2}},</a>
<a name="ln204">  {BGPPATHATTRORIGIN,         INTEGER, RONLY, bgpRcvdPathAttrTable,</a>
<a name="ln205">   3, {5, 1, 3}},</a>
<a name="ln206">  {BGPPATHATTRASPATH,         OCTET_STRING, RONLY, bgpRcvdPathAttrTable,</a>
<a name="ln207">   3, {5, 1, 4}},</a>
<a name="ln208">  {BGPPATHATTRNEXTHOP,        IPADDRESS, RONLY, bgpRcvdPathAttrTable,</a>
<a name="ln209">   3, {5, 1, 5}},</a>
<a name="ln210">  {BGPPATHATTRINTERASMETRIC,  INTEGER32, RONLY, bgpRcvdPathAttrTable,</a>
<a name="ln211">   3, {5, 1, 6}},</a>
<a name="ln212">  /* BGP-4 received path attribute table. */</a>
<a name="ln213">  {BGP4PATHATTRPEER, IPADDRESS, RONLY, bgp4PathAttrTable,</a>
<a name="ln214">   3, {6, 1, 1}},</a>
<a name="ln215">  {BGP4PATHATTRIPADDRPREFIXLEN, INTEGER, RONLY, bgp4PathAttrTable,</a>
<a name="ln216">   3, {6, 1, 2}},</a>
<a name="ln217">  {BGP4PATHATTRIPADDRPREFIX,  IPADDRESS, RONLY, bgp4PathAttrTable,</a>
<a name="ln218">   3, {6, 1, 3}},</a>
<a name="ln219">  {BGP4PATHATTRORIGIN,        INTEGER, RONLY, bgp4PathAttrTable,</a>
<a name="ln220">   3, {6, 1, 4}},</a>
<a name="ln221">  {BGP4PATHATTRASPATHSEGMENT, OCTET_STRING, RONLY, bgp4PathAttrTable,</a>
<a name="ln222">   3, {6, 1, 5}},</a>
<a name="ln223">  {BGP4PATHATTRNEXTHOP,       IPADDRESS, RONLY, bgp4PathAttrTable,</a>
<a name="ln224">   3, {6, 1, 6}},</a>
<a name="ln225">  {BGP4PATHATTRMULTIEXITDISC, INTEGER, RONLY, bgp4PathAttrTable,</a>
<a name="ln226">   3, {6, 1, 7}},</a>
<a name="ln227">  {BGP4PATHATTRLOCALPREF,     INTEGER, RONLY, bgp4PathAttrTable,</a>
<a name="ln228">   3, {6, 1, 8}},</a>
<a name="ln229">  {BGP4PATHATTRATOMICAGGREGATE, INTEGER, RONLY, bgp4PathAttrTable,</a>
<a name="ln230">   3, {6, 1, 9}},</a>
<a name="ln231">  {BGP4PATHATTRAGGREGATORAS,  INTEGER, RONLY, bgp4PathAttrTable,</a>
<a name="ln232">   3, {6, 1, 10}},</a>
<a name="ln233">  {BGP4PATHATTRAGGREGATORADDR, IPADDRESS, RONLY, bgp4PathAttrTable,</a>
<a name="ln234">   3, {6, 1, 11}},</a>
<a name="ln235">  {BGP4PATHATTRCALCLOCALPREF, INTEGER, RONLY, bgp4PathAttrTable,</a>
<a name="ln236">   3, {6, 1, 12}},</a>
<a name="ln237">  {BGP4PATHATTRBEST,          INTEGER, RONLY, bgp4PathAttrTable,</a>
<a name="ln238">   3, {6, 1, 13}},</a>
<a name="ln239">  {BGP4PATHATTRUNKNOWN,       OCTET_STRING, RONLY, bgp4PathAttrTable,</a>
<a name="ln240">   3, {6, 1, 14}},</a>
<a name="ln241">};</a>
<a name="ln242"> </a>
<a name="ln243"> </a>
<a name="ln244">static u_char *</a>
<a name="ln245">bgpVersion (struct variable *v, oid name[], size_t *length, int exact,</a>
<a name="ln246">	    size_t *var_len, WriteMethod **write_method)</a>
<a name="ln247">{</a>
<a name="ln248">  static u_char version;</a>
<a name="ln249"> </a>
<a name="ln250">  if (smux_header_generic(v, name, length, exact, var_len, write_method)</a>
<a name="ln251">      == MATCH_FAILED)</a>
<a name="ln252">    return NULL;</a>
<a name="ln253"> </a>
<a name="ln254">  /* Retrun BGP version.  Zebra bgpd only support version 4. */</a>
<a name="ln255">  version = (0x80 &gt;&gt; (BGP_VERSION_4 - 1));</a>
<a name="ln256"> </a>
<a name="ln257">  /* Return octet string length 1. */</a>
<a name="ln258">  *var_len = 1;</a>
<a name="ln259">  return (u_char *)&amp;version;</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">static u_char *</a>
<a name="ln263">bgpLocalAs (struct variable *v, oid name[], size_t *length,</a>
<a name="ln264">	    int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln265">{</a>
<a name="ln266">  struct bgp *bgp;</a>
<a name="ln267"> </a>
<a name="ln268">  if (smux_header_generic(v, name, length, exact, var_len, write_method)</a>
<a name="ln269">      == MATCH_FAILED)</a>
<a name="ln270">    return NULL;</a>
<a name="ln271"> </a>
<a name="ln272">  /* Get BGP structure. */</a>
<a name="ln273">  bgp = bgp_get_default ();</a>
<a name="ln274">  if (! bgp)</a>
<a name="ln275">    return NULL;</a>
<a name="ln276"> </a>
<a name="ln277">  return SNMP_INTEGER (bgp-&gt;as);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">static struct peer *</a>
<a name="ln281">peer_lookup_addr_ipv4 (struct in_addr *src)</a>
<a name="ln282">{</a>
<a name="ln283">  struct bgp *bgp;</a>
<a name="ln284">  struct peer *peer;</a>
<a name="ln285">  struct listnode *node;</a>
<a name="ln286">  struct in_addr addr;</a>
<a name="ln287">  int ret;</a>
<a name="ln288"> </a>
<a name="ln289">  bgp = bgp_get_default ();</a>
<a name="ln290">  if (! bgp)</a>
<a name="ln291">    return NULL;</a>
<a name="ln292"> </a>
<a name="ln293">  for (ALL_LIST_ELEMENTS_RO (bgp-&gt;peer, node, peer))</a>
<a name="ln294">    {</a>
<a name="ln295">      ret = inet_pton (AF_INET, peer-&gt;host, &amp;addr);</a>
<a name="ln296">      if (ret &gt; 0)</a>
<a name="ln297">	{</a>
<a name="ln298">	  if (IPV4_ADDR_SAME (&amp;addr, src))</a>
<a name="ln299">	    return peer;</a>
<a name="ln300">	}</a>
<a name="ln301">    }</a>
<a name="ln302">  return NULL;</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">static struct peer *</a>
<a name="ln306">bgp_peer_lookup_next (struct in_addr *src)</a>
<a name="ln307">{</a>
<a name="ln308">  struct bgp *bgp;</a>
<a name="ln309">  struct peer *peer;</a>
<a name="ln310">  struct listnode *node;</a>
<a name="ln311">  struct in_addr *p;</a>
<a name="ln312">  union sockunion su;</a>
<a name="ln313">  int ret;</a>
<a name="ln314"> </a>
<a name="ln315">  memset (&amp;su, 0, sizeof (union sockunion));</a>
<a name="ln316"> </a>
<a name="ln317">  bgp = bgp_get_default ();</a>
<a name="ln318">  if (! bgp)</a>
<a name="ln319">    return NULL;</a>
<a name="ln320"> </a>
<a name="ln321">  for (ALL_LIST_ELEMENTS_RO (bgp-&gt;peer, node, peer))</a>
<a name="ln322">    {</a>
<a name="ln323">      ret = inet_pton (AF_INET, peer-&gt;host, &amp;su.sin.sin_addr);</a>
<a name="ln324">      if (ret &gt; 0)</a>
<a name="ln325">	{</a>
<a name="ln326">	  p = &amp;su.sin.sin_addr;</a>
<a name="ln327"> </a>
<a name="ln328">	  if (ntohl (p-&gt;s_addr) &gt; ntohl (src-&gt;s_addr))</a>
<a name="ln329">	    {</a>
<a name="ln330">	      src-&gt;s_addr = p-&gt;s_addr;</a>
<a name="ln331">	      return peer;</a>
<a name="ln332">	    }</a>
<a name="ln333">	}</a>
<a name="ln334">    }</a>
<a name="ln335">  return NULL;</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">/* 1.3.6.1.2.1.15.3.1.x  = 10 */</a>
<a name="ln339">#define PEERTAB_NAMELEN 10</a>
<a name="ln340"> </a>
<a name="ln341">static struct peer *</a>
<a name="ln342">bgpPeerTable_lookup (struct variable *v, oid name[], size_t *length, </a>
<a name="ln343">		     struct in_addr *addr, int exact)</a>
<a name="ln344">{</a>
<a name="ln345">  struct peer *peer = NULL;</a>
<a name="ln346">  size_t namelen = v ? v-&gt;namelen : PEERTAB_NAMELEN;</a>
<a name="ln347">  int len;</a>
<a name="ln348"> </a>
<a name="ln349">  if (exact)</a>
<a name="ln350">    {</a>
<a name="ln351">      /* Check the length. */</a>
<a name="ln352">      if (*length - namelen != sizeof (struct in_addr))</a>
<a name="ln353">	return NULL;</a>
<a name="ln354"> </a>
<a name="ln355">      oid2in_addr (name + namelen, IN_ADDR_SIZE, addr);</a>
<a name="ln356"> </a>
<a name="ln357">      peer = peer_lookup_addr_ipv4 (addr);</a>
<a name="ln358">      return peer;</a>
<a name="ln359">    }</a>
<a name="ln360">  else</a>
<a name="ln361">    {</a>
<a name="ln362">      len = *length - namelen;</a>
<a name="ln363">      if (len &gt; 4) len = 4;</a>
<a name="ln364">      </a>
<a name="ln365">      oid2in_addr (name + namelen, len, addr);</a>
<a name="ln366">      </a>
<a name="ln367">      peer = bgp_peer_lookup_next (addr);</a>
<a name="ln368"> </a>
<a name="ln369">      if (peer == NULL)</a>
<a name="ln370">	return NULL;</a>
<a name="ln371"> </a>
<a name="ln372">      oid_copy_addr (name + namelen, addr, sizeof (struct in_addr));</a>
<a name="ln373">      *length = sizeof (struct in_addr) + namelen;</a>
<a name="ln374"> </a>
<a name="ln375">      return peer;</a>
<a name="ln376">    }</a>
<a name="ln377">  return NULL;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">/* BGP write methods. */</a>
<a name="ln381">static int</a>
<a name="ln382">write_bgpPeerTable (int action, u_char *var_val,</a>
<a name="ln383">		    u_char var_val_type, size_t var_val_len,</a>
<a name="ln384">		    u_char *statP, oid *name, size_t length)</a>
<a name="ln385">{</a>
<a name="ln386">  struct in_addr addr;</a>
<a name="ln387">  struct peer *peer;</a>
<a name="ln388">  long intval;</a>
<a name="ln389"> </a>
<a name="ln390">  if (var_val_type != ASN_INTEGER) </a>
<a name="ln391">    {</a>
<a name="ln392">      return SNMP_ERR_WRONGTYPE;</a>
<a name="ln393">    }</a>
<a name="ln394">  if (var_val_len != sizeof (long)) </a>
<a name="ln395">    {</a>
<a name="ln396">      return SNMP_ERR_WRONGLENGTH;</a>
<a name="ln397">    }</a>
<a name="ln398"> </a>
<a name="ln399">  intval = *(long *)var_val;</a>
<a name="ln400"> </a>
<a name="ln401">  memset (&amp;addr, 0, sizeof (struct in_addr));</a>
<a name="ln402"> </a>
<a name="ln403">  peer = bgpPeerTable_lookup (NULL, name, &amp;length, &amp;addr, 1);</a>
<a name="ln404">  if (! peer)</a>
<a name="ln405">    return SNMP_ERR_NOSUCHNAME;</a>
<a name="ln406"> </a>
<a name="ln407">  if (action != SNMP_MSG_INTERNAL_SET_COMMIT)</a>
<a name="ln408">    return SNMP_ERR_NOERROR;</a>
<a name="ln409"> </a>
<a name="ln410">  zlog_info (&quot;%s: SNMP write .%ld = %ld&quot;,</a>
<a name="ln411">             peer-&gt;host, (long)name[PEERTAB_NAMELEN - 1], intval);</a>
<a name="ln412"> </a>
<a name="ln413">  switch (name[PEERTAB_NAMELEN - 1])</a>
<a name="ln414">    {</a>
<a name="ln415">    case BGPPEERADMINSTATUS:</a>
<a name="ln416">#define BGP_PeerAdmin_stop  1</a>
<a name="ln417">#define BGP_PeerAdmin_start 2</a>
<a name="ln418">      /* When the peer is established,   */</a>
<a name="ln419">      if (intval == BGP_PeerAdmin_stop)</a>
<a name="ln420">	BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln421">      else if (intval == BGP_PeerAdmin_start)</a>
<a name="ln422">	;			/* Do nothing. */</a>
<a name="ln423">      else</a>
<a name="ln424">	return SNMP_ERR_NOSUCHNAME;</a>
<a name="ln425">      break;</a>
<a name="ln426">    case BGPPEERCONNECTRETRYINTERVAL:</a>
<a name="ln427">      SET_FLAG (peer-&gt;config, PEER_CONFIG_CONNECT);</a>
<a name="ln428">      peer-&gt;connect = intval;</a>
<a name="ln429">      peer-&gt;v_connect = intval;</a>
<a name="ln430">      break;</a>
<a name="ln431">    case BGPPEERHOLDTIMECONFIGURED:</a>
<a name="ln432">      SET_FLAG (peer-&gt;config, PEER_CONFIG_TIMER);</a>
<a name="ln433">      peer-&gt;holdtime = intval;</a>
<a name="ln434">      peer-&gt;v_holdtime = intval;</a>
<a name="ln435">      break;</a>
<a name="ln436">    case BGPPEERKEEPALIVECONFIGURED:</a>
<a name="ln437">      SET_FLAG (peer-&gt;config, PEER_CONFIG_TIMER);</a>
<a name="ln438">      peer-&gt;keepalive = intval;</a>
<a name="ln439">      peer-&gt;v_keepalive = intval;</a>
<a name="ln440">      break;</a>
<a name="ln441">    case BGPPEERMINROUTEADVERTISEMENTINTERVAL:</a>
<a name="ln442">      peer-&gt;v_routeadv = intval;</a>
<a name="ln443">      break;</a>
<a name="ln444">    }</a>
<a name="ln445">  return SNMP_ERR_NOERROR;</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">static u_char *</a>
<a name="ln449">bgpPeerTable (struct variable *v, oid name[], size_t *length,</a>
<a name="ln450">	      int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln451">{</a>
<a name="ln452">  static struct in_addr addr;</a>
<a name="ln453">  struct peer *peer;</a>
<a name="ln454"> </a>
<a name="ln455">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln456">      == MATCH_FAILED)</a>
<a name="ln457">    return NULL;</a>
<a name="ln458">  memset (&amp;addr, 0, sizeof (struct in_addr));</a>
<a name="ln459"> </a>
<a name="ln460">  peer = bgpPeerTable_lookup (v, name, length, &amp;addr, exact);</a>
<a name="ln461">  if (! peer)</a>
<a name="ln462">    return NULL;</a>
<a name="ln463"> </a>
<a name="ln464">  switch (v-&gt;magic)</a>
<a name="ln465">    {</a>
<a name="ln466">    case BGPPEERIDENTIFIER:</a>
<a name="ln467">      return SNMP_IPADDRESS (peer-&gt;remote_id);</a>
<a name="ln468">      break;</a>
<a name="ln469">    case BGPPEERSTATE:</a>
<a name="ln470">      return SNMP_INTEGER (peer-&gt;status);</a>
<a name="ln471">      break;</a>
<a name="ln472">    case BGPPEERADMINSTATUS:</a>
<a name="ln473">      *write_method = write_bgpPeerTable;</a>
<a name="ln474">#define BGP_PeerAdmin_stop  1</a>
<a name="ln475">#define BGP_PeerAdmin_start 2</a>
<a name="ln476">      if (CHECK_FLAG (peer-&gt;flags, PEER_FLAG_SHUTDOWN))</a>
<a name="ln477">	return SNMP_INTEGER (BGP_PeerAdmin_stop);</a>
<a name="ln478">      else</a>
<a name="ln479">	return SNMP_INTEGER (BGP_PeerAdmin_start);</a>
<a name="ln480">      break;</a>
<a name="ln481">    case BGPPEERNEGOTIATEDVERSION:</a>
<a name="ln482">      return SNMP_INTEGER (BGP_VERSION_4);</a>
<a name="ln483">      break;</a>
<a name="ln484">    case BGPPEERLOCALADDR:</a>
<a name="ln485">      if (peer-&gt;su_local)</a>
<a name="ln486">	return SNMP_IPADDRESS (peer-&gt;su_local-&gt;sin.sin_addr);</a>
<a name="ln487">      else</a>
<a name="ln488">	return SNMP_IPADDRESS (bgp_empty_addr);</a>
<a name="ln489">      break;</a>
<a name="ln490">    case BGPPEERLOCALPORT:</a>
<a name="ln491">      if (peer-&gt;su_local)</a>
<a name="ln492">	return SNMP_INTEGER (ntohs (peer-&gt;su_local-&gt;sin.sin_port));</a>
<a name="ln493">      else</a>
<a name="ln494">	return SNMP_INTEGER (0);</a>
<a name="ln495">      break;</a>
<a name="ln496">    case BGPPEERREMOTEADDR:</a>
<a name="ln497">      if (peer-&gt;su_remote)</a>
<a name="ln498">	return SNMP_IPADDRESS (peer-&gt;su_remote-&gt;sin.sin_addr);</a>
<a name="ln499">      else</a>
<a name="ln500">	return SNMP_IPADDRESS (bgp_empty_addr);</a>
<a name="ln501">      break;</a>
<a name="ln502">    case BGPPEERREMOTEPORT:</a>
<a name="ln503">      if (peer-&gt;su_remote)</a>
<a name="ln504">	return SNMP_INTEGER (ntohs (peer-&gt;su_remote-&gt;sin.sin_port));</a>
<a name="ln505">      else</a>
<a name="ln506">	return SNMP_INTEGER (0);</a>
<a name="ln507">      break;</a>
<a name="ln508">    case BGPPEERREMOTEAS:</a>
<a name="ln509">      return SNMP_INTEGER (peer-&gt;as);</a>
<a name="ln510">      break;</a>
<a name="ln511">    case BGPPEERINUPDATES:</a>
<a name="ln512">      return SNMP_INTEGER (peer-&gt;update_in);</a>
<a name="ln513">      break;</a>
<a name="ln514">    case BGPPEEROUTUPDATES:</a>
<a name="ln515">      return SNMP_INTEGER (peer-&gt;update_out);</a>
<a name="ln516">      break;</a>
<a name="ln517">    case BGPPEERINTOTALMESSAGES:</a>
<a name="ln518">      return SNMP_INTEGER (peer-&gt;open_in + peer-&gt;update_in</a>
<a name="ln519">			   + peer-&gt;keepalive_in + peer-&gt;notify_in</a>
<a name="ln520">			   + peer-&gt;refresh_in + peer-&gt;dynamic_cap_in);</a>
<a name="ln521">      break;</a>
<a name="ln522">    case BGPPEEROUTTOTALMESSAGES:</a>
<a name="ln523">      return SNMP_INTEGER (peer-&gt;open_out + peer-&gt;update_out</a>
<a name="ln524">			   + peer-&gt;keepalive_out + peer-&gt;notify_out</a>
<a name="ln525">			   + peer-&gt;refresh_out + peer-&gt;dynamic_cap_out);</a>
<a name="ln526">      break;</a>
<a name="ln527">    case BGPPEERLASTERROR:</a>
<a name="ln528">      {</a>
<a name="ln529">	static u_char lasterror[2];</a>
<a name="ln530">	lasterror[0] = peer-&gt;notify.code;</a>
<a name="ln531">	lasterror[1] = peer-&gt;notify.subcode;</a>
<a name="ln532">	*var_len = 2;</a>
<a name="ln533">	return (u_char *)&amp;lasterror;</a>
<a name="ln534">      }</a>
<a name="ln535">      break;</a>
<a name="ln536">    case BGPPEERFSMESTABLISHEDTRANSITIONS:</a>
<a name="ln537">      return SNMP_INTEGER (peer-&gt;established);</a>
<a name="ln538">      break;</a>
<a name="ln539">    case BGPPEERFSMESTABLISHEDTIME:</a>
<a name="ln540">      if (peer-&gt;uptime == 0)</a>
<a name="ln541">	return SNMP_INTEGER (0);</a>
<a name="ln542">      else</a>
<a name="ln543">	return SNMP_INTEGER (bgp_clock () - peer-&gt;uptime);</a>
<a name="ln544">      break;</a>
<a name="ln545">    case BGPPEERCONNECTRETRYINTERVAL:</a>
<a name="ln546">      *write_method = write_bgpPeerTable;</a>
<a name="ln547">      return SNMP_INTEGER (peer-&gt;v_connect);</a>
<a name="ln548">      break;</a>
<a name="ln549">    case BGPPEERHOLDTIME:</a>
<a name="ln550">      return SNMP_INTEGER (peer-&gt;v_holdtime);</a>
<a name="ln551">      break;</a>
<a name="ln552">    case BGPPEERKEEPALIVE:</a>
<a name="ln553">      return SNMP_INTEGER (peer-&gt;v_keepalive);</a>
<a name="ln554">      break;</a>
<a name="ln555">    case BGPPEERHOLDTIMECONFIGURED:</a>
<a name="ln556">      *write_method = write_bgpPeerTable;</a>
<a name="ln557">      if (CHECK_FLAG (peer-&gt;config, PEER_CONFIG_TIMER))</a>
<a name="ln558">	return SNMP_INTEGER (peer-&gt;holdtime);</a>
<a name="ln559">      else</a>
<a name="ln560">	return SNMP_INTEGER (peer-&gt;v_holdtime);</a>
<a name="ln561">      break;</a>
<a name="ln562">    case BGPPEERKEEPALIVECONFIGURED:</a>
<a name="ln563">      *write_method = write_bgpPeerTable;</a>
<a name="ln564">      if (CHECK_FLAG (peer-&gt;config, PEER_CONFIG_TIMER))</a>
<a name="ln565">	return SNMP_INTEGER (peer-&gt;keepalive);</a>
<a name="ln566">      else</a>
<a name="ln567">	return SNMP_INTEGER (peer-&gt;v_keepalive);</a>
<a name="ln568">      break;</a>
<a name="ln569">    case BGPPEERMINROUTEADVERTISEMENTINTERVAL:</a>
<a name="ln570">      *write_method = write_bgpPeerTable;</a>
<a name="ln571">      return SNMP_INTEGER (peer-&gt;v_routeadv);</a>
<a name="ln572">      break;</a>
<a name="ln573">    case BGPPEERINUPDATEELAPSEDTIME:</a>
<a name="ln574">      if (peer-&gt;update_time == 0)</a>
<a name="ln575">	return SNMP_INTEGER (0);</a>
<a name="ln576">      else</a>
<a name="ln577">	return SNMP_INTEGER (bgp_clock () - peer-&gt;update_time);</a>
<a name="ln578">      break;</a>
<a name="ln579">    default:</a>
<a name="ln580">      return NULL;</a>
<a name="ln581">      break;</a>
<a name="ln582">    }  </a>
<a name="ln583">  return NULL;</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">static u_char *</a>
<a name="ln587">bgpIdentifier (struct variable *v, oid name[], size_t *length,</a>
<a name="ln588">	       int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln589">{</a>
<a name="ln590">  struct bgp *bgp;</a>
<a name="ln591"> </a>
<a name="ln592">  if (smux_header_generic(v, name, length, exact, var_len, write_method)</a>
<a name="ln593">      == MATCH_FAILED)</a>
<a name="ln594">    return NULL;</a>
<a name="ln595"> </a>
<a name="ln596">  bgp = bgp_get_default ();</a>
<a name="ln597">  if (!bgp)</a>
<a name="ln598">    return NULL;</a>
<a name="ln599"> </a>
<a name="ln600">  return SNMP_IPADDRESS (bgp-&gt;router_id);</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">static u_char *</a>
<a name="ln604">bgpRcvdPathAttrTable (struct variable *v, oid name[], size_t *length,</a>
<a name="ln605">		      int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln606">{</a>
<a name="ln607">  /* Received Path Attribute Table.  This table contains, one entry</a>
<a name="ln608">     per path to a network, path attributes received from all peers</a>
<a name="ln609">     running BGP version 3 or less.  This table is obsolete, having</a>
<a name="ln610">     been replaced in functionality with the bgp4PathAttrTable.  */</a>
<a name="ln611">  return NULL;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">static struct bgp_info *</a>
<a name="ln615">bgp4PathAttrLookup (struct variable *v, oid name[], size_t *length,</a>
<a name="ln616">		    struct bgp *bgp, struct prefix_ipv4 *addr, int exact)</a>
<a name="ln617">{</a>
<a name="ln618">  oid *offset;</a>
<a name="ln619">  int offsetlen;</a>
<a name="ln620">  struct bgp_info *binfo;</a>
<a name="ln621">  struct bgp_info *min;</a>
<a name="ln622">  struct bgp_node *rn;</a>
<a name="ln623">  union sockunion su;</a>
<a name="ln624">  unsigned int len;</a>
<a name="ln625">  struct in_addr paddr;</a>
<a name="ln626"> </a>
<a name="ln627">#define BGP_PATHATTR_ENTRY_OFFSET \</a>
<a name="ln628">          (IN_ADDR_SIZE + 1 + IN_ADDR_SIZE)</a>
<a name="ln629"> </a>
<a name="ln630">  if (exact)</a>
<a name="ln631">    {</a>
<a name="ln632">      if (*length - v-&gt;namelen != BGP_PATHATTR_ENTRY_OFFSET)</a>
<a name="ln633">	return NULL;</a>
<a name="ln634"> </a>
<a name="ln635">      /* Set OID offset for prefix. */</a>
<a name="ln636">      offset = name + v-&gt;namelen;</a>
<a name="ln637">      oid2in_addr (offset, IN_ADDR_SIZE, &amp;addr-&gt;prefix);</a>
<a name="ln638">      offset += IN_ADDR_SIZE;</a>
<a name="ln639"> </a>
<a name="ln640">      /* Prefix length. */</a>
<a name="ln641">      addr-&gt;prefixlen = *offset;</a>
<a name="ln642">      offset++;</a>
<a name="ln643"> </a>
<a name="ln644">      /* Peer address. */</a>
<a name="ln645">      su.sin.sin_family = AF_INET;</a>
<a name="ln646">      oid2in_addr (offset, IN_ADDR_SIZE, &amp;su.sin.sin_addr);</a>
<a name="ln647"> </a>
<a name="ln648">      /* Lookup node. */</a>
<a name="ln649">      rn = bgp_node_lookup (bgp-&gt;rib[AFI_IP][SAFI_UNICAST], </a>
<a name="ln650">			      (struct prefix *) addr);</a>
<a name="ln651">      if (rn)</a>
<a name="ln652">	{</a>
<a name="ln653">	  bgp_unlock_node (rn);</a>
<a name="ln654"> </a>
<a name="ln655">	  for (binfo = rn-&gt;info; binfo; binfo = binfo-&gt;next)</a>
<a name="ln656">	    if (sockunion_same (&amp;binfo-&gt;peer-&gt;su, &amp;su))</a>
<a name="ln657">	      return binfo;</a>
<a name="ln658">	}</a>
<a name="ln659">    }</a>
<a name="ln660">  else</a>
<a name="ln661">    {</a>
<a name="ln662">      offset = name + v-&gt;namelen;</a>
<a name="ln663">      offsetlen = *length - v-&gt;namelen;</a>
<a name="ln664">      len = offsetlen;</a>
<a name="ln665"> </a>
<a name="ln666">      if (offsetlen == 0)</a>
<a name="ln667">	rn = bgp_table_top (bgp-&gt;rib[AFI_IP][SAFI_UNICAST]);</a>
<a name="ln668">      else</a>
<a name="ln669">	{</a>
<a name="ln670">	  if (len &gt; IN_ADDR_SIZE)</a>
<a name="ln671">	    len = IN_ADDR_SIZE;</a>
<a name="ln672">      </a>
<a name="ln673">	  oid2in_addr (offset, len, &amp;addr-&gt;prefix);</a>
<a name="ln674"> </a>
<a name="ln675">	  offset += IN_ADDR_SIZE;</a>
<a name="ln676">	  offsetlen -= IN_ADDR_SIZE;</a>
<a name="ln677"> </a>
<a name="ln678">	  if (offsetlen &gt; 0)</a>
<a name="ln679">	    addr-&gt;prefixlen = *offset;</a>
<a name="ln680">	  else</a>
<a name="ln681">	    addr-&gt;prefixlen = len * 8;</a>
<a name="ln682"> </a>
<a name="ln683">	  rn = bgp_node_get (bgp-&gt;rib[AFI_IP][SAFI_UNICAST],</a>
<a name="ln684">			       (struct prefix *) addr);</a>
<a name="ln685"> </a>
<a name="ln686">	  offset++;</a>
<a name="ln687">	  offsetlen--;</a>
<a name="ln688">	}</a>
<a name="ln689"> </a>
<a name="ln690">      if (offsetlen &gt; 0)</a>
<a name="ln691">	{</a>
<a name="ln692">	  len = offsetlen;</a>
<a name="ln693">	  if (len &gt; IN_ADDR_SIZE)</a>
<a name="ln694">	    len = IN_ADDR_SIZE;</a>
<a name="ln695"> </a>
<a name="ln696">	  oid2in_addr (offset, len, &amp;paddr);</a>
<a name="ln697">	}</a>
<a name="ln698">      else</a>
<a name="ln699">	paddr.s_addr = 0;</a>
<a name="ln700"> </a>
<a name="ln701">      if (! rn)</a>
<a name="ln702">	return NULL;</a>
<a name="ln703"> </a>
<a name="ln704">      do</a>
<a name="ln705">	{</a>
<a name="ln706">	  min = NULL;</a>
<a name="ln707"> </a>
<a name="ln708">	  for (binfo = rn-&gt;info; binfo; binfo = binfo-&gt;next)</a>
<a name="ln709">	    {</a>
<a name="ln710">	      if (binfo-&gt;peer-&gt;su.sin.sin_family == AF_INET</a>
<a name="ln711">		  &amp;&amp; ntohl (paddr.s_addr) </a>
<a name="ln712">		  &lt; ntohl (binfo-&gt;peer-&gt;su.sin.sin_addr.s_addr))</a>
<a name="ln713">		{</a>
<a name="ln714">		  if (min)</a>
<a name="ln715">		    {</a>
<a name="ln716">		      if (ntohl (binfo-&gt;peer-&gt;su.sin.sin_addr.s_addr) </a>
<a name="ln717">			  &lt; ntohl (min-&gt;peer-&gt;su.sin.sin_addr.s_addr))</a>
<a name="ln718">			min = binfo;</a>
<a name="ln719">		    }</a>
<a name="ln720">		  else</a>
<a name="ln721">		    min = binfo;</a>
<a name="ln722">		}</a>
<a name="ln723">	    }</a>
<a name="ln724"> </a>
<a name="ln725">	  if (min)</a>
<a name="ln726">	    {</a>
<a name="ln727">	      *length = v-&gt;namelen + BGP_PATHATTR_ENTRY_OFFSET;</a>
<a name="ln728"> </a>
<a name="ln729">	      offset = name + v-&gt;namelen;</a>
<a name="ln730">	      oid_copy_addr (offset, &amp;rn-&gt;p.u.prefix4, IN_ADDR_SIZE);</a>
<a name="ln731">	      offset += IN_ADDR_SIZE;</a>
<a name="ln732">	      *offset = rn-&gt;p.prefixlen;</a>
<a name="ln733">	      offset++;</a>
<a name="ln734">	      oid_copy_addr (offset, &amp;min-&gt;peer-&gt;su.sin.sin_addr, </a>
<a name="ln735">			     IN_ADDR_SIZE);</a>
<a name="ln736">	      addr-&gt;prefix = rn-&gt;p.u.prefix4;</a>
<a name="ln737">	      addr-&gt;prefixlen = rn-&gt;p.prefixlen;</a>
<a name="ln738"> </a>
<a name="ln739">	      bgp_unlock_node (rn);</a>
<a name="ln740"> </a>
<a name="ln741">	      return min;</a>
<a name="ln742">	    }</a>
<a name="ln743"> </a>
<a name="ln744">	  paddr.s_addr = 0;</a>
<a name="ln745">	}</a>
<a name="ln746">      while ((rn = bgp_route_next (rn)) != NULL);</a>
<a name="ln747">    }</a>
<a name="ln748">  return NULL;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">static u_char *</a>
<a name="ln752">bgp4PathAttrTable (struct variable *v, oid name[], size_t *length,</a>
<a name="ln753">		   int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln754">{</a>
<a name="ln755">  struct bgp *bgp;</a>
<a name="ln756">  struct bgp_info *binfo;</a>
<a name="ln757">  struct prefix_ipv4 addr;</a>
<a name="ln758">  </a>
<a name="ln759">  bgp = bgp_get_default ();</a>
<a name="ln760">  if (! bgp)</a>
<a name="ln761">    return NULL;</a>
<a name="ln762"> </a>
<a name="ln763">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln764">      == MATCH_FAILED)</a>
<a name="ln765">    return NULL;</a>
<a name="ln766">  memset (&amp;addr, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln767"> </a>
<a name="ln768">  binfo = bgp4PathAttrLookup (v, name, length, bgp, &amp;addr, exact);</a>
<a name="ln769">  if (! binfo)</a>
<a name="ln770">    return NULL;</a>
<a name="ln771"> </a>
<a name="ln772">  switch (v-&gt;magic)</a>
<a name="ln773">    {</a>
<a name="ln774">    case BGP4PATHATTRPEER:	/* 1 */</a>
<a name="ln775">      return SNMP_IPADDRESS (binfo-&gt;peer-&gt;su.sin.sin_addr);</a>
<a name="ln776">      break;</a>
<a name="ln777">    case BGP4PATHATTRIPADDRPREFIXLEN: /* 2 */</a>
<a name="ln778">      return SNMP_INTEGER (addr.prefixlen);</a>
<a name="ln779">      break;</a>
<a name="ln780">    case BGP4PATHATTRIPADDRPREFIX: /* 3 */</a>
<a name="ln781">      return SNMP_IPADDRESS (addr.prefix);</a>
<a name="ln782">      break;</a>
<a name="ln783">    case BGP4PATHATTRORIGIN:	/* 4 */</a>
<a name="ln784">      return SNMP_INTEGER (binfo-&gt;attr-&gt;origin);</a>
<a name="ln785">      break;</a>
<a name="ln786">    case BGP4PATHATTRASPATHSEGMENT: /* 5 */</a>
<a name="ln787">      return aspath_snmp_pathseg (binfo-&gt;attr-&gt;aspath, var_len);</a>
<a name="ln788">      break;</a>
<a name="ln789">    case BGP4PATHATTRNEXTHOP:	/* 6 */</a>
<a name="ln790">      return SNMP_IPADDRESS (binfo-&gt;attr-&gt;nexthop);</a>
<a name="ln791">      break;</a>
<a name="ln792">    case BGP4PATHATTRMULTIEXITDISC: /* 7 */</a>
<a name="ln793">      return SNMP_INTEGER (binfo-&gt;attr-&gt;med);</a>
<a name="ln794">      break;</a>
<a name="ln795">    case BGP4PATHATTRLOCALPREF:	/* 8 */</a>
<a name="ln796">      return SNMP_INTEGER (binfo-&gt;attr-&gt;local_pref);</a>
<a name="ln797">      break;</a>
<a name="ln798">    case BGP4PATHATTRATOMICAGGREGATE: /* 9 */</a>
<a name="ln799">      return SNMP_INTEGER (1);</a>
<a name="ln800">      break;</a>
<a name="ln801">    case BGP4PATHATTRAGGREGATORAS: /* 10 */</a>
<a name="ln802">      if (binfo-&gt;attr-&gt;extra)</a>
<a name="ln803">        return SNMP_INTEGER (binfo-&gt;attr-&gt;extra-&gt;aggregator_as);</a>
<a name="ln804">      else</a>
<a name="ln805">        return SNMP_INTEGER (0);</a>
<a name="ln806">      break;</a>
<a name="ln807">    case BGP4PATHATTRAGGREGATORADDR: /* 11 */</a>
<a name="ln808">      if (binfo-&gt;attr-&gt;extra)</a>
<a name="ln809">        return SNMP_IPADDRESS (binfo-&gt;attr-&gt;extra-&gt;aggregator_addr);</a>
<a name="ln810">      else</a>
<a name="ln811">        return SNMP_INTEGER (0);</a>
<a name="ln812">      break;</a>
<a name="ln813">    case BGP4PATHATTRCALCLOCALPREF: /* 12 */</a>
<a name="ln814">      return SNMP_INTEGER (-1);</a>
<a name="ln815">      break;</a>
<a name="ln816">    case BGP4PATHATTRBEST:	/* 13 */</a>
<a name="ln817">#define BGP4_PathAttrBest_false 1</a>
<a name="ln818">#define BGP4_PathAttrBest_true  2</a>
<a name="ln819">      if (CHECK_FLAG (binfo-&gt;flags, BGP_INFO_SELECTED))</a>
<a name="ln820">	return SNMP_INTEGER (BGP4_PathAttrBest_true);</a>
<a name="ln821">      else</a>
<a name="ln822">	return SNMP_INTEGER (BGP4_PathAttrBest_false);</a>
<a name="ln823">      break;</a>
<a name="ln824">    case BGP4PATHATTRUNKNOWN:	/* 14 */</a>
<a name="ln825">      *var_len = 0;</a>
<a name="ln826">      return NULL;</a>
<a name="ln827">      break;</a>
<a name="ln828">    }</a>
<a name="ln829">  return NULL;</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">/* BGP Traps. */</a>
<a name="ln833">struct trap_object bgpTrapList[] =</a>
<a name="ln834">{</a>
<a name="ln835">  {3, {3, 1, BGPPEERLASTERROR}},</a>
<a name="ln836">  {3, {3, 1, BGPPEERSTATE}}</a>
<a name="ln837">};</a>
<a name="ln838"> </a>
<a name="ln839">void</a>
<a name="ln840">bgpTrapEstablished (struct peer *peer)</a>
<a name="ln841">{</a>
<a name="ln842">  int ret;</a>
<a name="ln843">  struct in_addr addr;</a>
<a name="ln844">  oid index[sizeof (oid) * IN_ADDR_SIZE];</a>
<a name="ln845"> </a>
<a name="ln846">  ret = inet_aton (peer-&gt;host, &amp;addr);</a>
<a name="ln847">  if (ret == 0)</a>
<a name="ln848">    return;</a>
<a name="ln849"> </a>
<a name="ln850">  oid_copy_addr (index, &amp;addr, IN_ADDR_SIZE);</a>
<a name="ln851"> </a>
<a name="ln852">  smux_trap (bgp_variables, sizeof bgp_variables / sizeof (struct variable),</a>
<a name="ln853">	     bgp_trap_oid, sizeof bgp_trap_oid / sizeof (oid),</a>
<a name="ln854">	     bgp_oid, sizeof bgp_oid / sizeof (oid),</a>
<a name="ln855">	     index, IN_ADDR_SIZE,</a>
<a name="ln856">	     bgpTrapList, sizeof bgpTrapList / sizeof (struct trap_object),</a>
<a name="ln857">	     BGPESTABLISHED);</a>
<a name="ln858">}</a>
<a name="ln859"> </a>
<a name="ln860">void</a>
<a name="ln861">bgpTrapBackwardTransition (struct peer *peer)</a>
<a name="ln862">{</a>
<a name="ln863">  int ret;</a>
<a name="ln864">  struct in_addr addr;</a>
<a name="ln865">  oid index[sizeof (oid) * IN_ADDR_SIZE];</a>
<a name="ln866"> </a>
<a name="ln867">  ret = inet_aton (peer-&gt;host, &amp;addr);</a>
<a name="ln868">  if (ret == 0)</a>
<a name="ln869">    return;</a>
<a name="ln870"> </a>
<a name="ln871">  oid_copy_addr (index, &amp;addr, IN_ADDR_SIZE);</a>
<a name="ln872"> </a>
<a name="ln873">  smux_trap (bgp_variables, sizeof bgp_variables / sizeof (struct variable),</a>
<a name="ln874">	     bgp_trap_oid, sizeof bgp_trap_oid / sizeof (oid),</a>
<a name="ln875">	     bgp_oid, sizeof bgp_oid / sizeof (oid),</a>
<a name="ln876">	     index, IN_ADDR_SIZE,</a>
<a name="ln877">	     bgpTrapList, sizeof bgpTrapList / sizeof (struct trap_object),</a>
<a name="ln878">	     BGPBACKWARDTRANSITION);</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">void</a>
<a name="ln882">bgp_snmp_init (void)</a>
<a name="ln883">{</a>
<a name="ln884">  smux_init (bm-&gt;master);</a>
<a name="ln885">  REGISTER_MIB(&quot;mibII/bgp&quot;, bgp_variables, variable, bgp_oid);</a>
<a name="ln886">}</a>
<a name="ln887">#endif /* HAVE_SNMP */</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
