
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_nexthop.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP nexthop scan</a>
<a name="ln2">   Copyright (C) 2000 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;command.h&quot;</a>
<a name="ln24">#include &quot;thread.h&quot;</a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;zclient.h&quot;</a>
<a name="ln27">#include &quot;stream.h&quot;</a>
<a name="ln28">#include &quot;network.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;memory.h&quot;</a>
<a name="ln31">#include &quot;hash.h&quot;</a>
<a name="ln32">#include &quot;jhash.h&quot;</a>
<a name="ln33">#include &quot;filter.h&quot;</a>
<a name="ln34">#include &quot;nexthop.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln38">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln39">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln40">#include &quot;bgpd/bgp_nexthop.h&quot;</a>
<a name="ln41">#include &quot;bgpd/bgp_nht.h&quot;</a>
<a name="ln42">#include &quot;bgpd/bgp_debug.h&quot;</a>
<a name="ln43">#include &quot;bgpd/bgp_damp.h&quot;</a>
<a name="ln44">#include &quot;zebra/rib.h&quot;</a>
<a name="ln45">#include &quot;zebra/zserv.h&quot;	/* For ZEBRA_SERV_PATH. */</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">/* Route table for next-hop lookup cache. */</a>
<a name="ln49">struct bgp_table *bgp_nexthop_cache_table[AFI_MAX];</a>
<a name="ln50">static struct bgp_table *cache1_table[AFI_MAX];</a>
<a name="ln51"> </a>
<a name="ln52">/* Route table for connected route. */</a>
<a name="ln53">static struct bgp_table *bgp_connected_table[AFI_MAX];</a>
<a name="ln54"> </a>
<a name="ln55">char *</a>
<a name="ln56">bnc_str (struct bgp_nexthop_cache *bnc, char *buf, int size)</a>
<a name="ln57">{</a>
<a name="ln58">  prefix2str(&amp;(bnc-&gt;node-&gt;p), buf, size);</a>
<a name="ln59">  return buf;</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">void</a>
<a name="ln63">bnc_nexthop_free (struct bgp_nexthop_cache *bnc)</a>
<a name="ln64">{</a>
<a name="ln65">  struct nexthop *nexthop;</a>
<a name="ln66">  struct nexthop *next = NULL;</a>
<a name="ln67"> </a>
<a name="ln68">  for (nexthop = bnc-&gt;nexthop; nexthop; nexthop = next)</a>
<a name="ln69">    {</a>
<a name="ln70">      next = nexthop-&gt;next;</a>
<a name="ln71">      XFREE (MTYPE_NEXTHOP, nexthop);</a>
<a name="ln72">    }</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">struct bgp_nexthop_cache *</a>
<a name="ln76">bnc_new (void)</a>
<a name="ln77">{</a>
<a name="ln78">  struct bgp_nexthop_cache *bnc;</a>
<a name="ln79"> </a>
<a name="ln80">  bnc = XCALLOC (MTYPE_BGP_NEXTHOP_CACHE, sizeof (struct bgp_nexthop_cache));</a>
<a name="ln81">  LIST_INIT(&amp;(bnc-&gt;paths));</a>
<a name="ln82">  return bnc;</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">void</a>
<a name="ln86">bnc_free (struct bgp_nexthop_cache *bnc)</a>
<a name="ln87">{</a>
<a name="ln88">  bnc_nexthop_free (bnc);</a>
<a name="ln89">  XFREE (MTYPE_BGP_NEXTHOP_CACHE, bnc);</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">/* If nexthop exists on connected network return 1. */</a>
<a name="ln93">int</a>
<a name="ln94">bgp_nexthop_onlink (afi_t afi, struct attr *attr)</a>
<a name="ln95">{</a>
<a name="ln96">  struct bgp_node *rn;</a>
<a name="ln97">  </a>
<a name="ln98">  /* Lookup the address is onlink or not. */</a>
<a name="ln99">  if (afi == AFI_IP)</a>
<a name="ln100">    {</a>
<a name="ln101">      rn = bgp_node_match_ipv4 (bgp_connected_table[AFI_IP], &amp;attr-&gt;nexthop);</a>
<a name="ln102">      if (rn)</a>
<a name="ln103">	{</a>
<a name="ln104">	  bgp_unlock_node (rn);</a>
<a name="ln105">	  return 1;</a>
<a name="ln106">	}</a>
<a name="ln107">    }</a>
<a name="ln108">  else if (afi == AFI_IP6)</a>
<a name="ln109">    {</a>
<a name="ln110">      if (attr-&gt;extra-&gt;mp_nexthop_len == 32)</a>
<a name="ln111">	return 1;</a>
<a name="ln112">      else if (attr-&gt;extra-&gt;mp_nexthop_len == 16)</a>
<a name="ln113">	{</a>
<a name="ln114">	  if (IN6_IS_ADDR_LINKLOCAL (&amp;attr-&gt;extra-&gt;mp_nexthop_global))</a>
<a name="ln115">	    return 1;</a>
<a name="ln116"> </a>
<a name="ln117">	  rn = bgp_node_match_ipv6 (bgp_connected_table[AFI_IP6],</a>
<a name="ln118">				      &amp;attr-&gt;extra-&gt;mp_nexthop_global);</a>
<a name="ln119">	  if (rn)</a>
<a name="ln120">	    {</a>
<a name="ln121">	      bgp_unlock_node (rn);</a>
<a name="ln122">	      return 1;</a>
<a name="ln123">	    }</a>
<a name="ln124">	}</a>
<a name="ln125">    }</a>
<a name="ln126">  return 0;</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">/* BGP own address structure */</a>
<a name="ln130">struct bgp_addr</a>
<a name="ln131">{</a>
<a name="ln132">  struct in_addr addr;</a>
<a name="ln133">  int refcnt;</a>
<a name="ln134">};</a>
<a name="ln135"> </a>
<a name="ln136">static struct hash *bgp_address_hash;</a>
<a name="ln137"> </a>
<a name="ln138">static void *</a>
<a name="ln139">bgp_address_hash_alloc (void *p)</a>
<a name="ln140">{</a>
<a name="ln141">  struct in_addr *val = p;</a>
<a name="ln142">  struct bgp_addr *addr;</a>
<a name="ln143"> </a>
<a name="ln144">  addr = XMALLOC (MTYPE_BGP_ADDR, sizeof (struct bgp_addr));</a>
<a name="ln145">  addr-&gt;refcnt = 0;</a>
<a name="ln146">  addr-&gt;addr.s_addr = val-&gt;s_addr;</a>
<a name="ln147"> </a>
<a name="ln148">  return addr;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">static unsigned int</a>
<a name="ln152">bgp_address_hash_key_make (void *p)</a>
<a name="ln153">{</a>
<a name="ln154">  const struct bgp_addr *addr = p;</a>
<a name="ln155"> </a>
<a name="ln156">  return jhash_1word(addr-&gt;addr.s_addr, 0);</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">static int</a>
<a name="ln160">bgp_address_hash_cmp (const void *p1, const void *p2)</a>
<a name="ln161">{</a>
<a name="ln162">  const struct bgp_addr *addr1 = p1;</a>
<a name="ln163">  const struct bgp_addr *addr2 = p2;</a>
<a name="ln164"> </a>
<a name="ln165">  return addr1-&gt;addr.s_addr == addr2-&gt;addr.s_addr;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">void</a>
<a name="ln169">bgp_address_init (void)</a>
<a name="ln170">{</a>
<a name="ln171">  bgp_address_hash = hash_create (bgp_address_hash_key_make,</a>
<a name="ln172">                                  bgp_address_hash_cmp);</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">void</a>
<a name="ln176">bgp_address_destroy (void)</a>
<a name="ln177">{</a>
<a name="ln178">  if (bgp_address_hash == NULL)</a>
<a name="ln179">    return;</a>
<a name="ln180"> </a>
<a name="ln181">  hash_clean(bgp_address_hash, NULL);</a>
<a name="ln182">  hash_free(bgp_address_hash);</a>
<a name="ln183">  bgp_address_hash = NULL;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">static void</a>
<a name="ln187">bgp_address_add (struct prefix *p)</a>
<a name="ln188">{</a>
<a name="ln189">  struct bgp_addr tmp;</a>
<a name="ln190">  struct bgp_addr *addr;</a>
<a name="ln191"> </a>
<a name="ln192">  tmp.addr = p-&gt;u.prefix4;</a>
<a name="ln193"> </a>
<a name="ln194">  addr = hash_get (bgp_address_hash, &amp;tmp, bgp_address_hash_alloc);</a>
<a name="ln195">  if (!addr)</a>
<a name="ln196">    return;</a>
<a name="ln197"> </a>
<a name="ln198">  addr-&gt;refcnt++;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">static void</a>
<a name="ln202">bgp_address_del (struct prefix *p)</a>
<a name="ln203">{</a>
<a name="ln204">  struct bgp_addr tmp;</a>
<a name="ln205">  struct bgp_addr *addr;</a>
<a name="ln206"> </a>
<a name="ln207">  tmp.addr = p-&gt;u.prefix4;</a>
<a name="ln208"> </a>
<a name="ln209">  addr = hash_lookup (bgp_address_hash, &amp;tmp);</a>
<a name="ln210">  /* may have been deleted earlier by bgp_interface_down() */</a>
<a name="ln211">  if (addr == NULL)</a>
<a name="ln212">    return;</a>
<a name="ln213"> </a>
<a name="ln214">  addr-&gt;refcnt--;</a>
<a name="ln215"> </a>
<a name="ln216">  if (addr-&gt;refcnt == 0)</a>
<a name="ln217">    {</a>
<a name="ln218">      hash_release (bgp_address_hash, addr);</a>
<a name="ln219">      XFREE (MTYPE_BGP_ADDR, addr);</a>
<a name="ln220">    }</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223"> </a>
<a name="ln224">struct bgp_connected_ref</a>
<a name="ln225">{</a>
<a name="ln226">  unsigned int refcnt;</a>
<a name="ln227">};</a>
<a name="ln228"> </a>
<a name="ln229">void</a>
<a name="ln230">bgp_connected_add (struct connected *ifc)</a>
<a name="ln231">{</a>
<a name="ln232">  struct prefix p;</a>
<a name="ln233">  struct prefix *addr;</a>
<a name="ln234">  struct interface *ifp;</a>
<a name="ln235">  struct bgp_node *rn;</a>
<a name="ln236">  struct bgp_connected_ref *bc;</a>
<a name="ln237"> </a>
<a name="ln238">  ifp = ifc-&gt;ifp;</a>
<a name="ln239"> </a>
<a name="ln240">  if (! ifp)</a>
<a name="ln241">    return;</a>
<a name="ln242"> </a>
<a name="ln243">  if (if_is_loopback (ifp))</a>
<a name="ln244">    return;</a>
<a name="ln245"> </a>
<a name="ln246">  addr = ifc-&gt;address;</a>
<a name="ln247"> </a>
<a name="ln248">  p = *(CONNECTED_PREFIX(ifc));</a>
<a name="ln249">  if (addr-&gt;family == AF_INET)</a>
<a name="ln250">    {</a>
<a name="ln251">      apply_mask_ipv4 ((struct prefix_ipv4 *) &amp;p);</a>
<a name="ln252"> </a>
<a name="ln253">      if (prefix_ipv4_any ((struct prefix_ipv4 *) &amp;p))</a>
<a name="ln254">	return;</a>
<a name="ln255"> </a>
<a name="ln256">      bgp_address_add (addr);</a>
<a name="ln257"> </a>
<a name="ln258">      rn = bgp_node_get (bgp_connected_table[AFI_IP], (struct prefix *) &amp;p);</a>
<a name="ln259">      if (rn-&gt;info)</a>
<a name="ln260">	{</a>
<a name="ln261">	  bc = rn-&gt;info;</a>
<a name="ln262">	  bc-&gt;refcnt++;</a>
<a name="ln263">	}</a>
<a name="ln264">      else</a>
<a name="ln265">	{</a>
<a name="ln266">	  bc = XCALLOC (MTYPE_BGP_CONN, sizeof (struct bgp_connected_ref));</a>
<a name="ln267">	  bc-&gt;refcnt = 1;</a>
<a name="ln268">	  rn-&gt;info = bc;</a>
<a name="ln269">	}</a>
<a name="ln270">    }</a>
<a name="ln271">  else if (addr-&gt;family == AF_INET6)</a>
<a name="ln272">    {</a>
<a name="ln273">      apply_mask_ipv6 ((struct prefix_ipv6 *) &amp;p);</a>
<a name="ln274"> </a>
<a name="ln275">      if (IN6_IS_ADDR_UNSPECIFIED (&amp;p.u.prefix6))</a>
<a name="ln276">	return;</a>
<a name="ln277"> </a>
<a name="ln278">      if (IN6_IS_ADDR_LINKLOCAL (&amp;p.u.prefix6))</a>
<a name="ln279">	return;</a>
<a name="ln280"> </a>
<a name="ln281">      rn = bgp_node_get (bgp_connected_table[AFI_IP6], (struct prefix *) &amp;p);</a>
<a name="ln282">      if (rn-&gt;info)</a>
<a name="ln283">	{</a>
<a name="ln284">	  bc = rn-&gt;info;</a>
<a name="ln285">	  bc-&gt;refcnt++;</a>
<a name="ln286">	}</a>
<a name="ln287">      else</a>
<a name="ln288">	{</a>
<a name="ln289">	  bc = XCALLOC (MTYPE_BGP_CONN, sizeof (struct bgp_connected_ref));</a>
<a name="ln290">	  bc-&gt;refcnt = 1;</a>
<a name="ln291">	  rn-&gt;info = bc;</a>
<a name="ln292">	}</a>
<a name="ln293">    }</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">void</a>
<a name="ln297">bgp_connected_delete (struct connected *ifc)</a>
<a name="ln298">{</a>
<a name="ln299">  struct prefix p;</a>
<a name="ln300">  struct prefix *addr;</a>
<a name="ln301">  struct interface *ifp;</a>
<a name="ln302">  struct bgp_node *rn;</a>
<a name="ln303">  struct bgp_connected_ref *bc;</a>
<a name="ln304"> </a>
<a name="ln305">  ifp = ifc-&gt;ifp;</a>
<a name="ln306"> </a>
<a name="ln307">  if (if_is_loopback (ifp))</a>
<a name="ln308">    return;</a>
<a name="ln309"> </a>
<a name="ln310">  addr = ifc-&gt;address;</a>
<a name="ln311"> </a>
<a name="ln312">  p = *(CONNECTED_PREFIX(ifc));</a>
<a name="ln313">  if (addr-&gt;family == AF_INET)</a>
<a name="ln314">    {</a>
<a name="ln315">      apply_mask_ipv4 ((struct prefix_ipv4 *) &amp;p);</a>
<a name="ln316"> </a>
<a name="ln317">      if (prefix_ipv4_any ((struct prefix_ipv4 *) &amp;p))</a>
<a name="ln318">	return;</a>
<a name="ln319"> </a>
<a name="ln320">      bgp_address_del (addr);</a>
<a name="ln321"> </a>
<a name="ln322">      rn = bgp_node_lookup (bgp_connected_table[AFI_IP], &amp;p);</a>
<a name="ln323">      if (! rn)</a>
<a name="ln324">	return;</a>
<a name="ln325"> </a>
<a name="ln326">      bc = rn-&gt;info;</a>
<a name="ln327">      bc-&gt;refcnt--;</a>
<a name="ln328">      if (bc-&gt;refcnt == 0)</a>
<a name="ln329">	{</a>
<a name="ln330">	  XFREE (MTYPE_BGP_CONN, bc);</a>
<a name="ln331">	  rn-&gt;info = NULL;</a>
<a name="ln332">	}</a>
<a name="ln333">      bgp_unlock_node (rn);</a>
<a name="ln334">      bgp_unlock_node (rn);</a>
<a name="ln335">    }</a>
<a name="ln336">  else if (addr-&gt;family == AF_INET6)</a>
<a name="ln337">    {</a>
<a name="ln338">      apply_mask_ipv6 ((struct prefix_ipv6 *) &amp;p);</a>
<a name="ln339"> </a>
<a name="ln340">      if (IN6_IS_ADDR_UNSPECIFIED (&amp;p.u.prefix6))</a>
<a name="ln341">	return;</a>
<a name="ln342"> </a>
<a name="ln343">      if (IN6_IS_ADDR_LINKLOCAL (&amp;p.u.prefix6))</a>
<a name="ln344">	return;</a>
<a name="ln345"> </a>
<a name="ln346">      rn = bgp_node_lookup (bgp_connected_table[AFI_IP6], (struct prefix *) &amp;p);</a>
<a name="ln347">      if (! rn)</a>
<a name="ln348">	return;</a>
<a name="ln349"> </a>
<a name="ln350">      bc = rn-&gt;info;</a>
<a name="ln351">      bc-&gt;refcnt--;</a>
<a name="ln352">      if (bc-&gt;refcnt == 0)</a>
<a name="ln353">	{</a>
<a name="ln354">	  XFREE (MTYPE_BGP_CONN, bc);</a>
<a name="ln355">	  rn-&gt;info = NULL;</a>
<a name="ln356">	}</a>
<a name="ln357">      bgp_unlock_node (rn);</a>
<a name="ln358">      bgp_unlock_node (rn);</a>
<a name="ln359">    }</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">int</a>
<a name="ln363">bgp_nexthop_self (struct attr *attr)</a>
<a name="ln364">{</a>
<a name="ln365">  struct bgp_addr tmp, *addr;</a>
<a name="ln366"> </a>
<a name="ln367">  tmp.addr = attr-&gt;nexthop;</a>
<a name="ln368"> </a>
<a name="ln369">  addr = hash_lookup (bgp_address_hash, &amp;tmp);</a>
<a name="ln370">  if (addr)</a>
<a name="ln371">    return 1;</a>
<a name="ln372"> </a>
<a name="ln373">  return 0;</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">int</a>
<a name="ln377">bgp_multiaccess_check_v4 (struct in_addr nexthop, struct peer *peer)</a>
<a name="ln378">{</a>
<a name="ln379">  struct bgp_node *rn1;</a>
<a name="ln380">  struct bgp_node *rn2;</a>
<a name="ln381">  struct prefix p;</a>
<a name="ln382">  int ret;</a>
<a name="ln383"> </a>
<a name="ln384">  p.family = AF_INET;</a>
<a name="ln385">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln386">  p.u.prefix4 = nexthop;</a>
<a name="ln387"> </a>
<a name="ln388">  rn1 = bgp_node_match (bgp_connected_table[AFI_IP], &amp;p);</a>
<a name="ln389">  if (!rn1)</a>
<a name="ln390">    return 0;</a>
<a name="ln391"> </a>
<a name="ln392">  p.family = AF_INET;</a>
<a name="ln393">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln394">  p.u.prefix4 = peer-&gt;su.sin.sin_addr;</a>
<a name="ln395"> </a>
<a name="ln396">  rn2 = bgp_node_match (bgp_connected_table[AFI_IP], &amp;p);</a>
<a name="ln397">  if (!rn2)</a>
<a name="ln398">    {</a>
<a name="ln399">      bgp_unlock_node(rn1);</a>
<a name="ln400">      return 0;</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">  ret = (rn1 == rn2) ? 1 : 0;</a>
<a name="ln404"> </a>
<a name="ln405">  bgp_unlock_node(rn1);</a>
<a name="ln406">  bgp_unlock_node(rn2);</a>
<a name="ln407"> </a>
<a name="ln408">  return (ret);</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">static int</a>
<a name="ln412">show_ip_bgp_nexthop_table (struct vty *vty, int detail)</a>
<a name="ln413">{</a>
<a name="ln414">  struct bgp_node *rn;</a>
<a name="ln415">  struct bgp_nexthop_cache *bnc;</a>
<a name="ln416">  char buf[INET6_ADDRSTRLEN];</a>
<a name="ln417">  struct nexthop *nexthop;</a>
<a name="ln418">  time_t tbuf;</a>
<a name="ln419">  afi_t afi;</a>
<a name="ln420"> </a>
<a name="ln421">  vty_out (vty, &quot;Current BGP nexthop cache:%s&quot;, VTY_NEWLINE);</a>
<a name="ln422">  for (afi = AFI_IP ; afi &lt; AFI_MAX ; afi++)</a>
<a name="ln423">    {</a>
<a name="ln424">      if (!bgp_nexthop_cache_table[afi])</a>
<a name="ln425">        continue;</a>
<a name="ln426">      </a>
<a name="ln427">      for (rn = bgp_table_top (bgp_nexthop_cache_table[afi]); rn; rn = bgp_route_next (rn))</a>
<a name="ln428">	{</a>
<a name="ln429">	  if ((bnc = rn-&gt;info) != NULL)</a>
<a name="ln430">	    {</a>
<a name="ln431">	      if (CHECK_FLAG(bnc-&gt;flags, BGP_NEXTHOP_VALID))</a>
<a name="ln432">		{</a>
<a name="ln433">		  vty_out (vty, &quot; %s valid [IGP metric %d], #paths %d%s&quot;,</a>
<a name="ln434">			   inet_ntop (rn-&gt;p.family, &amp;rn-&gt;p.u.prefix, buf, sizeof (buf)),</a>
<a name="ln435">			   bnc-&gt;metric, bnc-&gt;path_count, VTY_NEWLINE);</a>
<a name="ln436">		  if (detail)</a>
<a name="ln437">		    for (nexthop = bnc-&gt;nexthop ; nexthop; nexthop = nexthop-&gt;next)</a>
<a name="ln438">		      switch (nexthop-&gt;type)</a>
<a name="ln439">			{</a>
<a name="ln440">			case NEXTHOP_TYPE_IPV6:</a>
<a name="ln441">			  vty_out (vty, &quot;  gate %s%s&quot;,</a>
<a name="ln442">				   inet_ntop (AF_INET6, &amp;nexthop-&gt;gate.ipv6,</a>
<a name="ln443">					      buf, INET6_ADDRSTRLEN), VTY_NEWLINE);</a>
<a name="ln444">			  break;</a>
<a name="ln445">			case NEXTHOP_TYPE_IPV6_IFINDEX:</a>
<a name="ln446">			  vty_out(vty, &quot;  gate %s, if %s%s&quot;,</a>
<a name="ln447">				  inet_ntop(AF_INET6, &amp;nexthop-&gt;gate.ipv6, buf,</a>
<a name="ln448">					    INET6_ADDRSTRLEN),</a>
<a name="ln449">				  ifindex2ifname(nexthop-&gt;ifindex),</a>
<a name="ln450">				  VTY_NEWLINE);</a>
<a name="ln451">			  break;</a>
<a name="ln452">			case NEXTHOP_TYPE_IPV4:</a>
<a name="ln453">			  vty_out (vty, &quot;  gate %s%s&quot;,</a>
<a name="ln454">				   inet_ntop (AF_INET, &amp;nexthop-&gt;gate.ipv4, buf,</a>
<a name="ln455">					      INET6_ADDRSTRLEN), VTY_NEWLINE);</a>
<a name="ln456">			  break;</a>
<a name="ln457">			case NEXTHOP_TYPE_IFINDEX:</a>
<a name="ln458">			  vty_out (vty, &quot;  if %s%s&quot;,</a>
<a name="ln459">				   ifindex2ifname(nexthop-&gt;ifindex), VTY_NEWLINE);</a>
<a name="ln460">			  break;</a>
<a name="ln461">			case NEXTHOP_TYPE_IPV4_IFINDEX:</a>
<a name="ln462">			  vty_out (vty, &quot;  gate %s, if %s%s&quot;,</a>
<a name="ln463">				   inet_ntop(AF_INET, &amp;nexthop-&gt;gate.ipv4, buf,</a>
<a name="ln464">					     INET6_ADDRSTRLEN),</a>
<a name="ln465">				   ifindex2ifname(nexthop-&gt;ifindex), VTY_NEWLINE);</a>
<a name="ln466">			  break;</a>
<a name="ln467">			default:</a>
<a name="ln468">			  vty_out (vty, &quot;  invalid nexthop type %u%s&quot;,</a>
<a name="ln469">				   nexthop-&gt;type, VTY_NEWLINE);</a>
<a name="ln470">			}</a>
<a name="ln471">		}</a>
<a name="ln472">	      else</a>
<a name="ln473">		vty_out (vty, &quot; %s invalid%s&quot;,</a>
<a name="ln474">			 inet_ntop (AF_INET, &amp;rn-&gt;p.u.prefix, buf, sizeof (buf)), VTY_NEWLINE);</a>
<a name="ln475">#ifdef HAVE_CLOCK_MONOTONIC</a>
<a name="ln476">	      tbuf = time(NULL) - (bgp_clock() - bnc-&gt;last_update);</a>
<a name="ln477">	      vty_out (vty, &quot;  Last update: %s&quot;, ctime(&amp;tbuf));</a>
<a name="ln478">#else</a>
<a name="ln479">	      vty_out (vty, &quot;  Last update: %s&quot;, ctime(&amp;bnc-&gt;uptime));</a>
<a name="ln480">#endif /* HAVE_CLOCK_MONOTONIC */</a>
<a name="ln481">	      vty_out(vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln482">	    }</a>
<a name="ln483">	}</a>
<a name="ln484">    }</a>
<a name="ln485">  return CMD_SUCCESS;</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">DEFUN (show_ip_bgp_nexthop,</a>
<a name="ln489">       show_ip_bgp_nexthop_cmd,</a>
<a name="ln490">       &quot;show ip bgp nexthop&quot;,</a>
<a name="ln491">       SHOW_STR</a>
<a name="ln492">       IP_STR</a>
<a name="ln493">       BGP_STR</a>
<a name="ln494">       &quot;BGP nexthop table\n&quot;)</a>
<a name="ln495">{</a>
<a name="ln496">  return show_ip_bgp_nexthop_table (vty, 0);</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">DEFUN (show_ip_bgp_nexthop_detail,</a>
<a name="ln500">       show_ip_bgp_nexthop_detail_cmd,</a>
<a name="ln501">       &quot;show ip bgp nexthop detail&quot;,</a>
<a name="ln502">       SHOW_STR</a>
<a name="ln503">       IP_STR</a>
<a name="ln504">       BGP_STR</a>
<a name="ln505">       &quot;BGP nexthop table\n&quot;)</a>
<a name="ln506">{</a>
<a name="ln507">  return show_ip_bgp_nexthop_table (vty, 1);</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">void</a>
<a name="ln511">bgp_scan_init (void)</a>
<a name="ln512">{</a>
<a name="ln513">  cache1_table[AFI_IP] = bgp_table_init (AFI_IP, SAFI_UNICAST);</a>
<a name="ln514">  bgp_nexthop_cache_table[AFI_IP] = cache1_table[AFI_IP];</a>
<a name="ln515"> </a>
<a name="ln516">  bgp_connected_table[AFI_IP] = bgp_table_init (AFI_IP, SAFI_UNICAST);</a>
<a name="ln517"> </a>
<a name="ln518">  cache1_table[AFI_IP6] = bgp_table_init (AFI_IP6, SAFI_UNICAST);</a>
<a name="ln519">  bgp_nexthop_cache_table[AFI_IP6] = cache1_table[AFI_IP6];</a>
<a name="ln520">  bgp_connected_table[AFI_IP6] = bgp_table_init (AFI_IP6, SAFI_UNICAST);</a>
<a name="ln521">  </a>
<a name="ln522">  cache1_table[AFI_ETHER] = bgp_table_init (AFI_ETHER, SAFI_UNICAST);</a>
<a name="ln523">  bgp_nexthop_cache_table[AFI_ETHER] = cache1_table[AFI_ETHER];</a>
<a name="ln524">  bgp_connected_table[AFI_ETHER] = bgp_table_init (AFI_ETHER, SAFI_UNICAST);</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">void</a>
<a name="ln528">bgp_scan_vty_init()</a>
<a name="ln529">{</a>
<a name="ln530">  install_element (VIEW_NODE, &amp;show_ip_bgp_nexthop_cmd);</a>
<a name="ln531">  install_element (VIEW_NODE, &amp;show_ip_bgp_nexthop_detail_cmd);</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">void</a>
<a name="ln535">bgp_scan_finish (void)</a>
<a name="ln536">{</a>
<a name="ln537">  if (cache1_table[AFI_IP])</a>
<a name="ln538">    bgp_table_unlock (cache1_table[AFI_IP]);</a>
<a name="ln539">  cache1_table[AFI_IP] = NULL;</a>
<a name="ln540"> </a>
<a name="ln541">  if (bgp_connected_table[AFI_IP])</a>
<a name="ln542">    bgp_table_unlock (bgp_connected_table[AFI_IP]);</a>
<a name="ln543">  bgp_connected_table[AFI_IP] = NULL;</a>
<a name="ln544"> </a>
<a name="ln545">  if (cache1_table[AFI_IP6])</a>
<a name="ln546">    bgp_table_unlock (cache1_table[AFI_IP6]);</a>
<a name="ln547">  cache1_table[AFI_IP6] = NULL;</a>
<a name="ln548"> </a>
<a name="ln549">  if (bgp_connected_table[AFI_IP6])</a>
<a name="ln550">    bgp_table_unlock (bgp_connected_table[AFI_IP6]);</a>
<a name="ln551">  bgp_connected_table[AFI_IP6] = NULL;</a>
<a name="ln552"> </a>
<a name="ln553">  if (cache1_table[AFI_ETHER])</a>
<a name="ln554">    bgp_table_unlock (cache1_table[AFI_ETHER]);</a>
<a name="ln555">  cache1_table[AFI_ETHER] = NULL;</a>
<a name="ln556">  </a>
<a name="ln557">  if (bgp_connected_table[AFI_ETHER])</a>
<a name="ln558">    bgp_table_unlock (bgp_connected_table[AFI_ETHER]);</a>
<a name="ln559">  bgp_connected_table[AFI_ETHER] = NULL;</a>
<a name="ln560"> </a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">void</a>
<a name="ln564">bgp_scan_destroy (void)</a>
<a name="ln565">{</a>
<a name="ln566">  bgp_scan_finish();</a>
<a name="ln567">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
