
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>zebra_fpm_netlink.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Code for encoding/decoding FPM messages that are in netlink format.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 1997, 98, 99 Kunihiro Ishiguro</a>
<a name="ln5"> * Copyright (C) 2012 by Open Source Routing.</a>
<a name="ln6"> * Copyright (C) 2012 by Internet Systems Consortium, Inc. (&quot;ISC&quot;)</a>
<a name="ln7"> *</a>
<a name="ln8"> * This file is part of GNU Zebra.</a>
<a name="ln9"> *</a>
<a name="ln10"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln11"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln12"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln13"> * later version.</a>
<a name="ln14"> *</a>
<a name="ln15"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln16"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln17"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln18"> * General Public License for more details.</a>
<a name="ln19"> *</a>
<a name="ln20"> * You should have received a copy of the GNU General Public License</a>
<a name="ln21"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln22"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln23"> * 02111-1307, USA.</a>
<a name="ln24"> */</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;zebra.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;log.h&quot;</a>
<a name="ln29">#include &quot;rib.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;rt_netlink.h&quot;</a>
<a name="ln32">#include &quot;nexthop.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;zebra_fpm_private.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">/*</a>
<a name="ln37"> * addr_to_a</a>
<a name="ln38"> *</a>
<a name="ln39"> * Returns string representation of an address of the given AF.</a>
<a name="ln40"> */</a>
<a name="ln41">static inline const char *</a>
<a name="ln42">addr_to_a (u_char af, void *addr)</a>
<a name="ln43">{</a>
<a name="ln44">  if (!addr)</a>
<a name="ln45">    return &quot;&lt;No address&gt;&quot;;</a>
<a name="ln46"> </a>
<a name="ln47">  switch (af)</a>
<a name="ln48">    {</a>
<a name="ln49"> </a>
<a name="ln50">    case AF_INET:</a>
<a name="ln51">      return inet_ntoa (*((struct in_addr *) addr));</a>
<a name="ln52"> </a>
<a name="ln53">#ifdef HAVE_IPV6</a>
<a name="ln54">    case AF_INET6:</a>
<a name="ln55">      return inet6_ntoa (*((struct in6_addr *) addr));</a>
<a name="ln56">#endif</a>
<a name="ln57"> </a>
<a name="ln58">    default:</a>
<a name="ln59">      return &quot;&lt;Addr in unknown AF&gt;&quot;;</a>
<a name="ln60">    }</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">/*</a>
<a name="ln64"> * prefix_addr_to_a</a>
<a name="ln65"> *</a>
<a name="ln66"> * Convience wrapper that returns a human-readable string for the</a>
<a name="ln67"> * address in a prefix.</a>
<a name="ln68"> */</a>
<a name="ln69">static const char *</a>
<a name="ln70">prefix_addr_to_a (struct prefix *prefix)</a>
<a name="ln71">{</a>
<a name="ln72">  if (!prefix)</a>
<a name="ln73">    return &quot;&lt;No address&gt;&quot;;</a>
<a name="ln74"> </a>
<a name="ln75">  return addr_to_a (prefix-&gt;family, &amp;prefix-&gt;u.prefix);</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">/*</a>
<a name="ln79"> * af_addr_size</a>
<a name="ln80"> *</a>
<a name="ln81"> * The size of an address in a given address family.</a>
<a name="ln82"> */</a>
<a name="ln83">static size_t</a>
<a name="ln84">af_addr_size (u_char af)</a>
<a name="ln85">{</a>
<a name="ln86">  switch (af)</a>
<a name="ln87">    {</a>
<a name="ln88"> </a>
<a name="ln89">    case AF_INET:</a>
<a name="ln90">      return 4;</a>
<a name="ln91"> </a>
<a name="ln92">#ifdef HAVE_IPV6</a>
<a name="ln93">    case AF_INET6:</a>
<a name="ln94">      return 16;</a>
<a name="ln95">#endif</a>
<a name="ln96"> </a>
<a name="ln97">    default:</a>
<a name="ln98">      assert(0);</a>
<a name="ln99">      return 16;</a>
<a name="ln100">    }</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">/*</a>
<a name="ln104"> * netlink_nh_info_t</a>
<a name="ln105"> *</a>
<a name="ln106"> * Holds information about a single nexthop for netlink. These info</a>
<a name="ln107"> * structures are transient and may contain pointers into rib</a>
<a name="ln108"> * data structures for convenience.</a>
<a name="ln109"> */</a>
<a name="ln110">typedef struct netlink_nh_info_t_</a>
<a name="ln111">{</a>
<a name="ln112">  uint32_t if_index;</a>
<a name="ln113">  union g_addr *gateway;</a>
<a name="ln114"> </a>
<a name="ln115">  /*</a>
<a name="ln116">   * Information from the struct nexthop from which this nh was</a>
<a name="ln117">   * derived. For debug purposes only.</a>
<a name="ln118">   */</a>
<a name="ln119">  int recursive;</a>
<a name="ln120">  enum nexthop_types_t type;</a>
<a name="ln121">} netlink_nh_info_t;</a>
<a name="ln122"> </a>
<a name="ln123">/*</a>
<a name="ln124"> * netlink_route_info_t</a>
<a name="ln125"> *</a>
<a name="ln126"> * A structure for holding information for a netlink route message.</a>
<a name="ln127"> */</a>
<a name="ln128">typedef struct netlink_route_info_t_</a>
<a name="ln129">{</a>
<a name="ln130">  uint16_t nlmsg_type;</a>
<a name="ln131">  u_char rtm_type;</a>
<a name="ln132">  uint32_t rtm_table;</a>
<a name="ln133">  u_char rtm_protocol;</a>
<a name="ln134">  u_char af;</a>
<a name="ln135">  struct prefix *prefix;</a>
<a name="ln136">  uint32_t *metric;</a>
<a name="ln137">  int num_nhs;</a>
<a name="ln138"> </a>
<a name="ln139">  /*</a>
<a name="ln140">   * Nexthop structures</a>
<a name="ln141">   */</a>
<a name="ln142">  netlink_nh_info_t nhs[MULTIPATH_NUM];</a>
<a name="ln143">  union g_addr *pref_src;</a>
<a name="ln144">} netlink_route_info_t;</a>
<a name="ln145"> </a>
<a name="ln146">/*</a>
<a name="ln147"> * netlink_route_info_add_nh</a>
<a name="ln148"> *</a>
<a name="ln149"> * Add information about the given nexthop to the given route info</a>
<a name="ln150"> * structure.</a>
<a name="ln151"> *</a>
<a name="ln152"> * Returns TRUE if a nexthop was added, FALSE otherwise.</a>
<a name="ln153"> */</a>
<a name="ln154">static int</a>
<a name="ln155">netlink_route_info_add_nh (netlink_route_info_t *ri, struct nexthop *nexthop,</a>
<a name="ln156">			   int recursive)</a>
<a name="ln157">{</a>
<a name="ln158">  netlink_nh_info_t nhi;</a>
<a name="ln159">  union g_addr *src;</a>
<a name="ln160"> </a>
<a name="ln161">  memset (&amp;nhi, 0, sizeof (nhi));</a>
<a name="ln162">  src = NULL;</a>
<a name="ln163"> </a>
<a name="ln164">  if (ri-&gt;num_nhs &gt;= (int) ZEBRA_NUM_OF (ri-&gt;nhs))</a>
<a name="ln165">    return 0;</a>
<a name="ln166"> </a>
<a name="ln167">  nhi.recursive = recursive;</a>
<a name="ln168">  nhi.type = nexthop-&gt;type;</a>
<a name="ln169">  nhi.if_index = nexthop-&gt;ifindex;</a>
<a name="ln170"> </a>
<a name="ln171">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV4</a>
<a name="ln172">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV4_IFINDEX)</a>
<a name="ln173">    {</a>
<a name="ln174">      nhi.gateway = &amp;nexthop-&gt;gate;</a>
<a name="ln175">      if (nexthop-&gt;src.ipv4.s_addr)</a>
<a name="ln176">	src = &amp;nexthop-&gt;src;</a>
<a name="ln177">    }</a>
<a name="ln178"> </a>
<a name="ln179">#ifdef HAVE_IPV6</a>
<a name="ln180">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV6</a>
<a name="ln181">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFNAME</a>
<a name="ln182">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFINDEX)</a>
<a name="ln183">    {</a>
<a name="ln184">      nhi.gateway = &amp;nexthop-&gt;gate;</a>
<a name="ln185">    }</a>
<a name="ln186">#endif /* HAVE_IPV6 */</a>
<a name="ln187"> </a>
<a name="ln188">  if (nexthop-&gt;type == NEXTHOP_TYPE_IFINDEX</a>
<a name="ln189">      || nexthop-&gt;type == NEXTHOP_TYPE_IFNAME)</a>
<a name="ln190">    {</a>
<a name="ln191">      if (nexthop-&gt;src.ipv4.s_addr)</a>
<a name="ln192">	src = &amp;nexthop-&gt;src;</a>
<a name="ln193">    }</a>
<a name="ln194"> </a>
<a name="ln195">  if (!nhi.gateway &amp;&amp; nhi.if_index == 0)</a>
<a name="ln196">    return 0;</a>
<a name="ln197"> </a>
<a name="ln198">  /*</a>
<a name="ln199">   * We have a valid nhi. Copy the structure over to the route_info.</a>
<a name="ln200">   */</a>
<a name="ln201">  ri-&gt;nhs[ri-&gt;num_nhs] = nhi;</a>
<a name="ln202">  ri-&gt;num_nhs++;</a>
<a name="ln203"> </a>
<a name="ln204">  if (src &amp;&amp; !ri-&gt;pref_src)</a>
<a name="ln205">    ri-&gt;pref_src = src;</a>
<a name="ln206"> </a>
<a name="ln207">  return 1;</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">/*</a>
<a name="ln211"> * netlink_proto_from_route_type</a>
<a name="ln212"> */</a>
<a name="ln213">static u_char</a>
<a name="ln214">netlink_proto_from_route_type (int type)</a>
<a name="ln215">{</a>
<a name="ln216">  switch (type)</a>
<a name="ln217">    {</a>
<a name="ln218">    case ZEBRA_ROUTE_KERNEL:</a>
<a name="ln219">    case ZEBRA_ROUTE_CONNECT:</a>
<a name="ln220">      return RTPROT_KERNEL;</a>
<a name="ln221"> </a>
<a name="ln222">    default:</a>
<a name="ln223">      return RTPROT_ZEBRA;</a>
<a name="ln224">    }</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">/*</a>
<a name="ln228"> * netlink_route_info_fill</a>
<a name="ln229"> *</a>
<a name="ln230"> * Fill out the route information object from the given route.</a>
<a name="ln231"> *</a>
<a name="ln232"> * Returns TRUE on success and FALSE on failure.</a>
<a name="ln233"> */</a>
<a name="ln234">static int</a>
<a name="ln235">netlink_route_info_fill (netlink_route_info_t *ri, int cmd,</a>
<a name="ln236">			 rib_dest_t *dest, struct rib *rib)</a>
<a name="ln237">{</a>
<a name="ln238">  struct nexthop *nexthop, *tnexthop;</a>
<a name="ln239">  int recursing;</a>
<a name="ln240">  int discard;</a>
<a name="ln241"> </a>
<a name="ln242">  memset (ri, 0, sizeof (*ri));</a>
<a name="ln243"> </a>
<a name="ln244">  ri-&gt;prefix = rib_dest_prefix (dest);</a>
<a name="ln245">  ri-&gt;af = rib_dest_af (dest);</a>
<a name="ln246"> </a>
<a name="ln247">  ri-&gt;nlmsg_type = cmd;</a>
<a name="ln248">  ri-&gt;rtm_table = rib_dest_vrf (dest)-&gt;vrf_id;</a>
<a name="ln249">  ri-&gt;rtm_protocol = RTPROT_UNSPEC;</a>
<a name="ln250"> </a>
<a name="ln251">  /*</a>
<a name="ln252">   * An RTM_DELROUTE need not be accompanied by any nexthops,</a>
<a name="ln253">   * particularly in our communication with the FPM.</a>
<a name="ln254">   */</a>
<a name="ln255">  if (cmd == RTM_DELROUTE)</a>
<a name="ln256">    goto skip;</a>
<a name="ln257"> </a>
<a name="ln258">  if (!rib)</a>
<a name="ln259">    {</a>
<a name="ln260">      zlog_err(&quot;netlink_route_info_fill RTM_ADDROUTE called without rib info&quot;);</a>
<a name="ln261">      return 0;</a>
<a name="ln262">    }</a>
<a name="ln263"> </a>
<a name="ln264">  ri-&gt;rtm_protocol = netlink_proto_from_route_type (rib-&gt;type);</a>
<a name="ln265"> </a>
<a name="ln266">  if ((rib-&gt;flags &amp; ZEBRA_FLAG_BLACKHOLE) || (rib-&gt;flags &amp; ZEBRA_FLAG_REJECT))</a>
<a name="ln267">    discard = 1;</a>
<a name="ln268">  else</a>
<a name="ln269">    discard = 0;</a>
<a name="ln270"> </a>
<a name="ln271">  if (cmd == RTM_NEWROUTE)</a>
<a name="ln272">    {</a>
<a name="ln273">      if (discard)</a>
<a name="ln274">        {</a>
<a name="ln275">          if (rib-&gt;flags &amp; ZEBRA_FLAG_BLACKHOLE)</a>
<a name="ln276">            ri-&gt;rtm_type = RTN_BLACKHOLE;</a>
<a name="ln277">          else if (rib-&gt;flags &amp; ZEBRA_FLAG_REJECT)</a>
<a name="ln278">            ri-&gt;rtm_type = RTN_UNREACHABLE;</a>
<a name="ln279">          else</a>
<a name="ln280">            assert (0);</a>
<a name="ln281">        }</a>
<a name="ln282">      else</a>
<a name="ln283">        ri-&gt;rtm_type = RTN_UNICAST;</a>
<a name="ln284">    }</a>
<a name="ln285"> </a>
<a name="ln286">  ri-&gt;metric = &amp;rib-&gt;metric;</a>
<a name="ln287"> </a>
<a name="ln288">  if (discard)</a>
<a name="ln289">    {</a>
<a name="ln290">      goto skip;</a>
<a name="ln291">    }</a>
<a name="ln292"> </a>
<a name="ln293">  for (ALL_NEXTHOPS_RO(rib-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln294">    {</a>
<a name="ln295">      if (ri-&gt;num_nhs &gt;= MULTIPATH_NUM)</a>
<a name="ln296">        break;</a>
<a name="ln297"> </a>
<a name="ln298">      if (CHECK_FLAG(nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE))</a>
<a name="ln299">        continue;</a>
<a name="ln300"> </a>
<a name="ln301">      if ((cmd == RTM_NEWROUTE</a>
<a name="ln302">           &amp;&amp; CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE))</a>
<a name="ln303">          || (cmd == RTM_DELROUTE</a>
<a name="ln304">              &amp;&amp; CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB)))</a>
<a name="ln305">        {</a>
<a name="ln306">          netlink_route_info_add_nh (ri, nexthop, recursing);</a>
<a name="ln307">        }</a>
<a name="ln308">    }</a>
<a name="ln309"> </a>
<a name="ln310">  /* If there is no useful nexthop then return. */</a>
<a name="ln311">  if (ri-&gt;num_nhs == 0)</a>
<a name="ln312">    {</a>
<a name="ln313">      zfpm_debug (&quot;netlink_encode_route(): No useful nexthop.&quot;);</a>
<a name="ln314">      return 0;</a>
<a name="ln315">    }</a>
<a name="ln316"> </a>
<a name="ln317"> skip:</a>
<a name="ln318">  return 1;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">/*</a>
<a name="ln322"> * netlink_route_info_encode</a>
<a name="ln323"> *</a>
<a name="ln324"> * Returns the number of bytes written to the buffer. 0 or a negative</a>
<a name="ln325"> * value indicates an error.</a>
<a name="ln326"> */</a>
<a name="ln327">static int</a>
<a name="ln328">netlink_route_info_encode (netlink_route_info_t *ri, char *in_buf,</a>
<a name="ln329">			   size_t in_buf_len)</a>
<a name="ln330">{</a>
<a name="ln331">  size_t bytelen;</a>
<a name="ln332">  int nexthop_num = 0;</a>
<a name="ln333">  size_t buf_offset;</a>
<a name="ln334">  netlink_nh_info_t *nhi;</a>
<a name="ln335"> </a>
<a name="ln336">  struct</a>
<a name="ln337">  {</a>
<a name="ln338">    struct nlmsghdr n;</a>
<a name="ln339">    struct rtmsg r;</a>
<a name="ln340">    char buf[1];</a>
<a name="ln341">  } *req;</a>
<a name="ln342"> </a>
<a name="ln343">  req = (void *) in_buf;</a>
<a name="ln344"> </a>
<a name="ln345">  buf_offset = ((char *) req-&gt;buf) - ((char *) req);</a>
<a name="ln346"> </a>
<a name="ln347">  if (in_buf_len &lt; buf_offset) {</a>
<a name="ln348">    assert(0);</a>
<a name="ln349">    return 0;</a>
<a name="ln350">  }</a>
<a name="ln351"> </a>
<a name="ln352">  memset (req, 0, buf_offset);</a>
<a name="ln353"> </a>
<a name="ln354">  bytelen = af_addr_size (ri-&gt;af);</a>
<a name="ln355"> </a>
<a name="ln356">  req-&gt;n.nlmsg_len = NLMSG_LENGTH (sizeof (struct rtmsg));</a>
<a name="ln357">  req-&gt;n.nlmsg_flags = NLM_F_CREATE | NLM_F_REQUEST;</a>
<a name="ln358">  req-&gt;n.nlmsg_type = ri-&gt;nlmsg_type;</a>
<a name="ln359">  req-&gt;r.rtm_family = ri-&gt;af;</a>
<a name="ln360">  req-&gt;r.rtm_table = ri-&gt;rtm_table;</a>
<a name="ln361">  req-&gt;r.rtm_dst_len = ri-&gt;prefix-&gt;prefixlen;</a>
<a name="ln362">  req-&gt;r.rtm_protocol = ri-&gt;rtm_protocol;</a>
<a name="ln363">  req-&gt;r.rtm_scope = RT_SCOPE_UNIVERSE;</a>
<a name="ln364"> </a>
<a name="ln365">  addattr_l (&amp;req-&gt;n, in_buf_len, RTA_DST, &amp;ri-&gt;prefix-&gt;u.prefix, bytelen);</a>
<a name="ln366"> </a>
<a name="ln367">  req-&gt;r.rtm_type = ri-&gt;rtm_type;</a>
<a name="ln368"> </a>
<a name="ln369">  /* Metric. */</a>
<a name="ln370">  if (ri-&gt;metric)</a>
<a name="ln371">    addattr32 (&amp;req-&gt;n, in_buf_len, RTA_PRIORITY, *ri-&gt;metric);</a>
<a name="ln372"> </a>
<a name="ln373">  if (ri-&gt;num_nhs == 0)</a>
<a name="ln374">    goto done;</a>
<a name="ln375"> </a>
<a name="ln376">  if (ri-&gt;num_nhs == 1)</a>
<a name="ln377">    {</a>
<a name="ln378">      nhi = &amp;ri-&gt;nhs[0];</a>
<a name="ln379"> </a>
<a name="ln380">      if (nhi-&gt;gateway)</a>
<a name="ln381">	{</a>
<a name="ln382">	  addattr_l (&amp;req-&gt;n, in_buf_len, RTA_GATEWAY, nhi-&gt;gateway,</a>
<a name="ln383">		     bytelen);</a>
<a name="ln384">	}</a>
<a name="ln385"> </a>
<a name="ln386">      if (nhi-&gt;if_index)</a>
<a name="ln387">	{</a>
<a name="ln388">	  addattr32 (&amp;req-&gt;n, in_buf_len, RTA_OIF, nhi-&gt;if_index);</a>
<a name="ln389">	}</a>
<a name="ln390"> </a>
<a name="ln391">      goto done;</a>
<a name="ln392"> </a>
<a name="ln393">    }</a>
<a name="ln394"> </a>
<a name="ln395">  /*</a>
<a name="ln396">   * Multipath case.</a>
<a name="ln397">   */</a>
<a name="ln398">  char buf[NL_PKT_BUF_SIZE];</a>
<a name="ln399">  struct rtattr *rta = (void *) buf;</a>
<a name="ln400">  struct rtnexthop *rtnh;</a>
<a name="ln401"> </a>
<a name="ln402">  rta-&gt;rta_type = RTA_MULTIPATH;</a>
<a name="ln403">  rta-&gt;rta_len = RTA_LENGTH (0);</a>
<a name="ln404">  rtnh = RTA_DATA (rta);</a>
<a name="ln405"> </a>
<a name="ln406">  for (nexthop_num = 0; nexthop_num &lt; ri-&gt;num_nhs; nexthop_num++)</a>
<a name="ln407">    {</a>
<a name="ln408">      nhi = &amp;ri-&gt;nhs[nexthop_num];</a>
<a name="ln409"> </a>
<a name="ln410">      rtnh-&gt;rtnh_len = sizeof (*rtnh);</a>
<a name="ln411">      rtnh-&gt;rtnh_flags = 0;</a>
<a name="ln412">      rtnh-&gt;rtnh_hops = 0;</a>
<a name="ln413">      rtnh-&gt;rtnh_ifindex = 0;</a>
<a name="ln414">      rta-&gt;rta_len += rtnh-&gt;rtnh_len;</a>
<a name="ln415"> </a>
<a name="ln416">      if (nhi-&gt;gateway)</a>
<a name="ln417">	{</a>
<a name="ln418">	  rta_addattr_l (rta, sizeof (buf), RTA_GATEWAY, nhi-&gt;gateway, bytelen);</a>
<a name="ln419">	  rtnh-&gt;rtnh_len += sizeof (struct rtattr) + bytelen;</a>
<a name="ln420">	}</a>
<a name="ln421"> </a>
<a name="ln422">      if (nhi-&gt;if_index)</a>
<a name="ln423">	{</a>
<a name="ln424">	  rtnh-&gt;rtnh_ifindex = nhi-&gt;if_index;</a>
<a name="ln425">	}</a>
<a name="ln426"> </a>
<a name="ln427">      rtnh = RTNH_NEXT (rtnh);</a>
<a name="ln428">    }</a>
<a name="ln429"> </a>
<a name="ln430">  assert (rta-&gt;rta_len &gt; RTA_LENGTH (0));</a>
<a name="ln431">  addattr_l (&amp;req-&gt;n, in_buf_len, RTA_MULTIPATH, RTA_DATA (rta),</a>
<a name="ln432">	     RTA_PAYLOAD (rta));</a>
<a name="ln433"> </a>
<a name="ln434">done:</a>
<a name="ln435"> </a>
<a name="ln436">  if (ri-&gt;pref_src)</a>
<a name="ln437">    {</a>
<a name="ln438">      addattr_l (&amp;req-&gt;n, in_buf_len, RTA_PREFSRC, &amp;ri-&gt;pref_src, bytelen);</a>
<a name="ln439">    }</a>
<a name="ln440"> </a>
<a name="ln441">  assert (req-&gt;n.nlmsg_len &lt; in_buf_len);</a>
<a name="ln442">  return req-&gt;n.nlmsg_len;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">/*</a>
<a name="ln446"> * zfpm_log_route_info</a>
<a name="ln447"> *</a>
<a name="ln448"> * Helper function to log the information in a route_info structure.</a>
<a name="ln449"> */</a>
<a name="ln450">static void</a>
<a name="ln451">zfpm_log_route_info (netlink_route_info_t *ri, const char *label)</a>
<a name="ln452">{</a>
<a name="ln453">  netlink_nh_info_t *nhi;</a>
<a name="ln454">  int i;</a>
<a name="ln455"> </a>
<a name="ln456">  zfpm_debug (&quot;%s : %s %s/%d, Proto: %s, Metric: %u&quot;, label,</a>
<a name="ln457">	      nl_msg_type_to_str (ri-&gt;nlmsg_type),</a>
<a name="ln458">	      prefix_addr_to_a (ri-&gt;prefix), ri-&gt;prefix-&gt;prefixlen,</a>
<a name="ln459">	      nl_rtproto_to_str (ri-&gt;rtm_protocol),</a>
<a name="ln460">	      ri-&gt;metric ? *ri-&gt;metric : 0);</a>
<a name="ln461"> </a>
<a name="ln462">  for (i = 0; i &lt; ri-&gt;num_nhs; i++)</a>
<a name="ln463">    {</a>
<a name="ln464">      nhi = &amp;ri-&gt;nhs[i];</a>
<a name="ln465">      zfpm_debug(&quot;  Intf: %u, Gateway: %s, Recursive: %s, Type: %s&quot;,</a>
<a name="ln466">		 nhi-&gt;if_index, addr_to_a (ri-&gt;af, nhi-&gt;gateway),</a>
<a name="ln467">		 nhi-&gt;recursive ? &quot;yes&quot; : &quot;no&quot;,</a>
<a name="ln468">		 nexthop_type_to_str (nhi-&gt;type));</a>
<a name="ln469">    }</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">/*</a>
<a name="ln473"> * zfpm_netlink_encode_route</a>
<a name="ln474"> *</a>
<a name="ln475"> * Create a netlink message corresponding to the given route in the</a>
<a name="ln476"> * given buffer space.</a>
<a name="ln477"> *</a>
<a name="ln478"> * Returns the number of bytes written to the buffer. 0 or a negative</a>
<a name="ln479"> * value indicates an error.</a>
<a name="ln480"> */</a>
<a name="ln481">int</a>
<a name="ln482">zfpm_netlink_encode_route (int cmd, rib_dest_t *dest, struct rib *rib,</a>
<a name="ln483">			   char *in_buf, size_t in_buf_len)</a>
<a name="ln484">{</a>
<a name="ln485">  netlink_route_info_t ri_space, *ri;</a>
<a name="ln486"> </a>
<a name="ln487">  ri = &amp;ri_space;</a>
<a name="ln488"> </a>
<a name="ln489">  if (!netlink_route_info_fill (ri, cmd, dest, rib))</a>
<a name="ln490">    return 0;</a>
<a name="ln491"> </a>
<a name="ln492">  zfpm_log_route_info (ri, __FUNCTION__);</a>
<a name="ln493"> </a>
<a name="ln494">  return netlink_route_info_encode (ri, in_buf, in_buf_len);</a>
<a name="ln495">}</a>

</code></pre>
<div class="balloon" rel="11"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="303"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: cmd == RTM_DELROUTE.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
