
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ripng_nexthop.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* RIPngd Zebra</a>
<a name="ln2"> * Copyright (C) 2002 6WIND &lt;vincent.jardin@6wind.com&gt;</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">/* This file is required in order to support properly the RIPng nexthop</a>
<a name="ln23"> * feature.</a>
<a name="ln24"> */</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;zebra.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">/* For struct udphdr. */</a>
<a name="ln29">#include &lt;netinet/udp.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;linklist.h&quot;</a>
<a name="ln32">#include &quot;stream.h&quot;</a>
<a name="ln33">#include &quot;log.h&quot;</a>
<a name="ln34">#include &quot;memory.h&quot;</a>
<a name="ln35">#include &quot;vty.h&quot;</a>
<a name="ln36">#include &quot;if.h&quot;</a>
<a name="ln37">#include &quot;prefix.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;ripngd/ripngd.h&quot;</a>
<a name="ln40">#include &quot;ripngd/ripng_debug.h&quot;</a>
<a name="ln41">#include &quot;ripngd/ripng_nexthop.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">#define DEBUG 1</a>
<a name="ln44"> </a>
<a name="ln45">#define min(a, b) ((a) &lt; (b) ? (a) : (b))</a>
<a name="ln46"> </a>
<a name="ln47">struct ripng_rte_data {</a>
<a name="ln48">  struct prefix_ipv6 *p;</a>
<a name="ln49">  struct ripng_info *rinfo;</a>
<a name="ln50">  struct ripng_aggregate *aggregate;</a>
<a name="ln51">};</a>
<a name="ln52"> </a>
<a name="ln53">void _ripng_rte_del(struct ripng_rte_data *A);</a>
<a name="ln54">int _ripng_rte_cmp(struct ripng_rte_data *A, struct ripng_rte_data *B);</a>
<a name="ln55"> </a>
<a name="ln56">#define METRIC_OUT(a) \</a>
<a name="ln57">    ((a)-&gt;rinfo ?  (a)-&gt;rinfo-&gt;metric_out : (a)-&gt;aggregate-&gt;metric_out)</a>
<a name="ln58">#define NEXTHOP_OUT_PTR(a) \</a>
<a name="ln59">    ((a)-&gt;rinfo ?  &amp;((a)-&gt;rinfo-&gt;nexthop_out) : &amp;((a)-&gt;aggregate-&gt;nexthop_out))</a>
<a name="ln60">#define TAG_OUT(a) \</a>
<a name="ln61">    ((a)-&gt;rinfo ?  (a)-&gt;rinfo-&gt;tag_out : (a)-&gt;aggregate-&gt;tag_out)</a>
<a name="ln62"> </a>
<a name="ln63">struct list *</a>
<a name="ln64">ripng_rte_new(void) {</a>
<a name="ln65">  struct list *rte;</a>
<a name="ln66"> </a>
<a name="ln67">  rte = list_new();</a>
<a name="ln68">  rte-&gt;cmp = (int (*)(void *, void *)) _ripng_rte_cmp;</a>
<a name="ln69">  rte-&gt;del = (void (*)(void *)) _ripng_rte_del;</a>
<a name="ln70"> </a>
<a name="ln71">  return rte;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">void</a>
<a name="ln75">ripng_rte_free(struct list *ripng_rte_list) {</a>
<a name="ln76">  list_delete(ripng_rte_list);</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">/* Delete RTE */</a>
<a name="ln80">void</a>
<a name="ln81">_ripng_rte_del(struct ripng_rte_data *A) {</a>
<a name="ln82">  XFREE(MTYPE_RIPNG_RTE_DATA, A);</a>
<a name="ln83">}</a>
<a name="ln84"> </a>
<a name="ln85">/* Compare RTE:</a>
<a name="ln86"> *  return +  if A &gt; B</a>
<a name="ln87"> *         0  if A = B</a>
<a name="ln88"> *         -  if A &lt; B</a>
<a name="ln89"> */</a>
<a name="ln90">int</a>
<a name="ln91">_ripng_rte_cmp(struct ripng_rte_data *A, struct ripng_rte_data *B) {</a>
<a name="ln92">  return addr6_cmp(NEXTHOP_OUT_PTR(A), NEXTHOP_OUT_PTR(B));</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95">/* Add routing table entry */</a>
<a name="ln96">void</a>
<a name="ln97">ripng_rte_add(struct list *ripng_rte_list, struct prefix_ipv6 *p,</a>
<a name="ln98">              struct ripng_info *rinfo, struct ripng_aggregate *aggregate) {</a>
<a name="ln99"> </a>
<a name="ln100">  struct ripng_rte_data *data;</a>
<a name="ln101"> </a>
<a name="ln102">  /* At least one should not be null */</a>
<a name="ln103">  assert(!rinfo || !aggregate);</a>
<a name="ln104"> </a>
<a name="ln105">  data = XMALLOC(MTYPE_RIPNG_RTE_DATA, sizeof(*data));</a>
<a name="ln106">  data-&gt;p     = p;</a>
<a name="ln107">  data-&gt;rinfo = rinfo;</a>
<a name="ln108">  data-&gt;aggregate = aggregate;</a>
<a name="ln109"> </a>
<a name="ln110">  listnode_add_sort(ripng_rte_list, data);</a>
<a name="ln111">} </a>
<a name="ln112"> </a>
<a name="ln113">/* Send the RTE with the nexthop support</a>
<a name="ln114"> */</a>
<a name="ln115">void</a>
<a name="ln116">ripng_rte_send(struct list *ripng_rte_list, struct interface *ifp,</a>
<a name="ln117">               struct sockaddr_in6 *to) {</a>
<a name="ln118"> </a>
<a name="ln119">  struct ripng_rte_data *data;</a>
<a name="ln120">  struct listnode *node, *nnode;</a>
<a name="ln121"> </a>
<a name="ln122">  struct in6_addr last_nexthop;</a>
<a name="ln123">  struct in6_addr myself_nexthop;</a>
<a name="ln124"> </a>
<a name="ln125">  struct stream *s;</a>
<a name="ln126">  int num;</a>
<a name="ln127">  int mtu;</a>
<a name="ln128">  int rtemax;</a>
<a name="ln129">  int ret;</a>
<a name="ln130"> </a>
<a name="ln131">  /* Most of the time, there is no nexthop */</a>
<a name="ln132">  memset(&amp;last_nexthop, 0, sizeof(last_nexthop));</a>
<a name="ln133"> </a>
<a name="ln134">  /* Use myself_nexthop if the nexthop is not a link-local address, because</a>
<a name="ln135">   * we remain a right path without beeing the optimal one.</a>
<a name="ln136">   */</a>
<a name="ln137">  memset(&amp;myself_nexthop, 0, sizeof(myself_nexthop));</a>
<a name="ln138"> </a>
<a name="ln139">  /* Output stream get from ripng structre.  XXX this should be</a>
<a name="ln140">     interface structure. */</a>
<a name="ln141">  s = ripng-&gt;obuf;</a>
<a name="ln142"> </a>
<a name="ln143">  /* Reset stream and RTE counter. */</a>
<a name="ln144">  stream_reset (s);</a>
<a name="ln145">  num = 0;</a>
<a name="ln146"> </a>
<a name="ln147">  mtu = ifp-&gt;mtu6;</a>
<a name="ln148">  if (mtu &lt; 0)</a>
<a name="ln149">    mtu = IFMINMTU;</a>
<a name="ln150"> </a>
<a name="ln151">  rtemax = (min (mtu, RIPNG_MAX_PACKET_SIZE) -</a>
<a name="ln152">	    IPV6_HDRLEN - </a>
<a name="ln153">	    sizeof (struct udphdr) -</a>
<a name="ln154">	    sizeof (struct ripng_packet) +</a>
<a name="ln155">	    sizeof (struct rte)) / sizeof (struct rte);</a>
<a name="ln156"> </a>
<a name="ln157">  for (ALL_LIST_ELEMENTS (ripng_rte_list, node, nnode, data)) {</a>
<a name="ln158">    /* (2.1) Next hop support */</a>
<a name="ln159">    if (!IPV6_ADDR_SAME(&amp;last_nexthop, NEXTHOP_OUT_PTR(data))) {</a>
<a name="ln160"> </a>
<a name="ln161">      /* A nexthop entry should be at least followed by 1 RTE */</a>
<a name="ln162">      if (num == (rtemax-1)) {</a>
<a name="ln163">	ret = ripng_send_packet ((caddr_t) STREAM_DATA (s), stream_get_endp (s),</a>
<a name="ln164">				 to, ifp);</a>
<a name="ln165"> </a>
<a name="ln166">        if (ret &gt;= 0 &amp;&amp; IS_RIPNG_DEBUG_SEND)</a>
<a name="ln167">          ripng_packet_dump((struct ripng_packet *)STREAM_DATA (s),</a>
<a name="ln168">			    stream_get_endp(s), &quot;SEND&quot;);</a>
<a name="ln169">        num = 0;</a>
<a name="ln170">        stream_reset (s);</a>
<a name="ln171">      }</a>
<a name="ln172"> </a>
<a name="ln173">      /* Add the nexthop (2.1) */</a>
<a name="ln174"> </a>
<a name="ln175">      /* If the received next hop address is not a link-local address,</a>
<a name="ln176">       * it should be treated as 0:0:0:0:0:0:0:0.</a>
<a name="ln177">       */</a>
<a name="ln178">      if (!IN6_IS_ADDR_LINKLOCAL(NEXTHOP_OUT_PTR(data)))</a>
<a name="ln179">        last_nexthop = myself_nexthop;</a>
<a name="ln180">      else</a>
<a name="ln181">	last_nexthop = *NEXTHOP_OUT_PTR(data);</a>
<a name="ln182"> </a>
<a name="ln183">      num = ripng_write_rte(num, s, NULL, &amp;last_nexthop, 0, RIPNG_METRIC_NEXTHOP);</a>
<a name="ln184">    } else {</a>
<a name="ln185">      /* Rewrite the nexthop for each new packet */</a>
<a name="ln186">      if ((num == 0) &amp;&amp; !IPV6_ADDR_SAME(&amp;last_nexthop, &amp;myself_nexthop))</a>
<a name="ln187">        num = ripng_write_rte(num, s, NULL, &amp;last_nexthop, 0, RIPNG_METRIC_NEXTHOP);</a>
<a name="ln188">    }</a>
<a name="ln189">    num = ripng_write_rte(num, s, data-&gt;p, NULL,</a>
<a name="ln190">			  TAG_OUT(data), METRIC_OUT(data));</a>
<a name="ln191"> </a>
<a name="ln192">    if (num == rtemax) {</a>
<a name="ln193">      ret = ripng_send_packet ((caddr_t) STREAM_DATA (s), stream_get_endp (s),</a>
<a name="ln194">			       to, ifp);</a>
<a name="ln195"> </a>
<a name="ln196">      if (ret &gt;= 0 &amp;&amp; IS_RIPNG_DEBUG_SEND)</a>
<a name="ln197">        ripng_packet_dump((struct ripng_packet *)STREAM_DATA (s),</a>
<a name="ln198">			  stream_get_endp(s), &quot;SEND&quot;);</a>
<a name="ln199">      num = 0;</a>
<a name="ln200">      stream_reset (s);</a>
<a name="ln201">    }</a>
<a name="ln202">  }</a>
<a name="ln203"> </a>
<a name="ln204">  /* If unwritten RTE exist, flush it. */</a>
<a name="ln205">  if (num != 0) {</a>
<a name="ln206">    ret = ripng_send_packet ((caddr_t) STREAM_DATA (s), stream_get_endp (s),</a>
<a name="ln207">			     to, ifp);</a>
<a name="ln208"> </a>
<a name="ln209">    if (ret &gt;= 0 &amp;&amp; IS_RIPNG_DEBUG_SEND)</a>
<a name="ln210">      ripng_packet_dump ((struct ripng_packet *)STREAM_DATA (s),</a>
<a name="ln211">			 stream_get_endp (s), &quot;SEND&quot;);</a>
<a name="ln212">    stream_reset (s);</a>
<a name="ln213">  }</a>
<a name="ln214">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
