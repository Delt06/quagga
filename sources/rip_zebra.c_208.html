
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>rip_zebra.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* RIPd and zebra interface.</a>
<a name="ln2"> * Copyright (C) 1997, 1999 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;command.h&quot;</a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;table.h&quot;</a>
<a name="ln27">#include &quot;stream.h&quot;</a>
<a name="ln28">#include &quot;memory.h&quot;</a>
<a name="ln29">#include &quot;routemap.h&quot;</a>
<a name="ln30">#include &quot;zclient.h&quot;</a>
<a name="ln31">#include &quot;log.h&quot;</a>
<a name="ln32">#include &quot;vrf.h&quot;</a>
<a name="ln33">#include &quot;ripd/ripd.h&quot;</a>
<a name="ln34">#include &quot;ripd/rip_debug.h&quot;</a>
<a name="ln35">#include &quot;ripd/rip_interface.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">/* All information about zebra. */</a>
<a name="ln38">struct zclient *zclient = NULL;</a>
<a name="ln39"> </a>
<a name="ln40">/* Send ECMP routes to zebra. */</a>
<a name="ln41">static void</a>
<a name="ln42">rip_zebra_ipv4_send (struct route_node *rp, u_char cmd)</a>
<a name="ln43">{</a>
<a name="ln44">  static struct in_addr **nexthops = NULL;</a>
<a name="ln45">  static unsigned int nexthops_len = 0;</a>
<a name="ln46"> </a>
<a name="ln47">  struct list *list = (struct list *)rp-&gt;info;</a>
<a name="ln48">  struct zapi_ipv4 api;</a>
<a name="ln49">  struct listnode *listnode = NULL;</a>
<a name="ln50">  struct rip_info *rinfo = NULL;</a>
<a name="ln51">  int count = 0;</a>
<a name="ln52"> </a>
<a name="ln53">  if (vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_RIP], VRF_DEFAULT))</a>
<a name="ln54">    {</a>
<a name="ln55">      api.vrf_id = VRF_DEFAULT;</a>
<a name="ln56">      api.type = ZEBRA_ROUTE_RIP;</a>
<a name="ln57">      api.flags = 0;</a>
<a name="ln58">      api.message = 0;</a>
<a name="ln59">      api.safi = SAFI_UNICAST;</a>
<a name="ln60"> </a>
<a name="ln61">      if (nexthops_len &lt; listcount (list))</a>
<a name="ln62">        {</a>
<a name="ln63">          nexthops_len = listcount (list);</a>
<a name="ln64">          nexthops = XREALLOC (MTYPE_TMP, nexthops,</a>
<a name="ln65">                               nexthops_len * sizeof (struct in_addr *));</a>
<a name="ln66">        }</a>
<a name="ln67"> </a>
<a name="ln68">      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln69">      for (ALL_LIST_ELEMENTS_RO (list, listnode, rinfo))</a>
<a name="ln70">        {</a>
<a name="ln71">          nexthops[count++] = &amp;rinfo-&gt;nexthop;</a>
<a name="ln72">          if (cmd == ZEBRA_IPV4_ROUTE_ADD)</a>
<a name="ln73">            SET_FLAG (rinfo-&gt;flags, RIP_RTF_FIB);</a>
<a name="ln74">          else</a>
<a name="ln75">            UNSET_FLAG (rinfo-&gt;flags, RIP_RTF_FIB);</a>
<a name="ln76">        }</a>
<a name="ln77"> </a>
<a name="ln78">      api.nexthop = nexthops;</a>
<a name="ln79">      api.nexthop_num = count;</a>
<a name="ln80">      api.ifindex_num = 0;</a>
<a name="ln81"> </a>
<a name="ln82">      rinfo = listgetdata (listhead (list));</a>
<a name="ln83"> </a>
<a name="ln84">      SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);</a>
<a name="ln85">      api.metric = rinfo-&gt;metric;</a>
<a name="ln86"> </a>
<a name="ln87">      if (rinfo-&gt;distance &amp;&amp; rinfo-&gt;distance != ZEBRA_RIP_DISTANCE_DEFAULT)</a>
<a name="ln88">        {</a>
<a name="ln89">          SET_FLAG (api.message, ZAPI_MESSAGE_DISTANCE);</a>
<a name="ln90">          api.distance = rinfo-&gt;distance;</a>
<a name="ln91">        }</a>
<a name="ln92"> </a>
<a name="ln93">      if (rinfo-&gt;tag)</a>
<a name="ln94">        {</a>
<a name="ln95">          SET_FLAG (api.message, ZAPI_MESSAGE_TAG);</a>
<a name="ln96">          api.tag = rinfo-&gt;tag;</a>
<a name="ln97">        }</a>
<a name="ln98"> </a>
<a name="ln99">      zapi_ipv4_route (cmd, zclient,</a>
<a name="ln100">                       (struct prefix_ipv4 *)&amp;rp-&gt;p, &amp;api);</a>
<a name="ln101"> </a>
<a name="ln102">      if (IS_RIP_DEBUG_ZEBRA)</a>
<a name="ln103">        {</a>
<a name="ln104">          if (rip-&gt;ecmp)</a>
<a name="ln105">            zlog_debug (&quot;%s: %s/%d nexthops %d&quot;,</a>
<a name="ln106">                        (cmd == ZEBRA_IPV4_ROUTE_ADD) ? \</a>
<a name="ln107">                            &quot;Install into zebra&quot; : &quot;Delete from zebra&quot;,</a>
<a name="ln108">                        inet_ntoa (rp-&gt;p.u.prefix4), rp-&gt;p.prefixlen, count);</a>
<a name="ln109">          else</a>
<a name="ln110">            zlog_debug (&quot;%s: %s/%d&quot;,</a>
<a name="ln111">                        (cmd == ZEBRA_IPV4_ROUTE_ADD) ? \</a>
<a name="ln112">                            &quot;Install into zebra&quot; : &quot;Delete from zebra&quot;,</a>
<a name="ln113">                        inet_ntoa (rp-&gt;p.u.prefix4), rp-&gt;p.prefixlen);</a>
<a name="ln114">        }</a>
<a name="ln115"> </a>
<a name="ln116">      rip_global_route_changes++;</a>
<a name="ln117">    }</a>
<a name="ln118">}</a>
<a name="ln119"> </a>
<a name="ln120">/* Add/update ECMP routes to zebra. */</a>
<a name="ln121">void</a>
<a name="ln122">rip_zebra_ipv4_add (struct route_node *rp)</a>
<a name="ln123">{</a>
<a name="ln124">  rip_zebra_ipv4_send (rp, ZEBRA_IPV4_ROUTE_ADD);</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">/* Delete ECMP routes from zebra. */</a>
<a name="ln128">void</a>
<a name="ln129">rip_zebra_ipv4_delete (struct route_node *rp)</a>
<a name="ln130">{</a>
<a name="ln131">  rip_zebra_ipv4_send (rp, ZEBRA_IPV4_ROUTE_DELETE);</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">/* Zebra route add and delete treatment. */</a>
<a name="ln135">static int</a>
<a name="ln136">rip_zebra_read_ipv4 (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln137">    vrf_id_t vrf_id)</a>
<a name="ln138">{</a>
<a name="ln139">  struct stream *s;</a>
<a name="ln140">  struct zapi_ipv4 api;</a>
<a name="ln141">  unsigned long ifindex;</a>
<a name="ln142">  struct in_addr nexthop;</a>
<a name="ln143">  struct prefix_ipv4 p;</a>
<a name="ln144">  unsigned char plength = 0;</a>
<a name="ln145"> </a>
<a name="ln146">  s = zclient-&gt;ibuf;</a>
<a name="ln147">  ifindex = 0;</a>
<a name="ln148">  nexthop.s_addr = 0;</a>
<a name="ln149"> </a>
<a name="ln150">  /* Type, flags, message. */</a>
<a name="ln151">  api.type = stream_getc (s);</a>
<a name="ln152">  api.flags = stream_getc (s);</a>
<a name="ln153">  api.message = stream_getc (s);</a>
<a name="ln154"> </a>
<a name="ln155">  /* IPv4 prefix. */</a>
<a name="ln156">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln157">  p.family = AF_INET;</a>
<a name="ln158">  plength = stream_getc (s);</a>
<a name="ln159">  p.prefixlen = MIN(IPV4_MAX_PREFIXLEN, plength);</a>
<a name="ln160">  stream_get (&amp;p.prefix, s, PSIZE (p.prefixlen));</a>
<a name="ln161"> </a>
<a name="ln162">  /* Nexthop, ifindex, distance, metric. */</a>
<a name="ln163">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln164">    {</a>
<a name="ln165">      api.nexthop_num = stream_getc (s);</a>
<a name="ln166">      nexthop.s_addr = stream_get_ipv4 (s);</a>
<a name="ln167">    }</a>
<a name="ln168">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))</a>
<a name="ln169">    {</a>
<a name="ln170">      api.ifindex_num = stream_getc (s);</a>
<a name="ln171">      ifindex = stream_getl (s);</a>
<a name="ln172">    }</a>
<a name="ln173">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln174">    api.distance = stream_getc (s);</a>
<a name="ln175">  else</a>
<a name="ln176">    api.distance = 255;</a>
<a name="ln177">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln178">    api.metric = stream_getl (s);</a>
<a name="ln179">  else</a>
<a name="ln180">    api.metric = 0;</a>
<a name="ln181"> </a>
<a name="ln182">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_TAG))</a>
<a name="ln183">    api.tag = stream_getl (s);</a>
<a name="ln184">  else</a>
<a name="ln185">    api.tag = 0;</a>
<a name="ln186"> </a>
<a name="ln187">  /* Then fetch IPv4 prefixes. */</a>
<a name="ln188">  if (command == ZEBRA_IPV4_ROUTE_ADD)</a>
<a name="ln189">    rip_redistribute_add (api.type, RIP_ROUTE_REDISTRIBUTE, &amp;p, ifindex, </a>
<a name="ln190">                          &amp;nexthop, api.metric, api.distance, api.tag);</a>
<a name="ln191">  else</a>
<a name="ln192">    rip_redistribute_delete (api.type, RIP_ROUTE_REDISTRIBUTE, &amp;p, ifindex);</a>
<a name="ln193"> </a>
<a name="ln194">  return 0;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">void</a>
<a name="ln198">rip_zclient_reset (void)</a>
<a name="ln199">{</a>
<a name="ln200">  zclient_reset (zclient);</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">/* RIP route-map set for redistribution */</a>
<a name="ln204">static void</a>
<a name="ln205">rip_routemap_set (int type, const char *name)</a>
<a name="ln206">{</a>
<a name="ln207">  if (rip-&gt;route_map[type].name)</a>
<a name="ln208">    free(rip-&gt;route_map[type].name);</a>
<a name="ln209"> </a>
<a name="ln210">  rip-&gt;route_map[type].name = strdup (name);</a>
<a name="ln211">  rip-&gt;route_map[type].map = route_map_lookup_by_name (name);</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">static void</a>
<a name="ln215">rip_redistribute_metric_set (int type, unsigned int metric)</a>
<a name="ln216">{</a>
<a name="ln217">  rip-&gt;route_map[type].metric_config = 1;</a>
<a name="ln218">  rip-&gt;route_map[type].metric = metric;</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">static int</a>
<a name="ln222">rip_metric_unset (int type, unsigned int metric)</a>
<a name="ln223">{</a>
<a name="ln224">#define DONT_CARE_METRIC_RIP 17  </a>
<a name="ln225">  if (metric != DONT_CARE_METRIC_RIP &amp;&amp;</a>
<a name="ln226">      rip-&gt;route_map[type].metric != metric)</a>
<a name="ln227">    return 1;</a>
<a name="ln228">  rip-&gt;route_map[type].metric_config = 0;</a>
<a name="ln229">  rip-&gt;route_map[type].metric = 0;</a>
<a name="ln230">  return 0;</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">/* RIP route-map unset for redistribution */</a>
<a name="ln234">static int</a>
<a name="ln235">rip_routemap_unset (int type, const char *name)</a>
<a name="ln236">{</a>
<a name="ln237">  if (! rip-&gt;route_map[type].name ||</a>
<a name="ln238">      (name != NULL &amp;&amp; strcmp(rip-&gt;route_map[type].name,name)))</a>
<a name="ln239">    return 1;</a>
<a name="ln240"> </a>
<a name="ln241">  free (rip-&gt;route_map[type].name);</a>
<a name="ln242">  rip-&gt;route_map[type].name = NULL;</a>
<a name="ln243">  rip-&gt;route_map[type].map = NULL;</a>
<a name="ln244"> </a>
<a name="ln245">  return 0;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">/* Redistribution types */</a>
<a name="ln249">static struct {</a>
<a name="ln250">  int type;</a>
<a name="ln251">  int str_min_len;</a>
<a name="ln252">  const char *str;</a>
<a name="ln253">} redist_type[] = {</a>
<a name="ln254">  {ZEBRA_ROUTE_KERNEL,  1, &quot;kernel&quot;},</a>
<a name="ln255">  {ZEBRA_ROUTE_CONNECT, 1, &quot;connected&quot;},</a>
<a name="ln256">  {ZEBRA_ROUTE_STATIC,  1, &quot;static&quot;},</a>
<a name="ln257">  {ZEBRA_ROUTE_OSPF,    1, &quot;ospf&quot;},</a>
<a name="ln258">  {ZEBRA_ROUTE_BGP,     2, &quot;bgp&quot;},</a>
<a name="ln259">  {ZEBRA_ROUTE_BABEL,   2, &quot;babel&quot;},</a>
<a name="ln260">  {0, 0, NULL}</a>
<a name="ln261">};</a>
<a name="ln262"> </a>
<a name="ln263">DEFUN (router_zebra,</a>
<a name="ln264">       router_zebra_cmd,</a>
<a name="ln265">       &quot;router zebra&quot;,</a>
<a name="ln266">       &quot;Enable a routing process\n&quot;</a>
<a name="ln267">       &quot;Make connection to zebra daemon\n&quot;)</a>
<a name="ln268">{</a>
<a name="ln269">  vty-&gt;node = ZEBRA_NODE;</a>
<a name="ln270">  zclient-&gt;enable = 1;</a>
<a name="ln271">  zclient_start (zclient);</a>
<a name="ln272">  return CMD_SUCCESS;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">DEFUN (no_router_zebra,</a>
<a name="ln276">       no_router_zebra_cmd,</a>
<a name="ln277">       &quot;no router zebra&quot;,</a>
<a name="ln278">       NO_STR</a>
<a name="ln279">       &quot;Enable a routing process\n&quot;</a>
<a name="ln280">       &quot;Make connection to zebra daemon\n&quot;)</a>
<a name="ln281">{</a>
<a name="ln282">  zclient-&gt;enable = 0;</a>
<a name="ln283">  zclient_stop (zclient);</a>
<a name="ln284">  return CMD_SUCCESS;</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">#if 0</a>
<a name="ln288">static int</a>
<a name="ln289">rip_redistribute_set (int type)</a>
<a name="ln290">{</a>
<a name="ln291">  if (vrf_bitmap_check (zclient-&gt;redist[type], VRF_DEFAULT))</a>
<a name="ln292">    return CMD_SUCCESS;</a>
<a name="ln293"> </a>
<a name="ln294">  vrf_bitmap_set (zclient-&gt;redist[type], VRF_DEFAULT);</a>
<a name="ln295"> </a>
<a name="ln296">  if (zclient-&gt;sock &gt; 0)</a>
<a name="ln297">    zebra_redistribute_send (ZEBRA_REDISTRIBUTE_ADD, zclient, type);</a>
<a name="ln298"> </a>
<a name="ln299">  return CMD_SUCCESS;</a>
<a name="ln300">}</a>
<a name="ln301">#endif</a>
<a name="ln302"> </a>
<a name="ln303">static int</a>
<a name="ln304">rip_redistribute_unset (int type)</a>
<a name="ln305">{</a>
<a name="ln306">  if (! vrf_bitmap_check (zclient-&gt;redist[type], VRF_DEFAULT))</a>
<a name="ln307">    return CMD_SUCCESS;</a>
<a name="ln308"> </a>
<a name="ln309">  vrf_bitmap_unset (zclient-&gt;redist[type], VRF_DEFAULT);</a>
<a name="ln310"> </a>
<a name="ln311">  if (zclient-&gt;sock &gt; 0)</a>
<a name="ln312">    zebra_redistribute_send (ZEBRA_REDISTRIBUTE_DELETE, zclient, type,</a>
<a name="ln313">                             VRF_DEFAULT);</a>
<a name="ln314"> </a>
<a name="ln315">  /* Remove the routes from RIP table. */</a>
<a name="ln316">  rip_redistribute_withdraw (type);</a>
<a name="ln317"> </a>
<a name="ln318">  return CMD_SUCCESS;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">int</a>
<a name="ln322">rip_redistribute_check (int type)</a>
<a name="ln323">{</a>
<a name="ln324">  return vrf_bitmap_check (zclient-&gt;redist[type], VRF_DEFAULT);</a>
<a name="ln325">}</a>
<a name="ln326"> </a>
<a name="ln327">void</a>
<a name="ln328">rip_redistribute_clean (void)</a>
<a name="ln329">{</a>
<a name="ln330">  int i;</a>
<a name="ln331"> </a>
<a name="ln332">  for (i = 0; redist_type[i].str; i++)</a>
<a name="ln333">    {</a>
<a name="ln334">      if (vrf_bitmap_check (zclient-&gt;redist[redist_type[i].type], VRF_DEFAULT))</a>
<a name="ln335">	{</a>
<a name="ln336">	  if (zclient-&gt;sock &gt; 0)</a>
<a name="ln337">	    zebra_redistribute_send (ZEBRA_REDISTRIBUTE_DELETE,</a>
<a name="ln338">				     zclient, redist_type[i].type,</a>
<a name="ln339">				     VRF_DEFAULT);</a>
<a name="ln340"> </a>
<a name="ln341">	  vrf_bitmap_unset (zclient-&gt;redist[redist_type[i].type], VRF_DEFAULT);</a>
<a name="ln342"> </a>
<a name="ln343">	  /* Remove the routes from RIP table. */</a>
<a name="ln344">	  rip_redistribute_withdraw (redist_type[i].type);</a>
<a name="ln345">	}</a>
<a name="ln346">    }</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">DEFUN (rip_redistribute_rip,</a>
<a name="ln350">       rip_redistribute_rip_cmd,</a>
<a name="ln351">       &quot;redistribute rip&quot;,</a>
<a name="ln352">       &quot;Redistribute information from another routing protocol\n&quot;</a>
<a name="ln353">       &quot;Routing Information Protocol (RIP)\n&quot;)</a>
<a name="ln354">{</a>
<a name="ln355">  vrf_bitmap_set (zclient-&gt;redist[ZEBRA_ROUTE_RIP], VRF_DEFAULT);</a>
<a name="ln356">  return CMD_SUCCESS;</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">DEFUN (no_rip_redistribute_rip,</a>
<a name="ln360">       no_rip_redistribute_rip_cmd,</a>
<a name="ln361">       &quot;no redistribute rip&quot;,</a>
<a name="ln362">       NO_STR</a>
<a name="ln363">       &quot;Redistribute information from another routing protocol\n&quot;</a>
<a name="ln364">       &quot;Routing Information Protocol (RIP)\n&quot;)</a>
<a name="ln365">{</a>
<a name="ln366">  vrf_bitmap_unset (zclient-&gt;redist[ZEBRA_ROUTE_RIP], VRF_DEFAULT);</a>
<a name="ln367">  return CMD_SUCCESS;</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">DEFUN (rip_redistribute_type,</a>
<a name="ln371">       rip_redistribute_type_cmd,</a>
<a name="ln372">       &quot;redistribute &quot; QUAGGA_REDIST_STR_RIPD,</a>
<a name="ln373">       REDIST_STR</a>
<a name="ln374">       QUAGGA_REDIST_HELP_STR_RIPD)</a>
<a name="ln375">{</a>
<a name="ln376">  int i;</a>
<a name="ln377"> </a>
<a name="ln378">  for(i = 0; redist_type[i].str; i++) </a>
<a name="ln379">    {</a>
<a name="ln380">      if (strncmp (redist_type[i].str, argv[0], </a>
<a name="ln381">		   redist_type[i].str_min_len) == 0) </a>
<a name="ln382">	{</a>
<a name="ln383">	  zclient_redistribute (ZEBRA_REDISTRIBUTE_ADD, zclient, </a>
<a name="ln384">	                        redist_type[i].type, VRF_DEFAULT);</a>
<a name="ln385">	  return CMD_SUCCESS;</a>
<a name="ln386">	}</a>
<a name="ln387">    }</a>
<a name="ln388"> </a>
<a name="ln389">  vty_out(vty, &quot;Invalid type %s%s&quot;, argv[0],</a>
<a name="ln390">	  VTY_NEWLINE);</a>
<a name="ln391"> </a>
<a name="ln392">  return CMD_WARNING;</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">DEFUN (no_rip_redistribute_type,</a>
<a name="ln396">       no_rip_redistribute_type_cmd,</a>
<a name="ln397">       &quot;no redistribute &quot; QUAGGA_REDIST_STR_RIPD,</a>
<a name="ln398">       NO_STR</a>
<a name="ln399">       REDIST_STR</a>
<a name="ln400">       QUAGGA_REDIST_HELP_STR_RIPD)</a>
<a name="ln401">{</a>
<a name="ln402">  int i;</a>
<a name="ln403"> </a>
<a name="ln404">  for (i = 0; redist_type[i].str; i++) </a>
<a name="ln405">    {</a>
<a name="ln406">      if (strncmp(redist_type[i].str, argv[0], </a>
<a name="ln407">		  redist_type[i].str_min_len) == 0) </a>
<a name="ln408">	{</a>
<a name="ln409">	  rip_metric_unset (redist_type[i].type, DONT_CARE_METRIC_RIP);</a>
<a name="ln410">	  rip_routemap_unset (redist_type[i].type,NULL);</a>
<a name="ln411">	  rip_redistribute_unset (redist_type[i].type);</a>
<a name="ln412">	  return CMD_SUCCESS;</a>
<a name="ln413">        }</a>
<a name="ln414">    }</a>
<a name="ln415"> </a>
<a name="ln416">  vty_out(vty, &quot;Invalid type %s%s&quot;, argv[0],</a>
<a name="ln417">	  VTY_NEWLINE);</a>
<a name="ln418"> </a>
<a name="ln419">  return CMD_WARNING;</a>
<a name="ln420">}</a>
<a name="ln421"> </a>
<a name="ln422">DEFUN (rip_redistribute_type_routemap,</a>
<a name="ln423">       rip_redistribute_type_routemap_cmd,</a>
<a name="ln424">       &quot;redistribute &quot; QUAGGA_REDIST_STR_RIPD &quot; route-map WORD&quot;,</a>
<a name="ln425">       REDIST_STR</a>
<a name="ln426">       QUAGGA_REDIST_HELP_STR_RIPD</a>
<a name="ln427">       &quot;Route map reference\n&quot;</a>
<a name="ln428">       &quot;Pointer to route-map entries\n&quot;)</a>
<a name="ln429">{</a>
<a name="ln430">  int i;</a>
<a name="ln431"> </a>
<a name="ln432">  for (i = 0; redist_type[i].str; i++) {</a>
<a name="ln433">    if (strncmp(redist_type[i].str, argv[0],</a>
<a name="ln434">		redist_type[i].str_min_len) == 0) </a>
<a name="ln435">      {</a>
<a name="ln436">	rip_routemap_set (redist_type[i].type, argv[1]);</a>
<a name="ln437">	zclient_redistribute (ZEBRA_REDISTRIBUTE_ADD, zclient, redist_type[i].type,</a>
<a name="ln438">	                      VRF_DEFAULT);</a>
<a name="ln439">	return CMD_SUCCESS;</a>
<a name="ln440">      }</a>
<a name="ln441">  }</a>
<a name="ln442"> </a>
<a name="ln443">  vty_out(vty, &quot;Invalid type %s%s&quot;, argv[0],</a>
<a name="ln444">	  VTY_NEWLINE);</a>
<a name="ln445"> </a>
<a name="ln446">  return CMD_WARNING;</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">DEFUN (no_rip_redistribute_type_routemap,</a>
<a name="ln450">       no_rip_redistribute_type_routemap_cmd,</a>
<a name="ln451">       &quot;no redistribute &quot; QUAGGA_REDIST_STR_RIPD &quot; route-map WORD&quot;,</a>
<a name="ln452">       NO_STR</a>
<a name="ln453">       REDIST_STR</a>
<a name="ln454">       QUAGGA_REDIST_HELP_STR_RIPD</a>
<a name="ln455">       &quot;Route map reference\n&quot;</a>
<a name="ln456">       &quot;Pointer to route-map entries\n&quot;)</a>
<a name="ln457">{</a>
<a name="ln458">  int i;</a>
<a name="ln459"> </a>
<a name="ln460">  for (i = 0; redist_type[i].str; i++) </a>
<a name="ln461">    {</a>
<a name="ln462">      if (strncmp(redist_type[i].str, argv[0], </a>
<a name="ln463">		  redist_type[i].str_min_len) == 0) </a>
<a name="ln464">	{</a>
<a name="ln465">	  if (rip_routemap_unset (redist_type[i].type,argv[1]))</a>
<a name="ln466">	    return CMD_WARNING;</a>
<a name="ln467">	  rip_redistribute_unset (redist_type[i].type);</a>
<a name="ln468">	  return CMD_SUCCESS;</a>
<a name="ln469">        }</a>
<a name="ln470">    }</a>
<a name="ln471"> </a>
<a name="ln472">  vty_out(vty, &quot;Invalid type %s%s&quot;, argv[0],</a>
<a name="ln473">	  VTY_NEWLINE);</a>
<a name="ln474"> </a>
<a name="ln475">  return CMD_WARNING;</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">DEFUN (rip_redistribute_type_metric,</a>
<a name="ln479">       rip_redistribute_type_metric_cmd,</a>
<a name="ln480">       &quot;redistribute &quot; QUAGGA_REDIST_STR_RIPD &quot; metric &lt;0-16&gt;&quot;,</a>
<a name="ln481">       REDIST_STR</a>
<a name="ln482">       QUAGGA_REDIST_HELP_STR_RIPD</a>
<a name="ln483">       &quot;Metric\n&quot;</a>
<a name="ln484">       &quot;Metric value\n&quot;)</a>
<a name="ln485">{</a>
<a name="ln486">  int i;</a>
<a name="ln487">  int metric;</a>
<a name="ln488"> </a>
<a name="ln489">  metric = atoi (argv[1]);</a>
<a name="ln490"> </a>
<a name="ln491">  for (i = 0; redist_type[i].str; i++) {</a>
<a name="ln492">    if (strncmp(redist_type[i].str, argv[0],</a>
<a name="ln493">		redist_type[i].str_min_len) == 0) </a>
<a name="ln494">      {</a>
<a name="ln495">	rip_redistribute_metric_set (redist_type[i].type, metric);</a>
<a name="ln496">	zclient_redistribute (ZEBRA_REDISTRIBUTE_ADD, zclient, redist_type[i].type,</a>
<a name="ln497">	                      VRF_DEFAULT);</a>
<a name="ln498">	return CMD_SUCCESS;</a>
<a name="ln499">      }</a>
<a name="ln500">  }</a>
<a name="ln501"> </a>
<a name="ln502">  vty_out(vty, &quot;Invalid type %s%s&quot;, argv[0],</a>
<a name="ln503">	  VTY_NEWLINE);</a>
<a name="ln504"> </a>
<a name="ln505">  return CMD_WARNING;</a>
<a name="ln506">}</a>
<a name="ln507"> </a>
<a name="ln508">DEFUN (no_rip_redistribute_type_metric,</a>
<a name="ln509">       no_rip_redistribute_type_metric_cmd,</a>
<a name="ln510">       &quot;no redistribute &quot; QUAGGA_REDIST_STR_RIPD &quot; metric &lt;0-16&gt;&quot;,</a>
<a name="ln511">       NO_STR</a>
<a name="ln512">       REDIST_STR</a>
<a name="ln513">       QUAGGA_REDIST_HELP_STR_RIPD</a>
<a name="ln514">       &quot;Metric\n&quot;</a>
<a name="ln515">       &quot;Metric value\n&quot;)</a>
<a name="ln516">{</a>
<a name="ln517">  int i;</a>
<a name="ln518"> </a>
<a name="ln519">  for (i = 0; redist_type[i].str; i++) </a>
<a name="ln520">    {</a>
<a name="ln521">      if (strncmp(redist_type[i].str, argv[0], </a>
<a name="ln522">		  redist_type[i].str_min_len) == 0) </a>
<a name="ln523">	{</a>
<a name="ln524">	  if (rip_metric_unset (redist_type[i].type, atoi(argv[1])))</a>
<a name="ln525">	    return CMD_WARNING;</a>
<a name="ln526">	  rip_redistribute_unset (redist_type[i].type);</a>
<a name="ln527">	  return CMD_SUCCESS;</a>
<a name="ln528">        }</a>
<a name="ln529">    }</a>
<a name="ln530"> </a>
<a name="ln531">  vty_out(vty, &quot;Invalid type %s%s&quot;, argv[0],</a>
<a name="ln532">	  VTY_NEWLINE);</a>
<a name="ln533"> </a>
<a name="ln534">  return CMD_WARNING;</a>
<a name="ln535">}</a>
<a name="ln536"> </a>
<a name="ln537">DEFUN (rip_redistribute_type_metric_routemap,</a>
<a name="ln538">       rip_redistribute_type_metric_routemap_cmd,</a>
<a name="ln539">       &quot;redistribute &quot; QUAGGA_REDIST_STR_RIPD &quot; metric &lt;0-16&gt; route-map WORD&quot;,</a>
<a name="ln540">       REDIST_STR</a>
<a name="ln541">       QUAGGA_REDIST_HELP_STR_RIPD</a>
<a name="ln542">       &quot;Metric\n&quot;</a>
<a name="ln543">       &quot;Metric value\n&quot;</a>
<a name="ln544">       &quot;Route map reference\n&quot;</a>
<a name="ln545">       &quot;Pointer to route-map entries\n&quot;)</a>
<a name="ln546">{</a>
<a name="ln547">  int i;</a>
<a name="ln548">  int metric;</a>
<a name="ln549"> </a>
<a name="ln550">  metric = atoi (argv[1]);</a>
<a name="ln551"> </a>
<a name="ln552">  for (i = 0; redist_type[i].str; i++) {</a>
<a name="ln553">    if (strncmp(redist_type[i].str, argv[0],</a>
<a name="ln554">		redist_type[i].str_min_len) == 0) </a>
<a name="ln555">      {</a>
<a name="ln556">	rip_redistribute_metric_set (redist_type[i].type, metric);</a>
<a name="ln557">	rip_routemap_set (redist_type[i].type, argv[2]);</a>
<a name="ln558">	zclient_redistribute (ZEBRA_REDISTRIBUTE_ADD, zclient, redist_type[i].type,</a>
<a name="ln559">	                      VRF_DEFAULT);</a>
<a name="ln560">	return CMD_SUCCESS;</a>
<a name="ln561">      }</a>
<a name="ln562">  }</a>
<a name="ln563"> </a>
<a name="ln564">  vty_out(vty, &quot;Invalid type %s%s&quot;, argv[0],</a>
<a name="ln565">	  VTY_NEWLINE);</a>
<a name="ln566"> </a>
<a name="ln567">  return CMD_WARNING;</a>
<a name="ln568">}</a>
<a name="ln569"> </a>
<a name="ln570"> </a>
<a name="ln571">DEFUN (no_rip_redistribute_type_metric_routemap,</a>
<a name="ln572">       no_rip_redistribute_type_metric_routemap_cmd,</a>
<a name="ln573">       &quot;no redistribute &quot; QUAGGA_REDIST_STR_RIPD</a>
<a name="ln574">       &quot; metric &lt;0-16&gt; route-map WORD&quot;,</a>
<a name="ln575">       NO_STR</a>
<a name="ln576">       REDIST_STR</a>
<a name="ln577">       QUAGGA_REDIST_HELP_STR_RIPD</a>
<a name="ln578">       &quot;Metric\n&quot;</a>
<a name="ln579">       &quot;Metric value\n&quot;</a>
<a name="ln580">       &quot;Route map reference\n&quot;</a>
<a name="ln581">       &quot;Pointer to route-map entries\n&quot;)</a>
<a name="ln582">{</a>
<a name="ln583">  int i;</a>
<a name="ln584"> </a>
<a name="ln585">  for (i = 0; redist_type[i].str; i++) </a>
<a name="ln586">    {</a>
<a name="ln587">      if (strncmp(redist_type[i].str, argv[0], </a>
<a name="ln588">		  redist_type[i].str_min_len) == 0) </a>
<a name="ln589">	{</a>
<a name="ln590">	  if (rip_metric_unset (redist_type[i].type, atoi(argv[1])))</a>
<a name="ln591">	    return CMD_WARNING;</a>
<a name="ln592">	  if (rip_routemap_unset (redist_type[i].type, argv[2]))</a>
<a name="ln593">	    {</a>
<a name="ln594">	      rip_redistribute_metric_set(redist_type[i].type, atoi(argv[1]));   </a>
<a name="ln595">	      return CMD_WARNING;</a>
<a name="ln596">	    }</a>
<a name="ln597">	  rip_redistribute_unset (redist_type[i].type);</a>
<a name="ln598">	  return CMD_SUCCESS;</a>
<a name="ln599">        }</a>
<a name="ln600">    }</a>
<a name="ln601"> </a>
<a name="ln602">  vty_out(vty, &quot;Invalid type %s%s&quot;, argv[0],</a>
<a name="ln603">	  VTY_NEWLINE);</a>
<a name="ln604"> </a>
<a name="ln605">  return CMD_WARNING;</a>
<a name="ln606">}</a>
<a name="ln607"> </a>
<a name="ln608">/* Default information originate. */</a>
<a name="ln609"> </a>
<a name="ln610">DEFUN (rip_default_information_originate,</a>
<a name="ln611">       rip_default_information_originate_cmd,</a>
<a name="ln612">       &quot;default-information originate&quot;,</a>
<a name="ln613">       &quot;Control distribution of default route\n&quot;</a>
<a name="ln614">       &quot;Distribute a default route\n&quot;)</a>
<a name="ln615">{</a>
<a name="ln616">  struct prefix_ipv4 p;</a>
<a name="ln617"> </a>
<a name="ln618">  if (! rip-&gt;default_information)</a>
<a name="ln619">    {</a>
<a name="ln620">      memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln621">      p.family = AF_INET;</a>
<a name="ln622"> </a>
<a name="ln623">      rip-&gt;default_information = 1;</a>
<a name="ln624">  </a>
<a name="ln625">      rip_redistribute_add (ZEBRA_ROUTE_RIP, RIP_ROUTE_DEFAULT, &amp;p, 0, </a>
<a name="ln626">                            NULL, 0, 0, 0);</a>
<a name="ln627">    }</a>
<a name="ln628"> </a>
<a name="ln629">  return CMD_SUCCESS;</a>
<a name="ln630">}</a>
<a name="ln631"> </a>
<a name="ln632">DEFUN (no_rip_default_information_originate,</a>
<a name="ln633">       no_rip_default_information_originate_cmd,</a>
<a name="ln634">       &quot;no default-information originate&quot;,</a>
<a name="ln635">       NO_STR</a>
<a name="ln636">       &quot;Control distribution of default route\n&quot;</a>
<a name="ln637">       &quot;Distribute a default route\n&quot;)</a>
<a name="ln638">{</a>
<a name="ln639">  struct prefix_ipv4 p;</a>
<a name="ln640"> </a>
<a name="ln641">  if (rip-&gt;default_information)</a>
<a name="ln642">    {</a>
<a name="ln643">      memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln644">      p.family = AF_INET;</a>
<a name="ln645"> </a>
<a name="ln646">      rip-&gt;default_information = 0;</a>
<a name="ln647">  </a>
<a name="ln648">      rip_redistribute_delete (ZEBRA_ROUTE_RIP, RIP_ROUTE_DEFAULT, &amp;p, 0);</a>
<a name="ln649">    }</a>
<a name="ln650"> </a>
<a name="ln651">  return CMD_SUCCESS;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">/* RIP configuration write function. */</a>
<a name="ln655">static int</a>
<a name="ln656">config_write_zebra (struct vty *vty)</a>
<a name="ln657">{</a>
<a name="ln658">  if (! zclient-&gt;enable)</a>
<a name="ln659">    {</a>
<a name="ln660">      vty_out (vty, &quot;no router zebra%s&quot;, VTY_NEWLINE);</a>
<a name="ln661">      return 1;</a>
<a name="ln662">    }</a>
<a name="ln663">  else if (! vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_RIP], VRF_DEFAULT))</a>
<a name="ln664">    {</a>
<a name="ln665">      vty_out (vty, &quot;router zebra%s&quot;, VTY_NEWLINE);</a>
<a name="ln666">      vty_out (vty, &quot; no redistribute rip%s&quot;, VTY_NEWLINE);</a>
<a name="ln667">      return 1;</a>
<a name="ln668">    }</a>
<a name="ln669">  return 0;</a>
<a name="ln670">}</a>
<a name="ln671"> </a>
<a name="ln672">int</a>
<a name="ln673">config_write_rip_redistribute (struct vty *vty, int config_mode)</a>
<a name="ln674">{</a>
<a name="ln675">  int i;</a>
<a name="ln676"> </a>
<a name="ln677">  for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln678">    if (i != zclient-&gt;redist_default &amp;&amp;</a>
<a name="ln679">        vrf_bitmap_check (zclient-&gt;redist[i], VRF_DEFAULT))</a>
<a name="ln680">      {</a>
<a name="ln681">	if (config_mode)</a>
<a name="ln682">	  {</a>
<a name="ln683">	    if (rip-&gt;route_map[i].metric_config)</a>
<a name="ln684">	      {</a>
<a name="ln685">		if (rip-&gt;route_map[i].name)</a>
<a name="ln686">		  vty_out (vty, &quot; redistribute %s metric %d route-map %s%s&quot;,</a>
<a name="ln687">			   zebra_route_string(i), rip-&gt;route_map[i].metric,</a>
<a name="ln688">			   rip-&gt;route_map[i].name,</a>
<a name="ln689">			   VTY_NEWLINE);</a>
<a name="ln690">		else</a>
<a name="ln691">		  vty_out (vty, &quot; redistribute %s metric %d%s&quot;,</a>
<a name="ln692">			   zebra_route_string(i), rip-&gt;route_map[i].metric,</a>
<a name="ln693">			   VTY_NEWLINE);</a>
<a name="ln694">	      }</a>
<a name="ln695">	    else</a>
<a name="ln696">	      {</a>
<a name="ln697">		if (rip-&gt;route_map[i].name)</a>
<a name="ln698">		  vty_out (vty, &quot; redistribute %s route-map %s%s&quot;,</a>
<a name="ln699">			   zebra_route_string(i), rip-&gt;route_map[i].name,</a>
<a name="ln700">			   VTY_NEWLINE);</a>
<a name="ln701">		else</a>
<a name="ln702">		  vty_out (vty, &quot; redistribute %s%s&quot;, zebra_route_string(i),</a>
<a name="ln703">			   VTY_NEWLINE);</a>
<a name="ln704">	      }</a>
<a name="ln705">	  }</a>
<a name="ln706">	else</a>
<a name="ln707">	  vty_out (vty, &quot; %s&quot;, zebra_route_string(i));</a>
<a name="ln708">      }</a>
<a name="ln709">  return 0;</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">/* Zebra node structure. */</a>
<a name="ln713">static struct cmd_node zebra_node =</a>
<a name="ln714">{</a>
<a name="ln715">  ZEBRA_NODE,</a>
<a name="ln716">  &quot;%s(config-router)# &quot;,</a>
<a name="ln717">};</a>
<a name="ln718"> </a>
<a name="ln719">static void</a>
<a name="ln720">rip_zebra_connected (struct zclient *zclient)</a>
<a name="ln721">{</a>
<a name="ln722">  zclient_send_requests (zclient, VRF_DEFAULT);</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">void</a>
<a name="ln726">rip_zclient_init (struct thread_master *master)</a>
<a name="ln727">{</a>
<a name="ln728">  /* Set default value to the zebra client structure. */</a>
<a name="ln729">  zclient = zclient_new (master);</a>
<a name="ln730">  zclient_init (zclient, ZEBRA_ROUTE_RIP);</a>
<a name="ln731">  zclient-&gt;zebra_connected = rip_zebra_connected;</a>
<a name="ln732">  zclient-&gt;interface_add = rip_interface_add;</a>
<a name="ln733">  zclient-&gt;interface_delete = rip_interface_delete;</a>
<a name="ln734">  zclient-&gt;interface_address_add = rip_interface_address_add;</a>
<a name="ln735">  zclient-&gt;interface_address_delete = rip_interface_address_delete;</a>
<a name="ln736">  zclient-&gt;ipv4_route_add = rip_zebra_read_ipv4;</a>
<a name="ln737">  zclient-&gt;ipv4_route_delete = rip_zebra_read_ipv4;</a>
<a name="ln738">  zclient-&gt;interface_up = rip_interface_up;</a>
<a name="ln739">  zclient-&gt;interface_down = rip_interface_down;</a>
<a name="ln740">  </a>
<a name="ln741">  /* Install zebra node. */</a>
<a name="ln742">  install_node (&amp;zebra_node, config_write_zebra);</a>
<a name="ln743"> </a>
<a name="ln744">  /* Install command elements to zebra node. */ </a>
<a name="ln745">  install_element (CONFIG_NODE, &amp;router_zebra_cmd);</a>
<a name="ln746">  install_element (CONFIG_NODE, &amp;no_router_zebra_cmd);</a>
<a name="ln747">  install_default (ZEBRA_NODE);</a>
<a name="ln748">  install_element (ZEBRA_NODE, &amp;rip_redistribute_rip_cmd);</a>
<a name="ln749">  install_element (ZEBRA_NODE, &amp;no_rip_redistribute_rip_cmd);</a>
<a name="ln750"> </a>
<a name="ln751">  /* Install command elements to rip node. */</a>
<a name="ln752">  install_element (RIP_NODE, &amp;rip_redistribute_type_cmd);</a>
<a name="ln753">  install_element (RIP_NODE, &amp;rip_redistribute_type_routemap_cmd);</a>
<a name="ln754">  install_element (RIP_NODE, &amp;rip_redistribute_type_metric_cmd);</a>
<a name="ln755">  install_element (RIP_NODE, &amp;rip_redistribute_type_metric_routemap_cmd);</a>
<a name="ln756">  install_element (RIP_NODE, &amp;no_rip_redistribute_type_cmd);</a>
<a name="ln757">  install_element (RIP_NODE, &amp;no_rip_redistribute_type_routemap_cmd);</a>
<a name="ln758">  install_element (RIP_NODE, &amp;no_rip_redistribute_type_metric_cmd);</a>
<a name="ln759">  install_element (RIP_NODE, &amp;no_rip_redistribute_type_metric_routemap_cmd);</a>
<a name="ln760">  install_element (RIP_NODE, &amp;rip_default_information_originate_cmd);</a>
<a name="ln761">  install_element (RIP_NODE, &amp;no_rip_default_information_originate_cmd);</a>
<a name="ln762">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="63"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'list' pointer was utilized before it was verified against nullptr. Check lines: 63, 69.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
