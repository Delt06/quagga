
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_tlv.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;log.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;pimd.h&quot;</a>
<a name="ln29">#include &quot;pim_int.h&quot;</a>
<a name="ln30">#include &quot;pim_tlv.h&quot;</a>
<a name="ln31">#include &quot;pim_str.h&quot;</a>
<a name="ln32">#include &quot;pim_msg.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">uint8_t *pim_tlv_append_uint16(uint8_t *buf,</a>
<a name="ln35">			       const uint8_t *buf_pastend,</a>
<a name="ln36">			       uint16_t option_type,</a>
<a name="ln37">			       uint16_t option_value)</a>
<a name="ln38">{</a>
<a name="ln39">  uint16_t option_len = 2;</a>
<a name="ln40"> </a>
<a name="ln41">  if ((buf + PIM_TLV_OPTION_SIZE(option_len)) &gt; buf_pastend)</a>
<a name="ln42">    return NULL;</a>
<a name="ln43"> </a>
<a name="ln44">  *(uint16_t *) buf = htons(option_type);</a>
<a name="ln45">  buf += 2;</a>
<a name="ln46">  *(uint16_t *) buf = htons(option_len);</a>
<a name="ln47">  buf += 2;</a>
<a name="ln48">  *(uint16_t *) buf = htons(option_value);</a>
<a name="ln49">  buf += option_len;</a>
<a name="ln50"> </a>
<a name="ln51">  return buf;</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54">uint8_t *pim_tlv_append_2uint16(uint8_t *buf,</a>
<a name="ln55">				const uint8_t *buf_pastend,</a>
<a name="ln56">				uint16_t option_type,</a>
<a name="ln57">				uint16_t option_value1,</a>
<a name="ln58">				uint16_t option_value2)</a>
<a name="ln59">{</a>
<a name="ln60">  uint16_t option_len = 4;</a>
<a name="ln61"> </a>
<a name="ln62">  if ((buf + PIM_TLV_OPTION_SIZE(option_len)) &gt; buf_pastend)</a>
<a name="ln63">    return NULL;</a>
<a name="ln64"> </a>
<a name="ln65">  *(uint16_t *) buf = htons(option_type);</a>
<a name="ln66">  buf += 2;</a>
<a name="ln67">  *(uint16_t *) buf = htons(option_len);</a>
<a name="ln68">  buf += 2;</a>
<a name="ln69">  *(uint16_t *) buf = htons(option_value1);</a>
<a name="ln70">  buf += 2;</a>
<a name="ln71">  *(uint16_t *) buf = htons(option_value2);</a>
<a name="ln72">  buf += 2;</a>
<a name="ln73"> </a>
<a name="ln74">  return buf;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">uint8_t *pim_tlv_append_uint32(uint8_t *buf,</a>
<a name="ln78">			       const uint8_t *buf_pastend,</a>
<a name="ln79">			       uint16_t option_type,</a>
<a name="ln80">			       uint32_t option_value)</a>
<a name="ln81">{</a>
<a name="ln82">  uint16_t option_len = 4;</a>
<a name="ln83"> </a>
<a name="ln84">  if ((buf + PIM_TLV_OPTION_SIZE(option_len)) &gt; buf_pastend)</a>
<a name="ln85">    return NULL;</a>
<a name="ln86"> </a>
<a name="ln87">  *(uint16_t *) buf = htons(option_type);</a>
<a name="ln88">  buf += 2;</a>
<a name="ln89">  *(uint16_t *) buf = htons(option_len);</a>
<a name="ln90">  buf += 2;</a>
<a name="ln91">  pim_write_uint32(buf, option_value);</a>
<a name="ln92">  buf += option_len;</a>
<a name="ln93"> </a>
<a name="ln94">  return buf;</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">#define ucast_ipv4_encoding_len (2 + sizeof(struct in_addr))</a>
<a name="ln98"> </a>
<a name="ln99">uint8_t *pim_tlv_append_addrlist_ucast(uint8_t *buf,</a>
<a name="ln100">				       const uint8_t *buf_pastend,</a>
<a name="ln101">				       struct list *ifconnected)</a>
<a name="ln102">{</a>
<a name="ln103">  struct listnode *node;</a>
<a name="ln104">  uint16_t option_len = 0;</a>
<a name="ln105"> </a>
<a name="ln106">  uint8_t *curr;</a>
<a name="ln107"> </a>
<a name="ln108">  node = listhead(ifconnected);</a>
<a name="ln109"> </a>
<a name="ln110">  /* Empty address list ? */</a>
<a name="ln111">  if (!node) {</a>
<a name="ln112">    return buf;</a>
<a name="ln113">  }</a>
<a name="ln114"> </a>
<a name="ln115">  /* Skip first address (primary) */</a>
<a name="ln116">  node = listnextnode(node);</a>
<a name="ln117"> </a>
<a name="ln118">  /* Scan secondary address list */</a>
<a name="ln119">  curr = buf + 4; /* skip T and L */</a>
<a name="ln120">  for (; node; node = listnextnode(node)) {</a>
<a name="ln121">    struct connected *ifc = listgetdata(node);</a>
<a name="ln122">    struct prefix *p = ifc-&gt;address;</a>
<a name="ln123">    </a>
<a name="ln124">    if (p-&gt;family != AF_INET)</a>
<a name="ln125">      continue;</a>
<a name="ln126"> </a>
<a name="ln127">    if ((curr + ucast_ipv4_encoding_len) &gt; buf_pastend)</a>
<a name="ln128">      return 0;</a>
<a name="ln129"> </a>
<a name="ln130">    /* Write encoded unicast IPv4 address */</a>
<a name="ln131">    *(uint8_t *) curr = PIM_MSG_ADDRESS_FAMILY_IPV4; /* notice: AF_INET != PIM_MSG_ADDRESS_FAMILY_IPV4 */</a>
<a name="ln132">    ++curr;</a>
<a name="ln133">    *(uint8_t *) curr = 0; /* ucast IPv4 native encoding type (RFC 4601: 4.9.1) */</a>
<a name="ln134">    ++curr;</a>
<a name="ln135">    memcpy(curr, &amp;p-&gt;u.prefix4, sizeof(struct in_addr));</a>
<a name="ln136">    curr += sizeof(struct in_addr);</a>
<a name="ln137"> </a>
<a name="ln138">    option_len += ucast_ipv4_encoding_len; </a>
<a name="ln139">  }</a>
<a name="ln140"> </a>
<a name="ln141">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln142">    zlog_debug(&quot;%s: number of encoded secondary unicast IPv4 addresses: %zu&quot;,</a>
<a name="ln143">	       __PRETTY_FUNCTION__,</a>
<a name="ln144">	       option_len / ucast_ipv4_encoding_len);</a>
<a name="ln145">  }</a>
<a name="ln146"> </a>
<a name="ln147">  if (option_len &lt; 1) {</a>
<a name="ln148">    /* Empty secondary unicast IPv4 address list */</a>
<a name="ln149">    return buf;</a>
<a name="ln150">  }</a>
<a name="ln151"> </a>
<a name="ln152">  /*</a>
<a name="ln153">   * Write T and L</a>
<a name="ln154">   */</a>
<a name="ln155">  *(uint16_t *) buf       = htons(PIM_MSG_OPTION_TYPE_ADDRESS_LIST);</a>
<a name="ln156">  *(uint16_t *) (buf + 2) = htons(option_len);</a>
<a name="ln157"> </a>
<a name="ln158">  return curr;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">static int check_tlv_length(const char *label, const char *tlv_name,</a>
<a name="ln162">			    const char *ifname, struct in_addr src_addr,</a>
<a name="ln163">			    int correct_len, int option_len)</a>
<a name="ln164">{</a>
<a name="ln165">  if (option_len != correct_len) {</a>
<a name="ln166">    char src_str[100];</a>
<a name="ln167">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln168">    zlog_warn(&quot;%s: PIM hello %s TLV with incorrect value size=%d correct=%d from %s on interface %s&quot;,</a>
<a name="ln169">	      label, tlv_name,</a>
<a name="ln170">	      option_len, correct_len,</a>
<a name="ln171">	      src_str, ifname);</a>
<a name="ln172">    return -1;</a>
<a name="ln173">  }</a>
<a name="ln174"> </a>
<a name="ln175">  return 0;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">static void check_tlv_redefinition_uint16(const char *label, const char *tlv_name,</a>
<a name="ln179">					  const char *ifname, struct in_addr src_addr,</a>
<a name="ln180">					  pim_hello_options options,</a>
<a name="ln181">					  pim_hello_options opt_mask,</a>
<a name="ln182">					  uint16_t new, uint16_t old)</a>
<a name="ln183">{</a>
<a name="ln184">  if (PIM_OPTION_IS_SET(options, opt_mask)) {</a>
<a name="ln185">    char src_str[100];</a>
<a name="ln186">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln187">    zlog_warn(&quot;%s: PIM hello TLV redefined %s=%u old=%u from %s on interface %s&quot;,</a>
<a name="ln188">	      label, tlv_name,</a>
<a name="ln189">	      new, old,</a>
<a name="ln190">	      src_str, ifname);</a>
<a name="ln191">  }</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">static void check_tlv_redefinition_uint32(const char *label, const char *tlv_name,</a>
<a name="ln195">					  const char *ifname, struct in_addr src_addr,</a>
<a name="ln196">					  pim_hello_options options,</a>
<a name="ln197">					  pim_hello_options opt_mask,</a>
<a name="ln198">					  uint32_t new, uint32_t old)</a>
<a name="ln199">{</a>
<a name="ln200">  if (PIM_OPTION_IS_SET(options, opt_mask)) {</a>
<a name="ln201">    char src_str[100];</a>
<a name="ln202">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln203">    zlog_warn(&quot;%s: PIM hello TLV redefined %s=%u old=%u from %s on interface %s&quot;,</a>
<a name="ln204">	      label, tlv_name,</a>
<a name="ln205">	      new, old,</a>
<a name="ln206">	      src_str, ifname);</a>
<a name="ln207">  }</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">static void check_tlv_redefinition_uint32_hex(const char *label, const char *tlv_name,</a>
<a name="ln211">					      const char *ifname, struct in_addr src_addr,</a>
<a name="ln212">					      pim_hello_options options,</a>
<a name="ln213">					      pim_hello_options opt_mask,</a>
<a name="ln214">					      uint32_t new, uint32_t old)</a>
<a name="ln215">{</a>
<a name="ln216">  if (PIM_OPTION_IS_SET(options, opt_mask)) {</a>
<a name="ln217">    char src_str[100];</a>
<a name="ln218">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln219">    zlog_warn(&quot;%s: PIM hello TLV redefined %s=%08x old=%08x from %s on interface %s&quot;,</a>
<a name="ln220">	      label, tlv_name,</a>
<a name="ln221">	      new, old,</a>
<a name="ln222">	      src_str, ifname);</a>
<a name="ln223">  }</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">int pim_tlv_parse_holdtime(const char *ifname, struct in_addr src_addr,</a>
<a name="ln227">			   pim_hello_options *hello_options,</a>
<a name="ln228">			   uint16_t *hello_option_holdtime,</a>
<a name="ln229">			   uint16_t option_len,</a>
<a name="ln230">			   const uint8_t *tlv_curr) </a>
<a name="ln231">{</a>
<a name="ln232">  const char *label = &quot;holdtime&quot;;</a>
<a name="ln233"> </a>
<a name="ln234">  if (check_tlv_length(__PRETTY_FUNCTION__, label,</a>
<a name="ln235">		       ifname, src_addr,</a>
<a name="ln236">		       sizeof(uint16_t), option_len)) {</a>
<a name="ln237">    return -1;</a>
<a name="ln238">  }</a>
<a name="ln239">  </a>
<a name="ln240">  check_tlv_redefinition_uint16(__PRETTY_FUNCTION__, label,</a>
<a name="ln241">				ifname, src_addr,</a>
<a name="ln242">				*hello_options, PIM_OPTION_MASK_HOLDTIME,</a>
<a name="ln243">				PIM_TLV_GET_HOLDTIME(tlv_curr),</a>
<a name="ln244">				*hello_option_holdtime);</a>
<a name="ln245">  </a>
<a name="ln246">  PIM_OPTION_SET(*hello_options, PIM_OPTION_MASK_HOLDTIME);</a>
<a name="ln247">  </a>
<a name="ln248">  *hello_option_holdtime = PIM_TLV_GET_HOLDTIME(tlv_curr);</a>
<a name="ln249">  </a>
<a name="ln250">  return 0;</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">int pim_tlv_parse_lan_prune_delay(const char *ifname, struct in_addr src_addr,</a>
<a name="ln254">				  pim_hello_options *hello_options,</a>
<a name="ln255">				  uint16_t *hello_option_propagation_delay,</a>
<a name="ln256">				  uint16_t *hello_option_override_interval,</a>
<a name="ln257">				  uint16_t option_len,</a>
<a name="ln258">				  const uint8_t *tlv_curr) </a>
<a name="ln259">{</a>
<a name="ln260">  if (check_tlv_length(__PRETTY_FUNCTION__, &quot;lan_prune_delay&quot;,</a>
<a name="ln261">		       ifname, src_addr,</a>
<a name="ln262">		       sizeof(uint32_t), option_len)) {</a>
<a name="ln263">    return -1;</a>
<a name="ln264">  }</a>
<a name="ln265">  </a>
<a name="ln266">  check_tlv_redefinition_uint16(__PRETTY_FUNCTION__, &quot;propagation_delay&quot;,</a>
<a name="ln267">				ifname, src_addr,</a>
<a name="ln268">				*hello_options, PIM_OPTION_MASK_LAN_PRUNE_DELAY,</a>
<a name="ln269">				PIM_TLV_GET_PROPAGATION_DELAY(tlv_curr),</a>
<a name="ln270">				*hello_option_propagation_delay);</a>
<a name="ln271">  </a>
<a name="ln272">  PIM_OPTION_SET(*hello_options, PIM_OPTION_MASK_LAN_PRUNE_DELAY);</a>
<a name="ln273">  </a>
<a name="ln274">  *hello_option_propagation_delay = PIM_TLV_GET_PROPAGATION_DELAY(tlv_curr);</a>
<a name="ln275">  if (PIM_TLV_GET_CAN_DISABLE_JOIN_SUPPRESSION(tlv_curr)) {</a>
<a name="ln276">    PIM_OPTION_SET(*hello_options, PIM_OPTION_MASK_CAN_DISABLE_JOIN_SUPPRESSION);</a>
<a name="ln277">  }</a>
<a name="ln278">  else {</a>
<a name="ln279">    PIM_OPTION_UNSET(*hello_options, PIM_OPTION_MASK_CAN_DISABLE_JOIN_SUPPRESSION);</a>
<a name="ln280">  }</a>
<a name="ln281">  ++tlv_curr;</a>
<a name="ln282">  ++tlv_curr;</a>
<a name="ln283">  *hello_option_override_interval = PIM_TLV_GET_OVERRIDE_INTERVAL(tlv_curr);</a>
<a name="ln284">  </a>
<a name="ln285">  return 0;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">int pim_tlv_parse_dr_priority(const char *ifname, struct in_addr src_addr,</a>
<a name="ln289">			      pim_hello_options *hello_options,</a>
<a name="ln290">			      uint32_t *hello_option_dr_priority,</a>
<a name="ln291">			      uint16_t option_len,</a>
<a name="ln292">			      const uint8_t *tlv_curr) </a>
<a name="ln293">{</a>
<a name="ln294">  const char *label = &quot;dr_priority&quot;;</a>
<a name="ln295"> </a>
<a name="ln296">  if (check_tlv_length(__PRETTY_FUNCTION__, label,</a>
<a name="ln297">		       ifname, src_addr,</a>
<a name="ln298">		       sizeof(uint32_t), option_len)) {</a>
<a name="ln299">    return -1;</a>
<a name="ln300">  }</a>
<a name="ln301">  </a>
<a name="ln302">  check_tlv_redefinition_uint32(__PRETTY_FUNCTION__, label,</a>
<a name="ln303">				ifname, src_addr,</a>
<a name="ln304">				*hello_options, PIM_OPTION_MASK_DR_PRIORITY,</a>
<a name="ln305">				PIM_TLV_GET_DR_PRIORITY(tlv_curr),</a>
<a name="ln306">				*hello_option_dr_priority);</a>
<a name="ln307">  </a>
<a name="ln308">  PIM_OPTION_SET(*hello_options, PIM_OPTION_MASK_DR_PRIORITY);</a>
<a name="ln309">  </a>
<a name="ln310">  *hello_option_dr_priority = PIM_TLV_GET_DR_PRIORITY(tlv_curr);</a>
<a name="ln311"> </a>
<a name="ln312">  return 0;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">int pim_tlv_parse_generation_id(const char *ifname, struct in_addr src_addr,</a>
<a name="ln316">				pim_hello_options *hello_options,</a>
<a name="ln317">				uint32_t *hello_option_generation_id,</a>
<a name="ln318">				uint16_t option_len,</a>
<a name="ln319">				const uint8_t *tlv_curr) </a>
<a name="ln320">{</a>
<a name="ln321">  const char *label = &quot;generation_id&quot;;</a>
<a name="ln322"> </a>
<a name="ln323">  if (check_tlv_length(__PRETTY_FUNCTION__, label,</a>
<a name="ln324">		       ifname, src_addr,</a>
<a name="ln325">		       sizeof(uint32_t), option_len)) {</a>
<a name="ln326">    return -1;</a>
<a name="ln327">  }</a>
<a name="ln328">  </a>
<a name="ln329">  check_tlv_redefinition_uint32_hex(__PRETTY_FUNCTION__, label,</a>
<a name="ln330">				    ifname, src_addr,</a>
<a name="ln331">				    *hello_options, PIM_OPTION_MASK_GENERATION_ID,</a>
<a name="ln332">				    PIM_TLV_GET_GENERATION_ID(tlv_curr),</a>
<a name="ln333">				    *hello_option_generation_id);</a>
<a name="ln334">  </a>
<a name="ln335">  PIM_OPTION_SET(*hello_options, PIM_OPTION_MASK_GENERATION_ID);</a>
<a name="ln336">  </a>
<a name="ln337">  *hello_option_generation_id = PIM_TLV_GET_GENERATION_ID(tlv_curr);</a>
<a name="ln338">  </a>
<a name="ln339">  return 0;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">int pim_parse_addr_ucast(const char *ifname, struct in_addr src_addr,</a>
<a name="ln343">			 struct prefix *p,</a>
<a name="ln344">			 const uint8_t *buf,</a>
<a name="ln345">			 int buf_size)</a>
<a name="ln346">{</a>
<a name="ln347">  const int ucast_encoding_min_len = 3; /* 1 family + 1 type + 1 addr */</a>
<a name="ln348">  const uint8_t *addr;</a>
<a name="ln349">  const uint8_t *pastend;</a>
<a name="ln350">  int family;</a>
<a name="ln351">  int type;</a>
<a name="ln352"> </a>
<a name="ln353">  if (buf_size &lt; ucast_encoding_min_len) {</a>
<a name="ln354">    char src_str[100];</a>
<a name="ln355">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln356">    zlog_warn(&quot;%s: unicast address encoding overflow: left=%d needed=%d from %s on %s&quot;,</a>
<a name="ln357">	      __PRETTY_FUNCTION__,</a>
<a name="ln358">	      buf_size, ucast_encoding_min_len,</a>
<a name="ln359">	      src_str, ifname);</a>
<a name="ln360">    return -1;</a>
<a name="ln361">  }</a>
<a name="ln362"> </a>
<a name="ln363">  addr = buf;</a>
<a name="ln364">  pastend = buf + buf_size;</a>
<a name="ln365"> </a>
<a name="ln366">  family = *addr++;</a>
<a name="ln367">  type = *addr++;</a>
<a name="ln368"> </a>
<a name="ln369">  switch (family) {</a>
<a name="ln370">  case PIM_MSG_ADDRESS_FAMILY_IPV4:</a>
<a name="ln371">    if (type) {</a>
<a name="ln372">      char src_str[100];</a>
<a name="ln373">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln374">      zlog_warn(&quot;%s: unknown unicast address encoding type=%d from %s on %s&quot;,</a>
<a name="ln375">		__PRETTY_FUNCTION__,</a>
<a name="ln376">		type, src_str, ifname);</a>
<a name="ln377">      return -2;</a>
<a name="ln378">    }</a>
<a name="ln379"> </a>
<a name="ln380">    if ((addr + sizeof(struct in_addr)) &gt; pastend) {</a>
<a name="ln381">      char src_str[100];</a>
<a name="ln382">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln383">      zlog_warn(&quot;%s: IPv4 unicast address overflow: left=%zd needed=%zu from %s on %s&quot;,</a>
<a name="ln384">		__PRETTY_FUNCTION__,</a>
<a name="ln385">		pastend - addr, sizeof(struct in_addr),</a>
<a name="ln386">		src_str, ifname);</a>
<a name="ln387">      return -3;</a>
<a name="ln388">    }</a>
<a name="ln389"> </a>
<a name="ln390">    p-&gt;family = AF_INET; /* notice: AF_INET != PIM_MSG_ADDRESS_FAMILY_IPV4 */</a>
<a name="ln391">    memcpy(&amp;p-&gt;u.prefix4, addr, sizeof(struct in_addr));</a>
<a name="ln392"> </a>
<a name="ln393">    addr += sizeof(struct in_addr);</a>
<a name="ln394"> </a>
<a name="ln395">    break;</a>
<a name="ln396">  default:</a>
<a name="ln397">    {</a>
<a name="ln398">      char src_str[100];</a>
<a name="ln399">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln400">      zlog_warn(&quot;%s: unknown unicast address encoding family=%d from %s on %s&quot;,</a>
<a name="ln401">		__PRETTY_FUNCTION__,</a>
<a name="ln402">		family, src_str, ifname);</a>
<a name="ln403">      return -4;</a>
<a name="ln404">    }</a>
<a name="ln405">  }</a>
<a name="ln406"> </a>
<a name="ln407">  return addr - buf;</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">int pim_parse_addr_group(const char *ifname, struct in_addr src_addr,</a>
<a name="ln411">			 struct prefix *p,</a>
<a name="ln412">			 const uint8_t *buf,</a>
<a name="ln413">			 int buf_size)</a>
<a name="ln414">{</a>
<a name="ln415">  const int grp_encoding_min_len = 4; /* 1 family + 1 type + 1 reserved + 1 addr */</a>
<a name="ln416">  const uint8_t *addr;</a>
<a name="ln417">  const uint8_t *pastend;</a>
<a name="ln418">  int family;</a>
<a name="ln419">  int type;</a>
<a name="ln420">  int mask_len;</a>
<a name="ln421"> </a>
<a name="ln422">  if (buf_size &lt; grp_encoding_min_len) {</a>
<a name="ln423">    char src_str[100];</a>
<a name="ln424">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln425">    zlog_warn(&quot;%s: group address encoding overflow: left=%d needed=%d from %s on %s&quot;,</a>
<a name="ln426">	      __PRETTY_FUNCTION__,</a>
<a name="ln427">	      buf_size, grp_encoding_min_len,</a>
<a name="ln428">	      src_str, ifname);</a>
<a name="ln429">    return -1;</a>
<a name="ln430">  }</a>
<a name="ln431"> </a>
<a name="ln432">  addr = buf;</a>
<a name="ln433">  pastend = buf + buf_size;</a>
<a name="ln434"> </a>
<a name="ln435">  family = *addr++;</a>
<a name="ln436">  type = *addr++;</a>
<a name="ln437">  //++addr;</a>
<a name="ln438">  ++addr; /* skip b_reserved_z fields */</a>
<a name="ln439">  mask_len = *addr++;</a>
<a name="ln440"> </a>
<a name="ln441">  switch (family) {</a>
<a name="ln442">  case PIM_MSG_ADDRESS_FAMILY_IPV4:</a>
<a name="ln443">    if (type) {</a>
<a name="ln444">      char src_str[100];</a>
<a name="ln445">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln446">      zlog_warn(&quot;%s: unknown group address encoding type=%d from %s on %s&quot;,</a>
<a name="ln447">		__PRETTY_FUNCTION__,</a>
<a name="ln448">		type, src_str, ifname);</a>
<a name="ln449">      return -2;</a>
<a name="ln450">    }</a>
<a name="ln451"> </a>
<a name="ln452">    if ((addr + sizeof(struct in_addr)) &gt; pastend) {</a>
<a name="ln453">      char src_str[100];</a>
<a name="ln454">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln455">      zlog_warn(&quot;%s: IPv4 group address overflow: left=%zd needed=%zu from %s on %s&quot;,</a>
<a name="ln456">		__PRETTY_FUNCTION__,</a>
<a name="ln457">		pastend - addr, sizeof(struct in_addr),</a>
<a name="ln458">		src_str, ifname);</a>
<a name="ln459">      return -3;</a>
<a name="ln460">    }</a>
<a name="ln461"> </a>
<a name="ln462">    p-&gt;family = AF_INET; /* notice: AF_INET != PIM_MSG_ADDRESS_FAMILY_IPV4 */</a>
<a name="ln463">    memcpy(&amp;p-&gt;u.prefix4, addr, sizeof(struct in_addr));</a>
<a name="ln464">    p-&gt;prefixlen = mask_len;</a>
<a name="ln465"> </a>
<a name="ln466">    addr += sizeof(struct in_addr);</a>
<a name="ln467"> </a>
<a name="ln468">    break;</a>
<a name="ln469">  default:</a>
<a name="ln470">    {</a>
<a name="ln471">      char src_str[100];</a>
<a name="ln472">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln473">      zlog_warn(&quot;%s: unknown group address encoding family=%d from %s on %s&quot;,</a>
<a name="ln474">		__PRETTY_FUNCTION__,</a>
<a name="ln475">		family, src_str, ifname);</a>
<a name="ln476">      return -4;</a>
<a name="ln477">    }</a>
<a name="ln478">  }</a>
<a name="ln479"> </a>
<a name="ln480">  return addr - buf;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">int pim_parse_addr_source(const char *ifname,</a>
<a name="ln484">			  struct in_addr src_addr,</a>
<a name="ln485">			  struct prefix *p,</a>
<a name="ln486">			  uint8_t *flags,</a>
<a name="ln487">			  const uint8_t *buf,</a>
<a name="ln488">			  int buf_size)</a>
<a name="ln489">{</a>
<a name="ln490">  const int src_encoding_min_len = 4; /* 1 family + 1 type + 1 reserved + 1 addr */</a>
<a name="ln491">  const uint8_t *addr;</a>
<a name="ln492">  const uint8_t *pastend;</a>
<a name="ln493">  int family;</a>
<a name="ln494">  int type;</a>
<a name="ln495">  int mask_len;</a>
<a name="ln496"> </a>
<a name="ln497">  if (buf_size &lt; src_encoding_min_len) {</a>
<a name="ln498">    char src_str[100];</a>
<a name="ln499">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln500">    zlog_warn(&quot;%s: source address encoding overflow: left=%d needed=%d from %s on %s&quot;,</a>
<a name="ln501">	      __PRETTY_FUNCTION__,</a>
<a name="ln502">	      buf_size, src_encoding_min_len,</a>
<a name="ln503">	      src_str, ifname);</a>
<a name="ln504">    return -1;</a>
<a name="ln505">  }</a>
<a name="ln506"> </a>
<a name="ln507">  addr = buf;</a>
<a name="ln508">  pastend = buf + buf_size;</a>
<a name="ln509"> </a>
<a name="ln510">  family = *addr++;</a>
<a name="ln511">  type = *addr++;</a>
<a name="ln512">  *flags = *addr++;</a>
<a name="ln513">  mask_len = *addr++;</a>
<a name="ln514"> </a>
<a name="ln515">  switch (family) {</a>
<a name="ln516">  case PIM_MSG_ADDRESS_FAMILY_IPV4:</a>
<a name="ln517">    if (type) {</a>
<a name="ln518">      char src_str[100];</a>
<a name="ln519">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln520">      zlog_warn(&quot;%s: unknown source address encoding type=%d from %s on %s: %02x%02x%02x%02x%02x%02x%02x%02x&quot;,</a>
<a name="ln521">		__PRETTY_FUNCTION__,</a>
<a name="ln522">		type, src_str, ifname,</a>
<a name="ln523">		buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);</a>
<a name="ln524">      return -2;</a>
<a name="ln525">    }</a>
<a name="ln526"> </a>
<a name="ln527">    if ((addr + sizeof(struct in_addr)) &gt; pastend) {</a>
<a name="ln528">      char src_str[100];</a>
<a name="ln529">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln530">      zlog_warn(&quot;%s: IPv4 source address overflow: left=%zd needed=%zu from %s on %s&quot;,</a>
<a name="ln531">		__PRETTY_FUNCTION__,</a>
<a name="ln532">		pastend - addr, sizeof(struct in_addr),</a>
<a name="ln533">		src_str, ifname);</a>
<a name="ln534">      return -3;</a>
<a name="ln535">    }</a>
<a name="ln536"> </a>
<a name="ln537">    p-&gt;family = AF_INET; /* notice: AF_INET != PIM_MSG_ADDRESS_FAMILY_IPV4 */</a>
<a name="ln538">    memcpy(&amp;p-&gt;u.prefix4, addr, sizeof(struct in_addr));</a>
<a name="ln539">    p-&gt;prefixlen = mask_len;</a>
<a name="ln540"> </a>
<a name="ln541">    /* </a>
<a name="ln542">       RFC 4601: 4.9.1  Encoded Source and Group Address Formats</a>
<a name="ln543"> </a>
<a name="ln544">       Encoded-Source Address</a>
<a name="ln545"> </a>
<a name="ln546">       The mask length MUST be equal to the mask length in bits for</a>
<a name="ln547">       the given Address Family and Encoding Type (32 for IPv4 native</a>
<a name="ln548">       and 128 for IPv6 native).  A router SHOULD ignore any messages</a>
<a name="ln549">       received with any other mask length.</a>
<a name="ln550">    */</a>
<a name="ln551">    if (p-&gt;prefixlen != 32) {</a>
<a name="ln552">      char src_str[100];</a>
<a name="ln553">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, p-&gt;u.prefix4, src_str, sizeof(src_str));</a>
<a name="ln554">      zlog_warn(&quot;%s: IPv4 bad source address mask: %s/%d&quot;,</a>
<a name="ln555">		__PRETTY_FUNCTION__, src_str, p-&gt;prefixlen);</a>
<a name="ln556">      return -4;</a>
<a name="ln557">    }</a>
<a name="ln558"> </a>
<a name="ln559">    addr += sizeof(struct in_addr);</a>
<a name="ln560"> </a>
<a name="ln561">    break;</a>
<a name="ln562">  default:</a>
<a name="ln563">    {</a>
<a name="ln564">      char src_str[100];</a>
<a name="ln565">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln566">      zlog_warn(&quot;%s: unknown source address encoding family=%d from %s on %s: %02x%02x%02x%02x%02x%02x%02x%02x&quot;,</a>
<a name="ln567">		__PRETTY_FUNCTION__,</a>
<a name="ln568">		family, src_str, ifname,</a>
<a name="ln569">		buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7]);</a>
<a name="ln570">      return -5;</a>
<a name="ln571">    }</a>
<a name="ln572">  }</a>
<a name="ln573"> </a>
<a name="ln574">  return addr - buf;</a>
<a name="ln575">}</a>
<a name="ln576"> </a>
<a name="ln577">#define FREE_ADDR_LIST(hello_option_addr_list) \</a>
<a name="ln578">{ \</a>
<a name="ln579">  if (hello_option_addr_list) { \</a>
<a name="ln580">    list_delete(hello_option_addr_list); \</a>
<a name="ln581">    hello_option_addr_list = 0; \</a>
<a name="ln582">  } \</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">int pim_tlv_parse_addr_list(const char *ifname, struct in_addr src_addr,</a>
<a name="ln586">			    pim_hello_options *hello_options,</a>
<a name="ln587">			    struct list **hello_option_addr_list,</a>
<a name="ln588">			    uint16_t option_len,</a>
<a name="ln589">			    const uint8_t *tlv_curr) </a>
<a name="ln590">{</a>
<a name="ln591">  const uint8_t *addr;</a>
<a name="ln592">  const uint8_t *pastend;</a>
<a name="ln593"> </a>
<a name="ln594">  zassert(hello_option_addr_list);</a>
<a name="ln595"> </a>
<a name="ln596">  /*</a>
<a name="ln597">    Scan addr list</a>
<a name="ln598">   */</a>
<a name="ln599">  addr = tlv_curr;</a>
<a name="ln600">  pastend = tlv_curr + option_len;</a>
<a name="ln601">  while (addr &lt; pastend) {</a>
<a name="ln602">    struct prefix tmp;</a>
<a name="ln603">    int addr_offset;</a>
<a name="ln604"> </a>
<a name="ln605">    /*</a>
<a name="ln606">      Parse ucast addr</a>
<a name="ln607">     */</a>
<a name="ln608">    addr_offset = pim_parse_addr_ucast(ifname, src_addr, &amp;tmp,</a>
<a name="ln609">				       addr, pastend - addr);</a>
<a name="ln610">    if (addr_offset &lt; 1) {</a>
<a name="ln611">      char src_str[100];</a>
<a name="ln612">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln613">      zlog_warn(&quot;%s: pim_parse_addr_ucast() failure: from %s on %s&quot;,</a>
<a name="ln614">		__PRETTY_FUNCTION__,</a>
<a name="ln615">		src_str, ifname);</a>
<a name="ln616">      FREE_ADDR_LIST(*hello_option_addr_list);</a>
<a name="ln617">      return -1;</a>
<a name="ln618">    }</a>
<a name="ln619">    addr += addr_offset;</a>
<a name="ln620"> </a>
<a name="ln621">    /*</a>
<a name="ln622">      Debug</a>
<a name="ln623">     */</a>
<a name="ln624">    if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln625">      switch (tmp.family) {</a>
<a name="ln626">      case AF_INET:</a>
<a name="ln627">	{</a>
<a name="ln628">	  char addr_str[100];</a>
<a name="ln629">	  char src_str[100];</a>
<a name="ln630">	  pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, tmp.u.prefix4, addr_str, sizeof(addr_str));</a>
<a name="ln631">	  pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln632">	  zlog_debug(&quot;%s: PIM hello TLV option: list_old_size=%d IPv4 address %s from %s on %s&quot;,</a>
<a name="ln633">		     __PRETTY_FUNCTION__,</a>
<a name="ln634">		     *hello_option_addr_list ?</a>
<a name="ln635">		     ((int) listcount(*hello_option_addr_list)) : -1,</a>
<a name="ln636">		     addr_str, src_str, ifname);</a>
<a name="ln637">	}</a>
<a name="ln638">	break;</a>
<a name="ln639">      default:</a>
<a name="ln640">	{</a>
<a name="ln641">	  char src_str[100];</a>
<a name="ln642">	  pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln643">	  zlog_debug(&quot;%s: PIM hello TLV option: list_old_size=%d UNKNOWN address family from %s on %s&quot;,</a>
<a name="ln644">		     __PRETTY_FUNCTION__,</a>
<a name="ln645">		     *hello_option_addr_list ?</a>
<a name="ln646">		     ((int) listcount(*hello_option_addr_list)) : -1,</a>
<a name="ln647">		     src_str, ifname);</a>
<a name="ln648">	}</a>
<a name="ln649">      }</a>
<a name="ln650">    }</a>
<a name="ln651"> </a>
<a name="ln652">    /*</a>
<a name="ln653">      Exclude neighbor's primary address if incorrectly included in</a>
<a name="ln654">      the secondary address list</a>
<a name="ln655">     */</a>
<a name="ln656">    if (tmp.family == AF_INET) {</a>
<a name="ln657">      if (tmp.u.prefix4.s_addr == src_addr.s_addr) {</a>
<a name="ln658">	  char src_str[100];</a>
<a name="ln659">	  pim_inet4_dump(&quot;&lt;src?&gt;&quot;, src_addr, src_str, sizeof(src_str));</a>
<a name="ln660">	  zlog_warn(&quot;%s: ignoring primary address in secondary list from %s on %s&quot;,</a>
<a name="ln661">		    __PRETTY_FUNCTION__,</a>
<a name="ln662">		    src_str, ifname);</a>
<a name="ln663">	  continue;</a>
<a name="ln664">      }</a>
<a name="ln665">    }</a>
<a name="ln666"> </a>
<a name="ln667">    /*</a>
<a name="ln668">      Allocate list if needed</a>
<a name="ln669">     */</a>
<a name="ln670">    if (!*hello_option_addr_list) {</a>
<a name="ln671">      *hello_option_addr_list = list_new();</a>
<a name="ln672">      if (!*hello_option_addr_list) {</a>
<a name="ln673">	zlog_err(&quot;%s %s: failure: hello_option_addr_list=list_new()&quot;,</a>
<a name="ln674">		 __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln675">	return -2;</a>
<a name="ln676">      }</a>
<a name="ln677">      (*hello_option_addr_list)-&gt;del = (void (*)(void *)) prefix_free;</a>
<a name="ln678">    }</a>
<a name="ln679"> </a>
<a name="ln680">    /*</a>
<a name="ln681">      Attach addr to list</a>
<a name="ln682">     */</a>
<a name="ln683">    {</a>
<a name="ln684">      struct prefix *p;</a>
<a name="ln685">      p = prefix_new();</a>
<a name="ln686">      if (!p) {</a>
<a name="ln687">	zlog_err(&quot;%s %s: failure: prefix_new()&quot;,</a>
<a name="ln688">		 __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln689">	FREE_ADDR_LIST(*hello_option_addr_list);</a>
<a name="ln690">	return -3;</a>
<a name="ln691">      }</a>
<a name="ln692">      p-&gt;family = tmp.family;</a>
<a name="ln693">      p-&gt;u.prefix4 = tmp.u.prefix4;</a>
<a name="ln694">      listnode_add(*hello_option_addr_list, p);</a>
<a name="ln695">    }</a>
<a name="ln696"> </a>
<a name="ln697">  } /* while (addr &lt; pastend) */</a>
<a name="ln698">  </a>
<a name="ln699">  /*</a>
<a name="ln700">    Mark hello option</a>
<a name="ln701">   */</a>
<a name="ln702">  PIM_OPTION_SET(*hello_options, PIM_OPTION_MASK_ADDRESS_LIST);</a>
<a name="ln703">  </a>
<a name="ln704">  return 0;</a>
<a name="ln705">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
