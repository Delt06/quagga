
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_upstream.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;zebra/rib.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &quot;zclient.h&quot;</a>
<a name="ln29">#include &quot;memory.h&quot;</a>
<a name="ln30">#include &quot;thread.h&quot;</a>
<a name="ln31">#include &quot;linklist.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;pimd.h&quot;</a>
<a name="ln34">#include &quot;pim_pim.h&quot;</a>
<a name="ln35">#include &quot;pim_str.h&quot;</a>
<a name="ln36">#include &quot;pim_time.h&quot;</a>
<a name="ln37">#include &quot;pim_iface.h&quot;</a>
<a name="ln38">#include &quot;pim_join.h&quot;</a>
<a name="ln39">#include &quot;pim_zlookup.h&quot;</a>
<a name="ln40">#include &quot;pim_upstream.h&quot;</a>
<a name="ln41">#include &quot;pim_ifchannel.h&quot;</a>
<a name="ln42">#include &quot;pim_neighbor.h&quot;</a>
<a name="ln43">#include &quot;pim_rpf.h&quot;</a>
<a name="ln44">#include &quot;pim_zebra.h&quot;</a>
<a name="ln45">#include &quot;pim_oil.h&quot;</a>
<a name="ln46">#include &quot;pim_macro.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">static void join_timer_start(struct pim_upstream *up);</a>
<a name="ln49">static void pim_upstream_update_assert_tracking_desired(struct pim_upstream *up);</a>
<a name="ln50"> </a>
<a name="ln51">void pim_upstream_free(struct pim_upstream *up)</a>
<a name="ln52">{</a>
<a name="ln53">  XFREE(MTYPE_PIM_UPSTREAM, up);</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56">static void upstream_channel_oil_detach(struct pim_upstream *up)</a>
<a name="ln57">{</a>
<a name="ln58">  if (up-&gt;channel_oil) {</a>
<a name="ln59">    pim_channel_oil_del(up-&gt;channel_oil);</a>
<a name="ln60">    up-&gt;channel_oil = 0;</a>
<a name="ln61">  }</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">void pim_upstream_delete(struct pim_upstream *up)</a>
<a name="ln65">{</a>
<a name="ln66">  THREAD_OFF(up-&gt;t_join_timer);</a>
<a name="ln67"> </a>
<a name="ln68">  upstream_channel_oil_detach(up);</a>
<a name="ln69"> </a>
<a name="ln70">  /*</a>
<a name="ln71">    notice that listnode_delete() can't be moved</a>
<a name="ln72">    into pim_upstream_free() because the later is</a>
<a name="ln73">    called by list_delete_all_node()</a>
<a name="ln74">  */</a>
<a name="ln75">  listnode_delete(qpim_upstream_list, up);</a>
<a name="ln76"> </a>
<a name="ln77">  pim_upstream_free(up);</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">static void send_join(struct pim_upstream *up)</a>
<a name="ln81">{</a>
<a name="ln82">  zassert(up-&gt;join_state == PIM_UPSTREAM_JOINED);</a>
<a name="ln83"> </a>
<a name="ln84">  </a>
<a name="ln85">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln86">    if (PIM_INADDR_IS_ANY(up-&gt;rpf.rpf_addr)) {</a>
<a name="ln87">      char src_str[100];</a>
<a name="ln88">      char grp_str[100];</a>
<a name="ln89">      char rpf_str[100];</a>
<a name="ln90">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, up-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln91">      pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, up-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln92">      pim_inet4_dump(&quot;&lt;rpf?&gt;&quot;, up-&gt;rpf.rpf_addr, rpf_str, sizeof(rpf_str));</a>
<a name="ln93">      zlog_warn(&quot;%s: can't send join upstream: RPF'(%s,%s)=%s&quot;,</a>
<a name="ln94">		__PRETTY_FUNCTION__,</a>
<a name="ln95">		src_str, grp_str, rpf_str);</a>
<a name="ln96">      /* warning only */</a>
<a name="ln97">    }</a>
<a name="ln98">  }</a>
<a name="ln99">  </a>
<a name="ln100">  /* send Join(S,G) to the current upstream neighbor */</a>
<a name="ln101">  pim_joinprune_send(up-&gt;rpf.source_nexthop.interface,</a>
<a name="ln102">  		     up-&gt;rpf.rpf_addr,</a>
<a name="ln103">		     up-&gt;source_addr,</a>
<a name="ln104">		     up-&gt;group_addr,</a>
<a name="ln105">		     1 /* join */);</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">static int on_join_timer(struct thread *t)</a>
<a name="ln109">{</a>
<a name="ln110">  struct pim_upstream *up;</a>
<a name="ln111"> </a>
<a name="ln112">  zassert(t);</a>
<a name="ln113">  up = THREAD_ARG(t);</a>
<a name="ln114">  zassert(up);</a>
<a name="ln115"> </a>
<a name="ln116">  send_join(up);</a>
<a name="ln117"> </a>
<a name="ln118">  up-&gt;t_join_timer = 0;</a>
<a name="ln119">  join_timer_start(up);</a>
<a name="ln120"> </a>
<a name="ln121">  return 0;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">static void join_timer_start(struct pim_upstream *up)</a>
<a name="ln125">{</a>
<a name="ln126">  if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln127">    char src_str[100];</a>
<a name="ln128">    char grp_str[100];</a>
<a name="ln129">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, up-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln130">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, up-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln131">    zlog_debug(&quot;%s: starting %d sec timer for upstream (S,G)=(%s,%s)&quot;,</a>
<a name="ln132">	       __PRETTY_FUNCTION__,</a>
<a name="ln133">	       qpim_t_periodic,</a>
<a name="ln134">	       src_str, grp_str);</a>
<a name="ln135">  }</a>
<a name="ln136"> </a>
<a name="ln137">  zassert(!up-&gt;t_join_timer);</a>
<a name="ln138"> </a>
<a name="ln139">  THREAD_TIMER_ON(master, up-&gt;t_join_timer,</a>
<a name="ln140">		  on_join_timer,</a>
<a name="ln141">		  up, qpim_t_periodic);</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">void pim_upstream_join_timer_restart(struct pim_upstream *up)</a>
<a name="ln145">{</a>
<a name="ln146">  THREAD_OFF(up-&gt;t_join_timer);</a>
<a name="ln147">  join_timer_start(up);</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">static void pim_upstream_join_timer_restart_msec(struct pim_upstream *up,</a>
<a name="ln151">						 int interval_msec)</a>
<a name="ln152">{</a>
<a name="ln153">  if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln154">    char src_str[100];</a>
<a name="ln155">    char grp_str[100];</a>
<a name="ln156">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, up-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln157">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, up-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln158">    zlog_debug(&quot;%s: restarting %d msec timer for upstream (S,G)=(%s,%s)&quot;,</a>
<a name="ln159">	       __PRETTY_FUNCTION__,</a>
<a name="ln160">	       interval_msec,</a>
<a name="ln161">	       src_str, grp_str);</a>
<a name="ln162">  }</a>
<a name="ln163"> </a>
<a name="ln164">  THREAD_OFF(up-&gt;t_join_timer);</a>
<a name="ln165">  THREAD_TIMER_MSEC_ON(master, up-&gt;t_join_timer,</a>
<a name="ln166">		       on_join_timer,</a>
<a name="ln167">		       up, interval_msec);</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">void pim_upstream_join_suppress(struct pim_upstream *up,</a>
<a name="ln171">				struct in_addr rpf_addr,</a>
<a name="ln172">				int holdtime)</a>
<a name="ln173">{</a>
<a name="ln174">  long t_joinsuppress_msec;</a>
<a name="ln175">  long join_timer_remain_msec;</a>
<a name="ln176"> </a>
<a name="ln177">  t_joinsuppress_msec = MIN(pim_if_t_suppressed_msec(up-&gt;rpf.source_nexthop.interface),</a>
<a name="ln178">			    1000 * holdtime);</a>
<a name="ln179"> </a>
<a name="ln180">  join_timer_remain_msec = pim_time_timer_remain_msec(up-&gt;t_join_timer);</a>
<a name="ln181"> </a>
<a name="ln182">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln183">    char src_str[100];</a>
<a name="ln184">    char grp_str[100];</a>
<a name="ln185">    char rpf_str[100];</a>
<a name="ln186">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, up-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln187">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, up-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln188">    pim_inet4_dump(&quot;&lt;rpf?&gt;&quot;, rpf_addr, rpf_str, sizeof(rpf_str));</a>
<a name="ln189">    zlog_debug(&quot;%s %s: detected Join(%s,%s) to RPF'(S,G)=%s: join_timer=%ld msec t_joinsuppress=%ld msec&quot;,</a>
<a name="ln190">	       __FILE__, __PRETTY_FUNCTION__, </a>
<a name="ln191">	       src_str, grp_str,</a>
<a name="ln192">	       rpf_str,</a>
<a name="ln193">	       join_timer_remain_msec, t_joinsuppress_msec);</a>
<a name="ln194">  }</a>
<a name="ln195"> </a>
<a name="ln196">  if (join_timer_remain_msec &lt; t_joinsuppress_msec) {</a>
<a name="ln197">    if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln198">      char src_str[100];</a>
<a name="ln199">      char grp_str[100];</a>
<a name="ln200">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, up-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln201">      pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, up-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln202">      zlog_debug(&quot;%s %s: suppressing Join(S,G)=(%s,%s) for %ld msec&quot;,</a>
<a name="ln203">		 __FILE__, __PRETTY_FUNCTION__, </a>
<a name="ln204">		 src_str, grp_str, t_joinsuppress_msec);</a>
<a name="ln205">    }</a>
<a name="ln206"> </a>
<a name="ln207">    pim_upstream_join_timer_restart_msec(up, t_joinsuppress_msec);</a>
<a name="ln208">  }</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">void pim_upstream_join_timer_decrease_to_t_override(const char *debug_label,</a>
<a name="ln212">						    struct pim_upstream *up,</a>
<a name="ln213">						    struct in_addr rpf_addr)</a>
<a name="ln214">{</a>
<a name="ln215">  long join_timer_remain_msec;</a>
<a name="ln216">  int t_override_msec;</a>
<a name="ln217"> </a>
<a name="ln218">  join_timer_remain_msec = pim_time_timer_remain_msec(up-&gt;t_join_timer);</a>
<a name="ln219">  t_override_msec = pim_if_t_override_msec(up-&gt;rpf.source_nexthop.interface);</a>
<a name="ln220"> </a>
<a name="ln221">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln222">    char src_str[100];</a>
<a name="ln223">    char grp_str[100];</a>
<a name="ln224">    char rpf_str[100];</a>
<a name="ln225">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, up-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln226">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, up-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln227">    pim_inet4_dump(&quot;&lt;rpf?&gt;&quot;, rpf_addr, rpf_str, sizeof(rpf_str));</a>
<a name="ln228">    zlog_debug(&quot;%s: to RPF'(%s,%s)=%s: join_timer=%ld msec t_override=%d msec&quot;,</a>
<a name="ln229">	       debug_label,</a>
<a name="ln230">	       src_str, grp_str, rpf_str,</a>
<a name="ln231">	       join_timer_remain_msec, t_override_msec);</a>
<a name="ln232">  }</a>
<a name="ln233">    </a>
<a name="ln234">  if (join_timer_remain_msec &gt; t_override_msec) {</a>
<a name="ln235">    if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln236">      char src_str[100];</a>
<a name="ln237">      char grp_str[100];</a>
<a name="ln238">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, up-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln239">      pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, up-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln240">      zlog_debug(&quot;%s: decreasing (S,G)=(%s,%s) join timer to t_override=%d msec&quot;,</a>
<a name="ln241">		 debug_label,</a>
<a name="ln242">		 src_str, grp_str,</a>
<a name="ln243">		 t_override_msec);</a>
<a name="ln244">    }</a>
<a name="ln245"> </a>
<a name="ln246">    pim_upstream_join_timer_restart_msec(up, t_override_msec);</a>
<a name="ln247">  }</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">static void forward_on(struct pim_upstream *up)</a>
<a name="ln251">{</a>
<a name="ln252">  struct listnode      *ifnode;</a>
<a name="ln253">  struct listnode      *ifnextnode;</a>
<a name="ln254">  struct listnode      *chnode;</a>
<a name="ln255">  struct listnode      *chnextnode;</a>
<a name="ln256">  struct interface     *ifp;</a>
<a name="ln257">  struct pim_interface *pim_ifp;</a>
<a name="ln258">  struct pim_ifchannel *ch;</a>
<a name="ln259"> </a>
<a name="ln260">  /* scan all interfaces */</a>
<a name="ln261">  for (ALL_LIST_ELEMENTS(iflist, ifnode, ifnextnode, ifp)) {</a>
<a name="ln262">    pim_ifp = ifp-&gt;info;</a>
<a name="ln263">    if (!pim_ifp)</a>
<a name="ln264">      continue;</a>
<a name="ln265"> </a>
<a name="ln266">    /* scan per-interface (S,G) state */</a>
<a name="ln267">    for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, chnode, chnextnode, ch)) {</a>
<a name="ln268"> </a>
<a name="ln269">      if (ch-&gt;upstream != up)</a>
<a name="ln270">	continue;</a>
<a name="ln271"> </a>
<a name="ln272">      if (pim_macro_chisin_oiflist(ch))</a>
<a name="ln273">	pim_forward_start(ch);</a>
<a name="ln274"> </a>
<a name="ln275">    } /* scan iface channel list */</a>
<a name="ln276">  } /* scan iflist */</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">static void forward_off(struct pim_upstream *up)</a>
<a name="ln280">{</a>
<a name="ln281">  struct listnode      *ifnode;</a>
<a name="ln282">  struct listnode      *ifnextnode;</a>
<a name="ln283">  struct listnode      *chnode;</a>
<a name="ln284">  struct listnode      *chnextnode;</a>
<a name="ln285">  struct interface     *ifp;</a>
<a name="ln286">  struct pim_interface *pim_ifp;</a>
<a name="ln287">  struct pim_ifchannel *ch;</a>
<a name="ln288"> </a>
<a name="ln289">  /* scan all interfaces */</a>
<a name="ln290">  for (ALL_LIST_ELEMENTS(iflist, ifnode, ifnextnode, ifp)) {</a>
<a name="ln291">    pim_ifp = ifp-&gt;info;</a>
<a name="ln292">    if (!pim_ifp)</a>
<a name="ln293">      continue;</a>
<a name="ln294"> </a>
<a name="ln295">    /* scan per-interface (S,G) state */</a>
<a name="ln296">    for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, chnode, chnextnode, ch)) {</a>
<a name="ln297"> </a>
<a name="ln298">      if (ch-&gt;upstream != up)</a>
<a name="ln299">	continue;</a>
<a name="ln300"> </a>
<a name="ln301">      pim_forward_stop(ch);</a>
<a name="ln302"> </a>
<a name="ln303">    } /* scan iface channel list */</a>
<a name="ln304">  } /* scan iflist */</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">static void pim_upstream_switch(struct pim_upstream *up,</a>
<a name="ln308">				enum pim_upstream_state new_state)</a>
<a name="ln309">{</a>
<a name="ln310">  enum pim_upstream_state old_state = up-&gt;join_state;</a>
<a name="ln311"> </a>
<a name="ln312">  zassert(old_state != new_state);</a>
<a name="ln313">  </a>
<a name="ln314">  up-&gt;join_state       = new_state;</a>
<a name="ln315">  up-&gt;state_transition = pim_time_monotonic_sec();</a>
<a name="ln316"> </a>
<a name="ln317">  if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln318">    char src_str[100];</a>
<a name="ln319">    char grp_str[100];</a>
<a name="ln320">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, up-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln321">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, up-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln322">    zlog_debug(&quot;%s: PIM_UPSTREAM_%s: (S,G)=(%s,%s)&quot;,</a>
<a name="ln323">	       __PRETTY_FUNCTION__,</a>
<a name="ln324">	       ((new_state == PIM_UPSTREAM_JOINED) ? &quot;JOINED&quot; : &quot;NOTJOINED&quot;),</a>
<a name="ln325">	       src_str, grp_str);</a>
<a name="ln326">  }</a>
<a name="ln327"> </a>
<a name="ln328">  pim_upstream_update_assert_tracking_desired(up);</a>
<a name="ln329"> </a>
<a name="ln330">  if (new_state == PIM_UPSTREAM_JOINED) {</a>
<a name="ln331">    forward_on(up);</a>
<a name="ln332">    send_join(up);</a>
<a name="ln333">    join_timer_start(up);</a>
<a name="ln334">  }</a>
<a name="ln335">  else {</a>
<a name="ln336">    forward_off(up);</a>
<a name="ln337">    pim_joinprune_send(up-&gt;rpf.source_nexthop.interface,</a>
<a name="ln338">		       up-&gt;rpf.rpf_addr,</a>
<a name="ln339">		       up-&gt;source_addr,</a>
<a name="ln340">		       up-&gt;group_addr,</a>
<a name="ln341">		       0 /* prune */);</a>
<a name="ln342">    zassert(up-&gt;t_join_timer);</a>
<a name="ln343">    THREAD_OFF(up-&gt;t_join_timer);</a>
<a name="ln344">  }</a>
<a name="ln345"> </a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">static struct pim_upstream *pim_upstream_new(struct in_addr source_addr,</a>
<a name="ln349">					     struct in_addr group_addr)</a>
<a name="ln350">{</a>
<a name="ln351">  struct pim_upstream *up;</a>
<a name="ln352">  enum pim_rpf_result rpf_result;</a>
<a name="ln353"> </a>
<a name="ln354">  up = XMALLOC(MTYPE_PIM_UPSTREAM, sizeof(*up));</a>
<a name="ln355">  if (!up) {</a>
<a name="ln356">    zlog_err(&quot;%s: PIM XMALLOC(%zu) failure&quot;,</a>
<a name="ln357">	     __PRETTY_FUNCTION__, sizeof(*up));</a>
<a name="ln358">    return 0;</a>
<a name="ln359">  }</a>
<a name="ln360">  </a>
<a name="ln361">  up-&gt;source_addr                = source_addr;</a>
<a name="ln362">  up-&gt;group_addr                 = group_addr;</a>
<a name="ln363">  up-&gt;flags                      = 0;</a>
<a name="ln364">  up-&gt;ref_count                  = 1;</a>
<a name="ln365">  up-&gt;t_join_timer               = 0;</a>
<a name="ln366">  up-&gt;join_state                 = 0;</a>
<a name="ln367">  up-&gt;state_transition           = pim_time_monotonic_sec();</a>
<a name="ln368">  up-&gt;channel_oil                = 0;</a>
<a name="ln369"> </a>
<a name="ln370">  up-&gt;rpf.source_nexthop.interface                = 0;</a>
<a name="ln371">  up-&gt;rpf.source_nexthop.mrib_nexthop_addr.s_addr = PIM_NET_INADDR_ANY;</a>
<a name="ln372">  up-&gt;rpf.source_nexthop.mrib_metric_preference   = qpim_infinite_assert_metric.metric_preference;</a>
<a name="ln373">  up-&gt;rpf.source_nexthop.mrib_route_metric        = qpim_infinite_assert_metric.route_metric;</a>
<a name="ln374">  up-&gt;rpf.rpf_addr.s_addr                         = PIM_NET_INADDR_ANY;</a>
<a name="ln375"> </a>
<a name="ln376">  rpf_result = pim_rpf_update(up, 0);</a>
<a name="ln377">  if (rpf_result == PIM_RPF_FAILURE) {</a>
<a name="ln378">    XFREE(MTYPE_PIM_UPSTREAM, up);</a>
<a name="ln379">    return NULL;</a>
<a name="ln380">  }</a>
<a name="ln381"> </a>
<a name="ln382">  listnode_add(qpim_upstream_list, up);</a>
<a name="ln383"> </a>
<a name="ln384">  return up;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">struct pim_upstream *pim_upstream_find(struct in_addr source_addr,</a>
<a name="ln388">				       struct in_addr group_addr)</a>
<a name="ln389">{</a>
<a name="ln390">  struct listnode     *up_node;</a>
<a name="ln391">  struct pim_upstream *up;</a>
<a name="ln392"> </a>
<a name="ln393">  for (ALL_LIST_ELEMENTS_RO(qpim_upstream_list, up_node, up)) {</a>
<a name="ln394">    if (</a>
<a name="ln395">	(source_addr.s_addr == up-&gt;source_addr.s_addr) &amp;&amp;</a>
<a name="ln396">	(group_addr.s_addr == up-&gt;group_addr.s_addr)</a>
<a name="ln397">	) {</a>
<a name="ln398">      return up;</a>
<a name="ln399">    }</a>
<a name="ln400">  }</a>
<a name="ln401"> </a>
<a name="ln402">  return 0;</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">struct pim_upstream *pim_upstream_add(struct in_addr source_addr,</a>
<a name="ln406">				      struct in_addr group_addr)</a>
<a name="ln407">{</a>
<a name="ln408">  struct pim_upstream *up;</a>
<a name="ln409"> </a>
<a name="ln410">  up = pim_upstream_find(source_addr, group_addr);</a>
<a name="ln411">  if (up) {</a>
<a name="ln412">    ++up-&gt;ref_count;</a>
<a name="ln413">  }</a>
<a name="ln414">  else {</a>
<a name="ln415">    up = pim_upstream_new(source_addr, group_addr);</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418">  return up;</a>
<a name="ln419">}</a>
<a name="ln420"> </a>
<a name="ln421">void pim_upstream_del(struct pim_upstream *up)</a>
<a name="ln422">{</a>
<a name="ln423">  --up-&gt;ref_count;</a>
<a name="ln424"> </a>
<a name="ln425">  if (up-&gt;ref_count &lt; 1) {</a>
<a name="ln426">    pim_upstream_delete(up);</a>
<a name="ln427">  }</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">/*</a>
<a name="ln431">  Evaluate JoinDesired(S,G):</a>
<a name="ln432"> </a>
<a name="ln433">  JoinDesired(S,G) is true if there is a downstream (S,G) interface I</a>
<a name="ln434">  in the set:</a>
<a name="ln435"> </a>
<a name="ln436">  inherited_olist(S,G) =</a>
<a name="ln437">  joins(S,G) (+) pim_include(S,G) (-) lost_assert(S,G)</a>
<a name="ln438"> </a>
<a name="ln439">  JoinDesired(S,G) may be affected by changes in the following:</a>
<a name="ln440"> </a>
<a name="ln441">  pim_ifp-&gt;primary_address</a>
<a name="ln442">  pim_ifp-&gt;pim_dr_addr</a>
<a name="ln443">  ch-&gt;ifassert_winner_metric</a>
<a name="ln444">  ch-&gt;ifassert_winner</a>
<a name="ln445">  ch-&gt;local_ifmembership </a>
<a name="ln446">  ch-&gt;ifjoin_state</a>
<a name="ln447">  ch-&gt;upstream-&gt;rpf.source_nexthop.mrib_metric_preference</a>
<a name="ln448">  ch-&gt;upstream-&gt;rpf.source_nexthop.mrib_route_metric</a>
<a name="ln449">  ch-&gt;upstream-&gt;rpf.source_nexthop.interface</a>
<a name="ln450"> </a>
<a name="ln451">  See also pim_upstream_update_join_desired() below.</a>
<a name="ln452"> */</a>
<a name="ln453">int pim_upstream_evaluate_join_desired(struct pim_upstream *up)</a>
<a name="ln454">{</a>
<a name="ln455">  struct listnode      *ifnode;</a>
<a name="ln456">  struct listnode      *ifnextnode;</a>
<a name="ln457">  struct listnode      *chnode;</a>
<a name="ln458">  struct listnode      *chnextnode;</a>
<a name="ln459">  struct interface     *ifp;</a>
<a name="ln460">  struct pim_interface *pim_ifp;</a>
<a name="ln461">  struct pim_ifchannel *ch;</a>
<a name="ln462"> </a>
<a name="ln463">  /* scan all interfaces */</a>
<a name="ln464">  for (ALL_LIST_ELEMENTS(iflist, ifnode, ifnextnode, ifp)) {</a>
<a name="ln465">    pim_ifp = ifp-&gt;info;</a>
<a name="ln466">    if (!pim_ifp)</a>
<a name="ln467">      continue;</a>
<a name="ln468"> </a>
<a name="ln469">    /* scan per-interface (S,G) state */</a>
<a name="ln470">    for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, chnode, chnextnode, ch)) {</a>
<a name="ln471">      if (ch-&gt;upstream != up)</a>
<a name="ln472">	continue;</a>
<a name="ln473"> </a>
<a name="ln474">      if (pim_macro_ch_lost_assert(ch))</a>
<a name="ln475">	continue; /* keep searching */</a>
<a name="ln476"> </a>
<a name="ln477">      if (pim_macro_chisin_joins_or_include(ch))</a>
<a name="ln478">	return 1; /* true */</a>
<a name="ln479">    } /* scan iface channel list */</a>
<a name="ln480">  } /* scan iflist */</a>
<a name="ln481"> </a>
<a name="ln482">  return 0; /* false */</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">/*</a>
<a name="ln486">  See also pim_upstream_evaluate_join_desired() above.</a>
<a name="ln487">*/</a>
<a name="ln488">void pim_upstream_update_join_desired(struct pim_upstream *up)</a>
<a name="ln489">{</a>
<a name="ln490">  int was_join_desired; /* boolean */</a>
<a name="ln491">  int is_join_desired; /* boolean */</a>
<a name="ln492"> </a>
<a name="ln493">  was_join_desired = PIM_UPSTREAM_FLAG_TEST_DR_JOIN_DESIRED(up-&gt;flags);</a>
<a name="ln494"> </a>
<a name="ln495">  is_join_desired = pim_upstream_evaluate_join_desired(up);</a>
<a name="ln496">  if (is_join_desired)</a>
<a name="ln497">    PIM_UPSTREAM_FLAG_SET_DR_JOIN_DESIRED(up-&gt;flags);</a>
<a name="ln498">  else</a>
<a name="ln499">    PIM_UPSTREAM_FLAG_UNSET_DR_JOIN_DESIRED(up-&gt;flags);</a>
<a name="ln500"> </a>
<a name="ln501">  /* switched from false to true */</a>
<a name="ln502">  if (is_join_desired &amp;&amp; !was_join_desired) {</a>
<a name="ln503">    zassert(up-&gt;join_state == PIM_UPSTREAM_NOTJOINED);</a>
<a name="ln504">    pim_upstream_switch(up, PIM_UPSTREAM_JOINED);</a>
<a name="ln505">    return;</a>
<a name="ln506">  }</a>
<a name="ln507">      </a>
<a name="ln508">  /* switched from true to false */</a>
<a name="ln509">  if (!is_join_desired &amp;&amp; was_join_desired) {</a>
<a name="ln510">    zassert(up-&gt;join_state == PIM_UPSTREAM_JOINED);</a>
<a name="ln511">    pim_upstream_switch(up, PIM_UPSTREAM_NOTJOINED);</a>
<a name="ln512">    return;</a>
<a name="ln513">  }</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">/*</a>
<a name="ln517">  RFC 4601 4.5.7. Sending (S,G) Join/Prune Messages</a>
<a name="ln518">  Transitions from Joined State</a>
<a name="ln519">  RPF'(S,G) GenID changes</a>
<a name="ln520"> </a>
<a name="ln521">  The upstream (S,G) state machine remains in Joined state.  If the</a>
<a name="ln522">  Join Timer is set to expire in more than t_override seconds, reset</a>
<a name="ln523">  it so that it expires after t_override seconds.</a>
<a name="ln524">*/</a>
<a name="ln525">void pim_upstream_rpf_genid_changed(struct in_addr neigh_addr)</a>
<a name="ln526">{</a>
<a name="ln527">  struct listnode     *up_node;</a>
<a name="ln528">  struct listnode     *up_nextnode;</a>
<a name="ln529">  struct pim_upstream *up;</a>
<a name="ln530"> </a>
<a name="ln531">  /*</a>
<a name="ln532">    Scan all (S,G) upstreams searching for RPF'(S,G)=neigh_addr</a>
<a name="ln533">  */</a>
<a name="ln534">  for (ALL_LIST_ELEMENTS(qpim_upstream_list, up_node, up_nextnode, up)) {</a>
<a name="ln535"> </a>
<a name="ln536">    if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln537">      char neigh_str[100];</a>
<a name="ln538">      char src_str[100];</a>
<a name="ln539">      char grp_str[100];</a>
<a name="ln540">      char rpf_addr_str[100];</a>
<a name="ln541">      pim_inet4_dump(&quot;&lt;neigh?&gt;&quot;, neigh_addr, neigh_str, sizeof(neigh_str));</a>
<a name="ln542">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, up-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln543">      pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, up-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln544">      pim_inet4_dump(&quot;&lt;rpf?&gt;&quot;, up-&gt;rpf.rpf_addr, rpf_addr_str, sizeof(rpf_addr_str));</a>
<a name="ln545">      zlog_debug(&quot;%s: matching neigh=%s against upstream (S,G)=(%s,%s) joined=%d rpf_addr=%s&quot;,</a>
<a name="ln546">		 __PRETTY_FUNCTION__,</a>
<a name="ln547">		 neigh_str, src_str, grp_str,</a>
<a name="ln548">		 up-&gt;join_state == PIM_UPSTREAM_JOINED,</a>
<a name="ln549">		 rpf_addr_str);</a>
<a name="ln550">    }</a>
<a name="ln551"> </a>
<a name="ln552">    /* consider only (S,G) upstream in Joined state */</a>
<a name="ln553">    if (up-&gt;join_state != PIM_UPSTREAM_JOINED)</a>
<a name="ln554">      continue;</a>
<a name="ln555"> </a>
<a name="ln556">    /* match RPF'(S,G)=neigh_addr */</a>
<a name="ln557">    if (up-&gt;rpf.rpf_addr.s_addr != neigh_addr.s_addr)</a>
<a name="ln558">      continue;</a>
<a name="ln559"> </a>
<a name="ln560">    pim_upstream_join_timer_decrease_to_t_override(&quot;RPF'(S,G) GenID change&quot;,</a>
<a name="ln561">						   up, neigh_addr);</a>
<a name="ln562">  }</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565"> </a>
<a name="ln566">void pim_upstream_rpf_interface_changed(struct pim_upstream *up,</a>
<a name="ln567">					struct interface *old_rpf_ifp)</a>
<a name="ln568">{</a>
<a name="ln569">  struct listnode  *ifnode;</a>
<a name="ln570">  struct listnode  *ifnextnode;</a>
<a name="ln571">  struct interface *ifp;</a>
<a name="ln572"> </a>
<a name="ln573">  /* scan all interfaces */</a>
<a name="ln574">  for (ALL_LIST_ELEMENTS(iflist, ifnode, ifnextnode, ifp)) {</a>
<a name="ln575">    struct listnode      *chnode;</a>
<a name="ln576">    struct listnode      *chnextnode;</a>
<a name="ln577">    struct pim_ifchannel *ch;</a>
<a name="ln578">    struct pim_interface *pim_ifp;</a>
<a name="ln579"> </a>
<a name="ln580">    pim_ifp = ifp-&gt;info;</a>
<a name="ln581">    if (!pim_ifp)</a>
<a name="ln582">      continue;</a>
<a name="ln583"> </a>
<a name="ln584">    /* search all ifchannels */</a>
<a name="ln585">    for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, chnode, chnextnode, ch)) {</a>
<a name="ln586">      if (ch-&gt;upstream != up)</a>
<a name="ln587">	continue;</a>
<a name="ln588"> </a>
<a name="ln589">      if (ch-&gt;ifassert_state == PIM_IFASSERT_I_AM_LOSER) {</a>
<a name="ln590">	if (</a>
<a name="ln591">	    /* RPF_interface(S) was NOT I */</a>
<a name="ln592">	    (old_rpf_ifp == ch-&gt;interface)</a>
<a name="ln593">	    &amp;&amp;</a>
<a name="ln594">	    /* RPF_interface(S) stopped being I */</a>
<a name="ln595">	    (ch-&gt;upstream-&gt;rpf.source_nexthop.interface != ch-&gt;interface)</a>
<a name="ln596">	    ) {</a>
<a name="ln597">	  assert_action_a5(ch);</a>
<a name="ln598">	}</a>
<a name="ln599">      } /* PIM_IFASSERT_I_AM_LOSER */</a>
<a name="ln600"> </a>
<a name="ln601">      pim_ifchannel_update_assert_tracking_desired(ch);</a>
<a name="ln602">    }</a>
<a name="ln603">  }</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">void pim_upstream_update_could_assert(struct pim_upstream *up)</a>
<a name="ln607">{</a>
<a name="ln608">  struct listnode      *ifnode;</a>
<a name="ln609">  struct listnode      *ifnextnode;</a>
<a name="ln610">  struct listnode      *chnode;</a>
<a name="ln611">  struct listnode      *chnextnode;</a>
<a name="ln612">  struct interface     *ifp;</a>
<a name="ln613">  struct pim_interface *pim_ifp;</a>
<a name="ln614">  struct pim_ifchannel *ch;</a>
<a name="ln615"> </a>
<a name="ln616">  /* scan all interfaces */</a>
<a name="ln617">  for (ALL_LIST_ELEMENTS(iflist, ifnode, ifnextnode, ifp)) {</a>
<a name="ln618">    pim_ifp = ifp-&gt;info;</a>
<a name="ln619">    if (!pim_ifp)</a>
<a name="ln620">      continue;</a>
<a name="ln621"> </a>
<a name="ln622">    /* scan per-interface (S,G) state */</a>
<a name="ln623">    for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, chnode, chnextnode, ch)) {</a>
<a name="ln624"> </a>
<a name="ln625">      if (ch-&gt;upstream != up)</a>
<a name="ln626">	continue;</a>
<a name="ln627"> </a>
<a name="ln628">      pim_ifchannel_update_could_assert(ch);</a>
<a name="ln629"> </a>
<a name="ln630">    } /* scan iface channel list */</a>
<a name="ln631">  } /* scan iflist */</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">void pim_upstream_update_my_assert_metric(struct pim_upstream *up)</a>
<a name="ln635">{</a>
<a name="ln636">  struct listnode      *ifnode;</a>
<a name="ln637">  struct listnode      *ifnextnode;</a>
<a name="ln638">  struct listnode      *chnode;</a>
<a name="ln639">  struct listnode      *chnextnode;</a>
<a name="ln640">  struct interface     *ifp;</a>
<a name="ln641">  struct pim_interface *pim_ifp;</a>
<a name="ln642">  struct pim_ifchannel *ch;</a>
<a name="ln643"> </a>
<a name="ln644">  /* scan all interfaces */</a>
<a name="ln645">  for (ALL_LIST_ELEMENTS(iflist, ifnode, ifnextnode, ifp)) {</a>
<a name="ln646">    pim_ifp = ifp-&gt;info;</a>
<a name="ln647">    if (!pim_ifp)</a>
<a name="ln648">      continue;</a>
<a name="ln649"> </a>
<a name="ln650">    /* scan per-interface (S,G) state */</a>
<a name="ln651">    for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, chnode, chnextnode, ch)) {</a>
<a name="ln652"> </a>
<a name="ln653">      if (ch-&gt;upstream != up)</a>
<a name="ln654">	continue;</a>
<a name="ln655"> </a>
<a name="ln656">      pim_ifchannel_update_my_assert_metric(ch);</a>
<a name="ln657"> </a>
<a name="ln658">    } /* scan iface channel list */</a>
<a name="ln659">  } /* scan iflist */</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">static void pim_upstream_update_assert_tracking_desired(struct pim_upstream *up)</a>
<a name="ln663">{</a>
<a name="ln664">  struct listnode      *ifnode;</a>
<a name="ln665">  struct listnode      *ifnextnode;</a>
<a name="ln666">  struct listnode      *chnode;</a>
<a name="ln667">  struct listnode      *chnextnode;</a>
<a name="ln668">  struct interface     *ifp;</a>
<a name="ln669">  struct pim_interface *pim_ifp;</a>
<a name="ln670">  struct pim_ifchannel *ch;</a>
<a name="ln671"> </a>
<a name="ln672">  /* scan all interfaces */</a>
<a name="ln673">  for (ALL_LIST_ELEMENTS(iflist, ifnode, ifnextnode, ifp)) {</a>
<a name="ln674">    pim_ifp = ifp-&gt;info;</a>
<a name="ln675">    if (!pim_ifp)</a>
<a name="ln676">      continue;</a>
<a name="ln677"> </a>
<a name="ln678">    /* scan per-interface (S,G) state */</a>
<a name="ln679">    for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, chnode, chnextnode, ch)) {</a>
<a name="ln680"> </a>
<a name="ln681">      if (ch-&gt;upstream != up)</a>
<a name="ln682">	continue;</a>
<a name="ln683"> </a>
<a name="ln684">      pim_ifchannel_update_assert_tracking_desired(ch);</a>
<a name="ln685"> </a>
<a name="ln686">    } /* scan iface channel list */</a>
<a name="ln687">  } /* scan iflist */</a>
<a name="ln688">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
