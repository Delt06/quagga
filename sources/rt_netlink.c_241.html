
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>rt_netlink.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Kernel routing table updates using netlink over GNU/Linux system.</a>
<a name="ln2"> * Copyright (C) 1997, 98, 99 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23">#include &lt;net/if_arp.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">/* Hack for GNU libc version 2. */</a>
<a name="ln26">#ifndef MSG_TRUNC</a>
<a name="ln27">#define MSG_TRUNC      0x20</a>
<a name="ln28">#endif /* MSG_TRUNC */</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;linklist.h&quot;</a>
<a name="ln31">#include &quot;if.h&quot;</a>
<a name="ln32">#include &quot;log.h&quot;</a>
<a name="ln33">#include &quot;prefix.h&quot;</a>
<a name="ln34">#include &quot;connected.h&quot;</a>
<a name="ln35">#include &quot;table.h&quot;</a>
<a name="ln36">#include &quot;memory.h&quot;</a>
<a name="ln37">#include &quot;rib.h&quot;</a>
<a name="ln38">#include &quot;thread.h&quot;</a>
<a name="ln39">#include &quot;privs.h&quot;</a>
<a name="ln40">#include &quot;vrf.h&quot;</a>
<a name="ln41">#include &quot;nexthop.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln44">#include &quot;zebra/rt.h&quot;</a>
<a name="ln45">#include &quot;zebra/redistribute.h&quot;</a>
<a name="ln46">#include &quot;zebra/interface.h&quot;</a>
<a name="ln47">#include &quot;zebra/debug.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">#include &quot;rt_netlink.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">static const struct message nlmsg_str[] = {</a>
<a name="ln52">  {RTM_NEWROUTE, &quot;RTM_NEWROUTE&quot;},</a>
<a name="ln53">  {RTM_DELROUTE, &quot;RTM_DELROUTE&quot;},</a>
<a name="ln54">  {RTM_GETROUTE, &quot;RTM_GETROUTE&quot;},</a>
<a name="ln55">  {RTM_NEWLINK,  &quot;RTM_NEWLINK&quot;},</a>
<a name="ln56">  {RTM_DELLINK,  &quot;RTM_DELLINK&quot;},</a>
<a name="ln57">  {RTM_GETLINK,  &quot;RTM_GETLINK&quot;},</a>
<a name="ln58">  {RTM_NEWADDR,  &quot;RTM_NEWADDR&quot;},</a>
<a name="ln59">  {RTM_DELADDR,  &quot;RTM_DELADDR&quot;},</a>
<a name="ln60">  {RTM_GETADDR,  &quot;RTM_GETADDR&quot;},</a>
<a name="ln61">  {0, NULL}</a>
<a name="ln62">};</a>
<a name="ln63"> </a>
<a name="ln64">extern struct zebra_t zebrad;</a>
<a name="ln65"> </a>
<a name="ln66">extern struct zebra_privs_t zserv_privs;</a>
<a name="ln67"> </a>
<a name="ln68">extern u_int32_t nl_rcvbufsize;</a>
<a name="ln69"> </a>
<a name="ln70">static struct {</a>
<a name="ln71">  char *p;</a>
<a name="ln72">  size_t size;</a>
<a name="ln73">} nl_rcvbuf;</a>
<a name="ln74"> </a>
<a name="ln75">/* Note: on netlink systems, there should be a 1-to-1 mapping between interface</a>
<a name="ln76">   names and ifindex values. */</a>
<a name="ln77">static void</a>
<a name="ln78">set_ifindex(struct interface *ifp, ifindex_t ifi_index)</a>
<a name="ln79">{</a>
<a name="ln80">  struct interface *oifp;</a>
<a name="ln81"> </a>
<a name="ln82">  if (((oifp = if_lookup_by_index(ifi_index)) != NULL) &amp;&amp; (oifp != ifp))</a>
<a name="ln83">    {</a>
<a name="ln84">      if (ifi_index == IFINDEX_INTERNAL)</a>
<a name="ln85">        zlog_err(&quot;Netlink is setting interface %s ifindex to reserved &quot;</a>
<a name="ln86">		 &quot;internal value %u&quot;, ifp-&gt;name, ifi_index);</a>
<a name="ln87">      else</a>
<a name="ln88">        {</a>
<a name="ln89">	  if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln90">	    zlog_debug(&quot;interface index %d was renamed from %s to %s&quot;,</a>
<a name="ln91">	    	       ifi_index, oifp-&gt;name, ifp-&gt;name);</a>
<a name="ln92">	  if (if_is_up(oifp))</a>
<a name="ln93">	    zlog_err(&quot;interface rename detected on up interface: index %d &quot;</a>
<a name="ln94">		     &quot;was renamed from %s to %s, results are uncertain!&quot;, </a>
<a name="ln95">	    	     ifi_index, oifp-&gt;name, ifp-&gt;name);</a>
<a name="ln96">	  if_delete_update(oifp);</a>
<a name="ln97">        }</a>
<a name="ln98">    }</a>
<a name="ln99">  ifp-&gt;ifindex = ifi_index;</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">#ifndef SO_RCVBUFFORCE</a>
<a name="ln103">#define SO_RCVBUFFORCE  (33)</a>
<a name="ln104">#endif</a>
<a name="ln105"> </a>
<a name="ln106">static int</a>
<a name="ln107">netlink_recvbuf (struct nlsock *nl, uint32_t newsize)</a>
<a name="ln108">{</a>
<a name="ln109">  u_int32_t oldsize;</a>
<a name="ln110">  socklen_t newlen = sizeof(newsize);</a>
<a name="ln111">  socklen_t oldlen = sizeof(oldsize);</a>
<a name="ln112">  int ret;</a>
<a name="ln113"> </a>
<a name="ln114">  ret = getsockopt(nl-&gt;sock, SOL_SOCKET, SO_RCVBUF, &amp;oldsize, &amp;oldlen);</a>
<a name="ln115">  if (ret &lt; 0)</a>
<a name="ln116">    {</a>
<a name="ln117">      zlog (NULL, LOG_ERR, &quot;Can't get %s receive buffer size: %s&quot;, nl-&gt;name,</a>
<a name="ln118">	    safe_strerror (errno));</a>
<a name="ln119">      return -1;</a>
<a name="ln120">    }</a>
<a name="ln121"> </a>
<a name="ln122">  /* Try force option (linux &gt;= 2.6.14) and fall back to normal set */</a>
<a name="ln123">  if ( zserv_privs.change (ZPRIVS_RAISE) )</a>
<a name="ln124">    zlog_err (&quot;routing_socket: Can't raise privileges&quot;);</a>
<a name="ln125">  ret = setsockopt(nl-&gt;sock, SOL_SOCKET, SO_RCVBUFFORCE, &amp;nl_rcvbufsize,</a>
<a name="ln126">		   sizeof(nl_rcvbufsize));</a>
<a name="ln127">  if ( zserv_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln128">    zlog_err (&quot;routing_socket: Can't lower privileges&quot;);</a>
<a name="ln129">  if (ret &lt; 0)</a>
<a name="ln130">     ret = setsockopt(nl-&gt;sock, SOL_SOCKET, SO_RCVBUF, &amp;nl_rcvbufsize,</a>
<a name="ln131">		      sizeof(nl_rcvbufsize));</a>
<a name="ln132">  if (ret &lt; 0)</a>
<a name="ln133">    {</a>
<a name="ln134">      zlog (NULL, LOG_ERR, &quot;Can't set %s receive buffer size: %s&quot;, nl-&gt;name,</a>
<a name="ln135">	    safe_strerror (errno));</a>
<a name="ln136">      return -1;</a>
<a name="ln137">    }</a>
<a name="ln138"> </a>
<a name="ln139">  ret = getsockopt(nl-&gt;sock, SOL_SOCKET, SO_RCVBUF, &amp;newsize, &amp;newlen);</a>
<a name="ln140">  if (ret &lt; 0)</a>
<a name="ln141">    {</a>
<a name="ln142">      zlog (NULL, LOG_ERR, &quot;Can't get %s receive buffer size: %s&quot;, nl-&gt;name,</a>
<a name="ln143">	    safe_strerror (errno));</a>
<a name="ln144">      return -1;</a>
<a name="ln145">    }</a>
<a name="ln146"> </a>
<a name="ln147">  zlog (NULL, LOG_INFO,</a>
<a name="ln148">	&quot;Setting netlink socket receive buffer size: %u -&gt; %u&quot;,</a>
<a name="ln149">	oldsize, newsize);</a>
<a name="ln150">  return 0;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">/* Make socket for Linux netlink interface. */</a>
<a name="ln154">static int</a>
<a name="ln155">netlink_socket (struct nlsock *nl, unsigned long groups, vrf_id_t vrf_id)</a>
<a name="ln156">{</a>
<a name="ln157">  int ret;</a>
<a name="ln158">  struct sockaddr_nl snl;</a>
<a name="ln159">  int sock;</a>
<a name="ln160">  int namelen;</a>
<a name="ln161">  int save_errno;</a>
<a name="ln162"> </a>
<a name="ln163">  if (zserv_privs.change (ZPRIVS_RAISE))</a>
<a name="ln164">    {</a>
<a name="ln165">      zlog (NULL, LOG_ERR, &quot;Can't raise privileges&quot;);</a>
<a name="ln166">      return -1;</a>
<a name="ln167">    }</a>
<a name="ln168"> </a>
<a name="ln169">  sock = vrf_socket (AF_NETLINK, SOCK_RAW, NETLINK_ROUTE, vrf_id);</a>
<a name="ln170">  if (sock &lt; 0)</a>
<a name="ln171">    {</a>
<a name="ln172">      zlog (NULL, LOG_ERR, &quot;Can't open %s socket: %s&quot;, nl-&gt;name,</a>
<a name="ln173">            safe_strerror (errno));</a>
<a name="ln174">      return -1;</a>
<a name="ln175">    }</a>
<a name="ln176"> </a>
<a name="ln177">  memset (&amp;snl, 0, sizeof snl);</a>
<a name="ln178">  snl.nl_family = AF_NETLINK;</a>
<a name="ln179">  snl.nl_groups = groups;</a>
<a name="ln180"> </a>
<a name="ln181">  /* Bind the socket to the netlink structure for anything. */</a>
<a name="ln182">  ret = bind (sock, (struct sockaddr *) &amp;snl, sizeof snl);</a>
<a name="ln183">  save_errno = errno;</a>
<a name="ln184">  if (zserv_privs.change (ZPRIVS_LOWER))</a>
<a name="ln185">    zlog (NULL, LOG_ERR, &quot;Can't lower privileges&quot;);</a>
<a name="ln186"> </a>
<a name="ln187">  if (ret &lt; 0)</a>
<a name="ln188">    {</a>
<a name="ln189">      zlog (NULL, LOG_ERR, &quot;Can't bind %s socket to group 0x%x: %s&quot;,</a>
<a name="ln190">            nl-&gt;name, snl.nl_groups, safe_strerror (save_errno));</a>
<a name="ln191">      close (sock);</a>
<a name="ln192">      return -1;</a>
<a name="ln193">    }</a>
<a name="ln194"> </a>
<a name="ln195">  /* multiple netlink sockets will have different nl_pid */</a>
<a name="ln196">  namelen = sizeof snl;</a>
<a name="ln197">  ret = getsockname (sock, (struct sockaddr *) &amp;snl, (socklen_t *) &amp;namelen);</a>
<a name="ln198">  if (ret &lt; 0 || namelen != sizeof snl)</a>
<a name="ln199">    {</a>
<a name="ln200">      zlog (NULL, LOG_ERR, &quot;Can't get %s socket name: %s&quot;, nl-&gt;name,</a>
<a name="ln201">            safe_strerror (errno));</a>
<a name="ln202">      close (sock);</a>
<a name="ln203">      return -1;</a>
<a name="ln204">    }</a>
<a name="ln205"> </a>
<a name="ln206">  nl-&gt;snl = snl;</a>
<a name="ln207">  nl-&gt;sock = sock;</a>
<a name="ln208">  return ret;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">/* Get type specified information from netlink. */</a>
<a name="ln212">static int</a>
<a name="ln213">netlink_request (int family, int type, struct nlsock *nl)</a>
<a name="ln214">{</a>
<a name="ln215">  int ret;</a>
<a name="ln216">  struct sockaddr_nl snl;</a>
<a name="ln217">  int save_errno;</a>
<a name="ln218"> </a>
<a name="ln219">  struct</a>
<a name="ln220">  {</a>
<a name="ln221">    struct nlmsghdr nlh;</a>
<a name="ln222">    struct rtgenmsg g;</a>
<a name="ln223">  } req;</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">  /* Check netlink socket. */</a>
<a name="ln227">  if (nl-&gt;sock &lt; 0)</a>
<a name="ln228">    {</a>
<a name="ln229">      zlog (NULL, LOG_ERR, &quot;%s socket isn't active.&quot;, nl-&gt;name);</a>
<a name="ln230">      return -1;</a>
<a name="ln231">    }</a>
<a name="ln232"> </a>
<a name="ln233">  memset (&amp;snl, 0, sizeof snl);</a>
<a name="ln234">  snl.nl_family = AF_NETLINK;</a>
<a name="ln235"> </a>
<a name="ln236">  memset (&amp;req, 0, sizeof req);</a>
<a name="ln237">  req.nlh.nlmsg_len = sizeof req;</a>
<a name="ln238">  req.nlh.nlmsg_type = type;</a>
<a name="ln239">  req.nlh.nlmsg_flags = NLM_F_ROOT | NLM_F_MATCH | NLM_F_REQUEST;</a>
<a name="ln240">  req.nlh.nlmsg_pid = nl-&gt;snl.nl_pid;</a>
<a name="ln241">  req.nlh.nlmsg_seq = ++nl-&gt;seq;</a>
<a name="ln242">  req.g.rtgen_family = family;</a>
<a name="ln243"> </a>
<a name="ln244">  /* linux appears to check capabilities on every message </a>
<a name="ln245">   * have to raise caps for every message sent</a>
<a name="ln246">   */</a>
<a name="ln247">  if (zserv_privs.change (ZPRIVS_RAISE))</a>
<a name="ln248">    {</a>
<a name="ln249">      zlog (NULL, LOG_ERR, &quot;Can't raise privileges&quot;);</a>
<a name="ln250">      return -1;</a>
<a name="ln251">    }</a>
<a name="ln252"> </a>
<a name="ln253">  ret = sendto (nl-&gt;sock, (void *) &amp;req, sizeof req, 0,</a>
<a name="ln254">                (struct sockaddr *) &amp;snl, sizeof snl);</a>
<a name="ln255">  save_errno = errno;</a>
<a name="ln256"> </a>
<a name="ln257">  if (zserv_privs.change (ZPRIVS_LOWER))</a>
<a name="ln258">    zlog (NULL, LOG_ERR, &quot;Can't lower privileges&quot;);</a>
<a name="ln259"> </a>
<a name="ln260">  if (ret &lt; 0)</a>
<a name="ln261">    {</a>
<a name="ln262">      zlog (NULL, LOG_ERR, &quot;%s sendto failed: %s&quot;, nl-&gt;name,</a>
<a name="ln263">            safe_strerror (save_errno));</a>
<a name="ln264">      return -1;</a>
<a name="ln265">    }</a>
<a name="ln266"> </a>
<a name="ln267">  return 0;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">/* Receive message from netlink interface and pass those information</a>
<a name="ln271">   to the given function. */</a>
<a name="ln272">static int</a>
<a name="ln273">netlink_parse_info (int (*filter) (struct sockaddr_nl *, struct nlmsghdr *,</a>
<a name="ln274">                                   vrf_id_t),</a>
<a name="ln275">                    struct nlsock *nl, struct zebra_vrf *zvrf)</a>
<a name="ln276">{</a>
<a name="ln277">  int status;</a>
<a name="ln278">  int ret = 0;</a>
<a name="ln279">  int error;</a>
<a name="ln280"> </a>
<a name="ln281">  while (1)</a>
<a name="ln282">    {</a>
<a name="ln283">      struct iovec iov = {</a>
<a name="ln284">        .iov_base = nl_rcvbuf.p,</a>
<a name="ln285">        .iov_len = nl_rcvbuf.size,</a>
<a name="ln286">      };</a>
<a name="ln287">      struct sockaddr_nl snl;</a>
<a name="ln288">      struct msghdr msg = {</a>
<a name="ln289">        .msg_name = (void *) &amp;snl,</a>
<a name="ln290">        .msg_namelen = sizeof snl,</a>
<a name="ln291">        .msg_iov = &amp;iov,</a>
<a name="ln292">        .msg_iovlen = 1</a>
<a name="ln293">      };</a>
<a name="ln294">      struct nlmsghdr *h;</a>
<a name="ln295"> </a>
<a name="ln296">      status = recvmsg (nl-&gt;sock, &amp;msg, 0);</a>
<a name="ln297">      if (status &lt; 0)</a>
<a name="ln298">        {</a>
<a name="ln299">          if (errno == EINTR)</a>
<a name="ln300">            continue;</a>
<a name="ln301">          if (errno == EWOULDBLOCK || errno == EAGAIN)</a>
<a name="ln302">            break;</a>
<a name="ln303">          zlog (NULL, LOG_ERR, &quot;%s recvmsg overrun: %s&quot;,</a>
<a name="ln304">	  	nl-&gt;name, safe_strerror(errno));</a>
<a name="ln305">          continue;</a>
<a name="ln306">        }</a>
<a name="ln307"> </a>
<a name="ln308">      if (status == 0)</a>
<a name="ln309">        {</a>
<a name="ln310">          zlog (NULL, LOG_ERR, &quot;%s EOF&quot;, nl-&gt;name);</a>
<a name="ln311">          return -1;</a>
<a name="ln312">        }</a>
<a name="ln313"> </a>
<a name="ln314">      if (msg.msg_namelen != sizeof snl)</a>
<a name="ln315">        {</a>
<a name="ln316">          zlog (NULL, LOG_ERR, &quot;%s sender address length error: length %d&quot;,</a>
<a name="ln317">                nl-&gt;name, msg.msg_namelen);</a>
<a name="ln318">          return -1;</a>
<a name="ln319">        }</a>
<a name="ln320">      </a>
<a name="ln321">      for (h = (struct nlmsghdr *) nl_rcvbuf.p; </a>
<a name="ln322">           NLMSG_OK (h, (unsigned int) status);</a>
<a name="ln323">           h = NLMSG_NEXT (h, status))</a>
<a name="ln324">        {</a>
<a name="ln325">          /* Finish of reading. */</a>
<a name="ln326">          if (h-&gt;nlmsg_type == NLMSG_DONE)</a>
<a name="ln327">            return ret;</a>
<a name="ln328"> </a>
<a name="ln329">          /* Error handling. */</a>
<a name="ln330">          if (h-&gt;nlmsg_type == NLMSG_ERROR)</a>
<a name="ln331">            {</a>
<a name="ln332">              struct nlmsgerr *err = (struct nlmsgerr *) NLMSG_DATA (h);</a>
<a name="ln333">	      int errnum = err-&gt;error;</a>
<a name="ln334">	      int msg_type = err-&gt;msg.nlmsg_type;</a>
<a name="ln335"> </a>
<a name="ln336">              /* If the error field is zero, then this is an ACK */</a>
<a name="ln337">              if (err-&gt;error == 0)</a>
<a name="ln338">                {</a>
<a name="ln339">                  if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln340">                    {</a>
<a name="ln341">                      zlog_debug (&quot;%s: %s ACK: type=%s(%u), seq=%u, pid=%u&quot;,</a>
<a name="ln342">                                 __FUNCTION__, nl-&gt;name,</a>
<a name="ln343">                                 lookup (nlmsg_str, err-&gt;msg.nlmsg_type),</a>
<a name="ln344">                                 err-&gt;msg.nlmsg_type, err-&gt;msg.nlmsg_seq,</a>
<a name="ln345">                                 err-&gt;msg.nlmsg_pid);</a>
<a name="ln346">                    }</a>
<a name="ln347"> </a>
<a name="ln348">                  /* return if not a multipart message, otherwise continue */</a>
<a name="ln349">                  if (!(h-&gt;nlmsg_flags &amp; NLM_F_MULTI))</a>
<a name="ln350">                    {</a>
<a name="ln351">                      return 0;</a>
<a name="ln352">                    }</a>
<a name="ln353">                  continue;</a>
<a name="ln354">                }</a>
<a name="ln355"> </a>
<a name="ln356">              if (h-&gt;nlmsg_len &lt; NLMSG_LENGTH (sizeof (struct nlmsgerr)))</a>
<a name="ln357">                {</a>
<a name="ln358">                  zlog (NULL, LOG_ERR, &quot;%s error: message truncated&quot;,</a>
<a name="ln359">                        nl-&gt;name);</a>
<a name="ln360">                  return -1;</a>
<a name="ln361">                }</a>
<a name="ln362"> </a>
<a name="ln363">              /* Deal with errors that occur because of races in link handling */</a>
<a name="ln364">	      if (nl == &amp;zvrf-&gt;netlink_cmd</a>
<a name="ln365">		  &amp;&amp; ((msg_type == RTM_DELROUTE &amp;&amp;</a>
<a name="ln366">		       (-errnum == ENODEV || -errnum == ESRCH))</a>
<a name="ln367">		      || (msg_type == RTM_NEWROUTE &amp;&amp; -errnum == EEXIST)))</a>
<a name="ln368">		{</a>
<a name="ln369">		  if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln370">		    zlog_debug (&quot;%s: error: %s type=%s(%u), seq=%u, pid=%u&quot;,</a>
<a name="ln371">				nl-&gt;name, safe_strerror (-errnum),</a>
<a name="ln372">				lookup (nlmsg_str, msg_type),</a>
<a name="ln373">				msg_type, err-&gt;msg.nlmsg_seq, err-&gt;msg.nlmsg_pid);</a>
<a name="ln374">		  return 0;</a>
<a name="ln375">		}</a>
<a name="ln376"> </a>
<a name="ln377">	      zlog_err (&quot;%s error: %s, type=%s(%u), seq=%u, pid=%u&quot;,</a>
<a name="ln378">			nl-&gt;name, safe_strerror (-errnum),</a>
<a name="ln379">			lookup (nlmsg_str, msg_type),</a>
<a name="ln380">			msg_type, err-&gt;msg.nlmsg_seq, err-&gt;msg.nlmsg_pid);</a>
<a name="ln381">              return -1;</a>
<a name="ln382">            }</a>
<a name="ln383"> </a>
<a name="ln384">          /* OK we got netlink message. */</a>
<a name="ln385">          if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln386">            zlog_debug (&quot;netlink_parse_info: %s type %s(%u), seq=%u, pid=%u&quot;,</a>
<a name="ln387">                       nl-&gt;name,</a>
<a name="ln388">                       lookup (nlmsg_str, h-&gt;nlmsg_type), h-&gt;nlmsg_type,</a>
<a name="ln389">                       h-&gt;nlmsg_seq, h-&gt;nlmsg_pid);</a>
<a name="ln390"> </a>
<a name="ln391">          /* skip unsolicited messages originating from command socket</a>
<a name="ln392">           * linux sets the originators port-id for {NEW|DEL}ADDR messages,</a>
<a name="ln393">           * so this has to be checked here. */</a>
<a name="ln394">          if (nl != &amp;zvrf-&gt;netlink_cmd</a>
<a name="ln395">              &amp;&amp; h-&gt;nlmsg_pid == zvrf-&gt;netlink_cmd.snl.nl_pid</a>
<a name="ln396">              &amp;&amp; (h-&gt;nlmsg_type != RTM_NEWADDR &amp;&amp; h-&gt;nlmsg_type != RTM_DELADDR))</a>
<a name="ln397">            {</a>
<a name="ln398">              if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln399">                zlog_debug (&quot;netlink_parse_info: %s packet comes from %s&quot;,</a>
<a name="ln400">                            zvrf-&gt;netlink_cmd.name, nl-&gt;name);</a>
<a name="ln401">              continue;</a>
<a name="ln402">            }</a>
<a name="ln403"> </a>
<a name="ln404">          error = (*filter) (&amp;snl, h, zvrf-&gt;vrf_id);</a>
<a name="ln405">          if (error &lt; 0)</a>
<a name="ln406">            {</a>
<a name="ln407">              zlog (NULL, LOG_ERR, &quot;%s filter function error&quot;, nl-&gt;name);</a>
<a name="ln408">              ret = error;</a>
<a name="ln409">            }</a>
<a name="ln410">        }</a>
<a name="ln411"> </a>
<a name="ln412">      /* After error care. */</a>
<a name="ln413">      if (msg.msg_flags &amp; MSG_TRUNC)</a>
<a name="ln414">        {</a>
<a name="ln415">          zlog (NULL, LOG_ERR, &quot;%s error: message truncated!&quot;, nl-&gt;name);</a>
<a name="ln416">          zlog (NULL, LOG_ERR, </a>
<a name="ln417">                &quot;Must restart with larger --nl-bufsize value!&quot;);</a>
<a name="ln418">          continue;</a>
<a name="ln419">        }</a>
<a name="ln420">      if (status)</a>
<a name="ln421">        {</a>
<a name="ln422">          zlog (NULL, LOG_ERR, &quot;%s error: data remnant size %d&quot;, nl-&gt;name,</a>
<a name="ln423">                status);</a>
<a name="ln424">          return -1;</a>
<a name="ln425">        }</a>
<a name="ln426">    }</a>
<a name="ln427">  return ret;</a>
<a name="ln428">}</a>
<a name="ln429"> </a>
<a name="ln430">/* Utility function for parse rtattr. */</a>
<a name="ln431">static void</a>
<a name="ln432">netlink_parse_rtattr (struct rtattr **tb, int max, struct rtattr *rta,</a>
<a name="ln433">                      int len)</a>
<a name="ln434">{</a>
<a name="ln435">  while (RTA_OK (rta, len))</a>
<a name="ln436">    {</a>
<a name="ln437">      if (rta-&gt;rta_type &lt;= max)</a>
<a name="ln438">        tb[rta-&gt;rta_type] = rta;</a>
<a name="ln439">      rta = RTA_NEXT (rta, len);</a>
<a name="ln440">    }</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">/* Utility function to parse hardware link-layer address and update ifp */</a>
<a name="ln444">static void</a>
<a name="ln445">netlink_interface_update_hw_addr (struct rtattr **tb, struct interface *ifp)</a>
<a name="ln446">{</a>
<a name="ln447">  int i;</a>
<a name="ln448"> </a>
<a name="ln449">  if (tb[IFLA_ADDRESS])</a>
<a name="ln450">    {</a>
<a name="ln451">      int hw_addr_len;</a>
<a name="ln452"> </a>
<a name="ln453">      hw_addr_len = RTA_PAYLOAD (tb[IFLA_ADDRESS]);</a>
<a name="ln454"> </a>
<a name="ln455">      if (hw_addr_len &gt; INTERFACE_HWADDR_MAX)</a>
<a name="ln456">        zlog_warn (&quot;Hardware address is too large: %d&quot;, hw_addr_len);</a>
<a name="ln457">      else</a>
<a name="ln458">        {</a>
<a name="ln459">          ifp-&gt;hw_addr_len = hw_addr_len;</a>
<a name="ln460">          memcpy (ifp-&gt;hw_addr, RTA_DATA (tb[IFLA_ADDRESS]), hw_addr_len);</a>
<a name="ln461"> </a>
<a name="ln462">          for (i = 0; i &lt; hw_addr_len; i++)</a>
<a name="ln463">            if (ifp-&gt;hw_addr[i] != 0)</a>
<a name="ln464">              break;</a>
<a name="ln465"> </a>
<a name="ln466">          if (i == hw_addr_len)</a>
<a name="ln467">            ifp-&gt;hw_addr_len = 0;</a>
<a name="ln468">          else</a>
<a name="ln469">            ifp-&gt;hw_addr_len = hw_addr_len;</a>
<a name="ln470">        }</a>
<a name="ln471">    }</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">static enum zebra_link_type</a>
<a name="ln475">netlink_to_zebra_link_type (unsigned int hwt)</a>
<a name="ln476">{</a>
<a name="ln477">  switch (hwt)</a>
<a name="ln478">  {</a>
<a name="ln479">    case ARPHRD_ETHER: return ZEBRA_LLT_ETHER;</a>
<a name="ln480">    case ARPHRD_EETHER: return ZEBRA_LLT_EETHER;</a>
<a name="ln481">    case ARPHRD_AX25: return ZEBRA_LLT_AX25;</a>
<a name="ln482">    case ARPHRD_PRONET: return ZEBRA_LLT_PRONET;</a>
<a name="ln483">    case ARPHRD_IEEE802: return ZEBRA_LLT_IEEE802;</a>
<a name="ln484">    case ARPHRD_ARCNET: return ZEBRA_LLT_ARCNET;</a>
<a name="ln485">    case ARPHRD_APPLETLK: return ZEBRA_LLT_APPLETLK;</a>
<a name="ln486">    case ARPHRD_DLCI: return ZEBRA_LLT_DLCI;</a>
<a name="ln487">    case ARPHRD_ATM: return ZEBRA_LLT_ATM;</a>
<a name="ln488">    case ARPHRD_METRICOM: return ZEBRA_LLT_METRICOM;</a>
<a name="ln489">    case ARPHRD_IEEE1394: return ZEBRA_LLT_IEEE1394;</a>
<a name="ln490">    case ARPHRD_EUI64: return ZEBRA_LLT_EUI64;</a>
<a name="ln491">    case ARPHRD_INFINIBAND: return ZEBRA_LLT_INFINIBAND;</a>
<a name="ln492">    case ARPHRD_SLIP: return ZEBRA_LLT_SLIP;</a>
<a name="ln493">    case ARPHRD_CSLIP: return ZEBRA_LLT_CSLIP;</a>
<a name="ln494">    case ARPHRD_SLIP6: return ZEBRA_LLT_SLIP6;</a>
<a name="ln495">    case ARPHRD_CSLIP6: return ZEBRA_LLT_CSLIP6;</a>
<a name="ln496">    case ARPHRD_RSRVD: return ZEBRA_LLT_RSRVD;</a>
<a name="ln497">    case ARPHRD_ADAPT: return ZEBRA_LLT_ADAPT;</a>
<a name="ln498">    case ARPHRD_ROSE: return ZEBRA_LLT_ROSE;</a>
<a name="ln499">    case ARPHRD_X25: return ZEBRA_LLT_X25;</a>
<a name="ln500">    case ARPHRD_PPP: return ZEBRA_LLT_PPP;</a>
<a name="ln501">    case ARPHRD_CISCO: return ZEBRA_LLT_CHDLC;</a>
<a name="ln502">    case ARPHRD_LAPB: return ZEBRA_LLT_LAPB;</a>
<a name="ln503">    case ARPHRD_RAWHDLC: return ZEBRA_LLT_RAWHDLC;</a>
<a name="ln504">    case ARPHRD_TUNNEL: return ZEBRA_LLT_IPIP;</a>
<a name="ln505">    case ARPHRD_TUNNEL6: return ZEBRA_LLT_IPIP6;</a>
<a name="ln506">    case ARPHRD_FRAD: return ZEBRA_LLT_FRAD;</a>
<a name="ln507">    case ARPHRD_SKIP: return ZEBRA_LLT_SKIP;</a>
<a name="ln508">    case ARPHRD_LOOPBACK: return ZEBRA_LLT_LOOPBACK;</a>
<a name="ln509">    case ARPHRD_LOCALTLK: return ZEBRA_LLT_LOCALTLK;</a>
<a name="ln510">    case ARPHRD_FDDI: return ZEBRA_LLT_FDDI;</a>
<a name="ln511">    case ARPHRD_SIT: return ZEBRA_LLT_SIT;</a>
<a name="ln512">    case ARPHRD_IPDDP: return ZEBRA_LLT_IPDDP;</a>
<a name="ln513">    case ARPHRD_IPGRE: return ZEBRA_LLT_IPGRE;</a>
<a name="ln514">    case ARPHRD_PIMREG: return ZEBRA_LLT_PIMREG;</a>
<a name="ln515">    case ARPHRD_HIPPI: return ZEBRA_LLT_HIPPI;</a>
<a name="ln516">    case ARPHRD_ECONET: return ZEBRA_LLT_ECONET;</a>
<a name="ln517">    case ARPHRD_IRDA: return ZEBRA_LLT_IRDA;</a>
<a name="ln518">    case ARPHRD_FCPP: return ZEBRA_LLT_FCPP;</a>
<a name="ln519">    case ARPHRD_FCAL: return ZEBRA_LLT_FCAL;</a>
<a name="ln520">    case ARPHRD_FCPL: return ZEBRA_LLT_FCPL;</a>
<a name="ln521">    case ARPHRD_FCFABRIC: return ZEBRA_LLT_FCFABRIC;</a>
<a name="ln522">    case ARPHRD_IEEE802_TR: return ZEBRA_LLT_IEEE802_TR;</a>
<a name="ln523">    case ARPHRD_IEEE80211: return ZEBRA_LLT_IEEE80211;</a>
<a name="ln524">    case ARPHRD_IEEE802154: return ZEBRA_LLT_IEEE802154;</a>
<a name="ln525">#ifdef ARPHRD_IP6GRE</a>
<a name="ln526">    case ARPHRD_IP6GRE: return ZEBRA_LLT_IP6GRE;</a>
<a name="ln527">#endif</a>
<a name="ln528">#ifdef ARPHRD_IEEE802154_PHY</a>
<a name="ln529">    case ARPHRD_IEEE802154_PHY: return ZEBRA_LLT_IEEE802154_PHY;</a>
<a name="ln530">#endif</a>
<a name="ln531"> </a>
<a name="ln532">    default: return ZEBRA_LLT_UNKNOWN;</a>
<a name="ln533">  }</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">/* Called from interface_lookup_netlink().  This function is only used</a>
<a name="ln537">   during bootstrap. */</a>
<a name="ln538">static int</a>
<a name="ln539">netlink_interface (struct sockaddr_nl *snl, struct nlmsghdr *h,</a>
<a name="ln540">    vrf_id_t vrf_id)</a>
<a name="ln541">{</a>
<a name="ln542">  int len;</a>
<a name="ln543">  struct ifinfomsg *ifi;</a>
<a name="ln544">  struct rtattr *tb[IFLA_MAX + 1];</a>
<a name="ln545">  struct interface *ifp;</a>
<a name="ln546">  char *name;</a>
<a name="ln547"> </a>
<a name="ln548">  ifi = NLMSG_DATA (h);</a>
<a name="ln549"> </a>
<a name="ln550">  if (h-&gt;nlmsg_type != RTM_NEWLINK)</a>
<a name="ln551">    return 0;</a>
<a name="ln552"> </a>
<a name="ln553">  len = h-&gt;nlmsg_len - NLMSG_LENGTH (sizeof (struct ifinfomsg));</a>
<a name="ln554">  if (len &lt; 0)</a>
<a name="ln555">    return -1;</a>
<a name="ln556"> </a>
<a name="ln557">  /* Looking up interface name. */</a>
<a name="ln558">  memset (tb, 0, sizeof tb);</a>
<a name="ln559">  netlink_parse_rtattr (tb, IFLA_MAX, IFLA_RTA (ifi), len);</a>
<a name="ln560">  </a>
<a name="ln561">#ifdef IFLA_WIRELESS</a>
<a name="ln562">  /* check for wireless messages to ignore */</a>
<a name="ln563">  if ((tb[IFLA_WIRELESS] != NULL) &amp;&amp; (ifi-&gt;ifi_change == 0))</a>
<a name="ln564">    {</a>
<a name="ln565">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln566">        zlog_debug (&quot;%s: ignoring IFLA_WIRELESS message&quot;, __func__);</a>
<a name="ln567">      return 0;</a>
<a name="ln568">    }</a>
<a name="ln569">#endif /* IFLA_WIRELESS */</a>
<a name="ln570"> </a>
<a name="ln571">  if (tb[IFLA_IFNAME] == NULL)</a>
<a name="ln572">    return -1;</a>
<a name="ln573">  name = (char *) RTA_DATA (tb[IFLA_IFNAME]);</a>
<a name="ln574"> </a>
<a name="ln575">  /* Add interface. */</a>
<a name="ln576">  ifp = if_get_by_name_vrf (name, vrf_id);</a>
<a name="ln577">  set_ifindex(ifp, ifi-&gt;ifi_index);</a>
<a name="ln578">  ifp-&gt;flags = ifi-&gt;ifi_flags &amp; 0x0000fffff;</a>
<a name="ln579">  ifp-&gt;mtu6 = ifp-&gt;mtu = *(uint32_t *) RTA_DATA (tb[IFLA_MTU]);</a>
<a name="ln580">  ifp-&gt;metric = 0;</a>
<a name="ln581"> </a>
<a name="ln582">  /* Hardware type and address. */</a>
<a name="ln583">  ifp-&gt;ll_type = netlink_to_zebra_link_type (ifi-&gt;ifi_type);</a>
<a name="ln584">  netlink_interface_update_hw_addr (tb, ifp);</a>
<a name="ln585"> </a>
<a name="ln586">  if_add_update (ifp);</a>
<a name="ln587"> </a>
<a name="ln588">  return 0;</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">/* Lookup interface IPv4/IPv6 address. */</a>
<a name="ln592">static int</a>
<a name="ln593">netlink_interface_addr (struct sockaddr_nl *snl, struct nlmsghdr *h,</a>
<a name="ln594">    vrf_id_t vrf_id)</a>
<a name="ln595">{</a>
<a name="ln596">  int len;</a>
<a name="ln597">  struct ifaddrmsg *ifa;</a>
<a name="ln598">  struct rtattr *tb[IFA_MAX + 1];</a>
<a name="ln599">  struct interface *ifp;</a>
<a name="ln600">  void *addr;</a>
<a name="ln601">  void *broad;</a>
<a name="ln602">  u_char flags = 0;</a>
<a name="ln603">  char *label = NULL;</a>
<a name="ln604"> </a>
<a name="ln605">  ifa = NLMSG_DATA (h);</a>
<a name="ln606"> </a>
<a name="ln607">  if (ifa-&gt;ifa_family != AF_INET</a>
<a name="ln608">#ifdef HAVE_IPV6</a>
<a name="ln609">      &amp;&amp; ifa-&gt;ifa_family != AF_INET6</a>
<a name="ln610">#endif /* HAVE_IPV6 */</a>
<a name="ln611">    )</a>
<a name="ln612">    return 0;</a>
<a name="ln613"> </a>
<a name="ln614">  if (h-&gt;nlmsg_type != RTM_NEWADDR &amp;&amp; h-&gt;nlmsg_type != RTM_DELADDR)</a>
<a name="ln615">    return 0;</a>
<a name="ln616"> </a>
<a name="ln617">  len = h-&gt;nlmsg_len - NLMSG_LENGTH (sizeof (struct ifaddrmsg));</a>
<a name="ln618">  if (len &lt; 0)</a>
<a name="ln619">    return -1;</a>
<a name="ln620"> </a>
<a name="ln621">  memset (tb, 0, sizeof tb);</a>
<a name="ln622">  netlink_parse_rtattr (tb, IFA_MAX, IFA_RTA (ifa), len);</a>
<a name="ln623"> </a>
<a name="ln624">  ifp = if_lookup_by_index_vrf (ifa-&gt;ifa_index, vrf_id);</a>
<a name="ln625">  if (ifp == NULL)</a>
<a name="ln626">    {</a>
<a name="ln627">      zlog_err (&quot;netlink_interface_addr can't find interface by index %d vrf %u&quot;,</a>
<a name="ln628">                ifa-&gt;ifa_index, vrf_id);</a>
<a name="ln629">      return -1;</a>
<a name="ln630">    }</a>
<a name="ln631"> </a>
<a name="ln632">  if (IS_ZEBRA_DEBUG_KERNEL)    /* remove this line to see initial ifcfg */</a>
<a name="ln633">    {</a>
<a name="ln634">      char buf[BUFSIZ];</a>
<a name="ln635">      zlog_debug (&quot;netlink_interface_addr %s %s vrf %u:&quot;,</a>
<a name="ln636">                 lookup (nlmsg_str, h-&gt;nlmsg_type), ifp-&gt;name, vrf_id);</a>
<a name="ln637">      if (tb[IFA_LOCAL])</a>
<a name="ln638">        zlog_debug (&quot;  IFA_LOCAL     %s/%d&quot;,</a>
<a name="ln639">		    inet_ntop (ifa-&gt;ifa_family, RTA_DATA (tb[IFA_LOCAL]),</a>
<a name="ln640">			       buf, BUFSIZ), ifa-&gt;ifa_prefixlen);</a>
<a name="ln641">      if (tb[IFA_ADDRESS])</a>
<a name="ln642">        zlog_debug (&quot;  IFA_ADDRESS   %s/%d&quot;,</a>
<a name="ln643">		    inet_ntop (ifa-&gt;ifa_family, RTA_DATA (tb[IFA_ADDRESS]),</a>
<a name="ln644">                               buf, BUFSIZ), ifa-&gt;ifa_prefixlen);</a>
<a name="ln645">      if (tb[IFA_BROADCAST])</a>
<a name="ln646">        zlog_debug (&quot;  IFA_BROADCAST %s/%d&quot;,</a>
<a name="ln647">		    inet_ntop (ifa-&gt;ifa_family, RTA_DATA (tb[IFA_BROADCAST]),</a>
<a name="ln648">			       buf, BUFSIZ), ifa-&gt;ifa_prefixlen);</a>
<a name="ln649">      if (tb[IFA_LABEL] &amp;&amp; strcmp (ifp-&gt;name, RTA_DATA (tb[IFA_LABEL])))</a>
<a name="ln650">        zlog_debug (&quot;  IFA_LABEL     %s&quot;, (char *)RTA_DATA (tb[IFA_LABEL]));</a>
<a name="ln651">      </a>
<a name="ln652">      if (tb[IFA_CACHEINFO])</a>
<a name="ln653">        {</a>
<a name="ln654">          struct ifa_cacheinfo *ci = RTA_DATA (tb[IFA_CACHEINFO]);</a>
<a name="ln655">          zlog_debug (&quot;  IFA_CACHEINFO pref %d, valid %d&quot;,</a>
<a name="ln656">                      ci-&gt;ifa_prefered, ci-&gt;ifa_valid);</a>
<a name="ln657">        }</a>
<a name="ln658">    }</a>
<a name="ln659">  </a>
<a name="ln660">  /* logic copied from iproute2/ip/ipaddress.c:print_addrinfo() */</a>
<a name="ln661">  if (tb[IFA_LOCAL] == NULL)</a>
<a name="ln662">    tb[IFA_LOCAL] = tb[IFA_ADDRESS];</a>
<a name="ln663">  if (tb[IFA_ADDRESS] == NULL)</a>
<a name="ln664">    tb[IFA_ADDRESS] = tb[IFA_LOCAL];</a>
<a name="ln665">  </a>
<a name="ln666">  /* local interface address */</a>
<a name="ln667">  addr = (tb[IFA_LOCAL] ? RTA_DATA(tb[IFA_LOCAL]) : NULL);</a>
<a name="ln668"> </a>
<a name="ln669">  /* is there a peer address? */</a>
<a name="ln670">  if (tb[IFA_ADDRESS] &amp;&amp;</a>
<a name="ln671">      memcmp(RTA_DATA(tb[IFA_ADDRESS]), RTA_DATA(tb[IFA_LOCAL]), RTA_PAYLOAD(tb[IFA_ADDRESS])))</a>
<a name="ln672">    {</a>
<a name="ln673">      broad = RTA_DATA(tb[IFA_ADDRESS]);</a>
<a name="ln674">      SET_FLAG (flags, ZEBRA_IFA_PEER);</a>
<a name="ln675">    }</a>
<a name="ln676">  else</a>
<a name="ln677">    /* seeking a broadcast address */</a>
<a name="ln678">    broad = (tb[IFA_BROADCAST] ? RTA_DATA(tb[IFA_BROADCAST]) : NULL);</a>
<a name="ln679"> </a>
<a name="ln680">  /* addr is primary key, SOL if we don't have one */</a>
<a name="ln681">  if (addr == NULL)</a>
<a name="ln682">    {</a>
<a name="ln683">      zlog_debug (&quot;%s: NULL address&quot;, __func__);</a>
<a name="ln684">      return -1;</a>
<a name="ln685">    }</a>
<a name="ln686"> </a>
<a name="ln687">  /* Flags. */</a>
<a name="ln688">  if (ifa-&gt;ifa_flags &amp; IFA_F_SECONDARY)</a>
<a name="ln689">    SET_FLAG (flags, ZEBRA_IFA_SECONDARY);</a>
<a name="ln690"> </a>
<a name="ln691">  /* Label */</a>
<a name="ln692">  if (tb[IFA_LABEL])</a>
<a name="ln693">    label = (char *) RTA_DATA (tb[IFA_LABEL]);</a>
<a name="ln694"> </a>
<a name="ln695">  if (ifp &amp;&amp; label &amp;&amp; strcmp (ifp-&gt;name, label) == 0)</a>
<a name="ln696">    label = NULL;</a>
<a name="ln697"> </a>
<a name="ln698">  /* Register interface address to the interface. */</a>
<a name="ln699">  if (ifa-&gt;ifa_family == AF_INET)</a>
<a name="ln700">    {</a>
<a name="ln701">      if (h-&gt;nlmsg_type == RTM_NEWADDR)</a>
<a name="ln702">        connected_add_ipv4 (ifp, flags,</a>
<a name="ln703">                            (struct in_addr *) addr, ifa-&gt;ifa_prefixlen,</a>
<a name="ln704">                            (struct in_addr *) broad, label);</a>
<a name="ln705">      else</a>
<a name="ln706">        connected_delete_ipv4 (ifp, flags,</a>
<a name="ln707">                               (struct in_addr *) addr, ifa-&gt;ifa_prefixlen,</a>
<a name="ln708">                               (struct in_addr *) broad);</a>
<a name="ln709">    }</a>
<a name="ln710">#ifdef HAVE_IPV6</a>
<a name="ln711">  if (ifa-&gt;ifa_family == AF_INET6)</a>
<a name="ln712">    {</a>
<a name="ln713">      if (h-&gt;nlmsg_type == RTM_NEWADDR)</a>
<a name="ln714">        connected_add_ipv6 (ifp, flags,</a>
<a name="ln715">                            (struct in6_addr *) addr, ifa-&gt;ifa_prefixlen,</a>
<a name="ln716">                            (struct in6_addr *) broad, label);</a>
<a name="ln717">      else</a>
<a name="ln718">        connected_delete_ipv6 (ifp,</a>
<a name="ln719">                               (struct in6_addr *) addr, ifa-&gt;ifa_prefixlen,</a>
<a name="ln720">                               (struct in6_addr *) broad);</a>
<a name="ln721">    }</a>
<a name="ln722">#endif /* HAVE_IPV6 */</a>
<a name="ln723"> </a>
<a name="ln724">  return 0;</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">/* Looking up routing table by netlink interface. */</a>
<a name="ln728">static int</a>
<a name="ln729">netlink_routing_table (struct sockaddr_nl *snl, struct nlmsghdr *h,</a>
<a name="ln730">    vrf_id_t vrf_id)</a>
<a name="ln731">{</a>
<a name="ln732">  int len;</a>
<a name="ln733">  struct rtmsg *rtm;</a>
<a name="ln734">  struct rtattr *tb[RTA_MAX + 1];</a>
<a name="ln735">  u_char flags = 0;</a>
<a name="ln736"> </a>
<a name="ln737">  char anyaddr[16] = { 0 };</a>
<a name="ln738"> </a>
<a name="ln739">  int index;</a>
<a name="ln740">  int table;</a>
<a name="ln741">  u_int32_t mtu = 0;</a>
<a name="ln742"> </a>
<a name="ln743">  void *dest;</a>
<a name="ln744">  void *gate;</a>
<a name="ln745">  void *src;</a>
<a name="ln746"> </a>
<a name="ln747">  rtm = NLMSG_DATA (h);</a>
<a name="ln748"> </a>
<a name="ln749">  if (h-&gt;nlmsg_type != RTM_NEWROUTE)</a>
<a name="ln750">    return 0;</a>
<a name="ln751">  if (rtm-&gt;rtm_type != RTN_UNICAST)</a>
<a name="ln752">    return 0;</a>
<a name="ln753"> </a>
<a name="ln754">  table = rtm-&gt;rtm_table;</a>
<a name="ln755">#if 0                           /* we weed them out later in rib_weed_tables () */</a>
<a name="ln756">  if (table != RT_TABLE_MAIN &amp;&amp; table != zebrad.rtm_table_default)</a>
<a name="ln757">    return 0;</a>
<a name="ln758">#endif</a>
<a name="ln759"> </a>
<a name="ln760">  len = h-&gt;nlmsg_len - NLMSG_LENGTH (sizeof (struct rtmsg));</a>
<a name="ln761">  if (len &lt; 0)</a>
<a name="ln762">    return -1;</a>
<a name="ln763"> </a>
<a name="ln764">  memset (tb, 0, sizeof tb);</a>
<a name="ln765">  netlink_parse_rtattr (tb, RTA_MAX, RTM_RTA (rtm), len);</a>
<a name="ln766"> </a>
<a name="ln767">  if (rtm-&gt;rtm_flags &amp; RTM_F_CLONED)</a>
<a name="ln768">    return 0;</a>
<a name="ln769">  if (rtm-&gt;rtm_protocol == RTPROT_REDIRECT)</a>
<a name="ln770">    return 0;</a>
<a name="ln771">  if (rtm-&gt;rtm_protocol == RTPROT_KERNEL)</a>
<a name="ln772">    return 0;</a>
<a name="ln773"> </a>
<a name="ln774">  if (rtm-&gt;rtm_src_len != 0)</a>
<a name="ln775">    return 0;</a>
<a name="ln776"> </a>
<a name="ln777">  /* Route which inserted by Zebra. */</a>
<a name="ln778">  if (rtm-&gt;rtm_protocol == RTPROT_ZEBRA)</a>
<a name="ln779">    flags |= ZEBRA_FLAG_SELFROUTE;</a>
<a name="ln780"> </a>
<a name="ln781">  index = 0;</a>
<a name="ln782">  dest = NULL;</a>
<a name="ln783">  gate = NULL;</a>
<a name="ln784">  src = NULL;</a>
<a name="ln785"> </a>
<a name="ln786">  if (tb[RTA_OIF])</a>
<a name="ln787">    index = *(int *) RTA_DATA (tb[RTA_OIF]);</a>
<a name="ln788"> </a>
<a name="ln789">  if (tb[RTA_DST])</a>
<a name="ln790">    dest = RTA_DATA (tb[RTA_DST]);</a>
<a name="ln791">  else</a>
<a name="ln792">    dest = anyaddr;</a>
<a name="ln793"> </a>
<a name="ln794">  if (tb[RTA_PREFSRC])</a>
<a name="ln795">    src = RTA_DATA (tb[RTA_PREFSRC]);</a>
<a name="ln796"> </a>
<a name="ln797">  if (tb[RTA_GATEWAY])</a>
<a name="ln798">    gate = RTA_DATA (tb[RTA_GATEWAY]);</a>
<a name="ln799"> </a>
<a name="ln800">  if (tb[RTA_METRICS])</a>
<a name="ln801">    {</a>
<a name="ln802">      struct rtattr *mxrta[RTAX_MAX+1];</a>
<a name="ln803"> </a>
<a name="ln804">      memset (mxrta, 0, sizeof mxrta);</a>
<a name="ln805">      netlink_parse_rtattr (mxrta, RTAX_MAX, RTA_DATA(tb[RTA_METRICS]),</a>
<a name="ln806">                            RTA_PAYLOAD(tb[RTA_METRICS]));</a>
<a name="ln807"> </a>
<a name="ln808">      if (mxrta[RTAX_MTU])</a>
<a name="ln809">        mtu = *(u_int32_t *) RTA_DATA(mxrta[RTAX_MTU]);</a>
<a name="ln810">    }</a>
<a name="ln811"> </a>
<a name="ln812">  if (rtm-&gt;rtm_family == AF_INET)</a>
<a name="ln813">    {</a>
<a name="ln814">      struct prefix_ipv4 p;</a>
<a name="ln815">      p.family = AF_INET;</a>
<a name="ln816">      memcpy (&amp;p.prefix, dest, 4);</a>
<a name="ln817">      p.prefixlen = rtm-&gt;rtm_dst_len;</a>
<a name="ln818"> </a>
<a name="ln819">      if (!tb[RTA_MULTIPATH])</a>
<a name="ln820">          rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, flags, &amp;p, gate, src, index,</a>
<a name="ln821">                        vrf_id, table, 0, mtu, 0, SAFI_UNICAST);</a>
<a name="ln822">      else</a>
<a name="ln823">        {</a>
<a name="ln824">          /* This is a multipath route */</a>
<a name="ln825"> </a>
<a name="ln826">          struct rib *rib;</a>
<a name="ln827">          struct rtnexthop *rtnh =</a>
<a name="ln828">            (struct rtnexthop *) RTA_DATA (tb[RTA_MULTIPATH]);</a>
<a name="ln829"> </a>
<a name="ln830">          len = RTA_PAYLOAD (tb[RTA_MULTIPATH]);</a>
<a name="ln831"> </a>
<a name="ln832">          rib = XCALLOC (MTYPE_RIB, sizeof (struct rib));</a>
<a name="ln833">          rib-&gt;type = ZEBRA_ROUTE_KERNEL;</a>
<a name="ln834">          rib-&gt;distance = 0;</a>
<a name="ln835">          rib-&gt;flags = flags;</a>
<a name="ln836">          rib-&gt;metric = 0;</a>
<a name="ln837">          rib-&gt;mtu = mtu;</a>
<a name="ln838">          rib-&gt;vrf_id = vrf_id;</a>
<a name="ln839">          rib-&gt;table = table;</a>
<a name="ln840">          rib-&gt;nexthop_num = 0;</a>
<a name="ln841">          rib-&gt;uptime = time (NULL);</a>
<a name="ln842"> </a>
<a name="ln843">          for (;;)</a>
<a name="ln844">            {</a>
<a name="ln845">              if (len &lt; (int) sizeof (*rtnh) || rtnh-&gt;rtnh_len &gt; len)</a>
<a name="ln846">                break;</a>
<a name="ln847"> </a>
<a name="ln848">              index = rtnh-&gt;rtnh_ifindex;</a>
<a name="ln849">              gate = 0;</a>
<a name="ln850">              if (rtnh-&gt;rtnh_len &gt; sizeof (*rtnh))</a>
<a name="ln851">                {</a>
<a name="ln852">                  memset (tb, 0, sizeof (tb));</a>
<a name="ln853">                  netlink_parse_rtattr (tb, RTA_MAX, RTNH_DATA (rtnh),</a>
<a name="ln854">                                        rtnh-&gt;rtnh_len - sizeof (*rtnh));</a>
<a name="ln855">                  if (tb[RTA_GATEWAY])</a>
<a name="ln856">                    gate = RTA_DATA (tb[RTA_GATEWAY]);</a>
<a name="ln857">                }</a>
<a name="ln858"> </a>
<a name="ln859">              if (gate)</a>
<a name="ln860">                {</a>
<a name="ln861">                  if (index)</a>
<a name="ln862">                    rib_nexthop_ipv4_ifindex_add (rib, gate, src, index);</a>
<a name="ln863">                  else</a>
<a name="ln864">                    rib_nexthop_ipv4_add (rib, gate, src);</a>
<a name="ln865">                }</a>
<a name="ln866">              else</a>
<a name="ln867">                rib_nexthop_ifindex_add (rib, index);</a>
<a name="ln868"> </a>
<a name="ln869">              len -= NLMSG_ALIGN(rtnh-&gt;rtnh_len);</a>
<a name="ln870">              rtnh = RTNH_NEXT(rtnh);</a>
<a name="ln871">            }</a>
<a name="ln872"> </a>
<a name="ln873">          if (rib-&gt;nexthop_num == 0)</a>
<a name="ln874">            XFREE (MTYPE_RIB, rib);</a>
<a name="ln875">          else</a>
<a name="ln876">            rib_add_ipv4_multipath (&amp;p, rib, SAFI_UNICAST);</a>
<a name="ln877">        }</a>
<a name="ln878">    }</a>
<a name="ln879">#ifdef HAVE_IPV6</a>
<a name="ln880">  if (rtm-&gt;rtm_family == AF_INET6)</a>
<a name="ln881">    {</a>
<a name="ln882">      struct prefix_ipv6 p;</a>
<a name="ln883">      p.family = AF_INET6;</a>
<a name="ln884">      memcpy (&amp;p.prefix, dest, 16);</a>
<a name="ln885">      p.prefixlen = rtm-&gt;rtm_dst_len;</a>
<a name="ln886"> </a>
<a name="ln887">      rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, flags, &amp;p, gate, index, vrf_id,</a>
<a name="ln888">                    table, 0, mtu, 0, SAFI_UNICAST);</a>
<a name="ln889">    }</a>
<a name="ln890">#endif /* HAVE_IPV6 */</a>
<a name="ln891"> </a>
<a name="ln892">  return 0;</a>
<a name="ln893">}</a>
<a name="ln894"> </a>
<a name="ln895">static const struct message rtproto_str[] = {</a>
<a name="ln896">  {RTPROT_REDIRECT, &quot;redirect&quot;},</a>
<a name="ln897">  {RTPROT_KERNEL,   &quot;kernel&quot;},</a>
<a name="ln898">  {RTPROT_BOOT,     &quot;boot&quot;},</a>
<a name="ln899">  {RTPROT_STATIC,   &quot;static&quot;},</a>
<a name="ln900">  {RTPROT_GATED,    &quot;GateD&quot;},</a>
<a name="ln901">  {RTPROT_RA,       &quot;router advertisement&quot;},</a>
<a name="ln902">  {RTPROT_MRT,      &quot;MRT&quot;},</a>
<a name="ln903">  {RTPROT_ZEBRA,    &quot;Zebra&quot;},</a>
<a name="ln904">#ifdef RTPROT_BIRD</a>
<a name="ln905">  {RTPROT_BIRD,     &quot;BIRD&quot;},</a>
<a name="ln906">#endif /* RTPROT_BIRD */</a>
<a name="ln907">  {0,               NULL}</a>
<a name="ln908">};</a>
<a name="ln909"> </a>
<a name="ln910">/* Routing information change from the kernel. */</a>
<a name="ln911">static int</a>
<a name="ln912">netlink_route_change (struct sockaddr_nl *snl, struct nlmsghdr *h,</a>
<a name="ln913">    vrf_id_t vrf_id)</a>
<a name="ln914">{</a>
<a name="ln915">  int len;</a>
<a name="ln916">  struct rtmsg *rtm;</a>
<a name="ln917">  struct rtattr *tb[RTA_MAX + 1];</a>
<a name="ln918">  u_char zebra_flags = 0;</a>
<a name="ln919"> </a>
<a name="ln920">  char anyaddr[16] = { 0 };</a>
<a name="ln921"> </a>
<a name="ln922">  int index;</a>
<a name="ln923">  int table;</a>
<a name="ln924">  u_int32_t mtu = 0;</a>
<a name="ln925"> </a>
<a name="ln926">  void *dest;</a>
<a name="ln927">  void *gate;</a>
<a name="ln928">  void *src;</a>
<a name="ln929"> </a>
<a name="ln930">  rtm = NLMSG_DATA (h);</a>
<a name="ln931"> </a>
<a name="ln932">  if (!(h-&gt;nlmsg_type == RTM_NEWROUTE || h-&gt;nlmsg_type == RTM_DELROUTE))</a>
<a name="ln933">    {</a>
<a name="ln934">      /* If this is not route add/delete message print warning. */</a>
<a name="ln935">      zlog_warn (&quot;Kernel message: %d vrf %u\n&quot;, h-&gt;nlmsg_type, vrf_id);</a>
<a name="ln936">      return 0;</a>
<a name="ln937">    }</a>
<a name="ln938"> </a>
<a name="ln939">  /* Connected route. */</a>
<a name="ln940">  if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln941">    zlog_debug (&quot;%s %s %s proto %s vrf %u&quot;,</a>
<a name="ln942">               h-&gt;nlmsg_type ==</a>
<a name="ln943">               RTM_NEWROUTE ? &quot;RTM_NEWROUTE&quot; : &quot;RTM_DELROUTE&quot;,</a>
<a name="ln944">               rtm-&gt;rtm_family == AF_INET ? &quot;ipv4&quot; : &quot;ipv6&quot;,</a>
<a name="ln945">               rtm-&gt;rtm_type == RTN_UNICAST ? &quot;unicast&quot; : &quot;multicast&quot;,</a>
<a name="ln946">               lookup (rtproto_str, rtm-&gt;rtm_protocol),</a>
<a name="ln947">               vrf_id);</a>
<a name="ln948"> </a>
<a name="ln949">  if (rtm-&gt;rtm_type != RTN_UNICAST)</a>
<a name="ln950">    {</a>
<a name="ln951">      return 0;</a>
<a name="ln952">    }</a>
<a name="ln953"> </a>
<a name="ln954">  table = rtm-&gt;rtm_table;</a>
<a name="ln955">  if (table != RT_TABLE_MAIN &amp;&amp; table != zebrad.rtm_table_default)</a>
<a name="ln956">    {</a>
<a name="ln957">      return 0;</a>
<a name="ln958">    }</a>
<a name="ln959"> </a>
<a name="ln960">  len = h-&gt;nlmsg_len - NLMSG_LENGTH (sizeof (struct rtmsg));</a>
<a name="ln961">  if (len &lt; 0)</a>
<a name="ln962">    return -1;</a>
<a name="ln963"> </a>
<a name="ln964">  memset (tb, 0, sizeof tb);</a>
<a name="ln965">  netlink_parse_rtattr (tb, RTA_MAX, RTM_RTA (rtm), len);</a>
<a name="ln966"> </a>
<a name="ln967">  if (rtm-&gt;rtm_flags &amp; RTM_F_CLONED)</a>
<a name="ln968">    return 0;</a>
<a name="ln969">  if (rtm-&gt;rtm_protocol == RTPROT_REDIRECT)</a>
<a name="ln970">    return 0;</a>
<a name="ln971">  if (rtm-&gt;rtm_protocol == RTPROT_KERNEL)</a>
<a name="ln972">    return 0;</a>
<a name="ln973"> </a>
<a name="ln974">  if (rtm-&gt;rtm_protocol == RTPROT_ZEBRA &amp;&amp; h-&gt;nlmsg_type == RTM_NEWROUTE)</a>
<a name="ln975">    return 0;</a>
<a name="ln976">  if (rtm-&gt;rtm_protocol == RTPROT_ZEBRA)</a>
<a name="ln977">    SET_FLAG(zebra_flags, ZEBRA_FLAG_SELFROUTE);</a>
<a name="ln978"> </a>
<a name="ln979">  if (rtm-&gt;rtm_src_len != 0)</a>
<a name="ln980">    {</a>
<a name="ln981">      zlog_warn (&quot;netlink_route_change(): no src len, vrf %u&quot;, vrf_id);</a>
<a name="ln982">      return 0;</a>
<a name="ln983">    }</a>
<a name="ln984"> </a>
<a name="ln985">  index = 0;</a>
<a name="ln986">  dest = NULL;</a>
<a name="ln987">  gate = NULL;</a>
<a name="ln988">  src = NULL;</a>
<a name="ln989"> </a>
<a name="ln990">  if (tb[RTA_OIF])</a>
<a name="ln991">    index = *(int *) RTA_DATA (tb[RTA_OIF]);</a>
<a name="ln992"> </a>
<a name="ln993">  if (tb[RTA_DST])</a>
<a name="ln994">    dest = RTA_DATA (tb[RTA_DST]);</a>
<a name="ln995">  else</a>
<a name="ln996">    dest = anyaddr;</a>
<a name="ln997"> </a>
<a name="ln998">  if (tb[RTA_GATEWAY])</a>
<a name="ln999">    gate = RTA_DATA (tb[RTA_GATEWAY]);</a>
<a name="ln1000"> </a>
<a name="ln1001">  if (tb[RTA_PREFSRC])</a>
<a name="ln1002">    src = RTA_DATA (tb[RTA_PREFSRC]);</a>
<a name="ln1003"> </a>
<a name="ln1004">  if (h-&gt;nlmsg_type == RTM_NEWROUTE)</a>
<a name="ln1005">    {</a>
<a name="ln1006">      if (tb[RTA_METRICS])</a>
<a name="ln1007">        {</a>
<a name="ln1008">          struct rtattr *mxrta[RTAX_MAX+1];</a>
<a name="ln1009"> </a>
<a name="ln1010">          memset (mxrta, 0, sizeof mxrta);</a>
<a name="ln1011">          netlink_parse_rtattr (mxrta, RTAX_MAX, RTA_DATA(tb[RTA_METRICS]),</a>
<a name="ln1012">                                RTA_PAYLOAD(tb[RTA_METRICS]));</a>
<a name="ln1013"> </a>
<a name="ln1014">          if (mxrta[RTAX_MTU])</a>
<a name="ln1015">            mtu = *(u_int32_t *) RTA_DATA(mxrta[RTAX_MTU]);</a>
<a name="ln1016">        }</a>
<a name="ln1017">    }</a>
<a name="ln1018"> </a>
<a name="ln1019">  if (rtm-&gt;rtm_family == AF_INET)</a>
<a name="ln1020">    {</a>
<a name="ln1021">      struct prefix_ipv4 p;</a>
<a name="ln1022">      p.family = AF_INET;</a>
<a name="ln1023">      memcpy (&amp;p.prefix, dest, 4);</a>
<a name="ln1024">      p.prefixlen = rtm-&gt;rtm_dst_len;</a>
<a name="ln1025"> </a>
<a name="ln1026">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1027">        {</a>
<a name="ln1028">          char buf[PREFIX_STRLEN];</a>
<a name="ln1029">          zlog_debug (&quot;%s %s vrf %u&quot;,</a>
<a name="ln1030">                      h-&gt;nlmsg_type == RTM_NEWROUTE ? &quot;RTM_NEWROUTE&quot; : &quot;RTM_DELROUTE&quot;,</a>
<a name="ln1031">                      prefix2str (&amp;p, buf, sizeof(buf)), vrf_id);</a>
<a name="ln1032">        }</a>
<a name="ln1033"> </a>
<a name="ln1034">      if (h-&gt;nlmsg_type == RTM_NEWROUTE)</a>
<a name="ln1035">        {</a>
<a name="ln1036">          if (!tb[RTA_MULTIPATH])</a>
<a name="ln1037">            rib_add_ipv4 (ZEBRA_ROUTE_KERNEL, 0, &amp;p, gate, src, index, vrf_id,</a>
<a name="ln1038">                          table, 0, mtu, 0, SAFI_UNICAST);</a>
<a name="ln1039">          else</a>
<a name="ln1040">            {</a>
<a name="ln1041">              /* This is a multipath route */</a>
<a name="ln1042"> </a>
<a name="ln1043">              struct rib *rib;</a>
<a name="ln1044">              struct rtnexthop *rtnh =</a>
<a name="ln1045">                (struct rtnexthop *) RTA_DATA (tb[RTA_MULTIPATH]);</a>
<a name="ln1046"> </a>
<a name="ln1047">              len = RTA_PAYLOAD (tb[RTA_MULTIPATH]);</a>
<a name="ln1048"> </a>
<a name="ln1049">              rib = XCALLOC (MTYPE_RIB, sizeof (struct rib));</a>
<a name="ln1050">              rib-&gt;type = ZEBRA_ROUTE_KERNEL;</a>
<a name="ln1051">              rib-&gt;distance = 0;</a>
<a name="ln1052">              rib-&gt;flags = 0;</a>
<a name="ln1053">              rib-&gt;metric = 0;</a>
<a name="ln1054">              rib-&gt;mtu = mtu;</a>
<a name="ln1055">              rib-&gt;vrf_id = vrf_id;</a>
<a name="ln1056">              rib-&gt;table = table;</a>
<a name="ln1057">              rib-&gt;nexthop_num = 0;</a>
<a name="ln1058">              rib-&gt;uptime = time (NULL);</a>
<a name="ln1059"> </a>
<a name="ln1060">              for (;;)</a>
<a name="ln1061">                {</a>
<a name="ln1062">                  if (len &lt; (int) sizeof (*rtnh) || rtnh-&gt;rtnh_len &gt; len)</a>
<a name="ln1063">                    break;</a>
<a name="ln1064"> </a>
<a name="ln1065">                  index = rtnh-&gt;rtnh_ifindex;</a>
<a name="ln1066">                  gate = 0;</a>
<a name="ln1067">                  if (rtnh-&gt;rtnh_len &gt; sizeof (*rtnh))</a>
<a name="ln1068">                    {</a>
<a name="ln1069">                      memset (tb, 0, sizeof (tb));</a>
<a name="ln1070">                      netlink_parse_rtattr (tb, RTA_MAX, RTNH_DATA (rtnh),</a>
<a name="ln1071">                                            rtnh-&gt;rtnh_len - sizeof (*rtnh));</a>
<a name="ln1072">                      if (tb[RTA_GATEWAY])</a>
<a name="ln1073">                        gate = RTA_DATA (tb[RTA_GATEWAY]);</a>
<a name="ln1074">                    }</a>
<a name="ln1075"> </a>
<a name="ln1076">                  if (gate)</a>
<a name="ln1077">                    {</a>
<a name="ln1078">                      if (index)</a>
<a name="ln1079">                        rib_nexthop_ipv4_ifindex_add (rib, gate, src, index);</a>
<a name="ln1080">                      else</a>
<a name="ln1081">                        rib_nexthop_ipv4_add (rib, gate, src);</a>
<a name="ln1082">                    }</a>
<a name="ln1083">                  else</a>
<a name="ln1084">                    rib_nexthop_ifindex_add (rib, index);</a>
<a name="ln1085"> </a>
<a name="ln1086">                  len -= NLMSG_ALIGN(rtnh-&gt;rtnh_len);</a>
<a name="ln1087">                  rtnh = RTNH_NEXT(rtnh);</a>
<a name="ln1088">                }</a>
<a name="ln1089"> </a>
<a name="ln1090">              if (rib-&gt;nexthop_num == 0)</a>
<a name="ln1091">                XFREE (MTYPE_RIB, rib);</a>
<a name="ln1092">              else</a>
<a name="ln1093">                rib_add_ipv4_multipath (&amp;p, rib, SAFI_UNICAST);</a>
<a name="ln1094">            }</a>
<a name="ln1095">        }</a>
<a name="ln1096">      else</a>
<a name="ln1097">        rib_delete_ipv4 (ZEBRA_ROUTE_KERNEL, zebra_flags, &amp;p, gate,</a>
<a name="ln1098">			 index, vrf_id, SAFI_UNICAST);</a>
<a name="ln1099">    }</a>
<a name="ln1100"> </a>
<a name="ln1101">#ifdef HAVE_IPV6</a>
<a name="ln1102">  if (rtm-&gt;rtm_family == AF_INET6)</a>
<a name="ln1103">    {</a>
<a name="ln1104">      struct prefix_ipv6 p;</a>
<a name="ln1105"> </a>
<a name="ln1106">      p.family = AF_INET6;</a>
<a name="ln1107">      memcpy (&amp;p.prefix, dest, 16);</a>
<a name="ln1108">      p.prefixlen = rtm-&gt;rtm_dst_len;</a>
<a name="ln1109"> </a>
<a name="ln1110">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1111">        {</a>
<a name="ln1112">          char buf[PREFIX_STRLEN];</a>
<a name="ln1113">          zlog_debug (&quot;%s %s vrf %u&quot;,</a>
<a name="ln1114">                      h-&gt;nlmsg_type == RTM_NEWROUTE ? &quot;RTM_NEWROUTE&quot; : &quot;RTM_DELROUTE&quot;,</a>
<a name="ln1115">                      prefix2str (&amp;p, buf, sizeof(buf)), vrf_id);</a>
<a name="ln1116">        }</a>
<a name="ln1117"> </a>
<a name="ln1118">      if (h-&gt;nlmsg_type == RTM_NEWROUTE)</a>
<a name="ln1119">        rib_add_ipv6 (ZEBRA_ROUTE_KERNEL, 0, &amp;p, gate, index, vrf_id, table,</a>
<a name="ln1120">                      0, mtu, 0, SAFI_UNICAST);</a>
<a name="ln1121">      else</a>
<a name="ln1122">        rib_delete_ipv6 (ZEBRA_ROUTE_KERNEL, zebra_flags, &amp;p, gate, index, vrf_id,</a>
<a name="ln1123">                         SAFI_UNICAST);</a>
<a name="ln1124">    }</a>
<a name="ln1125">#endif /* HAVE_IPV6 */</a>
<a name="ln1126"> </a>
<a name="ln1127">  return 0;</a>
<a name="ln1128">}</a>
<a name="ln1129"> </a>
<a name="ln1130">static int</a>
<a name="ln1131">netlink_link_change (struct sockaddr_nl *snl, struct nlmsghdr *h,</a>
<a name="ln1132">    vrf_id_t vrf_id)</a>
<a name="ln1133">{</a>
<a name="ln1134">  int len;</a>
<a name="ln1135">  struct ifinfomsg *ifi;</a>
<a name="ln1136">  struct rtattr *tb[IFLA_MAX + 1];</a>
<a name="ln1137">  struct interface *ifp;</a>
<a name="ln1138">  char *name;</a>
<a name="ln1139"> </a>
<a name="ln1140">  ifi = NLMSG_DATA (h);</a>
<a name="ln1141"> </a>
<a name="ln1142">  if (!(h-&gt;nlmsg_type == RTM_NEWLINK || h-&gt;nlmsg_type == RTM_DELLINK))</a>
<a name="ln1143">    {</a>
<a name="ln1144">      /* If this is not link add/delete message so print warning. */</a>
<a name="ln1145">      zlog_warn (&quot;netlink_link_change: wrong kernel message %d vrf %u\n&quot;,</a>
<a name="ln1146">                 h-&gt;nlmsg_type, vrf_id);</a>
<a name="ln1147">      return 0;</a>
<a name="ln1148">    }</a>
<a name="ln1149"> </a>
<a name="ln1150">  len = h-&gt;nlmsg_len - NLMSG_LENGTH (sizeof (struct ifinfomsg));</a>
<a name="ln1151">  if (len &lt; 0)</a>
<a name="ln1152">    return -1;</a>
<a name="ln1153"> </a>
<a name="ln1154">  /* Looking up interface name. */</a>
<a name="ln1155">  memset (tb, 0, sizeof tb);</a>
<a name="ln1156">  netlink_parse_rtattr (tb, IFLA_MAX, IFLA_RTA (ifi), len);</a>
<a name="ln1157"> </a>
<a name="ln1158">#ifdef IFLA_WIRELESS</a>
<a name="ln1159">  /* check for wireless messages to ignore */</a>
<a name="ln1160">  if ((tb[IFLA_WIRELESS] != NULL) &amp;&amp; (ifi-&gt;ifi_change == 0))</a>
<a name="ln1161">    {</a>
<a name="ln1162">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1163">        zlog_debug (&quot;%s: ignoring IFLA_WIRELESS message, vrf %u&quot;, __func__,</a>
<a name="ln1164">                    vrf_id);</a>
<a name="ln1165">      return 0;</a>
<a name="ln1166">    }</a>
<a name="ln1167">#endif /* IFLA_WIRELESS */</a>
<a name="ln1168">  </a>
<a name="ln1169">  if (tb[IFLA_IFNAME] == NULL)</a>
<a name="ln1170">    return -1;</a>
<a name="ln1171">  name = (char *) RTA_DATA (tb[IFLA_IFNAME]);</a>
<a name="ln1172"> </a>
<a name="ln1173">  /* Add interface. */</a>
<a name="ln1174">  if (h-&gt;nlmsg_type == RTM_NEWLINK)</a>
<a name="ln1175">    {</a>
<a name="ln1176">      ifp = if_lookup_by_name_vrf (name, vrf_id);</a>
<a name="ln1177"> </a>
<a name="ln1178">      if (ifp == NULL || !CHECK_FLAG (ifp-&gt;status, ZEBRA_INTERFACE_ACTIVE))</a>
<a name="ln1179">        {</a>
<a name="ln1180">          if (ifp == NULL)</a>
<a name="ln1181">            ifp = if_get_by_name_vrf (name, vrf_id);</a>
<a name="ln1182"> </a>
<a name="ln1183">          set_ifindex(ifp, ifi-&gt;ifi_index);</a>
<a name="ln1184">          ifp-&gt;flags = ifi-&gt;ifi_flags &amp; 0x0000fffff;</a>
<a name="ln1185">          ifp-&gt;mtu6 = ifp-&gt;mtu = *(int *) RTA_DATA (tb[IFLA_MTU]);</a>
<a name="ln1186">          ifp-&gt;metric = 0;</a>
<a name="ln1187"> </a>
<a name="ln1188">          netlink_interface_update_hw_addr (tb, ifp);</a>
<a name="ln1189"> </a>
<a name="ln1190">          /* If new link is added. */</a>
<a name="ln1191">          if_add_update (ifp);</a>
<a name="ln1192">        }</a>
<a name="ln1193">      else</a>
<a name="ln1194">        {</a>
<a name="ln1195">          /* Interface status change. */</a>
<a name="ln1196">          set_ifindex(ifp, ifi-&gt;ifi_index);</a>
<a name="ln1197">          ifp-&gt;mtu6 = ifp-&gt;mtu = *(int *) RTA_DATA (tb[IFLA_MTU]);</a>
<a name="ln1198">          ifp-&gt;metric = 0;</a>
<a name="ln1199"> </a>
<a name="ln1200">          netlink_interface_update_hw_addr (tb, ifp);</a>
<a name="ln1201"> </a>
<a name="ln1202">          if (if_is_operative (ifp))</a>
<a name="ln1203">            {</a>
<a name="ln1204">              ifp-&gt;flags = ifi-&gt;ifi_flags &amp; 0x0000fffff;</a>
<a name="ln1205">              if (!if_is_operative (ifp))</a>
<a name="ln1206">                if_down (ifp);</a>
<a name="ln1207">	      else</a>
<a name="ln1208">		/* Must notify client daemons of new interface status. */</a>
<a name="ln1209">	        zebra_interface_up_update (ifp);</a>
<a name="ln1210">            }</a>
<a name="ln1211">          else</a>
<a name="ln1212">            {</a>
<a name="ln1213">              ifp-&gt;flags = ifi-&gt;ifi_flags &amp; 0x0000fffff;</a>
<a name="ln1214">              if (if_is_operative (ifp))</a>
<a name="ln1215">                if_up (ifp);</a>
<a name="ln1216">            }</a>
<a name="ln1217">        }</a>
<a name="ln1218">    }</a>
<a name="ln1219">  else</a>
<a name="ln1220">    {</a>
<a name="ln1221">      /* RTM_DELLINK. */</a>
<a name="ln1222">      ifp = if_lookup_by_name_vrf (name, vrf_id);</a>
<a name="ln1223"> </a>
<a name="ln1224">      if (ifp == NULL)</a>
<a name="ln1225">        {</a>
<a name="ln1226">          zlog_warn (&quot;interface %s vrf %u is deleted but can't find&quot;,</a>
<a name="ln1227">                     name, vrf_id);</a>
<a name="ln1228">          return 0;</a>
<a name="ln1229">        }</a>
<a name="ln1230"> </a>
<a name="ln1231">      if_delete_update (ifp);</a>
<a name="ln1232">    }</a>
<a name="ln1233"> </a>
<a name="ln1234">  return 0;</a>
<a name="ln1235">}</a>
<a name="ln1236"> </a>
<a name="ln1237">static int</a>
<a name="ln1238">netlink_information_fetch (struct sockaddr_nl *snl, struct nlmsghdr *h,</a>
<a name="ln1239">    vrf_id_t vrf_id)</a>
<a name="ln1240">{</a>
<a name="ln1241">  /* JF: Ignore messages that aren't from the kernel */</a>
<a name="ln1242">  if ( snl-&gt;nl_pid != 0 )</a>
<a name="ln1243">    {</a>
<a name="ln1244">      zlog ( NULL, LOG_ERR, &quot;Ignoring message from pid %u&quot;, snl-&gt;nl_pid );</a>
<a name="ln1245">      return 0;</a>
<a name="ln1246">    }</a>
<a name="ln1247"> </a>
<a name="ln1248">  switch (h-&gt;nlmsg_type)</a>
<a name="ln1249">    {</a>
<a name="ln1250">    case RTM_NEWROUTE:</a>
<a name="ln1251">      return netlink_route_change (snl, h, vrf_id);</a>
<a name="ln1252">      break;</a>
<a name="ln1253">    case RTM_DELROUTE:</a>
<a name="ln1254">      return netlink_route_change (snl, h, vrf_id);</a>
<a name="ln1255">      break;</a>
<a name="ln1256">    case RTM_NEWLINK:</a>
<a name="ln1257">      return netlink_link_change (snl, h, vrf_id);</a>
<a name="ln1258">      break;</a>
<a name="ln1259">    case RTM_DELLINK:</a>
<a name="ln1260">      return netlink_link_change (snl, h, vrf_id);</a>
<a name="ln1261">      break;</a>
<a name="ln1262">    case RTM_NEWADDR:</a>
<a name="ln1263">      return netlink_interface_addr (snl, h, vrf_id);</a>
<a name="ln1264">      break;</a>
<a name="ln1265">    case RTM_DELADDR:</a>
<a name="ln1266">      return netlink_interface_addr (snl, h, vrf_id);</a>
<a name="ln1267">      break;</a>
<a name="ln1268">    default:</a>
<a name="ln1269">      zlog_warn (&quot;Unknown netlink nlmsg_type %d vrf %u\n&quot;, h-&gt;nlmsg_type,</a>
<a name="ln1270">                 vrf_id);</a>
<a name="ln1271">      break;</a>
<a name="ln1272">    }</a>
<a name="ln1273">  return 0;</a>
<a name="ln1274">}</a>
<a name="ln1275"> </a>
<a name="ln1276">/* Interface lookup by netlink socket. */</a>
<a name="ln1277">int</a>
<a name="ln1278">interface_lookup_netlink (struct zebra_vrf *zvrf)</a>
<a name="ln1279">{</a>
<a name="ln1280">  int ret;</a>
<a name="ln1281"> </a>
<a name="ln1282">  /* Get interface information. */</a>
<a name="ln1283">  ret = netlink_request (AF_PACKET, RTM_GETLINK, &amp;zvrf-&gt;netlink_cmd);</a>
<a name="ln1284">  if (ret &lt; 0)</a>
<a name="ln1285">    return ret;</a>
<a name="ln1286">  ret = netlink_parse_info (netlink_interface, &amp;zvrf-&gt;netlink_cmd, zvrf);</a>
<a name="ln1287">  if (ret &lt; 0)</a>
<a name="ln1288">    return ret;</a>
<a name="ln1289"> </a>
<a name="ln1290">  /* Get IPv4 address of the interfaces. */</a>
<a name="ln1291">  ret = netlink_request (AF_INET, RTM_GETADDR, &amp;zvrf-&gt;netlink_cmd);</a>
<a name="ln1292">  if (ret &lt; 0)</a>
<a name="ln1293">    return ret;</a>
<a name="ln1294">  ret = netlink_parse_info (netlink_interface_addr, &amp;zvrf-&gt;netlink_cmd, zvrf);</a>
<a name="ln1295">  if (ret &lt; 0)</a>
<a name="ln1296">    return ret;</a>
<a name="ln1297"> </a>
<a name="ln1298">#ifdef HAVE_IPV6</a>
<a name="ln1299">  /* Get IPv6 address of the interfaces. */</a>
<a name="ln1300">  ret = netlink_request (AF_INET6, RTM_GETADDR, &amp;zvrf-&gt;netlink_cmd);</a>
<a name="ln1301">  if (ret &lt; 0)</a>
<a name="ln1302">    return ret;</a>
<a name="ln1303">  ret = netlink_parse_info (netlink_interface_addr, &amp;zvrf-&gt;netlink_cmd, zvrf);</a>
<a name="ln1304">  if (ret &lt; 0)</a>
<a name="ln1305">    return ret;</a>
<a name="ln1306">#endif /* HAVE_IPV6 */</a>
<a name="ln1307"> </a>
<a name="ln1308">  return 0;</a>
<a name="ln1309">}</a>
<a name="ln1310"> </a>
<a name="ln1311">/* Routing table read function using netlink interface.  Only called</a>
<a name="ln1312">   bootstrap time. */</a>
<a name="ln1313">int</a>
<a name="ln1314">netlink_route_read (struct zebra_vrf *zvrf)</a>
<a name="ln1315">{</a>
<a name="ln1316">  int ret;</a>
<a name="ln1317"> </a>
<a name="ln1318">  /* Get IPv4 routing table. */</a>
<a name="ln1319">  ret = netlink_request (AF_INET, RTM_GETROUTE, &amp;zvrf-&gt;netlink_cmd);</a>
<a name="ln1320">  if (ret &lt; 0)</a>
<a name="ln1321">    return ret;</a>
<a name="ln1322">  ret = netlink_parse_info (netlink_routing_table, &amp;zvrf-&gt;netlink_cmd, zvrf);</a>
<a name="ln1323">  if (ret &lt; 0)</a>
<a name="ln1324">    return ret;</a>
<a name="ln1325"> </a>
<a name="ln1326">#ifdef HAVE_IPV6</a>
<a name="ln1327">  /* Get IPv6 routing table. */</a>
<a name="ln1328">  ret = netlink_request (AF_INET6, RTM_GETROUTE, &amp;zvrf-&gt;netlink_cmd);</a>
<a name="ln1329">  if (ret &lt; 0)</a>
<a name="ln1330">    return ret;</a>
<a name="ln1331">  ret = netlink_parse_info (netlink_routing_table, &amp;zvrf-&gt;netlink_cmd, zvrf);</a>
<a name="ln1332">  if (ret &lt; 0)</a>
<a name="ln1333">    return ret;</a>
<a name="ln1334">#endif /* HAVE_IPV6 */</a>
<a name="ln1335"> </a>
<a name="ln1336">  return 0;</a>
<a name="ln1337">}</a>
<a name="ln1338"> </a>
<a name="ln1339">/* Utility function  comes from iproute2. </a>
<a name="ln1340">   Authors:	Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt; */</a>
<a name="ln1341">int</a>
<a name="ln1342">addattr_l (struct nlmsghdr *n, size_t maxlen, int type, void *data, size_t alen)</a>
<a name="ln1343">{</a>
<a name="ln1344">  size_t len;</a>
<a name="ln1345">  struct rtattr *rta;</a>
<a name="ln1346"> </a>
<a name="ln1347">  len = RTA_LENGTH (alen);</a>
<a name="ln1348"> </a>
<a name="ln1349">  if (NLMSG_ALIGN (n-&gt;nlmsg_len) + len &gt; maxlen)</a>
<a name="ln1350">    return -1;</a>
<a name="ln1351"> </a>
<a name="ln1352">  rta = (struct rtattr *) (((char *) n) + NLMSG_ALIGN (n-&gt;nlmsg_len));</a>
<a name="ln1353">  rta-&gt;rta_type = type;</a>
<a name="ln1354">  rta-&gt;rta_len = len;</a>
<a name="ln1355">  memcpy (RTA_DATA (rta), data, alen);</a>
<a name="ln1356">  n-&gt;nlmsg_len = NLMSG_ALIGN (n-&gt;nlmsg_len) + len;</a>
<a name="ln1357"> </a>
<a name="ln1358">  return 0;</a>
<a name="ln1359">}</a>
<a name="ln1360"> </a>
<a name="ln1361">int</a>
<a name="ln1362">rta_addattr_l (struct rtattr *rta, size_t maxlen, int type, void *data, </a>
<a name="ln1363">               size_t alen)</a>
<a name="ln1364">{</a>
<a name="ln1365">  size_t len;</a>
<a name="ln1366">  struct rtattr *subrta;</a>
<a name="ln1367"> </a>
<a name="ln1368">  len = RTA_LENGTH (alen);</a>
<a name="ln1369"> </a>
<a name="ln1370">  if (RTA_ALIGN (rta-&gt;rta_len) + len &gt; maxlen)</a>
<a name="ln1371">    return -1;</a>
<a name="ln1372"> </a>
<a name="ln1373">  subrta = (struct rtattr *) (((char *) rta) + RTA_ALIGN (rta-&gt;rta_len));</a>
<a name="ln1374">  subrta-&gt;rta_type = type;</a>
<a name="ln1375">  subrta-&gt;rta_len = len;</a>
<a name="ln1376">  memcpy (RTA_DATA (subrta), data, alen);</a>
<a name="ln1377">  rta-&gt;rta_len = NLMSG_ALIGN (rta-&gt;rta_len) + len;</a>
<a name="ln1378"> </a>
<a name="ln1379">  return 0;</a>
<a name="ln1380">}</a>
<a name="ln1381"> </a>
<a name="ln1382">/* Utility function comes from iproute2. </a>
<a name="ln1383">   Authors:	Alexey Kuznetsov, &lt;kuznet@ms2.inr.ac.ru&gt; */</a>
<a name="ln1384">int</a>
<a name="ln1385">addattr32 (struct nlmsghdr *n, size_t maxlen, int type, int data)</a>
<a name="ln1386">{</a>
<a name="ln1387">  size_t len;</a>
<a name="ln1388">  struct rtattr *rta;</a>
<a name="ln1389"> </a>
<a name="ln1390">  len = RTA_LENGTH (4);</a>
<a name="ln1391"> </a>
<a name="ln1392">  if (NLMSG_ALIGN (n-&gt;nlmsg_len) + len &gt; maxlen)</a>
<a name="ln1393">    return -1;</a>
<a name="ln1394"> </a>
<a name="ln1395">  rta = (struct rtattr *) (((char *) n) + NLMSG_ALIGN (n-&gt;nlmsg_len));</a>
<a name="ln1396">  rta-&gt;rta_type = type;</a>
<a name="ln1397">  rta-&gt;rta_len = len;</a>
<a name="ln1398">  memcpy (RTA_DATA (rta), &amp;data, 4);</a>
<a name="ln1399">  n-&gt;nlmsg_len = NLMSG_ALIGN (n-&gt;nlmsg_len) + len;</a>
<a name="ln1400"> </a>
<a name="ln1401">  return 0;</a>
<a name="ln1402">}</a>
<a name="ln1403"> </a>
<a name="ln1404">static int</a>
<a name="ln1405">netlink_talk_filter (struct sockaddr_nl *snl, struct nlmsghdr *h,</a>
<a name="ln1406">    vrf_id_t vrf_id)</a>
<a name="ln1407">{</a>
<a name="ln1408">  zlog_warn (&quot;netlink_talk: ignoring message type 0x%04x vrf %u&quot;, h-&gt;nlmsg_type,</a>
<a name="ln1409">             vrf_id);</a>
<a name="ln1410">  return 0;</a>
<a name="ln1411">}</a>
<a name="ln1412"> </a>
<a name="ln1413">/* sendmsg() to netlink socket then recvmsg(). */</a>
<a name="ln1414">static int</a>
<a name="ln1415">netlink_talk (struct nlmsghdr *n, struct nlsock *nl, struct zebra_vrf *zvrf)</a>
<a name="ln1416">{</a>
<a name="ln1417">  int status;</a>
<a name="ln1418">  struct sockaddr_nl snl;</a>
<a name="ln1419">  struct iovec iov = {</a>
<a name="ln1420">    .iov_base = (void *) n,</a>
<a name="ln1421">    .iov_len = n-&gt;nlmsg_len</a>
<a name="ln1422">  };</a>
<a name="ln1423">  struct msghdr msg = {</a>
<a name="ln1424">    .msg_name = (void *) &amp;snl,</a>
<a name="ln1425">    .msg_namelen = sizeof snl,</a>
<a name="ln1426">    .msg_iov = &amp;iov,</a>
<a name="ln1427">    .msg_iovlen = 1,</a>
<a name="ln1428">  };</a>
<a name="ln1429">  int save_errno;</a>
<a name="ln1430"> </a>
<a name="ln1431">  memset (&amp;snl, 0, sizeof snl);</a>
<a name="ln1432">  snl.nl_family = AF_NETLINK;</a>
<a name="ln1433"> </a>
<a name="ln1434">  n-&gt;nlmsg_seq = ++nl-&gt;seq;</a>
<a name="ln1435"> </a>
<a name="ln1436">  /* Request an acknowledgement by setting NLM_F_ACK */</a>
<a name="ln1437">  n-&gt;nlmsg_flags |= NLM_F_ACK;</a>
<a name="ln1438"> </a>
<a name="ln1439">  if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1440">    zlog_debug (&quot;netlink_talk: %s type %s(%u), seq=%u&quot;, nl-&gt;name,</a>
<a name="ln1441">               lookup (nlmsg_str, n-&gt;nlmsg_type), n-&gt;nlmsg_type,</a>
<a name="ln1442">               n-&gt;nlmsg_seq);</a>
<a name="ln1443"> </a>
<a name="ln1444">  /* Send message to netlink interface. */</a>
<a name="ln1445">  if (zserv_privs.change (ZPRIVS_RAISE))</a>
<a name="ln1446">    zlog (NULL, LOG_ERR, &quot;Can't raise privileges&quot;);</a>
<a name="ln1447">  status = sendmsg (nl-&gt;sock, &amp;msg, 0);</a>
<a name="ln1448">  save_errno = errno;</a>
<a name="ln1449">  if (zserv_privs.change (ZPRIVS_LOWER))</a>
<a name="ln1450">    zlog (NULL, LOG_ERR, &quot;Can't lower privileges&quot;);</a>
<a name="ln1451"> </a>
<a name="ln1452">  if (status &lt; 0)</a>
<a name="ln1453">    {</a>
<a name="ln1454">      zlog (NULL, LOG_ERR, &quot;netlink_talk sendmsg() error: %s&quot;,</a>
<a name="ln1455">            safe_strerror (save_errno));</a>
<a name="ln1456">      return -1;</a>
<a name="ln1457">    }</a>
<a name="ln1458"> </a>
<a name="ln1459"> </a>
<a name="ln1460">  /* </a>
<a name="ln1461">   * Get reply from netlink socket. </a>
<a name="ln1462">   * The reply should either be an acknowlegement or an error.</a>
<a name="ln1463">   */</a>
<a name="ln1464">  return netlink_parse_info (netlink_talk_filter, nl, zvrf);</a>
<a name="ln1465">}</a>
<a name="ln1466"> </a>
<a name="ln1467">/* This function takes a nexthop as argument and adds</a>
<a name="ln1468"> * the appropriate netlink attributes to an existing</a>
<a name="ln1469"> * netlink message.</a>
<a name="ln1470"> *</a>
<a name="ln1471"> * @param routedesc: Human readable description of route type</a>
<a name="ln1472"> *                   (direct/recursive, single-/multipath)</a>
<a name="ln1473"> * @param bytelen: Length of addresses in bytes.</a>
<a name="ln1474"> * @param nexthop: Nexthop information</a>
<a name="ln1475"> * @param nlmsg: nlmsghdr structure to fill in.</a>
<a name="ln1476"> * @param req_size: The size allocated for the message.</a>
<a name="ln1477"> */</a>
<a name="ln1478">static void</a>
<a name="ln1479">_netlink_route_build_singlepath(</a>
<a name="ln1480">        const char *routedesc,</a>
<a name="ln1481">        int bytelen,</a>
<a name="ln1482">        struct nexthop *nexthop,</a>
<a name="ln1483">        struct nlmsghdr *nlmsg,</a>
<a name="ln1484">        struct rtmsg *rtmsg,</a>
<a name="ln1485">        size_t req_size)</a>
<a name="ln1486">{</a>
<a name="ln1487">  if (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ONLINK))</a>
<a name="ln1488">    rtmsg-&gt;rtm_flags |= RTNH_F_ONLINK;</a>
<a name="ln1489">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV4</a>
<a name="ln1490">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV4_IFINDEX)</a>
<a name="ln1491">    {</a>
<a name="ln1492">      addattr_l (nlmsg, req_size, RTA_GATEWAY,</a>
<a name="ln1493">                 &amp;nexthop-&gt;gate.ipv4, bytelen);</a>
<a name="ln1494">      if (nexthop-&gt;src.ipv4.s_addr)</a>
<a name="ln1495">        addattr_l (nlmsg, req_size, RTA_PREFSRC,</a>
<a name="ln1496">                   &amp;nexthop-&gt;src.ipv4, bytelen);</a>
<a name="ln1497"> </a>
<a name="ln1498">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1499">        zlog_debug(&quot;netlink_route_multipath() (%s): &quot;</a>
<a name="ln1500">                   &quot;nexthop via %s if %u&quot;,</a>
<a name="ln1501">                   routedesc,</a>
<a name="ln1502">                   inet_ntoa (nexthop-&gt;gate.ipv4),</a>
<a name="ln1503">                   nexthop-&gt;ifindex);</a>
<a name="ln1504">    }</a>
<a name="ln1505">#ifdef HAVE_IPV6</a>
<a name="ln1506">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV6</a>
<a name="ln1507">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFNAME</a>
<a name="ln1508">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFINDEX)</a>
<a name="ln1509">    {</a>
<a name="ln1510">      addattr_l (nlmsg, req_size, RTA_GATEWAY,</a>
<a name="ln1511">                 &amp;nexthop-&gt;gate.ipv6, bytelen);</a>
<a name="ln1512"> </a>
<a name="ln1513">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1514">        zlog_debug(&quot;netlink_route_multipath() (%s): &quot;</a>
<a name="ln1515">                   &quot;nexthop via %s if %u&quot;,</a>
<a name="ln1516">                   routedesc,</a>
<a name="ln1517">                   inet6_ntoa (nexthop-&gt;gate.ipv6),</a>
<a name="ln1518">                   nexthop-&gt;ifindex);</a>
<a name="ln1519">    }</a>
<a name="ln1520">#endif /* HAVE_IPV6 */</a>
<a name="ln1521">  if (nexthop-&gt;type == NEXTHOP_TYPE_IFINDEX</a>
<a name="ln1522">      || nexthop-&gt;type == NEXTHOP_TYPE_IFNAME</a>
<a name="ln1523">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV4_IFINDEX)</a>
<a name="ln1524">    {</a>
<a name="ln1525">      addattr32 (nlmsg, req_size, RTA_OIF, nexthop-&gt;ifindex);</a>
<a name="ln1526"> </a>
<a name="ln1527">      if (nexthop-&gt;src.ipv4.s_addr)</a>
<a name="ln1528">        addattr_l (nlmsg, req_size, RTA_PREFSRC,</a>
<a name="ln1529">                   &amp;nexthop-&gt;src.ipv4, bytelen);</a>
<a name="ln1530"> </a>
<a name="ln1531">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1532">        zlog_debug(&quot;netlink_route_multipath() (%s): &quot;</a>
<a name="ln1533">                   &quot;nexthop via if %u&quot;, routedesc, nexthop-&gt;ifindex);</a>
<a name="ln1534">    }</a>
<a name="ln1535"> </a>
<a name="ln1536">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFINDEX</a>
<a name="ln1537">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFNAME)</a>
<a name="ln1538">    {</a>
<a name="ln1539">      addattr32 (nlmsg, req_size, RTA_OIF, nexthop-&gt;ifindex);</a>
<a name="ln1540"> </a>
<a name="ln1541">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1542">        zlog_debug(&quot;netlink_route_multipath() (%s): &quot;</a>
<a name="ln1543">                   &quot;nexthop via if %u&quot;, routedesc, nexthop-&gt;ifindex);</a>
<a name="ln1544">    }</a>
<a name="ln1545">}</a>
<a name="ln1546"> </a>
<a name="ln1547">/* This function takes a nexthop as argument and</a>
<a name="ln1548"> * appends to the given rtattr/rtnexthop pair the</a>
<a name="ln1549"> * representation of the nexthop. If the nexthop</a>
<a name="ln1550"> * defines a preferred source, the src parameter</a>
<a name="ln1551"> * will be modified to point to that src, otherwise</a>
<a name="ln1552"> * it will be kept unmodified.</a>
<a name="ln1553"> *</a>
<a name="ln1554"> * @param routedesc: Human readable description of route type</a>
<a name="ln1555"> *                   (direct/recursive, single-/multipath)</a>
<a name="ln1556"> * @param bytelen: Length of addresses in bytes.</a>
<a name="ln1557"> * @param nexthop: Nexthop information</a>
<a name="ln1558"> * @param rta: rtnetlink attribute structure</a>
<a name="ln1559"> * @param rtnh: pointer to an rtnetlink nexthop structure</a>
<a name="ln1560"> * @param src: pointer pointing to a location where</a>
<a name="ln1561"> *             the prefsrc should be stored.</a>
<a name="ln1562"> */</a>
<a name="ln1563">static void</a>
<a name="ln1564">_netlink_route_build_multipath(</a>
<a name="ln1565">        const char *routedesc,</a>
<a name="ln1566">        int bytelen,</a>
<a name="ln1567">        struct nexthop *nexthop,</a>
<a name="ln1568">        struct rtattr *rta,</a>
<a name="ln1569">        struct rtnexthop *rtnh,</a>
<a name="ln1570">        union g_addr **src</a>
<a name="ln1571">        )</a>
<a name="ln1572">{</a>
<a name="ln1573">  rtnh-&gt;rtnh_len = sizeof (*rtnh);</a>
<a name="ln1574">  rtnh-&gt;rtnh_flags = 0;</a>
<a name="ln1575">  rtnh-&gt;rtnh_hops = 0;</a>
<a name="ln1576">  rta-&gt;rta_len += rtnh-&gt;rtnh_len;</a>
<a name="ln1577"> </a>
<a name="ln1578">  if (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ONLINK))</a>
<a name="ln1579">    rtnh-&gt;rtnh_flags |= RTNH_F_ONLINK;</a>
<a name="ln1580"> </a>
<a name="ln1581">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV4</a>
<a name="ln1582">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV4_IFINDEX)</a>
<a name="ln1583">    {</a>
<a name="ln1584">      rta_addattr_l (rta, NL_PKT_BUF_SIZE, RTA_GATEWAY,</a>
<a name="ln1585">                     &amp;nexthop-&gt;gate.ipv4, bytelen);</a>
<a name="ln1586">      rtnh-&gt;rtnh_len += sizeof (struct rtattr) + bytelen;</a>
<a name="ln1587"> </a>
<a name="ln1588">      if (nexthop-&gt;src.ipv4.s_addr)</a>
<a name="ln1589">        *src = &amp;nexthop-&gt;src;</a>
<a name="ln1590"> </a>
<a name="ln1591">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1592">        zlog_debug(&quot;netlink_route_multipath() (%s): &quot;</a>
<a name="ln1593">                   &quot;nexthop via %s if %u&quot;,</a>
<a name="ln1594">                   routedesc,</a>
<a name="ln1595">                   inet_ntoa (nexthop-&gt;gate.ipv4),</a>
<a name="ln1596">                   nexthop-&gt;ifindex);</a>
<a name="ln1597">    }</a>
<a name="ln1598">#ifdef HAVE_IPV6</a>
<a name="ln1599">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV6</a>
<a name="ln1600">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFNAME</a>
<a name="ln1601">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFINDEX)</a>
<a name="ln1602">    {</a>
<a name="ln1603">      rta_addattr_l (rta, NL_PKT_BUF_SIZE, RTA_GATEWAY,</a>
<a name="ln1604">                     &amp;nexthop-&gt;gate.ipv6, bytelen);</a>
<a name="ln1605">      rtnh-&gt;rtnh_len += sizeof (struct rtattr) + bytelen;</a>
<a name="ln1606"> </a>
<a name="ln1607">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1608">        zlog_debug(&quot;netlink_route_multipath() (%s): &quot;</a>
<a name="ln1609">                   &quot;nexthop via %s if %u&quot;,</a>
<a name="ln1610">                   routedesc,</a>
<a name="ln1611">                   inet6_ntoa (nexthop-&gt;gate.ipv6),</a>
<a name="ln1612">                   nexthop-&gt;ifindex);</a>
<a name="ln1613">    }</a>
<a name="ln1614">#endif /* HAVE_IPV6 */</a>
<a name="ln1615">  /* ifindex */</a>
<a name="ln1616">  if (nexthop-&gt;type == NEXTHOP_TYPE_IPV4_IFINDEX</a>
<a name="ln1617">      || nexthop-&gt;type == NEXTHOP_TYPE_IFINDEX</a>
<a name="ln1618">      || nexthop-&gt;type == NEXTHOP_TYPE_IFNAME)</a>
<a name="ln1619">    {</a>
<a name="ln1620">      rtnh-&gt;rtnh_ifindex = nexthop-&gt;ifindex;</a>
<a name="ln1621">      if (nexthop-&gt;src.ipv4.s_addr)</a>
<a name="ln1622">        *src = &amp;nexthop-&gt;src;</a>
<a name="ln1623">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1624">        zlog_debug(&quot;netlink_route_multipath() (%s): &quot;</a>
<a name="ln1625">                   &quot;nexthop via if %u&quot;, routedesc, nexthop-&gt;ifindex);</a>
<a name="ln1626">    }</a>
<a name="ln1627">  else if (nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFNAME</a>
<a name="ln1628">      || nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFINDEX)</a>
<a name="ln1629">    {</a>
<a name="ln1630">      rtnh-&gt;rtnh_ifindex = nexthop-&gt;ifindex;</a>
<a name="ln1631"> </a>
<a name="ln1632">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1633">        zlog_debug(&quot;netlink_route_multipath() (%s): &quot;</a>
<a name="ln1634">                   &quot;nexthop via if %u&quot;, routedesc, nexthop-&gt;ifindex);</a>
<a name="ln1635">    }</a>
<a name="ln1636">  else</a>
<a name="ln1637">    {</a>
<a name="ln1638">      rtnh-&gt;rtnh_ifindex = 0;</a>
<a name="ln1639">    }</a>
<a name="ln1640">}</a>
<a name="ln1641"> </a>
<a name="ln1642">/* Log debug information for netlink_route_multipath</a>
<a name="ln1643"> * if debug logging is enabled.</a>
<a name="ln1644"> *</a>
<a name="ln1645"> * @param cmd: Netlink command which is to be processed</a>
<a name="ln1646"> * @param p: Prefix for which the change is due</a>
<a name="ln1647"> * @param nexthop: Nexthop which is currently processed</a>
<a name="ln1648"> * @param routedesc: Semantic annotation for nexthop</a>
<a name="ln1649"> *                     (recursive, multipath, etc.)</a>
<a name="ln1650"> * @param family: Address family which the change concerns</a>
<a name="ln1651"> */</a>
<a name="ln1652">static void</a>
<a name="ln1653">_netlink_route_debug(</a>
<a name="ln1654">        int cmd,</a>
<a name="ln1655">        struct prefix *p,</a>
<a name="ln1656">        struct nexthop *nexthop,</a>
<a name="ln1657">        const char *routedesc,</a>
<a name="ln1658">        int family,</a>
<a name="ln1659">        struct zebra_vrf *zvrf)</a>
<a name="ln1660">{</a>
<a name="ln1661">  if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1662">    {</a>
<a name="ln1663">      char buf[PREFIX_STRLEN];</a>
<a name="ln1664">      zlog_debug (&quot;netlink_route_multipath() (%s): %s %s vrf %u type %s&quot;,</a>
<a name="ln1665">         routedesc,</a>
<a name="ln1666">         lookup (nlmsg_str, cmd),</a>
<a name="ln1667">         prefix2str (p, buf, sizeof(buf)),</a>
<a name="ln1668">         zvrf-&gt;vrf_id,</a>
<a name="ln1669">         nexthop_type_to_str (nexthop-&gt;type));</a>
<a name="ln1670">    }</a>
<a name="ln1671">}</a>
<a name="ln1672"> </a>
<a name="ln1673">/* Routing table change via netlink interface. */</a>
<a name="ln1674">static int</a>
<a name="ln1675">netlink_route_multipath (int cmd, struct prefix *p, struct rib *rib)</a>
<a name="ln1676">{</a>
<a name="ln1677">  int bytelen;</a>
<a name="ln1678">  struct sockaddr_nl snl;</a>
<a name="ln1679">  struct nexthop *nexthop = NULL, *tnexthop;</a>
<a name="ln1680">  int recursing;</a>
<a name="ln1681">  int nexthop_num;</a>
<a name="ln1682">  int discard;</a>
<a name="ln1683">  int family = PREFIX_FAMILY(p);</a>
<a name="ln1684">  const char *routedesc;</a>
<a name="ln1685"> </a>
<a name="ln1686">  struct</a>
<a name="ln1687">  {</a>
<a name="ln1688">    struct nlmsghdr n;</a>
<a name="ln1689">    struct rtmsg r;</a>
<a name="ln1690">    char buf[NL_PKT_BUF_SIZE];</a>
<a name="ln1691">  } req;</a>
<a name="ln1692"> </a>
<a name="ln1693">  struct zebra_vrf *zvrf = vrf_info_lookup (rib-&gt;vrf_id);</a>
<a name="ln1694"> </a>
<a name="ln1695">  memset (&amp;req, 0, sizeof req - NL_PKT_BUF_SIZE);</a>
<a name="ln1696"> </a>
<a name="ln1697">  bytelen = (family == AF_INET ? 4 : 16);</a>
<a name="ln1698"> </a>
<a name="ln1699">  req.n.nlmsg_len = NLMSG_LENGTH (sizeof (struct rtmsg));</a>
<a name="ln1700">  req.n.nlmsg_flags = NLM_F_CREATE | NLM_F_REPLACE | NLM_F_REQUEST;</a>
<a name="ln1701">  req.n.nlmsg_type = cmd;</a>
<a name="ln1702">  req.r.rtm_family = family;</a>
<a name="ln1703">  req.r.rtm_table = rib-&gt;table;</a>
<a name="ln1704">  req.r.rtm_dst_len = p-&gt;prefixlen;</a>
<a name="ln1705">  req.r.rtm_protocol = RTPROT_ZEBRA;</a>
<a name="ln1706">  req.r.rtm_scope = RT_SCOPE_LINK;</a>
<a name="ln1707"> </a>
<a name="ln1708">  if ((rib-&gt;flags &amp; ZEBRA_FLAG_BLACKHOLE) || (rib-&gt;flags &amp; ZEBRA_FLAG_REJECT))</a>
<a name="ln1709">    discard = 1;</a>
<a name="ln1710">  else</a>
<a name="ln1711">    discard = 0;</a>
<a name="ln1712"> </a>
<a name="ln1713">  if (cmd == RTM_NEWROUTE)</a>
<a name="ln1714">    {</a>
<a name="ln1715">      if (discard)</a>
<a name="ln1716">        {</a>
<a name="ln1717">          if (rib-&gt;flags &amp; ZEBRA_FLAG_BLACKHOLE)</a>
<a name="ln1718">            req.r.rtm_type = RTN_BLACKHOLE;</a>
<a name="ln1719">          else if (rib-&gt;flags &amp; ZEBRA_FLAG_REJECT)</a>
<a name="ln1720">            req.r.rtm_type = RTN_UNREACHABLE;</a>
<a name="ln1721">          else</a>
<a name="ln1722">            assert (RTN_BLACKHOLE != RTN_UNREACHABLE);  /* false */</a>
<a name="ln1723">        }</a>
<a name="ln1724">      else</a>
<a name="ln1725">        req.r.rtm_type = RTN_UNICAST;</a>
<a name="ln1726">    }</a>
<a name="ln1727"> </a>
<a name="ln1728">  addattr_l (&amp;req.n, sizeof req, RTA_DST, &amp;p-&gt;u.prefix, bytelen);</a>
<a name="ln1729"> </a>
<a name="ln1730">  /* Metric. */</a>
<a name="ln1731">  addattr32 (&amp;req.n, sizeof req, RTA_PRIORITY, NL_DEFAULT_ROUTE_METRIC);</a>
<a name="ln1732"> </a>
<a name="ln1733">  if (rib-&gt;mtu || rib-&gt;nexthop_mtu)</a>
<a name="ln1734">    {</a>
<a name="ln1735">      char buf[NL_PKT_BUF_SIZE];</a>
<a name="ln1736">      struct rtattr *rta = (void *) buf;</a>
<a name="ln1737">      u_int32_t mtu = rib-&gt;mtu;</a>
<a name="ln1738">      if (!mtu || (rib-&gt;nexthop_mtu &amp;&amp; rib-&gt;nexthop_mtu &lt; mtu))</a>
<a name="ln1739">        mtu = rib-&gt;nexthop_mtu;</a>
<a name="ln1740">      rta-&gt;rta_type = RTA_METRICS;</a>
<a name="ln1741">      rta-&gt;rta_len = RTA_LENGTH(0);</a>
<a name="ln1742">      rta_addattr_l (rta, NL_PKT_BUF_SIZE, RTAX_MTU, &amp;mtu, sizeof mtu);</a>
<a name="ln1743">      addattr_l (&amp;req.n, NL_PKT_BUF_SIZE, RTA_METRICS, RTA_DATA (rta),</a>
<a name="ln1744">                 RTA_PAYLOAD (rta));</a>
<a name="ln1745">    }</a>
<a name="ln1746"> </a>
<a name="ln1747">  if (discard)</a>
<a name="ln1748">    {</a>
<a name="ln1749">      if (cmd == RTM_NEWROUTE)</a>
<a name="ln1750">        for (ALL_NEXTHOPS_RO(rib-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1751">          {</a>
<a name="ln1752">            /* We shouldn't encounter recursive nexthops on discard routes,</a>
<a name="ln1753">             * but it is probably better to handle that case correctly anyway.</a>
<a name="ln1754">             */</a>
<a name="ln1755">            if (CHECK_FLAG(nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE))</a>
<a name="ln1756">              continue;</a>
<a name="ln1757">            SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln1758">          }</a>
<a name="ln1759">      goto skip;</a>
<a name="ln1760">    }</a>
<a name="ln1761"> </a>
<a name="ln1762">  /* Count overall nexthops so we can decide whether to use singlepath</a>
<a name="ln1763">   * or multipath case. */</a>
<a name="ln1764">  nexthop_num = 0;</a>
<a name="ln1765">  for (ALL_NEXTHOPS_RO(rib-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1766">    {</a>
<a name="ln1767">      if (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE))</a>
<a name="ln1768">        continue;</a>
<a name="ln1769">      if (cmd == RTM_NEWROUTE &amp;&amp; !CHECK_FLAG(nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE))</a>
<a name="ln1770">        continue;</a>
<a name="ln1771">      if (cmd == RTM_DELROUTE &amp;&amp; !CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB))</a>
<a name="ln1772">        continue;</a>
<a name="ln1773"> </a>
<a name="ln1774">      if (nexthop-&gt;type != NEXTHOP_TYPE_IFINDEX &amp;&amp;</a>
<a name="ln1775">          nexthop-&gt;type != NEXTHOP_TYPE_IFNAME)</a>
<a name="ln1776">        req.r.rtm_scope = RT_SCOPE_UNIVERSE;</a>
<a name="ln1777"> </a>
<a name="ln1778">      nexthop_num++;</a>
<a name="ln1779">    }</a>
<a name="ln1780"> </a>
<a name="ln1781">  /* Singlepath case. */</a>
<a name="ln1782">  if (nexthop_num == 1 || MULTIPATH_NUM == 1)</a>
<a name="ln1783">    {</a>
<a name="ln1784">      nexthop_num = 0;</a>
<a name="ln1785">      for (ALL_NEXTHOPS_RO(rib-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1786">        {</a>
<a name="ln1787">          if (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE))</a>
<a name="ln1788">            continue;</a>
<a name="ln1789"> </a>
<a name="ln1790">          if ((cmd == RTM_NEWROUTE</a>
<a name="ln1791">               &amp;&amp; CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE))</a>
<a name="ln1792">              || (cmd == RTM_DELROUTE</a>
<a name="ln1793">                  &amp;&amp; CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB)))</a>
<a name="ln1794">            {</a>
<a name="ln1795">              routedesc = recursing ? &quot;recursive, 1 hop&quot; : &quot;single hop&quot;;</a>
<a name="ln1796"> </a>
<a name="ln1797">              _netlink_route_debug(cmd, p, nexthop, routedesc, family, zvrf);</a>
<a name="ln1798">              _netlink_route_build_singlepath(routedesc, bytelen,</a>
<a name="ln1799">                                              nexthop, &amp;req.n, &amp;req.r,</a>
<a name="ln1800">                                              sizeof req);</a>
<a name="ln1801"> </a>
<a name="ln1802">              if (cmd == RTM_NEWROUTE)</a>
<a name="ln1803">                SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln1804"> </a>
<a name="ln1805">              nexthop_num++;</a>
<a name="ln1806">              break;</a>
<a name="ln1807">            }</a>
<a name="ln1808">        }</a>
<a name="ln1809">    }</a>
<a name="ln1810">  else</a>
<a name="ln1811">    {</a>
<a name="ln1812">      char buf[NL_PKT_BUF_SIZE];</a>
<a name="ln1813">      struct rtattr *rta = (void *) buf;</a>
<a name="ln1814">      struct rtnexthop *rtnh;</a>
<a name="ln1815">      union g_addr *src = NULL;</a>
<a name="ln1816"> </a>
<a name="ln1817">      rta-&gt;rta_type = RTA_MULTIPATH;</a>
<a name="ln1818">      rta-&gt;rta_len = RTA_LENGTH (0);</a>
<a name="ln1819">      rtnh = RTA_DATA (rta);</a>
<a name="ln1820"> </a>
<a name="ln1821">      nexthop_num = 0;</a>
<a name="ln1822">      for (ALL_NEXTHOPS_RO(rib-&gt;nexthop, nexthop, tnexthop, recursing))</a>
<a name="ln1823">        {</a>
<a name="ln1824">          if (nexthop_num &gt;= MULTIPATH_NUM)</a>
<a name="ln1825">            break;</a>
<a name="ln1826"> </a>
<a name="ln1827">          if (CHECK_FLAG(nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE))</a>
<a name="ln1828">            continue;</a>
<a name="ln1829"> </a>
<a name="ln1830">          if ((cmd == RTM_NEWROUTE</a>
<a name="ln1831">               &amp;&amp; CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE))</a>
<a name="ln1832">              || (cmd == RTM_DELROUTE</a>
<a name="ln1833">                  &amp;&amp; CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB)))</a>
<a name="ln1834">            {</a>
<a name="ln1835">              routedesc = recursing ? &quot;recursive, multihop&quot; : &quot;multihop&quot;;</a>
<a name="ln1836">              nexthop_num++;</a>
<a name="ln1837"> </a>
<a name="ln1838">              _netlink_route_debug(cmd, p, nexthop,</a>
<a name="ln1839">                                   routedesc, family, zvrf);</a>
<a name="ln1840">              _netlink_route_build_multipath(routedesc, bytelen,</a>
<a name="ln1841">                                             nexthop, rta, rtnh, &amp;src);</a>
<a name="ln1842">              rtnh = RTNH_NEXT (rtnh);</a>
<a name="ln1843"> </a>
<a name="ln1844">              if (cmd == RTM_NEWROUTE)</a>
<a name="ln1845">                SET_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB);</a>
<a name="ln1846">            }</a>
<a name="ln1847">        }</a>
<a name="ln1848">      if (src)</a>
<a name="ln1849">        addattr_l (&amp;req.n, sizeof req, RTA_PREFSRC, &amp;src-&gt;ipv4, bytelen);</a>
<a name="ln1850"> </a>
<a name="ln1851">      if (rta-&gt;rta_len &gt; RTA_LENGTH (0))</a>
<a name="ln1852">        addattr_l (&amp;req.n, NL_PKT_BUF_SIZE, RTA_MULTIPATH, RTA_DATA (rta),</a>
<a name="ln1853">                   RTA_PAYLOAD (rta));</a>
<a name="ln1854">    }</a>
<a name="ln1855"> </a>
<a name="ln1856">  /* If there is no useful nexthop then return. */</a>
<a name="ln1857">  if (nexthop_num == 0)</a>
<a name="ln1858">    {</a>
<a name="ln1859">      if (IS_ZEBRA_DEBUG_KERNEL)</a>
<a name="ln1860">        zlog_debug (&quot;netlink_route_multipath(): No useful nexthop.&quot;);</a>
<a name="ln1861">      return 0;</a>
<a name="ln1862">    }</a>
<a name="ln1863"> </a>
<a name="ln1864">skip:</a>
<a name="ln1865"> </a>
<a name="ln1866">  /* Destination netlink address. */</a>
<a name="ln1867">  memset (&amp;snl, 0, sizeof snl);</a>
<a name="ln1868">  snl.nl_family = AF_NETLINK;</a>
<a name="ln1869"> </a>
<a name="ln1870">  /* Talk to netlink socket. */</a>
<a name="ln1871">  return netlink_talk (&amp;req.n, &amp;zvrf-&gt;netlink_cmd, zvrf);</a>
<a name="ln1872">}</a>
<a name="ln1873"> </a>
<a name="ln1874">int</a>
<a name="ln1875">kernel_route_rib (struct prefix *p, struct rib *old, struct rib *new)</a>
<a name="ln1876">{</a>
<a name="ln1877">  if (!old &amp;&amp; new)</a>
<a name="ln1878">    return netlink_route_multipath (RTM_NEWROUTE, p, new);</a>
<a name="ln1879">  if (old &amp;&amp; !new)</a>
<a name="ln1880">    return netlink_route_multipath (RTM_DELROUTE, p, old);</a>
<a name="ln1881"> </a>
<a name="ln1882">   /* Replace, can be done atomically if metric does not change;</a>
<a name="ln1883">    * netlink uses [prefix, tos, priority] to identify prefix.</a>
<a name="ln1884">    * Now metric is not sent to kernel, so we can just do atomic replace. */</a>
<a name="ln1885">  return netlink_route_multipath (RTM_NEWROUTE, p, new);</a>
<a name="ln1886">}</a>
<a name="ln1887"> </a>
<a name="ln1888">/* Interface address modification. */</a>
<a name="ln1889">static int</a>
<a name="ln1890">netlink_address (int cmd, int family, struct interface *ifp,</a>
<a name="ln1891">                 struct connected *ifc)</a>
<a name="ln1892">{</a>
<a name="ln1893">  int bytelen;</a>
<a name="ln1894">  struct prefix *p;</a>
<a name="ln1895"> </a>
<a name="ln1896">  struct</a>
<a name="ln1897">  {</a>
<a name="ln1898">    struct nlmsghdr n;</a>
<a name="ln1899">    struct ifaddrmsg ifa;</a>
<a name="ln1900">    char buf[NL_PKT_BUF_SIZE];</a>
<a name="ln1901">  } req;</a>
<a name="ln1902"> </a>
<a name="ln1903">  struct zebra_vrf *zvrf = vrf_info_lookup (ifp-&gt;vrf_id);</a>
<a name="ln1904"> </a>
<a name="ln1905">  p = ifc-&gt;address;</a>
<a name="ln1906">  memset (&amp;req, 0, sizeof req - NL_PKT_BUF_SIZE);</a>
<a name="ln1907"> </a>
<a name="ln1908">  bytelen = (family == AF_INET ? 4 : 16);</a>
<a name="ln1909"> </a>
<a name="ln1910">  req.n.nlmsg_len = NLMSG_LENGTH (sizeof (struct ifaddrmsg));</a>
<a name="ln1911">  req.n.nlmsg_flags = NLM_F_REQUEST;</a>
<a name="ln1912">  req.n.nlmsg_type = cmd;</a>
<a name="ln1913">  req.ifa.ifa_family = family;</a>
<a name="ln1914"> </a>
<a name="ln1915">  req.ifa.ifa_index = ifp-&gt;ifindex;</a>
<a name="ln1916">  req.ifa.ifa_prefixlen = p-&gt;prefixlen;</a>
<a name="ln1917"> </a>
<a name="ln1918">  addattr_l (&amp;req.n, sizeof req, IFA_LOCAL, &amp;p-&gt;u.prefix, bytelen);</a>
<a name="ln1919"> </a>
<a name="ln1920">  if (family == AF_INET &amp;&amp; cmd == RTM_NEWADDR)</a>
<a name="ln1921">    {</a>
<a name="ln1922">      if (!CONNECTED_PEER(ifc) &amp;&amp; ifc-&gt;destination)</a>
<a name="ln1923">        {</a>
<a name="ln1924">          p = ifc-&gt;destination;</a>
<a name="ln1925">          addattr_l (&amp;req.n, sizeof req, IFA_BROADCAST, &amp;p-&gt;u.prefix,</a>
<a name="ln1926">                     bytelen);</a>
<a name="ln1927">        }</a>
<a name="ln1928">    }</a>
<a name="ln1929"> </a>
<a name="ln1930">  if (CHECK_FLAG (ifc-&gt;flags, ZEBRA_IFA_SECONDARY))</a>
<a name="ln1931">    SET_FLAG (req.ifa.ifa_flags, IFA_F_SECONDARY);</a>
<a name="ln1932"> </a>
<a name="ln1933">  if (ifc-&gt;label)</a>
<a name="ln1934">    addattr_l (&amp;req.n, sizeof req, IFA_LABEL, ifc-&gt;label,</a>
<a name="ln1935">               strlen (ifc-&gt;label) + 1);</a>
<a name="ln1936"> </a>
<a name="ln1937">  return netlink_talk (&amp;req.n, &amp;zvrf-&gt;netlink_cmd, zvrf);</a>
<a name="ln1938">}</a>
<a name="ln1939"> </a>
<a name="ln1940">int</a>
<a name="ln1941">kernel_address_add_ipv4 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln1942">{</a>
<a name="ln1943">  return netlink_address (RTM_NEWADDR, AF_INET, ifp, ifc);</a>
<a name="ln1944">}</a>
<a name="ln1945"> </a>
<a name="ln1946">int</a>
<a name="ln1947">kernel_address_delete_ipv4 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln1948">{</a>
<a name="ln1949">  return netlink_address (RTM_DELADDR, AF_INET, ifp, ifc);</a>
<a name="ln1950">}</a>
<a name="ln1951"> </a>
<a name="ln1952"> </a>
<a name="ln1953">extern struct thread_master *master;</a>
<a name="ln1954"> </a>
<a name="ln1955">/* Kernel route reflection. */</a>
<a name="ln1956">static int</a>
<a name="ln1957">kernel_read (struct thread *thread)</a>
<a name="ln1958">{</a>
<a name="ln1959">  struct zebra_vrf *zvrf = (struct zebra_vrf *)THREAD_ARG (thread);</a>
<a name="ln1960">  netlink_parse_info (netlink_information_fetch, &amp;zvrf-&gt;netlink, zvrf);</a>
<a name="ln1961">  zvrf-&gt;t_netlink = thread_add_read (zebrad.master, kernel_read, zvrf,</a>
<a name="ln1962">                                     zvrf-&gt;netlink.sock);</a>
<a name="ln1963"> </a>
<a name="ln1964">  return 0;</a>
<a name="ln1965">}</a>
<a name="ln1966"> </a>
<a name="ln1967">/* Filter out messages from self that occur on listener socket,</a>
<a name="ln1968">   caused by our actions on the command socket</a>
<a name="ln1969"> */</a>
<a name="ln1970">static void netlink_install_filter (int sock, __u32 pid)</a>
<a name="ln1971">{</a>
<a name="ln1972">  struct sock_filter filter[] = {</a>
<a name="ln1973">    /* 0: ldh [4]	          */</a>
<a name="ln1974">    BPF_STMT(BPF_LD|BPF_ABS|BPF_H, offsetof(struct nlmsghdr, nlmsg_type)),</a>
<a name="ln1975">    /* 1: jeq 0x18 jt 3 jf 6  */</a>
<a name="ln1976">    BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, htons(RTM_NEWROUTE), 1, 0),</a>
<a name="ln1977">    /* 2: jeq 0x19 jt 3 jf 6  */</a>
<a name="ln1978">    BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, htons(RTM_DELROUTE), 0, 3),</a>
<a name="ln1979">    /* 3: ldw [12]		  */</a>
<a name="ln1980">    BPF_STMT(BPF_LD|BPF_ABS|BPF_W, offsetof(struct nlmsghdr, nlmsg_pid)),</a>
<a name="ln1981">    /* 4: jeq XX  jt 5 jf 6   */</a>
<a name="ln1982">    BPF_JUMP(BPF_JMP|BPF_JEQ|BPF_K, htonl(pid), 0, 1),</a>
<a name="ln1983">    /* 5: ret 0    (skip)     */</a>
<a name="ln1984">    BPF_STMT(BPF_RET|BPF_K, 0),</a>
<a name="ln1985">    /* 6: ret 0xffff (keep)   */</a>
<a name="ln1986">    BPF_STMT(BPF_RET|BPF_K, 0xffff),</a>
<a name="ln1987">  };</a>
<a name="ln1988"> </a>
<a name="ln1989">  struct sock_fprog prog = {</a>
<a name="ln1990">    .len = array_size(filter),</a>
<a name="ln1991">    .filter = filter,</a>
<a name="ln1992">  };</a>
<a name="ln1993"> </a>
<a name="ln1994">  if (setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, &amp;prog, sizeof(prog)) &lt; 0)</a>
<a name="ln1995">    zlog_warn (&quot;Can't install socket filter: %s\n&quot;, safe_strerror(errno));</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998">/* Exported interface function.  This function simply calls</a>
<a name="ln1999">   netlink_socket (). */</a>
<a name="ln2000">void</a>
<a name="ln2001">kernel_init (struct zebra_vrf *zvrf)</a>
<a name="ln2002">{</a>
<a name="ln2003">  unsigned long groups;</a>
<a name="ln2004"> </a>
<a name="ln2005">  groups = RTMGRP_LINK | RTMGRP_IPV4_ROUTE | RTMGRP_IPV4_IFADDR;</a>
<a name="ln2006">#ifdef HAVE_IPV6</a>
<a name="ln2007">  groups |= RTMGRP_IPV6_ROUTE | RTMGRP_IPV6_IFADDR;</a>
<a name="ln2008">#endif /* HAVE_IPV6 */</a>
<a name="ln2009">  netlink_socket (&amp;zvrf-&gt;netlink, groups, zvrf-&gt;vrf_id);</a>
<a name="ln2010">  netlink_socket (&amp;zvrf-&gt;netlink_cmd, 0, zvrf-&gt;vrf_id);</a>
<a name="ln2011"> </a>
<a name="ln2012">  /* Register kernel socket. */</a>
<a name="ln2013">  if (zvrf-&gt;netlink.sock &gt; 0)</a>
<a name="ln2014">    {</a>
<a name="ln2015">      size_t bufsize = MAX(nl_rcvbufsize, 2 * sysconf(_SC_PAGESIZE));</a>
<a name="ln2016">      </a>
<a name="ln2017">      /* Only want non-blocking on the netlink event socket */</a>
<a name="ln2018">      if (fcntl (zvrf-&gt;netlink.sock, F_SETFL, O_NONBLOCK) &lt; 0)</a>
<a name="ln2019">        zlog_err (&quot;Can't set %s socket flags: %s&quot;, zvrf-&gt;netlink.name,</a>
<a name="ln2020">                  safe_strerror (errno));</a>
<a name="ln2021"> </a>
<a name="ln2022">      /* Set receive buffer size if it's set from command line */</a>
<a name="ln2023">      if (nl_rcvbufsize)</a>
<a name="ln2024">        netlink_recvbuf (&amp;zvrf-&gt;netlink, nl_rcvbufsize);</a>
<a name="ln2025">      </a>
<a name="ln2026">      nl_rcvbuf.p = XMALLOC (MTYPE_NETLINK_RCVBUF, bufsize);</a>
<a name="ln2027">      nl_rcvbuf.size = bufsize;</a>
<a name="ln2028">      </a>
<a name="ln2029">      netlink_install_filter (zvrf-&gt;netlink.sock, zvrf-&gt;netlink_cmd.snl.nl_pid);</a>
<a name="ln2030">      zvrf-&gt;t_netlink = thread_add_read (zebrad.master, kernel_read, zvrf,</a>
<a name="ln2031">                                         zvrf-&gt;netlink.sock);</a>
<a name="ln2032">    }</a>
<a name="ln2033">}</a>
<a name="ln2034"> </a>
<a name="ln2035">void</a>
<a name="ln2036">kernel_terminate (struct zebra_vrf *zvrf)</a>
<a name="ln2037">{</a>
<a name="ln2038">  THREAD_READ_OFF (zvrf-&gt;t_netlink);</a>
<a name="ln2039"> </a>
<a name="ln2040">  if (zvrf-&gt;netlink.sock &gt;= 0)</a>
<a name="ln2041">    {</a>
<a name="ln2042">      close (zvrf-&gt;netlink.sock);</a>
<a name="ln2043">      zvrf-&gt;netlink.sock = -1;</a>
<a name="ln2044">    }</a>
<a name="ln2045"> </a>
<a name="ln2046">  if (zvrf-&gt;netlink_cmd.sock &gt;= 0)</a>
<a name="ln2047">    {</a>
<a name="ln2048">      close (zvrf-&gt;netlink_cmd.sock);</a>
<a name="ln2049">      zvrf-&gt;netlink_cmd.sock = -1;</a>
<a name="ln2050">    }</a>
<a name="ln2051">}</a>
<a name="ln2052"> </a>
<a name="ln2053">/*</a>
<a name="ln2054"> * nl_msg_type_to_str</a>
<a name="ln2055"> */</a>
<a name="ln2056">const char *</a>
<a name="ln2057">nl_msg_type_to_str (uint16_t msg_type)</a>
<a name="ln2058">{</a>
<a name="ln2059">  return lookup (nlmsg_str, msg_type);</a>
<a name="ln2060">}</a>
<a name="ln2061"> </a>
<a name="ln2062">/*</a>
<a name="ln2063"> * nl_rtproto_to_str</a>
<a name="ln2064"> */</a>
<a name="ln2065">const char *</a>
<a name="ln2066">nl_rtproto_to_str (u_char rtproto)</a>
<a name="ln2067">{</a>
<a name="ln2068">  return lookup (rtproto_str, rtproto);</a>
<a name="ln2069">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="469"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1048/" target="_blank">V1048</a> The 'ifp->hw_addr_len' variable was assigned the same value.</p></div>
<div class="balloon" rel="671"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1004/" target="_blank">V1004</a> The '((char *)(tb[IFA_LOCAL]))' pointer was used unsafely after it was verified against nullptr. Check lines: 667, 671.</p></div>
<div class="balloon" rel="695"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: ifp.</p></div>
<div class="balloon" rel="1263"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1263, 1266</p></div>
<div class="balloon" rel="1257"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1257, 1260</p></div>
<div class="balloon" rel="1251"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1251, 1254</p></div>
<div class="balloon" rel="1695"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer '& req'.</p></div>
<div class="balloon" rel="1906"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to underflow of the buffer '& req'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
