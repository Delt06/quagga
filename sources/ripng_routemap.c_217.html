
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ripng_routemap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* RIPng routemap.</a>
<a name="ln2"> * Copyright (C) 1999 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;if.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;routemap.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29">#include &quot;sockunion.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;ripngd/ripngd.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">struct rip_metric_modifier</a>
<a name="ln34">{</a>
<a name="ln35">  enum </a>
<a name="ln36">  {</a>
<a name="ln37">    metric_increment,</a>
<a name="ln38">    metric_decrement,</a>
<a name="ln39">    metric_absolute</a>
<a name="ln40">  } type;</a>
<a name="ln41"> </a>
<a name="ln42">  u_char metric;</a>
<a name="ln43">};</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">static int</a>
<a name="ln47">ripng_route_match_add (struct vty *vty, struct route_map_index *index,</a>
<a name="ln48">		       const char *command, const char *arg)</a>
<a name="ln49">{</a>
<a name="ln50">  int ret;</a>
<a name="ln51"> </a>
<a name="ln52">  ret = route_map_add_match (index, command, arg);</a>
<a name="ln53">  if (ret)</a>
<a name="ln54">    {</a>
<a name="ln55">      switch (ret)</a>
<a name="ln56">	{</a>
<a name="ln57">	case RMAP_RULE_MISSING:</a>
<a name="ln58">	  vty_out (vty, &quot;RIPng Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln59">	  return CMD_WARNING;</a>
<a name="ln60">	case RMAP_COMPILE_ERROR:</a>
<a name="ln61">	  vty_out (vty, &quot;RIPng Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln62">	  return CMD_WARNING;</a>
<a name="ln63">	}</a>
<a name="ln64">    }</a>
<a name="ln65">  return CMD_SUCCESS;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">static int</a>
<a name="ln69">ripng_route_match_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln70">			  const char *command, const char *arg)</a>
<a name="ln71">{</a>
<a name="ln72">  int ret;</a>
<a name="ln73"> </a>
<a name="ln74">  ret = route_map_delete_match (index, command, arg);</a>
<a name="ln75">  if (ret)</a>
<a name="ln76">    {</a>
<a name="ln77">      switch (ret)</a>
<a name="ln78">	{</a>
<a name="ln79">	case RMAP_RULE_MISSING:</a>
<a name="ln80">	  vty_out (vty, &quot;RIPng Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln81">	  return CMD_WARNING;</a>
<a name="ln82">	case RMAP_COMPILE_ERROR:</a>
<a name="ln83">	  vty_out (vty, &quot;RIPng Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln84">	  return CMD_WARNING;</a>
<a name="ln85">	}</a>
<a name="ln86">    }</a>
<a name="ln87">  return CMD_SUCCESS;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">static int</a>
<a name="ln91">ripng_route_set_add (struct vty *vty, struct route_map_index *index,</a>
<a name="ln92">		     const char *command, const char *arg)</a>
<a name="ln93">{</a>
<a name="ln94">  int ret;</a>
<a name="ln95"> </a>
<a name="ln96">  ret = route_map_add_set (index, command, arg);</a>
<a name="ln97">  if (ret)</a>
<a name="ln98">    {</a>
<a name="ln99">      switch (ret)</a>
<a name="ln100">	{</a>
<a name="ln101">	case RMAP_RULE_MISSING:</a>
<a name="ln102">	  vty_out (vty, &quot;RIPng Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln103">	  return CMD_WARNING;</a>
<a name="ln104">	case RMAP_COMPILE_ERROR:</a>
<a name="ln105">	  vty_out (vty, &quot;RIPng Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln106">	  return CMD_WARNING;</a>
<a name="ln107">	}</a>
<a name="ln108">    }</a>
<a name="ln109">  return CMD_SUCCESS;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">static int</a>
<a name="ln113">ripng_route_set_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln114">			const char *command, const char *arg)</a>
<a name="ln115">{</a>
<a name="ln116">  int ret;</a>
<a name="ln117"> </a>
<a name="ln118">  ret = route_map_delete_set (index, command, arg);</a>
<a name="ln119">  if (ret)</a>
<a name="ln120">    {</a>
<a name="ln121">      switch (ret)</a>
<a name="ln122">	{</a>
<a name="ln123">	case RMAP_RULE_MISSING:</a>
<a name="ln124">	  vty_out (vty, &quot;RIPng Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln125">	  return CMD_WARNING;</a>
<a name="ln126">	case RMAP_COMPILE_ERROR:</a>
<a name="ln127">	  vty_out (vty, &quot;RIPng Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln128">	  return CMD_WARNING;</a>
<a name="ln129">	}</a>
<a name="ln130">    }</a>
<a name="ln131">  return CMD_SUCCESS;</a>
<a name="ln132">}</a>
<a name="ln133"> </a>
<a name="ln134">/* `match metric METRIC' */</a>
<a name="ln135">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln136">static route_map_result_t</a>
<a name="ln137">route_match_metric (void *rule, struct prefix *prefix, </a>
<a name="ln138">		    route_map_object_t type, void *object)</a>
<a name="ln139">{</a>
<a name="ln140">  u_int32_t *metric;</a>
<a name="ln141">  struct ripng_info *rinfo;</a>
<a name="ln142"> </a>
<a name="ln143">  if (type == RMAP_RIPNG)</a>
<a name="ln144">    {</a>
<a name="ln145">      metric = rule;</a>
<a name="ln146">      rinfo = object;</a>
<a name="ln147">    </a>
<a name="ln148">      if (rinfo-&gt;metric == *metric)</a>
<a name="ln149">	return RMAP_MATCH;</a>
<a name="ln150">      else</a>
<a name="ln151">	return RMAP_NOMATCH;</a>
<a name="ln152">    }</a>
<a name="ln153">  return RMAP_NOMATCH;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">/* Route map `match metric' match statement. `arg' is METRIC value */</a>
<a name="ln157">static void *</a>
<a name="ln158">route_match_metric_compile (const char *arg)</a>
<a name="ln159">{</a>
<a name="ln160">  u_int32_t *metric;</a>
<a name="ln161"> </a>
<a name="ln162">  metric = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_int32_t));</a>
<a name="ln163">  *metric = atoi (arg);</a>
<a name="ln164"> </a>
<a name="ln165">  if(*metric &gt; 0)</a>
<a name="ln166">    return metric;</a>
<a name="ln167"> </a>
<a name="ln168">  XFREE (MTYPE_ROUTE_MAP_COMPILED, metric);</a>
<a name="ln169">  return NULL;</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">/* Free route map's compiled `match metric' value. */</a>
<a name="ln173">static void</a>
<a name="ln174">route_match_metric_free (void *rule)</a>
<a name="ln175">{</a>
<a name="ln176">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln177">}</a>
<a name="ln178"> </a>
<a name="ln179">/* Route map commands for metric matching. */</a>
<a name="ln180">static struct route_map_rule_cmd route_match_metric_cmd =</a>
<a name="ln181">{</a>
<a name="ln182">  &quot;metric&quot;,</a>
<a name="ln183">  route_match_metric,</a>
<a name="ln184">  route_match_metric_compile,</a>
<a name="ln185">  route_match_metric_free</a>
<a name="ln186">};</a>
<a name="ln187"> </a>
<a name="ln188">/* `match interface IFNAME' */</a>
<a name="ln189">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln190">static route_map_result_t</a>
<a name="ln191">route_match_interface (void *rule, struct prefix *prefix,</a>
<a name="ln192">		       route_map_object_t type, void *object)</a>
<a name="ln193">{</a>
<a name="ln194">  struct ripng_info *rinfo;</a>
<a name="ln195">  struct interface *ifp;</a>
<a name="ln196">  char *ifname;</a>
<a name="ln197"> </a>
<a name="ln198">  if (type == RMAP_RIPNG)</a>
<a name="ln199">    {</a>
<a name="ln200">      ifname = rule;</a>
<a name="ln201">      ifp = if_lookup_by_name(ifname);</a>
<a name="ln202"> </a>
<a name="ln203">      if (!ifp)</a>
<a name="ln204">	return RMAP_NOMATCH;</a>
<a name="ln205"> </a>
<a name="ln206">      rinfo = object;</a>
<a name="ln207"> </a>
<a name="ln208">      if (rinfo-&gt;ifindex == ifp-&gt;ifindex)</a>
<a name="ln209">	return RMAP_MATCH;</a>
<a name="ln210">      else</a>
<a name="ln211">	return RMAP_NOMATCH;</a>
<a name="ln212">    }</a>
<a name="ln213">  return RMAP_NOMATCH;</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">/* Route map `match interface' match statement. `arg' is IFNAME value */</a>
<a name="ln217">static void *</a>
<a name="ln218">route_match_interface_compile (const char *arg)</a>
<a name="ln219">{</a>
<a name="ln220">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">static void</a>
<a name="ln224">route_match_interface_free (void *rule)</a>
<a name="ln225">{</a>
<a name="ln226">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">static struct route_map_rule_cmd route_match_interface_cmd =</a>
<a name="ln230">{</a>
<a name="ln231">  &quot;interface&quot;,</a>
<a name="ln232">  route_match_interface,</a>
<a name="ln233">  route_match_interface_compile,</a>
<a name="ln234">  route_match_interface_free</a>
<a name="ln235">};</a>
<a name="ln236"> </a>
<a name="ln237">/* `match tag TAG' */</a>
<a name="ln238">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln239">static route_map_result_t</a>
<a name="ln240">route_match_tag (void *rule, struct prefix *prefix, </a>
<a name="ln241">		    route_map_object_t type, void *object)</a>
<a name="ln242">{</a>
<a name="ln243">  route_tag_t *tag;</a>
<a name="ln244">  struct ripng_info *rinfo;</a>
<a name="ln245"> </a>
<a name="ln246">  if (type == RMAP_RIPNG)</a>
<a name="ln247">    {</a>
<a name="ln248">      tag = rule;</a>
<a name="ln249">      rinfo = object;</a>
<a name="ln250"> </a>
<a name="ln251">      /* The information stored by rinfo is host ordered. */</a>
<a name="ln252">      if (rinfo-&gt;tag == *tag)</a>
<a name="ln253">	return RMAP_MATCH;</a>
<a name="ln254">      else</a>
<a name="ln255">	return RMAP_NOMATCH;</a>
<a name="ln256">    }</a>
<a name="ln257">  return RMAP_NOMATCH;</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">static struct route_map_rule_cmd route_match_tag_cmd =</a>
<a name="ln261">{</a>
<a name="ln262">  &quot;tag&quot;,</a>
<a name="ln263">  route_match_tag,</a>
<a name="ln264">  route_map_rule_tag_compile,</a>
<a name="ln265">  route_map_rule_tag_free,</a>
<a name="ln266">};</a>
<a name="ln267"> </a>
<a name="ln268">/* `set metric METRIC' */</a>
<a name="ln269"> </a>
<a name="ln270">/* Set metric to attribute. */</a>
<a name="ln271">static route_map_result_t</a>
<a name="ln272">route_set_metric (void *rule, struct prefix *prefix, </a>
<a name="ln273">		  route_map_object_t type, void *object)</a>
<a name="ln274">{</a>
<a name="ln275">  if (type == RMAP_RIPNG)</a>
<a name="ln276">    {</a>
<a name="ln277">      struct rip_metric_modifier *mod;</a>
<a name="ln278">      struct ripng_info *rinfo;</a>
<a name="ln279"> </a>
<a name="ln280">      mod = rule;</a>
<a name="ln281">      rinfo = object;</a>
<a name="ln282"> </a>
<a name="ln283">      if (mod-&gt;type == metric_increment)</a>
<a name="ln284">	rinfo-&gt;metric_out += mod-&gt;metric;</a>
<a name="ln285">      else if (mod-&gt;type == metric_decrement)</a>
<a name="ln286">	rinfo-&gt;metric_out-= mod-&gt;metric;</a>
<a name="ln287">      else if (mod-&gt;type == metric_absolute)</a>
<a name="ln288">	rinfo-&gt;metric_out = mod-&gt;metric;</a>
<a name="ln289"> </a>
<a name="ln290">      if (rinfo-&gt;metric_out &lt; 1)</a>
<a name="ln291">	rinfo-&gt;metric_out = 1;</a>
<a name="ln292">      if (rinfo-&gt;metric_out &gt; RIPNG_METRIC_INFINITY)</a>
<a name="ln293">	rinfo-&gt;metric_out = RIPNG_METRIC_INFINITY;</a>
<a name="ln294"> </a>
<a name="ln295">      rinfo-&gt;metric_set = 1;</a>
<a name="ln296">    }</a>
<a name="ln297">  return RMAP_OKAY;</a>
<a name="ln298">}</a>
<a name="ln299"> </a>
<a name="ln300">/* set metric compilation. */</a>
<a name="ln301">static void *</a>
<a name="ln302">route_set_metric_compile (const char *arg)</a>
<a name="ln303">{</a>
<a name="ln304">  int len;</a>
<a name="ln305">  const char *pnt;</a>
<a name="ln306">  int type;</a>
<a name="ln307">  long metric;</a>
<a name="ln308">  char *endptr = NULL;</a>
<a name="ln309">  struct rip_metric_modifier *mod;</a>
<a name="ln310"> </a>
<a name="ln311">  len = strlen (arg);</a>
<a name="ln312">  pnt = arg;</a>
<a name="ln313"> </a>
<a name="ln314">  if (len == 0)</a>
<a name="ln315">    return NULL;</a>
<a name="ln316"> </a>
<a name="ln317">  /* Examine first character. */</a>
<a name="ln318">  if (arg[0] == '+')</a>
<a name="ln319">    {</a>
<a name="ln320">      type = metric_increment;</a>
<a name="ln321">      pnt++;</a>
<a name="ln322">    }</a>
<a name="ln323">  else if (arg[0] == '-')</a>
<a name="ln324">    {</a>
<a name="ln325">      type = metric_decrement;</a>
<a name="ln326">      pnt++;</a>
<a name="ln327">    }</a>
<a name="ln328">  else</a>
<a name="ln329">    type = metric_absolute;</a>
<a name="ln330"> </a>
<a name="ln331">  /* Check beginning with digit string. */</a>
<a name="ln332">  if (*pnt &lt; '0' || *pnt &gt; '9')</a>
<a name="ln333">    return NULL;</a>
<a name="ln334"> </a>
<a name="ln335">  /* Convert string to integer. */</a>
<a name="ln336">  metric = strtol (pnt, &amp;endptr, 10);</a>
<a name="ln337"> </a>
<a name="ln338">  if (metric == LONG_MAX || *endptr != '\0')</a>
<a name="ln339">    return NULL;</a>
<a name="ln340">  /* Commented out by Hasso Tepper, to avoid problems in vtysh. */</a>
<a name="ln341">  /* if (metric &lt; 0 || metric &gt; RIPNG_METRIC_INFINITY) */</a>
<a name="ln342">  if (metric &lt; 0)</a>
<a name="ln343">    return NULL;</a>
<a name="ln344"> </a>
<a name="ln345">  mod = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, </a>
<a name="ln346">		 sizeof (struct rip_metric_modifier));</a>
<a name="ln347">  mod-&gt;type = type;</a>
<a name="ln348">  mod-&gt;metric = metric;</a>
<a name="ln349"> </a>
<a name="ln350">  return mod;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">/* Free route map's compiled `set metric' value. */</a>
<a name="ln354">static void</a>
<a name="ln355">route_set_metric_free (void *rule)</a>
<a name="ln356">{</a>
<a name="ln357">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">static struct route_map_rule_cmd route_set_metric_cmd = </a>
<a name="ln361">{</a>
<a name="ln362">  &quot;metric&quot;,</a>
<a name="ln363">  route_set_metric,</a>
<a name="ln364">  route_set_metric_compile,</a>
<a name="ln365">  route_set_metric_free,</a>
<a name="ln366">};</a>
<a name="ln367"> </a>
<a name="ln368">/* `set ipv6 next-hop local IP_ADDRESS' */</a>
<a name="ln369"> </a>
<a name="ln370">/* Set nexthop to object.  ojbect must be pointer to struct attr. */</a>
<a name="ln371">static route_map_result_t</a>
<a name="ln372">route_set_ipv6_nexthop_local (void *rule, struct prefix *prefix, </a>
<a name="ln373">		      route_map_object_t type, void *object)</a>
<a name="ln374">{</a>
<a name="ln375">  struct in6_addr *address;</a>
<a name="ln376">  struct ripng_info *rinfo;</a>
<a name="ln377"> </a>
<a name="ln378">  if(type == RMAP_RIPNG)</a>
<a name="ln379">    {</a>
<a name="ln380">      /* Fetch routemap's rule information. */</a>
<a name="ln381">      address = rule;</a>
<a name="ln382">      rinfo = object;</a>
<a name="ln383">    </a>
<a name="ln384">      /* Set next hop value. */ </a>
<a name="ln385">      rinfo-&gt;nexthop_out = *address;</a>
<a name="ln386">    }</a>
<a name="ln387"> </a>
<a name="ln388">  return RMAP_OKAY;</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">/* Route map `ipv6 nexthop local' compile function.  Given string is converted</a>
<a name="ln392">   to struct in6_addr structure. */</a>
<a name="ln393">static void *</a>
<a name="ln394">route_set_ipv6_nexthop_local_compile (const char *arg)</a>
<a name="ln395">{</a>
<a name="ln396">  int ret;</a>
<a name="ln397">  struct in6_addr *address;</a>
<a name="ln398"> </a>
<a name="ln399">  address = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in6_addr));</a>
<a name="ln400"> </a>
<a name="ln401">  ret = inet_pton (AF_INET6, arg, address);</a>
<a name="ln402"> </a>
<a name="ln403">  if (ret == 0)</a>
<a name="ln404">    {</a>
<a name="ln405">      XFREE (MTYPE_ROUTE_MAP_COMPILED, address);</a>
<a name="ln406">      return NULL;</a>
<a name="ln407">    }</a>
<a name="ln408"> </a>
<a name="ln409">  return address;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">/* Free route map's compiled `ipv6 nexthop local' value. */</a>
<a name="ln413">static void</a>
<a name="ln414">route_set_ipv6_nexthop_local_free (void *rule)</a>
<a name="ln415">{</a>
<a name="ln416">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">/* Route map commands for ipv6 nexthop local set. */</a>
<a name="ln420">static struct route_map_rule_cmd route_set_ipv6_nexthop_local_cmd =</a>
<a name="ln421">{</a>
<a name="ln422">  &quot;ipv6 next-hop local&quot;,</a>
<a name="ln423">  route_set_ipv6_nexthop_local,</a>
<a name="ln424">  route_set_ipv6_nexthop_local_compile,</a>
<a name="ln425">  route_set_ipv6_nexthop_local_free</a>
<a name="ln426">};</a>
<a name="ln427"> </a>
<a name="ln428">/* `set tag TAG' */</a>
<a name="ln429"> </a>
<a name="ln430">/* Set tag to object.  ojbect must be pointer to struct attr. */</a>
<a name="ln431">static route_map_result_t</a>
<a name="ln432">route_set_tag (void *rule, struct prefix *prefix, </a>
<a name="ln433">		      route_map_object_t type, void *object)</a>
<a name="ln434">{</a>
<a name="ln435">  route_tag_t *tag;</a>
<a name="ln436">  struct ripng_info *rinfo;</a>
<a name="ln437"> </a>
<a name="ln438">  if(type == RMAP_RIPNG)</a>
<a name="ln439">    {</a>
<a name="ln440">      /* Fetch routemap's rule information. */</a>
<a name="ln441">      tag = rule;</a>
<a name="ln442">      rinfo = object;</a>
<a name="ln443"> </a>
<a name="ln444">      /* Set next hop value. */ </a>
<a name="ln445">      rinfo-&gt;tag_out = *tag;</a>
<a name="ln446">    }</a>
<a name="ln447"> </a>
<a name="ln448">  return RMAP_OKAY;</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">/* Route map commands for tag set. */</a>
<a name="ln452">static struct route_map_rule_cmd route_set_tag_cmd =</a>
<a name="ln453">{</a>
<a name="ln454">  &quot;tag&quot;,</a>
<a name="ln455">  route_set_tag,</a>
<a name="ln456">  route_map_rule_tag_compile,</a>
<a name="ln457">  route_map_rule_tag_free</a>
<a name="ln458">};</a>
<a name="ln459"> </a>
<a name="ln460">#define MATCH_STR &quot;Match values from routing table\n&quot;</a>
<a name="ln461">#define SET_STR &quot;Set values in destination routing protocol\n&quot;</a>
<a name="ln462"> </a>
<a name="ln463">DEFUN (match_metric, </a>
<a name="ln464">       match_metric_cmd,</a>
<a name="ln465">       &quot;match metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln466">       MATCH_STR</a>
<a name="ln467">       &quot;Match metric of route\n&quot;</a>
<a name="ln468">       &quot;Metric value\n&quot;)</a>
<a name="ln469">{</a>
<a name="ln470">  return ripng_route_match_add (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln471">}</a>
<a name="ln472"> </a>
<a name="ln473">DEFUN (no_match_metric,</a>
<a name="ln474">       no_match_metric_cmd,</a>
<a name="ln475">       &quot;no match metric&quot;,</a>
<a name="ln476">       NO_STR</a>
<a name="ln477">       MATCH_STR</a>
<a name="ln478">       &quot;Match metric of route\n&quot;)</a>
<a name="ln479">{</a>
<a name="ln480">  if (argc == 0)</a>
<a name="ln481">    return ripng_route_match_delete (vty, vty-&gt;index, &quot;metric&quot;, NULL);</a>
<a name="ln482"> </a>
<a name="ln483">  return ripng_route_match_delete (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">ALIAS (no_match_metric,</a>
<a name="ln487">       no_match_metric_val_cmd,</a>
<a name="ln488">       &quot;no match metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln489">       NO_STR</a>
<a name="ln490">       MATCH_STR</a>
<a name="ln491">       &quot;Match metric of route\n&quot;</a>
<a name="ln492">       &quot;Metric value\n&quot;)</a>
<a name="ln493"> </a>
<a name="ln494">DEFUN (match_interface,</a>
<a name="ln495">       match_interface_cmd,</a>
<a name="ln496">       &quot;match interface WORD&quot;,</a>
<a name="ln497">       MATCH_STR</a>
<a name="ln498">       &quot;Match first hop interface of route\n&quot;</a>
<a name="ln499">       &quot;Interface name\n&quot;)</a>
<a name="ln500">{</a>
<a name="ln501">  return ripng_route_match_add (vty, vty-&gt;index, &quot;interface&quot;, argv[0]);</a>
<a name="ln502">}</a>
<a name="ln503"> </a>
<a name="ln504">DEFUN (no_match_interface,</a>
<a name="ln505">       no_match_interface_cmd,</a>
<a name="ln506">       &quot;no match interface&quot;,</a>
<a name="ln507">       NO_STR</a>
<a name="ln508">       MATCH_STR</a>
<a name="ln509">       &quot;Match first hop interface of route\n&quot;)</a>
<a name="ln510">{</a>
<a name="ln511">  if (argc == 0)</a>
<a name="ln512">    return ripng_route_match_delete (vty, vty-&gt;index, &quot;interface&quot;, NULL);</a>
<a name="ln513"> </a>
<a name="ln514">  return ripng_route_match_delete (vty, vty-&gt;index, &quot;interface&quot;, argv[0]);</a>
<a name="ln515">}</a>
<a name="ln516"> </a>
<a name="ln517">ALIAS (no_match_interface,</a>
<a name="ln518">       no_match_interface_val_cmd,</a>
<a name="ln519">       &quot;no match interface WORD&quot;,</a>
<a name="ln520">       NO_STR</a>
<a name="ln521">       MATCH_STR</a>
<a name="ln522">       &quot;Match first hop interface of route\n&quot;</a>
<a name="ln523">       &quot;Interface name\n&quot;)</a>
<a name="ln524"> </a>
<a name="ln525">DEFUN (match_tag,</a>
<a name="ln526">       match_tag_cmd,</a>
<a name="ln527">       &quot;match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln528">       MATCH_STR</a>
<a name="ln529">       &quot;Match tag of route\n&quot;</a>
<a name="ln530">       &quot;Metric value\n&quot;)</a>
<a name="ln531">{</a>
<a name="ln532">  return ripng_route_match_add (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln533">}</a>
<a name="ln534"> </a>
<a name="ln535">DEFUN (no_match_tag,</a>
<a name="ln536">       no_match_tag_cmd,</a>
<a name="ln537">       &quot;no match tag&quot;,</a>
<a name="ln538">       NO_STR</a>
<a name="ln539">       MATCH_STR</a>
<a name="ln540">       &quot;Match tag of route\n&quot;)</a>
<a name="ln541">{</a>
<a name="ln542">  if (argc == 0)</a>
<a name="ln543">    return ripng_route_match_delete (vty, vty-&gt;index, &quot;tag&quot;, NULL);</a>
<a name="ln544"> </a>
<a name="ln545">  return ripng_route_match_delete (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">ALIAS (no_match_tag,</a>
<a name="ln549">       no_match_tag_val_cmd,</a>
<a name="ln550">       &quot;no match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln551">       NO_STR</a>
<a name="ln552">       MATCH_STR</a>
<a name="ln553">       &quot;Match tag of route\n&quot;</a>
<a name="ln554">       &quot;Metric value\n&quot;)</a>
<a name="ln555"> </a>
<a name="ln556">/* set functions */</a>
<a name="ln557"> </a>
<a name="ln558">DEFUN (set_metric,</a>
<a name="ln559">       set_metric_cmd,</a>
<a name="ln560">       &quot;set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln561">       &quot;Set value\n&quot;</a>
<a name="ln562">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln563">       &quot;Metric value\n&quot;)</a>
<a name="ln564">{</a>
<a name="ln565">  return ripng_route_set_add (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln566">}</a>
<a name="ln567"> </a>
<a name="ln568">DEFUN (no_set_metric,</a>
<a name="ln569">       no_set_metric_cmd,</a>
<a name="ln570">       &quot;no set metric&quot;,</a>
<a name="ln571">       NO_STR</a>
<a name="ln572">       SET_STR</a>
<a name="ln573">       &quot;Metric value for destination routing protocol\n&quot;)</a>
<a name="ln574">{</a>
<a name="ln575">  if (argc == 0)</a>
<a name="ln576">    return ripng_route_set_delete (vty, vty-&gt;index, &quot;metric&quot;, NULL);</a>
<a name="ln577"> </a>
<a name="ln578">  return ripng_route_set_delete (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">ALIAS (no_set_metric,</a>
<a name="ln582">       no_set_metric_val_cmd,</a>
<a name="ln583">       &quot;no set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln584">       NO_STR</a>
<a name="ln585">       SET_STR</a>
<a name="ln586">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln587">       &quot;Metric value\n&quot;)</a>
<a name="ln588"> </a>
<a name="ln589">DEFUN (set_ipv6_nexthop_local,</a>
<a name="ln590">       set_ipv6_nexthop_local_cmd,</a>
<a name="ln591">       &quot;set ipv6 next-hop local X:X::X:X&quot;,</a>
<a name="ln592">       SET_STR</a>
<a name="ln593">       IPV6_STR</a>
<a name="ln594">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln595">       &quot;IPv6 local address\n&quot;</a>
<a name="ln596">       &quot;IPv6 address of next hop\n&quot;)</a>
<a name="ln597">{</a>
<a name="ln598">  union sockunion su;</a>
<a name="ln599">  int ret;</a>
<a name="ln600"> </a>
<a name="ln601">  ret = str2sockunion (argv[0], &amp;su);</a>
<a name="ln602">  if (ret &lt; 0)</a>
<a name="ln603">    {</a>
<a name="ln604">      vty_out (vty, &quot;%% Malformed next-hop local address%s&quot;, VTY_NEWLINE);</a>
<a name="ln605">      return CMD_WARNING;</a>
<a name="ln606">    }</a>
<a name="ln607"> </a>
<a name="ln608">  return ripng_route_set_add (vty, vty-&gt;index, &quot;ipv6 next-hop local&quot;, argv[0]);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">DEFUN (no_set_ipv6_nexthop_local,</a>
<a name="ln612">       no_set_ipv6_nexthop_local_cmd,</a>
<a name="ln613">       &quot;no set ipv6 next-hop local&quot;,</a>
<a name="ln614">       NO_STR</a>
<a name="ln615">       SET_STR</a>
<a name="ln616">       IPV6_STR</a>
<a name="ln617">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln618">       &quot;IPv6 local address\n&quot;)</a>
<a name="ln619">{</a>
<a name="ln620">  if (argc == 0)</a>
<a name="ln621">    return ripng_route_set_delete (vty, vty-&gt;index, &quot;ipv6 next-hop local&quot;, NULL);</a>
<a name="ln622"> </a>
<a name="ln623">  return ripng_route_set_delete (vty, vty-&gt;index, &quot;ipv6 next-hop local&quot;, argv[0]);</a>
<a name="ln624">}</a>
<a name="ln625"> </a>
<a name="ln626">ALIAS (no_set_ipv6_nexthop_local,</a>
<a name="ln627">       no_set_ipv6_nexthop_local_val_cmd,</a>
<a name="ln628">       &quot;no set ipv6 next-hop local X:X::X:X&quot;,</a>
<a name="ln629">       NO_STR</a>
<a name="ln630">       SET_STR</a>
<a name="ln631">       IPV6_STR</a>
<a name="ln632">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln633">       &quot;IPv6 local address\n&quot;</a>
<a name="ln634">       &quot;IPv6 address of next hop\n&quot;)</a>
<a name="ln635"> </a>
<a name="ln636">DEFUN (set_tag,</a>
<a name="ln637">       set_tag_cmd,</a>
<a name="ln638">       &quot;set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln639">       SET_STR</a>
<a name="ln640">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln641">       &quot;Tag value\n&quot;)</a>
<a name="ln642">{</a>
<a name="ln643">  return ripng_route_set_add (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">DEFUN (no_set_tag,</a>
<a name="ln647">       no_set_tag_cmd,</a>
<a name="ln648">       &quot;no set tag&quot;,</a>
<a name="ln649">       NO_STR</a>
<a name="ln650">       SET_STR</a>
<a name="ln651">       &quot;Tag value for routing protocol\n&quot;)</a>
<a name="ln652">{</a>
<a name="ln653">  if (argc == 0)</a>
<a name="ln654">    return ripng_route_set_delete (vty, vty-&gt;index, &quot;tag&quot;, NULL);</a>
<a name="ln655"> </a>
<a name="ln656">  return ripng_route_set_delete (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln657">}</a>
<a name="ln658"> </a>
<a name="ln659">ALIAS (no_set_tag,</a>
<a name="ln660">       no_set_tag_val_cmd,</a>
<a name="ln661">       &quot;no set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln662">       NO_STR</a>
<a name="ln663">       SET_STR</a>
<a name="ln664">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln665">       &quot;Tag value\n&quot;)</a>
<a name="ln666"> </a>
<a name="ln667">void</a>
<a name="ln668">ripng_route_map_reset ()</a>
<a name="ln669">{</a>
<a name="ln670">  /* XXX ??? */</a>
<a name="ln671">  ;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">void</a>
<a name="ln675">ripng_route_map_init ()</a>
<a name="ln676">{</a>
<a name="ln677">  route_map_init ();</a>
<a name="ln678">  route_map_init_vty ();</a>
<a name="ln679"> </a>
<a name="ln680">  route_map_install_match (&amp;route_match_metric_cmd);</a>
<a name="ln681">  route_map_install_match (&amp;route_match_interface_cmd);</a>
<a name="ln682">  route_map_install_match (&amp;route_match_tag_cmd);</a>
<a name="ln683"> </a>
<a name="ln684">  route_map_install_set (&amp;route_set_metric_cmd);</a>
<a name="ln685">  route_map_install_set (&amp;route_set_ipv6_nexthop_local_cmd);</a>
<a name="ln686">  route_map_install_set (&amp;route_set_tag_cmd);</a>
<a name="ln687"> </a>
<a name="ln688">  install_element (RMAP_NODE, &amp;match_metric_cmd);</a>
<a name="ln689">  install_element (RMAP_NODE, &amp;no_match_metric_cmd);</a>
<a name="ln690">  install_element (RMAP_NODE, &amp;no_match_metric_val_cmd);</a>
<a name="ln691">  install_element (RMAP_NODE, &amp;match_interface_cmd);</a>
<a name="ln692">  install_element (RMAP_NODE, &amp;no_match_interface_cmd);</a>
<a name="ln693">  install_element (RMAP_NODE, &amp;no_match_interface_val_cmd);</a>
<a name="ln694">  install_element (RMAP_NODE, &amp;match_tag_cmd);</a>
<a name="ln695">  install_element (RMAP_NODE, &amp;no_match_tag_cmd);</a>
<a name="ln696">  install_element (RMAP_NODE, &amp;no_match_tag_val_cmd);</a>
<a name="ln697"> </a>
<a name="ln698">  install_element (RMAP_NODE, &amp;set_metric_cmd);</a>
<a name="ln699">  install_element (RMAP_NODE, &amp;no_set_metric_cmd);</a>
<a name="ln700">  install_element (RMAP_NODE, &amp;no_set_metric_val_cmd);</a>
<a name="ln701">  install_element (RMAP_NODE, &amp;set_ipv6_nexthop_local_cmd);</a>
<a name="ln702">  install_element (RMAP_NODE, &amp;no_set_ipv6_nexthop_local_cmd);</a>
<a name="ln703">  install_element (RMAP_NODE, &amp;no_set_ipv6_nexthop_local_val_cmd);</a>
<a name="ln704">  install_element (RMAP_NODE, &amp;set_tag_cmd);</a>
<a name="ln705">  install_element (RMAP_NODE, &amp;no_set_tag_cmd);</a>
<a name="ln706">  install_element (RMAP_NODE, &amp;no_set_tag_val_cmd);</a>
<a name="ln707">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
