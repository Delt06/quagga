
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_ism.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF version 2  Interface State Machine</a>
<a name="ln3"> *   From RFC2328 [OSPF Version 2] </a>
<a name="ln4"> * Copyright (C) 1999, 2000 Toshiaki Takada</a>
<a name="ln5"> *</a>
<a name="ln6"> * This file is part of GNU Zebra.</a>
<a name="ln7"> *</a>
<a name="ln8"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln9"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln10"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln11"> * later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln14"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public License</a>
<a name="ln19"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln20"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln21"> * 02111-1307, USA.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;thread.h&quot;</a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;table.h&quot;</a>
<a name="ln31">#include &quot;log.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln34">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln35">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln36">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_network.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_abr.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_snmp.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">/* elect DR and BDR. Refer to RFC2319 section 9.4 */</a>
<a name="ln49">static struct ospf_neighbor *</a>
<a name="ln50">ospf_dr_election_sub (struct list *routers)</a>
<a name="ln51">{</a>
<a name="ln52">  struct listnode *node;</a>
<a name="ln53">  struct ospf_neighbor *nbr, *max = NULL;</a>
<a name="ln54"> </a>
<a name="ln55">  /* Choose highest router priority.</a>
<a name="ln56">     In case of tie, choose highest Router ID. */</a>
<a name="ln57">  for (ALL_LIST_ELEMENTS_RO (routers, node, nbr))</a>
<a name="ln58">    {</a>
<a name="ln59">      if (max == NULL)</a>
<a name="ln60">	max = nbr;</a>
<a name="ln61">      else</a>
<a name="ln62">	{</a>
<a name="ln63">	  if (max-&gt;priority &lt; nbr-&gt;priority)</a>
<a name="ln64">	    max = nbr;</a>
<a name="ln65">	  else if (max-&gt;priority == nbr-&gt;priority)</a>
<a name="ln66">	    if (IPV4_ADDR_CMP (&amp;max-&gt;router_id, &amp;nbr-&gt;router_id) &lt; 0)</a>
<a name="ln67">	      max = nbr;</a>
<a name="ln68">	}</a>
<a name="ln69">    }</a>
<a name="ln70"> </a>
<a name="ln71">  return max;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">static struct ospf_neighbor *</a>
<a name="ln75">ospf_elect_dr (struct ospf_interface *oi, struct list *el_list)</a>
<a name="ln76">{</a>
<a name="ln77">  struct list *dr_list;</a>
<a name="ln78">  struct listnode *node;</a>
<a name="ln79">  struct ospf_neighbor *nbr, *dr = NULL, *bdr = NULL;</a>
<a name="ln80"> </a>
<a name="ln81">  dr_list = list_new ();</a>
<a name="ln82"> </a>
<a name="ln83">  /* Add neighbors to the list. */</a>
<a name="ln84">  for (ALL_LIST_ELEMENTS_RO (el_list, node, nbr))</a>
<a name="ln85">    {</a>
<a name="ln86">      /* neighbor declared to be DR. */</a>
<a name="ln87">      if (NBR_IS_DR (nbr))</a>
<a name="ln88">	listnode_add (dr_list, nbr);</a>
<a name="ln89"> </a>
<a name="ln90">      /* Preserve neighbor BDR. */</a>
<a name="ln91">      if (IPV4_ADDR_SAME (&amp;BDR (oi), &amp;nbr-&gt;address.u.prefix4))</a>
<a name="ln92">	bdr = nbr;</a>
<a name="ln93">    }</a>
<a name="ln94"> </a>
<a name="ln95">  /* Elect Designated Router. */</a>
<a name="ln96">  if (listcount (dr_list) &gt; 0)</a>
<a name="ln97">    dr = ospf_dr_election_sub (dr_list);</a>
<a name="ln98">  else</a>
<a name="ln99">    dr = bdr;</a>
<a name="ln100"> </a>
<a name="ln101">  /* Set DR to interface. */</a>
<a name="ln102">  if (dr)</a>
<a name="ln103">    DR (oi) = dr-&gt;address.u.prefix4;</a>
<a name="ln104">  else</a>
<a name="ln105">    DR (oi).s_addr = 0;</a>
<a name="ln106"> </a>
<a name="ln107">  list_delete (dr_list);</a>
<a name="ln108"> </a>
<a name="ln109">  return dr;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">static struct ospf_neighbor *</a>
<a name="ln113">ospf_elect_bdr (struct ospf_interface *oi, struct list *el_list)</a>
<a name="ln114">{</a>
<a name="ln115">  struct list *bdr_list, *no_dr_list;</a>
<a name="ln116">  struct listnode *node;</a>
<a name="ln117">  struct ospf_neighbor *nbr, *bdr = NULL;</a>
<a name="ln118"> </a>
<a name="ln119">  bdr_list = list_new ();</a>
<a name="ln120">  no_dr_list = list_new ();</a>
<a name="ln121"> </a>
<a name="ln122">  /* Add neighbors to the list. */</a>
<a name="ln123">  for (ALL_LIST_ELEMENTS_RO (el_list, node, nbr))</a>
<a name="ln124">    {</a>
<a name="ln125">      /* neighbor declared to be DR. */</a>
<a name="ln126">      if (NBR_IS_DR (nbr))</a>
<a name="ln127">	continue;</a>
<a name="ln128"> </a>
<a name="ln129">      /* neighbor declared to be BDR. */</a>
<a name="ln130">      if (NBR_IS_BDR (nbr))</a>
<a name="ln131">	listnode_add (bdr_list, nbr);</a>
<a name="ln132"> </a>
<a name="ln133">      listnode_add (no_dr_list, nbr);</a>
<a name="ln134">    }</a>
<a name="ln135"> </a>
<a name="ln136">  /* Elect Backup Designated Router. */</a>
<a name="ln137">  if (listcount (bdr_list) &gt; 0)</a>
<a name="ln138">    bdr = ospf_dr_election_sub (bdr_list);</a>
<a name="ln139">  else</a>
<a name="ln140">    bdr = ospf_dr_election_sub (no_dr_list);</a>
<a name="ln141"> </a>
<a name="ln142">  /* Set BDR to interface. */</a>
<a name="ln143">  if (bdr)</a>
<a name="ln144">    BDR (oi) = bdr-&gt;address.u.prefix4;</a>
<a name="ln145">  else</a>
<a name="ln146">    BDR (oi).s_addr = 0;</a>
<a name="ln147"> </a>
<a name="ln148">  list_delete (bdr_list);</a>
<a name="ln149">  list_delete (no_dr_list);</a>
<a name="ln150"> </a>
<a name="ln151">  return bdr;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">static int</a>
<a name="ln155">ospf_ism_state (struct ospf_interface *oi)</a>
<a name="ln156">{</a>
<a name="ln157">  if (IPV4_ADDR_SAME (&amp;DR (oi), &amp;oi-&gt;address-&gt;u.prefix4))</a>
<a name="ln158">    return ISM_DR;</a>
<a name="ln159">  else if (IPV4_ADDR_SAME (&amp;BDR (oi), &amp;oi-&gt;address-&gt;u.prefix4))</a>
<a name="ln160">    return ISM_Backup;</a>
<a name="ln161">  else</a>
<a name="ln162">    return ISM_DROther;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">static void</a>
<a name="ln166">ospf_dr_eligible_routers (struct route_table *nbrs, struct list *el_list)</a>
<a name="ln167">{</a>
<a name="ln168">  struct route_node *rn;</a>
<a name="ln169">  struct ospf_neighbor *nbr;</a>
<a name="ln170"> </a>
<a name="ln171">  for (rn = route_top (nbrs); rn; rn = route_next (rn))</a>
<a name="ln172">    if ((nbr = rn-&gt;info) != NULL)</a>
<a name="ln173">      /* Ignore 0.0.0.0 node*/</a>
<a name="ln174">      if (nbr-&gt;router_id.s_addr != 0)</a>
<a name="ln175">	/* Is neighbor eligible? */</a>
<a name="ln176">	if (nbr-&gt;priority &gt; 0)</a>
<a name="ln177">	  /* Is neighbor upper 2-Way? */</a>
<a name="ln178">	  if (nbr-&gt;state &gt;= NSM_TwoWay)</a>
<a name="ln179">	    listnode_add (el_list, nbr);</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">/* Generate AdjOK? NSM event. */</a>
<a name="ln183">static void</a>
<a name="ln184">ospf_dr_change (struct ospf *ospf, struct route_table *nbrs)</a>
<a name="ln185">{</a>
<a name="ln186">  struct route_node *rn;</a>
<a name="ln187">  struct ospf_neighbor *nbr;</a>
<a name="ln188"> </a>
<a name="ln189">  for (rn = route_top (nbrs); rn; rn = route_next (rn))</a>
<a name="ln190">    if ((nbr = rn-&gt;info) != NULL)</a>
<a name="ln191">      /* Ignore 0.0.0.0 node*/</a>
<a name="ln192">      if (nbr-&gt;router_id.s_addr != 0)</a>
<a name="ln193">	/* Is neighbor upper 2-Way? */</a>
<a name="ln194">	if (nbr-&gt;state &gt;= NSM_TwoWay)</a>
<a name="ln195">	  /* Ignore myself. */</a>
<a name="ln196">	  if (!IPV4_ADDR_SAME (&amp;nbr-&gt;router_id, &amp;ospf-&gt;router_id))</a>
<a name="ln197">	    OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_AdjOK);</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">static int</a>
<a name="ln201">ospf_dr_election (struct ospf_interface *oi)</a>
<a name="ln202">{</a>
<a name="ln203">  struct in_addr old_dr, old_bdr;</a>
<a name="ln204">  int old_state, new_state;</a>
<a name="ln205">  struct list *el_list;</a>
<a name="ln206"> </a>
<a name="ln207">  /* backup current values. */</a>
<a name="ln208">  old_dr = DR (oi);</a>
<a name="ln209">  old_bdr = BDR (oi);</a>
<a name="ln210">  old_state = oi-&gt;state;</a>
<a name="ln211"> </a>
<a name="ln212">  el_list = list_new ();</a>
<a name="ln213"> </a>
<a name="ln214">  /* List eligible routers. */</a>
<a name="ln215">  ospf_dr_eligible_routers (oi-&gt;nbrs, el_list);</a>
<a name="ln216"> </a>
<a name="ln217">  /* First election of DR and BDR. */</a>
<a name="ln218">  ospf_elect_bdr (oi, el_list);</a>
<a name="ln219">  ospf_elect_dr (oi, el_list);</a>
<a name="ln220"> </a>
<a name="ln221">  new_state = ospf_ism_state (oi);</a>
<a name="ln222"> </a>
<a name="ln223">  zlog_debug (&quot;DR-Election[1st]: Backup %s&quot;, inet_ntoa (BDR (oi)));</a>
<a name="ln224">  zlog_debug (&quot;DR-Election[1st]: DR     %s&quot;, inet_ntoa (DR (oi)));</a>
<a name="ln225"> </a>
<a name="ln226">  if (new_state != old_state &amp;&amp;</a>
<a name="ln227">      !(new_state == ISM_DROther &amp;&amp; old_state &lt; ISM_DROther))</a>
<a name="ln228">    {</a>
<a name="ln229">      ospf_elect_bdr (oi, el_list);</a>
<a name="ln230">      ospf_elect_dr (oi, el_list); </a>
<a name="ln231"> </a>
<a name="ln232">      new_state = ospf_ism_state (oi);</a>
<a name="ln233"> </a>
<a name="ln234">      zlog_debug (&quot;DR-Election[2nd]: Backup %s&quot;, inet_ntoa (BDR (oi)));</a>
<a name="ln235">      zlog_debug (&quot;DR-Election[2nd]: DR     %s&quot;, inet_ntoa (DR (oi)));</a>
<a name="ln236">    }</a>
<a name="ln237"> </a>
<a name="ln238">  list_delete (el_list);</a>
<a name="ln239"> </a>
<a name="ln240">  /* if DR or BDR changes, cause AdjOK? neighbor event. */</a>
<a name="ln241">  if (!IPV4_ADDR_SAME (&amp;old_dr, &amp;DR (oi)) ||</a>
<a name="ln242">      !IPV4_ADDR_SAME (&amp;old_bdr, &amp;BDR (oi)))</a>
<a name="ln243">    ospf_dr_change (oi-&gt;ospf, oi-&gt;nbrs);</a>
<a name="ln244"> </a>
<a name="ln245">  return new_state;</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248"> </a>
<a name="ln249">int</a>
<a name="ln250">ospf_hello_timer (struct thread *thread)</a>
<a name="ln251">{</a>
<a name="ln252">  struct ospf_interface *oi;</a>
<a name="ln253"> </a>
<a name="ln254">  oi = THREAD_ARG (thread);</a>
<a name="ln255">  oi-&gt;t_hello = NULL;</a>
<a name="ln256"> </a>
<a name="ln257">  if (IS_DEBUG_OSPF (ism, ISM_TIMERS))</a>
<a name="ln258">    zlog (NULL, LOG_DEBUG, &quot;ISM[%s]: Timer (Hello timer expire)&quot;,</a>
<a name="ln259">	  IF_NAME (oi));</a>
<a name="ln260"> </a>
<a name="ln261">  /* Sending hello packet. */</a>
<a name="ln262">  ospf_hello_send (oi);</a>
<a name="ln263"> </a>
<a name="ln264">  /* Hello timer set. */</a>
<a name="ln265">  OSPF_HELLO_TIMER_ON (oi);</a>
<a name="ln266">  </a>
<a name="ln267">  return 0;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">static int</a>
<a name="ln271">ospf_wait_timer (struct thread *thread)</a>
<a name="ln272">{</a>
<a name="ln273">  struct ospf_interface *oi;</a>
<a name="ln274"> </a>
<a name="ln275">  oi = THREAD_ARG (thread);</a>
<a name="ln276">  oi-&gt;t_wait = NULL;</a>
<a name="ln277"> </a>
<a name="ln278">  if (IS_DEBUG_OSPF (ism, ISM_TIMERS))</a>
<a name="ln279">    zlog (NULL, LOG_DEBUG, &quot;ISM[%s]: Timer (Wait timer expire)&quot;,</a>
<a name="ln280">	  IF_NAME (oi));</a>
<a name="ln281"> </a>
<a name="ln282">  OSPF_ISM_EVENT_SCHEDULE (oi, ISM_WaitTimer);</a>
<a name="ln283"> </a>
<a name="ln284">  return 0;</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">/* Hook function called after ospf ISM event is occured. And vty's</a>
<a name="ln288">   network command invoke this function after making interface</a>
<a name="ln289">   structure. */</a>
<a name="ln290">static void</a>
<a name="ln291">ism_timer_set (struct ospf_interface *oi)</a>
<a name="ln292">{</a>
<a name="ln293">  switch (oi-&gt;state)</a>
<a name="ln294">    {</a>
<a name="ln295">    case ISM_Down:</a>
<a name="ln296">      /* First entry point of ospf interface state machine. In this state</a>
<a name="ln297">	 interface parameters must be set to initial values, and timers are</a>
<a name="ln298">	 reset also. */</a>
<a name="ln299">      OSPF_ISM_TIMER_OFF (oi-&gt;t_hello);</a>
<a name="ln300">      OSPF_ISM_TIMER_OFF (oi-&gt;t_wait);</a>
<a name="ln301">      OSPF_ISM_TIMER_OFF (oi-&gt;t_ls_ack);</a>
<a name="ln302">      break;</a>
<a name="ln303">    case ISM_Loopback:</a>
<a name="ln304">      /* In this state, the interface may be looped back and will be</a>
<a name="ln305">	 unavailable for regular data traffic. */</a>
<a name="ln306">      OSPF_ISM_TIMER_OFF (oi-&gt;t_hello);</a>
<a name="ln307">      OSPF_ISM_TIMER_OFF (oi-&gt;t_wait);</a>
<a name="ln308">      OSPF_ISM_TIMER_OFF (oi-&gt;t_ls_ack);</a>
<a name="ln309">      break;</a>
<a name="ln310">    case ISM_Waiting:</a>
<a name="ln311">      /* The router is trying to determine the identity of DRouter and</a>
<a name="ln312">	 BDRouter. The router begin to receive and send Hello Packets. */</a>
<a name="ln313">      /* send first hello immediately */</a>
<a name="ln314">      OSPF_ISM_TIMER_MSEC_ON (oi-&gt;t_hello, ospf_hello_timer, 1);</a>
<a name="ln315">      OSPF_ISM_TIMER_ON (oi-&gt;t_wait, ospf_wait_timer,</a>
<a name="ln316">			 OSPF_IF_PARAM (oi, v_wait));</a>
<a name="ln317">      OSPF_ISM_TIMER_OFF (oi-&gt;t_ls_ack);</a>
<a name="ln318">      break;</a>
<a name="ln319">    case ISM_PointToPoint:</a>
<a name="ln320">      /* The interface connects to a physical Point-to-point network or</a>
<a name="ln321">	 virtual link. The router attempts to form an adjacency with</a>
<a name="ln322">	 neighboring router. Hello packets are also sent. */</a>
<a name="ln323">      /* send first hello immediately */</a>
<a name="ln324">      OSPF_ISM_TIMER_MSEC_ON (oi-&gt;t_hello, ospf_hello_timer, 1);      </a>
<a name="ln325">      OSPF_ISM_TIMER_OFF (oi-&gt;t_wait);</a>
<a name="ln326">      OSPF_ISM_TIMER_ON (oi-&gt;t_ls_ack, ospf_ls_ack_timer, oi-&gt;v_ls_ack);</a>
<a name="ln327">      break;</a>
<a name="ln328">    case ISM_DROther:</a>
<a name="ln329">      /* The network type of the interface is broadcast or NBMA network,</a>
<a name="ln330">	 and the router itself is neither Designated Router nor</a>
<a name="ln331">	 Backup Designated Router. */</a>
<a name="ln332">      OSPF_HELLO_TIMER_ON (oi);</a>
<a name="ln333">      OSPF_ISM_TIMER_OFF (oi-&gt;t_wait);</a>
<a name="ln334">      OSPF_ISM_TIMER_ON (oi-&gt;t_ls_ack, ospf_ls_ack_timer, oi-&gt;v_ls_ack);</a>
<a name="ln335">      break;</a>
<a name="ln336">    case ISM_Backup:</a>
<a name="ln337">      /* The network type of the interface is broadcast os NBMA network,</a>
<a name="ln338">	 and the router is Backup Designated Router. */</a>
<a name="ln339">      OSPF_HELLO_TIMER_ON (oi);</a>
<a name="ln340">      OSPF_ISM_TIMER_OFF (oi-&gt;t_wait);</a>
<a name="ln341">      OSPF_ISM_TIMER_ON (oi-&gt;t_ls_ack, ospf_ls_ack_timer, oi-&gt;v_ls_ack);</a>
<a name="ln342">      break;</a>
<a name="ln343">    case ISM_DR:</a>
<a name="ln344">      /* The network type of the interface is broadcast or NBMA network,</a>
<a name="ln345">	 and the router is Designated Router. */</a>
<a name="ln346">      OSPF_HELLO_TIMER_ON (oi);</a>
<a name="ln347">      OSPF_ISM_TIMER_OFF (oi-&gt;t_wait);</a>
<a name="ln348">      OSPF_ISM_TIMER_ON (oi-&gt;t_ls_ack, ospf_ls_ack_timer, oi-&gt;v_ls_ack);</a>
<a name="ln349">      break;</a>
<a name="ln350">    }</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">static int</a>
<a name="ln354">ism_interface_up (struct ospf_interface *oi)</a>
<a name="ln355">{</a>
<a name="ln356">  int next_state = 0;</a>
<a name="ln357"> </a>
<a name="ln358">  /* if network type is point-to-point, Point-to-MultiPoint or virtual link,</a>
<a name="ln359">     the state transitions to Point-to-Point. */</a>
<a name="ln360">  if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT ||</a>
<a name="ln361">      oi-&gt;type == OSPF_IFTYPE_POINTOMULTIPOINT ||</a>
<a name="ln362">      oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln363">    next_state = ISM_PointToPoint;</a>
<a name="ln364">  /* Else if the router is not eligible to DR, the state transitions to</a>
<a name="ln365">     DROther. */</a>
<a name="ln366">  else if (PRIORITY (oi) == 0) /* router is eligible? */</a>
<a name="ln367">    next_state = ISM_DROther;</a>
<a name="ln368">  else</a>
<a name="ln369">    /* Otherwise, the state transitions to Waiting. */</a>
<a name="ln370">    next_state = ISM_Waiting;</a>
<a name="ln371"> </a>
<a name="ln372">  if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln373">    ospf_nbr_nbma_if_update (oi-&gt;ospf, oi);</a>
<a name="ln374"> </a>
<a name="ln375">  /*  ospf_ism_event (t); */</a>
<a name="ln376">  return next_state;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">static int</a>
<a name="ln380">ism_loop_ind (struct ospf_interface *oi)</a>
<a name="ln381">{</a>
<a name="ln382">  int ret = 0;</a>
<a name="ln383"> </a>
<a name="ln384">  /* call ism_interface_down. */</a>
<a name="ln385">  /* ret = ism_interface_down (oi); */</a>
<a name="ln386"> </a>
<a name="ln387">  return ret;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">/* Interface down event handler. */</a>
<a name="ln391">static int</a>
<a name="ln392">ism_interface_down (struct ospf_interface *oi)</a>
<a name="ln393">{</a>
<a name="ln394">  ospf_if_cleanup (oi);</a>
<a name="ln395">  return 0;</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398"> </a>
<a name="ln399">static int</a>
<a name="ln400">ism_backup_seen (struct ospf_interface *oi)</a>
<a name="ln401">{</a>
<a name="ln402">  return ospf_dr_election (oi);</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">static int</a>
<a name="ln406">ism_wait_timer (struct ospf_interface *oi)</a>
<a name="ln407">{</a>
<a name="ln408">  return ospf_dr_election (oi);</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">static int</a>
<a name="ln412">ism_neighbor_change (struct ospf_interface *oi)</a>
<a name="ln413">{</a>
<a name="ln414">  return ospf_dr_election (oi);</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">static int</a>
<a name="ln418">ism_ignore (struct ospf_interface *oi)</a>
<a name="ln419">{</a>
<a name="ln420">  if (IS_DEBUG_OSPF (ism, ISM_EVENTS))</a>
<a name="ln421">    zlog (NULL, LOG_DEBUG, &quot;ISM[%s]: ism_ignore called&quot;, IF_NAME (oi));</a>
<a name="ln422"> </a>
<a name="ln423">  return 0;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">/* Interface State Machine */</a>
<a name="ln427">struct {</a>
<a name="ln428">  int (*func) (struct ospf_interface *);</a>
<a name="ln429">  int next_state;</a>
<a name="ln430">} ISM [OSPF_ISM_STATE_MAX][OSPF_ISM_EVENT_MAX] =</a>
<a name="ln431">{</a>
<a name="ln432">  {</a>
<a name="ln433">    /* DependUpon: dummy state. */</a>
<a name="ln434">    { ism_ignore,          ISM_DependUpon },    /* NoEvent        */</a>
<a name="ln435">    { ism_ignore,          ISM_DependUpon },    /* InterfaceUp    */</a>
<a name="ln436">    { ism_ignore,          ISM_DependUpon },    /* WaitTimer      */</a>
<a name="ln437">    { ism_ignore,          ISM_DependUpon },    /* BackupSeen     */</a>
<a name="ln438">    { ism_ignore,          ISM_DependUpon },    /* NeighborChange */</a>
<a name="ln439">    { ism_ignore,          ISM_DependUpon },    /* LoopInd        */</a>
<a name="ln440">    { ism_ignore,          ISM_DependUpon },    /* UnloopInd      */</a>
<a name="ln441">    { ism_ignore,          ISM_DependUpon },    /* InterfaceDown  */</a>
<a name="ln442">  },</a>
<a name="ln443">  {</a>
<a name="ln444">    /* Down:*/</a>
<a name="ln445">    { ism_ignore,          ISM_DependUpon },    /* NoEvent        */</a>
<a name="ln446">    { ism_interface_up,    ISM_DependUpon },    /* InterfaceUp    */</a>
<a name="ln447">    { ism_ignore,          ISM_Down },          /* WaitTimer      */</a>
<a name="ln448">    { ism_ignore,          ISM_Down },          /* BackupSeen     */</a>
<a name="ln449">    { ism_ignore,          ISM_Down },          /* NeighborChange */</a>
<a name="ln450">    { ism_loop_ind,        ISM_Loopback },      /* LoopInd        */</a>
<a name="ln451">    { ism_ignore,          ISM_Down },          /* UnloopInd      */</a>
<a name="ln452">    { ism_interface_down,  ISM_Down },          /* InterfaceDown  */</a>
<a name="ln453">  },</a>
<a name="ln454">  {</a>
<a name="ln455">    /* Loopback: */</a>
<a name="ln456">    { ism_ignore,          ISM_DependUpon },    /* NoEvent        */</a>
<a name="ln457">    { ism_ignore,          ISM_Loopback },      /* InterfaceUp    */</a>
<a name="ln458">    { ism_ignore,          ISM_Loopback },      /* WaitTimer      */</a>
<a name="ln459">    { ism_ignore,          ISM_Loopback },      /* BackupSeen     */</a>
<a name="ln460">    { ism_ignore,          ISM_Loopback },      /* NeighborChange */</a>
<a name="ln461">    { ism_ignore,          ISM_Loopback },      /* LoopInd        */</a>
<a name="ln462">    { ism_ignore,          ISM_Down },          /* UnloopInd      */</a>
<a name="ln463">    { ism_interface_down,  ISM_Down },          /* InterfaceDown  */</a>
<a name="ln464">  },</a>
<a name="ln465">  {</a>
<a name="ln466">    /* Waiting: */</a>
<a name="ln467">    { ism_ignore,          ISM_DependUpon },    /* NoEvent        */</a>
<a name="ln468">    { ism_ignore,          ISM_Waiting },       /* InterfaceUp    */</a>
<a name="ln469">    { ism_wait_timer,	   ISM_DependUpon },    /* WaitTimer      */</a>
<a name="ln470">    { ism_backup_seen,     ISM_DependUpon },    /* BackupSeen     */</a>
<a name="ln471">    { ism_ignore,          ISM_Waiting },       /* NeighborChange */</a>
<a name="ln472">    { ism_loop_ind,	   ISM_Loopback },      /* LoopInd        */</a>
<a name="ln473">    { ism_ignore,          ISM_Waiting },       /* UnloopInd      */</a>
<a name="ln474">    { ism_interface_down,  ISM_Down },          /* InterfaceDown  */</a>
<a name="ln475">  },</a>
<a name="ln476">  {</a>
<a name="ln477">    /* Point-to-Point: */</a>
<a name="ln478">    { ism_ignore,          ISM_DependUpon },    /* NoEvent        */</a>
<a name="ln479">    { ism_ignore,          ISM_PointToPoint },  /* InterfaceUp    */</a>
<a name="ln480">    { ism_ignore,          ISM_PointToPoint },  /* WaitTimer      */</a>
<a name="ln481">    { ism_ignore,          ISM_PointToPoint },  /* BackupSeen     */</a>
<a name="ln482">    { ism_ignore,          ISM_PointToPoint },  /* NeighborChange */</a>
<a name="ln483">    { ism_loop_ind,	   ISM_Loopback },      /* LoopInd        */</a>
<a name="ln484">    { ism_ignore,          ISM_PointToPoint },  /* UnloopInd      */</a>
<a name="ln485">    { ism_interface_down,  ISM_Down },          /* InterfaceDown  */</a>
<a name="ln486">  },</a>
<a name="ln487">  {</a>
<a name="ln488">    /* DROther: */</a>
<a name="ln489">    { ism_ignore,          ISM_DependUpon },    /* NoEvent        */</a>
<a name="ln490">    { ism_ignore,          ISM_DROther },       /* InterfaceUp    */</a>
<a name="ln491">    { ism_ignore,          ISM_DROther },       /* WaitTimer      */</a>
<a name="ln492">    { ism_ignore,          ISM_DROther },       /* BackupSeen     */</a>
<a name="ln493">    { ism_neighbor_change, ISM_DependUpon },    /* NeighborChange */</a>
<a name="ln494">    { ism_loop_ind,        ISM_Loopback },      /* LoopInd        */</a>
<a name="ln495">    { ism_ignore,          ISM_DROther },       /* UnloopInd      */</a>
<a name="ln496">    { ism_interface_down,  ISM_Down },          /* InterfaceDown  */</a>
<a name="ln497">  },</a>
<a name="ln498">  {</a>
<a name="ln499">    /* Backup: */</a>
<a name="ln500">    { ism_ignore,          ISM_DependUpon },    /* NoEvent        */</a>
<a name="ln501">    { ism_ignore,          ISM_Backup },        /* InterfaceUp    */</a>
<a name="ln502">    { ism_ignore,          ISM_Backup },        /* WaitTimer      */</a>
<a name="ln503">    { ism_ignore,          ISM_Backup },        /* BackupSeen     */</a>
<a name="ln504">    { ism_neighbor_change, ISM_DependUpon },    /* NeighborChange */</a>
<a name="ln505">    { ism_loop_ind,        ISM_Loopback },      /* LoopInd        */</a>
<a name="ln506">    { ism_ignore,          ISM_Backup },        /* UnloopInd      */</a>
<a name="ln507">    { ism_interface_down,  ISM_Down },          /* InterfaceDown  */</a>
<a name="ln508">  },</a>
<a name="ln509">  {</a>
<a name="ln510">    /* DR: */</a>
<a name="ln511">    { ism_ignore,          ISM_DependUpon },    /* NoEvent        */</a>
<a name="ln512">    { ism_ignore,          ISM_DR },            /* InterfaceUp    */</a>
<a name="ln513">    { ism_ignore,          ISM_DR },            /* WaitTimer      */</a>
<a name="ln514">    { ism_ignore,          ISM_DR },            /* BackupSeen     */</a>
<a name="ln515">    { ism_neighbor_change, ISM_DependUpon },    /* NeighborChange */</a>
<a name="ln516">    { ism_loop_ind,        ISM_Loopback },      /* LoopInd        */</a>
<a name="ln517">    { ism_ignore,          ISM_DR },            /* UnloopInd      */</a>
<a name="ln518">    { ism_interface_down,  ISM_Down },          /* InterfaceDown  */</a>
<a name="ln519">  },</a>
<a name="ln520">};  </a>
<a name="ln521"> </a>
<a name="ln522">static const char *ospf_ism_event_str[] =</a>
<a name="ln523">{</a>
<a name="ln524">  &quot;NoEvent&quot;,</a>
<a name="ln525">  &quot;InterfaceUp&quot;,</a>
<a name="ln526">  &quot;WaitTimer&quot;,</a>
<a name="ln527">  &quot;BackupSeen&quot;,</a>
<a name="ln528">  &quot;NeighborChange&quot;,</a>
<a name="ln529">  &quot;LoopInd&quot;,</a>
<a name="ln530">  &quot;UnLoopInd&quot;,</a>
<a name="ln531">  &quot;InterfaceDown&quot;,</a>
<a name="ln532">};</a>
<a name="ln533"> </a>
<a name="ln534">static void</a>
<a name="ln535">ism_change_state (struct ospf_interface *oi, int state)</a>
<a name="ln536">{</a>
<a name="ln537">  int old_state;</a>
<a name="ln538">  struct ospf_lsa *lsa;</a>
<a name="ln539"> </a>
<a name="ln540">  /* Logging change of state. */</a>
<a name="ln541">  if (IS_DEBUG_OSPF (ism, ISM_STATUS))</a>
<a name="ln542">    zlog (NULL, LOG_DEBUG, &quot;ISM[%s]: State change %s -&gt; %s&quot;, IF_NAME (oi),</a>
<a name="ln543">	  LOOKUP (ospf_ism_state_msg, oi-&gt;state),</a>
<a name="ln544">	  LOOKUP (ospf_ism_state_msg, state));</a>
<a name="ln545"> </a>
<a name="ln546">  old_state = oi-&gt;state;</a>
<a name="ln547">  oi-&gt;state = state;</a>
<a name="ln548">  oi-&gt;state_change++;</a>
<a name="ln549"> </a>
<a name="ln550">#ifdef HAVE_SNMP</a>
<a name="ln551">  /* Terminal state or regression */ </a>
<a name="ln552">  if ((state == ISM_DR) || (state == ISM_Backup) || (state == ISM_DROther) ||</a>
<a name="ln553">      (state == ISM_PointToPoint) || (state &lt; old_state))</a>
<a name="ln554">    {</a>
<a name="ln555">      /* ospfVirtIfStateChange */</a>
<a name="ln556">      if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln557">        ospfTrapVirtIfStateChange (oi);</a>
<a name="ln558">      /* ospfIfStateChange */</a>
<a name="ln559">      else</a>
<a name="ln560">        ospfTrapIfStateChange (oi);</a>
<a name="ln561">    }</a>
<a name="ln562">#endif</a>
<a name="ln563"> </a>
<a name="ln564">  /* Set multicast memberships appropriately for new state. */</a>
<a name="ln565">  ospf_if_set_multicast(oi);</a>
<a name="ln566"> </a>
<a name="ln567">  if (old_state == ISM_Down || state == ISM_Down)</a>
<a name="ln568">    ospf_check_abr_status (oi-&gt;ospf);</a>
<a name="ln569"> </a>
<a name="ln570">  /* Originate router-LSA. */</a>
<a name="ln571">  if (state == ISM_Down)</a>
<a name="ln572">    {</a>
<a name="ln573">      if (oi-&gt;area-&gt;act_ints &gt; 0)</a>
<a name="ln574">        oi-&gt;area-&gt;act_ints--;</a>
<a name="ln575">    }</a>
<a name="ln576">  else if (old_state == ISM_Down)</a>
<a name="ln577">    oi-&gt;area-&gt;act_ints++;</a>
<a name="ln578"> </a>
<a name="ln579">  /* schedule router-LSA originate. */</a>
<a name="ln580">  ospf_router_lsa_update_area (oi-&gt;area);</a>
<a name="ln581"> </a>
<a name="ln582">  /* Originate network-LSA. */</a>
<a name="ln583">  if (old_state != ISM_DR &amp;&amp; state == ISM_DR)</a>
<a name="ln584">    ospf_network_lsa_update (oi);</a>
<a name="ln585">  else if (old_state == ISM_DR &amp;&amp; state != ISM_DR)</a>
<a name="ln586">    {</a>
<a name="ln587">      /* Free self originated network LSA. */</a>
<a name="ln588">      lsa = oi-&gt;network_lsa_self;</a>
<a name="ln589">      if (lsa)</a>
<a name="ln590">        ospf_lsa_flush_area (lsa, oi-&gt;area);</a>
<a name="ln591"> </a>
<a name="ln592">      ospf_lsa_unlock (&amp;oi-&gt;network_lsa_self);</a>
<a name="ln593">      oi-&gt;network_lsa_self = NULL;</a>
<a name="ln594">    }</a>
<a name="ln595"> </a>
<a name="ln596">  ospf_opaque_ism_change (oi, old_state);</a>
<a name="ln597"> </a>
<a name="ln598">  /* Check area border status.  */</a>
<a name="ln599">  ospf_check_abr_status (oi-&gt;ospf);</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">/* Execute ISM event process. */</a>
<a name="ln603">int</a>
<a name="ln604">ospf_ism_event (struct thread *thread)</a>
<a name="ln605">{</a>
<a name="ln606">  int event;</a>
<a name="ln607">  int next_state;</a>
<a name="ln608">  struct ospf_interface *oi;</a>
<a name="ln609"> </a>
<a name="ln610">  oi = THREAD_ARG (thread);</a>
<a name="ln611">  event = THREAD_VAL (thread);</a>
<a name="ln612"> </a>
<a name="ln613">  /* Call function. */</a>
<a name="ln614">  next_state = (*(ISM [oi-&gt;state][event].func))(oi);</a>
<a name="ln615"> </a>
<a name="ln616">  if (! next_state)</a>
<a name="ln617">    next_state = ISM [oi-&gt;state][event].next_state;</a>
<a name="ln618"> </a>
<a name="ln619">  if (IS_DEBUG_OSPF (ism, ISM_EVENTS))</a>
<a name="ln620">    zlog (NULL, LOG_DEBUG, &quot;ISM[%s]: %s (%s)&quot;, IF_NAME (oi),</a>
<a name="ln621">	  LOOKUP (ospf_ism_state_msg, oi-&gt;state),</a>
<a name="ln622">	  ospf_ism_event_str[event]);</a>
<a name="ln623"> </a>
<a name="ln624">  /* If state is changed. */</a>
<a name="ln625">  if (next_state != oi-&gt;state)</a>
<a name="ln626">    ism_change_state (oi, next_state);</a>
<a name="ln627"> </a>
<a name="ln628">  /* Make sure timer is set. */</a>
<a name="ln629">  ism_timer_set (oi);</a>
<a name="ln630"> </a>
<a name="ln631">  return 0;</a>
<a name="ln632">}</a>
<a name="ln633"> </a>

</code></pre>
<div class="balloon" rel="9"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="299"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 299, 306</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
