
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_routemap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Route map function of ospfd.</a>
<a name="ln3"> * Copyright (C) 2000 IP Infusion Inc.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Written by Toshiaki Takada.</a>
<a name="ln6"> *</a>
<a name="ln7"> * This file is part of GNU Zebra.</a>
<a name="ln8"> *</a>
<a name="ln9"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln10"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln11"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln12"> * later version.</a>
<a name="ln13"> *</a>
<a name="ln14"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln15"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln16"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln17"> * General Public License for more details.</a>
<a name="ln18"> *</a>
<a name="ln19"> * You should have received a copy of the GNU General Public License</a>
<a name="ln20"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln21"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln22"> * 02111-1307, USA.</a>
<a name="ln23"> */</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;zebra.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;table.h&quot;</a>
<a name="ln30">#include &quot;routemap.h&quot;</a>
<a name="ln31">#include &quot;command.h&quot;</a>
<a name="ln32">#include &quot;log.h&quot;</a>
<a name="ln33">#include &quot;plist.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln36">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">/* Hook function for updating route_map assignment. */</a>
<a name="ln43">static void</a>
<a name="ln44">ospf_route_map_update (const char *name)</a>
<a name="ln45">{</a>
<a name="ln46">  struct ospf *ospf;</a>
<a name="ln47">  int type;</a>
<a name="ln48"> </a>
<a name="ln49">  /* If OSPF instatnce does not exist, return right now. */</a>
<a name="ln50">  ospf = ospf_lookup ();</a>
<a name="ln51">  if (ospf == NULL)</a>
<a name="ln52">    return;</a>
<a name="ln53"> </a>
<a name="ln54">  /* Update route-map */</a>
<a name="ln55">  for (type = 0; type &lt;= ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln56">    {</a>
<a name="ln57">      if (ROUTEMAP_NAME (ospf, type)</a>
<a name="ln58">	  &amp;&amp; strcmp (ROUTEMAP_NAME (ospf, type), name) == 0)</a>
<a name="ln59">	{</a>
<a name="ln60">	  /* Keep old route-map. */</a>
<a name="ln61">	  struct route_map *old = ROUTEMAP (ospf, type);</a>
<a name="ln62"> </a>
<a name="ln63">	  /* Update route-map. */</a>
<a name="ln64">	  ROUTEMAP (ospf, type) =</a>
<a name="ln65">	    route_map_lookup_by_name (ROUTEMAP_NAME (ospf, type));</a>
<a name="ln66"> </a>
<a name="ln67">	  /* No update for this distribute type. */</a>
<a name="ln68">	  if (old == NULL &amp;&amp; ROUTEMAP (ospf, type) == NULL)</a>
<a name="ln69">	    continue;</a>
<a name="ln70"> </a>
<a name="ln71">	  ospf_distribute_list_update (ospf, type);</a>
<a name="ln72">	}</a>
<a name="ln73">    }</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">static void</a>
<a name="ln77">ospf_route_map_event (route_map_event_t event, const char *name)</a>
<a name="ln78">{</a>
<a name="ln79">  struct ospf *ospf;</a>
<a name="ln80">  int type;</a>
<a name="ln81"> </a>
<a name="ln82">  /* If OSPF instatnce does not exist, return right now. */</a>
<a name="ln83">  ospf = ospf_lookup ();</a>
<a name="ln84">  if (ospf == NULL)</a>
<a name="ln85">    return;</a>
<a name="ln86"> </a>
<a name="ln87">  /* Update route-map. */</a>
<a name="ln88">  for (type = 0; type &lt;= ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln89">    {</a>
<a name="ln90">      if (ROUTEMAP_NAME (ospf, type) &amp;&amp;  ROUTEMAP (ospf, type)</a>
<a name="ln91">	  &amp;&amp; !strcmp (ROUTEMAP_NAME (ospf, type), name))</a>
<a name="ln92">        {</a>
<a name="ln93">          ospf_distribute_list_update (ospf, type);</a>
<a name="ln94">        }</a>
<a name="ln95">    }</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">/* Delete rip route map rule. */</a>
<a name="ln99">static int</a>
<a name="ln100">ospf_route_match_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln101">			 const char *command, const char *arg)</a>
<a name="ln102">{</a>
<a name="ln103">  int ret;</a>
<a name="ln104"> </a>
<a name="ln105">  ret = route_map_delete_match (index, command, arg);</a>
<a name="ln106">  if (ret)</a>
<a name="ln107">    {</a>
<a name="ln108">      switch (ret)</a>
<a name="ln109">        {</a>
<a name="ln110">        case RMAP_RULE_MISSING:</a>
<a name="ln111">          vty_out (vty, &quot;%% OSPF Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln112">          return CMD_WARNING;</a>
<a name="ln113">        case RMAP_COMPILE_ERROR:</a>
<a name="ln114">          vty_out (vty, &quot;%% OSPF Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln115">          return CMD_WARNING;</a>
<a name="ln116">        }</a>
<a name="ln117">    }</a>
<a name="ln118"> </a>
<a name="ln119">  return CMD_SUCCESS;</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">static int</a>
<a name="ln123">ospf_route_match_add (struct vty *vty, struct route_map_index *index,</a>
<a name="ln124">		      const char *command, const char *arg)</a>
<a name="ln125">{                                                                              </a>
<a name="ln126">  int ret;</a>
<a name="ln127"> </a>
<a name="ln128">  ret = route_map_add_match (index, command, arg);</a>
<a name="ln129">  if (ret)</a>
<a name="ln130">    {</a>
<a name="ln131">      switch (ret)</a>
<a name="ln132">        {</a>
<a name="ln133">        case RMAP_RULE_MISSING:</a>
<a name="ln134">          vty_out (vty, &quot;%% OSPF Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln135">          return CMD_WARNING;</a>
<a name="ln136">        case RMAP_COMPILE_ERROR:</a>
<a name="ln137">          vty_out (vty, &quot;%% OSPF Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln138">          return CMD_WARNING;</a>
<a name="ln139">        }</a>
<a name="ln140">    }</a>
<a name="ln141"> </a>
<a name="ln142">  return CMD_SUCCESS;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">static int</a>
<a name="ln146">ospf_route_set_add (struct vty *vty, struct route_map_index *index,</a>
<a name="ln147">		    const char *command, const char *arg)</a>
<a name="ln148">{</a>
<a name="ln149">  int ret;</a>
<a name="ln150"> </a>
<a name="ln151">  ret = route_map_add_set (index, command, arg);</a>
<a name="ln152">  if (ret)</a>
<a name="ln153">    {</a>
<a name="ln154">      switch (ret)</a>
<a name="ln155">        {</a>
<a name="ln156">        case RMAP_RULE_MISSING:</a>
<a name="ln157">          vty_out (vty, &quot;%% OSPF Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln158">          return CMD_WARNING;</a>
<a name="ln159">        case RMAP_COMPILE_ERROR:</a>
<a name="ln160">          vty_out (vty, &quot;%% OSPF Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln161">          return CMD_WARNING;</a>
<a name="ln162">        }</a>
<a name="ln163">    }</a>
<a name="ln164"> </a>
<a name="ln165">  return CMD_SUCCESS;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">/* Delete rip route map rule. */</a>
<a name="ln169">static int</a>
<a name="ln170">ospf_route_set_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln171">		       const char *command, const char *arg)</a>
<a name="ln172">{                                              </a>
<a name="ln173">  int ret;</a>
<a name="ln174"> </a>
<a name="ln175">  ret = route_map_delete_set (index, command, arg);</a>
<a name="ln176">  if (ret)</a>
<a name="ln177">    {</a>
<a name="ln178">      switch (ret)</a>
<a name="ln179">        {</a>
<a name="ln180">        case RMAP_RULE_MISSING:</a>
<a name="ln181">          vty_out (vty, &quot;%% OSPF Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln182">          return CMD_WARNING;</a>
<a name="ln183">        case RMAP_COMPILE_ERROR:</a>
<a name="ln184">          vty_out (vty, &quot;%% OSPF Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln185">          return CMD_WARNING;</a>
<a name="ln186">        }</a>
<a name="ln187">    }</a>
<a name="ln188"> </a>
<a name="ln189">  return CMD_SUCCESS;</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">/* `match ip netxthop ' */</a>
<a name="ln193">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln194">static route_map_result_t</a>
<a name="ln195">route_match_ip_nexthop (void *rule, struct prefix *prefix,</a>
<a name="ln196">			route_map_object_t type, void *object)</a>
<a name="ln197">{</a>
<a name="ln198">  struct access_list *alist;</a>
<a name="ln199">  struct external_info *ei = object;</a>
<a name="ln200">  struct prefix_ipv4 p;</a>
<a name="ln201"> </a>
<a name="ln202">  if (type == RMAP_OSPF)</a>
<a name="ln203">    {</a>
<a name="ln204">      p.family = AF_INET;</a>
<a name="ln205">      p.prefix = ei-&gt;nexthop;</a>
<a name="ln206">      p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln207"> </a>
<a name="ln208">      alist = access_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln209">      if (alist == NULL)</a>
<a name="ln210">        return RMAP_NOMATCH;</a>
<a name="ln211"> </a>
<a name="ln212">      return (access_list_apply (alist, &amp;p) == FILTER_DENY ?</a>
<a name="ln213">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln214">    }</a>
<a name="ln215">  return RMAP_NOMATCH;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">/* Route map `ip next-hop' match statement. `arg' should be</a>
<a name="ln219">   access-list name. */</a>
<a name="ln220">static void *</a>
<a name="ln221">route_match_ip_nexthop_compile (const char *arg)</a>
<a name="ln222">{</a>
<a name="ln223">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/* Free route map's compiled `ip address' value. */</a>
<a name="ln227">static void</a>
<a name="ln228">route_match_ip_nexthop_free (void *rule)</a>
<a name="ln229">{</a>
<a name="ln230">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">/* Route map commands for metric matching. */</a>
<a name="ln234">struct route_map_rule_cmd route_match_ip_nexthop_cmd =</a>
<a name="ln235">{</a>
<a name="ln236">  &quot;ip next-hop&quot;,</a>
<a name="ln237">  route_match_ip_nexthop,</a>
<a name="ln238">  route_match_ip_nexthop_compile,</a>
<a name="ln239">  route_match_ip_nexthop_free</a>
<a name="ln240">};</a>
<a name="ln241"> </a>
<a name="ln242">/* `match ip next-hop prefix-list PREFIX_LIST' */</a>
<a name="ln243"> </a>
<a name="ln244">static route_map_result_t</a>
<a name="ln245">route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,</a>
<a name="ln246">                                    route_map_object_t type, void *object)</a>
<a name="ln247">{</a>
<a name="ln248">  struct prefix_list *plist;</a>
<a name="ln249">  struct external_info *ei = object;</a>
<a name="ln250">  struct prefix_ipv4 p;</a>
<a name="ln251"> </a>
<a name="ln252">  if (type == RMAP_OSPF)</a>
<a name="ln253">    {</a>
<a name="ln254">      p.family = AF_INET;</a>
<a name="ln255">      p.prefix = ei-&gt;nexthop;</a>
<a name="ln256">      p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln257"> </a>
<a name="ln258">      plist = prefix_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln259">      if (plist == NULL)</a>
<a name="ln260">        return RMAP_NOMATCH;</a>
<a name="ln261"> </a>
<a name="ln262">      return (prefix_list_apply (plist, &amp;p) == PREFIX_DENY ?</a>
<a name="ln263">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln264">    }</a>
<a name="ln265">  return RMAP_NOMATCH;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">static void *</a>
<a name="ln269">route_match_ip_next_hop_prefix_list_compile (const char *arg)</a>
<a name="ln270">{</a>
<a name="ln271">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">static void</a>
<a name="ln275">route_match_ip_next_hop_prefix_list_free (void *rule)</a>
<a name="ln276">{</a>
<a name="ln277">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">struct route_map_rule_cmd route_match_ip_next_hop_prefix_list_cmd =</a>
<a name="ln281">{</a>
<a name="ln282">  &quot;ip next-hop prefix-list&quot;,</a>
<a name="ln283">  route_match_ip_next_hop_prefix_list,</a>
<a name="ln284">  route_match_ip_next_hop_prefix_list_compile,</a>
<a name="ln285">  route_match_ip_next_hop_prefix_list_free</a>
<a name="ln286">};</a>
<a name="ln287"> </a>
<a name="ln288">/* `match ip address IP_ACCESS_LIST' */</a>
<a name="ln289">/* Match function should return 1 if match is success else return</a>
<a name="ln290">   zero. */</a>
<a name="ln291">static route_map_result_t</a>
<a name="ln292">route_match_ip_address (void *rule, struct prefix *prefix,</a>
<a name="ln293">                        route_map_object_t type, void *object)</a>
<a name="ln294">{</a>
<a name="ln295">  struct access_list *alist;</a>
<a name="ln296">  /* struct prefix_ipv4 match; */</a>
<a name="ln297"> </a>
<a name="ln298">  if (type == RMAP_OSPF)</a>
<a name="ln299">    {</a>
<a name="ln300">      alist = access_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln301">      if (alist == NULL)</a>
<a name="ln302">        return RMAP_NOMATCH;</a>
<a name="ln303"> </a>
<a name="ln304">      return (access_list_apply (alist, prefix) == FILTER_DENY ?</a>
<a name="ln305">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln306">    }</a>
<a name="ln307">  return RMAP_NOMATCH;</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">/* Route map `ip address' match statement.  `arg' should be</a>
<a name="ln311">   access-list name. */</a>
<a name="ln312">static void *</a>
<a name="ln313">route_match_ip_address_compile (const char *arg)</a>
<a name="ln314">{</a>
<a name="ln315">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">/* Free route map's compiled `ip address' value. */</a>
<a name="ln319">static void</a>
<a name="ln320">route_match_ip_address_free (void *rule)</a>
<a name="ln321">{</a>
<a name="ln322">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">/* Route map commands for ip address matching. */</a>
<a name="ln326">struct route_map_rule_cmd route_match_ip_address_cmd =</a>
<a name="ln327">{</a>
<a name="ln328">  &quot;ip address&quot;,</a>
<a name="ln329">  route_match_ip_address,</a>
<a name="ln330">  route_match_ip_address_compile,</a>
<a name="ln331">  route_match_ip_address_free</a>
<a name="ln332">};</a>
<a name="ln333"> </a>
<a name="ln334">/* `match ip address prefix-list PREFIX_LIST' */</a>
<a name="ln335">static route_map_result_t</a>
<a name="ln336">route_match_ip_address_prefix_list (void *rule, struct prefix *prefix,</a>
<a name="ln337">                                    route_map_object_t type, void *object)</a>
<a name="ln338">{</a>
<a name="ln339">  struct prefix_list *plist;</a>
<a name="ln340"> </a>
<a name="ln341">  if (type == RMAP_OSPF)</a>
<a name="ln342">    {</a>
<a name="ln343">      plist = prefix_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln344">      if (plist == NULL)</a>
<a name="ln345">        return RMAP_NOMATCH;</a>
<a name="ln346"> </a>
<a name="ln347">      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?</a>
<a name="ln348">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln349">    }</a>
<a name="ln350">  return RMAP_NOMATCH;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">static void *</a>
<a name="ln354">route_match_ip_address_prefix_list_compile (const char *arg)</a>
<a name="ln355">{</a>
<a name="ln356">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">static void</a>
<a name="ln360">route_match_ip_address_prefix_list_free (void *rule)</a>
<a name="ln361">{</a>
<a name="ln362">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">struct route_map_rule_cmd route_match_ip_address_prefix_list_cmd =</a>
<a name="ln366">{</a>
<a name="ln367">  &quot;ip address prefix-list&quot;,</a>
<a name="ln368">  route_match_ip_address_prefix_list,</a>
<a name="ln369">  route_match_ip_address_prefix_list_compile,</a>
<a name="ln370">  route_match_ip_address_prefix_list_free</a>
<a name="ln371">};</a>
<a name="ln372"> </a>
<a name="ln373">/* `match interface IFNAME' */</a>
<a name="ln374">/* Match function should return 1 if match is success else return</a>
<a name="ln375">   zero. */</a>
<a name="ln376">static route_map_result_t</a>
<a name="ln377">route_match_interface (void *rule, struct prefix *prefix,</a>
<a name="ln378">		       route_map_object_t type, void *object)</a>
<a name="ln379">{</a>
<a name="ln380">  struct interface *ifp;</a>
<a name="ln381">  struct external_info *ei;</a>
<a name="ln382"> </a>
<a name="ln383">  if (type == RMAP_OSPF)</a>
<a name="ln384">    {</a>
<a name="ln385">      ei = object;</a>
<a name="ln386">      ifp = if_lookup_by_name ((char *)rule);</a>
<a name="ln387"> </a>
<a name="ln388">      if (ifp == NULL || ifp-&gt;ifindex != ei-&gt;ifindex)</a>
<a name="ln389">	return RMAP_NOMATCH;</a>
<a name="ln390"> </a>
<a name="ln391">      return RMAP_MATCH;</a>
<a name="ln392">    }</a>
<a name="ln393">  return RMAP_NOMATCH;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">/* Route map `interface' match statement.  `arg' should be</a>
<a name="ln397">   interface name. */</a>
<a name="ln398">static void *</a>
<a name="ln399">route_match_interface_compile (const char *arg)</a>
<a name="ln400">{</a>
<a name="ln401">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">/* Free route map's compiled `interface' value. */</a>
<a name="ln405">static void</a>
<a name="ln406">route_match_interface_free (void *rule)</a>
<a name="ln407">{</a>
<a name="ln408">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">/* Route map commands for ip address matching. */</a>
<a name="ln412">struct route_map_rule_cmd route_match_interface_cmd =</a>
<a name="ln413">{</a>
<a name="ln414">  &quot;interface&quot;,</a>
<a name="ln415">  route_match_interface,</a>
<a name="ln416">  route_match_interface_compile,</a>
<a name="ln417">  route_match_interface_free</a>
<a name="ln418">};</a>
<a name="ln419"> </a>
<a name="ln420">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln421">static route_map_result_t</a>
<a name="ln422">route_match_tag (void *rule, struct prefix *prefix,</a>
<a name="ln423">                 route_map_object_t type, void *object)</a>
<a name="ln424">{</a>
<a name="ln425">  route_tag_t *tag;</a>
<a name="ln426">  struct external_info *ei;</a>
<a name="ln427"> </a>
<a name="ln428">  if (type == RMAP_OSPF)</a>
<a name="ln429">    {</a>
<a name="ln430">      tag = rule;</a>
<a name="ln431">      ei = object;</a>
<a name="ln432"> </a>
<a name="ln433">      return ((ei-&gt;tag == *tag)? RMAP_MATCH : RMAP_NOMATCH);</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">  return RMAP_NOMATCH;</a>
<a name="ln437">}</a>
<a name="ln438"> </a>
<a name="ln439">/* Route map commands for tag matching. */</a>
<a name="ln440">static struct route_map_rule_cmd route_match_tag_cmd =</a>
<a name="ln441">{</a>
<a name="ln442">  &quot;tag&quot;,</a>
<a name="ln443">  route_match_tag,</a>
<a name="ln444">  route_map_rule_tag_compile,</a>
<a name="ln445">  route_map_rule_tag_free,</a>
<a name="ln446">};</a>
<a name="ln447"> </a>
<a name="ln448"> </a>
<a name="ln449">/* `set metric METRIC' */</a>
<a name="ln450">/* Set metric to attribute. */</a>
<a name="ln451">static route_map_result_t</a>
<a name="ln452">route_set_metric (void *rule, struct prefix *prefix,</a>
<a name="ln453">                  route_map_object_t type, void *object)</a>
<a name="ln454">{</a>
<a name="ln455">  u_int32_t *metric;</a>
<a name="ln456">  struct external_info *ei;</a>
<a name="ln457"> </a>
<a name="ln458">  if (type == RMAP_OSPF)</a>
<a name="ln459">    {</a>
<a name="ln460">      /* Fetch routemap's rule information. */</a>
<a name="ln461">      metric = rule;</a>
<a name="ln462">      ei = object;</a>
<a name="ln463"> </a>
<a name="ln464">      /* Set metric out value. */</a>
<a name="ln465">      ei-&gt;route_map_set.metric = *metric;</a>
<a name="ln466">    }</a>
<a name="ln467">  return RMAP_OKAY;</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">/* set metric compilation. */</a>
<a name="ln471">static void *</a>
<a name="ln472">route_set_metric_compile (const char *arg)</a>
<a name="ln473">{</a>
<a name="ln474">  u_int32_t *metric;</a>
<a name="ln475">  int32_t ret;</a>
<a name="ln476"> </a>
<a name="ln477">  /* OSPF doesn't support the +/- in</a>
<a name="ln478">     set metric &lt;+/-metric&gt; check</a>
<a name="ln479">     Ignore the +/- component */</a>
<a name="ln480">  if (! all_digit (arg))</a>
<a name="ln481">    {</a>
<a name="ln482">      if ((strncmp (arg, &quot;+&quot;, 1) == 0 || strncmp (arg, &quot;-&quot;, 1) == 0) &amp;&amp;</a>
<a name="ln483">	  all_digit (arg+1))</a>
<a name="ln484">	{</a>
<a name="ln485">	  zlog_warn (&quot;OSPF does not support 'set metric +/-'&quot;);</a>
<a name="ln486">	  arg++;</a>
<a name="ln487">	}</a>
<a name="ln488">      else</a>
<a name="ln489">	return NULL;</a>
<a name="ln490">    }</a>
<a name="ln491"> </a>
<a name="ln492">  metric = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_int32_t));</a>
<a name="ln493">  ret = atoi (arg);</a>
<a name="ln494"> </a>
<a name="ln495">  if (ret &gt;= 0)</a>
<a name="ln496">    {</a>
<a name="ln497">      *metric = (u_int32_t)ret;</a>
<a name="ln498">      return metric;</a>
<a name="ln499">    }</a>
<a name="ln500"> </a>
<a name="ln501">  XFREE (MTYPE_ROUTE_MAP_COMPILED, metric);</a>
<a name="ln502">  return NULL;</a>
<a name="ln503">}</a>
<a name="ln504"> </a>
<a name="ln505">/* Free route map's compiled `set metric' value. */</a>
<a name="ln506">static void</a>
<a name="ln507">route_set_metric_free (void *rule)</a>
<a name="ln508">{</a>
<a name="ln509">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">/* Set metric rule structure. */</a>
<a name="ln513">struct route_map_rule_cmd route_set_metric_cmd =</a>
<a name="ln514">{</a>
<a name="ln515">  &quot;metric&quot;,</a>
<a name="ln516">  route_set_metric,</a>
<a name="ln517">  route_set_metric_compile,</a>
<a name="ln518">  route_set_metric_free,</a>
<a name="ln519">};</a>
<a name="ln520"> </a>
<a name="ln521">/* `set metric-type TYPE' */</a>
<a name="ln522">/* Set metric-type to attribute. */</a>
<a name="ln523">static route_map_result_t</a>
<a name="ln524">route_set_metric_type (void *rule, struct prefix *prefix,</a>
<a name="ln525">		       route_map_object_t type, void *object)</a>
<a name="ln526">{</a>
<a name="ln527">  u_int32_t *metric_type;</a>
<a name="ln528">  struct external_info *ei;</a>
<a name="ln529"> </a>
<a name="ln530">  if (type == RMAP_OSPF)</a>
<a name="ln531">    {</a>
<a name="ln532">      /* Fetch routemap's rule information. */</a>
<a name="ln533">      metric_type = rule;</a>
<a name="ln534">      ei = object;</a>
<a name="ln535"> </a>
<a name="ln536">      /* Set metric out value. */</a>
<a name="ln537">      ei-&gt;route_map_set.metric_type = *metric_type;</a>
<a name="ln538">    }</a>
<a name="ln539">  return RMAP_OKAY;</a>
<a name="ln540">}</a>
<a name="ln541"> </a>
<a name="ln542">/* set metric-type compilation. */</a>
<a name="ln543">static void *</a>
<a name="ln544">route_set_metric_type_compile (const char *arg)</a>
<a name="ln545">{</a>
<a name="ln546">  u_int32_t *metric_type;</a>
<a name="ln547"> </a>
<a name="ln548">  metric_type = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_int32_t));</a>
<a name="ln549">  if (strcmp (arg, &quot;type-1&quot;) == 0)</a>
<a name="ln550">    *metric_type = EXTERNAL_METRIC_TYPE_1;</a>
<a name="ln551">  else if (strcmp (arg, &quot;type-2&quot;) == 0)</a>
<a name="ln552">    *metric_type = EXTERNAL_METRIC_TYPE_2;</a>
<a name="ln553"> </a>
<a name="ln554">  if (*metric_type == EXTERNAL_METRIC_TYPE_1 ||</a>
<a name="ln555">      *metric_type == EXTERNAL_METRIC_TYPE_2)</a>
<a name="ln556">    return metric_type;</a>
<a name="ln557"> </a>
<a name="ln558">  XFREE (MTYPE_ROUTE_MAP_COMPILED, metric_type);</a>
<a name="ln559">  return NULL;</a>
<a name="ln560">}</a>
<a name="ln561"> </a>
<a name="ln562">/* Free route map's compiled `set metric-type' value. */</a>
<a name="ln563">static void</a>
<a name="ln564">route_set_metric_type_free (void *rule)</a>
<a name="ln565">{</a>
<a name="ln566">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">/* Set metric rule structure. */</a>
<a name="ln570">struct route_map_rule_cmd route_set_metric_type_cmd =</a>
<a name="ln571">{</a>
<a name="ln572">  &quot;metric-type&quot;,</a>
<a name="ln573">  route_set_metric_type,</a>
<a name="ln574">  route_set_metric_type_compile,</a>
<a name="ln575">  route_set_metric_type_free,</a>
<a name="ln576">};</a>
<a name="ln577"> </a>
<a name="ln578">static route_map_result_t</a>
<a name="ln579">route_set_tag (void *rule, struct prefix *prefix,</a>
<a name="ln580">               route_map_object_t type, void *object)</a>
<a name="ln581">{</a>
<a name="ln582">  route_tag_t *tag;</a>
<a name="ln583">  struct external_info *ei;</a>
<a name="ln584"> </a>
<a name="ln585">  if (type == RMAP_OSPF)</a>
<a name="ln586">    {</a>
<a name="ln587">      tag = rule;</a>
<a name="ln588">      ei = object;</a>
<a name="ln589"> </a>
<a name="ln590">      /* Set tag value */</a>
<a name="ln591">      ei-&gt;tag=*tag;</a>
<a name="ln592">    }</a>
<a name="ln593"> </a>
<a name="ln594">  return RMAP_OKAY;</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">/* Route map commands for tag set. */</a>
<a name="ln598">static struct route_map_rule_cmd route_set_tag_cmd =</a>
<a name="ln599">{</a>
<a name="ln600">  &quot;tag&quot;,</a>
<a name="ln601">  route_set_tag,</a>
<a name="ln602">  route_map_rule_tag_compile,</a>
<a name="ln603">  route_map_rule_tag_free,</a>
<a name="ln604">};</a>
<a name="ln605"> </a>
<a name="ln606">DEFUN (match_ip_nexthop,</a>
<a name="ln607">       match_ip_nexthop_cmd,</a>
<a name="ln608">       &quot;match ip next-hop (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln609">       MATCH_STR</a>
<a name="ln610">       IP_STR</a>
<a name="ln611">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln612">       &quot;IP access-list number\n&quot;</a>
<a name="ln613">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln614">       &quot;IP access-list name\n&quot;)</a>
<a name="ln615">{</a>
<a name="ln616">  return ospf_route_match_add (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">DEFUN (no_match_ip_nexthop,</a>
<a name="ln620">       no_match_ip_nexthop_cmd,</a>
<a name="ln621">       &quot;no match ip next-hop&quot;,</a>
<a name="ln622">       NO_STR</a>
<a name="ln623">       MATCH_STR</a>
<a name="ln624">       IP_STR</a>
<a name="ln625">       &quot;Match next-hop address of route\n&quot;)</a>
<a name="ln626">{</a>
<a name="ln627">  if (argc == 0)</a>
<a name="ln628">    return ospf_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, NULL);</a>
<a name="ln629"> </a>
<a name="ln630">  return ospf_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">ALIAS (no_match_ip_nexthop,</a>
<a name="ln634">       no_match_ip_nexthop_val_cmd,</a>
<a name="ln635">       &quot;no match ip next-hop (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln636">       NO_STR</a>
<a name="ln637">       MATCH_STR</a>
<a name="ln638">       IP_STR</a>
<a name="ln639">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln640">       &quot;IP access-list number\n&quot;</a>
<a name="ln641">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln642">       &quot;IP access-list name\n&quot;)</a>
<a name="ln643"> </a>
<a name="ln644">DEFUN (match_ip_next_hop_prefix_list,</a>
<a name="ln645">       match_ip_next_hop_prefix_list_cmd,</a>
<a name="ln646">       &quot;match ip next-hop prefix-list WORD&quot;,</a>
<a name="ln647">       MATCH_STR</a>
<a name="ln648">       IP_STR</a>
<a name="ln649">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln650">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln651">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln652">{</a>
<a name="ln653">  return ospf_route_match_add (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;,</a>
<a name="ln654">			       argv[0]);</a>
<a name="ln655">}</a>
<a name="ln656"> </a>
<a name="ln657">DEFUN (no_match_ip_next_hop_prefix_list,</a>
<a name="ln658">       no_match_ip_next_hop_prefix_list_cmd,</a>
<a name="ln659">       &quot;no match ip next-hop prefix-list&quot;,</a>
<a name="ln660">       NO_STR</a>
<a name="ln661">       MATCH_STR</a>
<a name="ln662">       IP_STR</a>
<a name="ln663">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln664">       &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln665">{</a>
<a name="ln666">  if (argc == 0)</a>
<a name="ln667">    return ospf_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;,</a>
<a name="ln668">				    NULL);</a>
<a name="ln669">  return ospf_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;,</a>
<a name="ln670">				  argv[0]);</a>
<a name="ln671">}</a>
<a name="ln672"> </a>
<a name="ln673">ALIAS (no_match_ip_next_hop_prefix_list,</a>
<a name="ln674">       no_match_ip_next_hop_prefix_list_val_cmd,</a>
<a name="ln675">       &quot;no match ip next-hop prefix-list WORD&quot;,</a>
<a name="ln676">       NO_STR</a>
<a name="ln677">       MATCH_STR</a>
<a name="ln678">       IP_STR</a>
<a name="ln679">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln680">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln681">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln682"> </a>
<a name="ln683">DEFUN (match_ip_address,</a>
<a name="ln684">       match_ip_address_cmd,</a>
<a name="ln685">       &quot;match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln686">       MATCH_STR</a>
<a name="ln687">       IP_STR</a>
<a name="ln688">       &quot;Match address of route\n&quot;</a>
<a name="ln689">       &quot;IP access-list number\n&quot;</a>
<a name="ln690">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln691">       &quot;IP access-list name\n&quot;)</a>
<a name="ln692">{</a>
<a name="ln693">  return ospf_route_match_add (vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">DEFUN (no_match_ip_address,</a>
<a name="ln697">       no_match_ip_address_cmd,</a>
<a name="ln698">       &quot;no match ip address&quot;,</a>
<a name="ln699">       NO_STR</a>
<a name="ln700">       MATCH_STR</a>
<a name="ln701">       IP_STR</a>
<a name="ln702">       &quot;Match address of route\n&quot;)</a>
<a name="ln703">{</a>
<a name="ln704">  if (argc == 0)</a>
<a name="ln705">    return ospf_route_match_delete (vty, vty-&gt;index, &quot;ip address&quot;, NULL);</a>
<a name="ln706"> </a>
<a name="ln707">  return ospf_route_match_delete (vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">ALIAS (no_match_ip_address,</a>
<a name="ln711">       no_match_ip_address_val_cmd,</a>
<a name="ln712">       &quot;no match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln713">       NO_STR</a>
<a name="ln714">       MATCH_STR</a>
<a name="ln715">       IP_STR</a>
<a name="ln716">       &quot;Match address of route\n&quot;</a>
<a name="ln717">       &quot;IP access-list number\n&quot;</a>
<a name="ln718">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln719">       &quot;IP access-list name\n&quot;)</a>
<a name="ln720"> </a>
<a name="ln721">DEFUN (match_ip_address_prefix_list,</a>
<a name="ln722">       match_ip_address_prefix_list_cmd,</a>
<a name="ln723">       &quot;match ip address prefix-list WORD&quot;,</a>
<a name="ln724">       MATCH_STR</a>
<a name="ln725">       IP_STR</a>
<a name="ln726">       &quot;Match address of route\n&quot;</a>
<a name="ln727">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln728">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln729">{</a>
<a name="ln730">  return ospf_route_match_add (vty, vty-&gt;index, &quot;ip address prefix-list&quot;,</a>
<a name="ln731">			       argv[0]);</a>
<a name="ln732">}</a>
<a name="ln733"> </a>
<a name="ln734">DEFUN (no_match_ip_address_prefix_list,</a>
<a name="ln735">       no_match_ip_address_prefix_list_cmd,</a>
<a name="ln736">       &quot;no match ip address prefix-list&quot;,</a>
<a name="ln737">       NO_STR</a>
<a name="ln738">       MATCH_STR</a>
<a name="ln739">       IP_STR</a>
<a name="ln740">       &quot;Match address of route\n&quot;</a>
<a name="ln741">       &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln742">{</a>
<a name="ln743">  if (argc == 0)</a>
<a name="ln744">    return ospf_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;,</a>
<a name="ln745">				    NULL);</a>
<a name="ln746">  return ospf_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;,</a>
<a name="ln747">				  argv[0]);</a>
<a name="ln748">}</a>
<a name="ln749"> </a>
<a name="ln750">ALIAS (no_match_ip_address_prefix_list,</a>
<a name="ln751">       no_match_ip_address_prefix_list_val_cmd,</a>
<a name="ln752">       &quot;no match ip address prefix-list WORD&quot;,</a>
<a name="ln753">       NO_STR</a>
<a name="ln754">       MATCH_STR</a>
<a name="ln755">       IP_STR</a>
<a name="ln756">       &quot;Match address of route\n&quot;</a>
<a name="ln757">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln758">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln759"> </a>
<a name="ln760">DEFUN (match_interface,</a>
<a name="ln761">       match_interface_cmd,</a>
<a name="ln762">       &quot;match interface WORD&quot;,</a>
<a name="ln763">       MATCH_STR</a>
<a name="ln764">       &quot;Match first hop interface of route\n&quot;</a>
<a name="ln765">       &quot;Interface name\n&quot;)</a>
<a name="ln766">{</a>
<a name="ln767">  return ospf_route_match_add (vty, vty-&gt;index, &quot;interface&quot;, argv[0]);</a>
<a name="ln768">}</a>
<a name="ln769"> </a>
<a name="ln770">DEFUN (no_match_interface,</a>
<a name="ln771">       no_match_interface_cmd,</a>
<a name="ln772">       &quot;no match interface&quot;,</a>
<a name="ln773">       NO_STR</a>
<a name="ln774">       MATCH_STR</a>
<a name="ln775">       &quot;Match first hop interface of route\n&quot;)</a>
<a name="ln776">{</a>
<a name="ln777">  if (argc == 0)</a>
<a name="ln778">    return ospf_route_match_delete (vty, vty-&gt;index, &quot;interface&quot;, NULL);</a>
<a name="ln779"> </a>
<a name="ln780">  return ospf_route_match_delete (vty, vty-&gt;index, &quot;interface&quot;, argv[0]);</a>
<a name="ln781">}</a>
<a name="ln782"> </a>
<a name="ln783">ALIAS (no_match_interface,</a>
<a name="ln784">       no_match_interface_val_cmd,</a>
<a name="ln785">       &quot;no match interface WORD&quot;,</a>
<a name="ln786">       NO_STR</a>
<a name="ln787">       MATCH_STR</a>
<a name="ln788">       &quot;Match first hop interface of route\n&quot;</a>
<a name="ln789">       &quot;Interface name\n&quot;)</a>
<a name="ln790"> </a>
<a name="ln791">DEFUN (match_tag,</a>
<a name="ln792">       match_tag_cmd,</a>
<a name="ln793">       &quot;match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln794">       MATCH_STR</a>
<a name="ln795">       &quot;Match tag of route\n&quot;</a>
<a name="ln796">       &quot;Tag value\n&quot;)</a>
<a name="ln797">{</a>
<a name="ln798">  return ospf_route_match_add (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801">DEFUN (no_match_tag,</a>
<a name="ln802">       no_match_tag_cmd,</a>
<a name="ln803">       &quot;no match tag&quot;,</a>
<a name="ln804">       NO_STR</a>
<a name="ln805">       MATCH_STR</a>
<a name="ln806">       &quot;Match tag of route\n&quot;)</a>
<a name="ln807">{</a>
<a name="ln808">  if (argc == 0)</a>
<a name="ln809">    return ospf_route_match_delete (vty, vty-&gt;index, &quot;tag&quot;, NULL);</a>
<a name="ln810"> </a>
<a name="ln811">  return ospf_route_match_delete (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln812">}</a>
<a name="ln813"> </a>
<a name="ln814">ALIAS (no_match_tag,</a>
<a name="ln815">       no_match_tag_val_cmd,</a>
<a name="ln816">       &quot;no match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln817">       NO_STR</a>
<a name="ln818">       MATCH_STR</a>
<a name="ln819">       &quot;Match tag of route\n&quot;</a>
<a name="ln820">       &quot;Tag value\n&quot;)</a>
<a name="ln821"> </a>
<a name="ln822">DEFUN (set_metric,</a>
<a name="ln823">       set_metric_cmd,</a>
<a name="ln824">       &quot;set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln825">       SET_STR</a>
<a name="ln826">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln827">       &quot;Metric value\n&quot;)</a>
<a name="ln828">{</a>
<a name="ln829">  return ospf_route_set_add (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln830">}</a>
<a name="ln831"> </a>
<a name="ln832">DEFUN (no_set_metric,</a>
<a name="ln833">       no_set_metric_cmd,</a>
<a name="ln834">       &quot;no set metric&quot;,</a>
<a name="ln835">       NO_STR</a>
<a name="ln836">       SET_STR</a>
<a name="ln837">       &quot;Metric value for destination routing protocol\n&quot;)</a>
<a name="ln838">{</a>
<a name="ln839">  if (argc == 0)</a>
<a name="ln840">    return ospf_route_set_delete (vty, vty-&gt;index, &quot;metric&quot;, NULL);</a>
<a name="ln841"> </a>
<a name="ln842">  return ospf_route_set_delete (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">ALIAS (no_set_metric,</a>
<a name="ln846">       no_set_metric_val_cmd,</a>
<a name="ln847">       &quot;no set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln848">       NO_STR</a>
<a name="ln849">       SET_STR</a>
<a name="ln850">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln851">       &quot;Metric value\n&quot;)</a>
<a name="ln852"> </a>
<a name="ln853">DEFUN (set_metric_type,</a>
<a name="ln854">       set_metric_type_cmd,</a>
<a name="ln855">       &quot;set metric-type (type-1|type-2)&quot;,</a>
<a name="ln856">       SET_STR</a>
<a name="ln857">       &quot;Type of metric for destination routing protocol\n&quot;</a>
<a name="ln858">       &quot;OSPF[6] external type 1 metric\n&quot;</a>
<a name="ln859">       &quot;OSPF[6] external type 2 metric\n&quot;)</a>
<a name="ln860">{</a>
<a name="ln861">  if (strcmp (argv[0], &quot;1&quot;) == 0)</a>
<a name="ln862">    return ospf_route_set_add (vty, vty-&gt;index, &quot;metric-type&quot;, &quot;type-1&quot;);</a>
<a name="ln863">  if (strcmp (argv[0], &quot;2&quot;) == 0)</a>
<a name="ln864">    return ospf_route_set_add (vty, vty-&gt;index, &quot;metric-type&quot;, &quot;type-2&quot;);</a>
<a name="ln865"> </a>
<a name="ln866">  return ospf_route_set_add (vty, vty-&gt;index, &quot;metric-type&quot;, argv[0]);</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">DEFUN (no_set_metric_type,</a>
<a name="ln870">       no_set_metric_type_cmd,</a>
<a name="ln871">       &quot;no set metric-type&quot;,</a>
<a name="ln872">       NO_STR</a>
<a name="ln873">       SET_STR</a>
<a name="ln874">       &quot;Type of metric for destination routing protocol\n&quot;)</a>
<a name="ln875">{</a>
<a name="ln876">  if (argc == 0)</a>
<a name="ln877">    return ospf_route_set_delete (vty, vty-&gt;index, &quot;metric-type&quot;, NULL);</a>
<a name="ln878"> </a>
<a name="ln879">  return ospf_route_set_delete (vty, vty-&gt;index, &quot;metric-type&quot;, argv[0]);</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">ALIAS (no_set_metric_type,</a>
<a name="ln883">       no_set_metric_type_val_cmd,</a>
<a name="ln884">       &quot;no set metric-type (type-1|type-2)&quot;,</a>
<a name="ln885">       NO_STR</a>
<a name="ln886">       SET_STR</a>
<a name="ln887">       &quot;Type of metric for destination routing protocol\n&quot;</a>
<a name="ln888">       &quot;OSPF[6] external type 1 metric\n&quot;</a>
<a name="ln889">       &quot;OSPF[6] external type 2 metric\n&quot;)</a>
<a name="ln890"> </a>
<a name="ln891">DEFUN (set_tag,</a>
<a name="ln892">       set_tag_cmd,</a>
<a name="ln893">       &quot;set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln894">       SET_STR</a>
<a name="ln895">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln896">       &quot;Tag value\n&quot;)</a>
<a name="ln897">{</a>
<a name="ln898">  return ospf_route_set_add (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln899">}</a>
<a name="ln900"> </a>
<a name="ln901">DEFUN (no_set_tag,</a>
<a name="ln902">       no_set_tag_cmd,</a>
<a name="ln903">       &quot;no set tag&quot;,</a>
<a name="ln904">       NO_STR</a>
<a name="ln905">       SET_STR</a>
<a name="ln906">       &quot;Tag value for routing protocol\n&quot;)</a>
<a name="ln907">{</a>
<a name="ln908">  if (argc == 0)</a>
<a name="ln909">      ospf_route_set_delete(vty, vty-&gt;index, &quot;tag&quot;, NULL);</a>
<a name="ln910"> </a>
<a name="ln911">  return ospf_route_set_delete (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln912">}</a>
<a name="ln913"> </a>
<a name="ln914">ALIAS (no_set_tag,</a>
<a name="ln915">       no_set_tag_val_cmd,</a>
<a name="ln916">       &quot;no set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln917">       NO_STR</a>
<a name="ln918">       SET_STR</a>
<a name="ln919">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln920">       &quot;Tag value\n&quot;)</a>
<a name="ln921"> </a>
<a name="ln922">/* Route-map init */</a>
<a name="ln923">void</a>
<a name="ln924">ospf_route_map_init (void)</a>
<a name="ln925">{</a>
<a name="ln926">  route_map_init ();</a>
<a name="ln927">  route_map_init_vty ();</a>
<a name="ln928"> </a>
<a name="ln929">  route_map_add_hook (ospf_route_map_update);</a>
<a name="ln930">  route_map_delete_hook (ospf_route_map_update);</a>
<a name="ln931">  route_map_event_hook (ospf_route_map_event);</a>
<a name="ln932">  </a>
<a name="ln933">  route_map_install_match (&amp;route_match_ip_nexthop_cmd);</a>
<a name="ln934">  route_map_install_match (&amp;route_match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln935">  route_map_install_match (&amp;route_match_ip_address_cmd);</a>
<a name="ln936">  route_map_install_match (&amp;route_match_ip_address_prefix_list_cmd);</a>
<a name="ln937">  route_map_install_match (&amp;route_match_interface_cmd);</a>
<a name="ln938">  route_map_install_match (&amp;route_match_tag_cmd);</a>
<a name="ln939"> </a>
<a name="ln940">  route_map_install_set (&amp;route_set_metric_cmd);</a>
<a name="ln941">  route_map_install_set (&amp;route_set_metric_type_cmd);</a>
<a name="ln942">  route_map_install_set (&amp;route_set_tag_cmd);</a>
<a name="ln943"> </a>
<a name="ln944">  install_element (RMAP_NODE, &amp;match_ip_nexthop_cmd);</a>
<a name="ln945">  install_element (RMAP_NODE, &amp;no_match_ip_nexthop_cmd);</a>
<a name="ln946">  install_element (RMAP_NODE, &amp;no_match_ip_nexthop_val_cmd);</a>
<a name="ln947">  install_element (RMAP_NODE, &amp;match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln948">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln949">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_prefix_list_val_cmd);</a>
<a name="ln950">  install_element (RMAP_NODE, &amp;match_ip_address_cmd);</a>
<a name="ln951">  install_element (RMAP_NODE, &amp;no_match_ip_address_cmd);</a>
<a name="ln952">  install_element (RMAP_NODE, &amp;no_match_ip_address_val_cmd);</a>
<a name="ln953">  install_element (RMAP_NODE, &amp;match_ip_address_prefix_list_cmd);</a>
<a name="ln954">  install_element (RMAP_NODE, &amp;no_match_ip_address_prefix_list_cmd);</a>
<a name="ln955">  install_element (RMAP_NODE, &amp;no_match_ip_address_prefix_list_val_cmd);</a>
<a name="ln956">  install_element (RMAP_NODE, &amp;match_interface_cmd);</a>
<a name="ln957">  install_element (RMAP_NODE, &amp;no_match_interface_cmd);</a>
<a name="ln958">  install_element (RMAP_NODE, &amp;no_match_interface_val_cmd);</a>
<a name="ln959">  install_element (RMAP_NODE, &amp;match_tag_cmd);</a>
<a name="ln960">  install_element (RMAP_NODE, &amp;no_match_tag_cmd);</a>
<a name="ln961">  install_element (RMAP_NODE, &amp;no_match_tag_val_cmd);</a>
<a name="ln962"> </a>
<a name="ln963">  install_element (RMAP_NODE, &amp;set_metric_cmd);</a>
<a name="ln964">  install_element (RMAP_NODE, &amp;no_set_metric_cmd);</a>
<a name="ln965">  install_element (RMAP_NODE, &amp;no_set_metric_val_cmd);</a>
<a name="ln966">  install_element (RMAP_NODE, &amp;set_metric_type_cmd);</a>
<a name="ln967">  install_element (RMAP_NODE, &amp;no_set_metric_type_cmd);</a>
<a name="ln968">  install_element (RMAP_NODE, &amp;no_set_metric_type_val_cmd);</a>
<a name="ln969">  install_element (RMAP_NODE, &amp;set_tag_cmd);</a>
<a name="ln970">  install_element (RMAP_NODE, &amp;no_set_tag_cmd);</a>
<a name="ln971">  install_element (RMAP_NODE, &amp;no_set_tag_val_cmd);</a>
<a name="ln972">}</a>

</code></pre>
<div class="balloon" rel="10"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
