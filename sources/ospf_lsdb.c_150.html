
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_lsdb.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF LSDB support.</a>
<a name="ln3"> * Copyright (C) 1999, 2000 Alex Zinin, Kunihiro Ishiguro, Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;table.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;log.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln31">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln32">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln33">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">struct ospf_lsdb *</a>
<a name="ln36">ospf_lsdb_new ()</a>
<a name="ln37">{</a>
<a name="ln38">  struct ospf_lsdb *new;</a>
<a name="ln39"> </a>
<a name="ln40">  new = XCALLOC (MTYPE_OSPF_LSDB, sizeof (struct ospf_lsdb));</a>
<a name="ln41">  ospf_lsdb_init (new);</a>
<a name="ln42"> </a>
<a name="ln43">  return new;</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">void</a>
<a name="ln47">ospf_lsdb_init (struct ospf_lsdb *lsdb)</a>
<a name="ln48">{</a>
<a name="ln49">  int i;</a>
<a name="ln50">  </a>
<a name="ln51">  for (i = OSPF_MIN_LSA; i &lt; OSPF_MAX_LSA; i++)</a>
<a name="ln52">    lsdb-&gt;type[i].db = route_table_init ();</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">void</a>
<a name="ln56">ospf_lsdb_free (struct ospf_lsdb *lsdb)</a>
<a name="ln57">{</a>
<a name="ln58">  ospf_lsdb_cleanup (lsdb);</a>
<a name="ln59">  XFREE (MTYPE_OSPF_LSDB, lsdb);</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">void</a>
<a name="ln63">ospf_lsdb_cleanup (struct ospf_lsdb *lsdb)</a>
<a name="ln64">{</a>
<a name="ln65">  int i;</a>
<a name="ln66">  assert (lsdb);</a>
<a name="ln67">  assert (lsdb-&gt;total == 0);</a>
<a name="ln68"> </a>
<a name="ln69">  ospf_lsdb_delete_all (lsdb);</a>
<a name="ln70">  </a>
<a name="ln71">  for (i = OSPF_MIN_LSA; i &lt; OSPF_MAX_LSA; i++)</a>
<a name="ln72">    route_table_finish (lsdb-&gt;type[i].db);</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">void</a>
<a name="ln76">ls_prefix_set (struct prefix_ls *lp, struct ospf_lsa *lsa)</a>
<a name="ln77">{</a>
<a name="ln78">  if (lp &amp;&amp; lsa &amp;&amp; lsa-&gt;data)</a>
<a name="ln79">    {</a>
<a name="ln80">      lp-&gt;family = 0;</a>
<a name="ln81">      lp-&gt;prefixlen = 64;</a>
<a name="ln82">      lp-&gt;id = lsa-&gt;data-&gt;id;</a>
<a name="ln83">      lp-&gt;adv_router = lsa-&gt;data-&gt;adv_router;</a>
<a name="ln84">    }</a>
<a name="ln85">}</a>
<a name="ln86"> </a>
<a name="ln87">static void</a>
<a name="ln88">ospf_lsdb_delete_entry (struct ospf_lsdb *lsdb, struct route_node *rn)</a>
<a name="ln89">{</a>
<a name="ln90">  struct ospf_lsa *lsa = rn-&gt;info;</a>
<a name="ln91">  </a>
<a name="ln92">  if (!lsa)</a>
<a name="ln93">    return;</a>
<a name="ln94">  </a>
<a name="ln95">  assert (rn-&gt;table == lsdb-&gt;type[lsa-&gt;data-&gt;type].db);</a>
<a name="ln96">  </a>
<a name="ln97">  if (IS_LSA_SELF (lsa))</a>
<a name="ln98">    lsdb-&gt;type[lsa-&gt;data-&gt;type].count_self--;</a>
<a name="ln99">  lsdb-&gt;type[lsa-&gt;data-&gt;type].count--;</a>
<a name="ln100">  lsdb-&gt;type[lsa-&gt;data-&gt;type].checksum -= ntohs(lsa-&gt;data-&gt;checksum);</a>
<a name="ln101">  lsdb-&gt;total--;</a>
<a name="ln102">  rn-&gt;info = NULL;</a>
<a name="ln103">  route_unlock_node (rn);</a>
<a name="ln104">#ifdef MONITOR_LSDB_CHANGE</a>
<a name="ln105">  if (lsdb-&gt;del_lsa_hook != NULL)</a>
<a name="ln106">    (* lsdb-&gt;del_lsa_hook)(lsa);</a>
<a name="ln107">#endif /* MONITOR_LSDB_CHANGE */</a>
<a name="ln108">  ospf_lsa_unlock (&amp;lsa); /* lsdb */</a>
<a name="ln109">  return;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">/* Add new LSA to lsdb. */</a>
<a name="ln113">void</a>
<a name="ln114">ospf_lsdb_add (struct ospf_lsdb *lsdb, struct ospf_lsa *lsa)</a>
<a name="ln115">{</a>
<a name="ln116">  struct route_table *table;</a>
<a name="ln117">  struct prefix_ls lp;</a>
<a name="ln118">  struct route_node *rn;</a>
<a name="ln119"> </a>
<a name="ln120">  table = lsdb-&gt;type[lsa-&gt;data-&gt;type].db;</a>
<a name="ln121">  ls_prefix_set (&amp;lp, lsa);</a>
<a name="ln122">  rn = route_node_get (table, (struct prefix *)&amp;lp);</a>
<a name="ln123">  </a>
<a name="ln124">  /* nothing to do? */</a>
<a name="ln125">  if (rn-&gt;info &amp;&amp; rn-&gt;info == lsa)</a>
<a name="ln126">    {</a>
<a name="ln127">      route_unlock_node (rn);</a>
<a name="ln128">      return;</a>
<a name="ln129">    }</a>
<a name="ln130">  </a>
<a name="ln131">  /* purge old entry? */</a>
<a name="ln132">  if (rn-&gt;info)</a>
<a name="ln133">    ospf_lsdb_delete_entry (lsdb, rn);</a>
<a name="ln134"> </a>
<a name="ln135">  if (IS_LSA_SELF (lsa))</a>
<a name="ln136">    lsdb-&gt;type[lsa-&gt;data-&gt;type].count_self++;</a>
<a name="ln137">  lsdb-&gt;type[lsa-&gt;data-&gt;type].count++;</a>
<a name="ln138">  lsdb-&gt;total++;</a>
<a name="ln139"> </a>
<a name="ln140">#ifdef MONITOR_LSDB_CHANGE</a>
<a name="ln141">  if (lsdb-&gt;new_lsa_hook != NULL)</a>
<a name="ln142">    (* lsdb-&gt;new_lsa_hook)(lsa);</a>
<a name="ln143">#endif /* MONITOR_LSDB_CHANGE */</a>
<a name="ln144">  lsdb-&gt;type[lsa-&gt;data-&gt;type].checksum += ntohs(lsa-&gt;data-&gt;checksum);</a>
<a name="ln145">  rn-&gt;info = ospf_lsa_lock (lsa); /* lsdb */</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">void</a>
<a name="ln149">ospf_lsdb_delete (struct ospf_lsdb *lsdb, struct ospf_lsa *lsa)</a>
<a name="ln150">{</a>
<a name="ln151">  struct route_table *table;</a>
<a name="ln152">  struct prefix_ls lp;</a>
<a name="ln153">  struct route_node *rn;</a>
<a name="ln154"> </a>
<a name="ln155">  if (!lsdb)</a>
<a name="ln156">    {</a>
<a name="ln157">      zlog_warn (&quot;%s: Called with NULL LSDB&quot;, __func__);</a>
<a name="ln158">      if (lsa)</a>
<a name="ln159">        zlog_warn (&quot;LSA[Type%d:%s]: LSA %p, lsa-&gt;lsdb %p&quot;,</a>
<a name="ln160">                   lsa-&gt;data-&gt;type, inet_ntoa (lsa-&gt;data-&gt;id),</a>
<a name="ln161">                   (void *)lsa, (void *)lsa-&gt;lsdb);</a>
<a name="ln162">      return;</a>
<a name="ln163">    }</a>
<a name="ln164">  </a>
<a name="ln165">  if (!lsa)</a>
<a name="ln166">    {</a>
<a name="ln167">      zlog_warn (&quot;%s: Called with NULL LSA&quot;, __func__);</a>
<a name="ln168">      return;</a>
<a name="ln169">    }</a>
<a name="ln170">  </a>
<a name="ln171">  assert (lsa-&gt;data-&gt;type &lt; OSPF_MAX_LSA);</a>
<a name="ln172">  table = lsdb-&gt;type[lsa-&gt;data-&gt;type].db;</a>
<a name="ln173">  ls_prefix_set (&amp;lp, lsa);</a>
<a name="ln174">  if ((rn = route_node_lookup (table, (struct prefix *) &amp;lp)))</a>
<a name="ln175">    {</a>
<a name="ln176">      if (rn-&gt;info == lsa)</a>
<a name="ln177">        ospf_lsdb_delete_entry (lsdb, rn);</a>
<a name="ln178">      route_unlock_node (rn); /* route_node_lookup */</a>
<a name="ln179">    }</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">void</a>
<a name="ln183">ospf_lsdb_delete_all (struct ospf_lsdb *lsdb)</a>
<a name="ln184">{</a>
<a name="ln185">  struct route_table *table;</a>
<a name="ln186">  struct route_node *rn;</a>
<a name="ln187">  int i;</a>
<a name="ln188"> </a>
<a name="ln189">  for (i = OSPF_MIN_LSA; i &lt; OSPF_MAX_LSA; i++)</a>
<a name="ln190">    {</a>
<a name="ln191">      table = lsdb-&gt;type[i].db;</a>
<a name="ln192">      for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln193">	if (rn-&gt;info != NULL)</a>
<a name="ln194">	  ospf_lsdb_delete_entry (lsdb, rn);</a>
<a name="ln195">    }</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">void</a>
<a name="ln199">ospf_lsdb_clean_stat (struct ospf_lsdb *lsdb)</a>
<a name="ln200">{</a>
<a name="ln201">  struct route_table *table;</a>
<a name="ln202">  struct route_node *rn;</a>
<a name="ln203">  struct ospf_lsa *lsa;</a>
<a name="ln204">  int i;</a>
<a name="ln205"> </a>
<a name="ln206">  for (i = OSPF_MIN_LSA; i &lt; OSPF_MAX_LSA; i++)</a>
<a name="ln207">    {</a>
<a name="ln208">      table = lsdb-&gt;type[i].db;</a>
<a name="ln209">      for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln210">	if ((lsa = (rn-&gt;info)) != NULL)</a>
<a name="ln211">	  lsa-&gt;stat = LSA_SPF_NOT_EXPLORED;</a>
<a name="ln212">    }</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">struct ospf_lsa *</a>
<a name="ln216">ospf_lsdb_lookup (struct ospf_lsdb *lsdb, struct ospf_lsa *lsa)</a>
<a name="ln217">{</a>
<a name="ln218">  struct route_table *table;</a>
<a name="ln219">  struct prefix_ls lp;</a>
<a name="ln220">  struct route_node *rn;</a>
<a name="ln221">  struct ospf_lsa *find;</a>
<a name="ln222"> </a>
<a name="ln223">  table = lsdb-&gt;type[lsa-&gt;data-&gt;type].db;</a>
<a name="ln224">  ls_prefix_set (&amp;lp, lsa);</a>
<a name="ln225">  rn = route_node_lookup (table, (struct prefix *) &amp;lp);</a>
<a name="ln226">  if (rn)</a>
<a name="ln227">    {</a>
<a name="ln228">      find = rn-&gt;info;</a>
<a name="ln229">      route_unlock_node (rn);</a>
<a name="ln230">      return find;</a>
<a name="ln231">    }</a>
<a name="ln232">  return NULL;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">struct ospf_lsa *</a>
<a name="ln236">ospf_lsdb_lookup_by_id (struct ospf_lsdb *lsdb, u_char type,</a>
<a name="ln237">		       struct in_addr id, struct in_addr adv_router)</a>
<a name="ln238">{</a>
<a name="ln239">  struct route_table *table;</a>
<a name="ln240">  struct prefix_ls lp;</a>
<a name="ln241">  struct route_node *rn;</a>
<a name="ln242">  struct ospf_lsa *find;</a>
<a name="ln243"> </a>
<a name="ln244">  table = lsdb-&gt;type[type].db;</a>
<a name="ln245"> </a>
<a name="ln246">  memset (&amp;lp, 0, sizeof (struct prefix_ls));</a>
<a name="ln247">  lp.family = 0;</a>
<a name="ln248">  lp.prefixlen = 64;</a>
<a name="ln249">  lp.id = id;</a>
<a name="ln250">  lp.adv_router = adv_router;</a>
<a name="ln251"> </a>
<a name="ln252">  rn = route_node_lookup (table, (struct prefix *) &amp;lp);</a>
<a name="ln253">  if (rn)</a>
<a name="ln254">    {</a>
<a name="ln255">      find = rn-&gt;info;</a>
<a name="ln256">      route_unlock_node (rn);</a>
<a name="ln257">      return find;</a>
<a name="ln258">    }</a>
<a name="ln259">  return NULL;</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">struct ospf_lsa *</a>
<a name="ln263">ospf_lsdb_lookup_by_id_next (struct ospf_lsdb *lsdb, u_char type,</a>
<a name="ln264">			    struct in_addr id, struct in_addr adv_router,</a>
<a name="ln265">			    int first)</a>
<a name="ln266">{</a>
<a name="ln267">  struct route_table *table;</a>
<a name="ln268">  struct prefix_ls lp;</a>
<a name="ln269">  struct route_node *rn;</a>
<a name="ln270">  struct ospf_lsa *find;</a>
<a name="ln271"> </a>
<a name="ln272">  table = lsdb-&gt;type[type].db;</a>
<a name="ln273"> </a>
<a name="ln274">  memset (&amp;lp, 0, sizeof (struct prefix_ls));</a>
<a name="ln275">  lp.family = 0;</a>
<a name="ln276">  lp.prefixlen = 64;</a>
<a name="ln277">  lp.id = id;</a>
<a name="ln278">  lp.adv_router = adv_router;</a>
<a name="ln279"> </a>
<a name="ln280">  if (first)</a>
<a name="ln281">      rn = route_top (table);</a>
<a name="ln282">  else</a>
<a name="ln283">    {</a>
<a name="ln284">      if ((rn = route_node_lookup (table, (struct prefix *) &amp;lp)) == NULL)</a>
<a name="ln285">        return NULL;</a>
<a name="ln286">      rn = route_next (rn);</a>
<a name="ln287">    }</a>
<a name="ln288"> </a>
<a name="ln289">  for (; rn; rn = route_next (rn))</a>
<a name="ln290">    if (rn-&gt;info)</a>
<a name="ln291">      break;</a>
<a name="ln292"> </a>
<a name="ln293">  if (rn &amp;&amp; rn-&gt;info)</a>
<a name="ln294">    {</a>
<a name="ln295">      find = rn-&gt;info;</a>
<a name="ln296">      route_unlock_node (rn);</a>
<a name="ln297">      return find;</a>
<a name="ln298">    }</a>
<a name="ln299">  return NULL;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">unsigned long</a>
<a name="ln303">ospf_lsdb_count_all (struct ospf_lsdb *lsdb)</a>
<a name="ln304">{</a>
<a name="ln305">  return lsdb-&gt;total;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">unsigned long</a>
<a name="ln309">ospf_lsdb_count (struct ospf_lsdb *lsdb, int type)</a>
<a name="ln310">{</a>
<a name="ln311">  return lsdb-&gt;type[type].count;</a>
<a name="ln312">}</a>
<a name="ln313"> </a>
<a name="ln314">unsigned long</a>
<a name="ln315">ospf_lsdb_count_self (struct ospf_lsdb *lsdb, int type)</a>
<a name="ln316">{</a>
<a name="ln317">  return lsdb-&gt;type[type].count_self;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">unsigned int</a>
<a name="ln321">ospf_lsdb_checksum (struct ospf_lsdb *lsdb, int type)</a>
<a name="ln322">{</a>
<a name="ln323">  return lsdb-&gt;type[type].checksum;</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">unsigned long</a>
<a name="ln327">ospf_lsdb_isempty (struct ospf_lsdb *lsdb)</a>
<a name="ln328">{</a>
<a name="ln329">  return (lsdb-&gt;total == 0);</a>
<a name="ln330">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
