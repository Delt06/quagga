
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_packet.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP packet handling functions</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln11">#include &quot;nhrpd.h&quot;</a>
<a name="ln12">#include &quot;zbuf.h&quot;</a>
<a name="ln13">#include &quot;thread.h&quot;</a>
<a name="ln14">#include &quot;hash.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;nhrp_protocol.h&quot;</a>
<a name="ln17">#include &quot;os.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">struct nhrp_reqid_pool nhrp_packet_reqid;</a>
<a name="ln20"> </a>
<a name="ln21">static uint16_t family2proto(int family)</a>
<a name="ln22">{</a>
<a name="ln23">	switch (family) {</a>
<a name="ln24">	case AF_INET: return ETH_P_IP;</a>
<a name="ln25">	case AF_INET6: return ETH_P_IPV6;</a>
<a name="ln26">	}</a>
<a name="ln27">	return 0;</a>
<a name="ln28">}</a>
<a name="ln29"> </a>
<a name="ln30">static int proto2family(uint16_t proto)</a>
<a name="ln31">{</a>
<a name="ln32">	switch (proto) {</a>
<a name="ln33">	case ETH_P_IP: return AF_INET;</a>
<a name="ln34">	case ETH_P_IPV6: return AF_INET6;</a>
<a name="ln35">	}</a>
<a name="ln36">	return AF_UNSPEC;</a>
<a name="ln37">}</a>
<a name="ln38"> </a>
<a name="ln39">struct nhrp_packet_header *nhrp_packet_push(</a>
<a name="ln40">	struct zbuf *zb, uint8_t type,</a>
<a name="ln41">	const union sockunion *src_nbma,</a>
<a name="ln42">	const union sockunion *src_proto,</a>
<a name="ln43">	const union sockunion *dst_proto)</a>
<a name="ln44">{</a>
<a name="ln45">	struct nhrp_packet_header *hdr;</a>
<a name="ln46"> </a>
<a name="ln47">	hdr = zbuf_push(zb, struct nhrp_packet_header);</a>
<a name="ln48">	if (!hdr) return NULL;</a>
<a name="ln49"> </a>
<a name="ln50">	*hdr = (struct nhrp_packet_header) {</a>
<a name="ln51">		.afnum = htons(family2afi(sockunion_family(src_nbma))),</a>
<a name="ln52">		.protocol_type = htons(family2proto(sockunion_family(src_proto))),</a>
<a name="ln53">		.version = NHRP_VERSION_RFC2332,</a>
<a name="ln54">		.type = type,</a>
<a name="ln55">		.hop_count = 64,</a>
<a name="ln56">		.src_nbma_address_len = sockunion_get_addrlen(src_nbma),</a>
<a name="ln57">		.src_protocol_address_len = sockunion_get_addrlen(src_proto),</a>
<a name="ln58">		.dst_protocol_address_len = sockunion_get_addrlen(dst_proto),</a>
<a name="ln59">	};</a>
<a name="ln60"> </a>
<a name="ln61">	zbuf_put(zb, sockunion_get_addr(src_nbma), hdr-&gt;src_nbma_address_len);</a>
<a name="ln62">	zbuf_put(zb, sockunion_get_addr(src_proto), hdr-&gt;src_protocol_address_len);</a>
<a name="ln63">	zbuf_put(zb, sockunion_get_addr(dst_proto), hdr-&gt;dst_protocol_address_len);</a>
<a name="ln64"> </a>
<a name="ln65">	return hdr;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">struct nhrp_packet_header *nhrp_packet_pull(</a>
<a name="ln69">	struct zbuf *zb,</a>
<a name="ln70">	union sockunion *src_nbma,</a>
<a name="ln71">	union sockunion *src_proto,</a>
<a name="ln72">	union sockunion *dst_proto)</a>
<a name="ln73">{</a>
<a name="ln74">	struct nhrp_packet_header *hdr;</a>
<a name="ln75"> </a>
<a name="ln76">	hdr = zbuf_pull(zb, struct nhrp_packet_header);</a>
<a name="ln77">	if (!hdr) return NULL;</a>
<a name="ln78"> </a>
<a name="ln79">	sockunion_set(</a>
<a name="ln80">		src_nbma, afi2family(htons(hdr-&gt;afnum)),</a>
<a name="ln81">		zbuf_pulln(zb, hdr-&gt;src_nbma_address_len + hdr-&gt;src_nbma_subaddress_len),</a>
<a name="ln82">		hdr-&gt;src_nbma_address_len + hdr-&gt;src_nbma_subaddress_len);</a>
<a name="ln83">	sockunion_set(</a>
<a name="ln84">		src_proto, proto2family(htons(hdr-&gt;protocol_type)),</a>
<a name="ln85">		zbuf_pulln(zb, hdr-&gt;src_protocol_address_len),</a>
<a name="ln86">		hdr-&gt;src_protocol_address_len);</a>
<a name="ln87">	sockunion_set(</a>
<a name="ln88">		dst_proto, proto2family(htons(hdr-&gt;protocol_type)),</a>
<a name="ln89">		zbuf_pulln(zb, hdr-&gt;dst_protocol_address_len),</a>
<a name="ln90">		hdr-&gt;dst_protocol_address_len);</a>
<a name="ln91"> </a>
<a name="ln92">	return hdr;</a>
<a name="ln93">}</a>
<a name="ln94"> </a>
<a name="ln95">uint16_t nhrp_packet_calculate_checksum(const uint8_t *pdu, uint16_t len)</a>
<a name="ln96">{</a>
<a name="ln97">	const uint16_t *pdu16 = (const uint16_t *) pdu;</a>
<a name="ln98">	uint32_t csum = 0;</a>
<a name="ln99">	int i;</a>
<a name="ln100"> </a>
<a name="ln101">	for (i = 0; i &lt; len / 2; i++)</a>
<a name="ln102">		csum += pdu16[i];</a>
<a name="ln103">	if (len &amp; 1)</a>
<a name="ln104">		csum += htons(pdu[len - 1]);</a>
<a name="ln105"> </a>
<a name="ln106">	while (csum &amp; 0xffff0000)</a>
<a name="ln107">		csum = (csum &amp; 0xffff) + (csum &gt;&gt; 16);</a>
<a name="ln108"> </a>
<a name="ln109">	return (~csum) &amp; 0xffff;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">void nhrp_packet_complete(struct zbuf *zb, struct nhrp_packet_header *hdr)</a>
<a name="ln113">{</a>
<a name="ln114">	unsigned short size;</a>
<a name="ln115"> </a>
<a name="ln116">	if (hdr-&gt;extension_offset)</a>
<a name="ln117">		nhrp_ext_push(zb, hdr, NHRP_EXTENSION_END | NHRP_EXTENSION_FLAG_COMPULSORY);</a>
<a name="ln118"> </a>
<a name="ln119">	size = zb-&gt;tail - (uint8_t *)hdr;</a>
<a name="ln120">	hdr-&gt;packet_size = htons(size);</a>
<a name="ln121">	hdr-&gt;checksum = 0;</a>
<a name="ln122">	hdr-&gt;checksum = nhrp_packet_calculate_checksum((uint8_t *) hdr, size);</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">struct nhrp_cie_header *nhrp_cie_push(</a>
<a name="ln126">	struct zbuf *zb,</a>
<a name="ln127">	uint8_t code,</a>
<a name="ln128">	const union sockunion *nbma,</a>
<a name="ln129">	const union sockunion *proto)</a>
<a name="ln130">{</a>
<a name="ln131">	struct nhrp_cie_header *cie;</a>
<a name="ln132"> </a>
<a name="ln133">	cie = zbuf_push(zb, struct nhrp_cie_header);</a>
<a name="ln134">	*cie = (struct nhrp_cie_header) {</a>
<a name="ln135">		.code = code,</a>
<a name="ln136">	};</a>
<a name="ln137">	if (nbma) {</a>
<a name="ln138">		cie-&gt;nbma_address_len = sockunion_get_addrlen(nbma);</a>
<a name="ln139">		zbuf_put(zb, sockunion_get_addr(nbma), cie-&gt;nbma_address_len);</a>
<a name="ln140">	}</a>
<a name="ln141">	if (proto) {</a>
<a name="ln142">		cie-&gt;protocol_address_len = sockunion_get_addrlen(proto);</a>
<a name="ln143">		zbuf_put(zb, sockunion_get_addr(proto), cie-&gt;protocol_address_len);</a>
<a name="ln144">	}</a>
<a name="ln145"> </a>
<a name="ln146">	return cie;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">struct nhrp_cie_header *nhrp_cie_pull(</a>
<a name="ln150">	struct zbuf *zb,</a>
<a name="ln151">	struct nhrp_packet_header *hdr,</a>
<a name="ln152">	union sockunion *nbma,</a>
<a name="ln153">	union sockunion *proto)</a>
<a name="ln154">{</a>
<a name="ln155">	struct nhrp_cie_header *cie;</a>
<a name="ln156"> </a>
<a name="ln157">	cie = zbuf_pull(zb, struct nhrp_cie_header);</a>
<a name="ln158">	if (!cie) return NULL;</a>
<a name="ln159"> </a>
<a name="ln160">	if (cie-&gt;nbma_address_len + cie-&gt;nbma_subaddress_len) {</a>
<a name="ln161">		sockunion_set(</a>
<a name="ln162">			nbma, afi2family(htons(hdr-&gt;afnum)),</a>
<a name="ln163">			zbuf_pulln(zb, cie-&gt;nbma_address_len + cie-&gt;nbma_subaddress_len),</a>
<a name="ln164">			cie-&gt;nbma_address_len + cie-&gt;nbma_subaddress_len);</a>
<a name="ln165">	} else {</a>
<a name="ln166">		sockunion_family(nbma) = AF_UNSPEC;</a>
<a name="ln167">	}</a>
<a name="ln168"> </a>
<a name="ln169">	if (cie-&gt;protocol_address_len) {</a>
<a name="ln170">		sockunion_set(</a>
<a name="ln171">			proto, proto2family(htons(hdr-&gt;protocol_type)),</a>
<a name="ln172">			zbuf_pulln(zb, cie-&gt;protocol_address_len),</a>
<a name="ln173">			cie-&gt;protocol_address_len);</a>
<a name="ln174">	} else {</a>
<a name="ln175">		sockunion_family(proto) = AF_UNSPEC;</a>
<a name="ln176">	}</a>
<a name="ln177"> </a>
<a name="ln178">	return cie;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181">struct nhrp_extension_header *nhrp_ext_push(struct zbuf *zb, struct nhrp_packet_header *hdr, uint16_t type)</a>
<a name="ln182">{</a>
<a name="ln183">	struct nhrp_extension_header *ext;</a>
<a name="ln184">	ext = zbuf_push(zb, struct nhrp_extension_header);</a>
<a name="ln185">	if (!ext) return NULL;</a>
<a name="ln186"> </a>
<a name="ln187">	if (!hdr-&gt;extension_offset)</a>
<a name="ln188">		hdr-&gt;extension_offset = htons(zb-&gt;tail - (uint8_t*) hdr - sizeof(struct nhrp_extension_header));</a>
<a name="ln189"> </a>
<a name="ln190">	*ext = (struct nhrp_extension_header) {</a>
<a name="ln191">		.type = htons(type),</a>
<a name="ln192">		.length = 0,</a>
<a name="ln193">	};</a>
<a name="ln194">	return ext;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">void nhrp_ext_complete(struct zbuf *zb, struct nhrp_extension_header *ext)</a>
<a name="ln198">{</a>
<a name="ln199">	ext-&gt;length = htons(zb-&gt;tail - (uint8_t*)ext - sizeof(struct nhrp_extension_header));</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">struct nhrp_extension_header *nhrp_ext_pull(struct zbuf *zb, struct zbuf *payload)</a>
<a name="ln203">{</a>
<a name="ln204">	struct nhrp_extension_header *ext;</a>
<a name="ln205">	uint16_t plen;</a>
<a name="ln206"> </a>
<a name="ln207">	ext = zbuf_pull(zb, struct nhrp_extension_header);</a>
<a name="ln208">	if (!ext) return NULL;</a>
<a name="ln209"> </a>
<a name="ln210">	plen = htons(ext-&gt;length);</a>
<a name="ln211">	zbuf_init(payload, zbuf_pulln(zb, plen), plen, plen);</a>
<a name="ln212">	return ext;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">void nhrp_ext_request(struct zbuf *zb, struct nhrp_packet_header *hdr, struct interface *ifp)</a>
<a name="ln216">{</a>
<a name="ln217">	/* Place holders for standard extensions */</a>
<a name="ln218">	nhrp_ext_push(zb, hdr, NHRP_EXTENSION_FORWARD_TRANSIT_NHS | NHRP_EXTENSION_FLAG_COMPULSORY);</a>
<a name="ln219">	nhrp_ext_push(zb, hdr, NHRP_EXTENSION_REVERSE_TRANSIT_NHS | NHRP_EXTENSION_FLAG_COMPULSORY);</a>
<a name="ln220">	nhrp_ext_push(zb, hdr, NHRP_EXTENSION_RESPONDER_ADDRESS | NHRP_EXTENSION_FLAG_COMPULSORY);</a>
<a name="ln221">}</a>
<a name="ln222"> </a>
<a name="ln223">int nhrp_ext_reply(struct zbuf *zb, struct nhrp_packet_header *hdr, struct interface *ifp, struct nhrp_extension_header *ext, struct zbuf *extpayload)</a>
<a name="ln224">{</a>
<a name="ln225">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln226">	struct nhrp_afi_data *ad = &amp;nifp-&gt;afi[htons(hdr-&gt;afnum)];</a>
<a name="ln227">	struct nhrp_extension_header *dst;</a>
<a name="ln228">	struct nhrp_cie_header *cie;</a>
<a name="ln229">	uint16_t type;</a>
<a name="ln230"> </a>
<a name="ln231">	type = htons(ext-&gt;type) &amp; ~NHRP_EXTENSION_FLAG_COMPULSORY;</a>
<a name="ln232">	if (type == NHRP_EXTENSION_END)</a>
<a name="ln233">		return 0;</a>
<a name="ln234"> </a>
<a name="ln235">	dst = nhrp_ext_push(zb, hdr, htons(ext-&gt;type));</a>
<a name="ln236">	if (!dst) goto err;</a>
<a name="ln237"> </a>
<a name="ln238">	switch (type) {</a>
<a name="ln239">	case NHRP_EXTENSION_RESPONDER_ADDRESS:</a>
<a name="ln240">		cie = nhrp_cie_push(zb, NHRP_CODE_SUCCESS, &amp;nifp-&gt;nbma, &amp;ad-&gt;addr);</a>
<a name="ln241">		if (!cie) goto err;</a>
<a name="ln242">		cie-&gt;holding_time = htons(ad-&gt;holdtime);</a>
<a name="ln243">		break;</a>
<a name="ln244">	default:</a>
<a name="ln245">		if (type &amp; NHRP_EXTENSION_FLAG_COMPULSORY)</a>
<a name="ln246">			goto err;</a>
<a name="ln247">	case NHRP_EXTENSION_FORWARD_TRANSIT_NHS:</a>
<a name="ln248">	case NHRP_EXTENSION_REVERSE_TRANSIT_NHS:</a>
<a name="ln249">		/* Supported compulsory extensions, and any</a>
<a name="ln250">		 * non-compulsory that is not explicitly handled,</a>
<a name="ln251">		 * should be just copied. */</a>
<a name="ln252">		zbuf_copy(zb, extpayload, zbuf_used(extpayload));</a>
<a name="ln253">		break;</a>
<a name="ln254">	}</a>
<a name="ln255">	nhrp_ext_complete(zb, dst);</a>
<a name="ln256">	return 0;</a>
<a name="ln257">err:</a>
<a name="ln258">	zbuf_set_werror(zb);</a>
<a name="ln259">	return -1;</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">static int nhrp_packet_recvraw(struct thread *t)</a>
<a name="ln263">{</a>
<a name="ln264">	int fd = THREAD_FD(t), ifindex;</a>
<a name="ln265">	struct zbuf *zb;</a>
<a name="ln266">	struct interface *ifp;</a>
<a name="ln267">	struct nhrp_peer *p;</a>
<a name="ln268">	union sockunion remote_nbma;</a>
<a name="ln269">	uint8_t addr[64];</a>
<a name="ln270">	size_t len, addrlen;</a>
<a name="ln271"> </a>
<a name="ln272">	thread_add_read(master, nhrp_packet_recvraw, 0, fd);</a>
<a name="ln273"> </a>
<a name="ln274">	zb = zbuf_alloc(1500);</a>
<a name="ln275">	if (!zb) return 0;</a>
<a name="ln276"> </a>
<a name="ln277">	len = zbuf_size(zb);</a>
<a name="ln278">	addrlen = sizeof(addr);</a>
<a name="ln279">	if (os_recvmsg(zb-&gt;buf, &amp;len, &amp;ifindex, addr, &amp;addrlen) &lt; 0)</a>
<a name="ln280">		goto err;</a>
<a name="ln281"> </a>
<a name="ln282">	zb-&gt;head = zb-&gt;buf;</a>
<a name="ln283">	zb-&gt;tail = zb-&gt;buf + len;</a>
<a name="ln284"> </a>
<a name="ln285">	switch (addrlen) {</a>
<a name="ln286">	case 4:</a>
<a name="ln287">		sockunion_set(&amp;remote_nbma, AF_INET, addr, addrlen);</a>
<a name="ln288">		break;</a>
<a name="ln289">	default:</a>
<a name="ln290">		goto err;</a>
<a name="ln291">	}</a>
<a name="ln292"> </a>
<a name="ln293">	ifp = if_lookup_by_index(ifindex);</a>
<a name="ln294">	if (!ifp) goto err;</a>
<a name="ln295"> </a>
<a name="ln296">	p = nhrp_peer_get(ifp, &amp;remote_nbma);</a>
<a name="ln297">	if (!p) goto err;</a>
<a name="ln298"> </a>
<a name="ln299">	nhrp_peer_recv(p, zb);</a>
<a name="ln300">	nhrp_peer_unref(p);</a>
<a name="ln301">	return 0;</a>
<a name="ln302"> </a>
<a name="ln303">err:</a>
<a name="ln304">	zbuf_free(zb);</a>
<a name="ln305">	return 0;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">int nhrp_packet_init(void)</a>
<a name="ln309">{</a>
<a name="ln310">	thread_add_read(master, nhrp_packet_recvraw, 0, os_socket());</a>
<a name="ln311">	return 0;</a>
<a name="ln312">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="160"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v793/" target="_blank">V793</a> It is odd that the result of the '+' operator is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
