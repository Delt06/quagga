
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>hash.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Hash routine.</a>
<a name="ln2"> * Copyright (C) 1998 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln7"> * it under the terms of the GNU General Public License as published</a>
<a name="ln8"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln9"> * option) any later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln18"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln19"> * Boston, MA 02111-1307, USA.</a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;hash.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">/* Allocate a new hash.  */</a>
<a name="ln28">struct hash *</a>
<a name="ln29">hash_create_size (unsigned int size, unsigned int (*hash_key) (void *),</a>
<a name="ln30">                                     int (*hash_cmp) (const void *, const void *))</a>
<a name="ln31">{</a>
<a name="ln32">  struct hash *hash;</a>
<a name="ln33"> </a>
<a name="ln34">  assert ((size &amp; (size-1)) == 0);</a>
<a name="ln35">  hash = XMALLOC (MTYPE_HASH, sizeof (struct hash));</a>
<a name="ln36">  hash-&gt;index = XCALLOC (MTYPE_HASH_INDEX,</a>
<a name="ln37">			 sizeof (struct hash_backet *) * size);</a>
<a name="ln38">  hash-&gt;size = size;</a>
<a name="ln39">  hash-&gt;no_expand = 0;</a>
<a name="ln40">  hash-&gt;hash_key = hash_key;</a>
<a name="ln41">  hash-&gt;hash_cmp = hash_cmp;</a>
<a name="ln42">  hash-&gt;count = 0;</a>
<a name="ln43"> </a>
<a name="ln44">  return hash;</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">/* Allocate a new hash with default hash size.  */</a>
<a name="ln48">struct hash *</a>
<a name="ln49">hash_create (unsigned int (*hash_key) (void *), </a>
<a name="ln50">             int (*hash_cmp) (const void *, const void *))</a>
<a name="ln51">{</a>
<a name="ln52">  return hash_create_size (HASH_INITIAL_SIZE, hash_key, hash_cmp);</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">/* Utility function for hash_get().  When this function is specified</a>
<a name="ln56">   as alloc_func, return arugment as it is.  This function is used for</a>
<a name="ln57">   intern already allocated value.  */</a>
<a name="ln58">void *</a>
<a name="ln59">hash_alloc_intern (void *arg)</a>
<a name="ln60">{</a>
<a name="ln61">  return arg;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">/* Expand hash if the chain length exceeds the threshold. */</a>
<a name="ln65">static void hash_expand (struct hash *hash)</a>
<a name="ln66">{</a>
<a name="ln67">  unsigned int i, new_size, losers;</a>
<a name="ln68">  struct hash_backet *hb, *hbnext, **new_index;</a>
<a name="ln69"> </a>
<a name="ln70">  new_size = hash-&gt;size * 2;</a>
<a name="ln71">  new_index = XCALLOC(MTYPE_HASH_INDEX, sizeof(struct hash_backet *) * new_size);</a>
<a name="ln72">  if (new_index == NULL)</a>
<a name="ln73">    return;</a>
<a name="ln74"> </a>
<a name="ln75">  for (i = 0; i &lt; hash-&gt;size; i++)</a>
<a name="ln76">    for (hb = hash-&gt;index[i]; hb; hb = hbnext)</a>
<a name="ln77">      {</a>
<a name="ln78">	unsigned int h = hb-&gt;key &amp; (new_size - 1);</a>
<a name="ln79"> </a>
<a name="ln80">	hbnext = hb-&gt;next;</a>
<a name="ln81">	hb-&gt;next = new_index[h];</a>
<a name="ln82">	new_index[h] = hb;</a>
<a name="ln83">      }</a>
<a name="ln84"> </a>
<a name="ln85">  /* Switch to new table */</a>
<a name="ln86">  XFREE(MTYPE_HASH_INDEX, hash-&gt;index);</a>
<a name="ln87">  hash-&gt;size = new_size;</a>
<a name="ln88">  hash-&gt;index = new_index;</a>
<a name="ln89"> </a>
<a name="ln90">  /* Ideally, new index should have chains half as long as the original.</a>
<a name="ln91">     If expansion didn't help, then not worth expanding again,</a>
<a name="ln92">     the problem is the hash function. */</a>
<a name="ln93">  losers = 0;</a>
<a name="ln94">  for (i = 0; i &lt; hash-&gt;size; i++)</a>
<a name="ln95">    {</a>
<a name="ln96">      unsigned int len = 0;</a>
<a name="ln97">      for (hb = hash-&gt;index[i]; hb; hb = hb-&gt;next)</a>
<a name="ln98">	{</a>
<a name="ln99">	  if (++len &gt; HASH_THRESHOLD/2)</a>
<a name="ln100">	    ++losers;</a>
<a name="ln101">	  if (len &gt;= HASH_THRESHOLD)</a>
<a name="ln102">	    hash-&gt;no_expand = 1;</a>
<a name="ln103">	}</a>
<a name="ln104">    }</a>
<a name="ln105"> </a>
<a name="ln106">  if (losers &gt; hash-&gt;count / 2)</a>
<a name="ln107">    hash-&gt;no_expand = 1;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">/* Lookup and return hash backet in hash.  If there is no</a>
<a name="ln111">   corresponding hash backet and alloc_func is specified, create new</a>
<a name="ln112">   hash backet.  */</a>
<a name="ln113">void *</a>
<a name="ln114">hash_get (struct hash *hash, void *data, void * (*alloc_func) (void *))</a>
<a name="ln115">{</a>
<a name="ln116">  unsigned int key;</a>
<a name="ln117">  unsigned int index;</a>
<a name="ln118">  void *newdata;</a>
<a name="ln119">  unsigned int len;</a>
<a name="ln120">  struct hash_backet *backet;</a>
<a name="ln121"> </a>
<a name="ln122">  key = (*hash-&gt;hash_key) (data);</a>
<a name="ln123">  index = key &amp; (hash-&gt;size - 1);</a>
<a name="ln124">  len = 0;</a>
<a name="ln125"> </a>
<a name="ln126">  for (backet = hash-&gt;index[index]; backet != NULL; backet = backet-&gt;next)</a>
<a name="ln127">    {</a>
<a name="ln128">      if (backet-&gt;key == key &amp;&amp; (*hash-&gt;hash_cmp) (backet-&gt;data, data))</a>
<a name="ln129">	return backet-&gt;data;</a>
<a name="ln130">      ++len;</a>
<a name="ln131">    }</a>
<a name="ln132"> </a>
<a name="ln133">  if (alloc_func)</a>
<a name="ln134">    {</a>
<a name="ln135">      newdata = (*alloc_func) (data);</a>
<a name="ln136">      if (newdata == NULL)</a>
<a name="ln137">	return NULL;</a>
<a name="ln138"> </a>
<a name="ln139">      if (len &gt; HASH_THRESHOLD &amp;&amp; !hash-&gt;no_expand)</a>
<a name="ln140">	{</a>
<a name="ln141">	  hash_expand (hash);</a>
<a name="ln142">	  index = key &amp; (hash-&gt;size - 1);</a>
<a name="ln143">	}</a>
<a name="ln144"> </a>
<a name="ln145">      backet = XMALLOC (MTYPE_HASH_BACKET, sizeof (struct hash_backet));</a>
<a name="ln146">      backet-&gt;data = newdata;</a>
<a name="ln147">      backet-&gt;key = key;</a>
<a name="ln148">      backet-&gt;next = hash-&gt;index[index];</a>
<a name="ln149">      hash-&gt;index[index] = backet;</a>
<a name="ln150">      hash-&gt;count++;</a>
<a name="ln151">      return backet-&gt;data;</a>
<a name="ln152">    }</a>
<a name="ln153">  return NULL;</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">/* Hash lookup.  */</a>
<a name="ln157">void *</a>
<a name="ln158">hash_lookup (struct hash *hash, void *data)</a>
<a name="ln159">{</a>
<a name="ln160">  return hash_get (hash, data, NULL);</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">/* Simple Bernstein hash which is simple and fast for common case */</a>
<a name="ln164">unsigned int string_hash_make (const char *str)</a>
<a name="ln165">{</a>
<a name="ln166">  unsigned int hash = 0;</a>
<a name="ln167"> </a>
<a name="ln168">  while (*str)</a>
<a name="ln169">    hash = (hash * 33) ^ (unsigned int) *str++;</a>
<a name="ln170"> </a>
<a name="ln171">  return hash;</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">/* This function release registered value from specified hash.  When</a>
<a name="ln175">   release is successfully finished, return the data pointer in the</a>
<a name="ln176">   hash backet.  */</a>
<a name="ln177">void *</a>
<a name="ln178">hash_release (struct hash *hash, void *data)</a>
<a name="ln179">{</a>
<a name="ln180">  void *ret;</a>
<a name="ln181">  unsigned int key;</a>
<a name="ln182">  unsigned int index;</a>
<a name="ln183">  struct hash_backet *backet;</a>
<a name="ln184">  struct hash_backet *pp;</a>
<a name="ln185"> </a>
<a name="ln186">  key = (*hash-&gt;hash_key) (data);</a>
<a name="ln187">  index = key &amp; (hash-&gt;size - 1);</a>
<a name="ln188"> </a>
<a name="ln189">  for (backet = pp = hash-&gt;index[index]; backet; backet = backet-&gt;next)</a>
<a name="ln190">    {</a>
<a name="ln191">      if (backet-&gt;key == key &amp;&amp; (*hash-&gt;hash_cmp) (backet-&gt;data, data)) </a>
<a name="ln192">	{</a>
<a name="ln193">	  if (backet == pp) </a>
<a name="ln194">	    hash-&gt;index[index] = backet-&gt;next;</a>
<a name="ln195">	  else </a>
<a name="ln196">	    pp-&gt;next = backet-&gt;next;</a>
<a name="ln197"> </a>
<a name="ln198">	  ret = backet-&gt;data;</a>
<a name="ln199">	  XFREE (MTYPE_HASH_BACKET, backet);</a>
<a name="ln200">	  hash-&gt;count--;</a>
<a name="ln201">	  return ret;</a>
<a name="ln202">	}</a>
<a name="ln203">      pp = backet;</a>
<a name="ln204">    }</a>
<a name="ln205">  return NULL;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">/* Iterator function for hash.  */</a>
<a name="ln209">void</a>
<a name="ln210">hash_iterate (struct hash *hash, </a>
<a name="ln211">	      void (*func) (struct hash_backet *, void *), void *arg)</a>
<a name="ln212">{</a>
<a name="ln213">  unsigned int i;</a>
<a name="ln214">  struct hash_backet *hb;</a>
<a name="ln215">  struct hash_backet *hbnext;</a>
<a name="ln216"> </a>
<a name="ln217">  for (i = 0; i &lt; hash-&gt;size; i++)</a>
<a name="ln218">    for (hb = hash-&gt;index[i]; hb; hb = hbnext)</a>
<a name="ln219">      {</a>
<a name="ln220">	/* get pointer to next hash backet here, in case (*func)</a>
<a name="ln221">	 * decides to delete hb by calling hash_release</a>
<a name="ln222">	 */</a>
<a name="ln223">	hbnext = hb-&gt;next;</a>
<a name="ln224">	(*func) (hb, arg);</a>
<a name="ln225">      }</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">/* Clean up hash.  */</a>
<a name="ln229">void</a>
<a name="ln230">hash_clean (struct hash *hash, void (*free_func) (void *))</a>
<a name="ln231">{</a>
<a name="ln232">  unsigned int i;</a>
<a name="ln233">  struct hash_backet *hb;</a>
<a name="ln234">  struct hash_backet *next;</a>
<a name="ln235"> </a>
<a name="ln236">  for (i = 0; i &lt; hash-&gt;size; i++)</a>
<a name="ln237">    {</a>
<a name="ln238">      for (hb = hash-&gt;index[i]; hb; hb = next)</a>
<a name="ln239">	{</a>
<a name="ln240">	  next = hb-&gt;next;</a>
<a name="ln241">	      </a>
<a name="ln242">	  if (free_func)</a>
<a name="ln243">	    (*free_func) (hb-&gt;data);</a>
<a name="ln244"> </a>
<a name="ln245">	  XFREE (MTYPE_HASH_BACKET, hb);</a>
<a name="ln246">	  hash-&gt;count--;</a>
<a name="ln247">	}</a>
<a name="ln248">      hash-&gt;index[i] = NULL;</a>
<a name="ln249">    }</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">/* Free hash memory.  You may call hash_clean before call this</a>
<a name="ln253">   function.  */</a>
<a name="ln254">void</a>
<a name="ln255">hash_free (struct hash *hash)</a>
<a name="ln256">{</a>
<a name="ln257">  XFREE (MTYPE_HASH_INDEX, hash-&gt;index);</a>
<a name="ln258">  XFREE (MTYPE_HASH, hash);</a>
<a name="ln259">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
