
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>netlink_arp.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP netlink/neighbor table arpd code</a>
<a name="ln2"> * Copyright (c) 2014-2016 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;fcntl.h&gt;</a>
<a name="ln11">#include &lt;net/if.h&gt;</a>
<a name="ln12">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln13">#include &lt;linux/netlink.h&gt;</a>
<a name="ln14">#include &lt;linux/neighbour.h&gt;</a>
<a name="ln15">#include &lt;linux/netfilter/nfnetlink_log.h&gt;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;thread.h&quot;</a>
<a name="ln18">#include &quot;nhrpd.h&quot;</a>
<a name="ln19">#include &quot;netlink.h&quot;</a>
<a name="ln20">#include &quot;znl.h&quot;</a>
<a name="ln21"> </a>
<a name="ln22">int netlink_req_fd = -1;</a>
<a name="ln23">int netlink_nflog_group;</a>
<a name="ln24">static int netlink_log_fd = -1;</a>
<a name="ln25">static struct thread *netlink_log_thread;</a>
<a name="ln26">static int netlink_listen_fd = -1;</a>
<a name="ln27"> </a>
<a name="ln28">typedef void (*netlink_dispatch_f)(struct nlmsghdr *msg, struct zbuf *zb);</a>
<a name="ln29"> </a>
<a name="ln30">void netlink_update_binding(struct interface *ifp, union sockunion *proto, union sockunion *nbma)</a>
<a name="ln31">{</a>
<a name="ln32">	struct nlmsghdr *n;</a>
<a name="ln33">	struct ndmsg *ndm;</a>
<a name="ln34">	struct zbuf *zb = zbuf_alloc(512);</a>
<a name="ln35"> </a>
<a name="ln36">	n = znl_nlmsg_push(zb, nbma ? RTM_NEWNEIGH : RTM_DELNEIGH, NLM_F_REQUEST | NLM_F_REPLACE | NLM_F_CREATE);</a>
<a name="ln37">	ndm = znl_push(zb, sizeof(*ndm));</a>
<a name="ln38">	*ndm = (struct ndmsg) {</a>
<a name="ln39">		.ndm_family = sockunion_family(proto),</a>
<a name="ln40">		.ndm_ifindex = ifp-&gt;ifindex,</a>
<a name="ln41">		.ndm_type = RTN_UNICAST,</a>
<a name="ln42">		.ndm_state = nbma ? NUD_REACHABLE : NUD_FAILED,</a>
<a name="ln43">	};</a>
<a name="ln44">	znl_rta_push(zb, NDA_DST, sockunion_get_addr(proto), family2addrsize(sockunion_family(proto)));</a>
<a name="ln45">	if (nbma)</a>
<a name="ln46">		znl_rta_push(zb, NDA_LLADDR, sockunion_get_addr(nbma), family2addrsize(sockunion_family(nbma)));</a>
<a name="ln47">	znl_nlmsg_complete(zb, n);</a>
<a name="ln48">	zbuf_send(zb, netlink_req_fd);</a>
<a name="ln49">	zbuf_recv(zb, netlink_req_fd);</a>
<a name="ln50">	zbuf_free(zb);</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">static void netlink_neigh_msg(struct nlmsghdr *msg, struct zbuf *zb)</a>
<a name="ln54">{</a>
<a name="ln55">	struct ndmsg *ndm;</a>
<a name="ln56">	struct rtattr *rta;</a>
<a name="ln57">	struct nhrp_cache *c;</a>
<a name="ln58">	struct interface *ifp;</a>
<a name="ln59">	struct zbuf payload;</a>
<a name="ln60">	union sockunion addr;</a>
<a name="ln61">	size_t len;</a>
<a name="ln62">	char buf[SU_ADDRSTRLEN];</a>
<a name="ln63">	int state;</a>
<a name="ln64"> </a>
<a name="ln65">	ndm = znl_pull(zb, sizeof(*ndm));</a>
<a name="ln66">	if (!ndm) return;</a>
<a name="ln67"> </a>
<a name="ln68">	sockunion_family(&amp;addr) = AF_UNSPEC;</a>
<a name="ln69">	while ((rta = znl_rta_pull(zb, &amp;payload)) != NULL) {</a>
<a name="ln70">		len = zbuf_used(&amp;payload);</a>
<a name="ln71">		switch (rta-&gt;rta_type) {</a>
<a name="ln72">		case NDA_DST:</a>
<a name="ln73">			sockunion_set(&amp;addr, ndm-&gt;ndm_family, zbuf_pulln(&amp;payload, len), len);</a>
<a name="ln74">			break;</a>
<a name="ln75">		}</a>
<a name="ln76">	}</a>
<a name="ln77"> </a>
<a name="ln78">	ifp = if_lookup_by_index(ndm-&gt;ndm_ifindex);</a>
<a name="ln79">	if (!ifp || sockunion_family(&amp;addr) == AF_UNSPEC)</a>
<a name="ln80">		return;</a>
<a name="ln81"> </a>
<a name="ln82">	c = nhrp_cache_get(ifp, &amp;addr, 0);</a>
<a name="ln83">	if (!c)</a>
<a name="ln84">		return;</a>
<a name="ln85"> </a>
<a name="ln86">	if (msg-&gt;nlmsg_type == RTM_GETNEIGH) {</a>
<a name="ln87">		debugf(NHRP_DEBUG_KERNEL, &quot;Netlink: who-has %s dev %s&quot;,</a>
<a name="ln88">			sockunion2str(&amp;addr, buf, sizeof buf),</a>
<a name="ln89">			ifp-&gt;name);</a>
<a name="ln90"> </a>
<a name="ln91">		if (c-&gt;cur.type &gt;= NHRP_CACHE_CACHED) {</a>
<a name="ln92">			nhrp_cache_set_used(c, 1);</a>
<a name="ln93">			netlink_update_binding(ifp, &amp;addr, &amp;c-&gt;cur.peer-&gt;vc-&gt;remote.nbma);</a>
<a name="ln94">		}</a>
<a name="ln95">	} else {</a>
<a name="ln96">		debugf(NHRP_DEBUG_KERNEL, &quot;Netlink: update %s dev %s nud %x&quot;,</a>
<a name="ln97">			sockunion2str(&amp;addr, buf, sizeof buf),</a>
<a name="ln98">			ifp-&gt;name, ndm-&gt;ndm_state);</a>
<a name="ln99"> </a>
<a name="ln100">		state = (msg-&gt;nlmsg_type == RTM_NEWNEIGH) ? ndm-&gt;ndm_state : NUD_FAILED;</a>
<a name="ln101">		nhrp_cache_set_used(c, state == NUD_REACHABLE);</a>
<a name="ln102">	}</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">static int netlink_route_recv(struct thread *t)</a>
<a name="ln106">{</a>
<a name="ln107">	uint8_t buf[ZNL_BUFFER_SIZE];</a>
<a name="ln108">	int fd = THREAD_FD(t);</a>
<a name="ln109">	struct zbuf payload, zb;</a>
<a name="ln110">	struct nlmsghdr *n;</a>
<a name="ln111"> </a>
<a name="ln112">	zbuf_init(&amp;zb, buf, sizeof(buf), 0);</a>
<a name="ln113">	while (zbuf_recv(&amp;zb, fd) &gt; 0) {</a>
<a name="ln114">		while ((n = znl_nlmsg_pull(&amp;zb, &amp;payload)) != 0) {</a>
<a name="ln115">			debugf(NHRP_DEBUG_KERNEL, &quot;Netlink: Received msg_type %u, msg_flags %u&quot;,</a>
<a name="ln116">				n-&gt;nlmsg_type, n-&gt;nlmsg_flags);</a>
<a name="ln117">			switch (n-&gt;nlmsg_type) {</a>
<a name="ln118">			case RTM_GETNEIGH:</a>
<a name="ln119">			case RTM_NEWNEIGH:</a>
<a name="ln120">			case RTM_DELNEIGH:</a>
<a name="ln121">				netlink_neigh_msg(n, &amp;payload);</a>
<a name="ln122">				break;</a>
<a name="ln123">			}</a>
<a name="ln124">		}</a>
<a name="ln125">	}</a>
<a name="ln126"> </a>
<a name="ln127">	thread_add_read(master, netlink_route_recv, 0, fd);</a>
<a name="ln128"> </a>
<a name="ln129">	return 0;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">static void netlink_log_register(int fd, int group)</a>
<a name="ln133">{</a>
<a name="ln134">	struct nlmsghdr *n;</a>
<a name="ln135">	struct nfgenmsg *nf;</a>
<a name="ln136">	struct nfulnl_msg_config_cmd cmd;</a>
<a name="ln137">	struct zbuf *zb = zbuf_alloc(512);</a>
<a name="ln138"> </a>
<a name="ln139">	n = znl_nlmsg_push(zb, (NFNL_SUBSYS_ULOG&lt;&lt;8) | NFULNL_MSG_CONFIG, NLM_F_REQUEST | NLM_F_ACK);</a>
<a name="ln140">	nf = znl_push(zb, sizeof(*nf));</a>
<a name="ln141">	*nf = (struct nfgenmsg) {</a>
<a name="ln142">		.nfgen_family = AF_UNSPEC,</a>
<a name="ln143">		.version = NFNETLINK_V0,</a>
<a name="ln144">		.res_id = htons(group),</a>
<a name="ln145">	};</a>
<a name="ln146">	cmd.command = NFULNL_CFG_CMD_BIND;</a>
<a name="ln147">	znl_rta_push(zb, NFULA_CFG_CMD, &amp;cmd, sizeof(cmd));</a>
<a name="ln148">	znl_nlmsg_complete(zb, n);</a>
<a name="ln149"> </a>
<a name="ln150">	zbuf_send(zb, fd);</a>
<a name="ln151">	zbuf_free(zb);</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">static void netlink_log_indication(struct nlmsghdr *msg, struct zbuf *zb)</a>
<a name="ln155">{</a>
<a name="ln156">	struct nfgenmsg *nf;</a>
<a name="ln157">	struct rtattr *rta;</a>
<a name="ln158">	struct zbuf rtapl, pktpl;</a>
<a name="ln159">	struct interface *ifp;</a>
<a name="ln160">	struct nfulnl_msg_packet_hdr *pkthdr = NULL;</a>
<a name="ln161">	uint32_t *in_ndx = NULL;</a>
<a name="ln162"> </a>
<a name="ln163">	nf = znl_pull(zb, sizeof(*nf));</a>
<a name="ln164">	if (!nf) return;</a>
<a name="ln165"> </a>
<a name="ln166">	memset(&amp;pktpl, 0, sizeof(pktpl));</a>
<a name="ln167">	while ((rta = znl_rta_pull(zb, &amp;rtapl)) != NULL) {</a>
<a name="ln168">		switch (rta-&gt;rta_type) {</a>
<a name="ln169">		case NFULA_PACKET_HDR:</a>
<a name="ln170">			pkthdr = znl_pull(&amp;rtapl, sizeof(*pkthdr));</a>
<a name="ln171">			break;</a>
<a name="ln172">		case NFULA_IFINDEX_INDEV:</a>
<a name="ln173">			in_ndx = znl_pull(&amp;rtapl, sizeof(*in_ndx));</a>
<a name="ln174">			break;</a>
<a name="ln175">		case NFULA_PAYLOAD:</a>
<a name="ln176">			pktpl = rtapl;</a>
<a name="ln177">			break;</a>
<a name="ln178">		/* NFULA_HWHDR exists and is supposed to contain source</a>
<a name="ln179">		 * hardware address. However, for ip_gre it seems to be</a>
<a name="ln180">		 * the nexthop destination address if the packet matches</a>
<a name="ln181">		 * route. */</a>
<a name="ln182">		}</a>
<a name="ln183">	}</a>
<a name="ln184"> </a>
<a name="ln185">	if (!pkthdr || !in_ndx || !zbuf_used(&amp;pktpl))</a>
<a name="ln186">		return;</a>
<a name="ln187"> </a>
<a name="ln188">	ifp = if_lookup_by_index(htonl(*in_ndx));</a>
<a name="ln189">	if (!ifp)</a>
<a name="ln190">		return;</a>
<a name="ln191"> </a>
<a name="ln192">	nhrp_peer_send_indication(ifp, htons(pkthdr-&gt;hw_protocol), &amp;pktpl);</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">static int netlink_log_recv(struct thread *t)</a>
<a name="ln196">{</a>
<a name="ln197">	uint8_t buf[ZNL_BUFFER_SIZE];</a>
<a name="ln198">	int fd = THREAD_FD(t);</a>
<a name="ln199">	struct zbuf payload, zb;</a>
<a name="ln200">	struct nlmsghdr *n;</a>
<a name="ln201"> </a>
<a name="ln202">	netlink_log_thread = NULL;</a>
<a name="ln203"> </a>
<a name="ln204">	zbuf_init(&amp;zb, buf, sizeof(buf), 0);</a>
<a name="ln205">	while (zbuf_recv(&amp;zb, fd) &gt; 0) {</a>
<a name="ln206">		while ((n = znl_nlmsg_pull(&amp;zb, &amp;payload)) != 0) {</a>
<a name="ln207">			debugf(NHRP_DEBUG_KERNEL, &quot;Netlink-log: Received msg_type %u, msg_flags %u&quot;,</a>
<a name="ln208">				n-&gt;nlmsg_type, n-&gt;nlmsg_flags);</a>
<a name="ln209">			switch (n-&gt;nlmsg_type) {</a>
<a name="ln210">			case (NFNL_SUBSYS_ULOG&lt;&lt;8) | NFULNL_MSG_PACKET:</a>
<a name="ln211">				netlink_log_indication(n, &amp;payload);</a>
<a name="ln212">				break;</a>
<a name="ln213">			}</a>
<a name="ln214">		}</a>
<a name="ln215">	}</a>
<a name="ln216"> </a>
<a name="ln217">	THREAD_READ_ON(master, netlink_log_thread, netlink_log_recv, 0, netlink_log_fd);</a>
<a name="ln218"> </a>
<a name="ln219">	return 0;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">void netlink_set_nflog_group(int nlgroup)</a>
<a name="ln223">{</a>
<a name="ln224">	if (netlink_log_fd &gt;= 0) {</a>
<a name="ln225">		THREAD_OFF(netlink_log_thread);</a>
<a name="ln226">		close(netlink_log_fd);</a>
<a name="ln227">		netlink_log_fd = -1;</a>
<a name="ln228">	}</a>
<a name="ln229">	netlink_nflog_group = nlgroup;</a>
<a name="ln230">	if (nlgroup) {</a>
<a name="ln231">		netlink_log_fd = znl_open(NETLINK_NETFILTER,  0);</a>
<a name="ln232">		netlink_log_register(netlink_log_fd, nlgroup);</a>
<a name="ln233">		THREAD_READ_ON(master, netlink_log_thread, netlink_log_recv, 0, netlink_log_fd);</a>
<a name="ln234">	}</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">int netlink_init(void)</a>
<a name="ln238">{</a>
<a name="ln239">	netlink_req_fd = znl_open(NETLINK_ROUTE, 0);</a>
<a name="ln240">	netlink_listen_fd = znl_open(NETLINK_ROUTE, RTMGRP_NEIGH);</a>
<a name="ln241">	thread_add_read(master, netlink_route_recv, 0, netlink_listen_fd);</a>
<a name="ln242"> </a>
<a name="ln243">	return 0;</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">int netlink_configure_arp(unsigned int ifindex, int pf)</a>
<a name="ln247">{</a>
<a name="ln248">	struct nlmsghdr *n;</a>
<a name="ln249">	struct ndtmsg *ndtm;</a>
<a name="ln250">	struct rtattr *rta;</a>
<a name="ln251">	struct zbuf *zb = zbuf_alloc(512);</a>
<a name="ln252">	int r;</a>
<a name="ln253"> </a>
<a name="ln254">	n = znl_nlmsg_push(zb, RTM_SETNEIGHTBL, NLM_F_REQUEST | NLM_F_REPLACE);</a>
<a name="ln255">	ndtm = znl_push(zb, sizeof(*ndtm));</a>
<a name="ln256">	*ndtm = (struct ndtmsg) {</a>
<a name="ln257">		.ndtm_family = pf,</a>
<a name="ln258">	};</a>
<a name="ln259"> </a>
<a name="ln260">	znl_rta_push(zb, NDTA_NAME, pf == AF_INET ? &quot;arp_cache&quot; : &quot;ndisc_cache&quot;, 10);</a>
<a name="ln261"> </a>
<a name="ln262">	rta = znl_rta_nested_push(zb, NDTA_PARMS);</a>
<a name="ln263">	znl_rta_push_u32(zb, NDTPA_IFINDEX, ifindex);</a>
<a name="ln264">	znl_rta_push_u32(zb, NDTPA_APP_PROBES, 1);</a>
<a name="ln265">	znl_rta_push_u32(zb, NDTPA_MCAST_PROBES, 0);</a>
<a name="ln266">	znl_rta_push_u32(zb, NDTPA_UCAST_PROBES, 0);</a>
<a name="ln267">	znl_rta_nested_complete(zb, rta);</a>
<a name="ln268"> </a>
<a name="ln269">	znl_nlmsg_complete(zb, n);</a>
<a name="ln270">	r = zbuf_send(zb, netlink_req_fd);</a>
<a name="ln271">	zbuf_recv(zb, netlink_req_fd);</a>
<a name="ln272">	zbuf_free(zb);</a>
<a name="ln273"> </a>
<a name="ln274">	return r;</a>
<a name="ln275">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
