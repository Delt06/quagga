
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spgrid.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">#include &lt;zebra.h&gt;</a>
<a name="ln2"> </a>
<a name="ln3">#include &lt;stdio.h&gt;</a>
<a name="ln4">#include &lt;stdlib.h&gt;</a>
<a name="ln5">#include &lt;string.h&gt;</a>
<a name="ln6"> </a>
<a name="ln7">#include &quot;random.c&quot;</a>
<a name="ln8"> </a>
<a name="ln9">#include &quot;thread.h&quot;</a>
<a name="ln10">#include &quot;vty.h&quot;</a>
<a name="ln11">#include &quot;log.h&quot;</a>
<a name="ln12">#include &quot;linklist.h&quot;</a>
<a name="ln13"> </a>
<a name="ln14">#include &quot;spgrid.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16"> </a>
<a name="ln17">#define DASH '-'</a>
<a name="ln18">#define VERY_FAR 100000000</a>
<a name="ln19"> </a>
<a name="ln20">#define DOUBLE_CYCLE   0</a>
<a name="ln21">#define CYCLE          1</a>
<a name="ln22">#define PATH           2</a>
<a name="ln23"> </a>
<a name="ln24">#define NO             0</a>
<a name="ln25">#define YES            1</a>
<a name="ln26"> </a>
<a name="ln27">#define NODE( x, y ) (x*Y + y + 1)</a>
<a name="ln28"> </a>
<a name="ln29">/*</a>
<a name="ln30"> * Prototypes.</a>
<a name="ln31"> */</a>
<a name="ln32">void free_arc(void *);</a>
<a name="ln33">void help(struct vty *);</a>
<a name="ln34">void print_arc(struct vty *, struct list *, long, long, long);</a>
<a name="ln35">void hhelp(struct vty *);</a>
<a name="ln36">void usage(struct vty *);</a>
<a name="ln37"> </a>
<a name="ln38">const char   *graph_type[] =  {</a>
<a name="ln39">  &quot;double cycle&quot;,</a>
<a name="ln40">  &quot;cycle&quot;,</a>
<a name="ln41">  &quot;path&quot;</a>
<a name="ln42">};</a>
<a name="ln43"> </a>
<a name="ln44">struct arc *arc;</a>
<a name="ln45"> </a>
<a name="ln46">char   args[30];</a>
<a name="ln47"> </a>
<a name="ln48">long   X,   /* horizontal size of grid */</a>
<a name="ln49">       Y;   /* vertical size of grid */</a>
<a name="ln50"> </a>
<a name="ln51">long   x,</a>
<a name="ln52">       y,</a>
<a name="ln53">       yy1, yy2, yyp,</a>
<a name="ln54">       dl, dx, xn, yyn, count,</a>
<a name="ln55">       *mess;</a>
<a name="ln56"> </a>
<a name="ln57">double n;</a>
<a name="ln58">long   n0,</a>
<a name="ln59">       source,</a>
<a name="ln60">       i,</a>
<a name="ln61">       i0,</a>
<a name="ln62">       j,</a>
<a name="ln63">       dij;</a>
<a name="ln64"> </a>
<a name="ln65">double m;</a>
<a name="ln66">long   m0,</a>
<a name="ln67">       mc,</a>
<a name="ln68">       k;</a>
<a name="ln69"> </a>
<a name="ln70">long   *p,</a>
<a name="ln71">       p_t,</a>
<a name="ln72">       l,</a>
<a name="ln73">       lx;</a>
<a name="ln74"> </a>
<a name="ln75">long   seed,</a>
<a name="ln76">       seed1,</a>
<a name="ln77">       seed2;</a>
<a name="ln78"> </a>
<a name="ln79">int    ext=0;</a>
<a name="ln80"> </a>
<a name="ln81">/* initialized by default values */</a>
<a name="ln82"> </a>
<a name="ln83">/* variables for generating one layer */</a>
<a name="ln84"> </a>
<a name="ln85">/* variables for generating spanning graph */</a>
<a name="ln86">int    c_f = 0, cw_f = 0, cm_f = 0, cl_f = 0;</a>
<a name="ln87"> </a>
<a name="ln88">int    cw = DOUBLE_CYCLE;  /* type of spanning graph */</a>
<a name="ln89">long   cm = 0,             /* lower bound of the interval */</a>
<a name="ln90">       cl = 100;           /* upper bound of the interval */</a>
<a name="ln91"> </a>
<a name="ln92">/* variables for generating additional arcs */</a>
<a name="ln93">int    a_f = 0, ax_f = 0, am_f = 0, al_f = 0;</a>
<a name="ln94"> </a>
<a name="ln95">long   ax = 0,             /* number of additional arcs */</a>
<a name="ln96">       am = 0,             /* lower bound of the interval */</a>
<a name="ln97">       al = 100;           /* upper bound of the interval */</a>
<a name="ln98"> </a>
<a name="ln99">/* variables for inter-layer arcs */</a>
<a name="ln100">int    i_f = 0, ip_f = 0, ix_f = 0, ih_f = 0,</a>
<a name="ln101">       im_f = 0, il_f = 0, in_f = 0, is_f = 0;</a>
<a name="ln102"> </a>
<a name="ln103">int    ip = NO;       /* to mess or not to mess */</a>
<a name="ln104">long   ix = 1,        /* number of interlayered arcs in a NODE */</a>
<a name="ln105">       ih = 1,        /* step between two layeres */</a>
<a name="ln106">       il = 10000,    /* upper bound of the interval */</a>
<a name="ln107">       im = 1000;     /* lower bound of the interval */</a>
<a name="ln108">double in = 1,        /* l *=  in * |x1-x2| */</a>
<a name="ln109">       is = 0;        /* l *=  is * |x1-x2|^2 */</a>
<a name="ln110"> </a>
<a name="ln111">/* variables for artifical source */</a>
<a name="ln112">int    s_f = 0, sl_f = 0, sm_f = 0;</a>
<a name="ln113">long   sl   = VERY_FAR, /* upper bound of artifical arc */</a>
<a name="ln114">       sm,              /* lower bound of artifical arc */</a>
<a name="ln115">       s;</a>
<a name="ln116"> </a>
<a name="ln117">/* variables for potentials */</a>
<a name="ln118">int    p_f = 0, pl_f = 0, pm_f = 0, pn_f = 0, ps_f = 0;</a>
<a name="ln119"> </a>
<a name="ln120">long   pl,            /* upper bound of the interval */</a>
<a name="ln121">       pm;            /* lower bound of the interval */</a>
<a name="ln122">double pn = 0,        /* p +=  ln * (x+1) */</a>
<a name="ln123">       ps = 0;        /* p +=  ls * (x+1)^2 */</a>
<a name="ln124"> </a>
<a name="ln125">int np;               /* number of parameter parsing now */</a>
<a name="ln126"> </a>
<a name="ln127"> </a>
<a name="ln128">void</a>
<a name="ln129">free_arc   (void *val) {</a>
<a name="ln130">  free(val);</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">void</a>
<a name="ln134">print_arc (struct vty *vty, struct list *topology, long i, long j, long length)</a>
<a name="ln135">{</a>
<a name="ln136">  struct arc *myarc;</a>
<a name="ln137"> </a>
<a name="ln138">  l = length;</a>
<a name="ln139">  if ( p_f ) l += ( p[i] - p[j] );</a>
<a name="ln140">//  vty_out (vty,&quot;a %8ld %8ld %12ld%s&quot;, i, j, l ,VTY_NEWLINE);</a>
<a name="ln141">  myarc = malloc (sizeof(struct arc));</a>
<a name="ln142">  myarc-&gt;from_node = i;</a>
<a name="ln143">  myarc-&gt;to_node = j;</a>
<a name="ln144">  myarc-&gt;distance = l;</a>
<a name="ln145">  topology-&gt;del = free_arc;</a>
<a name="ln146">  listnode_add (topology, myarc);</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">/* ---- help ---- */</a>
<a name="ln150">void</a>
<a name="ln151">help (struct vty *vty) {</a>
<a name="ln152">//  if ( args[2] == 'h') hhelp (vty);</a>
<a name="ln153">  vty_out (vty,&quot;grid network generator for shortest paths problem.%s&quot;,VTY_NEWLINE);</a>
<a name="ln154">  vty_out (vty,&quot;Generates problems in extended DIMACS format.%s&quot;,VTY_NEWLINE);</a>
<a name="ln155">  vty_out (vty,&quot;X Y seed [ -cl#i -cm#i -c{c|d|p} -ip -il#i -im#i -p -pl#i -pm#i... ]%s&quot;,VTY_NEWLINE);</a>
<a name="ln156">  vty_out (vty,&quot;#i - integer number%s&quot;,VTY_NEWLINE);</a>
<a name="ln157">  vty_out (vty,&quot;-cl#i - #i is the upper bound on layer arc lengths    (default 100)%s&quot;,VTY_NEWLINE);</a>
<a name="ln158">  vty_out (vty,&quot;-cm#i - #i is the lower bound on layer arc lengths    (default 0)%s&quot;,VTY_NEWLINE);</a>
<a name="ln159">  vty_out (vty,&quot;-c#t  - #t is the type of connecting graph: { c | d | p }%s&quot;,VTY_NEWLINE);</a>
<a name="ln160">  vty_out (vty,&quot;           c - cycle, d - double cycle, p - path      (default d)%s&quot;,VTY_NEWLINE);</a>
<a name="ln161">  vty_out (vty,&quot;-ip   - shuffle inter-layer arcs                     (default NO)%s&quot;,VTY_NEWLINE);</a>
<a name="ln162">  vty_out (vty,&quot;-il#i - #i is the upper bound on inter-layer arc lengths (default 10000)%s&quot;,VTY_NEWLINE);</a>
<a name="ln163">  vty_out (vty,&quot;-im#i - #i is the lower bound on inter-layer arc lengths (default 1000)%s&quot;,VTY_NEWLINE);</a>
<a name="ln164">  vty_out (vty,&quot;-p    - generate potentials%s&quot;,VTY_NEWLINE);</a>
<a name="ln165">  vty_out (vty,&quot;-pl#i - #i is the upper bound on potentials           (default il)%s&quot;,VTY_NEWLINE);</a>
<a name="ln166">  vty_out (vty,&quot;-pm#i - #i is the lower bound on potentials           (default im)%s&quot;,VTY_NEWLINE);</a>
<a name="ln167">  vty_out (vty,&quot;%s&quot;,VTY_NEWLINE);</a>
<a name="ln168">  vty_out (vty,&quot;-hh    - extended help%s&quot;,VTY_NEWLINE);</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">/* --------- sophisticated help ------------ */</a>
<a name="ln172">void</a>
<a name="ln173">hhelp (struct vty *vty) {</a>
<a name="ln174">/*</a>
<a name="ln175">zlog_info (</a>
<a name="ln176">&quot;\n'%s' - grid network generator for shortest paths problem.\n\</a>
<a name="ln177">Generates problems in extended DIMACS format.\n\</a>
<a name="ln178">\n\</a>
<a name="ln179">   %s  X Y seed [ -cl#i -cm#i -c{c|d|p}\n\</a>
<a name="ln180">                      -ax#i -al#i -am#i\n\</a>
<a name="ln181">                      -ip   -il#i -im#i -in#i -is#i -ix#i -ih#i\n\</a>
<a name="ln182">                      -p    -pl#i -pm#i -pn#f -ps#f\n\</a>
<a name="ln183">                      -s    -sl#i -sm#i\n\</a>
<a name="ln184">                    ]\n\</a>
<a name="ln185">   %s -hh file_name\n\</a>
<a name="ln186">\n\</a>
<a name="ln187">                        #i - integer number   #f - real number\n\</a>
<a name="ln188">\n\</a>
<a name="ln189">      Parameters of connecting arcs within one layer:\n\</a>
<a name="ln190">-cl#i - #i is the upper bound on arc lengths          (default 100)\n\</a>
<a name="ln191">-cm#i - #i is the lower bound on arc lengths          (default 0)\n\</a>
<a name="ln192">-c#t  - #t is the type of connecting graph: { c | d | p }\n\</a>
<a name="ln193">           c - cycle, d - double cycle, p - path      (default d)\n\</a>
<a name="ln194">\n\</a>
<a name="ln195">      Parameters of additional arcs within one layer:\n\</a>
<a name="ln196">-ax#i - #i is the number of additional arcs           (default 0)\n\</a>
<a name="ln197">-al#i - #i is the upper bound on arc lengths          (default 100)\n\</a>
<a name="ln198">-am#i - #i is the lower bound on arc lengths          (default 0)\n\</a>
<a name="ln199">\n\</a>
<a name="ln200">      Interlayerd arc parameters:\n\</a>
<a name="ln201">-ip    - shuffle inter-layer arcs                         (default NO)\n\</a>
<a name="ln202">-il#i  - #i is the upper bound on arc lengths          (default 10000)\n\</a>
<a name="ln203">-im#i  - #i is the lower bound on arc lengths          (default 1000)\n\</a>
<a name="ln204">-in#f  - multiply l(i, j) by #f * x(j)-x(i)           (default 1)\n\</a>
<a name="ln205">         if #f=0 - don't multiply\n\</a>
<a name="ln206">-is#f  - multiply l(i, j) by #f * (x(j)-x(i))^2       (default NO)\n\</a>
<a name="ln207">-ix#i  - #i - is the number of arcs from a node        (default 1)\n\</a>
<a name="ln208">-ih#i  - #i - is the step between connected layers     (default 1)\n\</a>
<a name="ln209">\n\</a>
<a name="ln210">      Potential parameters:\n\</a>
<a name="ln211">-p     - generate potentials \n\</a>
<a name="ln212">-pl#i  - #i is the upper bound on potentials           (default ll)\n\</a>
<a name="ln213">-pm#i  - #i is the lower bound on potentials           (default lm)\n\</a>
<a name="ln214">-pn#f  - multiply p(i) by #f * x(i)                    (default NO)\n\</a>
<a name="ln215">-ps#f  - multiply p(i) by #f * x(i)^2                  (default NO)\n\</a>
<a name="ln216">\n&quot;);</a>
<a name="ln217">zlog_info (</a>
<a name="ln218">&quot;     Artificial source parameters:\n\</a>
<a name="ln219">-s     - generate artificial source with default connecting arc lengths\n\</a>
<a name="ln220">-sl#i  - #i is the upper bound on art. arc lengths    (default 100000000)\n\</a>
<a name="ln221">-sm#i  - #i is the lower bound on art. arc lengths    (default sl)\n\&quot;</a>
<a name="ln222">);*/</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">/* ----- wrong usage ----- */</a>
<a name="ln226">void</a>
<a name="ln227">usage (struct vty *vty) {</a>
<a name="ln228">  vty_out (vty,&quot;usage: X Y seed [-ll#i -lm#i -cl#i -p -pl#i -pm#i ...]%s&quot;,VTY_NEWLINE);</a>
<a name="ln229">  vty_out (vty,&quot;help: -h or -hh%s&quot;,VTY_NEWLINE);</a>
<a name="ln230"> </a>
<a name="ln231">  if ( np &gt; 0 )</a>
<a name="ln232">    zlog_err (&quot;error in parameter # %d\n\n&quot;, np );</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235"> </a>
<a name="ln236">/* parsing  parameters */</a>
<a name="ln237">/* checks the validity of incoming parameters */</a>
<a name="ln238">int</a>
<a name="ln239">spgrid_check_params ( struct vty *vty, int argc, const char **argv)</a>
<a name="ln240">{</a>
<a name="ln241">/* initialized by default values */</a>
<a name="ln242">  ext=0;</a>
<a name="ln243"> </a>
<a name="ln244">/* variables for generating one layer */</a>
<a name="ln245"> </a>
<a name="ln246">/* variables for generating spanning graph */</a>
<a name="ln247">  c_f = 0;</a>
<a name="ln248">  cw_f = 0;</a>
<a name="ln249">  cm_f = 0;</a>
<a name="ln250">  cl_f = 0;</a>
<a name="ln251"> </a>
<a name="ln252">  cw = PATH;  /* type of spanning graph */</a>
<a name="ln253">  cm = 0;             /* lower bound of the interval */</a>
<a name="ln254">  cl = 63;           /* upper bound of the interval */</a>
<a name="ln255"> </a>
<a name="ln256">/* variables for generating additional arcs */</a>
<a name="ln257">  a_f = 0;</a>
<a name="ln258">  ax_f = 0;</a>
<a name="ln259">  am_f = 0;</a>
<a name="ln260">  al_f = 0;</a>
<a name="ln261"> </a>
<a name="ln262">  ax = 0;             /* number of additional arcs */</a>
<a name="ln263">  am = 0;             /* lower bound of the interval */</a>
<a name="ln264">  al = 63;           /* upper bound of the interval */</a>
<a name="ln265"> </a>
<a name="ln266">/* variables for inter-layer arcs */</a>
<a name="ln267">  i_f = 0;</a>
<a name="ln268">  ip_f = 0;</a>
<a name="ln269">  ix_f = 0;</a>
<a name="ln270">  ih_f = 0;</a>
<a name="ln271">  im_f = 0;</a>
<a name="ln272">  il_f = 0;</a>
<a name="ln273">  in_f = 0;</a>
<a name="ln274">  is_f = 0;</a>
<a name="ln275"> </a>
<a name="ln276">  ip = NO;       /* to mess or not to mess */</a>
<a name="ln277">  ix = 1;        /* number of interlayered arcs in a NODE */</a>
<a name="ln278">  ih = 1;        /* step between two layeres */</a>
<a name="ln279">  il = 63; //was 10000;    /* upper bound of the interval */</a>
<a name="ln280">  im = 0;  //was 1000;     /* lower bound of the interval */</a>
<a name="ln281">  in = 1;        /* l *=  in * |x1-x2| */</a>
<a name="ln282">  is = 0;        /* l *=  is * |x1-x2|^2 */</a>
<a name="ln283"> </a>
<a name="ln284">/* variables for artifical source */</a>
<a name="ln285">  s_f = 0;</a>
<a name="ln286">  sl_f = 0;</a>
<a name="ln287">  sm_f = 0;</a>
<a name="ln288">  sl   = VERY_FAR; /* upper bound of artifical arc */</a>
<a name="ln289"> </a>
<a name="ln290">/* variables for potentials */</a>
<a name="ln291">  p_f = 0;</a>
<a name="ln292">  pl_f = 0;</a>
<a name="ln293">  pm_f = 0;</a>
<a name="ln294">  pn_f = 0;</a>
<a name="ln295">  ps_f = 0;</a>
<a name="ln296"> </a>
<a name="ln297">  pn = 0;        /* p +=  ln * (x+1) */</a>
<a name="ln298">  ps = 0;        /* p +=  ls * (x+1)^2 */</a>
<a name="ln299"> </a>
<a name="ln300"> </a>
<a name="ln301">  if ( argc &lt; 1 ) {</a>
<a name="ln302">    usage (vty);</a>
<a name="ln303">    return 1;</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306">  np = 0;</a>
<a name="ln307"> </a>
<a name="ln308">  strcpy ( args, argv[0] );</a>
<a name="ln309"> </a>
<a name="ln310">  if ((args[0] == DASH) &amp;&amp; (args[1] == 'h'))</a>
<a name="ln311">    help (vty);</a>
<a name="ln312"> </a>
<a name="ln313">  if ( argc &lt; 3 ) {</a>
<a name="ln314">    usage (vty);</a>
<a name="ln315">    return 1;</a>
<a name="ln316">  }</a>
<a name="ln317"> </a>
<a name="ln318">  /* first parameter - horizontal size */</a>
<a name="ln319">  np = 1;</a>
<a name="ln320">  if ( ( X = atoi ( argv[0] ) )  &lt;  1  ) {</a>
<a name="ln321">    usage (vty);</a>
<a name="ln322">    return 1;</a>
<a name="ln323">  }</a>
<a name="ln324"> </a>
<a name="ln325">  /* second parameter - vertical size */</a>
<a name="ln326">  np = 2;</a>
<a name="ln327">  if ( ( Y = atoi ( argv[1] ) )  &lt;  1  ) {</a>
<a name="ln328">    usage (vty);</a>
<a name="ln329">    return 1;</a>
<a name="ln330">  }</a>
<a name="ln331"> </a>
<a name="ln332">  /* third parameter - seed */</a>
<a name="ln333">  np=3;</a>
<a name="ln334">  if ( ( seed = atoi ( argv[2] ) )  &lt;=  0  ) {</a>
<a name="ln335">    usage (vty);</a>
<a name="ln336">    return 1;</a>
<a name="ln337">  }</a>
<a name="ln338"> </a>
<a name="ln339">  /* other parameters */</a>
<a name="ln340">  for ( np = 3; np &lt; argc; np ++ ) {</a>
<a name="ln341">    strcpy ( args, argv[np] );</a>
<a name="ln342">    if ( args[0] != DASH )  {</a>
<a name="ln343">      usage (vty);</a>
<a name="ln344">      return 1;</a>
<a name="ln345">    }</a>
<a name="ln346"> </a>
<a name="ln347">    switch ( args[1] ) {</a>
<a name="ln348">      case 'c' : /* spanning graph in one layer */</a>
<a name="ln349">        c_f = 1;</a>
<a name="ln350">        switch ( args[2] ) {</a>
<a name="ln351">          case 'l': /* upper bound of the interval */</a>
<a name="ln352">            cl_f = 1;</a>
<a name="ln353">            cl  =  atol ( &amp;args[3] );</a>
<a name="ln354">            break;</a>
<a name="ln355">          case 'm': /* lower bound */</a>
<a name="ln356">            cm_f = 1;</a>
<a name="ln357">            cm  = atol ( &amp;args[3] );</a>
<a name="ln358">            break;</a>
<a name="ln359">          case 'c': /* type - cycle */</a>
<a name="ln360">            cw_f = 1;</a>
<a name="ln361">            cw   = CYCLE;</a>
<a name="ln362">            break;</a>
<a name="ln363">          case 'd': /* type - double cycle */</a>
<a name="ln364">            cw_f = 1;</a>
<a name="ln365">            cw   = DOUBLE_CYCLE;</a>
<a name="ln366">            break;</a>
<a name="ln367">          case 'p': /* type - path */</a>
<a name="ln368">            cw_f = 1;</a>
<a name="ln369">            cw   = PATH;</a>
<a name="ln370">            break;</a>
<a name="ln371"> </a>
<a name="ln372">          default:  /* unknown switch  value */</a>
<a name="ln373">            usage (vty);</a>
<a name="ln374">            return 1;</a>
<a name="ln375">          }</a>
<a name="ln376">        break;</a>
<a name="ln377"> </a>
<a name="ln378">      case 'a' : /* additional arcs in one layer */</a>
<a name="ln379">         a_f = 1;</a>
<a name="ln380">        switch ( args[2] )</a>
<a name="ln381">          {</a>
<a name="ln382">          case 'l': /* upper bound of the interval */</a>
<a name="ln383">            al_f = 1;</a>
<a name="ln384">            al  =  atol ( &amp;args[3] );</a>
<a name="ln385">            break;</a>
<a name="ln386">          case 'm': /* lower bound */</a>
<a name="ln387">            am_f = 1;</a>
<a name="ln388">            am  = atol ( &amp;args[3] );</a>
<a name="ln389">            break;</a>
<a name="ln390">          case 'x': /* number of additional arcs */</a>
<a name="ln391">            ax_f = 1;</a>
<a name="ln392">            ax   = atol ( &amp;args[3] );</a>
<a name="ln393">            if ( ax &lt; 0 )</a>
<a name="ln394">             {</a>
<a name="ln395">               usage (vty);</a>
<a name="ln396">               return 1;</a>
<a name="ln397">             }</a>
<a name="ln398">            break;</a>
<a name="ln399"> </a>
<a name="ln400">          default:  /* unknown switch  value */</a>
<a name="ln401">            {</a>
<a name="ln402">              usage (vty);</a>
<a name="ln403">              return 1;</a>
<a name="ln404">            }</a>
<a name="ln405">          }</a>
<a name="ln406">        break;</a>
<a name="ln407"> </a>
<a name="ln408"> </a>
<a name="ln409">      case 'i' : /* interlayered arcs */</a>
<a name="ln410">        i_f = 1;</a>
<a name="ln411"> </a>
<a name="ln412">        switch ( args[2] )</a>
<a name="ln413">          {</a>
<a name="ln414">          case 'l': /* upper bound */</a>
<a name="ln415">            il_f = 1;</a>
<a name="ln416">            il  =  atol ( &amp;args[3] );</a>
<a name="ln417">            break;</a>
<a name="ln418">          case 'm': /* lower bound */</a>
<a name="ln419">            im_f = 1;</a>
<a name="ln420">            im  = atol ( &amp;args[3] );</a>
<a name="ln421">            break;</a>
<a name="ln422">          case 'n': /* additional length: l *= in*|i1-i2| */</a>
<a name="ln423">            in_f = 1;</a>
<a name="ln424">            in  = atof ( &amp;args[3] );</a>
<a name="ln425">            break;</a>
<a name="ln426">          case 's': /* additional length: l *= is*|i1-i2|^2 */</a>
<a name="ln427">            is_f = 1;</a>
<a name="ln428">            is  = atof ( &amp;args[3] );</a>
<a name="ln429">            break;</a>
<a name="ln430">          case 'p': /* mess interlayered arcs */</a>
<a name="ln431">            ip_f = 1;</a>
<a name="ln432">            ip = YES;</a>
<a name="ln433">            break;</a>
<a name="ln434">          case 'x': /* number of interlayered arcs */</a>
<a name="ln435">            ix_f = 1;</a>
<a name="ln436">            ix  = atof ( &amp;args[3] );</a>
<a name="ln437">            if ( ix &lt; 1 ) {</a>
<a name="ln438">              usage (vty);</a>
<a name="ln439">              return 1;</a>
<a name="ln440">            }</a>
<a name="ln441">            break;</a>
<a name="ln442">          case 'h': /* step between two layeres */</a>
<a name="ln443">            ih_f = 1;</a>
<a name="ln444">            ih  = atof ( &amp;args[3] );</a>
<a name="ln445">            if ( ih &lt; 1 ) {</a>
<a name="ln446">               usage (vty);</a>
<a name="ln447">               return 1;</a>
<a name="ln448">             }</a>
<a name="ln449">            break;</a>
<a name="ln450">          default:  /* unknown switch  value */</a>
<a name="ln451">            usage (vty);</a>
<a name="ln452">            return 1;</a>
<a name="ln453">          }</a>
<a name="ln454">        break;</a>
<a name="ln455"> </a>
<a name="ln456">      case 's' : /* additional source */</a>
<a name="ln457">        s_f = 1;</a>
<a name="ln458">        if ( strlen ( args ) &gt; 2 )</a>
<a name="ln459">        {</a>
<a name="ln460">        switch ( args[2] )</a>
<a name="ln461">          {</a>
<a name="ln462">          case 'l': /* upper bound of art. arc */</a>
<a name="ln463">            sl_f = 1;</a>
<a name="ln464">            sl  =  atol ( &amp;args[3] );</a>
<a name="ln465">            break;</a>
<a name="ln466">          case 'm': /* lower bound of art. arc */</a>
<a name="ln467">            sm_f = 1;</a>
<a name="ln468">            sm  =  atol ( &amp;args[3] );</a>
<a name="ln469">            break;</a>
<a name="ln470">          default:  /* unknown switch  value */</a>
<a name="ln471">            usage (vty);</a>
<a name="ln472">            return 1;</a>
<a name="ln473">          }</a>
<a name="ln474">         }</a>
<a name="ln475">        break;</a>
<a name="ln476"> </a>
<a name="ln477">      case 'p' : /* potentials */</a>
<a name="ln478">        p_f = 1;</a>
<a name="ln479">        if ( strlen ( args ) &gt; 2 )</a>
<a name="ln480">        {</a>
<a name="ln481">        switch ( args[2] )</a>
<a name="ln482">          {</a>
<a name="ln483">          case 'l': /* upper bound */</a>
<a name="ln484">            pl_f = 1;</a>
<a name="ln485">            pl  =  atol ( &amp;args[3] );</a>
<a name="ln486">            break;</a>
<a name="ln487">          case 'm': /* lower bound */</a>
<a name="ln488">            pm_f = 1;</a>
<a name="ln489">            pm  = atol ( &amp;args[3] );</a>
<a name="ln490">            break;</a>
<a name="ln491">          case 'n': /* additional: p *= pn*(x+1) */</a>
<a name="ln492">            pn_f = 1;</a>
<a name="ln493">            pn  = atof ( &amp;args[3] );</a>
<a name="ln494">            break;</a>
<a name="ln495">          case 's': /* additional: p = ps* (x+1)^2 */</a>
<a name="ln496">            ps_f = 1;</a>
<a name="ln497">            ps  = atof ( &amp;args[3] );</a>
<a name="ln498">            break;</a>
<a name="ln499">          default:  /* unknown switch  value */</a>
<a name="ln500">            usage (vty);</a>
<a name="ln501">            return 1;</a>
<a name="ln502">          }</a>
<a name="ln503">        }</a>
<a name="ln504">        break;</a>
<a name="ln505"> </a>
<a name="ln506">      default: /* unknoun case */</a>
<a name="ln507">        usage (vty);</a>
<a name="ln508">        return 1;</a>
<a name="ln509">      }</a>
<a name="ln510">  }</a>
<a name="ln511"> </a>
<a name="ln512"> </a>
<a name="ln513">  return 0;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516"> </a>
<a name="ln517">/* generator of layered networks for the shortest paths problem;</a>
<a name="ln518">   extended DIMACS format for output */</a>
<a name="ln519">int</a>
<a name="ln520">gen_spgrid_topology (struct vty *vty, struct list *topology)</a>
<a name="ln521">{</a>
<a name="ln522">  /* ----- ajusting parameters ----- */</a>
<a name="ln523"> </a>
<a name="ln524">  /* spanning */</a>
<a name="ln525">  if ( cl &lt; cm ) { lx = cl; cl = cm; cm = lx; }</a>
<a name="ln526"> </a>
<a name="ln527">  /* additional arcs */</a>
<a name="ln528">  if ( al &lt; am ) { lx = al; al = am; am = lx; }</a>
<a name="ln529"> </a>
<a name="ln530">  /* interlayered arcs */</a>
<a name="ln531">  if ( il &lt; im ) { lx = il; il = im; im = lx; }</a>
<a name="ln532"> </a>
<a name="ln533">  /* potential parameters */</a>
<a name="ln534">  if ( p_f )</a>
<a name="ln535">    {</a>
<a name="ln536">     if ( ! pl_f ) pl = il;</a>
<a name="ln537">     if ( ! pm_f ) pm = im;</a>
<a name="ln538">     if ( pl &lt; pm ) { lx = pl; pl = pm; pm = lx; }</a>
<a name="ln539">    }</a>
<a name="ln540"> </a>
<a name="ln541">  /* number of nodes and arcs */</a>
<a name="ln542"> </a>
<a name="ln543">  n = (double)X *(double)Y + 1;</a>
<a name="ln544"> </a>
<a name="ln545">  m  = (double)Y; /* arcs from source */</a>
<a name="ln546"> </a>
<a name="ln547">  switch ( cw )</a>
<a name="ln548">  {</a>
<a name="ln549">   case PATH:</a>
<a name="ln550">    mc = (double)Y - 1;</a>
<a name="ln551">    break;</a>
<a name="ln552">   case CYCLE:</a>
<a name="ln553">    mc = (double)Y;</a>
<a name="ln554">    break;</a>
<a name="ln555">   case DOUBLE_CYCLE:</a>
<a name="ln556">    mc = 2*(double)Y;</a>
<a name="ln557">  }</a>
<a name="ln558"> </a>
<a name="ln559">  m += (double)X * (double)mc;  /* spanning arcs */</a>
<a name="ln560">  m += (double)X * (double)ax;  /* additional arcs */</a>
<a name="ln561"> </a>
<a name="ln562">  /* interlayered arcs */</a>
<a name="ln563">  for ( x = 0; x &lt; X; x ++ )</a>
<a name="ln564">  {</a>
<a name="ln565">    dl = ( ( X - x - 1 ) + ( ih - 1 ) ) / ih;</a>
<a name="ln566">    if ( dl &gt; ix ) dl = ix;</a>
<a name="ln567">    m += (double)Y * (double)dl;</a>
<a name="ln568">  }</a>
<a name="ln569"> </a>
<a name="ln570">   /* artifical source parameters */</a>
<a name="ln571">  if ( s_f ) {</a>
<a name="ln572">    m += n; n ++ ;</a>
<a name="ln573">    if ( ! sm_f ) sm = sl;</a>
<a name="ln574">    if ( sl &lt; sm ) { lx = sl; sl = sm; sm = lx; }</a>
<a name="ln575">  }</a>
<a name="ln576"> </a>
<a name="ln577">  if ( n &gt;= (double)LONG_MAX || m &gt;= (double)LONG_MAX )</a>
<a name="ln578">  {</a>
<a name="ln579">    zlog_err (&quot;Too large problem. It can't be generated\n&quot;);</a>
<a name="ln580">    exit (4);</a>
<a name="ln581">  }</a>
<a name="ln582">   else</a>
<a name="ln583">  {</a>
<a name="ln584">    n0 = (long)n; m0 = (long)m;</a>
<a name="ln585">  }</a>
<a name="ln586"> </a>
<a name="ln587">  if ( ip_f )</a>
<a name="ln588">     mess = (long*) calloc ( Y, sizeof ( long ) );</a>
<a name="ln589"> </a>
<a name="ln590">  /* printing title */</a>
<a name="ln591">  zlog_info (&quot;Generating topology for ISIS&quot;);</a>
<a name="ln592"> </a>
<a name="ln593">  source = ( s_f ) ? n0-1 : n0;</a>
<a name="ln594"> </a>
<a name="ln595">  if ( p_f ) /* generating potentials */ {</a>
<a name="ln596">    p = (long*) calloc ( n0+1, sizeof (long) );</a>
<a name="ln597">    seed1 = 2*seed + 1;</a>
<a name="ln598">    init_rand ( seed1);</a>
<a name="ln599">    pl = pl - pm + 1;</a>
<a name="ln600"> </a>
<a name="ln601">    for ( x = 0; x &lt; X; x ++ ) {</a>
<a name="ln602">      for ( y = 0; y &lt; Y; y ++ ) {</a>
<a name="ln603">        p_t = pm + nrand ( pl );</a>
<a name="ln604">        if ( pn_f ) p_t *= (long) ( (1 + x) * pn );</a>
<a name="ln605">        if ( ps_f ) p_t *= (long) ( (1 + x) * ( (1 + x) * ps ));</a>
<a name="ln606"> </a>
<a name="ln607">        p[ NODE ( x, y ) ] = p_t;</a>
<a name="ln608">      }</a>
<a name="ln609">    }</a>
<a name="ln610">    p[n0] = 0;</a>
<a name="ln611">    if ( s_f ) p[n0-1] = 0;</a>
<a name="ln612">  }</a>
<a name="ln613"> </a>
<a name="ln614">  if ( s_f ) /* additional arcs from artifical source */</a>
<a name="ln615">    {</a>
<a name="ln616">      seed2 = 3*seed + 1;</a>
<a name="ln617">      init_rand ( seed2 );</a>
<a name="ln618">      sl = sl - sm + 1;</a>
<a name="ln619"> </a>
<a name="ln620">      for ( x = X - 1; x &gt;= 0; x -- )</a>
<a name="ln621">        for ( y = Y - 1; y &gt;= 0; y -- )</a>
<a name="ln622">        {</a>
<a name="ln623">          i = NODE ( x, y );</a>
<a name="ln624">          s = sm + nrand ( sl );</a>
<a name="ln625">          print_arc (vty, topology,  n0, i, s );</a>
<a name="ln626">        }</a>
<a name="ln627"> </a>
<a name="ln628">      print_arc (vty, topology,  n0, n0-1, 0 );</a>
<a name="ln629">    }</a>
<a name="ln630"> </a>
<a name="ln631"> </a>
<a name="ln632">  /* ----- generating arcs within layers ----- */</a>
<a name="ln633"> </a>
<a name="ln634">  init_rand ( seed );</a>
<a name="ln635">  cl = cl - cm + 1;</a>
<a name="ln636">  al = al - am + 1;</a>
<a name="ln637"> </a>
<a name="ln638">  for ( x = 0; x &lt; X; x ++ )</a>
<a name="ln639">   {</a>
<a name="ln640">  /* generating arcs within one layer */</a>
<a name="ln641">    for ( y = 0; y &lt; Y-1; y ++ )</a>
<a name="ln642">    {</a>
<a name="ln643">       /* generating spanning graph */</a>
<a name="ln644">       i = NODE ( x, y );</a>
<a name="ln645">       j = NODE ( x, y+1 );</a>
<a name="ln646">       l = cm + nrand ( cl );</a>
<a name="ln647">       print_arc (vty, topology,  i, j, l );</a>
<a name="ln648"> </a>
<a name="ln649">       if ( cw == DOUBLE_CYCLE )</a>
<a name="ln650">         {</a>
<a name="ln651">           l = cm + nrand ( cl );</a>
<a name="ln652">           print_arc (vty, topology,  j, i, l );</a>
<a name="ln653">         }</a>
<a name="ln654">     }</a>
<a name="ln655"> </a>
<a name="ln656">    if ( cw &lt;= CYCLE )</a>
<a name="ln657">      {</a>
<a name="ln658">        i = NODE ( x, Y-1 );</a>
<a name="ln659">        j = NODE ( x, 0 );</a>
<a name="ln660">        l = cm + nrand ( cl );</a>
<a name="ln661">        print_arc (vty, topology,  i, j, l );</a>
<a name="ln662"> </a>
<a name="ln663">        if ( cw == DOUBLE_CYCLE )</a>
<a name="ln664">          {</a>
<a name="ln665">  	  l = cm + nrand ( cl );</a>
<a name="ln666">            print_arc (vty, topology,  j, i, l );</a>
<a name="ln667">          }</a>
<a name="ln668">       }</a>
<a name="ln669"> </a>
<a name="ln670">  /* generating additional arcs */</a>
<a name="ln671"> </a>
<a name="ln672">    for ( k = ax; k &gt; 0; k -- )</a>
<a name="ln673">       {</a>
<a name="ln674">         yy1 = nrand ( Y );</a>
<a name="ln675">         do</a>
<a name="ln676">            yy2 = nrand ( Y );</a>
<a name="ln677">         while ( yy2 == yy1 );</a>
<a name="ln678">         i  = NODE ( x, yy1 );</a>
<a name="ln679">         j  = NODE ( x, yy2 );</a>
<a name="ln680">         l = am + nrand ( al );</a>
<a name="ln681">         print_arc (vty, topology,  i, j, l );</a>
<a name="ln682">       }</a>
<a name="ln683">   }</a>
<a name="ln684"> </a>
<a name="ln685">  /* ----- generating interlayered arcs ------ */</a>
<a name="ln686"> </a>
<a name="ln687">  il = il - im + 1;</a>
<a name="ln688"> </a>
<a name="ln689">  /* arcs from the source */</a>
<a name="ln690"> </a>
<a name="ln691">    for ( y = 0; y &lt; Y; y ++ )</a>
<a name="ln692">      {</a>
<a name="ln693">        l = im + nrand ( il );</a>
<a name="ln694">        i = NODE ( 0, y );</a>
<a name="ln695">        print_arc (vty, topology,  source, i, l );</a>
<a name="ln696">      }</a>
<a name="ln697"> </a>
<a name="ln698">  for ( x = 0; x &lt; X-1; x ++ )</a>
<a name="ln699">   {</a>
<a name="ln700">  /* generating arcs from one layer */</a>
<a name="ln701">     for ( count = 0, xn = x + 1;</a>
<a name="ln702">           count &lt; ix &amp;&amp; xn &lt; X;</a>
<a name="ln703">           count ++, xn += ih )</a>
<a name="ln704">      {</a>
<a name="ln705">        if ( ip_f )</a>
<a name="ln706">        for ( y = 0; y &lt; Y; y ++ )</a>
<a name="ln707">  	mess[y] = y;</a>
<a name="ln708"> </a>
<a name="ln709">        for ( y = 0; y &lt; Y; y ++ )</a>
<a name="ln710">         {</a>
<a name="ln711">            i = NODE ( x, y );</a>
<a name="ln712">  	  dx = xn - x;</a>
<a name="ln713">  	  if ( ip_f )</a>
<a name="ln714">  	    {</a>
<a name="ln715">  	      yyp = nrand(Y-y);</a>
<a name="ln716">  	      yyn = mess[ yyp ];</a>
<a name="ln717">                mess[ yyp ] = mess[ Y - y - 1 ];</a>
<a name="ln718">  	    }</a>
<a name="ln719">  	  else</a>
<a name="ln720">               yyn =  y;</a>
<a name="ln721">  	  j = NODE ( xn, yyn );</a>
<a name="ln722">  	  l = im + nrand ( il );</a>
<a name="ln723">  	  if ( in != 0 )</a>
<a name="ln724">              l *= (long) ( in * dx );</a>
<a name="ln725">            if ( is_f )</a>
<a name="ln726">              l *= (long) ( ( is * dx ) * dx );</a>
<a name="ln727">            print_arc (vty, topology,  i, j, l );</a>
<a name="ln728">  	}</a>
<a name="ln729">      }</a>
<a name="ln730">   }</a>
<a name="ln731">  /* all is done */</a>
<a name="ln732">  return ext;</a>
<a name="ln733"> </a>
<a name="ln734">return 0;</a>
<a name="ln735">}</a>
<a name="ln736"> </a>
<a name="ln737"> </a>
<a name="ln738"> </a>

</code></pre>
<div class="balloon" rel="48"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'X', 'Y' variables.</p></div>
<div class="balloon" rel="51"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'x', 'y', 'dl', 'dx', 'xn' variables.</p></div>
<div class="balloon" rel="57"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'n' variable.</p></div>
<div class="balloon" rel="58"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'n0', 'i', 'i0', 'j' variables.</p></div>
<div class="balloon" rel="65"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'm' variable.</p></div>
<div class="balloon" rel="66"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'm0', 'mc', 'k' variables.</p></div>
<div class="balloon" rel="70"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'p', 'l', 'lx' variables.</p></div>
<div class="balloon" rel="88"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'cw' variable.</p></div>
<div class="balloon" rel="89"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'cm', 'cl' variables.</p></div>
<div class="balloon" rel="95"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'ax', 'am', 'al' variables.</p></div>
<div class="balloon" rel="103"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'ip' variable.</p></div>
<div class="balloon" rel="104"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'ix', 'ih', 'il', 'im' variables.</p></div>
<div class="balloon" rel="108"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'in', 'is' variables.</p></div>
<div class="balloon" rel="113"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'sl', 'sm', 's' variables.</p></div>
<div class="balloon" rel="120"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'pl', 'pm' variables.</p></div>
<div class="balloon" rel="122"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'pn', 'ps' variables.</p></div>
<div class="balloon" rel="125"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'np' variable.</p></div>
<div class="balloon" rel="142"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'myarc'. Check lines: 142, 141.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
