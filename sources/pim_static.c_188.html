
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_static.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga: add the ability to configure multicast static routes</a>
<a name="ln3">  Copyright (C) 2014  Nathan Bahr, ATCorp</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14"> </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19"> </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;vty.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;pim_static.h&quot;</a>
<a name="ln28">#include &quot;pim_time.h&quot;</a>
<a name="ln29">#include &quot;pim_str.h&quot;</a>
<a name="ln30">#include &quot;pimd.h&quot;</a>
<a name="ln31">#include &quot;pim_iface.h&quot;</a>
<a name="ln32">#include &quot;log.h&quot;</a>
<a name="ln33">#include &quot;memory.h&quot;</a>
<a name="ln34">#include &quot;linklist.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">void pim_static_route_free(struct static_route *s_route)</a>
<a name="ln37">{</a>
<a name="ln38">  XFREE(MTYPE_PIM_STATIC_ROUTE, s_route);</a>
<a name="ln39">}</a>
<a name="ln40"> </a>
<a name="ln41">static struct static_route * static_route_alloc()</a>
<a name="ln42">{</a>
<a name="ln43">   struct static_route *s_route;</a>
<a name="ln44"> </a>
<a name="ln45">   s_route = XCALLOC(MTYPE_PIM_STATIC_ROUTE, sizeof(*s_route));</a>
<a name="ln46">   if (!s_route) {</a>
<a name="ln47">     zlog_err(&quot;PIM XCALLOC(%zu) failure&quot;, sizeof(*s_route));</a>
<a name="ln48">     return 0;</a>
<a name="ln49">   }</a>
<a name="ln50">   return s_route;</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">static struct static_route *static_route_new(unsigned int   iif,</a>
<a name="ln54">                                             unsigned int   oif,</a>
<a name="ln55">                                             struct in_addr group,</a>
<a name="ln56">                                             struct in_addr source)</a>
<a name="ln57">{</a>
<a name="ln58">  struct static_route * s_route;</a>
<a name="ln59">  s_route = static_route_alloc();</a>
<a name="ln60">  if (!s_route) {</a>
<a name="ln61">     return 0;</a>
<a name="ln62">  }</a>
<a name="ln63"> </a>
<a name="ln64">  s_route-&gt;group             = group;</a>
<a name="ln65">  s_route-&gt;source            = source;</a>
<a name="ln66">  s_route-&gt;iif               = iif;</a>
<a name="ln67">  s_route-&gt;oif_ttls[oif]     = 1;</a>
<a name="ln68">  s_route-&gt;oif_count         = 1;</a>
<a name="ln69">  s_route-&gt;mc.mfcc_origin    = source;</a>
<a name="ln70">  s_route-&gt;mc.mfcc_mcastgrp  = group;</a>
<a name="ln71">  s_route-&gt;mc.mfcc_parent    = iif;</a>
<a name="ln72">  s_route-&gt;mc.mfcc_ttls[oif] = 1;</a>
<a name="ln73">  s_route-&gt;creation[oif] = pim_time_monotonic_sec();</a>
<a name="ln74"> </a>
<a name="ln75">  return s_route;</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">int pim_static_add(struct interface *iif, struct interface *oif, struct in_addr group, struct in_addr source)</a>
<a name="ln80">{</a>
<a name="ln81">   struct listnode *node = 0;</a>
<a name="ln82">   struct static_route *s_route = 0;</a>
<a name="ln83">   struct static_route *original_s_route = 0;</a>
<a name="ln84">   struct pim_interface *pim_iif = iif ? iif-&gt;info : 0;</a>
<a name="ln85">   struct pim_interface *pim_oif = oif ? oif-&gt;info : 0;</a>
<a name="ln86">   unsigned int iif_index = pim_iif ? pim_iif-&gt;mroute_vif_index : 0;</a>
<a name="ln87">   unsigned int oif_index = pim_oif ? pim_oif-&gt;mroute_vif_index : 0;</a>
<a name="ln88"> </a>
<a name="ln89">   if (!iif_index || !oif_index) {</a>
<a name="ln90">      zlog_warn(&quot;%s %s: Unable to add static route: Invalid interface index(iif=%d,oif=%d)&quot;,</a>
<a name="ln91">               __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln92">               iif_index,</a>
<a name="ln93">               oif_index);</a>
<a name="ln94">      return -2;</a>
<a name="ln95">   }</a>
<a name="ln96"> </a>
<a name="ln97">#ifdef PIM_ENFORCE_LOOPFREE_MFC</a>
<a name="ln98">   if (iif_index == oif_index) {</a>
<a name="ln99">      /* looped MFC entry */</a>
<a name="ln100">      zlog_warn(&quot;%s %s: Unable to add static route: Looped MFC entry(iif=%d,oif=%d)&quot;,</a>
<a name="ln101">               __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln102">               iif_index,</a>
<a name="ln103">               oif_index);</a>
<a name="ln104">      return -4;</a>
<a name="ln105">   }</a>
<a name="ln106">#endif</a>
<a name="ln107"> </a>
<a name="ln108">   for (ALL_LIST_ELEMENTS_RO(qpim_static_route_list, node, s_route)) {</a>
<a name="ln109">      if (s_route-&gt;group.s_addr == group.s_addr &amp;&amp;</a>
<a name="ln110">          s_route-&gt;source.s_addr == source.s_addr) {</a>
<a name="ln111">         if (s_route-&gt;iif == iif_index &amp;&amp;</a>
<a name="ln112">             s_route-&gt;oif_ttls[oif_index]) {</a>
<a name="ln113">            char gifaddr_str[100];</a>
<a name="ln114">            char sifaddr_str[100];</a>
<a name="ln115">            pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, group, gifaddr_str, sizeof(gifaddr_str));</a>
<a name="ln116">            pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, source, sifaddr_str, sizeof(sifaddr_str));</a>
<a name="ln117">            zlog_warn(&quot;%s %s: Unable to add static route: Route already exists (iif=%d,oif=%d,group=%s,source=%s)&quot;,</a>
<a name="ln118">                     __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln119">                     iif_index,</a>
<a name="ln120">                     oif_index,</a>
<a name="ln121">                     gifaddr_str,</a>
<a name="ln122">                     sifaddr_str);</a>
<a name="ln123">            return -3;</a>
<a name="ln124">         }</a>
<a name="ln125"> </a>
<a name="ln126">         /* Ok, from here on out we will be making changes to the s_route structure, but if</a>
<a name="ln127">          * for some reason we fail to commit these changes to the kernel, we want to be able</a>
<a name="ln128">          * restore the state of the list. So copy the node data and if need be, we can copy</a>
<a name="ln129">          * back if it fails.</a>
<a name="ln130">          */</a>
<a name="ln131">         original_s_route = static_route_alloc();</a>
<a name="ln132">         if (!original_s_route) {</a>
<a name="ln133">            return -5;</a>
<a name="ln134">         }</a>
<a name="ln135">         memcpy(original_s_route, s_route, sizeof(struct static_route));</a>
<a name="ln136"> </a>
<a name="ln137">         /* Route exists and has the same input interface, but adding a new output interface */</a>
<a name="ln138">         if (s_route-&gt;iif == iif_index) {</a>
<a name="ln139">            s_route-&gt;oif_ttls[oif_index] = 1;</a>
<a name="ln140">            s_route-&gt;mc.mfcc_ttls[oif_index] = 1;</a>
<a name="ln141">            s_route-&gt;creation[oif_index] = pim_time_monotonic_sec();</a>
<a name="ln142">            ++s_route-&gt;oif_count;</a>
<a name="ln143">         } else {</a>
<a name="ln144">            /* input interface changed */</a>
<a name="ln145">            s_route-&gt;iif = iif_index;</a>
<a name="ln146">            s_route-&gt;mc.mfcc_parent = iif_index;</a>
<a name="ln147"> </a>
<a name="ln148">#ifdef PIM_ENFORCE_LOOPFREE_MFC</a>
<a name="ln149">            /* check to make sure the new input was not an old output */</a>
<a name="ln150">            if (s_route-&gt;oif_ttls[iif_index]) {</a>
<a name="ln151">               s_route-&gt;oif_ttls[iif_index] = 0;</a>
<a name="ln152">               s_route-&gt;creation[iif_index] = 0;</a>
<a name="ln153">               s_route-&gt;mc.mfcc_ttls[iif_index] = 0;</a>
<a name="ln154">               --s_route-&gt;oif_count;</a>
<a name="ln155">            }</a>
<a name="ln156">#endif</a>
<a name="ln157"> </a>
<a name="ln158">            /* now add the new output, if it is new */</a>
<a name="ln159">            if (!s_route-&gt;oif_ttls[oif_index]) {</a>
<a name="ln160">               s_route-&gt;oif_ttls[oif_index] = 1;</a>
<a name="ln161">               s_route-&gt;creation[oif_index] = pim_time_monotonic_sec();</a>
<a name="ln162">               s_route-&gt;mc.mfcc_ttls[oif_index] = 1;</a>
<a name="ln163">               ++s_route-&gt;oif_count;</a>
<a name="ln164">            }</a>
<a name="ln165">         }</a>
<a name="ln166"> </a>
<a name="ln167">         break;</a>
<a name="ln168">      }</a>
<a name="ln169">   }</a>
<a name="ln170"> </a>
<a name="ln171">   /* If node is null then we reached the end of the list without finding a match */</a>
<a name="ln172">   if (!node) {</a>
<a name="ln173">      s_route = static_route_new(iif_index, oif_index, group, source);</a>
<a name="ln174">      listnode_add(qpim_static_route_list, s_route);</a>
<a name="ln175">   }</a>
<a name="ln176"> </a>
<a name="ln177">   if (pim_mroute_add(&amp;(s_route-&gt;mc)))</a>
<a name="ln178">   {</a>
<a name="ln179">      char gifaddr_str[100];</a>
<a name="ln180">      char sifaddr_str[100];</a>
<a name="ln181">      pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, group, gifaddr_str, sizeof(gifaddr_str));</a>
<a name="ln182">      pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, source, sifaddr_str, sizeof(sifaddr_str));</a>
<a name="ln183">      zlog_warn(&quot;%s %s: Unable to add static route(iif=%d,oif=%d,group=%s,source=%s)&quot;,</a>
<a name="ln184">               __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln185">               iif_index,</a>
<a name="ln186">               oif_index,</a>
<a name="ln187">               gifaddr_str,</a>
<a name="ln188">               sifaddr_str);</a>
<a name="ln189"> </a>
<a name="ln190">      /* Need to put s_route back to the way it was */</a>
<a name="ln191">      if (original_s_route) {</a>
<a name="ln192">         memcpy(s_route, original_s_route, sizeof(struct static_route));</a>
<a name="ln193">      } else {</a>
<a name="ln194">         /* we never stored off a copy, so it must have been a fresh new route */</a>
<a name="ln195">         listnode_delete(qpim_static_route_list, s_route);</a>
<a name="ln196">         pim_static_route_free(s_route);</a>
<a name="ln197">      }</a>
<a name="ln198"> </a>
<a name="ln199">      if (original_s_route) {</a>
<a name="ln200">         pim_static_route_free(original_s_route);</a>
<a name="ln201">      }</a>
<a name="ln202"> </a>
<a name="ln203">      return -1;</a>
<a name="ln204">   }</a>
<a name="ln205"> </a>
<a name="ln206">   /* Make sure we free the memory for the route copy if used */</a>
<a name="ln207">   if (original_s_route) {</a>
<a name="ln208">      pim_static_route_free(original_s_route);</a>
<a name="ln209">   }</a>
<a name="ln210"> </a>
<a name="ln211">   if (PIM_DEBUG_STATIC) {</a>
<a name="ln212">     char gifaddr_str[100];</a>
<a name="ln213">     char sifaddr_str[100];</a>
<a name="ln214">     pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, group, gifaddr_str, sizeof(gifaddr_str));</a>
<a name="ln215">     pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, source, sifaddr_str, sizeof(sifaddr_str));</a>
<a name="ln216">     zlog_debug(&quot;%s: Static route added(iif=%d,oif=%d,group=%s,source=%s)&quot;,</a>
<a name="ln217">           __PRETTY_FUNCTION__,</a>
<a name="ln218">           iif_index,</a>
<a name="ln219">           oif_index,</a>
<a name="ln220">           gifaddr_str,</a>
<a name="ln221">           sifaddr_str);</a>
<a name="ln222">   }</a>
<a name="ln223"> </a>
<a name="ln224">   return 0;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">int pim_static_del(struct interface *iif, struct interface *oif, struct in_addr group, struct in_addr source)</a>
<a name="ln228">{</a>
<a name="ln229">   struct listnode *node = 0;</a>
<a name="ln230">   struct listnode *nextnode = 0;</a>
<a name="ln231">   struct static_route *s_route = 0;</a>
<a name="ln232">   struct pim_interface *pim_iif = iif ? iif-&gt;info : 0;</a>
<a name="ln233">   struct pim_interface *pim_oif = oif ? oif-&gt;info : 0;</a>
<a name="ln234">   unsigned int iif_index = pim_iif ? pim_iif-&gt;mroute_vif_index : 0;</a>
<a name="ln235">   unsigned int oif_index = pim_oif ? pim_oif-&gt;mroute_vif_index : 0;</a>
<a name="ln236"> </a>
<a name="ln237">   if (!iif_index || !oif_index) {</a>
<a name="ln238">      zlog_warn(&quot;%s %s: Unable to remove static route: Invalid interface index(iif=%d,oif=%d)&quot;,</a>
<a name="ln239">               __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln240">               iif_index,</a>
<a name="ln241">               oif_index);</a>
<a name="ln242">      return -2;</a>
<a name="ln243">   }</a>
<a name="ln244"> </a>
<a name="ln245">   for (ALL_LIST_ELEMENTS(qpim_static_route_list, node, nextnode, s_route)) {</a>
<a name="ln246">      if (s_route-&gt;iif == iif_index &amp;&amp;</a>
<a name="ln247">          s_route-&gt;group.s_addr == group.s_addr &amp;&amp;</a>
<a name="ln248">          s_route-&gt;source.s_addr == source.s_addr &amp;&amp;</a>
<a name="ln249">          s_route-&gt;oif_ttls[oif_index]) {</a>
<a name="ln250">         s_route-&gt;oif_ttls[oif_index] = 0;</a>
<a name="ln251">         s_route-&gt;mc.mfcc_ttls[oif_index] = 0;</a>
<a name="ln252">         --s_route-&gt;oif_count;</a>
<a name="ln253"> </a>
<a name="ln254">         /* If there are no more outputs then delete the whole route, otherwise set the route with the new outputs */</a>
<a name="ln255">         if (s_route-&gt;oif_count &lt;= 0 ? pim_mroute_del(&amp;s_route-&gt;mc) : pim_mroute_add(&amp;s_route-&gt;mc)) {</a>
<a name="ln256">            char gifaddr_str[100];</a>
<a name="ln257">            char sifaddr_str[100];</a>
<a name="ln258">            pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, group, gifaddr_str, sizeof(gifaddr_str));</a>
<a name="ln259">            pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, source, sifaddr_str, sizeof(sifaddr_str));</a>
<a name="ln260">            zlog_warn(&quot;%s %s: Unable to remove static route(iif=%d,oif=%d,group=%s,source=%s)&quot;,</a>
<a name="ln261">                     __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln262">                     iif_index,</a>
<a name="ln263">                     oif_index,</a>
<a name="ln264">                     gifaddr_str,</a>
<a name="ln265">                     sifaddr_str);</a>
<a name="ln266"> </a>
<a name="ln267">            s_route-&gt;oif_ttls[oif_index] = 1;</a>
<a name="ln268">            s_route-&gt;mc.mfcc_ttls[oif_index] = 1;</a>
<a name="ln269">            ++s_route-&gt;oif_count;</a>
<a name="ln270"> </a>
<a name="ln271">            return -1;</a>
<a name="ln272">         }</a>
<a name="ln273"> </a>
<a name="ln274">         s_route-&gt;creation[oif_index] = 0;</a>
<a name="ln275"> </a>
<a name="ln276">         if (s_route-&gt;oif_count &lt;= 0) {</a>
<a name="ln277">            listnode_delete(qpim_static_route_list, s_route);</a>
<a name="ln278">            pim_static_route_free(s_route);</a>
<a name="ln279">         }</a>
<a name="ln280"> </a>
<a name="ln281">         if (PIM_DEBUG_STATIC) {</a>
<a name="ln282">           char gifaddr_str[100];</a>
<a name="ln283">           char sifaddr_str[100];</a>
<a name="ln284">           pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, group, gifaddr_str, sizeof(gifaddr_str));</a>
<a name="ln285">           pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, source, sifaddr_str, sizeof(sifaddr_str));</a>
<a name="ln286">           zlog_debug(&quot;%s: Static route removed(iif=%d,oif=%d,group=%s,source=%s)&quot;,</a>
<a name="ln287">                 __PRETTY_FUNCTION__,</a>
<a name="ln288">                 iif_index,</a>
<a name="ln289">                 oif_index,</a>
<a name="ln290">                 gifaddr_str,</a>
<a name="ln291">                 sifaddr_str);</a>
<a name="ln292">         }</a>
<a name="ln293"> </a>
<a name="ln294">         break;</a>
<a name="ln295">      }</a>
<a name="ln296">   }</a>
<a name="ln297"> </a>
<a name="ln298">   if (!node) {</a>
<a name="ln299">      char gifaddr_str[100];</a>
<a name="ln300">      char sifaddr_str[100];</a>
<a name="ln301">      pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, group, gifaddr_str, sizeof(gifaddr_str));</a>
<a name="ln302">      pim_inet4_dump(&quot;&lt;ifaddr?&gt;&quot;, source, sifaddr_str, sizeof(sifaddr_str));</a>
<a name="ln303">      zlog_warn(&quot;%s %s: Unable to remove static route: Route does not exist(iif=%d,oif=%d,group=%s,source=%s)&quot;,</a>
<a name="ln304">               __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln305">               iif_index,</a>
<a name="ln306">               oif_index,</a>
<a name="ln307">               gifaddr_str,</a>
<a name="ln308">               sifaddr_str);</a>
<a name="ln309">      return -3;</a>
<a name="ln310">   }</a>
<a name="ln311"> </a>
<a name="ln312">   return 0;</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">int</a>
<a name="ln316">pim_static_write_mroute (struct vty *vty, struct interface *ifp)</a>
<a name="ln317">{</a>
<a name="ln318">  struct listnode *node;</a>
<a name="ln319">  struct static_route *sroute;</a>
<a name="ln320">  int count = 0;</a>
<a name="ln321">  char sbuf[100];</a>
<a name="ln322">  char gbuf[100];</a>
<a name="ln323"> </a>
<a name="ln324">  for (ALL_LIST_ELEMENTS_RO (qpim_static_route_list, node, sroute))</a>
<a name="ln325">    {</a>
<a name="ln326">      pim_inet4_dump (&quot;&lt;ifaddr?&gt;&quot;, sroute-&gt;group, gbuf, sizeof (gbuf));</a>
<a name="ln327">      pim_inet4_dump (&quot;&lt;ifaddr?&gt;&quot;, sroute-&gt;source, sbuf, sizeof (sbuf));</a>
<a name="ln328">      if (sroute-&gt;iif == ifp-&gt;ifindex)</a>
<a name="ln329">	{</a>
<a name="ln330">	  int i;</a>
<a name="ln331">	  for (i = 0; i &lt; MAXVIFS; i++)</a>
<a name="ln332">	    if (sroute-&gt;oif_ttls[i])</a>
<a name="ln333">	      {</a>
<a name="ln334">		struct interface *oifp = if_lookup_by_index (i);</a>
<a name="ln335">		vty_out (vty, &quot; ip mroute %s %s %s%s&quot;, oifp-&gt;name, gbuf, sbuf, VTY_NEWLINE);</a>
<a name="ln336">		count ++;</a>
<a name="ln337">	      }</a>
<a name="ln338">	}</a>
<a name="ln339">    }</a>
<a name="ln340"> </a>
<a name="ln341">  return count;</a>
<a name="ln342">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
