
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>zebra_routemap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* zebra routemap.</a>
<a name="ln2"> * Copyright (C) 2006 IBM Corporation</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;memory.h&quot;</a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;rib.h&quot;</a>
<a name="ln27">#include &quot;routemap.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29">#include &quot;filter.h&quot;</a>
<a name="ln30">#include &quot;plist.h&quot;</a>
<a name="ln31">#include &quot;vrf.h&quot;</a>
<a name="ln32">#include &quot;nexthop.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">/* Add zebra route map rule */</a>
<a name="ln37">static int</a>
<a name="ln38">zebra_route_match_add(struct vty *vty, struct route_map_index *index,</a>
<a name="ln39">		      const char *command, const char *arg)</a>
<a name="ln40">{</a>
<a name="ln41">  int ret;</a>
<a name="ln42"> </a>
<a name="ln43">  ret = route_map_add_match (index, command, arg);</a>
<a name="ln44">  if (ret)</a>
<a name="ln45">    {</a>
<a name="ln46">      switch (ret)</a>
<a name="ln47">	{</a>
<a name="ln48">	case RMAP_RULE_MISSING:</a>
<a name="ln49">	  vty_out (vty, &quot;%% Zebra Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln50">	  return CMD_WARNING;</a>
<a name="ln51">	case RMAP_COMPILE_ERROR:</a>
<a name="ln52">	  vty_out (vty, &quot;%% Zebra Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln53">	  return CMD_WARNING;</a>
<a name="ln54">	}</a>
<a name="ln55">    }</a>
<a name="ln56">  return CMD_SUCCESS;</a>
<a name="ln57">}</a>
<a name="ln58"> </a>
<a name="ln59">/* Delete zebra route map rule. */</a>
<a name="ln60">static int</a>
<a name="ln61">zebra_route_match_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln62">			const char *command, const char *arg)</a>
<a name="ln63">{</a>
<a name="ln64">  int ret;</a>
<a name="ln65"> </a>
<a name="ln66">  ret = route_map_delete_match (index, command, arg);</a>
<a name="ln67">  if (ret)</a>
<a name="ln68">    {</a>
<a name="ln69">      switch (ret)</a>
<a name="ln70">	{</a>
<a name="ln71">	case RMAP_RULE_MISSING:</a>
<a name="ln72">	  vty_out (vty, &quot;%% Zebra Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln73">	  return CMD_WARNING;</a>
<a name="ln74">	case RMAP_COMPILE_ERROR:</a>
<a name="ln75">	  vty_out (vty, &quot;%% Zebra Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln76">	  return CMD_WARNING;</a>
<a name="ln77">	}</a>
<a name="ln78">    }</a>
<a name="ln79">  return CMD_SUCCESS;</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">/* Add zebra route map rule. */</a>
<a name="ln83">static int</a>
<a name="ln84">zebra_route_set_add (struct vty *vty, struct route_map_index *index,</a>
<a name="ln85">		   const char *command, const char *arg)</a>
<a name="ln86">{</a>
<a name="ln87">  int ret;</a>
<a name="ln88"> </a>
<a name="ln89">  ret = route_map_add_set (index, command, arg);</a>
<a name="ln90">  if (ret)</a>
<a name="ln91">    {</a>
<a name="ln92">      switch (ret)</a>
<a name="ln93">	{</a>
<a name="ln94">	case RMAP_RULE_MISSING:</a>
<a name="ln95">	  vty_out (vty, &quot;%% Zebra Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln96">	  return CMD_WARNING;</a>
<a name="ln97">	case RMAP_COMPILE_ERROR:</a>
<a name="ln98">	  vty_out (vty, &quot;%% Zebra Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln99">	  return CMD_WARNING;</a>
<a name="ln100">	}</a>
<a name="ln101">    }</a>
<a name="ln102">  return CMD_SUCCESS;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">/* Delete zebra route map rule. */</a>
<a name="ln106">static int</a>
<a name="ln107">zebra_route_set_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln108">		      const char *command, const char *arg)</a>
<a name="ln109">{</a>
<a name="ln110">  int ret;</a>
<a name="ln111"> </a>
<a name="ln112">  ret = route_map_delete_set (index, command, arg);</a>
<a name="ln113">  if (ret)</a>
<a name="ln114">    {</a>
<a name="ln115">      switch (ret)</a>
<a name="ln116">	{</a>
<a name="ln117">	case RMAP_RULE_MISSING:</a>
<a name="ln118">	  vty_out (vty, &quot;%% Zebra Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln119">	  return CMD_WARNING;</a>
<a name="ln120">	case RMAP_COMPILE_ERROR:</a>
<a name="ln121">	  vty_out (vty, &quot;%% Zebra Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln122">	  return CMD_WARNING;</a>
<a name="ln123">	}</a>
<a name="ln124">    }</a>
<a name="ln125">  return CMD_SUCCESS;</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128"> </a>
<a name="ln129">/* `match interface IFNAME' */</a>
<a name="ln130">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln131">static route_map_result_t</a>
<a name="ln132">route_match_interface (void *rule, struct prefix *prefix,</a>
<a name="ln133">		       route_map_object_t type, void *object)</a>
<a name="ln134">{</a>
<a name="ln135">  struct nexthop_vrfid *nh_vrf;</a>
<a name="ln136">  struct nexthop *nexthop;</a>
<a name="ln137">  char *ifname = rule;</a>
<a name="ln138">  ifindex_t ifindex;</a>
<a name="ln139"> </a>
<a name="ln140">  if (type == RMAP_ZEBRA)</a>
<a name="ln141">    {</a>
<a name="ln142">      if (strcasecmp(ifname, &quot;any&quot;) == 0)</a>
<a name="ln143">	return RMAP_MATCH;</a>
<a name="ln144">      nh_vrf = object;</a>
<a name="ln145">      if (!nh_vrf)</a>
<a name="ln146">	return RMAP_NOMATCH;</a>
<a name="ln147">      ifindex = ifname2ifindex_vrf (ifname, nh_vrf-&gt;vrf_id);</a>
<a name="ln148">      if (ifindex == 0)</a>
<a name="ln149">	return RMAP_NOMATCH;</a>
<a name="ln150">      nexthop = nh_vrf-&gt;nexthop;</a>
<a name="ln151">      if (!nexthop)</a>
<a name="ln152">	return RMAP_NOMATCH;</a>
<a name="ln153">      if (nexthop-&gt;ifindex == ifindex)</a>
<a name="ln154">	return RMAP_MATCH;</a>
<a name="ln155">    }</a>
<a name="ln156">  return RMAP_NOMATCH;</a>
<a name="ln157">}</a>
<a name="ln158"> </a>
<a name="ln159">/* Route map `match interface' match statement. `arg' is IFNAME value */</a>
<a name="ln160">static void *</a>
<a name="ln161">route_match_interface_compile (const char *arg)</a>
<a name="ln162">{</a>
<a name="ln163">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">/* Free route map's compiled `match interface' value. */</a>
<a name="ln167">static void</a>
<a name="ln168">route_match_interface_free (void *rule)</a>
<a name="ln169">{</a>
<a name="ln170">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">/* Route map commands for interface matching */</a>
<a name="ln174">struct route_map_rule_cmd route_match_interface_cmd =</a>
<a name="ln175">{</a>
<a name="ln176">   &quot;interface&quot;,</a>
<a name="ln177">   route_match_interface,</a>
<a name="ln178">   route_match_interface_compile,</a>
<a name="ln179">   route_match_interface_free</a>
<a name="ln180">};</a>
<a name="ln181"> </a>
<a name="ln182">DEFUN (match_interface,</a>
<a name="ln183">       match_interface_cmd,</a>
<a name="ln184">       &quot;match interface WORD&quot;,</a>
<a name="ln185">       MATCH_STR</a>
<a name="ln186">       &quot;match first hop interface of route\n&quot;</a>
<a name="ln187">       &quot;Interface name\n&quot;)</a>
<a name="ln188">{</a>
<a name="ln189">  return zebra_route_match_add (vty, vty-&gt;index, &quot;interface&quot;, argv[0]);</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">DEFUN (no_match_interface,</a>
<a name="ln193">       no_match_interface_cmd,</a>
<a name="ln194">       &quot;no match interface&quot;,</a>
<a name="ln195">       NO_STR</a>
<a name="ln196">       MATCH_STR</a>
<a name="ln197">       &quot;Match first hop interface of route\n&quot;)</a>
<a name="ln198">{</a>
<a name="ln199">  if (argc == 0)</a>
<a name="ln200">    return zebra_route_match_delete (vty, vty-&gt;index, &quot;interface&quot;, NULL);</a>
<a name="ln201"> </a>
<a name="ln202">  return zebra_route_match_delete (vty, vty-&gt;index, &quot;interface&quot;, argv[0]);</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">ALIAS (no_match_interface,</a>
<a name="ln206">       no_match_interface_val_cmd,</a>
<a name="ln207">       &quot;no match interface WORD&quot;,</a>
<a name="ln208">       NO_STR</a>
<a name="ln209">       MATCH_STR</a>
<a name="ln210">       &quot;Match first hop interface of route\n&quot;</a>
<a name="ln211">       &quot;Interface name\n&quot;)</a>
<a name="ln212"> </a>
<a name="ln213">DEFUN (match_ip_next_hop,</a>
<a name="ln214">       match_ip_next_hop_cmd,</a>
<a name="ln215">       &quot;match ip next-hop (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln216">       MATCH_STR</a>
<a name="ln217">       IP_STR</a>
<a name="ln218">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln219">       &quot;IP access-list number\n&quot;</a>
<a name="ln220">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln221">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln222">{</a>
<a name="ln223">  return zebra_route_match_add (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">DEFUN (no_match_ip_next_hop,</a>
<a name="ln227">       no_match_ip_next_hop_cmd,</a>
<a name="ln228">       &quot;no match ip next-hop&quot;,</a>
<a name="ln229">       NO_STR</a>
<a name="ln230">       MATCH_STR</a>
<a name="ln231">       IP_STR</a>
<a name="ln232">       &quot;Match next-hop address of route\n&quot;)</a>
<a name="ln233">{</a>
<a name="ln234">  if (argc == 0)</a>
<a name="ln235">    return zebra_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, NULL);</a>
<a name="ln236"> </a>
<a name="ln237">  return zebra_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln238">}</a>
<a name="ln239"> </a>
<a name="ln240">ALIAS (no_match_ip_next_hop,</a>
<a name="ln241">       no_match_ip_next_hop_val_cmd,</a>
<a name="ln242">       &quot;no match ip next-hop (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln243">       NO_STR</a>
<a name="ln244">       MATCH_STR</a>
<a name="ln245">       IP_STR</a>
<a name="ln246">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln247">       &quot;IP access-list number\n&quot;</a>
<a name="ln248">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln249">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln250"> </a>
<a name="ln251">DEFUN (match_ip_next_hop_prefix_list,</a>
<a name="ln252">       match_ip_next_hop_prefix_list_cmd,</a>
<a name="ln253">       &quot;match ip next-hop prefix-list WORD&quot;,</a>
<a name="ln254">       MATCH_STR</a>
<a name="ln255">       IP_STR</a>
<a name="ln256">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln257">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln258">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln259">{</a>
<a name="ln260">  return zebra_route_match_add (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;, argv[0]);</a>
<a name="ln261">}</a>
<a name="ln262"> </a>
<a name="ln263">DEFUN (no_match_ip_next_hop_prefix_list,</a>
<a name="ln264">       no_match_ip_next_hop_prefix_list_cmd,</a>
<a name="ln265">       &quot;no match ip next-hop prefix-list&quot;,</a>
<a name="ln266">       NO_STR</a>
<a name="ln267">       MATCH_STR</a>
<a name="ln268">       IP_STR</a>
<a name="ln269">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln270">       &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln271">{</a>
<a name="ln272">  if (argc == 0)</a>
<a name="ln273">    return zebra_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;, NULL);</a>
<a name="ln274"> </a>
<a name="ln275">  return zebra_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;, argv[0]);</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">ALIAS (no_match_ip_next_hop_prefix_list,</a>
<a name="ln279">       no_match_ip_next_hop_prefix_list_val_cmd,</a>
<a name="ln280">       &quot;no match ip next-hop prefix-list WORD&quot;,</a>
<a name="ln281">       NO_STR</a>
<a name="ln282">       MATCH_STR</a>
<a name="ln283">       IP_STR</a>
<a name="ln284">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln285">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln286">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln287"> </a>
<a name="ln288">DEFUN (match_ip_address,</a>
<a name="ln289">       match_ip_address_cmd,</a>
<a name="ln290">       &quot;match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln291">       MATCH_STR</a>
<a name="ln292">       IP_STR</a>
<a name="ln293">       &quot;Match address of route\n&quot;</a>
<a name="ln294">       &quot;IP access-list number\n&quot;</a>
<a name="ln295">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln296">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln297"> </a>
<a name="ln298">{</a>
<a name="ln299">  return zebra_route_match_add (vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">DEFUN (no_match_ip_address, </a>
<a name="ln303">       no_match_ip_address_cmd,</a>
<a name="ln304">       &quot;no match ip address&quot;,</a>
<a name="ln305">       NO_STR</a>
<a name="ln306">       MATCH_STR</a>
<a name="ln307">       IP_STR</a>
<a name="ln308">       &quot;Match address of route\n&quot;)</a>
<a name="ln309">{</a>
<a name="ln310">  if (argc == 0)</a>
<a name="ln311">    return zebra_route_match_delete (vty, vty-&gt;index, &quot;ip address&quot;, NULL);</a>
<a name="ln312"> </a>
<a name="ln313">  return zebra_route_match_delete (vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">ALIAS (no_match_ip_address,</a>
<a name="ln317">       no_match_ip_address_val_cmd,</a>
<a name="ln318">       &quot;no match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln319">       NO_STR</a>
<a name="ln320">       MATCH_STR</a>
<a name="ln321">       IP_STR</a>
<a name="ln322">       &quot;Match address of route\n&quot;</a>
<a name="ln323">       &quot;IP access-list number\n&quot;</a>
<a name="ln324">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln325">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln326"> </a>
<a name="ln327">DEFUN (match_ip_address_prefix_list, </a>
<a name="ln328">       match_ip_address_prefix_list_cmd,</a>
<a name="ln329">       &quot;match ip address prefix-list WORD&quot;,</a>
<a name="ln330">       MATCH_STR</a>
<a name="ln331">       IP_STR</a>
<a name="ln332">       &quot;Match address of route\n&quot;</a>
<a name="ln333">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln334">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln335">{</a>
<a name="ln336">  return zebra_route_match_add (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, argv[0]);</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">DEFUN (no_match_ip_address_prefix_list,</a>
<a name="ln340">       no_match_ip_address_prefix_list_cmd,</a>
<a name="ln341">       &quot;no match ip address prefix-list&quot;,</a>
<a name="ln342">       NO_STR</a>
<a name="ln343">       MATCH_STR</a>
<a name="ln344">       IP_STR</a>
<a name="ln345">       &quot;Match address of route\n&quot;</a>
<a name="ln346">       &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln347">{</a>
<a name="ln348">  if (argc == 0)</a>
<a name="ln349">    return zebra_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, NULL);</a>
<a name="ln350"> </a>
<a name="ln351">  return zebra_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, argv[0]);</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">ALIAS (no_match_ip_address_prefix_list,</a>
<a name="ln355">       no_match_ip_address_prefix_list_val_cmd,</a>
<a name="ln356">       &quot;no match ip address prefix-list WORD&quot;,</a>
<a name="ln357">       NO_STR</a>
<a name="ln358">       MATCH_STR</a>
<a name="ln359">       IP_STR</a>
<a name="ln360">       &quot;Match address of route\n&quot;</a>
<a name="ln361">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln362">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln363"> </a>
<a name="ln364">/* set functions */</a>
<a name="ln365"> </a>
<a name="ln366">DEFUN (set_src,</a>
<a name="ln367">       set_src_cmd,</a>
<a name="ln368">       &quot;set src A.B.C.D&quot;,</a>
<a name="ln369">       SET_STR</a>
<a name="ln370">       &quot;src address for route\n&quot;</a>
<a name="ln371">       &quot;src address\n&quot;)</a>
<a name="ln372">{</a>
<a name="ln373">  struct in_addr src;</a>
<a name="ln374">  struct interface *pif = NULL;</a>
<a name="ln375">  vrf_iter_t iter;</a>
<a name="ln376"> </a>
<a name="ln377">  if (inet_pton(AF_INET, argv[0], &amp;src) &lt;= 0)</a>
<a name="ln378">    {</a>
<a name="ln379">      vty_out (vty, &quot;%% not a local address%s&quot;, VTY_NEWLINE);</a>
<a name="ln380">      return CMD_WARNING;</a>
<a name="ln381">    }</a>
<a name="ln382"> </a>
<a name="ln383">  for (iter = vrf_first (); iter != VRF_ITER_INVALID; iter = vrf_next (iter))</a>
<a name="ln384">    if ((pif = if_lookup_exact_address_vrf (src, vrf_iter2id (iter))) != NULL)</a>
<a name="ln385">      break;</a>
<a name="ln386"> </a>
<a name="ln387">  if (!pif)</a>
<a name="ln388">    {</a>
<a name="ln389">      vty_out (vty, &quot;%% not a local address%s&quot;, VTY_NEWLINE);</a>
<a name="ln390">      return CMD_WARNING;</a>
<a name="ln391">    }</a>
<a name="ln392"> </a>
<a name="ln393">  return zebra_route_set_add (vty, vty-&gt;index, &quot;src&quot;, argv[0]);</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">DEFUN (no_set_src,</a>
<a name="ln397">       no_set_src_cmd,</a>
<a name="ln398">       &quot;no set src&quot;,</a>
<a name="ln399">       NO_STR</a>
<a name="ln400">       SET_STR</a>
<a name="ln401">       &quot;Source address for route\n&quot;)</a>
<a name="ln402">{</a>
<a name="ln403">  if (argc == 0)</a>
<a name="ln404">    return zebra_route_set_delete (vty, vty-&gt;index, &quot;src&quot;, NULL);</a>
<a name="ln405"> </a>
<a name="ln406">  return zebra_route_set_delete (vty, vty-&gt;index, &quot;src&quot;, argv[0]);</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">ALIAS (no_set_src,</a>
<a name="ln410">       no_set_src_val_cmd,</a>
<a name="ln411">       &quot;no set src (A.B.C.D)&quot;,</a>
<a name="ln412">       NO_STR</a>
<a name="ln413">       SET_STR</a>
<a name="ln414">       &quot;src address for route\n&quot;</a>
<a name="ln415">       &quot;src address\n&quot;)</a>
<a name="ln416"> </a>
<a name="ln417">/*XXXXXXXXXXXXXXXXXXXXXXXXXXXX*/</a>
<a name="ln418"> </a>
<a name="ln419">/* `match ip next-hop IP_ACCESS_LIST' */</a>
<a name="ln420"> </a>
<a name="ln421">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln422">static route_map_result_t</a>
<a name="ln423">route_match_ip_next_hop (void *rule, struct prefix *prefix,</a>
<a name="ln424">			route_map_object_t type, void *object)</a>
<a name="ln425">{</a>
<a name="ln426">  struct access_list *alist;</a>
<a name="ln427">  struct nexthop *nexthop;</a>
<a name="ln428">  struct nexthop_vrfid *nh_vrf;</a>
<a name="ln429">  struct prefix_ipv4 p;</a>
<a name="ln430"> </a>
<a name="ln431">  if (type == RMAP_ZEBRA)</a>
<a name="ln432">    {</a>
<a name="ln433">      nh_vrf = object;</a>
<a name="ln434">      nexthop = nh_vrf-&gt;nexthop;</a>
<a name="ln435">      switch (nexthop-&gt;type) {</a>
<a name="ln436">      case NEXTHOP_TYPE_IFINDEX:</a>
<a name="ln437">      case NEXTHOP_TYPE_IFNAME:</a>
<a name="ln438">        /* Interface routes can't match ip next-hop */</a>
<a name="ln439">        return RMAP_NOMATCH;</a>
<a name="ln440">      case NEXTHOP_TYPE_IPV4_IFINDEX:</a>
<a name="ln441">      case NEXTHOP_TYPE_IPV4_IFNAME:</a>
<a name="ln442">      case NEXTHOP_TYPE_IPV4:</a>
<a name="ln443">        p.family = AF_INET;</a>
<a name="ln444">        p.prefix = nexthop-&gt;gate.ipv4;</a>
<a name="ln445">        p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln446">        break;</a>
<a name="ln447">      default:</a>
<a name="ln448">        return RMAP_NOMATCH;</a>
<a name="ln449">      }</a>
<a name="ln450">      alist = access_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln451">      if (alist == NULL)</a>
<a name="ln452">	return RMAP_NOMATCH;</a>
<a name="ln453"> </a>
<a name="ln454">      return (access_list_apply (alist, &amp;p) == FILTER_DENY ?</a>
<a name="ln455">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln456">    }</a>
<a name="ln457">  return RMAP_NOMATCH;</a>
<a name="ln458">}</a>
<a name="ln459"> </a>
<a name="ln460">/* Route map `ip next-hop' match statement.  `arg' should be</a>
<a name="ln461">   access-list name. */</a>
<a name="ln462">static void *</a>
<a name="ln463">route_match_ip_next_hop_compile (const char *arg)</a>
<a name="ln464">{</a>
<a name="ln465">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468">/* Free route map's compiled `. */</a>
<a name="ln469">static void</a>
<a name="ln470">route_match_ip_next_hop_free (void *rule)</a>
<a name="ln471">{</a>
<a name="ln472">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln473">}</a>
<a name="ln474"> </a>
<a name="ln475">/* Route map commands for ip next-hop matching. */</a>
<a name="ln476">static struct route_map_rule_cmd route_match_ip_next_hop_cmd =</a>
<a name="ln477">{</a>
<a name="ln478">  &quot;ip next-hop&quot;,</a>
<a name="ln479">  route_match_ip_next_hop,</a>
<a name="ln480">  route_match_ip_next_hop_compile,</a>
<a name="ln481">  route_match_ip_next_hop_free</a>
<a name="ln482">};</a>
<a name="ln483"> </a>
<a name="ln484">/* `match ip next-hop prefix-list PREFIX_LIST' */</a>
<a name="ln485"> </a>
<a name="ln486">static route_map_result_t</a>
<a name="ln487">route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,</a>
<a name="ln488">                                    route_map_object_t type, void *object)</a>
<a name="ln489">{</a>
<a name="ln490">  struct prefix_list *plist;</a>
<a name="ln491">  struct nexthop *nexthop;</a>
<a name="ln492">  struct nexthop_vrfid *nh_vrf;</a>
<a name="ln493">  struct prefix_ipv4 p;</a>
<a name="ln494"> </a>
<a name="ln495">  if (type == RMAP_ZEBRA)</a>
<a name="ln496">    {</a>
<a name="ln497">      nh_vrf = object;</a>
<a name="ln498">      nexthop = nh_vrf-&gt;nexthop;</a>
<a name="ln499">      switch (nexthop-&gt;type) {</a>
<a name="ln500">      case NEXTHOP_TYPE_IFINDEX:</a>
<a name="ln501">      case NEXTHOP_TYPE_IFNAME:</a>
<a name="ln502">        /* Interface routes can't match ip next-hop */</a>
<a name="ln503">        return RMAP_NOMATCH;</a>
<a name="ln504">      case NEXTHOP_TYPE_IPV4_IFINDEX:</a>
<a name="ln505">      case NEXTHOP_TYPE_IPV4_IFNAME:</a>
<a name="ln506">      case NEXTHOP_TYPE_IPV4:</a>
<a name="ln507">        p.family = AF_INET;</a>
<a name="ln508">        p.prefix = nexthop-&gt;gate.ipv4;</a>
<a name="ln509">        p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln510">        break;</a>
<a name="ln511">      default:</a>
<a name="ln512">        return RMAP_NOMATCH;</a>
<a name="ln513">      }</a>
<a name="ln514">      plist = prefix_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln515">      if (plist == NULL)</a>
<a name="ln516">        return RMAP_NOMATCH;</a>
<a name="ln517"> </a>
<a name="ln518">      return (prefix_list_apply (plist, &amp;p) == PREFIX_DENY ?</a>
<a name="ln519">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln520">    }</a>
<a name="ln521">  return RMAP_NOMATCH;</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">static void *</a>
<a name="ln525">route_match_ip_next_hop_prefix_list_compile (const char *arg)</a>
<a name="ln526">{</a>
<a name="ln527">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln528">}</a>
<a name="ln529"> </a>
<a name="ln530">static void</a>
<a name="ln531">route_match_ip_next_hop_prefix_list_free (void *rule)</a>
<a name="ln532">{</a>
<a name="ln533">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536">static struct route_map_rule_cmd route_match_ip_next_hop_prefix_list_cmd =</a>
<a name="ln537">{</a>
<a name="ln538">  &quot;ip next-hop prefix-list&quot;,</a>
<a name="ln539">  route_match_ip_next_hop_prefix_list,</a>
<a name="ln540">  route_match_ip_next_hop_prefix_list_compile,</a>
<a name="ln541">  route_match_ip_next_hop_prefix_list_free</a>
<a name="ln542">};</a>
<a name="ln543"> </a>
<a name="ln544">/* `match ip address IP_ACCESS_LIST' */</a>
<a name="ln545"> </a>
<a name="ln546">/* Match function should return 1 if match is success else return</a>
<a name="ln547">   zero. */</a>
<a name="ln548">static route_map_result_t</a>
<a name="ln549">route_match_ip_address (void *rule, struct prefix *prefix, </a>
<a name="ln550">			route_map_object_t type, void *object)</a>
<a name="ln551">{</a>
<a name="ln552">  struct access_list *alist;</a>
<a name="ln553"> </a>
<a name="ln554">  if (type == RMAP_ZEBRA)</a>
<a name="ln555">    {</a>
<a name="ln556">      alist = access_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln557">      if (alist == NULL)</a>
<a name="ln558">	return RMAP_NOMATCH;</a>
<a name="ln559">    </a>
<a name="ln560">      return (access_list_apply (alist, prefix) == FILTER_DENY ?</a>
<a name="ln561">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln562">    }</a>
<a name="ln563">  return RMAP_NOMATCH;</a>
<a name="ln564">}</a>
<a name="ln565"> </a>
<a name="ln566">/* Route map `ip address' match statement.  `arg' should be</a>
<a name="ln567">   access-list name. */</a>
<a name="ln568">static void *</a>
<a name="ln569">route_match_ip_address_compile (const char *arg)</a>
<a name="ln570">{</a>
<a name="ln571">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln572">}</a>
<a name="ln573"> </a>
<a name="ln574">/* Free route map's compiled `ip address' value. */</a>
<a name="ln575">static void</a>
<a name="ln576">route_match_ip_address_free (void *rule)</a>
<a name="ln577">{</a>
<a name="ln578">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">/* Route map commands for ip address matching. */</a>
<a name="ln582">static struct route_map_rule_cmd route_match_ip_address_cmd =</a>
<a name="ln583">{</a>
<a name="ln584">  &quot;ip address&quot;,</a>
<a name="ln585">  route_match_ip_address,</a>
<a name="ln586">  route_match_ip_address_compile,</a>
<a name="ln587">  route_match_ip_address_free</a>
<a name="ln588">};</a>
<a name="ln589"> </a>
<a name="ln590">/* `match ip address prefix-list PREFIX_LIST' */</a>
<a name="ln591"> </a>
<a name="ln592">static route_map_result_t</a>
<a name="ln593">route_match_ip_address_prefix_list (void *rule, struct prefix *prefix, </a>
<a name="ln594">				    route_map_object_t type, void *object)</a>
<a name="ln595">{</a>
<a name="ln596">  struct prefix_list *plist;</a>
<a name="ln597"> </a>
<a name="ln598">  if (type == RMAP_ZEBRA)</a>
<a name="ln599">    {</a>
<a name="ln600">      plist = prefix_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln601">      if (plist == NULL)</a>
<a name="ln602">	return RMAP_NOMATCH;</a>
<a name="ln603">    </a>
<a name="ln604">      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?</a>
<a name="ln605">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln606">    }</a>
<a name="ln607">  return RMAP_NOMATCH;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">static void *</a>
<a name="ln611">route_match_ip_address_prefix_list_compile (const char *arg)</a>
<a name="ln612">{</a>
<a name="ln613">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">static void</a>
<a name="ln617">route_match_ip_address_prefix_list_free (void *rule)</a>
<a name="ln618">{</a>
<a name="ln619">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">static struct route_map_rule_cmd route_match_ip_address_prefix_list_cmd =</a>
<a name="ln623">{</a>
<a name="ln624">  &quot;ip address prefix-list&quot;,</a>
<a name="ln625">  route_match_ip_address_prefix_list,</a>
<a name="ln626">  route_match_ip_address_prefix_list_compile,</a>
<a name="ln627">  route_match_ip_address_prefix_list_free</a>
<a name="ln628">};</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">/* `set src A.B.C.D' */</a>
<a name="ln632"> </a>
<a name="ln633">/* Set src. */</a>
<a name="ln634">static route_map_result_t</a>
<a name="ln635">route_set_src (void *rule, struct prefix *prefix, </a>
<a name="ln636">		  route_map_object_t type, void *object)</a>
<a name="ln637">{</a>
<a name="ln638">  if (type == RMAP_ZEBRA)</a>
<a name="ln639">    {</a>
<a name="ln640">      struct nexthop_vrfid *nh_vrf;</a>
<a name="ln641"> </a>
<a name="ln642">      nh_vrf = object;</a>
<a name="ln643">      nh_vrf-&gt;nexthop-&gt;src = *(union g_addr *)rule;</a>
<a name="ln644">    }</a>
<a name="ln645">  return RMAP_OKAY;</a>
<a name="ln646">}</a>
<a name="ln647"> </a>
<a name="ln648">/* set src compilation. */</a>
<a name="ln649">static void *</a>
<a name="ln650">route_set_src_compile (const char *arg)</a>
<a name="ln651">{</a>
<a name="ln652">  union g_addr src, *psrc;</a>
<a name="ln653"> </a>
<a name="ln654">  if (inet_pton(AF_INET, arg, &amp;src.ipv4) != 1</a>
<a name="ln655">#ifdef HAVE_IPV6</a>
<a name="ln656">      &amp;&amp; inet_pton(AF_INET6, arg, &amp;src.ipv6) != 1</a>
<a name="ln657">#endif /* HAVE_IPV6 */</a>
<a name="ln658">     )</a>
<a name="ln659">    return NULL;</a>
<a name="ln660"> </a>
<a name="ln661">  psrc = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (union g_addr));</a>
<a name="ln662">  *psrc = src;</a>
<a name="ln663"> </a>
<a name="ln664">  return psrc;</a>
<a name="ln665">}</a>
<a name="ln666"> </a>
<a name="ln667">/* Free route map's compiled `set src' value. */</a>
<a name="ln668">static void</a>
<a name="ln669">route_set_src_free (void *rule)</a>
<a name="ln670">{</a>
<a name="ln671">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">/* Set src rule structure. */</a>
<a name="ln675">static struct route_map_rule_cmd route_set_src_cmd = </a>
<a name="ln676">{</a>
<a name="ln677">  &quot;src&quot;,</a>
<a name="ln678">  route_set_src,</a>
<a name="ln679">  route_set_src_compile,</a>
<a name="ln680">  route_set_src_free,</a>
<a name="ln681">};</a>
<a name="ln682"> </a>
<a name="ln683">void</a>
<a name="ln684">zebra_route_map_init ()</a>
<a name="ln685">{</a>
<a name="ln686">  route_map_init ();</a>
<a name="ln687">  route_map_init_vty ();</a>
<a name="ln688"> </a>
<a name="ln689">  route_map_install_match (&amp;route_match_interface_cmd);</a>
<a name="ln690">  route_map_install_match (&amp;route_match_ip_next_hop_cmd);</a>
<a name="ln691">  route_map_install_match (&amp;route_match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln692">  route_map_install_match (&amp;route_match_ip_address_cmd);</a>
<a name="ln693">  route_map_install_match (&amp;route_match_ip_address_prefix_list_cmd);</a>
<a name="ln694">/* */</a>
<a name="ln695">  route_map_install_set (&amp;route_set_src_cmd);</a>
<a name="ln696">/* */</a>
<a name="ln697">  install_element (RMAP_NODE, &amp;match_interface_cmd);</a>
<a name="ln698">  install_element (RMAP_NODE, &amp;no_match_interface_cmd); </a>
<a name="ln699">  install_element (RMAP_NODE, &amp;no_match_interface_val_cmd); </a>
<a name="ln700">  install_element (RMAP_NODE, &amp;match_ip_next_hop_cmd); </a>
<a name="ln701">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_cmd); </a>
<a name="ln702">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_val_cmd); </a>
<a name="ln703">  install_element (RMAP_NODE, &amp;match_ip_next_hop_prefix_list_cmd); </a>
<a name="ln704">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_prefix_list_cmd); </a>
<a name="ln705">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_prefix_list_val_cmd); </a>
<a name="ln706">  install_element (RMAP_NODE, &amp;match_ip_address_cmd); </a>
<a name="ln707">  install_element (RMAP_NODE, &amp;no_match_ip_address_cmd); </a>
<a name="ln708">  install_element (RMAP_NODE, &amp;no_match_ip_address_val_cmd); </a>
<a name="ln709">  install_element (RMAP_NODE, &amp;match_ip_address_prefix_list_cmd); </a>
<a name="ln710">  install_element (RMAP_NODE, &amp;no_match_ip_address_prefix_list_cmd); </a>
<a name="ln711">  install_element (RMAP_NODE, &amp;no_match_ip_address_prefix_list_val_cmd);</a>
<a name="ln712">/* */</a>
<a name="ln713">  install_element (RMAP_NODE, &amp;set_src_cmd);</a>
<a name="ln714">  install_element (RMAP_NODE, &amp;no_set_src_cmd);</a>
<a name="ln715">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
