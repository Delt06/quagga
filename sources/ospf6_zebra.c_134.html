
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf6_zebra.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (C) 2003 Yasuhiro Ohara</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the </a>
<a name="ln18"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330, </a>
<a name="ln19"> * Boston, MA 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;log.h&quot;</a>
<a name="ln25">#include &quot;vty.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;stream.h&quot;</a>
<a name="ln29">#include &quot;zclient.h&quot;</a>
<a name="ln30">#include &quot;memory.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;ospf6_proto.h&quot;</a>
<a name="ln33">#include &quot;ospf6_top.h&quot;</a>
<a name="ln34">#include &quot;ospf6_interface.h&quot;</a>
<a name="ln35">#include &quot;ospf6_route.h&quot;</a>
<a name="ln36">#include &quot;ospf6_lsa.h&quot;</a>
<a name="ln37">#include &quot;ospf6_lsdb.h&quot;</a>
<a name="ln38">#include &quot;ospf6_asbr.h&quot;</a>
<a name="ln39">#include &quot;ospf6_zebra.h&quot;</a>
<a name="ln40">#include &quot;ospf6d.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">unsigned char conf_debug_ospf6_zebra = 0;</a>
<a name="ln43"> </a>
<a name="ln44">/* information about zebra. */</a>
<a name="ln45">struct zclient *zclient = NULL;</a>
<a name="ln46"> </a>
<a name="ln47">struct in_addr router_id_zebra;</a>
<a name="ln48"> </a>
<a name="ln49">/* Router-id update message from zebra. */</a>
<a name="ln50">static int</a>
<a name="ln51">ospf6_router_id_update_zebra (int command, struct zclient *zclient,</a>
<a name="ln52">			      zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln53">{</a>
<a name="ln54">  struct prefix router_id;</a>
<a name="ln55">  struct ospf6 *o = ospf6;</a>
<a name="ln56"> </a>
<a name="ln57">  zebra_router_id_update_read(zclient-&gt;ibuf,&amp;router_id);</a>
<a name="ln58">  router_id_zebra = router_id.u.prefix4;</a>
<a name="ln59"> </a>
<a name="ln60">  if (o == NULL)</a>
<a name="ln61">    return 0;</a>
<a name="ln62"> </a>
<a name="ln63">  if (o-&gt;router_id  == 0)</a>
<a name="ln64">    o-&gt;router_id = (u_int32_t) router_id_zebra.s_addr;</a>
<a name="ln65"> </a>
<a name="ln66">  return 0;</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">/* redistribute function */</a>
<a name="ln70">void</a>
<a name="ln71">ospf6_zebra_redistribute (int type)</a>
<a name="ln72">{</a>
<a name="ln73">  if (vrf_bitmap_check (zclient-&gt;redist[type], VRF_DEFAULT))</a>
<a name="ln74">    return;</a>
<a name="ln75">  vrf_bitmap_set (zclient-&gt;redist[type], VRF_DEFAULT);</a>
<a name="ln76">  if (zclient-&gt;sock &gt; 0)</a>
<a name="ln77">    zebra_redistribute_send (ZEBRA_REDISTRIBUTE_ADD, zclient, type,</a>
<a name="ln78">                             VRF_DEFAULT);</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">void</a>
<a name="ln82">ospf6_zebra_no_redistribute (int type)</a>
<a name="ln83">{</a>
<a name="ln84">  if (! vrf_bitmap_check (zclient-&gt;redist[type], VRF_DEFAULT))</a>
<a name="ln85">    return;</a>
<a name="ln86">  vrf_bitmap_unset (zclient-&gt;redist[type], VRF_DEFAULT);</a>
<a name="ln87">  if (zclient-&gt;sock &gt; 0)</a>
<a name="ln88">    zebra_redistribute_send (ZEBRA_REDISTRIBUTE_DELETE, zclient, type,</a>
<a name="ln89">                             VRF_DEFAULT);</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">/* Inteface addition message from zebra. */</a>
<a name="ln93">static int</a>
<a name="ln94">ospf6_zebra_if_add (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln95">    vrf_id_t vrf_id)</a>
<a name="ln96">{</a>
<a name="ln97">  struct interface *ifp;</a>
<a name="ln98"> </a>
<a name="ln99">  ifp = zebra_interface_add_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln100">  if (IS_OSPF6_DEBUG_ZEBRA (RECV))</a>
<a name="ln101">    zlog_debug (&quot;Zebra Interface add: %s index %d mtu %d&quot;,</a>
<a name="ln102">		ifp-&gt;name, ifp-&gt;ifindex, ifp-&gt;mtu6);</a>
<a name="ln103">  ospf6_interface_if_add (ifp);</a>
<a name="ln104">  return 0;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">static int</a>
<a name="ln108">ospf6_zebra_if_del (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln109">    vrf_id_t vrf_id)</a>
<a name="ln110">{</a>
<a name="ln111">  struct interface *ifp;</a>
<a name="ln112"> </a>
<a name="ln113">  if (!(ifp = zebra_interface_state_read (zclient-&gt;ibuf, vrf_id)))</a>
<a name="ln114">    return 0;</a>
<a name="ln115"> </a>
<a name="ln116">  if (if_is_up (ifp))</a>
<a name="ln117">    zlog_warn (&quot;Zebra: got delete of %s, but interface is still up&quot;, ifp-&gt;name);</a>
<a name="ln118"> </a>
<a name="ln119">  if (IS_OSPF6_DEBUG_ZEBRA (RECV))</a>
<a name="ln120">    zlog_debug (&quot;Zebra Interface delete: %s index %d mtu %d&quot;,</a>
<a name="ln121">		ifp-&gt;name, ifp-&gt;ifindex, ifp-&gt;mtu6);</a>
<a name="ln122"> </a>
<a name="ln123">  ifp-&gt;ifindex = IFINDEX_INTERNAL;</a>
<a name="ln124">  return 0;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">static int</a>
<a name="ln128">ospf6_zebra_if_state_update (int command, struct zclient *zclient,</a>
<a name="ln129">                             zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln130">{</a>
<a name="ln131">  struct interface *ifp;</a>
<a name="ln132"> </a>
<a name="ln133">  ifp = zebra_interface_state_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln134">  if (ifp == NULL)</a>
<a name="ln135">    return 0;</a>
<a name="ln136">  </a>
<a name="ln137">  if (IS_OSPF6_DEBUG_ZEBRA (RECV))</a>
<a name="ln138">    zlog_debug (&quot;Zebra Interface state change: &quot;</a>
<a name="ln139">                &quot;%s index %d flags %llx metric %d mtu %d bandwidth %d&quot;,</a>
<a name="ln140">		ifp-&gt;name, ifp-&gt;ifindex, (unsigned long long)ifp-&gt;flags, </a>
<a name="ln141">		ifp-&gt;metric, ifp-&gt;mtu6, ifp-&gt;bandwidth);</a>
<a name="ln142"> </a>
<a name="ln143">  ospf6_interface_state_update (ifp);</a>
<a name="ln144">  return 0;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">static int</a>
<a name="ln148">ospf6_zebra_if_address_update_add (int command, struct zclient *zclient,</a>
<a name="ln149">                                   zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln150">{</a>
<a name="ln151">  struct connected *c;</a>
<a name="ln152">  char buf[128];</a>
<a name="ln153"> </a>
<a name="ln154">  c = zebra_interface_address_read (ZEBRA_INTERFACE_ADDRESS_ADD, zclient-&gt;ibuf,</a>
<a name="ln155">                                    vrf_id);</a>
<a name="ln156">  if (c == NULL)</a>
<a name="ln157">    return 0;</a>
<a name="ln158"> </a>
<a name="ln159">  if (IS_OSPF6_DEBUG_ZEBRA (RECV))</a>
<a name="ln160">    zlog_debug (&quot;Zebra Interface address add: %s %5s %s/%d&quot;,</a>
<a name="ln161">		c-&gt;ifp-&gt;name, prefix_family_str (c-&gt;address),</a>
<a name="ln162">		inet_ntop (c-&gt;address-&gt;family, &amp;c-&gt;address-&gt;u.prefix,</a>
<a name="ln163">			   buf, sizeof (buf)), c-&gt;address-&gt;prefixlen);</a>
<a name="ln164"> </a>
<a name="ln165">  if (c-&gt;address-&gt;family == AF_INET6)</a>
<a name="ln166">    {</a>
<a name="ln167">      ospf6_interface_state_update (c-&gt;ifp);</a>
<a name="ln168">      ospf6_interface_connected_route_update (c-&gt;ifp);</a>
<a name="ln169">    }</a>
<a name="ln170">  return 0;</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">static int</a>
<a name="ln174">ospf6_zebra_if_address_update_delete (int command, struct zclient *zclient,</a>
<a name="ln175">                               zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln176">{</a>
<a name="ln177">  struct connected *c;</a>
<a name="ln178">  char buf[128];</a>
<a name="ln179"> </a>
<a name="ln180">  c = zebra_interface_address_read (ZEBRA_INTERFACE_ADDRESS_DELETE, zclient-&gt;ibuf,</a>
<a name="ln181">                                    vrf_id);</a>
<a name="ln182">  if (c == NULL)</a>
<a name="ln183">    return 0;</a>
<a name="ln184"> </a>
<a name="ln185">  if (IS_OSPF6_DEBUG_ZEBRA (RECV))</a>
<a name="ln186">    zlog_debug (&quot;Zebra Interface address delete: %s %5s %s/%d&quot;,</a>
<a name="ln187">		c-&gt;ifp-&gt;name, prefix_family_str (c-&gt;address),</a>
<a name="ln188">		inet_ntop (c-&gt;address-&gt;family, &amp;c-&gt;address-&gt;u.prefix,</a>
<a name="ln189">			   buf, sizeof (buf)), c-&gt;address-&gt;prefixlen);</a>
<a name="ln190"> </a>
<a name="ln191">  if (c-&gt;address-&gt;family == AF_INET6)</a>
<a name="ln192">    {</a>
<a name="ln193">      ospf6_interface_connected_route_update (c-&gt;ifp);</a>
<a name="ln194">      ospf6_interface_state_update (c-&gt;ifp);</a>
<a name="ln195">    }</a>
<a name="ln196"> </a>
<a name="ln197">  return 0;</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">static int</a>
<a name="ln201">ospf6_zebra_read_ipv6 (int command, struct zclient *zclient,</a>
<a name="ln202">                       zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln203">{</a>
<a name="ln204">  struct stream *s;</a>
<a name="ln205">  struct zapi_ipv6 api;</a>
<a name="ln206">  unsigned long ifindex;</a>
<a name="ln207">  struct prefix_ipv6 p;</a>
<a name="ln208">  struct in6_addr *nexthop;</a>
<a name="ln209">  unsigned char plength = 0;</a>
<a name="ln210"> </a>
<a name="ln211">  s = zclient-&gt;ibuf;</a>
<a name="ln212">  ifindex = 0;</a>
<a name="ln213">  nexthop = NULL;</a>
<a name="ln214">  memset (&amp;api, 0, sizeof (api));</a>
<a name="ln215"> </a>
<a name="ln216">  /* Type, flags, message. */</a>
<a name="ln217">  api.type = stream_getc (s);</a>
<a name="ln218">  api.flags = stream_getc (s);</a>
<a name="ln219">  api.message = stream_getc (s);</a>
<a name="ln220"> </a>
<a name="ln221">  /* IPv6 prefix. */</a>
<a name="ln222">  memset (&amp;p, 0, sizeof (struct prefix_ipv6));</a>
<a name="ln223">  p.family = AF_INET6;</a>
<a name="ln224">  plength = stream_getc (s);</a>
<a name="ln225">  p.prefixlen = MIN(IPV6_MAX_PREFIXLEN, plength);</a>
<a name="ln226">  stream_get (&amp;p.prefix, s, PSIZE (p.prefixlen));</a>
<a name="ln227"> </a>
<a name="ln228">  /* Nexthop, ifindex, distance, metric. */</a>
<a name="ln229">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln230">    {</a>
<a name="ln231">      api.nexthop_num = stream_getc (s);</a>
<a name="ln232">      nexthop = (struct in6_addr *)</a>
<a name="ln233">        malloc (api.nexthop_num * sizeof (struct in6_addr));</a>
<a name="ln234">      stream_get (nexthop, s, api.nexthop_num * sizeof (struct in6_addr));</a>
<a name="ln235">    }</a>
<a name="ln236">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))</a>
<a name="ln237">    {</a>
<a name="ln238">      api.ifindex_num = stream_getc (s);</a>
<a name="ln239">      ifindex = stream_getl (s);</a>
<a name="ln240">    }</a>
<a name="ln241">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln242">    api.distance = stream_getc (s);</a>
<a name="ln243">  else</a>
<a name="ln244">    api.distance = 0;</a>
<a name="ln245">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln246">    api.metric = stream_getl (s);</a>
<a name="ln247">  else</a>
<a name="ln248">    api.metric = 0;</a>
<a name="ln249"> </a>
<a name="ln250">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_TAG))</a>
<a name="ln251">    api.tag = stream_getl (s);</a>
<a name="ln252">  else</a>
<a name="ln253">    api.tag = 0;</a>
<a name="ln254"> </a>
<a name="ln255">  if (IS_OSPF6_DEBUG_ZEBRA (RECV))</a>
<a name="ln256">    {</a>
<a name="ln257">      char prefixstr[128], nexthopstr[128];</a>
<a name="ln258">      prefix2str ((struct prefix *)&amp;p, prefixstr, sizeof (prefixstr));</a>
<a name="ln259">      if (nexthop)</a>
<a name="ln260">        inet_ntop (AF_INET6, nexthop, nexthopstr, sizeof (nexthopstr));</a>
<a name="ln261">      else</a>
<a name="ln262">        snprintf (nexthopstr, sizeof (nexthopstr), &quot;::&quot;);</a>
<a name="ln263"> </a>
<a name="ln264">      zlog_debug (&quot;Zebra Receive route %s: %s %s nexthop %s ifindex %ld tag %u&quot;,</a>
<a name="ln265">		  (command == ZEBRA_IPV6_ROUTE_ADD ? &quot;add&quot; : &quot;delete&quot;),</a>
<a name="ln266">		  zebra_route_string(api.type), prefixstr, nexthopstr, ifindex, api.tag);</a>
<a name="ln267">    }</a>
<a name="ln268"> </a>
<a name="ln269">  if (command == ZEBRA_IPV6_ROUTE_ADD)</a>
<a name="ln270">    ospf6_asbr_redistribute_add (api.type, ifindex, (struct prefix *) &amp;p,</a>
<a name="ln271">                                 api.nexthop_num, nexthop, api.tag);</a>
<a name="ln272">  else</a>
<a name="ln273">    ospf6_asbr_redistribute_remove (api.type, ifindex, (struct prefix *) &amp;p);</a>
<a name="ln274"> </a>
<a name="ln275">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln276">    free (nexthop);</a>
<a name="ln277"> </a>
<a name="ln278">  return 0;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282"> </a>
<a name="ln283"> </a>
<a name="ln284">DEFUN (show_zebra,</a>
<a name="ln285">       show_zebra_cmd,</a>
<a name="ln286">       &quot;show zebra&quot;,</a>
<a name="ln287">       SHOW_STR</a>
<a name="ln288">       &quot;Zebra information\n&quot;)</a>
<a name="ln289">{</a>
<a name="ln290">  int i;</a>
<a name="ln291">  if (zclient == NULL)</a>
<a name="ln292">    {</a>
<a name="ln293">      vty_out (vty, &quot;Not connected to zebra%s&quot;, VNL);</a>
<a name="ln294">      return CMD_SUCCESS;</a>
<a name="ln295">    }</a>
<a name="ln296"> </a>
<a name="ln297">  vty_out (vty, &quot;Zebra Infomation%s&quot;, VNL);</a>
<a name="ln298">  vty_out (vty, &quot;  enable: %d fail: %d%s&quot;,</a>
<a name="ln299">           zclient-&gt;enable, zclient-&gt;fail, VNL);</a>
<a name="ln300">  vty_out (vty, &quot;  redistribute default: %d%s&quot;,</a>
<a name="ln301">           vrf_bitmap_check (zclient-&gt;default_information, VRF_DEFAULT),</a>
<a name="ln302">           VNL);</a>
<a name="ln303">  vty_out (vty, &quot;  redistribute:&quot;);</a>
<a name="ln304">  for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln305">    {</a>
<a name="ln306">      if (vrf_bitmap_check (zclient-&gt;redist[i], VRF_DEFAULT))</a>
<a name="ln307">        vty_out (vty, &quot; %s&quot;, zebra_route_string(i));</a>
<a name="ln308">    }</a>
<a name="ln309">  vty_out (vty, &quot;%s&quot;, VNL);</a>
<a name="ln310">  return CMD_SUCCESS;</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">DEFUN (router_zebra,</a>
<a name="ln314">       router_zebra_cmd,</a>
<a name="ln315">       &quot;router zebra&quot;,</a>
<a name="ln316">       &quot;Enable a routing process\n&quot;</a>
<a name="ln317">       &quot;Make connection to zebra daemon\n&quot;)</a>
<a name="ln318">{</a>
<a name="ln319">  vty-&gt;node = ZEBRA_NODE;</a>
<a name="ln320">  zclient-&gt;enable = 1;</a>
<a name="ln321">  zclient_start (zclient);</a>
<a name="ln322">  return CMD_SUCCESS;</a>
<a name="ln323">}</a>
<a name="ln324"> </a>
<a name="ln325">DEFUN (no_router_zebra,</a>
<a name="ln326">       no_router_zebra_cmd,</a>
<a name="ln327">       &quot;no router zebra&quot;,</a>
<a name="ln328">       NO_STR</a>
<a name="ln329">       &quot;Configure routing process\n&quot;</a>
<a name="ln330">       &quot;Disable connection to zebra daemon\n&quot;)</a>
<a name="ln331">{</a>
<a name="ln332">  zclient-&gt;enable = 0;</a>
<a name="ln333">  zclient_stop (zclient);</a>
<a name="ln334">  return CMD_SUCCESS;</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">/* Zebra configuration write function. */</a>
<a name="ln338">static int</a>
<a name="ln339">config_write_ospf6_zebra (struct vty *vty)</a>
<a name="ln340">{</a>
<a name="ln341">  if (! zclient-&gt;enable)</a>
<a name="ln342">    {</a>
<a name="ln343">      vty_out (vty, &quot;no router zebra%s&quot;, VNL);</a>
<a name="ln344">      vty_out (vty, &quot;!%s&quot;, VNL);</a>
<a name="ln345">    }</a>
<a name="ln346">  else if (! vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_OSPF6], VRF_DEFAULT))</a>
<a name="ln347">    {</a>
<a name="ln348">      vty_out (vty, &quot;router zebra%s&quot;, VNL);</a>
<a name="ln349">      vty_out (vty, &quot; no redistribute ospf6%s&quot;, VNL);</a>
<a name="ln350">      vty_out (vty, &quot;!%s&quot;, VNL);</a>
<a name="ln351">    }</a>
<a name="ln352">  return 0;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">/* Zebra node structure. */</a>
<a name="ln356">static struct cmd_node zebra_node =</a>
<a name="ln357">{</a>
<a name="ln358">  ZEBRA_NODE,</a>
<a name="ln359">  &quot;%s(config-zebra)# &quot;,</a>
<a name="ln360">};</a>
<a name="ln361"> </a>
<a name="ln362">#define ADD    0</a>
<a name="ln363">#define REM    1</a>
<a name="ln364">static void</a>
<a name="ln365">ospf6_zebra_route_update (int type, struct ospf6_route *request)</a>
<a name="ln366">{</a>
<a name="ln367">  struct zapi_ipv6 api;</a>
<a name="ln368">  char buf[64];</a>
<a name="ln369">  int nhcount;</a>
<a name="ln370">  struct in6_addr **nexthops;</a>
<a name="ln371">  ifindex_t *ifindexes;</a>
<a name="ln372">  int i, ret = 0;</a>
<a name="ln373">  struct prefix_ipv6 *dest;</a>
<a name="ln374"> </a>
<a name="ln375">  if (IS_OSPF6_DEBUG_ZEBRA (SEND))</a>
<a name="ln376">    {</a>
<a name="ln377">      prefix2str (&amp;request-&gt;prefix, buf, sizeof (buf));</a>
<a name="ln378">      zlog_debug (&quot;Send %s route: %s&quot;,</a>
<a name="ln379">		  (type == REM ? &quot;remove&quot; : &quot;add&quot;), buf);</a>
<a name="ln380">    }</a>
<a name="ln381"> </a>
<a name="ln382">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln383">    {</a>
<a name="ln384">      if (IS_OSPF6_DEBUG_ZEBRA (SEND))</a>
<a name="ln385">        zlog_debug (&quot;  Not connected to Zebra&quot;);</a>
<a name="ln386">      return;</a>
<a name="ln387">    }</a>
<a name="ln388"> </a>
<a name="ln389">  if (request-&gt;path.origin.adv_router == ospf6-&gt;router_id &amp;&amp;</a>
<a name="ln390">      (request-&gt;path.type == OSPF6_PATH_TYPE_EXTERNAL1 ||</a>
<a name="ln391">       request-&gt;path.type == OSPF6_PATH_TYPE_EXTERNAL2))</a>
<a name="ln392">    {</a>
<a name="ln393">      if (IS_OSPF6_DEBUG_ZEBRA (SEND))</a>
<a name="ln394">        zlog_debug (&quot;  Ignore self-originated external route&quot;);</a>
<a name="ln395">      return;</a>
<a name="ln396">    }</a>
<a name="ln397"> </a>
<a name="ln398">  /* If removing is the best path and if there's another path,</a>
<a name="ln399">     treat this request as add the secondary path */</a>
<a name="ln400">  if (type == REM &amp;&amp; ospf6_route_is_best (request) &amp;&amp;</a>
<a name="ln401">      request-&gt;next &amp;&amp; ospf6_route_is_same (request, request-&gt;next))</a>
<a name="ln402">    {</a>
<a name="ln403">      if (IS_OSPF6_DEBUG_ZEBRA (SEND))</a>
<a name="ln404">        zlog_debug (&quot;  Best-path removal resulted Sencondary addition&quot;);</a>
<a name="ln405">      type = ADD;</a>
<a name="ln406">      request = request-&gt;next;</a>
<a name="ln407">    }</a>
<a name="ln408"> </a>
<a name="ln409">  /* Only the best path will be sent to zebra. */</a>
<a name="ln410">  if (! ospf6_route_is_best (request))</a>
<a name="ln411">    {</a>
<a name="ln412">      /* this is not preferred best route, ignore */</a>
<a name="ln413">      if (IS_OSPF6_DEBUG_ZEBRA (SEND))</a>
<a name="ln414">        zlog_debug (&quot;  Ignore non-best route&quot;);</a>
<a name="ln415">      return;</a>
<a name="ln416">    }</a>
<a name="ln417"> </a>
<a name="ln418">  nhcount = 0;</a>
<a name="ln419">  for (i = 0; i &lt; OSPF6_MULTI_PATH_LIMIT; i++)</a>
<a name="ln420">    if (ospf6_nexthop_is_set (&amp;request-&gt;nexthop[i]))</a>
<a name="ln421">      nhcount++;</a>
<a name="ln422"> </a>
<a name="ln423">  if (nhcount == 0)</a>
<a name="ln424">    {</a>
<a name="ln425">      if (IS_OSPF6_DEBUG_ZEBRA (SEND))</a>
<a name="ln426">        zlog_debug (&quot;  No nexthop, ignore&quot;);</a>
<a name="ln427">      return;</a>
<a name="ln428">    }</a>
<a name="ln429"> </a>
<a name="ln430">  /* allocate memory for nexthop_list */</a>
<a name="ln431">  nexthops = XCALLOC (MTYPE_OSPF6_OTHER,</a>
<a name="ln432">                      nhcount * sizeof (struct in6_addr *));</a>
<a name="ln433">  if (nexthops == NULL)</a>
<a name="ln434">    {</a>
<a name="ln435">      zlog_warn (&quot;Can't send route to zebra: malloc failed&quot;);</a>
<a name="ln436">      return;</a>
<a name="ln437">    }</a>
<a name="ln438"> </a>
<a name="ln439">  /* allocate memory for ifindex_list */</a>
<a name="ln440">  ifindexes = XCALLOC (MTYPE_OSPF6_OTHER,</a>
<a name="ln441">                       nhcount * sizeof (unsigned int));</a>
<a name="ln442">  if (ifindexes == NULL)</a>
<a name="ln443">    {</a>
<a name="ln444">      zlog_warn (&quot;Can't send route to zebra: malloc failed&quot;);</a>
<a name="ln445">      XFREE (MTYPE_OSPF6_OTHER, nexthops);</a>
<a name="ln446">      return;</a>
<a name="ln447">    }</a>
<a name="ln448"> </a>
<a name="ln449">  for (i = 0; i &lt; nhcount; i++)</a>
<a name="ln450">    {</a>
<a name="ln451">      if (IS_OSPF6_DEBUG_ZEBRA (SEND))</a>
<a name="ln452">	{</a>
<a name="ln453">	  const char *ifname;</a>
<a name="ln454">	  inet_ntop (AF_INET6, &amp;request-&gt;nexthop[i].address,</a>
<a name="ln455">		     buf, sizeof (buf));</a>
<a name="ln456">	  ifname = ifindex2ifname (request-&gt;nexthop[i].ifindex);</a>
<a name="ln457">	  zlog_debug (&quot;  nexthop: %s%%%.*s(%d)&quot;, buf, IFNAMSIZ, ifname,</a>
<a name="ln458">		      request-&gt;nexthop[i].ifindex);</a>
<a name="ln459">	}</a>
<a name="ln460">      nexthops[i] = &amp;request-&gt;nexthop[i].address;</a>
<a name="ln461">      ifindexes[i] = request-&gt;nexthop[i].ifindex;</a>
<a name="ln462">    }</a>
<a name="ln463"> </a>
<a name="ln464">  api.vrf_id = VRF_DEFAULT;</a>
<a name="ln465">  api.type = ZEBRA_ROUTE_OSPF6;</a>
<a name="ln466">  api.flags = 0;</a>
<a name="ln467">  api.message = 0;</a>
<a name="ln468">  api.safi = SAFI_UNICAST;</a>
<a name="ln469">  SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln470">  api.nexthop_num = nhcount;</a>
<a name="ln471">  api.nexthop = nexthops;</a>
<a name="ln472">  SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);</a>
<a name="ln473">  api.ifindex_num = nhcount;</a>
<a name="ln474">  api.ifindex = ifindexes;</a>
<a name="ln475">  SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);</a>
<a name="ln476">  api.metric = (request-&gt;path.metric_type == 2 ?</a>
<a name="ln477">                request-&gt;path.cost_e2 : request-&gt;path.cost);</a>
<a name="ln478">  if (request-&gt;path.tag)</a>
<a name="ln479">    {</a>
<a name="ln480">      SET_FLAG (api.message, ZAPI_MESSAGE_TAG);</a>
<a name="ln481">      api.tag = request-&gt;path.tag;</a>
<a name="ln482">    }</a>
<a name="ln483">  </a>
<a name="ln484">  dest = (struct prefix_ipv6 *) &amp;request-&gt;prefix;</a>
<a name="ln485">  if (type == REM)</a>
<a name="ln486">    ret = zapi_ipv6_route (ZEBRA_IPV6_ROUTE_DELETE, zclient, dest, &amp;api);</a>
<a name="ln487">  else</a>
<a name="ln488">    ret = zapi_ipv6_route (ZEBRA_IPV6_ROUTE_ADD, zclient, dest, &amp;api);</a>
<a name="ln489"> </a>
<a name="ln490">  if (ret &lt; 0)</a>
<a name="ln491">    zlog_err (&quot;zapi_ipv6_route() %s failed: %s&quot;,</a>
<a name="ln492">              (type == REM ? &quot;delete&quot; : &quot;add&quot;), safe_strerror (errno));</a>
<a name="ln493"> </a>
<a name="ln494">  XFREE (MTYPE_OSPF6_OTHER, nexthops);</a>
<a name="ln495">  XFREE (MTYPE_OSPF6_OTHER, ifindexes);</a>
<a name="ln496"> </a>
<a name="ln497">  return;</a>
<a name="ln498">}</a>
<a name="ln499"> </a>
<a name="ln500">void</a>
<a name="ln501">ospf6_zebra_route_update_add (struct ospf6_route *request)</a>
<a name="ln502">{</a>
<a name="ln503">  if (! vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_OSPF6], VRF_DEFAULT))</a>
<a name="ln504">    {</a>
<a name="ln505">      ospf6-&gt;route_table-&gt;hook_add = NULL;</a>
<a name="ln506">      ospf6-&gt;route_table-&gt;hook_remove = NULL;</a>
<a name="ln507">      return;</a>
<a name="ln508">    }</a>
<a name="ln509">  ospf6_zebra_route_update (ADD, request);</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">void</a>
<a name="ln513">ospf6_zebra_route_update_remove (struct ospf6_route *request)</a>
<a name="ln514">{</a>
<a name="ln515">  if (! vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_OSPF6], VRF_DEFAULT))</a>
<a name="ln516">    {</a>
<a name="ln517">      ospf6-&gt;route_table-&gt;hook_add = NULL;</a>
<a name="ln518">      ospf6-&gt;route_table-&gt;hook_remove = NULL;</a>
<a name="ln519">      return;</a>
<a name="ln520">    }</a>
<a name="ln521">  ospf6_zebra_route_update (REM, request);</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">DEFUN (redistribute_ospf6,</a>
<a name="ln525">       redistribute_ospf6_cmd,</a>
<a name="ln526">       &quot;redistribute ospf6&quot;,</a>
<a name="ln527">       &quot;Redistribute control\n&quot;</a>
<a name="ln528">       &quot;OSPF6 route\n&quot;)</a>
<a name="ln529">{</a>
<a name="ln530">  struct ospf6_route *route;</a>
<a name="ln531"> </a>
<a name="ln532">  if (vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_OSPF6], VRF_DEFAULT))</a>
<a name="ln533">    return CMD_SUCCESS;</a>
<a name="ln534"> </a>
<a name="ln535">  vrf_bitmap_set (zclient-&gt;redist[ZEBRA_ROUTE_OSPF6], VRF_DEFAULT);</a>
<a name="ln536"> </a>
<a name="ln537">  if (ospf6 == NULL)</a>
<a name="ln538">    return CMD_SUCCESS;</a>
<a name="ln539"> </a>
<a name="ln540">  /* send ospf6 route to zebra route table */</a>
<a name="ln541">  for (route = ospf6_route_head (ospf6-&gt;route_table); route;</a>
<a name="ln542">       route = ospf6_route_next (route))</a>
<a name="ln543">    ospf6_zebra_route_update_add (route);</a>
<a name="ln544"> </a>
<a name="ln545">  ospf6-&gt;route_table-&gt;hook_add = ospf6_zebra_route_update_add;</a>
<a name="ln546">  ospf6-&gt;route_table-&gt;hook_remove = ospf6_zebra_route_update_remove;</a>
<a name="ln547"> </a>
<a name="ln548">  return CMD_SUCCESS;</a>
<a name="ln549">}</a>
<a name="ln550"> </a>
<a name="ln551">DEFUN (no_redistribute_ospf6,</a>
<a name="ln552">       no_redistribute_ospf6_cmd,</a>
<a name="ln553">       &quot;no redistribute ospf6&quot;,</a>
<a name="ln554">       NO_STR</a>
<a name="ln555">       &quot;Redistribute control\n&quot;</a>
<a name="ln556">       &quot;OSPF6 route\n&quot;)</a>
<a name="ln557">{</a>
<a name="ln558">  struct ospf6_route *route;</a>
<a name="ln559"> </a>
<a name="ln560">  if (! vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_OSPF6], VRF_DEFAULT))</a>
<a name="ln561">    return CMD_SUCCESS;</a>
<a name="ln562"> </a>
<a name="ln563">  vrf_bitmap_unset (zclient-&gt;redist[ZEBRA_ROUTE_OSPF6], VRF_DEFAULT);</a>
<a name="ln564"> </a>
<a name="ln565">  if (ospf6 == NULL)</a>
<a name="ln566">    return CMD_SUCCESS;</a>
<a name="ln567"> </a>
<a name="ln568">  ospf6-&gt;route_table-&gt;hook_add = NULL;</a>
<a name="ln569">  ospf6-&gt;route_table-&gt;hook_remove = NULL;</a>
<a name="ln570"> </a>
<a name="ln571">  /* withdraw ospf6 route from zebra route table */</a>
<a name="ln572">  for (route = ospf6_route_head (ospf6-&gt;route_table); route;</a>
<a name="ln573">       route = ospf6_route_next (route))</a>
<a name="ln574">    ospf6_zebra_route_update_remove (route);</a>
<a name="ln575"> </a>
<a name="ln576">  return CMD_SUCCESS;</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">static void</a>
<a name="ln580">ospf6_zebra_connected (struct zclient *zclient)</a>
<a name="ln581">{</a>
<a name="ln582">  zclient_send_requests (zclient, VRF_DEFAULT);</a>
<a name="ln583">}</a>
<a name="ln584"> </a>
<a name="ln585">static struct ospf6_distance *</a>
<a name="ln586">ospf6_distance_new (void)</a>
<a name="ln587">{</a>
<a name="ln588">  return XCALLOC (MTYPE_OSPF6_DISTANCE, sizeof (struct ospf6_distance));</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">static void</a>
<a name="ln592">ospf6_distance_free (struct ospf6_distance *odistance)</a>
<a name="ln593">{</a>
<a name="ln594">  XFREE (MTYPE_OSPF6_DISTANCE, odistance);</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597">int</a>
<a name="ln598">ospf6_distance_set (struct vty *vty, struct ospf6 *o,</a>
<a name="ln599">                    const char *distance_str,</a>
<a name="ln600">                    const char *ip_str,</a>
<a name="ln601">                    const char *access_list_str)</a>
<a name="ln602">{</a>
<a name="ln603">  int ret;</a>
<a name="ln604">  struct prefix_ipv6 p;</a>
<a name="ln605">  u_char distance;</a>
<a name="ln606">  struct route_node *rn;</a>
<a name="ln607">  struct ospf6_distance *odistance;</a>
<a name="ln608"> </a>
<a name="ln609">  ret = str2prefix_ipv6 (ip_str, &amp;p);</a>
<a name="ln610">  if (ret == 0)</a>
<a name="ln611">    {</a>
<a name="ln612">      vty_out (vty, &quot;Malformed prefix%s&quot;, VTY_NEWLINE);</a>
<a name="ln613">      return CMD_WARNING;</a>
<a name="ln614">    }</a>
<a name="ln615"> </a>
<a name="ln616">  distance = atoi (distance_str);</a>
<a name="ln617"> </a>
<a name="ln618">  /* Get OSPF6 distance node. */</a>
<a name="ln619">  rn = route_node_get (o-&gt;distance_table, (struct prefix *) &amp;p);</a>
<a name="ln620">  if (rn-&gt;info)</a>
<a name="ln621">    {</a>
<a name="ln622">      odistance = rn-&gt;info;</a>
<a name="ln623">      route_unlock_node (rn);</a>
<a name="ln624">    }</a>
<a name="ln625">  else</a>
<a name="ln626">    {</a>
<a name="ln627">      odistance = ospf6_distance_new ();</a>
<a name="ln628">      rn-&gt;info = odistance;</a>
<a name="ln629">    }</a>
<a name="ln630"> </a>
<a name="ln631">  /* Set distance value. */</a>
<a name="ln632">  odistance-&gt;distance = distance;</a>
<a name="ln633"> </a>
<a name="ln634">  /*Reset access-list configuration. */</a>
<a name="ln635">  if (odistance-&gt;access_list)</a>
<a name="ln636">    {</a>
<a name="ln637">      free (odistance-&gt;access_list);</a>
<a name="ln638">      odistance-&gt;access_list = NULL;</a>
<a name="ln639">    }</a>
<a name="ln640">  if (access_list_str)</a>
<a name="ln641">    odistance-&gt;access_list = strdup (access_list_str);</a>
<a name="ln642"> </a>
<a name="ln643">  return CMD_SUCCESS;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">int</a>
<a name="ln647">ospf6_distance_unset (struct vty *vty, struct ospf6 *o,</a>
<a name="ln648">                      const char *ip_str,</a>
<a name="ln649">                      const char *access_list_str)</a>
<a name="ln650">{</a>
<a name="ln651">  int ret;</a>
<a name="ln652">  struct prefix_ipv6 p;</a>
<a name="ln653">  struct route_node *rn;</a>
<a name="ln654">  struct ospf6_distance *odistance;</a>
<a name="ln655"> </a>
<a name="ln656">  ret = str2prefix_ipv6 (ip_str, &amp;p);</a>
<a name="ln657">  if (ret == 0)</a>
<a name="ln658">    {</a>
<a name="ln659">      vty_out (vty, &quot;Malformed prefix%s&quot;, VTY_NEWLINE);</a>
<a name="ln660">      return CMD_WARNING;</a>
<a name="ln661">    }</a>
<a name="ln662"> </a>
<a name="ln663">  rn = route_node_lookup (o-&gt;distance_table, (struct prefix *) &amp;p);</a>
<a name="ln664">  if (!rn)</a>
<a name="ln665">    {</a>
<a name="ln666">      vty_out (vty, &quot;Cant't find specified prefix%s&quot;, VTY_NEWLINE);</a>
<a name="ln667">      return CMD_WARNING;</a>
<a name="ln668">    }</a>
<a name="ln669"> </a>
<a name="ln670">  odistance = rn-&gt;info;</a>
<a name="ln671"> </a>
<a name="ln672">  if (odistance-&gt;access_list)</a>
<a name="ln673">    free (odistance-&gt;access_list);</a>
<a name="ln674">  ospf6_distance_free (odistance);</a>
<a name="ln675"> </a>
<a name="ln676">  rn-&gt;info = NULL;</a>
<a name="ln677">  route_unlock_node (rn);</a>
<a name="ln678">  route_unlock_node (rn);</a>
<a name="ln679"> </a>
<a name="ln680">  return CMD_SUCCESS;</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">void</a>
<a name="ln684">ospf6_distance_reset (struct ospf6 *o)</a>
<a name="ln685">{</a>
<a name="ln686">  struct route_node *rn;</a>
<a name="ln687">  struct ospf6_distance *odistance;</a>
<a name="ln688"> </a>
<a name="ln689">  for (rn = route_top (o-&gt;distance_table); rn; rn = route_next (rn))</a>
<a name="ln690">    if ((odistance = rn-&gt;info) != NULL)</a>
<a name="ln691">      {</a>
<a name="ln692">        if (odistance-&gt;access_list)</a>
<a name="ln693">          free (odistance-&gt;access_list);</a>
<a name="ln694">        ospf6_distance_free (odistance);</a>
<a name="ln695">        rn-&gt;info = NULL;</a>
<a name="ln696">        route_unlock_node (rn);</a>
<a name="ln697">      }</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">u_char</a>
<a name="ln701">ospf6_distance_apply (struct ospf6_route *or, struct ospf6 *o)</a>
<a name="ln702">{</a>
<a name="ln703"> </a>
<a name="ln704">  if (o == NULL)</a>
<a name="ln705">    return 0;</a>
<a name="ln706"> </a>
<a name="ln707">  if (o-&gt;distance_intra)</a>
<a name="ln708">    if (or-&gt;path.type == OSPF6_PATH_TYPE_INTRA)</a>
<a name="ln709">      return o-&gt;distance_intra;</a>
<a name="ln710"> </a>
<a name="ln711">  if (o-&gt;distance_inter)</a>
<a name="ln712">    if (or-&gt;path.type == OSPF6_PATH_TYPE_INTER)</a>
<a name="ln713">      return o-&gt;distance_inter;</a>
<a name="ln714"> </a>
<a name="ln715">  if (o-&gt;distance_external)</a>
<a name="ln716">    if(or-&gt;path.type == OSPF6_PATH_TYPE_EXTERNAL1</a>
<a name="ln717">       || or-&gt;path.type == OSPF6_PATH_TYPE_EXTERNAL2)</a>
<a name="ln718">      return o-&gt;distance_external;</a>
<a name="ln719"> </a>
<a name="ln720">  if (o-&gt;distance_all)</a>
<a name="ln721">    return o-&gt;distance_all;</a>
<a name="ln722"> </a>
<a name="ln723">  return 0;</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">void</a>
<a name="ln727">ospf6_zebra_init (struct thread_master *master)</a>
<a name="ln728">{</a>
<a name="ln729">  /* Allocate zebra structure. */</a>
<a name="ln730">  zclient = zclient_new (master);</a>
<a name="ln731">  zclient_init (zclient, ZEBRA_ROUTE_OSPF6);</a>
<a name="ln732">  zclient-&gt;zebra_connected = ospf6_zebra_connected;</a>
<a name="ln733">  zclient-&gt;router_id_update = ospf6_router_id_update_zebra;</a>
<a name="ln734">  zclient-&gt;interface_add = ospf6_zebra_if_add;</a>
<a name="ln735">  zclient-&gt;interface_delete = ospf6_zebra_if_del;</a>
<a name="ln736">  zclient-&gt;interface_up = ospf6_zebra_if_state_update;</a>
<a name="ln737">  zclient-&gt;interface_down = ospf6_zebra_if_state_update;</a>
<a name="ln738">  zclient-&gt;interface_address_add = ospf6_zebra_if_address_update_add;</a>
<a name="ln739">  zclient-&gt;interface_address_delete = ospf6_zebra_if_address_update_delete;</a>
<a name="ln740">  zclient-&gt;ipv4_route_add = NULL;</a>
<a name="ln741">  zclient-&gt;ipv4_route_delete = NULL;</a>
<a name="ln742">  zclient-&gt;ipv6_route_add = ospf6_zebra_read_ipv6;</a>
<a name="ln743">  zclient-&gt;ipv6_route_delete = ospf6_zebra_read_ipv6;</a>
<a name="ln744"> </a>
<a name="ln745">  /* redistribute connected route by default */</a>
<a name="ln746">  /* ospf6_zebra_redistribute (ZEBRA_ROUTE_CONNECT); */</a>
<a name="ln747"> </a>
<a name="ln748">  /* Install zebra node. */</a>
<a name="ln749">  install_node (&amp;zebra_node, config_write_ospf6_zebra);</a>
<a name="ln750"> </a>
<a name="ln751">  /* Install command element for zebra node. */</a>
<a name="ln752">  install_element (VIEW_NODE, &amp;show_zebra_cmd);</a>
<a name="ln753">  install_element (CONFIG_NODE, &amp;router_zebra_cmd);</a>
<a name="ln754">  install_element (CONFIG_NODE, &amp;no_router_zebra_cmd);</a>
<a name="ln755"> </a>
<a name="ln756">  install_default (ZEBRA_NODE);</a>
<a name="ln757">  install_element (ZEBRA_NODE, &amp;redistribute_ospf6_cmd);</a>
<a name="ln758">  install_element (ZEBRA_NODE, &amp;no_redistribute_ospf6_cmd);</a>
<a name="ln759"> </a>
<a name="ln760">  return;</a>
<a name="ln761">}</a>
<a name="ln762"> </a>
<a name="ln763">/* Debug */</a>
<a name="ln764"> </a>
<a name="ln765">DEFUN (debug_ospf6_zebra_sendrecv,</a>
<a name="ln766">       debug_ospf6_zebra_sendrecv_cmd,</a>
<a name="ln767">       &quot;debug ospf6 zebra (send|recv)&quot;,</a>
<a name="ln768">       DEBUG_STR</a>
<a name="ln769">       OSPF6_STR</a>
<a name="ln770">       &quot;Debug connection between zebra\n&quot;</a>
<a name="ln771">       &quot;Debug Sending zebra\n&quot;</a>
<a name="ln772">       &quot;Debug Receiving zebra\n&quot;</a>
<a name="ln773">      )</a>
<a name="ln774">{</a>
<a name="ln775">  unsigned char level = 0;</a>
<a name="ln776"> </a>
<a name="ln777">  if (argc)</a>
<a name="ln778">    {</a>
<a name="ln779">      if (! strncmp (argv[0], &quot;s&quot;, 1))</a>
<a name="ln780">        level = OSPF6_DEBUG_ZEBRA_SEND;</a>
<a name="ln781">      else if (! strncmp (argv[0], &quot;r&quot;, 1))</a>
<a name="ln782">        level = OSPF6_DEBUG_ZEBRA_RECV;</a>
<a name="ln783">    }</a>
<a name="ln784">  else</a>
<a name="ln785">    level = OSPF6_DEBUG_ZEBRA_SEND | OSPF6_DEBUG_ZEBRA_RECV;</a>
<a name="ln786"> </a>
<a name="ln787">  OSPF6_DEBUG_ZEBRA_ON (level);</a>
<a name="ln788">  return CMD_SUCCESS;</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">ALIAS (debug_ospf6_zebra_sendrecv,</a>
<a name="ln792">       debug_ospf6_zebra_cmd,</a>
<a name="ln793">       &quot;debug ospf6 zebra&quot;,</a>
<a name="ln794">       DEBUG_STR</a>
<a name="ln795">       OSPF6_STR</a>
<a name="ln796">       &quot;Debug connection between zebra\n&quot;</a>
<a name="ln797">      )</a>
<a name="ln798"> </a>
<a name="ln799"> </a>
<a name="ln800">DEFUN (no_debug_ospf6_zebra_sendrecv,</a>
<a name="ln801">       no_debug_ospf6_zebra_sendrecv_cmd,</a>
<a name="ln802">       &quot;no debug ospf6 zebra (send|recv)&quot;,</a>
<a name="ln803">       NO_STR</a>
<a name="ln804">       DEBUG_STR</a>
<a name="ln805">       OSPF6_STR</a>
<a name="ln806">       &quot;Debug connection between zebra\n&quot;</a>
<a name="ln807">       &quot;Debug Sending zebra\n&quot;</a>
<a name="ln808">       &quot;Debug Receiving zebra\n&quot;</a>
<a name="ln809">      )</a>
<a name="ln810">{</a>
<a name="ln811">  unsigned char level = 0;</a>
<a name="ln812"> </a>
<a name="ln813">  if (argc)</a>
<a name="ln814">    {</a>
<a name="ln815">      if (! strncmp (argv[0], &quot;s&quot;, 1))</a>
<a name="ln816">        level = OSPF6_DEBUG_ZEBRA_SEND;</a>
<a name="ln817">      else if (! strncmp (argv[0], &quot;r&quot;, 1))</a>
<a name="ln818">        level = OSPF6_DEBUG_ZEBRA_RECV;</a>
<a name="ln819">    }</a>
<a name="ln820">  else</a>
<a name="ln821">    level = OSPF6_DEBUG_ZEBRA_SEND | OSPF6_DEBUG_ZEBRA_RECV;</a>
<a name="ln822"> </a>
<a name="ln823">  OSPF6_DEBUG_ZEBRA_OFF (level);</a>
<a name="ln824">  return CMD_SUCCESS;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">ALIAS (no_debug_ospf6_zebra_sendrecv,</a>
<a name="ln828">       no_debug_ospf6_zebra_cmd,</a>
<a name="ln829">       &quot;no debug ospf6 zebra&quot;,</a>
<a name="ln830">       NO_STR</a>
<a name="ln831">       DEBUG_STR</a>
<a name="ln832">       OSPF6_STR</a>
<a name="ln833">       &quot;Debug connection between zebra\n&quot;</a>
<a name="ln834">      )</a>
<a name="ln835"> </a>
<a name="ln836">int</a>
<a name="ln837">config_write_ospf6_debug_zebra (struct vty *vty)</a>
<a name="ln838">{</a>
<a name="ln839">  if (IS_OSPF6_DEBUG_ZEBRA (SEND) &amp;&amp; IS_OSPF6_DEBUG_ZEBRA (RECV))</a>
<a name="ln840">    vty_out (vty, &quot;debug ospf6 zebra%s&quot;, VNL);</a>
<a name="ln841">  else</a>
<a name="ln842">    {</a>
<a name="ln843">      if (IS_OSPF6_DEBUG_ZEBRA (SEND))</a>
<a name="ln844">        vty_out (vty, &quot;debug ospf6 zebra send%s&quot;, VNL);</a>
<a name="ln845">      if (IS_OSPF6_DEBUG_ZEBRA (RECV))</a>
<a name="ln846">        vty_out (vty, &quot;debug ospf6 zebra recv%s&quot;, VNL);</a>
<a name="ln847">    }</a>
<a name="ln848">  return 0;</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">void</a>
<a name="ln852">install_element_ospf6_debug_zebra (void)</a>
<a name="ln853">{</a>
<a name="ln854">  install_element (ENABLE_NODE, &amp;debug_ospf6_zebra_cmd);</a>
<a name="ln855">  install_element (ENABLE_NODE, &amp;no_debug_ospf6_zebra_cmd);</a>
<a name="ln856">  install_element (ENABLE_NODE, &amp;debug_ospf6_zebra_sendrecv_cmd);</a>
<a name="ln857">  install_element (ENABLE_NODE, &amp;no_debug_ospf6_zebra_sendrecv_cmd);</a>
<a name="ln858">  install_element (CONFIG_NODE, &amp;debug_ospf6_zebra_cmd);</a>
<a name="ln859">  install_element (CONFIG_NODE, &amp;no_debug_ospf6_zebra_cmd);</a>
<a name="ln860">  install_element (CONFIG_NODE, &amp;debug_ospf6_zebra_sendrecv_cmd);</a>
<a name="ln861">  install_element (CONFIG_NODE, &amp;no_debug_ospf6_zebra_sendrecv_cmd);</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864"> </a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
