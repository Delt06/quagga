
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_encap_tlv.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright 2015, LabN Consulting, L.L.C.</a>
<a name="ln3"> *</a>
<a name="ln4"> * This program is free software; you can redistribute it and/or</a>
<a name="ln5"> * modify it under the terms of the GNU General Public License</a>
<a name="ln6"> * as published by the Free Software Foundation; either version 2</a>
<a name="ln7"> * of the License, or (at your option) any later version.</a>
<a name="ln8"> *</a>
<a name="ln9"> * This program is distributed in the hope that it will be useful,</a>
<a name="ln10"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln11"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln12"> * GNU General Public License for more details.</a>
<a name="ln13"> *</a>
<a name="ln14"> * You should have received a copy of the GNU General Public License</a>
<a name="ln15"> * along with this program; if not, write to the Free Software</a>
<a name="ln16"> * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln17"> *</a>
<a name="ln18"> */</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;zebra.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;memory.h&quot;</a>
<a name="ln23">#include &quot;prefix.h&quot;</a>
<a name="ln24">#include &quot;vty.h&quot;</a>
<a name="ln25">#include &quot;filter.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;bgpd.h&quot;</a>
<a name="ln28">#include &quot;bgp_attr.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;bgp_encap_types.h&quot;</a>
<a name="ln31">#include &quot;bgp_encap_tlv.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">/***********************************************************************</a>
<a name="ln34"> *			SUBTLV ENCODE</a>
<a name="ln35"> ***********************************************************************/</a>
<a name="ln36"> </a>
<a name="ln37">/* rfc5512 4.1 */</a>
<a name="ln38">static struct bgp_attr_encap_subtlv *</a>
<a name="ln39">subtlv_encode_encap_l2tpv3_over_ip(</a>
<a name="ln40">    struct bgp_tea_subtlv_encap_l2tpv3_over_ip	*st)</a>
<a name="ln41">{</a>
<a name="ln42">    struct bgp_attr_encap_subtlv	*new;</a>
<a name="ln43">    uint8_t				*p;</a>
<a name="ln44">    int					total = 4 + st-&gt;cookie_length;</a>
<a name="ln45"> </a>
<a name="ln46">    /* sanity check */</a>
<a name="ln47">    assert(st-&gt;cookie_length &lt;= sizeof(st-&gt;cookie));</a>
<a name="ln48">    assert(total &lt;= 0xff);</a>
<a name="ln49"> </a>
<a name="ln50">    new = XCALLOC(MTYPE_ENCAP_TLV, sizeof(struct bgp_attr_encap_subtlv) - 1 + total);</a>
<a name="ln51">    assert(new);</a>
<a name="ln52">    new-&gt;type = BGP_ENCAP_SUBTLV_TYPE_ENCAPSULATION;</a>
<a name="ln53">    new-&gt;length = total;</a>
<a name="ln54">    p = new-&gt;value;</a>
<a name="ln55"> </a>
<a name="ln56">    *p++ = (st-&gt;sessionid &amp; 0xff000000) &gt;&gt; 24;</a>
<a name="ln57">    *p++ = (st-&gt;sessionid &amp; 0xff0000) &gt;&gt; 16;</a>
<a name="ln58">    *p++ = (st-&gt;sessionid &amp; 0xff00) &gt;&gt; 8;</a>
<a name="ln59">    *p++ = (st-&gt;sessionid &amp; 0xff);</a>
<a name="ln60">    memcpy(p, st-&gt;cookie, st-&gt;cookie_length);</a>
<a name="ln61">    return new;</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">/* rfc5512 4.1 */</a>
<a name="ln65">static struct bgp_attr_encap_subtlv *</a>
<a name="ln66">subtlv_encode_encap_gre(</a>
<a name="ln67">    struct bgp_tea_subtlv_encap_gre_key *st)</a>
<a name="ln68">{</a>
<a name="ln69">    struct bgp_attr_encap_subtlv	*new;</a>
<a name="ln70">    uint8_t				*p;</a>
<a name="ln71">    int					total = 4;</a>
<a name="ln72"> </a>
<a name="ln73">    assert(total &lt;= 0xff);</a>
<a name="ln74"> </a>
<a name="ln75">    new = XCALLOC(MTYPE_ENCAP_TLV, sizeof(struct bgp_attr_encap_subtlv) - 1 + total);</a>
<a name="ln76">    assert(new);</a>
<a name="ln77">    new-&gt;type = BGP_ENCAP_SUBTLV_TYPE_ENCAPSULATION;</a>
<a name="ln78">    new-&gt;length = total;</a>
<a name="ln79">    p = new-&gt;value;</a>
<a name="ln80"> </a>
<a name="ln81">    *p++ = (st-&gt;gre_key &amp; 0xff000000) &gt;&gt; 24;</a>
<a name="ln82">    *p++ = (st-&gt;gre_key &amp; 0xff0000) &gt;&gt; 16;</a>
<a name="ln83">    *p++ = (st-&gt;gre_key &amp; 0xff00) &gt;&gt; 8;</a>
<a name="ln84">    *p++ = (st-&gt;gre_key &amp; 0xff);</a>
<a name="ln85">    return new;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">static struct bgp_attr_encap_subtlv *</a>
<a name="ln89">subtlv_encode_encap_pbb(</a>
<a name="ln90">    struct bgp_tea_subtlv_encap_pbb	*st)</a>
<a name="ln91">{</a>
<a name="ln92">    struct bgp_attr_encap_subtlv	*new;</a>
<a name="ln93">    uint8_t				*p;</a>
<a name="ln94">    int		total = 1 + 3 + 6 + 2;	/* flags + isid + madaddr + vid */</a>
<a name="ln95"> </a>
<a name="ln96">    assert(total &lt;= 0xff);</a>
<a name="ln97"> </a>
<a name="ln98">    new = XCALLOC(MTYPE_ENCAP_TLV, sizeof(struct bgp_attr_encap_subtlv) - 1 + total);</a>
<a name="ln99">    assert(new);</a>
<a name="ln100">    new-&gt;type = BGP_ENCAP_SUBTLV_TYPE_ENCAPSULATION;</a>
<a name="ln101">    new-&gt;length = total;</a>
<a name="ln102">    p = new-&gt;value;</a>
<a name="ln103"> </a>
<a name="ln104">    *p++ = (st-&gt;flag_isid? 0x80: 0) |</a>
<a name="ln105">	     (st-&gt;flag_vid? 0x40: 0) |</a>
<a name="ln106">	     0;</a>
<a name="ln107">    if (st-&gt;flag_isid) {</a>
<a name="ln108">	*p = (st-&gt;isid &amp; 0xff0000) &gt;&gt; 16;</a>
<a name="ln109">	*(p+1) = (st-&gt;isid &amp; 0xff00) &gt;&gt; 8;</a>
<a name="ln110">	*(p+2) = (st-&gt;isid &amp; 0xff);</a>
<a name="ln111">    }</a>
<a name="ln112">    p += 3;</a>
<a name="ln113">    memcpy(p, st-&gt;macaddr, 6);</a>
<a name="ln114">    p += 6;</a>
<a name="ln115">    if (st-&gt;flag_vid) {</a>
<a name="ln116">	*p++ = (st-&gt;vid &amp; 0xf00) &gt;&gt; 8;</a>
<a name="ln117">	*p++ = st-&gt;vid &amp; 0xff;</a>
<a name="ln118">    }</a>
<a name="ln119">    return new;</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">/* rfc5512 4.2 */</a>
<a name="ln123">static struct bgp_attr_encap_subtlv *</a>
<a name="ln124">subtlv_encode_proto_type(</a>
<a name="ln125">    struct bgp_tea_subtlv_proto_type	*st)</a>
<a name="ln126">{</a>
<a name="ln127">    struct bgp_attr_encap_subtlv	*new;</a>
<a name="ln128">    uint8_t				*p;</a>
<a name="ln129">    int	total = 2;</a>
<a name="ln130"> </a>
<a name="ln131">    assert(total &lt;= 0xff);</a>
<a name="ln132"> </a>
<a name="ln133">    new = XCALLOC(MTYPE_ENCAP_TLV, sizeof(struct bgp_attr_encap_subtlv) - 1 + total);</a>
<a name="ln134">    assert(new);</a>
<a name="ln135">    new-&gt;type = BGP_ENCAP_SUBTLV_TYPE_PROTO_TYPE;</a>
<a name="ln136">    new-&gt;length = total;</a>
<a name="ln137">    p = new-&gt;value;</a>
<a name="ln138"> </a>
<a name="ln139">    *p++ = (st-&gt;proto &amp; 0xff00) &gt;&gt; 8;</a>
<a name="ln140">    *p++ = (st-&gt;proto &amp; 0xff);</a>
<a name="ln141">    return new;</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">/* rfc5512 4.3 */</a>
<a name="ln145">static struct bgp_attr_encap_subtlv *</a>
<a name="ln146">subtlv_encode_color(</a>
<a name="ln147">    struct bgp_tea_subtlv_color	*st)</a>
<a name="ln148">{</a>
<a name="ln149">    struct bgp_attr_encap_subtlv	*new;</a>
<a name="ln150">    uint8_t				*p;</a>
<a name="ln151">    int	total = 8;</a>
<a name="ln152"> </a>
<a name="ln153">    assert(total &lt;= 0xff);</a>
<a name="ln154"> </a>
<a name="ln155">    new = XCALLOC(MTYPE_ENCAP_TLV, sizeof(struct bgp_attr_encap_subtlv) - 1 + total);</a>
<a name="ln156">    assert(new);</a>
<a name="ln157">    new-&gt;type = BGP_ENCAP_SUBTLV_TYPE_COLOR;</a>
<a name="ln158">    new-&gt;length = total;</a>
<a name="ln159">    p = new-&gt;value;</a>
<a name="ln160"> </a>
<a name="ln161">    *p++ = 0x03;				/* transitive*/</a>
<a name="ln162">    *p++ = 0x0b;</a>
<a name="ln163">    *p++ = 0;					/* reserved */</a>
<a name="ln164">    *p++ = 0;					/* reserved */</a>
<a name="ln165"> </a>
<a name="ln166">    *p++ = (st-&gt;color &amp; 0xff000000) &gt;&gt; 24;</a>
<a name="ln167">    *p++ = (st-&gt;color &amp; 0xff0000) &gt;&gt; 16;</a>
<a name="ln168">    *p++ = (st-&gt;color &amp; 0xff00) &gt;&gt; 8;</a>
<a name="ln169">    *p++ = (st-&gt;color &amp; 0xff);</a>
<a name="ln170"> </a>
<a name="ln171">    return new;</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">/* rfc 5566 4. */</a>
<a name="ln175">static struct bgp_attr_encap_subtlv *</a>
<a name="ln176">subtlv_encode_ipsec_ta(</a>
<a name="ln177">    struct bgp_tea_subtlv_ipsec_ta	*st)</a>
<a name="ln178">{</a>
<a name="ln179">    struct bgp_attr_encap_subtlv	*new;</a>
<a name="ln180">    uint8_t				*p;</a>
<a name="ln181">    int	total = 2 + st-&gt;authenticator_length;</a>
<a name="ln182"> </a>
<a name="ln183">    /* sanity check */</a>
<a name="ln184">    assert(st-&gt;authenticator_length &lt;= sizeof(st-&gt;value));</a>
<a name="ln185">    assert(total &lt;= 0xff);</a>
<a name="ln186"> </a>
<a name="ln187">    new = XCALLOC(MTYPE_ENCAP_TLV, sizeof(struct bgp_attr_encap_subtlv) - 1 + total);</a>
<a name="ln188">    assert(new);</a>
<a name="ln189">    new-&gt;type = BGP_ENCAP_SUBTLV_TYPE_IPSEC_TA;</a>
<a name="ln190">    new-&gt;length = total;</a>
<a name="ln191">    p = new-&gt;value;</a>
<a name="ln192"> </a>
<a name="ln193">    *p++ = (st-&gt;authenticator_type &amp; 0xff00) &gt;&gt; 8;</a>
<a name="ln194">    *p++ = st-&gt;authenticator_type &amp; 0xff;</a>
<a name="ln195">    memcpy(p, st-&gt;value, st-&gt;authenticator_length);</a>
<a name="ln196">    return new;</a>
<a name="ln197">}</a>
<a name="ln198"> </a>
<a name="ln199">/* draft-rosen-idr-tunnel-encaps 2.1 */</a>
<a name="ln200">static struct bgp_attr_encap_subtlv *</a>
<a name="ln201">subtlv_encode_remote_endpoint(</a>
<a name="ln202">    struct bgp_tea_subtlv_remote_endpoint	*st)</a>
<a name="ln203">{</a>
<a name="ln204">    struct bgp_attr_encap_subtlv	*new;</a>
<a name="ln205">    uint8_t				*p;</a>
<a name="ln206">    </a>
<a name="ln207">    int	total = (st-&gt;family==AF_INET?8:20);</a>
<a name="ln208"> </a>
<a name="ln209">    assert(total &lt;= 0xff);</a>
<a name="ln210"> </a>
<a name="ln211">    new = XCALLOC(MTYPE_ENCAP_TLV, sizeof(struct bgp_attr_encap_subtlv) - 1 + total);</a>
<a name="ln212">    assert(new);</a>
<a name="ln213">    new-&gt;type = BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT;</a>
<a name="ln214">    new-&gt;length = total;</a>
<a name="ln215">    p = new-&gt;value;</a>
<a name="ln216">    if (st-&gt;family == AF_INET) {</a>
<a name="ln217">        memcpy (p, &amp;(st-&gt;ip_address.v4.s_addr), 4);</a>
<a name="ln218">        p+=4;</a>
<a name="ln219">    } else {</a>
<a name="ln220">        assert (st-&gt;family == AF_INET6);</a>
<a name="ln221">        memcpy (p, &amp;(st-&gt;ip_address.v6.s6_addr), 16);</a>
<a name="ln222">        p+=16;</a>
<a name="ln223">    }</a>
<a name="ln224">    memcpy (p, &amp;(st-&gt;as4), 4);</a>
<a name="ln225">    return new;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">/***********************************************************************</a>
<a name="ln229"> *		TUNNEL TYPE-SPECIFIC TLV ENCODE</a>
<a name="ln230"> ***********************************************************************/</a>
<a name="ln231"> </a>
<a name="ln232">/*</a>
<a name="ln233"> * requires &quot;extra&quot; and &quot;last&quot; to be defined in caller</a>
<a name="ln234"> */</a>
<a name="ln235">#define ENC_SUBTLV(flag, function, field) do {\</a>
<a name="ln236">    struct bgp_attr_encap_subtlv	*new;\</a>
<a name="ln237">    if (CHECK_FLAG(bet-&gt;valid_subtlvs, (flag))) {\</a>
<a name="ln238">	new = function(&amp;bet-&gt;field);\</a>
<a name="ln239">	if (last) {\</a>
<a name="ln240">	    last-&gt;next = new;\</a>
<a name="ln241">	} else {\</a>
<a name="ln242">	    extra-&gt;encap_subtlvs = new;\</a>
<a name="ln243">	}\</a>
<a name="ln244">	last = new;\</a>
<a name="ln245">    }\</a>
<a name="ln246">} while (0)</a>
<a name="ln247"> </a>
<a name="ln248">void</a>
<a name="ln249">bgp_encap_type_l2tpv3overip_to_tlv(</a>
<a name="ln250">    struct bgp_encap_type_l2tpv3_over_ip	*bet,	/* input structure */</a>
<a name="ln251">    struct attr					*attr)</a>
<a name="ln252">{</a>
<a name="ln253">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln254">    struct bgp_attr_encap_subtlv	*last;</a>
<a name="ln255"> </a>
<a name="ln256">    /* advance to last subtlv */</a>
<a name="ln257">    for (last = extra-&gt;encap_subtlvs; last &amp;&amp; last-&gt;next; last = last-&gt;next);</a>
<a name="ln258"> </a>
<a name="ln259">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_L2TPV3_OVER_IP;</a>
<a name="ln260"> </a>
<a name="ln261">    assert(CHECK_FLAG(bet-&gt;valid_subtlvs, BGP_TEA_SUBTLV_ENCAP));</a>
<a name="ln262"> </a>
<a name="ln263">    ENC_SUBTLV(BGP_TEA_SUBTLV_ENCAP, subtlv_encode_encap_l2tpv3_over_ip, st_encap);</a>
<a name="ln264">    ENC_SUBTLV(BGP_TEA_SUBTLV_PROTO_TYPE, subtlv_encode_proto_type, st_proto);</a>
<a name="ln265">    ENC_SUBTLV(BGP_TEA_SUBTLV_COLOR, subtlv_encode_color, st_color);</a>
<a name="ln266">    ENC_SUBTLV(BGP_TEA_SUBTLV_REMOTE_ENDPOINT, subtlv_encode_remote_endpoint, st_endpoint);</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">void</a>
<a name="ln270">bgp_encap_type_gre_to_tlv(</a>
<a name="ln271">    struct bgp_encap_type_gre	*bet,	/* input structure */</a>
<a name="ln272">    struct attr			*attr)</a>
<a name="ln273">{</a>
<a name="ln274">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln275">    struct bgp_attr_encap_subtlv	*last;</a>
<a name="ln276"> </a>
<a name="ln277">    /* advance to last subtlv */</a>
<a name="ln278">    for (last = extra-&gt;encap_subtlvs; last &amp;&amp; last-&gt;next; last = last-&gt;next);</a>
<a name="ln279"> </a>
<a name="ln280">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_GRE;</a>
<a name="ln281"> </a>
<a name="ln282">    ENC_SUBTLV(BGP_TEA_SUBTLV_ENCAP, subtlv_encode_encap_gre, st_encap);</a>
<a name="ln283">    ENC_SUBTLV(BGP_TEA_SUBTLV_PROTO_TYPE, subtlv_encode_proto_type, st_proto);</a>
<a name="ln284">    ENC_SUBTLV(BGP_TEA_SUBTLV_COLOR, subtlv_encode_color, st_color);</a>
<a name="ln285">    ENC_SUBTLV(BGP_TEA_SUBTLV_REMOTE_ENDPOINT, subtlv_encode_remote_endpoint, st_endpoint);</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">void</a>
<a name="ln289">bgp_encap_type_ip_in_ip_to_tlv(</a>
<a name="ln290">    struct bgp_encap_type_ip_in_ip	*bet,	/* input structure */</a>
<a name="ln291">    struct attr				*attr)</a>
<a name="ln292">{</a>
<a name="ln293">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln294">    struct bgp_attr_encap_subtlv	*last;</a>
<a name="ln295"> </a>
<a name="ln296">    /* advance to last subtlv */</a>
<a name="ln297">    for (last = extra-&gt;encap_subtlvs; last &amp;&amp; last-&gt;next; last = last-&gt;next);</a>
<a name="ln298"> </a>
<a name="ln299">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_IP_IN_IP;</a>
<a name="ln300"> </a>
<a name="ln301">    ENC_SUBTLV(BGP_TEA_SUBTLV_PROTO_TYPE, subtlv_encode_proto_type, st_proto);</a>
<a name="ln302">    ENC_SUBTLV(BGP_TEA_SUBTLV_COLOR, subtlv_encode_color, st_color);</a>
<a name="ln303">    ENC_SUBTLV(BGP_TEA_SUBTLV_REMOTE_ENDPOINT, subtlv_encode_remote_endpoint, st_endpoint);</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">void</a>
<a name="ln307">bgp_encap_type_transmit_tunnel_endpoint(</a>
<a name="ln308">    struct bgp_encap_type_transmit_tunnel_endpoint	*bet,	/* input structure */</a>
<a name="ln309">    struct attr				*attr)</a>
<a name="ln310">{</a>
<a name="ln311">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln312">    struct bgp_attr_encap_subtlv	*last;</a>
<a name="ln313"> </a>
<a name="ln314">    /* advance to last subtlv */</a>
<a name="ln315">    for (last = extra-&gt;encap_subtlvs; last &amp;&amp; last-&gt;next; last = last-&gt;next);</a>
<a name="ln316"> </a>
<a name="ln317">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_TRANSMIT_TUNNEL_ENDPOINT;</a>
<a name="ln318"> </a>
<a name="ln319">    /* no subtlvs for this type */</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">void</a>
<a name="ln323">bgp_encap_type_ipsec_in_tunnel_mode_to_tlv(</a>
<a name="ln324">    struct bgp_encap_type_ipsec_in_tunnel_mode	*bet,	/* input structure */</a>
<a name="ln325">    struct attr				*attr)</a>
<a name="ln326">{</a>
<a name="ln327">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln328">    struct bgp_attr_encap_subtlv	*last;</a>
<a name="ln329"> </a>
<a name="ln330">    /* advance to last subtlv */</a>
<a name="ln331">    for (last = extra-&gt;encap_subtlvs; last &amp;&amp; last-&gt;next; last = last-&gt;next);</a>
<a name="ln332"> </a>
<a name="ln333">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_IPSEC_IN_TUNNEL_MODE;</a>
<a name="ln334"> </a>
<a name="ln335">    ENC_SUBTLV(BGP_TEA_SUBTLV_IPSEC_TA, subtlv_encode_ipsec_ta, st_ipsec_ta);</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">void</a>
<a name="ln339">bgp_encap_type_ip_in_ip_tunnel_with_ipsec_transport_mode_to_tlv(</a>
<a name="ln340">    struct bgp_encap_type_ip_in_ip_tunnel_with_ipsec_transport_mode	*bet,	/* input structure */</a>
<a name="ln341">    struct attr				*attr)</a>
<a name="ln342">{</a>
<a name="ln343">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln344">    struct bgp_attr_encap_subtlv	*last;</a>
<a name="ln345"> </a>
<a name="ln346">    /* advance to last subtlv */</a>
<a name="ln347">    for (last = extra-&gt;encap_subtlvs; last &amp;&amp; last-&gt;next; last = last-&gt;next);</a>
<a name="ln348"> </a>
<a name="ln349">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_IP_IN_IP_TUNNEL_WITH_IPSEC_TRANSPORT_MODE;</a>
<a name="ln350"> </a>
<a name="ln351">    ENC_SUBTLV(BGP_TEA_SUBTLV_IPSEC_TA, subtlv_encode_ipsec_ta, st_ipsec_ta);</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">void</a>
<a name="ln355">bgp_encap_type_mpls_in_ip_tunnel_with_ipsec_transport_mode_to_tlv(</a>
<a name="ln356">    struct bgp_encap_type_mpls_in_ip_tunnel_with_ipsec_transport_mode	*bet,	/* input structure */</a>
<a name="ln357">    struct attr				*attr)</a>
<a name="ln358">{</a>
<a name="ln359">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln360">    struct bgp_attr_encap_subtlv	*last;</a>
<a name="ln361"> </a>
<a name="ln362">    /* advance to last subtlv */</a>
<a name="ln363">    for (last = extra-&gt;encap_subtlvs; last &amp;&amp; last-&gt;next; last = last-&gt;next);</a>
<a name="ln364"> </a>
<a name="ln365">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_MPLS_IN_IP_TUNNEL_WITH_IPSEC_TRANSPORT_MODE;</a>
<a name="ln366"> </a>
<a name="ln367">    ENC_SUBTLV(BGP_TEA_SUBTLV_IPSEC_TA, subtlv_encode_ipsec_ta, st_ipsec_ta);</a>
<a name="ln368">}</a>
<a name="ln369"> </a>
<a name="ln370">void</a>
<a name="ln371">bgp_encap_type_pbb_to_tlv(</a>
<a name="ln372">    struct bgp_encap_type_pbb	*bet,	/* input structure */</a>
<a name="ln373">    struct attr				*attr)</a>
<a name="ln374">{</a>
<a name="ln375">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln376">    struct bgp_attr_encap_subtlv	*last;</a>
<a name="ln377"> </a>
<a name="ln378">    /* advance to last subtlv */</a>
<a name="ln379">    for (last = extra-&gt;encap_subtlvs; last &amp;&amp; last-&gt;next; last = last-&gt;next);</a>
<a name="ln380"> </a>
<a name="ln381">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_PBB;</a>
<a name="ln382"> </a>
<a name="ln383">    assert(CHECK_FLAG(bet-&gt;valid_subtlvs, BGP_TEA_SUBTLV_ENCAP));</a>
<a name="ln384">    ENC_SUBTLV(BGP_TEA_SUBTLV_ENCAP, subtlv_encode_encap_pbb, st_encap);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">void</a>
<a name="ln388">bgp_encap_type_vxlan_to_tlv(</a>
<a name="ln389">    struct bgp_encap_type_vxlan	*bet,	/* input structure */</a>
<a name="ln390">    struct attr				*attr)</a>
<a name="ln391">{</a>
<a name="ln392">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln393"> </a>
<a name="ln394">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_VXLAN;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">void</a>
<a name="ln398">bgp_encap_type_nvgre_to_tlv(</a>
<a name="ln399">    struct bgp_encap_type_nvgre	*bet,	/* input structure */</a>
<a name="ln400">    struct attr				*attr)</a>
<a name="ln401">{</a>
<a name="ln402">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln403"> </a>
<a name="ln404">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_NVGRE;</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">void</a>
<a name="ln408">bgp_encap_type_mpls_to_tlv(</a>
<a name="ln409">    struct bgp_encap_type_mpls	*bet,	/* input structure */</a>
<a name="ln410">    struct attr				*attr)</a>
<a name="ln411">{</a>
<a name="ln412">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln413"> </a>
<a name="ln414">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_MPLS;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">void</a>
<a name="ln418">bgp_encap_type_mpls_in_gre_to_tlv(</a>
<a name="ln419">    struct bgp_encap_type_mpls_in_gre	*bet,	/* input structure */</a>
<a name="ln420">    struct attr				*attr)</a>
<a name="ln421">{</a>
<a name="ln422">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln423"> </a>
<a name="ln424">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_MPLS_IN_GRE;</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">void</a>
<a name="ln428">bgp_encap_type_vxlan_gpe_to_tlv(</a>
<a name="ln429">    struct bgp_encap_type_vxlan_gpe	*bet,	/* input structure */</a>
<a name="ln430">    struct attr				*attr)</a>
<a name="ln431">{</a>
<a name="ln432">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln433"> </a>
<a name="ln434">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_VXLAN_GPE;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">void</a>
<a name="ln438">bgp_encap_type_mpls_in_udp_to_tlv(</a>
<a name="ln439">    struct bgp_encap_type_mpls_in_udp	*bet,	/* input structure */</a>
<a name="ln440">    struct attr				*attr)</a>
<a name="ln441">{</a>
<a name="ln442">    struct attr_extra			*extra = bgp_attr_extra_get(attr);</a>
<a name="ln443"> </a>
<a name="ln444">    extra-&gt;encap_tunneltype = BGP_ENCAP_TYPE_MPLS_IN_UDP;</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447"> </a>
<a name="ln448">/***********************************************************************</a>
<a name="ln449"> *			SUBTLV DECODE</a>
<a name="ln450"> ***********************************************************************/</a>
<a name="ln451">/* rfc5512 4.1 */</a>
<a name="ln452">static int</a>
<a name="ln453">subtlv_decode_encap_l2tpv3_over_ip(</a>
<a name="ln454">    struct bgp_attr_encap_subtlv 		*subtlv,</a>
<a name="ln455">    struct bgp_tea_subtlv_encap_l2tpv3_over_ip	*st)</a>
<a name="ln456">{</a>
<a name="ln457">    if (subtlv-&gt;length &lt; 4) {</a>
<a name="ln458">	zlog_debug(&quot;%s, subtlv length %d is less than 4&quot;,</a>
<a name="ln459">	    __func__, subtlv-&gt;length);</a>
<a name="ln460">	return -1;</a>
<a name="ln461">    }</a>
<a name="ln462"> </a>
<a name="ln463">    st-&gt;sessionid = (subtlv-&gt;value[0] &lt;&lt; 24) |</a>
<a name="ln464">		    (subtlv-&gt;value[1] &lt;&lt; 16) |</a>
<a name="ln465">		    (subtlv-&gt;value[2] &lt;&lt; 8)  |</a>
<a name="ln466">		    subtlv-&gt;value[3];</a>
<a name="ln467">    st-&gt;cookie_length = subtlv-&gt;length - 4;</a>
<a name="ln468">    if (st-&gt;cookie_length &gt; sizeof(st-&gt;cookie)) {</a>
<a name="ln469">	zlog_debug(&quot;%s, subtlv length %d is greater than %d&quot;,</a>
<a name="ln470">	    __func__, st-&gt;cookie_length, (int)sizeof(st-&gt;cookie));</a>
<a name="ln471">	return -1;</a>
<a name="ln472">    }</a>
<a name="ln473">    memcpy(st-&gt;cookie, subtlv-&gt;value + 4, st-&gt;cookie_length);</a>
<a name="ln474">    return 0;</a>
<a name="ln475">}</a>
<a name="ln476"> </a>
<a name="ln477">/* rfc5512 4.1 */</a>
<a name="ln478">static int</a>
<a name="ln479">subtlv_decode_encap_gre(</a>
<a name="ln480">    struct bgp_attr_encap_subtlv	*subtlv,</a>
<a name="ln481">    struct bgp_tea_subtlv_encap_gre_key *st)</a>
<a name="ln482">{</a>
<a name="ln483">    if (subtlv-&gt;length != 4) {</a>
<a name="ln484">	zlog_debug(&quot;%s, subtlv length %d does not equal 4&quot;,</a>
<a name="ln485">	    __func__, subtlv-&gt;length);</a>
<a name="ln486">	return -1;</a>
<a name="ln487">    }</a>
<a name="ln488">    st-&gt;gre_key = (subtlv-&gt;value[0] &lt;&lt; 24) |</a>
<a name="ln489">		    (subtlv-&gt;value[1] &lt;&lt; 16) |</a>
<a name="ln490">		    (subtlv-&gt;value[2] &lt;&lt; 8)  |</a>
<a name="ln491">		    subtlv-&gt;value[3];</a>
<a name="ln492">    return 0;</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">static int</a>
<a name="ln496">subtlv_decode_encap_pbb(</a>
<a name="ln497">    struct bgp_attr_encap_subtlv	*subtlv,</a>
<a name="ln498">    struct bgp_tea_subtlv_encap_pbb	*st)</a>
<a name="ln499">{</a>
<a name="ln500">    if (subtlv-&gt;length != 1 + 3 + 6 + 2) {</a>
<a name="ln501">	zlog_debug(&quot;%s, subtlv length %d does not equal %d&quot;,</a>
<a name="ln502">	    __func__, subtlv-&gt;length, 1 + 3 + 6 + 2);</a>
<a name="ln503">	return -1;</a>
<a name="ln504">    }</a>
<a name="ln505">    if (subtlv-&gt;value[0] &amp; 0x80) {</a>
<a name="ln506">	st-&gt;flag_isid = 1;</a>
<a name="ln507">	st-&gt;isid = (subtlv-&gt;value[1] &lt;&lt; 16) |</a>
<a name="ln508">		    (subtlv-&gt;value[2] &lt;&lt; 8) |</a>
<a name="ln509">		    subtlv-&gt;value[3];</a>
<a name="ln510">    }</a>
<a name="ln511">    if (subtlv-&gt;value[0] &amp; 0x40) {</a>
<a name="ln512">	st-&gt;flag_vid  = 1;</a>
<a name="ln513">	st-&gt;vid = ((subtlv-&gt;value[10] &amp; 0x0f) &lt;&lt; 8) | subtlv-&gt;value[11];</a>
<a name="ln514">    }</a>
<a name="ln515">    memcpy(st-&gt;macaddr, subtlv-&gt;value + 4, 6);</a>
<a name="ln516">    return 0;</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">/* rfc5512 4.2 */</a>
<a name="ln520">static int</a>
<a name="ln521">subtlv_decode_proto_type(</a>
<a name="ln522">    struct bgp_attr_encap_subtlv 	*subtlv,</a>
<a name="ln523">    struct bgp_tea_subtlv_proto_type	*st)</a>
<a name="ln524">{</a>
<a name="ln525">    if (subtlv-&gt;length != 2) {</a>
<a name="ln526">	zlog_debug(&quot;%s, subtlv length %d does not equal 2&quot;,</a>
<a name="ln527">	    __func__, subtlv-&gt;length);</a>
<a name="ln528">	return -1;</a>
<a name="ln529">    }</a>
<a name="ln530">    st-&gt;proto = (subtlv-&gt;value[0] &lt;&lt; 8) | subtlv-&gt;value[1];</a>
<a name="ln531">    return 0;</a>
<a name="ln532">}</a>
<a name="ln533"> </a>
<a name="ln534">/* rfc5512 4.3 */</a>
<a name="ln535">static int</a>
<a name="ln536">subtlv_decode_color(</a>
<a name="ln537">    struct bgp_attr_encap_subtlv 	*subtlv,</a>
<a name="ln538">    struct bgp_tea_subtlv_color		*st)</a>
<a name="ln539">{</a>
<a name="ln540">    if (subtlv-&gt;length != 8) {</a>
<a name="ln541">	zlog_debug(&quot;%s, subtlv length %d does not equal 8&quot;,</a>
<a name="ln542">	    __func__, subtlv-&gt;length);</a>
<a name="ln543">	return -1;</a>
<a name="ln544">    }</a>
<a name="ln545">    if ((subtlv-&gt;value[0] != 0x03) ||</a>
<a name="ln546">	(subtlv-&gt;value[1] != 0x0b) ||</a>
<a name="ln547">	(subtlv-&gt;value[2] != 0)    ||</a>
<a name="ln548">	(subtlv-&gt;value[3] != 0)) {</a>
<a name="ln549">	zlog_debug(&quot;%s, subtlv value 1st 4 bytes are not 0x030b0000&quot;, __func__);</a>
<a name="ln550">	return -1;</a>
<a name="ln551">    }</a>
<a name="ln552">    st-&gt;color = (subtlv-&gt;value[4] &lt;&lt; 24) |</a>
<a name="ln553">		(subtlv-&gt;value[5] &lt;&lt; 16) |</a>
<a name="ln554">		(subtlv-&gt;value[6] &lt;&lt; 8)  |</a>
<a name="ln555">		subtlv-&gt;value[7];</a>
<a name="ln556">    return 0;</a>
<a name="ln557">}</a>
<a name="ln558"> </a>
<a name="ln559">/* rfc 5566 4. */</a>
<a name="ln560">static int</a>
<a name="ln561">subtlv_decode_ipsec_ta(</a>
<a name="ln562">    struct bgp_attr_encap_subtlv 	*subtlv,</a>
<a name="ln563">    struct bgp_tea_subtlv_ipsec_ta	*st)</a>
<a name="ln564">{</a>
<a name="ln565">    st-&gt;authenticator_length = subtlv-&gt;length - 2;</a>
<a name="ln566">    if (st-&gt;authenticator_length &gt; sizeof(st-&gt;value)) {</a>
<a name="ln567">	zlog_debug(&quot;%s, authenticator length %d exceeds storage maximum %d&quot;,</a>
<a name="ln568">	    __func__, st-&gt;authenticator_length, (int)sizeof(st-&gt;value));</a>
<a name="ln569">	return -1;</a>
<a name="ln570">    }</a>
<a name="ln571">    st-&gt;authenticator_type = (subtlv-&gt;value[0] &lt;&lt; 8) | subtlv-&gt;value[1];</a>
<a name="ln572">    memcpy(st-&gt;value, subtlv-&gt;value + 2,  st-&gt;authenticator_length);</a>
<a name="ln573">    return 0;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">/* draft-rosen-idr-tunnel-encaps 2.1 */</a>
<a name="ln577">static int</a>
<a name="ln578">subtlv_decode_remote_endpoint(</a>
<a name="ln579">    struct bgp_attr_encap_subtlv 	  *subtlv,</a>
<a name="ln580">    struct bgp_tea_subtlv_remote_endpoint *st)</a>
<a name="ln581">{</a>
<a name="ln582">   int i;</a>
<a name="ln583">   if (subtlv-&gt;length != 8 &amp;&amp; subtlv-&gt;length != 20 ) {</a>
<a name="ln584">	zlog_debug(&quot;%s, subtlv length %d does not equal 8 or 20&quot;,</a>
<a name="ln585">	    __func__, subtlv-&gt;length);</a>
<a name="ln586">	return -1;</a>
<a name="ln587">    }</a>
<a name="ln588">    if (subtlv-&gt;length == 8) {</a>
<a name="ln589">        st-&gt;family = AF_INET;</a>
<a name="ln590">        st-&gt;ip_address.v4.s_addr = ((subtlv-&gt;value[0] &lt;&lt; 24) |</a>
<a name="ln591">                                    (subtlv-&gt;value[1] &lt;&lt; 16) |</a>
<a name="ln592">                                    (subtlv-&gt;value[2] &lt;&lt; 8)  |</a>
<a name="ln593">                                    subtlv-&gt;value[3]);</a>
<a name="ln594">    } else {</a>
<a name="ln595">        st-&gt;family = AF_INET6;</a>
<a name="ln596">        memcpy (&amp;(st-&gt;ip_address.v6.s6_addr), subtlv-&gt;value, 16);</a>
<a name="ln597">    }</a>
<a name="ln598">    i = subtlv-&gt;length - 4;</a>
<a name="ln599">    st-&gt;as4 = ((subtlv-&gt;value[i] &lt;&lt; 24) |</a>
<a name="ln600">               (subtlv-&gt;value[i+1] &lt;&lt; 16) |</a>
<a name="ln601">               (subtlv-&gt;value[i+2] &lt;&lt; 8)  |</a>
<a name="ln602">               subtlv-&gt;value[i+3]);</a>
<a name="ln603">    return 0;</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">/***********************************************************************</a>
<a name="ln607"> *		TUNNEL TYPE-SPECIFIC TLV DECODE</a>
<a name="ln608"> ***********************************************************************/</a>
<a name="ln609"> </a>
<a name="ln610">int</a>
<a name="ln611">tlv_to_bgp_encap_type_l2tpv3overip(</a>
<a name="ln612">    struct bgp_attr_encap_subtlv		*stlv,	/* subtlv chain */</a>
<a name="ln613">    struct bgp_encap_type_l2tpv3_over_ip	*bet)	/* caller-allocated */</a>
<a name="ln614">{</a>
<a name="ln615">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln616">    int						rc = 0;</a>
<a name="ln617"> </a>
<a name="ln618">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln619">	switch (st-&gt;type) {</a>
<a name="ln620">	    case BGP_ENCAP_SUBTLV_TYPE_ENCAPSULATION:</a>
<a name="ln621">		rc |= subtlv_decode_encap_l2tpv3_over_ip(st, &amp;bet-&gt;st_encap);</a>
<a name="ln622">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_ENCAP);</a>
<a name="ln623">		break;</a>
<a name="ln624"> </a>
<a name="ln625">	    case BGP_ENCAP_SUBTLV_TYPE_PROTO_TYPE:</a>
<a name="ln626">		rc |= subtlv_decode_proto_type(st, &amp;bet-&gt;st_proto);</a>
<a name="ln627">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_PROTO_TYPE);</a>
<a name="ln628">		break;</a>
<a name="ln629"> </a>
<a name="ln630">	    case BGP_ENCAP_SUBTLV_TYPE_COLOR:</a>
<a name="ln631">		rc |= subtlv_decode_color(st, &amp;bet-&gt;st_color);</a>
<a name="ln632">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_COLOR);</a>
<a name="ln633">		break;</a>
<a name="ln634"> </a>
<a name="ln635">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln636">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln637">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln638">		break;</a>
<a name="ln639"> </a>
<a name="ln640">	    default:</a>
<a name="ln641">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln642">		rc |= -1;</a>
<a name="ln643">		break;</a>
<a name="ln644">	}</a>
<a name="ln645">    }</a>
<a name="ln646">    return rc;</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">int</a>
<a name="ln650">tlv_to_bgp_encap_type_gre(</a>
<a name="ln651">    struct bgp_attr_encap_subtlv	*stlv,	/* subtlv chain */</a>
<a name="ln652">    struct bgp_encap_type_gre		*bet)	/* caller-allocated */</a>
<a name="ln653">{</a>
<a name="ln654">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln655">    int						rc = 0;</a>
<a name="ln656"> </a>
<a name="ln657">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln658">	switch (st-&gt;type) {</a>
<a name="ln659">	    case BGP_ENCAP_SUBTLV_TYPE_ENCAPSULATION:</a>
<a name="ln660">		rc |= subtlv_decode_encap_gre(st, &amp;bet-&gt;st_encap);</a>
<a name="ln661">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_ENCAP);</a>
<a name="ln662">		break;</a>
<a name="ln663"> </a>
<a name="ln664">	    case BGP_ENCAP_SUBTLV_TYPE_PROTO_TYPE:</a>
<a name="ln665">		rc |= subtlv_decode_proto_type(st, &amp;bet-&gt;st_proto);</a>
<a name="ln666">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_PROTO_TYPE);</a>
<a name="ln667">		break;</a>
<a name="ln668"> </a>
<a name="ln669">	    case BGP_ENCAP_SUBTLV_TYPE_COLOR:</a>
<a name="ln670">		rc |= subtlv_decode_color(st, &amp;bet-&gt;st_color);</a>
<a name="ln671">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_COLOR);</a>
<a name="ln672">		break;</a>
<a name="ln673"> </a>
<a name="ln674">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln675">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln676">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln677">		break;</a>
<a name="ln678"> </a>
<a name="ln679">	    default:</a>
<a name="ln680">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln681">		rc |= -1;</a>
<a name="ln682">		break;</a>
<a name="ln683">	}</a>
<a name="ln684">    }</a>
<a name="ln685">    return rc;</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">int</a>
<a name="ln689">tlv_to_bgp_encap_type_ip_in_ip(</a>
<a name="ln690">    struct bgp_attr_encap_subtlv	*stlv,	/* subtlv chain */</a>
<a name="ln691">    struct bgp_encap_type_ip_in_ip	*bet)	/* caller-allocated */</a>
<a name="ln692">{</a>
<a name="ln693">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln694">    int						rc = 0;</a>
<a name="ln695"> </a>
<a name="ln696">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln697">	switch (st-&gt;type) {</a>
<a name="ln698">	    case BGP_ENCAP_SUBTLV_TYPE_PROTO_TYPE:</a>
<a name="ln699">		rc |= subtlv_decode_proto_type(st, &amp;bet-&gt;st_proto);</a>
<a name="ln700">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_PROTO_TYPE);</a>
<a name="ln701">		break;</a>
<a name="ln702"> </a>
<a name="ln703">	    case BGP_ENCAP_SUBTLV_TYPE_COLOR:</a>
<a name="ln704">		rc |= subtlv_decode_color(st, &amp;bet-&gt;st_color);</a>
<a name="ln705">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_COLOR);</a>
<a name="ln706">		break;</a>
<a name="ln707"> </a>
<a name="ln708">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln709">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln710">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln711">		break;</a>
<a name="ln712"> </a>
<a name="ln713">	    default:</a>
<a name="ln714">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln715">		rc |= -1;</a>
<a name="ln716">		break;</a>
<a name="ln717">	}</a>
<a name="ln718">    }</a>
<a name="ln719">    return rc;</a>
<a name="ln720">}</a>
<a name="ln721"> </a>
<a name="ln722">int</a>
<a name="ln723">tlv_to_bgp_encap_type_transmit_tunnel_endpoint(</a>
<a name="ln724">    struct bgp_attr_encap_subtlv			*stlv,</a>
<a name="ln725">    struct bgp_encap_type_transmit_tunnel_endpoint	*bet)</a>
<a name="ln726">{</a>
<a name="ln727">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln728">    int						rc = 0;</a>
<a name="ln729"> </a>
<a name="ln730">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln731">	switch (st-&gt;type) {</a>
<a name="ln732"> </a>
<a name="ln733">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln734">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln735">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln736">		break;</a>
<a name="ln737"> </a>
<a name="ln738">	    default:</a>
<a name="ln739">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln740">		rc |= -1;</a>
<a name="ln741">		break;</a>
<a name="ln742">	}</a>
<a name="ln743">    }</a>
<a name="ln744">    return rc;</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">int</a>
<a name="ln748">tlv_to_bgp_encap_type_ipsec_in_tunnel_mode(</a>
<a name="ln749">    struct bgp_attr_encap_subtlv		*stlv,	/* subtlv chain */</a>
<a name="ln750">    struct bgp_encap_type_ipsec_in_tunnel_mode	*bet)	/* caller-allocated */</a>
<a name="ln751">{</a>
<a name="ln752">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln753">    int						rc = 0;</a>
<a name="ln754"> </a>
<a name="ln755">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln756">	switch (st-&gt;type) {</a>
<a name="ln757">	    case BGP_ENCAP_SUBTLV_TYPE_IPSEC_TA:</a>
<a name="ln758">		rc |= subtlv_decode_ipsec_ta(st, &amp;bet-&gt;st_ipsec_ta);</a>
<a name="ln759">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_IPSEC_TA);</a>
<a name="ln760">		break;</a>
<a name="ln761"> </a>
<a name="ln762">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln763">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln764">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln765">		break;</a>
<a name="ln766"> </a>
<a name="ln767">	    default:</a>
<a name="ln768">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln769">		rc |= -1;</a>
<a name="ln770">		break;</a>
<a name="ln771">	}</a>
<a name="ln772">    }</a>
<a name="ln773">    return rc;</a>
<a name="ln774">}</a>
<a name="ln775"> </a>
<a name="ln776">int</a>
<a name="ln777">tlv_to_bgp_encap_type_ip_in_ip_tunnel_with_ipsec_transport_mode(</a>
<a name="ln778">    struct bgp_attr_encap_subtlv					*stlv,</a>
<a name="ln779">    struct bgp_encap_type_ip_in_ip_tunnel_with_ipsec_transport_mode	*bet)</a>
<a name="ln780">{</a>
<a name="ln781">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln782">    int						rc = 0;</a>
<a name="ln783"> </a>
<a name="ln784">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln785">	switch (st-&gt;type) {</a>
<a name="ln786">	    case BGP_ENCAP_SUBTLV_TYPE_IPSEC_TA:</a>
<a name="ln787">		rc |= subtlv_decode_ipsec_ta(st, &amp;bet-&gt;st_ipsec_ta);</a>
<a name="ln788">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_IPSEC_TA);</a>
<a name="ln789">		break;</a>
<a name="ln790"> </a>
<a name="ln791">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln792">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln793">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln794">		break;</a>
<a name="ln795"> </a>
<a name="ln796">	    default:</a>
<a name="ln797">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln798">		rc |= -1;</a>
<a name="ln799">		break;</a>
<a name="ln800">	}</a>
<a name="ln801">    }</a>
<a name="ln802">    return rc;</a>
<a name="ln803">}</a>
<a name="ln804"> </a>
<a name="ln805">int</a>
<a name="ln806">tlv_to_bgp_encap_type_mpls_in_ip_tunnel_with_ipsec_transport_mode(</a>
<a name="ln807">    struct bgp_attr_encap_subtlv					*stlv,</a>
<a name="ln808">    struct bgp_encap_type_mpls_in_ip_tunnel_with_ipsec_transport_mode	*bet)</a>
<a name="ln809">{</a>
<a name="ln810">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln811">    int						rc = 0;</a>
<a name="ln812"> </a>
<a name="ln813">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln814">	switch (st-&gt;type) {</a>
<a name="ln815">	    case BGP_ENCAP_SUBTLV_TYPE_IPSEC_TA:</a>
<a name="ln816">		rc |= subtlv_decode_ipsec_ta(st, &amp;bet-&gt;st_ipsec_ta);</a>
<a name="ln817">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_IPSEC_TA);</a>
<a name="ln818">		break;</a>
<a name="ln819"> </a>
<a name="ln820">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln821">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln822">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln823">		break;</a>
<a name="ln824"> </a>
<a name="ln825">	    default:</a>
<a name="ln826">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln827">		rc |= -1;</a>
<a name="ln828">		break;</a>
<a name="ln829">	}</a>
<a name="ln830">    }</a>
<a name="ln831">    return rc;</a>
<a name="ln832">}</a>
<a name="ln833"> </a>
<a name="ln834">int</a>
<a name="ln835">tlv_to_bgp_encap_type_vxlan(</a>
<a name="ln836">    struct bgp_attr_encap_subtlv	*stlv,</a>
<a name="ln837">    struct bgp_encap_type_vxlan		*bet)</a>
<a name="ln838">{</a>
<a name="ln839">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln840">    int						rc = 0;</a>
<a name="ln841"> </a>
<a name="ln842">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln843">	switch (st-&gt;type) {</a>
<a name="ln844"> </a>
<a name="ln845">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln846">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln847">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln848">		break;</a>
<a name="ln849"> </a>
<a name="ln850">	    default:</a>
<a name="ln851">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln852">		rc |= -1;</a>
<a name="ln853">		break;</a>
<a name="ln854">	}</a>
<a name="ln855">    }</a>
<a name="ln856">    return rc;</a>
<a name="ln857">}</a>
<a name="ln858"> </a>
<a name="ln859">int</a>
<a name="ln860">tlv_to_bgp_encap_type_nvgre(</a>
<a name="ln861">    struct bgp_attr_encap_subtlv	*stlv,</a>
<a name="ln862">    struct bgp_encap_type_nvgre		*bet)</a>
<a name="ln863">{</a>
<a name="ln864">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln865">    int						rc = 0;</a>
<a name="ln866"> </a>
<a name="ln867">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln868">	switch (st-&gt;type) {</a>
<a name="ln869"> </a>
<a name="ln870">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln871">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln872">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln873">		break;</a>
<a name="ln874"> </a>
<a name="ln875">	    default:</a>
<a name="ln876">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln877">		rc |= -1;</a>
<a name="ln878">		break;</a>
<a name="ln879">	}</a>
<a name="ln880">    }</a>
<a name="ln881">    return rc;</a>
<a name="ln882">}</a>
<a name="ln883"> </a>
<a name="ln884">int</a>
<a name="ln885">tlv_to_bgp_encap_type_mpls(</a>
<a name="ln886">    struct bgp_attr_encap_subtlv	*stlv,</a>
<a name="ln887">    struct bgp_encap_type_mpls		*bet)</a>
<a name="ln888">{</a>
<a name="ln889">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln890">    int						rc = 0;</a>
<a name="ln891"> </a>
<a name="ln892">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln893">	switch (st-&gt;type) {</a>
<a name="ln894"> </a>
<a name="ln895">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln896">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln897">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln898">		break;</a>
<a name="ln899"> </a>
<a name="ln900">	    default:</a>
<a name="ln901">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln902">		rc |= -1;</a>
<a name="ln903">		break;</a>
<a name="ln904">	}</a>
<a name="ln905">    }</a>
<a name="ln906">    return rc;</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">int</a>
<a name="ln910">tlv_to_bgp_encap_type_mpls_in_gre(</a>
<a name="ln911">    struct bgp_attr_encap_subtlv	*stlv,</a>
<a name="ln912">    struct bgp_encap_type_mpls_in_gre	*bet)</a>
<a name="ln913">{</a>
<a name="ln914">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln915">    int						rc = 0;</a>
<a name="ln916"> </a>
<a name="ln917">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln918">	switch (st-&gt;type) {</a>
<a name="ln919"> </a>
<a name="ln920">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln921">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln922">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln923">		break;</a>
<a name="ln924"> </a>
<a name="ln925">	    default:</a>
<a name="ln926">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln927">		rc |= -1;</a>
<a name="ln928">		break;</a>
<a name="ln929">	}</a>
<a name="ln930">    }</a>
<a name="ln931">    return rc;</a>
<a name="ln932">}</a>
<a name="ln933"> </a>
<a name="ln934">int</a>
<a name="ln935">tlv_to_bgp_encap_type_vxlan_gpe(</a>
<a name="ln936">    struct bgp_attr_encap_subtlv	*stlv,</a>
<a name="ln937">    struct bgp_encap_type_vxlan_gpe	*bet)</a>
<a name="ln938">{</a>
<a name="ln939">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln940">    int						rc = 0;</a>
<a name="ln941"> </a>
<a name="ln942">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln943">	switch (st-&gt;type) {</a>
<a name="ln944"> </a>
<a name="ln945">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln946">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln947">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln948">		break;</a>
<a name="ln949"> </a>
<a name="ln950">	    default:</a>
<a name="ln951">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln952">		rc |= -1;</a>
<a name="ln953">		break;</a>
<a name="ln954">	}</a>
<a name="ln955">    }</a>
<a name="ln956">    return rc;</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">int</a>
<a name="ln960">tlv_to_bgp_encap_type_mpls_in_udp(</a>
<a name="ln961">    struct bgp_attr_encap_subtlv	*stlv,</a>
<a name="ln962">    struct bgp_encap_type_mpls_in_udp	*bet)</a>
<a name="ln963">{</a>
<a name="ln964">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln965">    int						rc = 0;</a>
<a name="ln966"> </a>
<a name="ln967">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln968">	switch (st-&gt;type) {</a>
<a name="ln969"> </a>
<a name="ln970">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln971">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln972">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln973">		break;</a>
<a name="ln974"> </a>
<a name="ln975">	    default:</a>
<a name="ln976">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln977">		rc |= -1;</a>
<a name="ln978">		break;</a>
<a name="ln979">	}</a>
<a name="ln980">    }</a>
<a name="ln981">    return rc;</a>
<a name="ln982">}</a>
<a name="ln983"> </a>
<a name="ln984">int</a>
<a name="ln985">tlv_to_bgp_encap_type_pbb(</a>
<a name="ln986">    struct bgp_attr_encap_subtlv	*stlv,	/* subtlv chain */</a>
<a name="ln987">    struct bgp_encap_type_pbb		*bet)	/* caller-allocated */</a>
<a name="ln988">{</a>
<a name="ln989">    struct bgp_attr_encap_subtlv		*st;</a>
<a name="ln990">    int						rc = 0;</a>
<a name="ln991"> </a>
<a name="ln992">    for (st = stlv; st; st = st-&gt;next) {</a>
<a name="ln993">	switch (st-&gt;type) {</a>
<a name="ln994">	    case BGP_ENCAP_SUBTLV_TYPE_ENCAPSULATION:</a>
<a name="ln995">		rc |= subtlv_decode_encap_pbb(st, &amp;bet-&gt;st_encap);</a>
<a name="ln996">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_ENCAP);</a>
<a name="ln997">		break;</a>
<a name="ln998"> </a>
<a name="ln999">	    case BGP_ENCAP_SUBTLV_TYPE_REMOTE_ENDPOINT:</a>
<a name="ln1000">		rc |= subtlv_decode_remote_endpoint(st, &amp;bet-&gt;st_endpoint);</a>
<a name="ln1001">		SET_SUBTLV_FLAG(bet, BGP_TEA_SUBTLV_REMOTE_ENDPOINT);</a>
<a name="ln1002">		break;</a>
<a name="ln1003"> </a>
<a name="ln1004">	    default:</a>
<a name="ln1005">		zlog_debug(&quot;%s: unexpected subtlv type %d&quot;, __func__, st-&gt;type);</a>
<a name="ln1006">		rc |= -1;</a>
<a name="ln1007">		break;</a>
<a name="ln1008">	}</a>
<a name="ln1009">    }</a>
<a name="ln1010">    return rc;</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
