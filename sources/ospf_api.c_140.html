
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_api.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * API message handling module for OSPF daemon and client.</a>
<a name="ln3"> * Copyright (C) 2001, 2002 Ralph Keller</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> * </a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln8"> * it under the terms of the GNU General Public License as published</a>
<a name="ln9"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln10"> * option) any later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln20"> * Boston, MA 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#ifdef SUPPORT_OSPF_API</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;table.h&quot;</a>
<a name="ln31">#include &quot;memory.h&quot;</a>
<a name="ln32">#include &quot;command.h&quot;</a>
<a name="ln33">#include &quot;vty.h&quot;</a>
<a name="ln34">#include &quot;stream.h&quot;</a>
<a name="ln35">#include &quot;log.h&quot;</a>
<a name="ln36">#include &quot;thread.h&quot;</a>
<a name="ln37">#include &quot;hash.h&quot;</a>
<a name="ln38">#include &quot;sockunion.h&quot;		/* for inet_aton() */</a>
<a name="ln39">#include &quot;buffer.h&quot;</a>
<a name="ln40">#include &quot;network.h&quot;</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln48">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln49">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln50">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln51">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln52">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln53">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln54">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln55">#include &quot;ospfd/ospf_ase.h&quot;</a>
<a name="ln56">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">#include &quot;ospfd/ospf_api.h&quot;</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">/* For debugging only, will be removed */</a>
<a name="ln62">void</a>
<a name="ln63">api_opaque_lsa_print (struct lsa_header *data)</a>
<a name="ln64">{</a>
<a name="ln65">  struct opaque_lsa</a>
<a name="ln66">  {</a>
<a name="ln67">    struct lsa_header header;</a>
<a name="ln68">    u_char mydata[];</a>
<a name="ln69">  };</a>
<a name="ln70"> </a>
<a name="ln71">  struct opaque_lsa *olsa;</a>
<a name="ln72">  int opaquelen;</a>
<a name="ln73">  int i;</a>
<a name="ln74"> </a>
<a name="ln75">  ospf_lsa_header_dump (data);</a>
<a name="ln76"> </a>
<a name="ln77">  olsa = (struct opaque_lsa *) data;</a>
<a name="ln78"> </a>
<a name="ln79">  opaquelen = ntohs (data-&gt;length) - OSPF_LSA_HEADER_SIZE;</a>
<a name="ln80">  zlog_debug (&quot;apiserver_lsa_print: opaquelen=%d\n&quot;, opaquelen);</a>
<a name="ln81"> </a>
<a name="ln82">  for (i = 0; i &lt; opaquelen; i++)</a>
<a name="ln83">    {</a>
<a name="ln84">      zlog_debug (&quot;0x%x &quot;, olsa-&gt;mydata[i]);</a>
<a name="ln85">    }</a>
<a name="ln86">  zlog_debug (&quot;\n&quot;);</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">/* -----------------------------------------------------------</a>
<a name="ln90"> * Generic messages</a>
<a name="ln91"> * -----------------------------------------------------------</a>
<a name="ln92"> */</a>
<a name="ln93"> </a>
<a name="ln94">struct msg *</a>
<a name="ln95">msg_new (u_char msgtype, void *msgbody, u_int32_t seqnum, u_int16_t msglen)</a>
<a name="ln96">{</a>
<a name="ln97">  struct msg *new;</a>
<a name="ln98"> </a>
<a name="ln99">  new = XCALLOC (MTYPE_OSPF_API_MSG, sizeof (struct msg));</a>
<a name="ln100"> </a>
<a name="ln101">  new-&gt;hdr.version = OSPF_API_VERSION;</a>
<a name="ln102">  new-&gt;hdr.msgtype = msgtype;</a>
<a name="ln103">  new-&gt;hdr.msglen = htons (msglen);</a>
<a name="ln104">  new-&gt;hdr.msgseq = htonl (seqnum);</a>
<a name="ln105"> </a>
<a name="ln106">  new-&gt;s = stream_new (msglen);</a>
<a name="ln107">  assert (new-&gt;s);</a>
<a name="ln108">  stream_put (new-&gt;s, msgbody, msglen);</a>
<a name="ln109"> </a>
<a name="ln110">  return new;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113"> </a>
<a name="ln114">/* Duplicate a message by copying content. */</a>
<a name="ln115">struct msg *</a>
<a name="ln116">msg_dup (struct msg *msg)</a>
<a name="ln117">{</a>
<a name="ln118">  struct msg *new;</a>
<a name="ln119"> </a>
<a name="ln120">  assert (msg);</a>
<a name="ln121"> </a>
<a name="ln122">  new = msg_new (msg-&gt;hdr.msgtype, STREAM_DATA (msg-&gt;s),</a>
<a name="ln123">		 ntohl (msg-&gt;hdr.msgseq), ntohs (msg-&gt;hdr.msglen));</a>
<a name="ln124">  return new;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127"> </a>
<a name="ln128">/* XXX only for testing, will be removed */</a>
<a name="ln129"> </a>
<a name="ln130">struct nametab {</a>
<a name="ln131">  int value;</a>
<a name="ln132">  const char *name;</a>
<a name="ln133">};</a>
<a name="ln134"> </a>
<a name="ln135">const char *</a>
<a name="ln136">ospf_api_typename (int msgtype)</a>
<a name="ln137">{</a>
<a name="ln138">  struct nametab NameTab[] = {</a>
<a name="ln139">    { MSG_REGISTER_OPAQUETYPE,   &quot;Register opaque-type&quot;,   },</a>
<a name="ln140">    { MSG_UNREGISTER_OPAQUETYPE, &quot;Unregister opaque-type&quot;, },</a>
<a name="ln141">    { MSG_REGISTER_EVENT,        &quot;Register event&quot;,         },</a>
<a name="ln142">    { MSG_SYNC_LSDB,             &quot;Sync LSDB&quot;,              },</a>
<a name="ln143">    { MSG_ORIGINATE_REQUEST,     &quot;Originate request&quot;,      },</a>
<a name="ln144">    { MSG_DELETE_REQUEST,        &quot;Delete request&quot;,         },</a>
<a name="ln145">    { MSG_REPLY,                 &quot;Reply&quot;,                  },</a>
<a name="ln146">    { MSG_READY_NOTIFY,          &quot;Ready notify&quot;,           },</a>
<a name="ln147">    { MSG_LSA_UPDATE_NOTIFY,     &quot;LSA update notify&quot;,      },</a>
<a name="ln148">    { MSG_LSA_DELETE_NOTIFY,     &quot;LSA delete notify&quot;,      },</a>
<a name="ln149">    { MSG_NEW_IF,                &quot;New interface&quot;,          },</a>
<a name="ln150">    { MSG_DEL_IF,                &quot;Del interface&quot;,          },</a>
<a name="ln151">    { MSG_ISM_CHANGE,            &quot;ISM change&quot;,             },</a>
<a name="ln152">    { MSG_NSM_CHANGE,            &quot;NSM change&quot;,             },</a>
<a name="ln153">  };</a>
<a name="ln154"> </a>
<a name="ln155">  int i, n = array_size(NameTab);</a>
<a name="ln156">  const char *name = NULL;</a>
<a name="ln157"> </a>
<a name="ln158">  for (i = 0; i &lt; n; i++)</a>
<a name="ln159">    {</a>
<a name="ln160">      if (NameTab[i].value == msgtype)</a>
<a name="ln161">        {</a>
<a name="ln162">          name = NameTab[i].name;</a>
<a name="ln163">          break;</a>
<a name="ln164">        }</a>
<a name="ln165">    }</a>
<a name="ln166"> </a>
<a name="ln167">  return name ? name : &quot;?&quot;;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">const char *</a>
<a name="ln171">ospf_api_errname (int errcode)</a>
<a name="ln172">{</a>
<a name="ln173">  struct nametab NameTab[] = {</a>
<a name="ln174">    { OSPF_API_OK,                      &quot;OK&quot;,                         },</a>
<a name="ln175">    { OSPF_API_NOSUCHINTERFACE,         &quot;No such interface&quot;,          },</a>
<a name="ln176">    { OSPF_API_NOSUCHAREA,              &quot;No such area&quot;,               },</a>
<a name="ln177">    { OSPF_API_NOSUCHLSA,               &quot;No such LSA&quot;,                },</a>
<a name="ln178">    { OSPF_API_ILLEGALLSATYPE,          &quot;Illegal LSA type&quot;,           },</a>
<a name="ln179">    { OSPF_API_OPAQUETYPEINUSE,         &quot;Opaque type in use&quot;,         },</a>
<a name="ln180">    { OSPF_API_OPAQUETYPENOTREGISTERED, &quot;Opaque type not registered&quot;, },</a>
<a name="ln181">    { OSPF_API_NOTREADY,                &quot;Not ready&quot;,                  },</a>
<a name="ln182">    { OSPF_API_NOMEMORY,                &quot;No memory&quot;,                  },</a>
<a name="ln183">    { OSPF_API_ERROR,                   &quot;Other error&quot;,                },</a>
<a name="ln184">    { OSPF_API_UNDEF,                   &quot;Undefined&quot;,                  },</a>
<a name="ln185">  };</a>
<a name="ln186"> </a>
<a name="ln187">  int i, n = array_size(NameTab);</a>
<a name="ln188">  const char *name = NULL;</a>
<a name="ln189"> </a>
<a name="ln190">  for (i = 0; i &lt; n; i++)</a>
<a name="ln191">    {</a>
<a name="ln192">      if (NameTab[i].value == errcode)</a>
<a name="ln193">        {</a>
<a name="ln194">          name = NameTab[i].name;</a>
<a name="ln195">          break;</a>
<a name="ln196">        }</a>
<a name="ln197">    }</a>
<a name="ln198"> </a>
<a name="ln199">  return name ? name : &quot;?&quot;;</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">void</a>
<a name="ln203">msg_print (struct msg *msg)</a>
<a name="ln204">{</a>
<a name="ln205">  if (!msg)</a>
<a name="ln206">    {</a>
<a name="ln207">      zlog_debug (&quot;msg_print msg=NULL!\n&quot;);</a>
<a name="ln208">      return;</a>
<a name="ln209">    }</a>
<a name="ln210"> </a>
<a name="ln211">#ifdef ORIGINAL_CODING</a>
<a name="ln212">  zlog_debug</a>
<a name="ln213">    (&quot;msg=%p msgtype=%d msglen=%d msgseq=%d streamdata=%p streamsize=%lu\n&quot;,</a>
<a name="ln214">     msg, msg-&gt;hdr.msgtype, ntohs (msg-&gt;hdr.msglen), ntohl (msg-&gt;hdr.msgseq),</a>
<a name="ln215">     STREAM_DATA (msg-&gt;s), STREAM_SIZE (msg-&gt;s));</a>
<a name="ln216">#else /* ORIGINAL_CODING */</a>
<a name="ln217">  /* API message common header part. */</a>
<a name="ln218">  zlog_debug</a>
<a name="ln219">    (&quot;API-msg [%s]: type(%d),len(%d),seq(%lu),data(%p),size(%zd)&quot;,</a>
<a name="ln220">     ospf_api_typename (msg-&gt;hdr.msgtype), msg-&gt;hdr.msgtype, </a>
<a name="ln221">     ntohs (msg-&gt;hdr.msglen), (unsigned long) ntohl (msg-&gt;hdr.msgseq),</a>
<a name="ln222">     STREAM_DATA (msg-&gt;s), STREAM_SIZE (msg-&gt;s));</a>
<a name="ln223"> </a>
<a name="ln224">  /* API message body part. */</a>
<a name="ln225">#ifdef ndef</a>
<a name="ln226">  /* Generic Hex/Ascii dump */</a>
<a name="ln227">  DumpBuf (STREAM_DATA (msg-&gt;s), STREAM_SIZE (msg-&gt;s)); /* Sorry, deleted! */</a>
<a name="ln228">#else /* ndef */</a>
<a name="ln229">  /* Message-type dependent dump function. */</a>
<a name="ln230">#endif /* ndef */</a>
<a name="ln231"> </a>
<a name="ln232">  return;</a>
<a name="ln233">#endif /* ORIGINAL_CODING */</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">void</a>
<a name="ln237">msg_free (struct msg *msg)</a>
<a name="ln238">{</a>
<a name="ln239">  if (msg-&gt;s)</a>
<a name="ln240">    stream_free (msg-&gt;s);</a>
<a name="ln241"> </a>
<a name="ln242">  XFREE (MTYPE_OSPF_API_MSG, msg);</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">/* Set sequence number of message */</a>
<a name="ln247">void</a>
<a name="ln248">msg_set_seq (struct msg *msg, u_int32_t seqnr)</a>
<a name="ln249">{</a>
<a name="ln250">  assert (msg);</a>
<a name="ln251">  msg-&gt;hdr.msgseq = htonl (seqnr);</a>
<a name="ln252">}</a>
<a name="ln253"> </a>
<a name="ln254">/* Get sequence number of message */</a>
<a name="ln255">u_int32_t</a>
<a name="ln256">msg_get_seq (struct msg *msg)</a>
<a name="ln257">{</a>
<a name="ln258">  assert (msg);</a>
<a name="ln259">  return ntohl (msg-&gt;hdr.msgseq);</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">/* -----------------------------------------------------------</a>
<a name="ln263"> * Message fifo queues</a>
<a name="ln264"> * -----------------------------------------------------------</a>
<a name="ln265"> */</a>
<a name="ln266"> </a>
<a name="ln267">struct msg_fifo *</a>
<a name="ln268">msg_fifo_new ()</a>
<a name="ln269">{</a>
<a name="ln270">  return XCALLOC (MTYPE_OSPF_API_FIFO, sizeof (struct msg_fifo));</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">/* Add new message to fifo. */</a>
<a name="ln274">void</a>
<a name="ln275">msg_fifo_push (struct msg_fifo *fifo, struct msg *msg)</a>
<a name="ln276">{</a>
<a name="ln277">  if (fifo-&gt;tail)</a>
<a name="ln278">    fifo-&gt;tail-&gt;next = msg;</a>
<a name="ln279">  else</a>
<a name="ln280">    fifo-&gt;head = msg;</a>
<a name="ln281"> </a>
<a name="ln282">  fifo-&gt;tail = msg;</a>
<a name="ln283">  fifo-&gt;count++;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">/* Remove first message from fifo. */</a>
<a name="ln288">struct msg *</a>
<a name="ln289">msg_fifo_pop (struct msg_fifo *fifo)</a>
<a name="ln290">{</a>
<a name="ln291">  struct msg *msg;</a>
<a name="ln292"> </a>
<a name="ln293">  msg = fifo-&gt;head;</a>
<a name="ln294">  if (msg)</a>
<a name="ln295">    {</a>
<a name="ln296">      fifo-&gt;head = msg-&gt;next;</a>
<a name="ln297"> </a>
<a name="ln298">      if (fifo-&gt;head == NULL)</a>
<a name="ln299">	fifo-&gt;tail = NULL;</a>
<a name="ln300"> </a>
<a name="ln301">      fifo-&gt;count--;</a>
<a name="ln302">    }</a>
<a name="ln303">  return msg;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">/* Return first fifo entry but do not remove it. */</a>
<a name="ln307">struct msg *</a>
<a name="ln308">msg_fifo_head (struct msg_fifo *fifo)</a>
<a name="ln309">{</a>
<a name="ln310">  return fifo-&gt;head;</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">/* Flush message fifo. */</a>
<a name="ln314">void</a>
<a name="ln315">msg_fifo_flush (struct msg_fifo *fifo)</a>
<a name="ln316">{</a>
<a name="ln317">  struct msg *op;</a>
<a name="ln318">  struct msg *next;</a>
<a name="ln319"> </a>
<a name="ln320">  for (op = fifo-&gt;head; op; op = next)</a>
<a name="ln321">    {</a>
<a name="ln322">      next = op-&gt;next;</a>
<a name="ln323">      msg_free (op);</a>
<a name="ln324">    }</a>
<a name="ln325"> </a>
<a name="ln326">  fifo-&gt;head = fifo-&gt;tail = NULL;</a>
<a name="ln327">  fifo-&gt;count = 0;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">/* Free API message fifo. */</a>
<a name="ln331">void</a>
<a name="ln332">msg_fifo_free (struct msg_fifo *fifo)</a>
<a name="ln333">{</a>
<a name="ln334">  msg_fifo_flush (fifo);</a>
<a name="ln335"> </a>
<a name="ln336">  XFREE (MTYPE_OSPF_API_FIFO, fifo);</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">struct msg *</a>
<a name="ln340">msg_read (int fd)</a>
<a name="ln341">{</a>
<a name="ln342">  struct msg *msg;</a>
<a name="ln343">  struct apimsghdr hdr;</a>
<a name="ln344">  u_char buf[OSPF_API_MAX_MSG_SIZE];</a>
<a name="ln345">  int bodylen;</a>
<a name="ln346">  int rlen;</a>
<a name="ln347"> </a>
<a name="ln348">  /* Read message header */</a>
<a name="ln349">  rlen = readn (fd, (u_char *) &amp;hdr, sizeof (struct apimsghdr));</a>
<a name="ln350"> </a>
<a name="ln351">  if (rlen &lt; 0)</a>
<a name="ln352">    {</a>
<a name="ln353">      zlog_warn (&quot;msg_read: readn %s&quot;, safe_strerror (errno));</a>
<a name="ln354">      return NULL;</a>
<a name="ln355">    }</a>
<a name="ln356">  else if (rlen == 0)</a>
<a name="ln357">    {</a>
<a name="ln358">      zlog_warn (&quot;msg_read: Connection closed by peer&quot;);</a>
<a name="ln359">      return NULL;</a>
<a name="ln360">    }</a>
<a name="ln361">  else if (rlen != sizeof (struct apimsghdr))</a>
<a name="ln362">    {</a>
<a name="ln363">      zlog_warn (&quot;msg_read: Cannot read message header!&quot;);</a>
<a name="ln364">      return NULL;</a>
<a name="ln365">    }</a>
<a name="ln366"> </a>
<a name="ln367">  /* Check version of API protocol */</a>
<a name="ln368">  if (hdr.version != OSPF_API_VERSION)</a>
<a name="ln369">    {</a>
<a name="ln370">      zlog_warn (&quot;msg_read: OSPF API protocol version mismatch&quot;);</a>
<a name="ln371">      return NULL;</a>
<a name="ln372">    }</a>
<a name="ln373"> </a>
<a name="ln374">  /* Determine body length. */</a>
<a name="ln375">  bodylen = ntohs (hdr.msglen);</a>
<a name="ln376">  if (bodylen &gt; 0)</a>
<a name="ln377">    {</a>
<a name="ln378"> </a>
<a name="ln379">      /* Read message body */</a>
<a name="ln380">      rlen = readn (fd, buf, bodylen);</a>
<a name="ln381">      if (rlen &lt; 0)</a>
<a name="ln382">	{</a>
<a name="ln383">	  zlog_warn (&quot;msg_read: readn %s&quot;, safe_strerror (errno));</a>
<a name="ln384">	  return NULL;</a>
<a name="ln385">	}</a>
<a name="ln386">      else if (rlen == 0)</a>
<a name="ln387">	{</a>
<a name="ln388">	  zlog_warn (&quot;msg_read: Connection closed by peer&quot;);</a>
<a name="ln389">	  return NULL;</a>
<a name="ln390">	}</a>
<a name="ln391">      else if (rlen != bodylen)</a>
<a name="ln392">	{</a>
<a name="ln393">	  zlog_warn (&quot;msg_read: Cannot read message body!&quot;);</a>
<a name="ln394">	  return NULL;</a>
<a name="ln395">	}</a>
<a name="ln396">    }</a>
<a name="ln397"> </a>
<a name="ln398">  /* Allocate new message */</a>
<a name="ln399">  msg = msg_new (hdr.msgtype, buf, ntohl (hdr.msgseq), ntohs (hdr.msglen));</a>
<a name="ln400"> </a>
<a name="ln401">  return msg;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">int</a>
<a name="ln405">msg_write (int fd, struct msg *msg)</a>
<a name="ln406">{</a>
<a name="ln407">  u_char buf[OSPF_API_MAX_MSG_SIZE];</a>
<a name="ln408">  int l;</a>
<a name="ln409">  int wlen;</a>
<a name="ln410"> </a>
<a name="ln411">  assert (msg);</a>
<a name="ln412">  assert (msg-&gt;s);</a>
<a name="ln413"> </a>
<a name="ln414">  /* Length of message including header */</a>
<a name="ln415">  l = sizeof (struct apimsghdr) + ntohs (msg-&gt;hdr.msglen);</a>
<a name="ln416"> </a>
<a name="ln417">  /* Make contiguous memory buffer for message */</a>
<a name="ln418">  memcpy (buf, &amp;msg-&gt;hdr, sizeof (struct apimsghdr));</a>
<a name="ln419">  memcpy (buf + sizeof (struct apimsghdr), STREAM_DATA (msg-&gt;s),</a>
<a name="ln420">	  ntohs (msg-&gt;hdr.msglen));</a>
<a name="ln421"> </a>
<a name="ln422">  wlen = writen (fd, buf, l);</a>
<a name="ln423">  if (wlen &lt; 0)</a>
<a name="ln424">    {</a>
<a name="ln425">      zlog_warn (&quot;msg_write: writen %s&quot;, safe_strerror (errno));</a>
<a name="ln426">      return -1;</a>
<a name="ln427">    }</a>
<a name="ln428">  else if (wlen == 0)</a>
<a name="ln429">    {</a>
<a name="ln430">      zlog_warn (&quot;msg_write: Connection closed by peer&quot;);</a>
<a name="ln431">      return -1;</a>
<a name="ln432">    }</a>
<a name="ln433">  else if (wlen != l)</a>
<a name="ln434">    {</a>
<a name="ln435">      zlog_warn (&quot;msg_write: Cannot write API message&quot;);</a>
<a name="ln436">      return -1;</a>
<a name="ln437">    }</a>
<a name="ln438">  return 0;</a>
<a name="ln439">}</a>
<a name="ln440"> </a>
<a name="ln441">/* -----------------------------------------------------------</a>
<a name="ln442"> * Specific messages</a>
<a name="ln443"> * -----------------------------------------------------------</a>
<a name="ln444"> */</a>
<a name="ln445"> </a>
<a name="ln446">struct msg *</a>
<a name="ln447">new_msg_register_opaque_type (u_int32_t seqnum, u_char ltype, u_char otype)</a>
<a name="ln448">{</a>
<a name="ln449">  struct msg_register_opaque_type rmsg;</a>
<a name="ln450"> </a>
<a name="ln451">  rmsg.lsatype = ltype;</a>
<a name="ln452">  rmsg.opaquetype = otype;</a>
<a name="ln453">  memset (&amp;rmsg.pad, 0, sizeof (rmsg.pad));</a>
<a name="ln454"> </a>
<a name="ln455">  return msg_new (MSG_REGISTER_OPAQUETYPE, &amp;rmsg, seqnum,</a>
<a name="ln456">		  sizeof (struct msg_register_opaque_type));</a>
<a name="ln457">}</a>
<a name="ln458"> </a>
<a name="ln459">struct msg *</a>
<a name="ln460">new_msg_register_event (u_int32_t seqnum, struct lsa_filter_type *filter)</a>
<a name="ln461">{</a>
<a name="ln462">  u_char buf[OSPF_API_MAX_MSG_SIZE];</a>
<a name="ln463">  struct msg_register_event *emsg;</a>
<a name="ln464">  size_t len;</a>
<a name="ln465"> </a>
<a name="ln466">  emsg = (struct msg_register_event *) buf;</a>
<a name="ln467">  len = sizeof (struct msg_register_event) +</a>
<a name="ln468">    filter-&gt;num_areas * sizeof (struct in_addr);</a>
<a name="ln469">  emsg-&gt;filter.typemask = htons (filter-&gt;typemask);</a>
<a name="ln470">  emsg-&gt;filter.origin = filter-&gt;origin;</a>
<a name="ln471">  emsg-&gt;filter.num_areas = filter-&gt;num_areas;</a>
<a name="ln472">  if (len &gt; sizeof (buf))</a>
<a name="ln473">    len = sizeof(buf);</a>
<a name="ln474">  /* API broken - missing memcpy to fill data */</a>
<a name="ln475">  return msg_new (MSG_REGISTER_EVENT, emsg, seqnum, len);</a>
<a name="ln476">}</a>
<a name="ln477"> </a>
<a name="ln478">struct msg *</a>
<a name="ln479">new_msg_sync_lsdb (u_int32_t seqnum, struct lsa_filter_type *filter)</a>
<a name="ln480">{</a>
<a name="ln481">  u_char buf[OSPF_API_MAX_MSG_SIZE];</a>
<a name="ln482">  struct msg_sync_lsdb *smsg;</a>
<a name="ln483">  size_t len;</a>
<a name="ln484"> </a>
<a name="ln485">  smsg = (struct msg_sync_lsdb *) buf;</a>
<a name="ln486">  len = sizeof (struct msg_sync_lsdb) +</a>
<a name="ln487">    filter-&gt;num_areas * sizeof (struct in_addr);</a>
<a name="ln488">  smsg-&gt;filter.typemask = htons (filter-&gt;typemask);</a>
<a name="ln489">  smsg-&gt;filter.origin = filter-&gt;origin;</a>
<a name="ln490">  smsg-&gt;filter.num_areas = filter-&gt;num_areas;</a>
<a name="ln491">  if (len &gt; sizeof (buf))</a>
<a name="ln492">    len = sizeof(buf);</a>
<a name="ln493">  /* API broken - missing memcpy to fill data */</a>
<a name="ln494">  return msg_new (MSG_SYNC_LSDB, smsg, seqnum, len);</a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497"> </a>
<a name="ln498">struct msg *</a>
<a name="ln499">new_msg_originate_request (u_int32_t seqnum,</a>
<a name="ln500">			   struct in_addr ifaddr,</a>
<a name="ln501">			   struct in_addr area_id, struct lsa_header *data)</a>
<a name="ln502">{</a>
<a name="ln503">  struct msg_originate_request *omsg;</a>
<a name="ln504">  size_t omsglen;</a>
<a name="ln505">  char buf[OSPF_API_MAX_MSG_SIZE];</a>
<a name="ln506"> </a>
<a name="ln507">  omsg = (struct msg_originate_request *) buf;</a>
<a name="ln508">  omsg-&gt;ifaddr = ifaddr;</a>
<a name="ln509">  omsg-&gt;area_id = area_id;</a>
<a name="ln510"> </a>
<a name="ln511">  omsglen = ntohs (data-&gt;length);</a>
<a name="ln512">  if (omsglen &gt; sizeof (buf) - offsetof (struct msg_originate_request, data))</a>
<a name="ln513">    omsglen = sizeof (buf) - offsetof (struct msg_originate_request, data);</a>
<a name="ln514">  memcpy (&amp;omsg-&gt;data, data, omsglen);</a>
<a name="ln515">  omsglen += sizeof (struct msg_originate_request) - sizeof (struct lsa_header);</a>
<a name="ln516"> </a>
<a name="ln517">  return msg_new (MSG_ORIGINATE_REQUEST, omsg, seqnum, omsglen);</a>
<a name="ln518">}</a>
<a name="ln519"> </a>
<a name="ln520">struct msg *</a>
<a name="ln521">new_msg_delete_request (u_int32_t seqnum,</a>
<a name="ln522">			struct in_addr area_id, u_char lsa_type,</a>
<a name="ln523">			u_char opaque_type, u_int32_t opaque_id)</a>
<a name="ln524">{</a>
<a name="ln525">  struct msg_delete_request dmsg;</a>
<a name="ln526">  dmsg.area_id = area_id;</a>
<a name="ln527">  dmsg.lsa_type = lsa_type;</a>
<a name="ln528">  dmsg.opaque_type = opaque_type;</a>
<a name="ln529">  dmsg.opaque_id = htonl (opaque_id);</a>
<a name="ln530">  memset (&amp;dmsg.pad, 0, sizeof (dmsg.pad));</a>
<a name="ln531"> </a>
<a name="ln532">  return msg_new (MSG_DELETE_REQUEST, &amp;dmsg, seqnum,</a>
<a name="ln533">		  sizeof (struct msg_delete_request));</a>
<a name="ln534">}</a>
<a name="ln535"> </a>
<a name="ln536"> </a>
<a name="ln537">struct msg *</a>
<a name="ln538">new_msg_reply (u_int32_t seqnr, u_char rc)</a>
<a name="ln539">{</a>
<a name="ln540">  struct msg *msg;</a>
<a name="ln541">  struct msg_reply rmsg;</a>
<a name="ln542"> </a>
<a name="ln543">  /* Set return code */</a>
<a name="ln544">  rmsg.errcode = rc;</a>
<a name="ln545">  memset (&amp;rmsg.pad, 0, sizeof (rmsg.pad));</a>
<a name="ln546"> </a>
<a name="ln547">  msg = msg_new (MSG_REPLY, &amp;rmsg, seqnr, sizeof (struct msg_reply));</a>
<a name="ln548"> </a>
<a name="ln549">  return msg;</a>
<a name="ln550">}</a>
<a name="ln551"> </a>
<a name="ln552">struct msg *</a>
<a name="ln553">new_msg_ready_notify (u_int32_t seqnr, u_char lsa_type,</a>
<a name="ln554">		      u_char opaque_type, struct in_addr addr)</a>
<a name="ln555">{</a>
<a name="ln556">  struct msg_ready_notify rmsg;</a>
<a name="ln557"> </a>
<a name="ln558">  rmsg.lsa_type = lsa_type;</a>
<a name="ln559">  rmsg.opaque_type = opaque_type;</a>
<a name="ln560">  memset (&amp;rmsg.pad, 0, sizeof (rmsg.pad));</a>
<a name="ln561">  rmsg.addr = addr;</a>
<a name="ln562"> </a>
<a name="ln563">  return msg_new (MSG_READY_NOTIFY, &amp;rmsg, seqnr,</a>
<a name="ln564">		  sizeof (struct msg_ready_notify));</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">struct msg *</a>
<a name="ln568">new_msg_new_if (u_int32_t seqnr,</a>
<a name="ln569">		struct in_addr ifaddr, struct in_addr area_id)</a>
<a name="ln570">{</a>
<a name="ln571">  struct msg_new_if nmsg;</a>
<a name="ln572"> </a>
<a name="ln573">  nmsg.ifaddr = ifaddr;</a>
<a name="ln574">  nmsg.area_id = area_id;</a>
<a name="ln575"> </a>
<a name="ln576">  return msg_new (MSG_NEW_IF, &amp;nmsg, seqnr, sizeof (struct msg_new_if));</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">struct msg *</a>
<a name="ln580">new_msg_del_if (u_int32_t seqnr, struct in_addr ifaddr)</a>
<a name="ln581">{</a>
<a name="ln582">  struct msg_del_if dmsg;</a>
<a name="ln583"> </a>
<a name="ln584">  dmsg.ifaddr = ifaddr;</a>
<a name="ln585"> </a>
<a name="ln586">  return msg_new (MSG_DEL_IF, &amp;dmsg, seqnr, sizeof (struct msg_del_if));</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">struct msg *</a>
<a name="ln590">new_msg_ism_change (u_int32_t seqnr, struct in_addr ifaddr,</a>
<a name="ln591">		    struct in_addr area_id, u_char status)</a>
<a name="ln592">{</a>
<a name="ln593">  struct msg_ism_change imsg;</a>
<a name="ln594"> </a>
<a name="ln595">  imsg.ifaddr = ifaddr;</a>
<a name="ln596">  imsg.area_id = area_id;</a>
<a name="ln597">  imsg.status = status;</a>
<a name="ln598">  memset (&amp;imsg.pad, 0, sizeof (imsg.pad));</a>
<a name="ln599"> </a>
<a name="ln600">  return msg_new (MSG_ISM_CHANGE, &amp;imsg, seqnr,</a>
<a name="ln601">		  sizeof (struct msg_ism_change));</a>
<a name="ln602">}</a>
<a name="ln603"> </a>
<a name="ln604">struct msg *</a>
<a name="ln605">new_msg_nsm_change (u_int32_t seqnr, struct in_addr ifaddr,</a>
<a name="ln606">		    struct in_addr nbraddr,</a>
<a name="ln607">		    struct in_addr router_id, u_char status)</a>
<a name="ln608">{</a>
<a name="ln609">  struct msg_nsm_change nmsg;</a>
<a name="ln610"> </a>
<a name="ln611">  nmsg.ifaddr = ifaddr;</a>
<a name="ln612">  nmsg.nbraddr = nbraddr;</a>
<a name="ln613">  nmsg.router_id = router_id;</a>
<a name="ln614">  nmsg.status = status;</a>
<a name="ln615">  memset (&amp;nmsg.pad, 0, sizeof (nmsg.pad));</a>
<a name="ln616"> </a>
<a name="ln617">  return msg_new (MSG_NSM_CHANGE, &amp;nmsg, seqnr,</a>
<a name="ln618">		  sizeof (struct msg_nsm_change));</a>
<a name="ln619">}</a>
<a name="ln620"> </a>
<a name="ln621">struct msg *</a>
<a name="ln622">new_msg_lsa_change_notify (u_char msgtype,</a>
<a name="ln623">			   u_int32_t seqnum,</a>
<a name="ln624">			   struct in_addr ifaddr,</a>
<a name="ln625">			   struct in_addr area_id,</a>
<a name="ln626">			   u_char is_self_originated, struct lsa_header *data)</a>
<a name="ln627">{</a>
<a name="ln628">  u_char buf[OSPF_API_MAX_MSG_SIZE];</a>
<a name="ln629">  struct msg_lsa_change_notify *nmsg;</a>
<a name="ln630">  size_t len;</a>
<a name="ln631"> </a>
<a name="ln632">  assert (data);</a>
<a name="ln633"> </a>
<a name="ln634">  nmsg = (struct msg_lsa_change_notify *) buf;</a>
<a name="ln635">  nmsg-&gt;ifaddr = ifaddr;</a>
<a name="ln636">  nmsg-&gt;area_id = area_id;</a>
<a name="ln637">  nmsg-&gt;is_self_originated = is_self_originated;</a>
<a name="ln638">  memset (&amp;nmsg-&gt;pad, 0, sizeof (nmsg-&gt;pad));</a>
<a name="ln639"> </a>
<a name="ln640">  len = ntohs (data-&gt;length);</a>
<a name="ln641">  if (len &gt; sizeof (buf) - offsetof (struct msg_lsa_change_notify, data))</a>
<a name="ln642">    len = sizeof (buf) - offsetof (struct msg_lsa_change_notify, data);</a>
<a name="ln643">  memcpy (&amp;nmsg-&gt;data, data, len);</a>
<a name="ln644">  len += sizeof (struct msg_lsa_change_notify) - sizeof (struct lsa_header);</a>
<a name="ln645"> </a>
<a name="ln646">  return msg_new (msgtype, nmsg, seqnum, len);</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">#endif /* SUPPORT_OSPF_API */</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="466"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'buf' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="472"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'len > sizeof (buf)' is always false.</p></div>
<div class="balloon" rel="485"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'buf' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="491"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'len > sizeof (buf)' is always false.</p></div>
<div class="balloon" rel="507"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'buf' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="634"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'buf' is cast to a more strictly aligned pointer type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
