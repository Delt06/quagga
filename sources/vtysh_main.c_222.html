
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>vtysh_main.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Virtual terminal interface shell.</a>
<a name="ln2"> * Copyright (C) 2000 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;sys/un.h&gt;</a>
<a name="ln25">#include &lt;setjmp.h&gt;</a>
<a name="ln26">#include &lt;sys/wait.h&gt;</a>
<a name="ln27">#include &lt;pwd.h&gt;</a>
<a name="ln28"> </a>
<a name="ln29">#include &lt;readline/readline.h&gt;</a>
<a name="ln30">#include &lt;readline/history.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &lt;lib/version.h&gt;</a>
<a name="ln33">#include &quot;getopt.h&quot;</a>
<a name="ln34">#include &quot;command.h&quot;</a>
<a name="ln35">#include &quot;memory.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;vtysh/vtysh.h&quot;</a>
<a name="ln38">#include &quot;vtysh/vtysh_user.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">/* VTY shell program name. */</a>
<a name="ln41">char *progname;</a>
<a name="ln42"> </a>
<a name="ln43">/* Configuration file name and directory. */</a>
<a name="ln44">char config_default[] = SYSCONFDIR VTYSH_DEFAULT_CONFIG;</a>
<a name="ln45">char history_file[MAXPATHLEN];</a>
<a name="ln46"> </a>
<a name="ln47">/* Flag for indicate executing child command. */</a>
<a name="ln48">int execute_flag = 0;</a>
<a name="ln49"> </a>
<a name="ln50">/* For sigsetjmp() &amp; siglongjmp(). */</a>
<a name="ln51">static sigjmp_buf jmpbuf;</a>
<a name="ln52"> </a>
<a name="ln53">/* Flag for avoid recursive siglongjmp() call. */</a>
<a name="ln54">static int jmpflag = 0;</a>
<a name="ln55"> </a>
<a name="ln56">/* A static variable for holding the line. */</a>
<a name="ln57">static char *line_read;</a>
<a name="ln58"> </a>
<a name="ln59">/* Master of threads. */</a>
<a name="ln60">struct thread_master *master;</a>
<a name="ln61"> </a>
<a name="ln62">/* Command logging */</a>
<a name="ln63">FILE *logfile;</a>
<a name="ln64"> </a>
<a name="ln65">/* SIGTSTP handler.  This function care user's ^Z input. */</a>
<a name="ln66">static void</a>
<a name="ln67">sigtstp (int sig)</a>
<a name="ln68">{</a>
<a name="ln69">  /* Execute &quot;end&quot; command. */</a>
<a name="ln70">  vtysh_execute (&quot;end&quot;);</a>
<a name="ln71">  </a>
<a name="ln72">  /* Initialize readline. */</a>
<a name="ln73">  rl_initialize ();</a>
<a name="ln74">  printf (&quot;\n&quot;);</a>
<a name="ln75"> </a>
<a name="ln76">  /* Check jmpflag for duplicate siglongjmp(). */</a>
<a name="ln77">  if (! jmpflag)</a>
<a name="ln78">    return;</a>
<a name="ln79"> </a>
<a name="ln80">  jmpflag = 0;</a>
<a name="ln81"> </a>
<a name="ln82">  /* Back to main command loop. */</a>
<a name="ln83">  siglongjmp (jmpbuf, 1);</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">/* SIGINT handler.  This function care user's ^Z input.  */</a>
<a name="ln87">static void</a>
<a name="ln88">sigint (int sig)</a>
<a name="ln89">{</a>
<a name="ln90">  /* Check this process is not child process. */</a>
<a name="ln91">  if (! execute_flag)</a>
<a name="ln92">    {</a>
<a name="ln93">      rl_initialize ();</a>
<a name="ln94">      printf (&quot;\n&quot;);</a>
<a name="ln95">      rl_forced_update_display ();</a>
<a name="ln96">    }</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">/* Signale wrapper for vtysh. We don't use sigevent because</a>
<a name="ln100"> * vtysh doesn't use threads. TODO */</a>
<a name="ln101">static void</a>
<a name="ln102">vtysh_signal_set (int signo, void (*func)(int))</a>
<a name="ln103">{</a>
<a name="ln104">  struct sigaction sig;</a>
<a name="ln105">  struct sigaction osig;</a>
<a name="ln106"> </a>
<a name="ln107">  sig.sa_handler = func;</a>
<a name="ln108">  sigemptyset (&amp;sig.sa_mask);</a>
<a name="ln109">  sig.sa_flags = 0;</a>
<a name="ln110">#ifdef SA_RESTART</a>
<a name="ln111">  sig.sa_flags |= SA_RESTART;</a>
<a name="ln112">#endif /* SA_RESTART */</a>
<a name="ln113"> </a>
<a name="ln114">  sigaction (signo, &amp;sig, &amp;osig);</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">/* Initialization of signal handles. */</a>
<a name="ln118">static void</a>
<a name="ln119">vtysh_signal_init ()</a>
<a name="ln120">{</a>
<a name="ln121">  vtysh_signal_set (SIGINT, sigint);</a>
<a name="ln122">  vtysh_signal_set (SIGTSTP, sigtstp);</a>
<a name="ln123">  vtysh_signal_set (SIGPIPE, SIG_IGN);</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">/* Help information display. */</a>
<a name="ln127">static void</a>
<a name="ln128">usage (int status)</a>
<a name="ln129">{</a>
<a name="ln130">  if (status != 0)</a>
<a name="ln131">    fprintf (stderr, &quot;Try `%s --help' for more information.\n&quot;, progname);</a>
<a name="ln132">  else</a>
<a name="ln133">    printf (&quot;Usage : %s [OPTION...]\n\n&quot; \</a>
<a name="ln134">	    &quot;Integrated shell for Quagga routing software suite. \n\n&quot; \</a>
<a name="ln135">	    &quot;-b, --boot               Execute boot startup configuration\n&quot; \</a>
<a name="ln136">	    &quot;-c, --command            Execute argument as command\n&quot; \</a>
<a name="ln137">	    &quot;-d, --daemon             Connect only to the specified daemon\n&quot; \</a>
<a name="ln138">	    &quot;-E, --echo               Echo prompt and command in -c mode\n&quot; \</a>
<a name="ln139">	    &quot;-C, --dryrun             Check configuration for validity and exit\n&quot; \</a>
<a name="ln140">	    &quot;-h, --help               Display this help and exit\n\n&quot; \</a>
<a name="ln141">	    &quot;Note that multiple commands may be executed from the command\n&quot; \</a>
<a name="ln142">	    &quot;line by passing multiple -c args, or by embedding linefeed\n&quot; \</a>
<a name="ln143">	    &quot;characters in one or more of the commands.\n\n&quot; \</a>
<a name="ln144">	    &quot;Report bugs to %s\n&quot;, progname, ZEBRA_BUG_ADDRESS);</a>
<a name="ln145"> </a>
<a name="ln146">  exit (status);</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">/* VTY shell options, we use GNU getopt library. */</a>
<a name="ln150">struct option longopts[] = </a>
<a name="ln151">{</a>
<a name="ln152">  { &quot;boot&quot;,                 no_argument,             NULL, 'b'},</a>
<a name="ln153">  /* For compatibility with older zebra/quagga versions */</a>
<a name="ln154">  { &quot;eval&quot;,                 required_argument,       NULL, 'e'},</a>
<a name="ln155">  { &quot;command&quot;,              required_argument,       NULL, 'c'},</a>
<a name="ln156">  { &quot;daemon&quot;,               required_argument,       NULL, 'd'},</a>
<a name="ln157">  { &quot;echo&quot;,                 no_argument,             NULL, 'E'},</a>
<a name="ln158">  { &quot;dryrun&quot;,		    no_argument,	     NULL, 'C'},</a>
<a name="ln159">  { &quot;help&quot;,                 no_argument,             NULL, 'h'},</a>
<a name="ln160">  { &quot;noerror&quot;,		    no_argument,	     NULL, 'n'},</a>
<a name="ln161">  { 0 }</a>
<a name="ln162">};</a>
<a name="ln163"> </a>
<a name="ln164">/* Read a string, and return a pointer to it.  Returns NULL on EOF. */</a>
<a name="ln165">static char *</a>
<a name="ln166">vtysh_rl_gets ()</a>
<a name="ln167">{</a>
<a name="ln168">  HIST_ENTRY *last;</a>
<a name="ln169">  /* If the buffer has already been allocated, return the memory</a>
<a name="ln170">   * to the free pool. */</a>
<a name="ln171">  if (line_read)</a>
<a name="ln172">    {</a>
<a name="ln173">      free (line_read);</a>
<a name="ln174">      line_read = NULL;</a>
<a name="ln175">    }</a>
<a name="ln176">     </a>
<a name="ln177">  /* Get a line from the user.  Change prompt according to node.  XXX. */</a>
<a name="ln178">  line_read = readline (vtysh_prompt ());</a>
<a name="ln179">     </a>
<a name="ln180">  /* If the line has any text in it, save it on the history. But only if</a>
<a name="ln181">   * last command in history isn't the same one. */</a>
<a name="ln182">  if (line_read &amp;&amp; *line_read)</a>
<a name="ln183">    {</a>
<a name="ln184">      using_history();</a>
<a name="ln185">      last = previous_history();</a>
<a name="ln186">      if (!last || strcmp (last-&gt;line, line_read) != 0) {</a>
<a name="ln187">	add_history (line_read);</a>
<a name="ln188">	append_history(1,history_file);</a>
<a name="ln189">      }</a>
<a name="ln190">    }</a>
<a name="ln191">     </a>
<a name="ln192">  return (line_read);</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">static void log_it(const char *line)</a>
<a name="ln196">{</a>
<a name="ln197">  time_t t = time(NULL);</a>
<a name="ln198">  struct tm *tmp = localtime(&amp;t);</a>
<a name="ln199">  const char *user = getenv(&quot;USER&quot;);</a>
<a name="ln200">  char tod[64];</a>
<a name="ln201"> </a>
<a name="ln202">  if (!user)</a>
<a name="ln203">    user = &quot;boot&quot;;</a>
<a name="ln204"> </a>
<a name="ln205">  strftime(tod, sizeof tod, &quot;%Y%m%d-%H:%M.%S&quot;, tmp);</a>
<a name="ln206">  </a>
<a name="ln207">  fprintf(logfile, &quot;%s:%s %s\n&quot;, tod, user, line);</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">/* VTY shell main routine. */</a>
<a name="ln211">int</a>
<a name="ln212">main (int argc, char **argv, char **env)</a>
<a name="ln213">{</a>
<a name="ln214">  char *p;</a>
<a name="ln215">  int opt;</a>
<a name="ln216">  int dryrun = 0;</a>
<a name="ln217">  int boot_flag = 0;</a>
<a name="ln218">  const char *daemon_name = NULL;</a>
<a name="ln219">  struct cmd_rec {</a>
<a name="ln220">    const char *line;</a>
<a name="ln221">    struct cmd_rec *next;</a>
<a name="ln222">  } *cmd = NULL;</a>
<a name="ln223">  struct cmd_rec *tail = NULL;</a>
<a name="ln224">  int echo_command = 0;</a>
<a name="ln225">  int no_error = 0;</a>
<a name="ln226">  char *homedir = NULL;</a>
<a name="ln227"> </a>
<a name="ln228">  /* Preserve name of myself. */</a>
<a name="ln229">  progname = ((p = strrchr (argv[0], '/')) ? ++p : argv[0]);</a>
<a name="ln230"> </a>
<a name="ln231">  /* if logging open now */</a>
<a name="ln232">  if ((p = getenv(&quot;VTYSH_LOG&quot;)) != NULL)</a>
<a name="ln233">      logfile = fopen(p, &quot;a&quot;);</a>
<a name="ln234"> </a>
<a name="ln235">  /* Option handling. */</a>
<a name="ln236">  while (1) </a>
<a name="ln237">    {</a>
<a name="ln238">      opt = getopt_long (argc, argv, &quot;be:c:d:nEhC&quot;, longopts, 0);</a>
<a name="ln239">    </a>
<a name="ln240">      if (opt == EOF)</a>
<a name="ln241">	break;</a>
<a name="ln242"> </a>
<a name="ln243">      switch (opt) </a>
<a name="ln244">	{</a>
<a name="ln245">	case 0:</a>
<a name="ln246">	  break;</a>
<a name="ln247">	case 'b':</a>
<a name="ln248">	  boot_flag = 1;</a>
<a name="ln249">	  break;</a>
<a name="ln250">	case 'e':</a>
<a name="ln251">	case 'c':</a>
<a name="ln252">	  {</a>
<a name="ln253">	    struct cmd_rec *cr;</a>
<a name="ln254">	    cr = XMALLOC(MTYPE_TMP, sizeof(*cr));</a>
<a name="ln255">	    cr-&gt;line = optarg;</a>
<a name="ln256">	    cr-&gt;next = NULL;</a>
<a name="ln257">	    if (tail)</a>
<a name="ln258">	      tail-&gt;next = cr;</a>
<a name="ln259">	    else</a>
<a name="ln260">	      cmd = cr;</a>
<a name="ln261">	    tail = cr;</a>
<a name="ln262">	  }</a>
<a name="ln263">	  break;</a>
<a name="ln264">	case 'd':</a>
<a name="ln265">	  daemon_name = optarg;</a>
<a name="ln266">	  break;</a>
<a name="ln267">	case 'n':</a>
<a name="ln268">	  no_error = 1;</a>
<a name="ln269">	  break;</a>
<a name="ln270">	case 'E':</a>
<a name="ln271">	  echo_command = 1;</a>
<a name="ln272">	  break;</a>
<a name="ln273">	case 'C':</a>
<a name="ln274">	  dryrun = 1;</a>
<a name="ln275">	  break;</a>
<a name="ln276">	case 'h':</a>
<a name="ln277">	  usage (0);</a>
<a name="ln278">	  break;</a>
<a name="ln279">	default:</a>
<a name="ln280">	  usage (1);</a>
<a name="ln281">	  break;</a>
<a name="ln282">	}</a>
<a name="ln283">    }</a>
<a name="ln284"> </a>
<a name="ln285">  /* Initialize user input buffer. */</a>
<a name="ln286">  line_read = NULL;</a>
<a name="ln287">  setlinebuf(stdout);</a>
<a name="ln288"> </a>
<a name="ln289">  /* Signal and others. */</a>
<a name="ln290">  vtysh_signal_init ();</a>
<a name="ln291"> </a>
<a name="ln292">  /* Make vty structure and register commands. */</a>
<a name="ln293">  vtysh_init_vty ();</a>
<a name="ln294">  vtysh_init_cmd ();</a>
<a name="ln295">  vtysh_user_init ();</a>
<a name="ln296">  vtysh_config_init ();</a>
<a name="ln297"> </a>
<a name="ln298">  vty_init_vtysh ();</a>
<a name="ln299"> </a>
<a name="ln300">  /* Read vtysh configuration file before connecting to daemons. */</a>
<a name="ln301">  vtysh_read_config (config_default);</a>
<a name="ln302"> </a>
<a name="ln303">  /* Start execution only if not in dry-run mode */</a>
<a name="ln304">  if(dryrun)</a>
<a name="ln305">    return(0);</a>
<a name="ln306">  </a>
<a name="ln307">  /* Ignore error messages */</a>
<a name="ln308">  if (no_error)</a>
<a name="ln309">    freopen(&quot;/dev/null&quot;, &quot;w&quot;, stdout);</a>
<a name="ln310"> </a>
<a name="ln311">  /* Make sure we pass authentication before proceeding. */</a>
<a name="ln312">  vtysh_auth ();</a>
<a name="ln313"> </a>
<a name="ln314">  /* Do not connect until we have passed authentication. */</a>
<a name="ln315">  if (vtysh_connect_all (daemon_name) &lt;= 0)</a>
<a name="ln316">    {</a>
<a name="ln317">      fprintf(stderr, &quot;Exiting: failed to connect to any daemons.\n&quot;);</a>
<a name="ln318">      exit(1);</a>
<a name="ln319">    }</a>
<a name="ln320"> </a>
<a name="ln321">  /*</a>
<a name="ln322">   * Setup history file for use by both -c and regular input</a>
<a name="ln323">   * If we can't find the home directory, then don't store</a>
<a name="ln324">   * the history information</a>
<a name="ln325">   */</a>
<a name="ln326">  homedir = vtysh_get_home ();</a>
<a name="ln327">  if (homedir)</a>
<a name="ln328">    {</a>
<a name="ln329">      snprintf(history_file, sizeof(history_file), &quot;%s/.history_quagga&quot;, homedir);</a>
<a name="ln330">      if (read_history (history_file) != 0)</a>
<a name="ln331">	{</a>
<a name="ln332">	  int fp;</a>
<a name="ln333"> </a>
<a name="ln334">	  fp = open (history_file, O_CREAT | O_EXCL, S_IRUSR | S_IWUSR);</a>
<a name="ln335">	  if (fp)</a>
<a name="ln336">	    close (fp);</a>
<a name="ln337"> </a>
<a name="ln338">	  read_history (history_file);</a>
<a name="ln339">	}</a>
<a name="ln340">    }</a>
<a name="ln341"> </a>
<a name="ln342">  /* If eval mode. */</a>
<a name="ln343">  if (cmd)</a>
<a name="ln344">    {</a>
<a name="ln345">      /* Enter into enable node. */</a>
<a name="ln346">      vtysh_execute (&quot;enable&quot;);</a>
<a name="ln347"> </a>
<a name="ln348">      while (cmd != NULL)</a>
<a name="ln349">        {</a>
<a name="ln350">	  int ret;</a>
<a name="ln351">	  char *eol;</a>
<a name="ln352"> </a>
<a name="ln353">	  while ((eol = strchr(cmd-&gt;line, '\n')) != NULL)</a>
<a name="ln354">	    {</a>
<a name="ln355">	      *eol = '\0';</a>
<a name="ln356"> </a>
<a name="ln357">	      add_history (cmd-&gt;line);</a>
<a name="ln358">	      append_history (1, history_file);</a>
<a name="ln359"> </a>
<a name="ln360">	      if (echo_command)</a>
<a name="ln361">		printf(&quot;%s%s\n&quot;, vtysh_prompt(), cmd-&gt;line);</a>
<a name="ln362">	      </a>
<a name="ln363">	      if (logfile)</a>
<a name="ln364">		log_it(cmd-&gt;line);</a>
<a name="ln365"> </a>
<a name="ln366">	      ret = vtysh_execute_no_pager(cmd-&gt;line);</a>
<a name="ln367">	      if (!no_error &amp;&amp;</a>
<a name="ln368">		  ! (ret == CMD_SUCCESS ||</a>
<a name="ln369">		     ret == CMD_SUCCESS_DAEMON ||</a>
<a name="ln370">		     ret == CMD_WARNING))</a>
<a name="ln371">		exit(1);</a>
<a name="ln372"> </a>
<a name="ln373">	      cmd-&gt;line = eol+1;</a>
<a name="ln374">	    }</a>
<a name="ln375"> </a>
<a name="ln376">	  add_history (cmd-&gt;line);</a>
<a name="ln377">	  append_history (1, history_file);</a>
<a name="ln378"> </a>
<a name="ln379">	  if (echo_command)</a>
<a name="ln380">	    printf(&quot;%s%s\n&quot;, vtysh_prompt(), cmd-&gt;line);</a>
<a name="ln381"> </a>
<a name="ln382">	  if (logfile)</a>
<a name="ln383">	    log_it(cmd-&gt;line);</a>
<a name="ln384"> </a>
<a name="ln385">	  ret = vtysh_execute_no_pager(cmd-&gt;line);</a>
<a name="ln386">	  if (!no_error &amp;&amp;</a>
<a name="ln387">	      ! (ret == CMD_SUCCESS ||</a>
<a name="ln388">		 ret == CMD_SUCCESS_DAEMON ||</a>
<a name="ln389">		 ret == CMD_WARNING))</a>
<a name="ln390">	    exit(1);</a>
<a name="ln391"> </a>
<a name="ln392">	  {</a>
<a name="ln393">	    struct cmd_rec *cr;</a>
<a name="ln394">	    cr = cmd;</a>
<a name="ln395">	    cmd = cmd-&gt;next;</a>
<a name="ln396">	    XFREE(0, cr);</a>
<a name="ln397">	  }</a>
<a name="ln398">        }</a>
<a name="ln399"> </a>
<a name="ln400">      history_truncate_file(history_file,1000);</a>
<a name="ln401">      exit (0);</a>
<a name="ln402">    }</a>
<a name="ln403">  </a>
<a name="ln404">  /* Boot startup configuration file. */</a>
<a name="ln405">  if (boot_flag)</a>
<a name="ln406">    {</a>
<a name="ln407">      if (vtysh_read_config (integrate_default))</a>
<a name="ln408">	{</a>
<a name="ln409">	  fprintf (stderr, &quot;Can't open configuration file [%s]\n&quot;,</a>
<a name="ln410">		   integrate_default);</a>
<a name="ln411">	  exit (1);</a>
<a name="ln412">	}</a>
<a name="ln413">      else</a>
<a name="ln414">	exit (0);</a>
<a name="ln415">    }</a>
<a name="ln416"> </a>
<a name="ln417">  vtysh_pager_init ();</a>
<a name="ln418"> </a>
<a name="ln419">  vtysh_readline_init ();</a>
<a name="ln420"> </a>
<a name="ln421">  vty_hello (vty);</a>
<a name="ln422"> </a>
<a name="ln423">  /* Enter into enable node. */</a>
<a name="ln424">  vtysh_execute (&quot;enable&quot;);</a>
<a name="ln425"> </a>
<a name="ln426">  /* Preparation for longjmp() in sigtstp(). */</a>
<a name="ln427">  sigsetjmp (jmpbuf, 1);</a>
<a name="ln428">  jmpflag = 1;</a>
<a name="ln429"> </a>
<a name="ln430">  /* Main command loop. */</a>
<a name="ln431">  while (vtysh_rl_gets ())</a>
<a name="ln432">    vtysh_execute (line_read);</a>
<a name="ln433"> </a>
<a name="ln434">  history_truncate_file(history_file,1000);</a>
<a name="ln435">  printf (&quot;\n&quot;);</a>
<a name="ln436"> </a>
<a name="ln437">  /* Rest in peace. */</a>
<a name="ln438">  exit (0);</a>
<a name="ln439">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
