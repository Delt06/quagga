
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_shortcut.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP shortcut related functions</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;nhrpd.h&quot;</a>
<a name="ln11">#include &quot;table.h&quot;</a>
<a name="ln12">#include &quot;memory.h&quot;</a>
<a name="ln13">#include &quot;thread.h&quot;</a>
<a name="ln14">#include &quot;log.h&quot;</a>
<a name="ln15">#include &quot;nhrp_protocol.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17">static struct route_table *shortcut_rib[AFI_MAX];</a>
<a name="ln18"> </a>
<a name="ln19">static int nhrp_shortcut_do_purge(struct thread *t);</a>
<a name="ln20">static void nhrp_shortcut_delete(struct nhrp_shortcut *s);</a>
<a name="ln21">static void nhrp_shortcut_send_resolution_req(struct nhrp_shortcut *s);</a>
<a name="ln22"> </a>
<a name="ln23">static void nhrp_shortcut_check_use(struct nhrp_shortcut *s)</a>
<a name="ln24">{</a>
<a name="ln25">	char buf[PREFIX_STRLEN];</a>
<a name="ln26"> </a>
<a name="ln27">	if (s-&gt;expiring &amp;&amp; s-&gt;cache &amp;&amp; s-&gt;cache-&gt;used) {</a>
<a name="ln28">		debugf(NHRP_DEBUG_ROUTE, &quot;Shortcut %s used and expiring&quot;,</a>
<a name="ln29">			prefix2str(s-&gt;p, buf, sizeof buf));</a>
<a name="ln30">		nhrp_shortcut_send_resolution_req(s);</a>
<a name="ln31">	}</a>
<a name="ln32">}</a>
<a name="ln33"> </a>
<a name="ln34">static int nhrp_shortcut_do_expire(struct thread *t)</a>
<a name="ln35">{</a>
<a name="ln36">	struct nhrp_shortcut *s = THREAD_ARG(t);</a>
<a name="ln37"> </a>
<a name="ln38">	s-&gt;t_timer = NULL;</a>
<a name="ln39">	THREAD_TIMER_ON(master, s-&gt;t_timer, nhrp_shortcut_do_purge, s, s-&gt;holding_time/3);</a>
<a name="ln40">	s-&gt;expiring = 1;</a>
<a name="ln41">	nhrp_shortcut_check_use(s);</a>
<a name="ln42"> </a>
<a name="ln43">	return 0;</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">static void nhrp_shortcut_cache_notify(struct notifier_block *n, unsigned long cmd)</a>
<a name="ln47">{</a>
<a name="ln48">	struct nhrp_shortcut *s = container_of(n, struct nhrp_shortcut, cache_notifier);</a>
<a name="ln49"> </a>
<a name="ln50">	switch (cmd) {</a>
<a name="ln51">	case NOTIFY_CACHE_UP:</a>
<a name="ln52">		if (!s-&gt;route_installed) {</a>
<a name="ln53">			nhrp_route_announce(1, s-&gt;type, s-&gt;p, NULL, &amp;s-&gt;cache-&gt;remote_addr, 0);</a>
<a name="ln54">			s-&gt;route_installed = 1;</a>
<a name="ln55">		}</a>
<a name="ln56">		break;</a>
<a name="ln57">	case NOTIFY_CACHE_USED:</a>
<a name="ln58">		nhrp_shortcut_check_use(s);</a>
<a name="ln59">		break;</a>
<a name="ln60">	case NOTIFY_CACHE_DOWN:</a>
<a name="ln61">	case NOTIFY_CACHE_DELETE:</a>
<a name="ln62">		if (s-&gt;route_installed) {</a>
<a name="ln63">			nhrp_route_announce(0, NHRP_CACHE_INVALID, s-&gt;p, NULL, NULL, 0);</a>
<a name="ln64">			s-&gt;route_installed = 0;</a>
<a name="ln65">		}</a>
<a name="ln66">		if (cmd == NOTIFY_CACHE_DELETE)</a>
<a name="ln67">			nhrp_shortcut_delete(s);</a>
<a name="ln68">		break;</a>
<a name="ln69">	}</a>
<a name="ln70">}</a>
<a name="ln71"> </a>
<a name="ln72">static void nhrp_shortcut_update_binding(struct nhrp_shortcut *s, enum nhrp_cache_type type, struct nhrp_cache *c, int holding_time)</a>
<a name="ln73">{</a>
<a name="ln74">	s-&gt;type = type;</a>
<a name="ln75">	if (c != s-&gt;cache) {</a>
<a name="ln76">		if (s-&gt;cache) {</a>
<a name="ln77">			nhrp_cache_notify_del(s-&gt;cache, &amp;s-&gt;cache_notifier);</a>
<a name="ln78">			s-&gt;cache = NULL;</a>
<a name="ln79">		}</a>
<a name="ln80">		s-&gt;cache = c;</a>
<a name="ln81">		if (s-&gt;cache) {</a>
<a name="ln82">			nhrp_cache_notify_add(s-&gt;cache, &amp;s-&gt;cache_notifier, nhrp_shortcut_cache_notify);</a>
<a name="ln83">			if (s-&gt;cache-&gt;route_installed) {</a>
<a name="ln84">				/* Force renewal of Zebra announce on prefix change */</a>
<a name="ln85">				s-&gt;route_installed = 0;</a>
<a name="ln86">				nhrp_shortcut_cache_notify(&amp;s-&gt;cache_notifier, NOTIFY_CACHE_UP);</a>
<a name="ln87">			}</a>
<a name="ln88">		}</a>
<a name="ln89">		if (!s-&gt;cache || !s-&gt;cache-&gt;route_installed)</a>
<a name="ln90">			nhrp_shortcut_cache_notify(&amp;s-&gt;cache_notifier, NOTIFY_CACHE_DOWN);</a>
<a name="ln91">	}</a>
<a name="ln92">	if (s-&gt;type == NHRP_CACHE_NEGATIVE &amp;&amp; !s-&gt;route_installed) {</a>
<a name="ln93">		nhrp_route_announce(1, s-&gt;type, s-&gt;p, NULL, NULL, 0);</a>
<a name="ln94">		s-&gt;route_installed = 1;</a>
<a name="ln95">	} else if (s-&gt;type == NHRP_CACHE_INVALID &amp;&amp; s-&gt;route_installed) {</a>
<a name="ln96">		nhrp_route_announce(0, NHRP_CACHE_INVALID, s-&gt;p, NULL, NULL, 0);</a>
<a name="ln97">		s-&gt;route_installed = 0;</a>
<a name="ln98">	}</a>
<a name="ln99"> </a>
<a name="ln100">	THREAD_OFF(s-&gt;t_timer);</a>
<a name="ln101">	if (holding_time) {</a>
<a name="ln102">		s-&gt;expiring = 0;</a>
<a name="ln103">		s-&gt;holding_time = holding_time;</a>
<a name="ln104">		THREAD_TIMER_ON(master, s-&gt;t_timer, nhrp_shortcut_do_expire, s, 2*holding_time/3);</a>
<a name="ln105">	}</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">static void nhrp_shortcut_delete(struct nhrp_shortcut *s)</a>
<a name="ln109">{</a>
<a name="ln110">	struct route_node *rn;</a>
<a name="ln111">	afi_t afi = family2afi(PREFIX_FAMILY(s-&gt;p));</a>
<a name="ln112">	char buf[PREFIX_STRLEN];</a>
<a name="ln113"> </a>
<a name="ln114">	THREAD_OFF(s-&gt;t_timer);</a>
<a name="ln115">	nhrp_reqid_free(&amp;nhrp_packet_reqid, &amp;s-&gt;reqid);</a>
<a name="ln116"> </a>
<a name="ln117">	debugf(NHRP_DEBUG_ROUTE, &quot;Shortcut %s purged&quot;,</a>
<a name="ln118">		prefix2str(s-&gt;p, buf, sizeof buf));</a>
<a name="ln119"> </a>
<a name="ln120">	nhrp_shortcut_update_binding(s, NHRP_CACHE_INVALID, NULL, 0);</a>
<a name="ln121"> </a>
<a name="ln122">	/* Delete node */</a>
<a name="ln123">	rn = route_node_lookup(shortcut_rib[afi], s-&gt;p);</a>
<a name="ln124">	if (rn) {</a>
<a name="ln125">		XFREE(MTYPE_NHRP_SHORTCUT, rn-&gt;info);</a>
<a name="ln126">		rn-&gt;info = NULL;</a>
<a name="ln127">		route_unlock_node(rn);</a>
<a name="ln128">		route_unlock_node(rn);</a>
<a name="ln129">	}</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">static int nhrp_shortcut_do_purge(struct thread *t)</a>
<a name="ln133">{</a>
<a name="ln134">	struct nhrp_shortcut *s = THREAD_ARG(t);</a>
<a name="ln135">	s-&gt;t_timer = NULL;</a>
<a name="ln136">	nhrp_shortcut_delete(s);</a>
<a name="ln137">	return 0;</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">static struct nhrp_shortcut *nhrp_shortcut_get(struct prefix *p)</a>
<a name="ln141">{</a>
<a name="ln142">	struct nhrp_shortcut *s;</a>
<a name="ln143">	struct route_node *rn;</a>
<a name="ln144">	char buf[PREFIX_STRLEN];</a>
<a name="ln145">	afi_t afi = family2afi(PREFIX_FAMILY(p));</a>
<a name="ln146"> </a>
<a name="ln147">	if (!shortcut_rib[afi])</a>
<a name="ln148">		return 0;</a>
<a name="ln149"> </a>
<a name="ln150">	rn = route_node_get(shortcut_rib[afi], p);</a>
<a name="ln151">	if (!rn-&gt;info) {</a>
<a name="ln152">		s = rn-&gt;info = XCALLOC(MTYPE_NHRP_SHORTCUT, sizeof(struct nhrp_shortcut));</a>
<a name="ln153">		s-&gt;type = NHRP_CACHE_INVALID;</a>
<a name="ln154">		s-&gt;p = &amp;rn-&gt;p;</a>
<a name="ln155"> </a>
<a name="ln156">		debugf(NHRP_DEBUG_ROUTE, &quot;Shortcut %s created&quot;,</a>
<a name="ln157">			prefix2str(s-&gt;p, buf, sizeof buf));</a>
<a name="ln158">	} else {</a>
<a name="ln159">		s = rn-&gt;info;</a>
<a name="ln160">		route_unlock_node(rn);</a>
<a name="ln161">	}</a>
<a name="ln162">	return s;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">static void nhrp_shortcut_recv_resolution_rep(struct nhrp_reqid *reqid, void *arg)</a>
<a name="ln166">{</a>
<a name="ln167">	struct nhrp_packet_parser *pp = arg;</a>
<a name="ln168">	struct nhrp_shortcut *s = container_of(reqid, struct nhrp_shortcut, reqid);</a>
<a name="ln169">	struct nhrp_shortcut *ps;</a>
<a name="ln170">	struct nhrp_extension_header *ext;</a>
<a name="ln171">	struct nhrp_cie_header *cie;</a>
<a name="ln172">	struct nhrp_cache *c = NULL;</a>
<a name="ln173">	union sockunion *proto, cie_proto, *nbma, *nbma_natoa, cie_nbma, nat_nbma;</a>
<a name="ln174">	struct prefix prefix, route_prefix;</a>
<a name="ln175">	struct zbuf extpl;</a>
<a name="ln176">	char bufp[PREFIX_STRLEN], buf[3][SU_ADDRSTRLEN];</a>
<a name="ln177">	int holding_time = pp-&gt;if_ad-&gt;holdtime;</a>
<a name="ln178"> </a>
<a name="ln179">	nhrp_reqid_free(&amp;nhrp_packet_reqid, &amp;s-&gt;reqid);</a>
<a name="ln180">	THREAD_OFF(s-&gt;t_timer);</a>
<a name="ln181">	THREAD_TIMER_ON(master, s-&gt;t_timer, nhrp_shortcut_do_purge, s, 1);</a>
<a name="ln182"> </a>
<a name="ln183">	if (pp-&gt;hdr-&gt;type != NHRP_PACKET_RESOLUTION_REPLY) {</a>
<a name="ln184">		if (pp-&gt;hdr-&gt;type == NHRP_PACKET_ERROR_INDICATION &amp;&amp;</a>
<a name="ln185">		    pp-&gt;hdr-&gt;u.error.code == NHRP_ERROR_PROTOCOL_ADDRESS_UNREACHABLE) {</a>
<a name="ln186">			debugf(NHRP_DEBUG_COMMON, &quot;Shortcut: Resolution: Protocol address unreachable&quot;);</a>
<a name="ln187">			nhrp_shortcut_update_binding(s, NHRP_CACHE_NEGATIVE, NULL, holding_time);</a>
<a name="ln188">		} else {</a>
<a name="ln189">			debugf(NHRP_DEBUG_COMMON, &quot;Shortcut: Resolution failed&quot;);</a>
<a name="ln190">		}</a>
<a name="ln191">		return;</a>
<a name="ln192">	}</a>
<a name="ln193"> </a>
<a name="ln194">	/* Parse extensions */</a>
<a name="ln195">	memset(&amp;nat_nbma, 0, sizeof nat_nbma);</a>
<a name="ln196">	while ((ext = nhrp_ext_pull(&amp;pp-&gt;extensions, &amp;extpl)) != NULL) {</a>
<a name="ln197">		switch (htons(ext-&gt;type) &amp; ~NHRP_EXTENSION_FLAG_COMPULSORY) {</a>
<a name="ln198">		case NHRP_EXTENSION_NAT_ADDRESS:</a>
<a name="ln199">			nhrp_cie_pull(&amp;extpl, pp-&gt;hdr, &amp;nat_nbma, &amp;cie_proto);</a>
<a name="ln200">			break;</a>
<a name="ln201">		}</a>
<a name="ln202">	}</a>
<a name="ln203"> </a>
<a name="ln204">	/* Minor sanity check */</a>
<a name="ln205">	prefix2sockunion(s-&gt;p, &amp;cie_proto);</a>
<a name="ln206">	if (!sockunion_same(&amp;cie_proto, &amp;pp-&gt;dst_proto)) {</a>
<a name="ln207">		debugf(NHRP_DEBUG_COMMON, &quot;Shortcut: Warning dst_proto altered from %s to %s&quot;,</a>
<a name="ln208">			sockunion2str(&amp;cie_proto, buf[0], sizeof buf[0]),</a>
<a name="ln209">			sockunion2str(&amp;pp-&gt;dst_proto, buf[1], sizeof buf[1]));</a>
<a name="ln210">	}</a>
<a name="ln211"> </a>
<a name="ln212">	/* One or more CIEs should be given as reply, we support only one */</a>
<a name="ln213">	cie = nhrp_cie_pull(&amp;pp-&gt;payload, pp-&gt;hdr, &amp;cie_nbma, &amp;cie_proto);</a>
<a name="ln214">	if (!cie || cie-&gt;code != NHRP_CODE_SUCCESS) {</a>
<a name="ln215">		debugf(NHRP_DEBUG_COMMON, &quot;Shortcut: CIE code %d&quot;, cie ? cie-&gt;code : -1);</a>
<a name="ln216">		return;</a>
<a name="ln217">	}</a>
<a name="ln218"> </a>
<a name="ln219">	proto = sockunion_family(&amp;cie_proto) != AF_UNSPEC ? &amp;cie_proto : &amp;pp-&gt;dst_proto;</a>
<a name="ln220">	if (cie-&gt;holding_time)</a>
<a name="ln221">		holding_time = htons(cie-&gt;holding_time);</a>
<a name="ln222"> </a>
<a name="ln223">	prefix = *s-&gt;p;</a>
<a name="ln224">	prefix.prefixlen = cie-&gt;prefix_length;</a>
<a name="ln225"> </a>
<a name="ln226">	/* Sanity check prefix length */</a>
<a name="ln227">	if (prefix.prefixlen &gt;= 8*prefix_blen(&amp;prefix) || prefix.prefixlen == 0) {</a>
<a name="ln228">		prefix.prefixlen = 8*prefix_blen(&amp;prefix);</a>
<a name="ln229">	} else if (nhrp_route_address(NULL, &amp;pp-&gt;dst_proto, &amp;route_prefix, NULL) == NHRP_ROUTE_NBMA_NEXTHOP) {</a>
<a name="ln230">		if (prefix.prefixlen &lt; route_prefix.prefixlen)</a>
<a name="ln231">			prefix.prefixlen = route_prefix.prefixlen;</a>
<a name="ln232">	}</a>
<a name="ln233"> </a>
<a name="ln234">	debugf(NHRP_DEBUG_COMMON, &quot;Shortcut: %s is at proto %s cie-nbma %s nat-nbma %s cie-holdtime %d&quot;,</a>
<a name="ln235">		prefix2str(&amp;prefix, bufp, sizeof bufp),</a>
<a name="ln236">		sockunion2str(proto, buf[0], sizeof buf[0]),</a>
<a name="ln237">		sockunion2str(&amp;cie_nbma, buf[1], sizeof buf[1]),</a>
<a name="ln238">		sockunion2str(&amp;nat_nbma, buf[2], sizeof buf[2]),</a>
<a name="ln239">		htons(cie-&gt;holding_time));</a>
<a name="ln240"> </a>
<a name="ln241">	/* Update cache entry for the protocol to nbma binding */</a>
<a name="ln242">	if (sockunion_family(&amp;nat_nbma) != AF_UNSPEC) {</a>
<a name="ln243">		nbma = &amp;nat_nbma;</a>
<a name="ln244">		nbma_natoa = &amp;cie_nbma;</a>
<a name="ln245">	} else {</a>
<a name="ln246">		nbma = &amp;cie_nbma;</a>
<a name="ln247">		nbma_natoa = NULL;</a>
<a name="ln248">	}</a>
<a name="ln249">	if (sockunion_family(nbma)) {</a>
<a name="ln250">		c = nhrp_cache_get(pp-&gt;ifp, proto, 1);</a>
<a name="ln251">		if (c) {</a>
<a name="ln252">			nhrp_cache_update_binding(</a>
<a name="ln253">					c, NHRP_CACHE_CACHED, holding_time,</a>
<a name="ln254">					nhrp_peer_get(pp-&gt;ifp, nbma),</a>
<a name="ln255">					htons(cie-&gt;mtu), nbma_natoa);</a>
<a name="ln256">		}</a>
<a name="ln257">	}</a>
<a name="ln258"> </a>
<a name="ln259">	/* Update shortcut entry for subnet to protocol gw binding */</a>
<a name="ln260">	if (c &amp;&amp; !sockunion_same(proto, &amp;pp-&gt;dst_proto)) {</a>
<a name="ln261">		ps = nhrp_shortcut_get(&amp;prefix);</a>
<a name="ln262">		if (ps) {</a>
<a name="ln263">			ps-&gt;addr = s-&gt;addr;</a>
<a name="ln264">			nhrp_shortcut_update_binding(ps, NHRP_CACHE_CACHED, c, holding_time);</a>
<a name="ln265">		}</a>
<a name="ln266">	}</a>
<a name="ln267"> </a>
<a name="ln268">	debugf(NHRP_DEBUG_COMMON, &quot;Shortcut: Resolution reply handled&quot;);</a>
<a name="ln269">}</a>
<a name="ln270"> </a>
<a name="ln271">static void nhrp_shortcut_send_resolution_req(struct nhrp_shortcut *s)</a>
<a name="ln272">{</a>
<a name="ln273">	struct zbuf *zb;</a>
<a name="ln274">	struct nhrp_packet_header *hdr;</a>
<a name="ln275">	struct interface *ifp;</a>
<a name="ln276">	struct nhrp_interface *nifp;</a>
<a name="ln277">	struct nhrp_peer *peer;</a>
<a name="ln278"> </a>
<a name="ln279">	if (nhrp_route_address(NULL, &amp;s-&gt;addr, NULL, &amp;peer) != NHRP_ROUTE_NBMA_NEXTHOP)</a>
<a name="ln280">		return;</a>
<a name="ln281"> </a>
<a name="ln282">	if (s-&gt;type == NHRP_CACHE_INVALID || s-&gt;type == NHRP_CACHE_NEGATIVE)</a>
<a name="ln283">		s-&gt;type = NHRP_CACHE_INCOMPLETE;</a>
<a name="ln284"> </a>
<a name="ln285">	ifp = peer-&gt;ifp;</a>
<a name="ln286">	nifp = ifp-&gt;info;</a>
<a name="ln287"> </a>
<a name="ln288">	/* Create request */</a>
<a name="ln289">	zb = zbuf_alloc(1500);</a>
<a name="ln290">	hdr = nhrp_packet_push(zb, NHRP_PACKET_RESOLUTION_REQUEST,</a>
<a name="ln291">		&amp;nifp-&gt;nbma, &amp;nifp-&gt;afi[family2afi(sockunion_family(&amp;s-&gt;addr))].addr, &amp;s-&gt;addr);</a>
<a name="ln292">	hdr-&gt;u.request_id = htonl(nhrp_reqid_alloc(&amp;nhrp_packet_reqid, &amp;s-&gt;reqid, nhrp_shortcut_recv_resolution_rep));</a>
<a name="ln293">	hdr-&gt;flags = htons(NHRP_FLAG_RESOLUTION_SOURCE_IS_ROUTER |</a>
<a name="ln294">			   NHRP_FLAG_RESOLUTION_AUTHORATIVE |</a>
<a name="ln295">			   NHRP_FLAG_RESOLUTION_SOURCE_STABLE);</a>
<a name="ln296"> </a>
<a name="ln297">	/* RFC2332 - One or zero CIEs, if CIE is present contains:</a>
<a name="ln298">	 *  - Prefix length: widest acceptable prefix we accept (if U set, 0xff)</a>
<a name="ln299">	 *  - MTU: MTU of the source station</a>
<a name="ln300">	 *  - Holding Time: Max time to cache the source information</a>
<a name="ln301">	 * */</a>
<a name="ln302">	/* FIXME: Send holding time, and MTU */</a>
<a name="ln303"> </a>
<a name="ln304">	nhrp_ext_request(zb, hdr, ifp);</a>
<a name="ln305"> </a>
<a name="ln306">	/* Cisco NAT detection extension */</a>
<a name="ln307">	hdr-&gt;flags |= htons(NHRP_FLAG_RESOLUTION_NAT);</a>
<a name="ln308">	nhrp_ext_push(zb, hdr, NHRP_EXTENSION_NAT_ADDRESS);</a>
<a name="ln309"> </a>
<a name="ln310">	nhrp_packet_complete(zb, hdr);</a>
<a name="ln311"> </a>
<a name="ln312">	nhrp_peer_send(peer, zb);</a>
<a name="ln313">	nhrp_peer_unref(peer);</a>
<a name="ln314">	zbuf_free(zb);</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">void nhrp_shortcut_initiate(union sockunion *addr)</a>
<a name="ln318">{</a>
<a name="ln319">	struct prefix p;</a>
<a name="ln320">	struct nhrp_shortcut *s;</a>
<a name="ln321"> </a>
<a name="ln322">	sockunion2hostprefix(addr, &amp;p);</a>
<a name="ln323">	s = nhrp_shortcut_get(&amp;p);</a>
<a name="ln324">	if (s &amp;&amp; s-&gt;type != NHRP_CACHE_INCOMPLETE) {</a>
<a name="ln325">		s-&gt;addr = *addr;</a>
<a name="ln326">		THREAD_OFF(s-&gt;t_timer);</a>
<a name="ln327">		THREAD_TIMER_ON(master, s-&gt;t_timer, nhrp_shortcut_do_purge, s, 30);</a>
<a name="ln328">		nhrp_shortcut_send_resolution_req(s);</a>
<a name="ln329">	}</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">void nhrp_shortcut_init(void)</a>
<a name="ln333">{</a>
<a name="ln334">	shortcut_rib[AFI_IP] = route_table_init();</a>
<a name="ln335">	shortcut_rib[AFI_IP6] = route_table_init();</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">void nhrp_shortcut_terminate(void)</a>
<a name="ln339">{</a>
<a name="ln340">	route_table_finish(shortcut_rib[AFI_IP]);</a>
<a name="ln341">	route_table_finish(shortcut_rib[AFI_IP6]);</a>
<a name="ln342">}</a>
<a name="ln343"> </a>
<a name="ln344">void nhrp_shortcut_foreach(afi_t afi, void (*cb)(struct nhrp_shortcut *, void *), void *ctx)</a>
<a name="ln345">{</a>
<a name="ln346">	struct route_table *rt = shortcut_rib[afi];</a>
<a name="ln347">	struct route_node *rn;</a>
<a name="ln348">	route_table_iter_t iter;</a>
<a name="ln349"> </a>
<a name="ln350">	if (!rt) return;</a>
<a name="ln351"> </a>
<a name="ln352">	route_table_iter_init(&amp;iter, rt);</a>
<a name="ln353">	while ((rn = route_table_iter_next(&amp;iter)) != NULL) {</a>
<a name="ln354">		if (rn-&gt;info) cb(rn-&gt;info, ctx);</a>
<a name="ln355">	}</a>
<a name="ln356">	route_table_iter_cleanup(&amp;iter);</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">struct purge_ctx {</a>
<a name="ln360">	const struct prefix *p;</a>
<a name="ln361">	int deleted;</a>
<a name="ln362">};</a>
<a name="ln363"> </a>
<a name="ln364">void nhrp_shortcut_purge(struct nhrp_shortcut *s, int force)</a>
<a name="ln365">{</a>
<a name="ln366">	THREAD_OFF(s-&gt;t_timer);</a>
<a name="ln367">	nhrp_reqid_free(&amp;nhrp_packet_reqid, &amp;s-&gt;reqid);</a>
<a name="ln368"> </a>
<a name="ln369">	if (force) {</a>
<a name="ln370">		/* Immediate purge on route with draw or pending shortcut */</a>
<a name="ln371">		THREAD_TIMER_MSEC_ON(master, s-&gt;t_timer, nhrp_shortcut_do_purge, s, 5);</a>
<a name="ln372">	} else {</a>
<a name="ln373">		/* Soft expire - force immediate renewal, but purge</a>
<a name="ln374">		 * in few seconds to make sure stale route is not</a>
<a name="ln375">		 * used too long. In practice most purges are caused</a>
<a name="ln376">		 * by hub bgp change, but target usually stays same.</a>
<a name="ln377">		 * This allows to keep nhrp route up, and to not</a>
<a name="ln378">		 * cause temporary rerouting via hubs causing latency</a>
<a name="ln379">		 * jitter. */</a>
<a name="ln380">		THREAD_TIMER_MSEC_ON(master, s-&gt;t_timer, nhrp_shortcut_do_purge, s, 3000);</a>
<a name="ln381">		s-&gt;expiring = 1;</a>
<a name="ln382">		nhrp_shortcut_check_use(s);</a>
<a name="ln383">	}</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">static void nhrp_shortcut_purge_prefix(struct nhrp_shortcut *s, void *ctx)</a>
<a name="ln387">{</a>
<a name="ln388">	struct purge_ctx *pctx = ctx;</a>
<a name="ln389"> </a>
<a name="ln390">	if (prefix_match(pctx-&gt;p, s-&gt;p))</a>
<a name="ln391">		nhrp_shortcut_purge(s, pctx-&gt;deleted || !s-&gt;cache);</a>
<a name="ln392">}</a>
<a name="ln393"> </a>
<a name="ln394">void nhrp_shortcut_prefix_change(const struct prefix *p, int deleted)</a>
<a name="ln395">{</a>
<a name="ln396">	struct purge_ctx pctx = {</a>
<a name="ln397">		.p = p,</a>
<a name="ln398">		.deleted = deleted,</a>
<a name="ln399">	};</a>
<a name="ln400">	nhrp_shortcut_foreach(family2afi(PREFIX_FAMILY(p)), nhrp_shortcut_purge_prefix, &amp;pctx);</a>
<a name="ln401">}</a>
<a name="ln402"> </a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
