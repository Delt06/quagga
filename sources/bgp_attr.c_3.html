
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_attr.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP attributes management routines.</a>
<a name="ln2">   Copyright (C) 1996, 97, 98, 1999 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;linklist.h&quot;</a>
<a name="ln24">#include &quot;prefix.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;vector.h&quot;</a>
<a name="ln27">#include &quot;vty.h&quot;</a>
<a name="ln28">#include &quot;stream.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;hash.h&quot;</a>
<a name="ln31">#include &quot;jhash.h&quot;</a>
<a name="ln32">#include &quot;filter.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln35">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln38">#include &quot;bgpd/bgp_community.h&quot;</a>
<a name="ln39">#include &quot;bgpd/bgp_debug.h&quot;</a>
<a name="ln40">#include &quot;bgpd/bgp_packet.h&quot;</a>
<a name="ln41">#include &quot;bgpd/bgp_ecommunity.h&quot;</a>
<a name="ln42">#include &quot;bgpd/bgp_lcommunity.h&quot;</a>
<a name="ln43">#include &quot;table.h&quot;</a>
<a name="ln44">#include &quot;bgp_encap_types.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">/* Attribute strings for logging. */</a>
<a name="ln47">static const struct message attr_str [] = </a>
<a name="ln48">{</a>
<a name="ln49">  { BGP_ATTR_ORIGIN,           &quot;ORIGIN&quot; }, </a>
<a name="ln50">  { BGP_ATTR_AS_PATH,          &quot;AS_PATH&quot; }, </a>
<a name="ln51">  { BGP_ATTR_NEXT_HOP,         &quot;NEXT_HOP&quot; }, </a>
<a name="ln52">  { BGP_ATTR_MULTI_EXIT_DISC,  &quot;MULTI_EXIT_DISC&quot; }, </a>
<a name="ln53">  { BGP_ATTR_LOCAL_PREF,       &quot;LOCAL_PREF&quot; }, </a>
<a name="ln54">  { BGP_ATTR_ATOMIC_AGGREGATE, &quot;ATOMIC_AGGREGATE&quot; }, </a>
<a name="ln55">  { BGP_ATTR_AGGREGATOR,       &quot;AGGREGATOR&quot; }, </a>
<a name="ln56">  { BGP_ATTR_COMMUNITIES,      &quot;COMMUNITY&quot; }, </a>
<a name="ln57">  { BGP_ATTR_ORIGINATOR_ID,    &quot;ORIGINATOR_ID&quot; },</a>
<a name="ln58">  { BGP_ATTR_CLUSTER_LIST,     &quot;CLUSTER_LIST&quot; }, </a>
<a name="ln59">  { BGP_ATTR_DPA,              &quot;DPA&quot; },</a>
<a name="ln60">  { BGP_ATTR_ADVERTISER,       &quot;ADVERTISER&quot;} ,</a>
<a name="ln61">  { BGP_ATTR_RCID_PATH,        &quot;RCID_PATH&quot; },</a>
<a name="ln62">  { BGP_ATTR_MP_REACH_NLRI,    &quot;MP_REACH_NLRI&quot; },</a>
<a name="ln63">  { BGP_ATTR_MP_UNREACH_NLRI,  &quot;MP_UNREACH_NLRI&quot; },</a>
<a name="ln64">  { BGP_ATTR_EXT_COMMUNITIES,  &quot;EXT_COMMUNITIES&quot; },</a>
<a name="ln65">  { BGP_ATTR_AS4_PATH,         &quot;AS4_PATH&quot; }, </a>
<a name="ln66">  { BGP_ATTR_AS4_AGGREGATOR,   &quot;AS4_AGGREGATOR&quot; }, </a>
<a name="ln67">  { BGP_ATTR_AS_PATHLIMIT,     &quot;AS_PATHLIMIT&quot; },</a>
<a name="ln68">  { BGP_ATTR_ENCAP,            &quot;ENCAP&quot; },</a>
<a name="ln69">  { 21,                        &quot;&quot;},</a>
<a name="ln70">  { 22,                        &quot;&quot;},</a>
<a name="ln71">  { 23,                        &quot;&quot;},</a>
<a name="ln72">  { 24,                        &quot;&quot;},</a>
<a name="ln73">  { 25,                        &quot;&quot;},</a>
<a name="ln74">  { 26,                        &quot;&quot;},</a>
<a name="ln75">  { 27,                        &quot;&quot;},</a>
<a name="ln76">  { 28,                        &quot;&quot;},</a>
<a name="ln77">  { 29,                        &quot;&quot;},</a>
<a name="ln78">  { 30,                        &quot;&quot;},</a>
<a name="ln79">  { 31,                        &quot;&quot;},</a>
<a name="ln80">  { BGP_ATTR_LARGE_COMMUNITIES, &quot;LARGE_COMMUNITY&quot; }</a>
<a name="ln81">};</a>
<a name="ln82">static const int attr_str_max = array_size(attr_str);</a>
<a name="ln83"> </a>
<a name="ln84">static const struct message attr_flag_str[] =</a>
<a name="ln85">{</a>
<a name="ln86">  { BGP_ATTR_FLAG_OPTIONAL, &quot;Optional&quot; },</a>
<a name="ln87">  { BGP_ATTR_FLAG_TRANS,    &quot;Transitive&quot; },</a>
<a name="ln88">  { BGP_ATTR_FLAG_PARTIAL,  &quot;Partial&quot; },</a>
<a name="ln89">  /* bgp_attr_flags_diagnose() relies on this bit being last in this list */</a>
<a name="ln90">  { BGP_ATTR_FLAG_EXTLEN,   &quot;Extended Length&quot; },</a>
<a name="ln91">};</a>
<a name="ln92"> </a>
<a name="ln93">static struct hash *cluster_hash;</a>
<a name="ln94"> </a>
<a name="ln95">static void *</a>
<a name="ln96">cluster_hash_alloc (void *p)</a>
<a name="ln97">{</a>
<a name="ln98">  struct cluster_list * val = (struct cluster_list *) p;</a>
<a name="ln99">  struct cluster_list *cluster;</a>
<a name="ln100"> </a>
<a name="ln101">  cluster = XMALLOC (MTYPE_CLUSTER, sizeof (struct cluster_list));</a>
<a name="ln102">  cluster-&gt;length = val-&gt;length;</a>
<a name="ln103"> </a>
<a name="ln104">  if (cluster-&gt;length)</a>
<a name="ln105">    {</a>
<a name="ln106">      cluster-&gt;list = XMALLOC (MTYPE_CLUSTER_VAL, val-&gt;length);</a>
<a name="ln107">      memcpy (cluster-&gt;list, val-&gt;list, val-&gt;length);</a>
<a name="ln108">    }</a>
<a name="ln109">  else</a>
<a name="ln110">    cluster-&gt;list = NULL;</a>
<a name="ln111"> </a>
<a name="ln112">  cluster-&gt;refcnt = 0;</a>
<a name="ln113"> </a>
<a name="ln114">  return cluster;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">/* Cluster list related functions. */</a>
<a name="ln118">static struct cluster_list *</a>
<a name="ln119">cluster_parse (struct in_addr * pnt, int length)</a>
<a name="ln120">{</a>
<a name="ln121">  struct cluster_list tmp;</a>
<a name="ln122">  struct cluster_list *cluster;</a>
<a name="ln123"> </a>
<a name="ln124">  tmp.length = length;</a>
<a name="ln125">  tmp.list = pnt;</a>
<a name="ln126"> </a>
<a name="ln127">  cluster = hash_get (cluster_hash, &amp;tmp, cluster_hash_alloc);</a>
<a name="ln128">  cluster-&gt;refcnt++;</a>
<a name="ln129">  return cluster;</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">int</a>
<a name="ln133">cluster_loop_check (struct cluster_list *cluster, struct in_addr originator)</a>
<a name="ln134">{</a>
<a name="ln135">  int i;</a>
<a name="ln136">    </a>
<a name="ln137">  for (i = 0; i &lt; cluster-&gt;length / 4; i++)</a>
<a name="ln138">    if (cluster-&gt;list[i].s_addr == originator.s_addr)</a>
<a name="ln139">      return 1;</a>
<a name="ln140">  return 0;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">static unsigned int</a>
<a name="ln144">cluster_hash_key_make (void *p)</a>
<a name="ln145">{</a>
<a name="ln146">  const struct cluster_list *cluster = p;</a>
<a name="ln147"> </a>
<a name="ln148">  return jhash(cluster-&gt;list, cluster-&gt;length, 0);</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">static int</a>
<a name="ln152">cluster_hash_cmp (const void *p1, const void *p2)</a>
<a name="ln153">{</a>
<a name="ln154">  const struct cluster_list * cluster1 = p1;</a>
<a name="ln155">  const struct cluster_list * cluster2 = p2;</a>
<a name="ln156"> </a>
<a name="ln157">  return (cluster1-&gt;length == cluster2-&gt;length &amp;&amp;</a>
<a name="ln158">	  memcmp (cluster1-&gt;list, cluster2-&gt;list, cluster1-&gt;length) == 0);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">static void</a>
<a name="ln162">cluster_free (struct cluster_list *cluster)</a>
<a name="ln163">{</a>
<a name="ln164">  if (cluster-&gt;list)</a>
<a name="ln165">    XFREE (MTYPE_CLUSTER_VAL, cluster-&gt;list);</a>
<a name="ln166">  XFREE (MTYPE_CLUSTER, cluster);</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">#if 0</a>
<a name="ln170">static struct cluster_list *</a>
<a name="ln171">cluster_dup (struct cluster_list *cluster)</a>
<a name="ln172">{</a>
<a name="ln173">  struct cluster_list *new;</a>
<a name="ln174"> </a>
<a name="ln175">  new = XCALLOC (MTYPE_CLUSTER, sizeof (struct cluster_list));</a>
<a name="ln176">  new-&gt;length = cluster-&gt;length;</a>
<a name="ln177"> </a>
<a name="ln178">  if (cluster-&gt;length)</a>
<a name="ln179">    {</a>
<a name="ln180">      new-&gt;list = XMALLOC (MTYPE_CLUSTER_VAL, cluster-&gt;length);</a>
<a name="ln181">      memcpy (new-&gt;list, cluster-&gt;list, cluster-&gt;length);</a>
<a name="ln182">    }</a>
<a name="ln183">  else</a>
<a name="ln184">    new-&gt;list = NULL;</a>
<a name="ln185">  </a>
<a name="ln186">  return new;</a>
<a name="ln187">}</a>
<a name="ln188">#endif</a>
<a name="ln189"> </a>
<a name="ln190">static struct cluster_list *</a>
<a name="ln191">cluster_intern (struct cluster_list *cluster)</a>
<a name="ln192">{</a>
<a name="ln193">  struct cluster_list *find;</a>
<a name="ln194"> </a>
<a name="ln195">  find = hash_get (cluster_hash, cluster, cluster_hash_alloc);</a>
<a name="ln196">  find-&gt;refcnt++;</a>
<a name="ln197"> </a>
<a name="ln198">  return find;</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">void</a>
<a name="ln202">cluster_unintern (struct cluster_list **cluster)</a>
<a name="ln203">{</a>
<a name="ln204">  struct cluster_list *c = *cluster;</a>
<a name="ln205">  if (c-&gt;refcnt)</a>
<a name="ln206">    c-&gt;refcnt--;</a>
<a name="ln207"> </a>
<a name="ln208">  if (c-&gt;refcnt == 0)</a>
<a name="ln209">    {</a>
<a name="ln210">      hash_release (cluster_hash, c);</a>
<a name="ln211">      cluster_free (c);</a>
<a name="ln212">      *cluster = NULL;</a>
<a name="ln213">    }</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">static void</a>
<a name="ln217">cluster_init (void)</a>
<a name="ln218">{</a>
<a name="ln219">  cluster_hash = hash_create (cluster_hash_key_make, cluster_hash_cmp);</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">static void</a>
<a name="ln223">cluster_finish (void)</a>
<a name="ln224">{</a>
<a name="ln225">  hash_clean (cluster_hash, (void (*)(void *))cluster_free);</a>
<a name="ln226">  hash_free (cluster_hash);</a>
<a name="ln227">  cluster_hash = NULL;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">struct bgp_attr_encap_subtlv *</a>
<a name="ln231">encap_tlv_dup(struct bgp_attr_encap_subtlv *orig)</a>
<a name="ln232">{</a>
<a name="ln233">    struct bgp_attr_encap_subtlv *new;</a>
<a name="ln234">    struct bgp_attr_encap_subtlv *tail;</a>
<a name="ln235">    struct bgp_attr_encap_subtlv *p;</a>
<a name="ln236"> </a>
<a name="ln237">    for (p = orig, tail = new = NULL; p; p = p-&gt;next) {</a>
<a name="ln238">	int size = sizeof(struct bgp_attr_encap_subtlv) - 1 + p-&gt;length;</a>
<a name="ln239">	if (tail) {</a>
<a name="ln240">	    tail-&gt;next = XCALLOC(MTYPE_ENCAP_TLV, size);</a>
<a name="ln241">	    tail = tail-&gt;next;</a>
<a name="ln242">	} else {</a>
<a name="ln243">	    tail = new = XCALLOC(MTYPE_ENCAP_TLV, size);</a>
<a name="ln244">	}</a>
<a name="ln245">	assert(tail);</a>
<a name="ln246">	memcpy(tail, p, size);</a>
<a name="ln247">	tail-&gt;next = NULL;</a>
<a name="ln248">    }</a>
<a name="ln249"> </a>
<a name="ln250">    return new;</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">static void</a>
<a name="ln254">encap_free(struct bgp_attr_encap_subtlv *p)</a>
<a name="ln255">{</a>
<a name="ln256">    struct bgp_attr_encap_subtlv *next;</a>
<a name="ln257">    while (p) {</a>
<a name="ln258">        next    = p-&gt;next;</a>
<a name="ln259">        p-&gt;next = NULL;</a>
<a name="ln260">        XFREE(MTYPE_ENCAP_TLV, p);</a>
<a name="ln261">        p       = next;</a>
<a name="ln262">    }</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">void</a>
<a name="ln266">bgp_attr_flush_encap(struct attr *attr)</a>
<a name="ln267">{</a>
<a name="ln268">    if (!attr || !attr-&gt;extra)</a>
<a name="ln269">	return;</a>
<a name="ln270"> </a>
<a name="ln271">    if (attr-&gt;extra-&gt;encap_subtlvs) {</a>
<a name="ln272">	encap_free(attr-&gt;extra-&gt;encap_subtlvs);</a>
<a name="ln273">	attr-&gt;extra-&gt;encap_subtlvs = NULL;</a>
<a name="ln274">    }</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">/*</a>
<a name="ln278"> * Compare encap sub-tlv chains</a>
<a name="ln279"> *</a>
<a name="ln280"> *	1 = equivalent</a>
<a name="ln281"> *	0 = not equivalent</a>
<a name="ln282"> *</a>
<a name="ln283"> * This algorithm could be made faster if needed</a>
<a name="ln284"> */</a>
<a name="ln285">static int</a>
<a name="ln286">encap_same(struct bgp_attr_encap_subtlv *h1, struct bgp_attr_encap_subtlv *h2)</a>
<a name="ln287">{</a>
<a name="ln288">    struct bgp_attr_encap_subtlv *p;</a>
<a name="ln289">    struct bgp_attr_encap_subtlv *q;</a>
<a name="ln290"> </a>
<a name="ln291">    if (!h1 &amp;&amp; !h2)</a>
<a name="ln292">	return 1;</a>
<a name="ln293">    if (h1 &amp;&amp; !h2)</a>
<a name="ln294">	return 0;</a>
<a name="ln295">    if (!h1 &amp;&amp; h2)</a>
<a name="ln296">	return 0;</a>
<a name="ln297">    if (h1 == h2)</a>
<a name="ln298">	return 1;</a>
<a name="ln299"> </a>
<a name="ln300">    for (p = h1; p; p = p-&gt;next) {</a>
<a name="ln301">	for (q = h2; q; q = q-&gt;next) {</a>
<a name="ln302">	    if ((p-&gt;type == q-&gt;type) &amp;&amp;</a>
<a name="ln303">		(p-&gt;length == q-&gt;length) &amp;&amp;</a>
<a name="ln304">		!memcmp(p-&gt;value, q-&gt;value, p-&gt;length)) {</a>
<a name="ln305"> </a>
<a name="ln306">		break;</a>
<a name="ln307">	    }</a>
<a name="ln308">	}</a>
<a name="ln309">	if (!q)</a>
<a name="ln310">	    return 0;</a>
<a name="ln311">    }</a>
<a name="ln312"> </a>
<a name="ln313">    for (p = h2; p; p = p-&gt;next) {</a>
<a name="ln314">	for (q = h1; q; q = q-&gt;next) {</a>
<a name="ln315">	    if ((p-&gt;type == q-&gt;type) &amp;&amp;</a>
<a name="ln316">		(p-&gt;length == q-&gt;length) &amp;&amp;</a>
<a name="ln317">		!memcmp(p-&gt;value, q-&gt;value, p-&gt;length)) {</a>
<a name="ln318"> </a>
<a name="ln319">		break;</a>
<a name="ln320">	    }</a>
<a name="ln321">	}</a>
<a name="ln322">	if (!q)</a>
<a name="ln323">	    return 0;</a>
<a name="ln324">    }</a>
<a name="ln325"> </a>
<a name="ln326">    return 1;</a>
<a name="ln327">}</a>
<a name="ln328"> </a>
<a name="ln329">/* Unknown transit attribute. */</a>
<a name="ln330">static struct hash *transit_hash;</a>
<a name="ln331"> </a>
<a name="ln332">static void</a>
<a name="ln333">transit_free (struct transit *transit)</a>
<a name="ln334">{</a>
<a name="ln335">  if (transit-&gt;val)</a>
<a name="ln336">    XFREE (MTYPE_TRANSIT_VAL, transit-&gt;val);</a>
<a name="ln337">  XFREE (MTYPE_TRANSIT, transit);</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340"> </a>
<a name="ln341">static void *</a>
<a name="ln342">transit_hash_alloc (void *p)</a>
<a name="ln343">{</a>
<a name="ln344">  /* Transit structure is already allocated.  */</a>
<a name="ln345">  return p;</a>
<a name="ln346">}</a>
<a name="ln347"> </a>
<a name="ln348">static struct transit *</a>
<a name="ln349">transit_intern (struct transit *transit)</a>
<a name="ln350">{</a>
<a name="ln351">  struct transit *find;</a>
<a name="ln352"> </a>
<a name="ln353">  find = hash_get (transit_hash, transit, transit_hash_alloc);</a>
<a name="ln354">  if (find != transit)</a>
<a name="ln355">    transit_free (transit);</a>
<a name="ln356">  find-&gt;refcnt++;</a>
<a name="ln357"> </a>
<a name="ln358">  return find;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">void</a>
<a name="ln362">transit_unintern (struct transit **transit)</a>
<a name="ln363">{</a>
<a name="ln364">  struct transit *t = *transit;</a>
<a name="ln365">  </a>
<a name="ln366">  if (t-&gt;refcnt)</a>
<a name="ln367">    t-&gt;refcnt--;</a>
<a name="ln368"> </a>
<a name="ln369">  if (t-&gt;refcnt == 0)</a>
<a name="ln370">    {</a>
<a name="ln371">      hash_release (transit_hash, t);</a>
<a name="ln372">      transit_free (t);</a>
<a name="ln373">      *transit = NULL;</a>
<a name="ln374">    }</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">static unsigned int</a>
<a name="ln378">transit_hash_key_make (void *p)</a>
<a name="ln379">{</a>
<a name="ln380">  const struct transit * transit = p;</a>
<a name="ln381"> </a>
<a name="ln382">  return jhash(transit-&gt;val, transit-&gt;length, 0);</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">static int</a>
<a name="ln386">transit_hash_cmp (const void *p1, const void *p2)</a>
<a name="ln387">{</a>
<a name="ln388">  const struct transit * transit1 = p1;</a>
<a name="ln389">  const struct transit * transit2 = p2;</a>
<a name="ln390"> </a>
<a name="ln391">  return (transit1-&gt;length == transit2-&gt;length &amp;&amp;</a>
<a name="ln392">	  memcmp (transit1-&gt;val, transit2-&gt;val, transit1-&gt;length) == 0);</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">static void</a>
<a name="ln396">transit_init (void)</a>
<a name="ln397">{</a>
<a name="ln398">  transit_hash = hash_create (transit_hash_key_make, transit_hash_cmp);</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">static void</a>
<a name="ln402">transit_finish (void)</a>
<a name="ln403">{</a>
<a name="ln404">  hash_clean (transit_hash, (void (*)(void *))transit_free);</a>
<a name="ln405">  hash_free (transit_hash);</a>
<a name="ln406">  transit_hash = NULL;</a>
<a name="ln407">}</a>
<a name="ln408"> </a>
<a name="ln409">/* Attribute hash routines. */</a>
<a name="ln410">static struct hash *attrhash;</a>
<a name="ln411"> </a>
<a name="ln412">static struct attr_extra *</a>
<a name="ln413">bgp_attr_extra_new (void)</a>
<a name="ln414">{</a>
<a name="ln415">  return XCALLOC (MTYPE_ATTR_EXTRA, sizeof (struct attr_extra));</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">void</a>
<a name="ln419">bgp_attr_extra_free (struct attr *attr)</a>
<a name="ln420">{</a>
<a name="ln421">  if (attr-&gt;extra)</a>
<a name="ln422">    {</a>
<a name="ln423">      if (attr-&gt;extra-&gt;encap_subtlvs) {</a>
<a name="ln424">	encap_free(attr-&gt;extra-&gt;encap_subtlvs);</a>
<a name="ln425">	attr-&gt;extra-&gt;encap_subtlvs = NULL;</a>
<a name="ln426">      }</a>
<a name="ln427">      XFREE (MTYPE_ATTR_EXTRA, attr-&gt;extra);</a>
<a name="ln428">      attr-&gt;extra = NULL;</a>
<a name="ln429">    }</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432">struct attr_extra *</a>
<a name="ln433">bgp_attr_extra_get (struct attr *attr)</a>
<a name="ln434">{</a>
<a name="ln435">  if (!attr-&gt;extra)</a>
<a name="ln436">    attr-&gt;extra = bgp_attr_extra_new();</a>
<a name="ln437">  return attr-&gt;extra;</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">/* Shallow copy of an attribute</a>
<a name="ln441"> * Though, not so shallow that it doesn't copy the contents</a>
<a name="ln442"> * of the attr_extra pointed to by 'extra'</a>
<a name="ln443"> */</a>
<a name="ln444">void</a>
<a name="ln445">bgp_attr_dup (struct attr *new, struct attr *orig)</a>
<a name="ln446">{</a>
<a name="ln447">  struct attr_extra *extra = new-&gt;extra;</a>
<a name="ln448"> </a>
<a name="ln449">  *new = *orig;</a>
<a name="ln450">  /* if caller provided attr_extra space, use it in any case.</a>
<a name="ln451">   *</a>
<a name="ln452">   * This is neccesary even if orig-&gt;extra equals NULL, because otherwise</a>
<a name="ln453">   * memory may be later allocated on the heap by bgp_attr_extra_get.</a>
<a name="ln454">   *</a>
<a name="ln455">   * That memory would eventually be leaked, because the caller must not</a>
<a name="ln456">   * call bgp_attr_extra_free if he provided attr_extra on the stack.</a>
<a name="ln457">   */</a>
<a name="ln458">  if (extra)</a>
<a name="ln459">    {</a>
<a name="ln460">      new-&gt;extra = extra;</a>
<a name="ln461">      memset(new-&gt;extra, 0, sizeof(struct attr_extra));</a>
<a name="ln462">      if (orig-&gt;extra) {</a>
<a name="ln463">        *new-&gt;extra = *orig-&gt;extra;</a>
<a name="ln464">        if (orig-&gt;extra-&gt;encap_subtlvs) {</a>
<a name="ln465">          new-&gt;extra-&gt;encap_subtlvs = encap_tlv_dup(orig-&gt;extra-&gt;encap_subtlvs);</a>
<a name="ln466">        }</a>
<a name="ln467">      }</a>
<a name="ln468">    }</a>
<a name="ln469">  else if (orig-&gt;extra)</a>
<a name="ln470">    {</a>
<a name="ln471">      new-&gt;extra = bgp_attr_extra_new();</a>
<a name="ln472">      *new-&gt;extra = *orig-&gt;extra;</a>
<a name="ln473">      if (orig-&gt;extra-&gt;encap_subtlvs) {</a>
<a name="ln474">	new-&gt;extra-&gt;encap_subtlvs = encap_tlv_dup(orig-&gt;extra-&gt;encap_subtlvs);</a>
<a name="ln475">      }</a>
<a name="ln476">    }</a>
<a name="ln477">}</a>
<a name="ln478"> </a>
<a name="ln479">unsigned long int</a>
<a name="ln480">attr_count (void)</a>
<a name="ln481">{</a>
<a name="ln482">  return attrhash-&gt;count;</a>
<a name="ln483">}</a>
<a name="ln484"> </a>
<a name="ln485">unsigned long int</a>
<a name="ln486">attr_unknown_count (void)</a>
<a name="ln487">{</a>
<a name="ln488">  return transit_hash-&gt;count;</a>
<a name="ln489">}</a>
<a name="ln490"> </a>
<a name="ln491">unsigned int</a>
<a name="ln492">attrhash_key_make (void *p)</a>
<a name="ln493">{</a>
<a name="ln494">  const struct attr *attr = (struct attr *) p;</a>
<a name="ln495">  const struct attr_extra *extra = attr-&gt;extra;</a>
<a name="ln496">  uint32_t key = 0;</a>
<a name="ln497">#define MIX(val)	key = jhash_1word(val, key)</a>
<a name="ln498"> </a>
<a name="ln499">  MIX(attr-&gt;origin);</a>
<a name="ln500">  MIX(attr-&gt;nexthop.s_addr);</a>
<a name="ln501">  MIX(attr-&gt;med);</a>
<a name="ln502">  MIX(attr-&gt;local_pref);</a>
<a name="ln503"> </a>
<a name="ln504">  key += attr-&gt;origin;</a>
<a name="ln505">  key += attr-&gt;nexthop.s_addr;</a>
<a name="ln506">  key += attr-&gt;med;</a>
<a name="ln507">  key += attr-&gt;local_pref;</a>
<a name="ln508">  </a>
<a name="ln509">  if (extra)</a>
<a name="ln510">    {</a>
<a name="ln511">      MIX(extra-&gt;aggregator_as);</a>
<a name="ln512">      MIX(extra-&gt;aggregator_addr.s_addr);</a>
<a name="ln513">      MIX(extra-&gt;weight);</a>
<a name="ln514">      MIX(extra-&gt;mp_nexthop_global_in.s_addr);</a>
<a name="ln515">      MIX(extra-&gt;originator_id.s_addr);</a>
<a name="ln516">      MIX(extra-&gt;tag);</a>
<a name="ln517">    }</a>
<a name="ln518">  </a>
<a name="ln519">  if (attr-&gt;aspath)</a>
<a name="ln520">    MIX(aspath_key_make (attr-&gt;aspath));</a>
<a name="ln521">  if (attr-&gt;community)</a>
<a name="ln522">    MIX(community_hash_make (attr-&gt;community));</a>
<a name="ln523">  </a>
<a name="ln524">  if (extra)</a>
<a name="ln525">    {</a>
<a name="ln526">      if (extra-&gt;lcommunity)</a>
<a name="ln527">	MIX(lcommunity_hash_make (extra-&gt;lcommunity));</a>
<a name="ln528">      if (extra-&gt;ecommunity)</a>
<a name="ln529">        MIX(ecommunity_hash_make (extra-&gt;ecommunity));</a>
<a name="ln530">      if (extra-&gt;cluster)</a>
<a name="ln531">        MIX(cluster_hash_key_make (extra-&gt;cluster));</a>
<a name="ln532">      if (extra-&gt;transit)</a>
<a name="ln533">        MIX(transit_hash_key_make (extra-&gt;transit));</a>
<a name="ln534"> </a>
<a name="ln535">      MIX(extra-&gt;mp_nexthop_len);</a>
<a name="ln536">      key = jhash(extra-&gt;mp_nexthop_global.s6_addr, 16, key);</a>
<a name="ln537">      key = jhash(extra-&gt;mp_nexthop_local.s6_addr, 16, key);</a>
<a name="ln538">    }</a>
<a name="ln539"> </a>
<a name="ln540">  return key;</a>
<a name="ln541">}</a>
<a name="ln542"> </a>
<a name="ln543">int</a>
<a name="ln544">attrhash_cmp (const void *p1, const void *p2)</a>
<a name="ln545">{</a>
<a name="ln546">  const struct attr * attr1 = p1;</a>
<a name="ln547">  const struct attr * attr2 = p2;</a>
<a name="ln548"> </a>
<a name="ln549">  if (attr1-&gt;flag == attr2-&gt;flag</a>
<a name="ln550">      &amp;&amp; attr1-&gt;origin == attr2-&gt;origin</a>
<a name="ln551">      &amp;&amp; attr1-&gt;nexthop.s_addr == attr2-&gt;nexthop.s_addr</a>
<a name="ln552">      &amp;&amp; attr1-&gt;aspath == attr2-&gt;aspath</a>
<a name="ln553">      &amp;&amp; attr1-&gt;community == attr2-&gt;community</a>
<a name="ln554">      &amp;&amp; attr1-&gt;med == attr2-&gt;med</a>
<a name="ln555">      &amp;&amp; attr1-&gt;local_pref == attr2-&gt;local_pref)</a>
<a name="ln556">    {</a>
<a name="ln557">      const struct attr_extra *ae1 = attr1-&gt;extra;</a>
<a name="ln558">      const struct attr_extra *ae2 = attr2-&gt;extra;</a>
<a name="ln559">      </a>
<a name="ln560">      if (ae1 &amp;&amp; ae2</a>
<a name="ln561">          &amp;&amp; ae1-&gt;aggregator_as == ae2-&gt;aggregator_as</a>
<a name="ln562">          &amp;&amp; ae1-&gt;aggregator_addr.s_addr == ae2-&gt;aggregator_addr.s_addr</a>
<a name="ln563">          &amp;&amp; ae1-&gt;weight == ae2-&gt;weight</a>
<a name="ln564">          &amp;&amp; ae1-&gt;tag == ae2-&gt;tag</a>
<a name="ln565">          &amp;&amp; ae1-&gt;mp_nexthop_len == ae2-&gt;mp_nexthop_len</a>
<a name="ln566">          &amp;&amp; IPV6_ADDR_SAME (&amp;ae1-&gt;mp_nexthop_global, &amp;ae2-&gt;mp_nexthop_global)</a>
<a name="ln567">          &amp;&amp; IPV6_ADDR_SAME (&amp;ae1-&gt;mp_nexthop_local, &amp;ae2-&gt;mp_nexthop_local)</a>
<a name="ln568">          &amp;&amp; IPV4_ADDR_SAME (&amp;ae1-&gt;mp_nexthop_global_in, &amp;ae2-&gt;mp_nexthop_global_in)</a>
<a name="ln569">          &amp;&amp; ae1-&gt;ecommunity == ae2-&gt;ecommunity</a>
<a name="ln570">	  &amp;&amp; ae1-&gt;lcommunity == ae2-&gt;lcommunity</a>
<a name="ln571">          &amp;&amp; ae1-&gt;cluster == ae2-&gt;cluster</a>
<a name="ln572">          &amp;&amp; ae1-&gt;transit == ae2-&gt;transit</a>
<a name="ln573">	  &amp;&amp; (ae1-&gt;encap_tunneltype == ae2-&gt;encap_tunneltype)</a>
<a name="ln574">	  &amp;&amp; encap_same(ae1-&gt;encap_subtlvs, ae2-&gt;encap_subtlvs)</a>
<a name="ln575">          &amp;&amp; IPV4_ADDR_SAME (&amp;ae1-&gt;originator_id, &amp;ae2-&gt;originator_id))</a>
<a name="ln576">        return 1;</a>
<a name="ln577">      else if (ae1 || ae2)</a>
<a name="ln578">        return 0;</a>
<a name="ln579">      /* neither attribute has extra attributes, so they're same */</a>
<a name="ln580">      return 1;</a>
<a name="ln581">    }</a>
<a name="ln582">  else</a>
<a name="ln583">    return 0;</a>
<a name="ln584">}</a>
<a name="ln585"> </a>
<a name="ln586">static void</a>
<a name="ln587">attrhash_init (void)</a>
<a name="ln588">{</a>
<a name="ln589">  attrhash = hash_create (attrhash_key_make, attrhash_cmp);</a>
<a name="ln590">}</a>
<a name="ln591"> </a>
<a name="ln592">/*</a>
<a name="ln593"> * special for hash_clean below</a>
<a name="ln594"> */</a>
<a name="ln595">static void</a>
<a name="ln596">attr_vfree (void *attr)</a>
<a name="ln597">{</a>
<a name="ln598">  bgp_attr_extra_free ((struct attr *)attr);</a>
<a name="ln599">  XFREE (MTYPE_ATTR, attr);</a>
<a name="ln600">}</a>
<a name="ln601"> </a>
<a name="ln602">static void</a>
<a name="ln603">attrhash_finish (void)</a>
<a name="ln604">{</a>
<a name="ln605">  hash_clean(attrhash, attr_vfree);</a>
<a name="ln606">  hash_free (attrhash);</a>
<a name="ln607">  attrhash = NULL;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">static void</a>
<a name="ln611">attr_show_all_iterator (struct hash_backet *backet, struct vty *vty)</a>
<a name="ln612">{</a>
<a name="ln613">  struct attr *attr = backet-&gt;data;</a>
<a name="ln614"> </a>
<a name="ln615">  vty_out (vty, &quot;attr[%ld] nexthop %s%s&quot;, attr-&gt;refcnt, </a>
<a name="ln616">	   inet_ntoa (attr-&gt;nexthop), VTY_NEWLINE);</a>
<a name="ln617">}</a>
<a name="ln618"> </a>
<a name="ln619">void</a>
<a name="ln620">attr_show_all (struct vty *vty)</a>
<a name="ln621">{</a>
<a name="ln622">  hash_iterate (attrhash, </a>
<a name="ln623">		(void (*)(struct hash_backet *, void *))</a>
<a name="ln624">		attr_show_all_iterator,</a>
<a name="ln625">		vty);</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">static void *</a>
<a name="ln629">bgp_attr_hash_alloc (void *p)</a>
<a name="ln630">{</a>
<a name="ln631">  struct attr * val = (struct attr *) p;</a>
<a name="ln632">  struct attr *attr;</a>
<a name="ln633"> </a>
<a name="ln634">  attr = XMALLOC (MTYPE_ATTR, sizeof (struct attr));</a>
<a name="ln635">  *attr = *val;</a>
<a name="ln636">  if (val-&gt;extra)</a>
<a name="ln637">    {</a>
<a name="ln638">      attr-&gt;extra = bgp_attr_extra_new ();</a>
<a name="ln639">      *attr-&gt;extra = *val-&gt;extra;</a>
<a name="ln640"> </a>
<a name="ln641">      if (attr-&gt;extra-&gt;encap_subtlvs) {</a>
<a name="ln642">	attr-&gt;extra-&gt;encap_subtlvs = encap_tlv_dup(attr-&gt;extra-&gt;encap_subtlvs);</a>
<a name="ln643">      }</a>
<a name="ln644">    }</a>
<a name="ln645">  attr-&gt;refcnt = 0;</a>
<a name="ln646">  return attr;</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">/* Internet argument attribute. */</a>
<a name="ln650">struct attr *</a>
<a name="ln651">bgp_attr_intern (struct attr *attr)</a>
<a name="ln652">{</a>
<a name="ln653">  struct attr *find;</a>
<a name="ln654"> </a>
<a name="ln655">  /* Intern referenced strucutre. */</a>
<a name="ln656">  if (attr-&gt;aspath)</a>
<a name="ln657">    {</a>
<a name="ln658">      if (! attr-&gt;aspath-&gt;refcnt)</a>
<a name="ln659">	attr-&gt;aspath = aspath_intern (attr-&gt;aspath);</a>
<a name="ln660">      else</a>
<a name="ln661">	attr-&gt;aspath-&gt;refcnt++;</a>
<a name="ln662">    }</a>
<a name="ln663">  if (attr-&gt;community)</a>
<a name="ln664">    {</a>
<a name="ln665">      if (! attr-&gt;community-&gt;refcnt)</a>
<a name="ln666">	attr-&gt;community = community_intern (attr-&gt;community);</a>
<a name="ln667">      else</a>
<a name="ln668">	attr-&gt;community-&gt;refcnt++;</a>
<a name="ln669">    }</a>
<a name="ln670">  if (attr-&gt;extra)</a>
<a name="ln671">    {</a>
<a name="ln672">      struct attr_extra *attre = attr-&gt;extra;</a>
<a name="ln673">      </a>
<a name="ln674">      if (attre-&gt;ecommunity)</a>
<a name="ln675">        {</a>
<a name="ln676">          if (! attre-&gt;ecommunity-&gt;refcnt)</a>
<a name="ln677">            attre-&gt;ecommunity = ecommunity_intern (attre-&gt;ecommunity);</a>
<a name="ln678">          else</a>
<a name="ln679">            attre-&gt;ecommunity-&gt;refcnt++;</a>
<a name="ln680">          </a>
<a name="ln681">        }</a>
<a name="ln682">      if (attre-&gt;lcommunity)</a>
<a name="ln683">        {</a>
<a name="ln684">          if (! attre-&gt;lcommunity-&gt;refcnt)</a>
<a name="ln685">            attre-&gt;lcommunity = lcommunity_intern (attre-&gt;lcommunity);</a>
<a name="ln686">          else</a>
<a name="ln687">            attre-&gt;lcommunity-&gt;refcnt++;</a>
<a name="ln688">        }</a>
<a name="ln689">      if (attre-&gt;cluster)</a>
<a name="ln690">        {</a>
<a name="ln691">          if (! attre-&gt;cluster-&gt;refcnt)</a>
<a name="ln692">            attre-&gt;cluster = cluster_intern (attre-&gt;cluster);</a>
<a name="ln693">          else</a>
<a name="ln694">            attre-&gt;cluster-&gt;refcnt++;</a>
<a name="ln695">        }</a>
<a name="ln696">      if (attre-&gt;transit)</a>
<a name="ln697">        {</a>
<a name="ln698">          if (! attre-&gt;transit-&gt;refcnt)</a>
<a name="ln699">            attre-&gt;transit = transit_intern (attre-&gt;transit);</a>
<a name="ln700">          else</a>
<a name="ln701">            attre-&gt;transit-&gt;refcnt++;</a>
<a name="ln702">        }</a>
<a name="ln703">    }</a>
<a name="ln704">  </a>
<a name="ln705">  find = (struct attr *) hash_get (attrhash, attr, bgp_attr_hash_alloc);</a>
<a name="ln706">  find-&gt;refcnt++;</a>
<a name="ln707">  </a>
<a name="ln708">  return find;</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711"> </a>
<a name="ln712">/* Make network statement's attribute. */</a>
<a name="ln713">struct attr *</a>
<a name="ln714">bgp_attr_default_set (struct attr *attr, u_char origin)</a>
<a name="ln715">{</a>
<a name="ln716">  memset (attr, 0, sizeof (struct attr));</a>
<a name="ln717">  bgp_attr_extra_get (attr);</a>
<a name="ln718">  </a>
<a name="ln719">  attr-&gt;origin = origin;</a>
<a name="ln720">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);</a>
<a name="ln721">  attr-&gt;aspath = aspath_empty ();</a>
<a name="ln722">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);</a>
<a name="ln723">  attr-&gt;extra-&gt;weight = BGP_ATTR_DEFAULT_WEIGHT;</a>
<a name="ln724">  attr-&gt;extra-&gt;tag = 0;</a>
<a name="ln725">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);</a>
<a name="ln726">  attr-&gt;extra-&gt;mp_nexthop_len = IPV6_MAX_BYTELEN;</a>
<a name="ln727"> </a>
<a name="ln728">  return attr;</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731"> </a>
<a name="ln732">/* Make network statement's attribute. */</a>
<a name="ln733">struct attr *</a>
<a name="ln734">bgp_attr_default_intern (u_char origin)</a>
<a name="ln735">{</a>
<a name="ln736">  struct attr attr;</a>
<a name="ln737">  struct attr *new;</a>
<a name="ln738"> </a>
<a name="ln739">  memset (&amp;attr, 0, sizeof (struct attr));</a>
<a name="ln740">  bgp_attr_extra_get (&amp;attr);</a>
<a name="ln741"> </a>
<a name="ln742">  bgp_attr_default_set(&amp;attr, origin);</a>
<a name="ln743"> </a>
<a name="ln744">  new = bgp_attr_intern (&amp;attr);</a>
<a name="ln745">  bgp_attr_extra_free (&amp;attr);</a>
<a name="ln746">  </a>
<a name="ln747">  aspath_unintern (&amp;new-&gt;aspath);</a>
<a name="ln748">  return new;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">/* Create the attributes for an aggregate */</a>
<a name="ln752">struct attr *</a>
<a name="ln753">bgp_attr_aggregate_intern (struct bgp *bgp, u_char origin,</a>
<a name="ln754">			   struct aspath *aspath,</a>
<a name="ln755">			   struct community *community, int as_set,</a>
<a name="ln756">			   u_char atomic_aggregate)</a>
<a name="ln757">{</a>
<a name="ln758">  struct attr attr;</a>
<a name="ln759">  struct attr *new;</a>
<a name="ln760">  struct attr_extra attre;</a>
<a name="ln761"> </a>
<a name="ln762">  memset (&amp;attr, 0, sizeof (struct attr));</a>
<a name="ln763">  memset (&amp;attre, 0, sizeof (struct attr_extra));</a>
<a name="ln764">  attr.extra = &amp;attre;</a>
<a name="ln765"> </a>
<a name="ln766">  /* Origin attribute. */</a>
<a name="ln767">  attr.origin = origin;</a>
<a name="ln768">  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);</a>
<a name="ln769"> </a>
<a name="ln770">  /* AS path attribute. */</a>
<a name="ln771">  if (aspath)</a>
<a name="ln772">    attr.aspath = aspath_intern (aspath);</a>
<a name="ln773">  else</a>
<a name="ln774">    attr.aspath = aspath_empty ();</a>
<a name="ln775">  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);</a>
<a name="ln776"> </a>
<a name="ln777">  /* Next hop attribute.  */</a>
<a name="ln778">  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);</a>
<a name="ln779"> </a>
<a name="ln780">  if (community)</a>
<a name="ln781">    {</a>
<a name="ln782">      attr.community = community;</a>
<a name="ln783">      attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);</a>
<a name="ln784">    }</a>
<a name="ln785"> </a>
<a name="ln786">  attre.weight = BGP_ATTR_DEFAULT_WEIGHT;</a>
<a name="ln787">  attre.mp_nexthop_len = IPV6_MAX_BYTELEN;</a>
<a name="ln788"> </a>
<a name="ln789">  if (! as_set || atomic_aggregate)</a>
<a name="ln790">    attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);</a>
<a name="ln791">  attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR);</a>
<a name="ln792">  if (CHECK_FLAG (bgp-&gt;config, BGP_CONFIG_CONFEDERATION))</a>
<a name="ln793">    attre.aggregator_as = bgp-&gt;confed_id;</a>
<a name="ln794">  else</a>
<a name="ln795">    attre.aggregator_as = bgp-&gt;as;</a>
<a name="ln796">  attre.aggregator_addr = bgp-&gt;router_id;</a>
<a name="ln797"> </a>
<a name="ln798">  new = bgp_attr_intern (&amp;attr);</a>
<a name="ln799"> </a>
<a name="ln800">  aspath_unintern (&amp;new-&gt;aspath);</a>
<a name="ln801">  return new;</a>
<a name="ln802">}</a>
<a name="ln803"> </a>
<a name="ln804">/* Unintern just the sub-components of the attr, but not the attr */</a>
<a name="ln805">void</a>
<a name="ln806">bgp_attr_unintern_sub (struct attr *attr)</a>
<a name="ln807">{</a>
<a name="ln808">  /* aspath refcount shoud be decrement. */</a>
<a name="ln809">  if (attr-&gt;aspath)</a>
<a name="ln810">    aspath_unintern (&amp;attr-&gt;aspath);</a>
<a name="ln811">  UNSET_FLAG(attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_AS_PATH));</a>
<a name="ln812">  </a>
<a name="ln813">  if (attr-&gt;community)</a>
<a name="ln814">    community_unintern (&amp;attr-&gt;community);</a>
<a name="ln815">  UNSET_FLAG(attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES));</a>
<a name="ln816">  </a>
<a name="ln817">  if (attr-&gt;extra)</a>
<a name="ln818">    {</a>
<a name="ln819">      if (attr-&gt;extra-&gt;ecommunity)</a>
<a name="ln820">        ecommunity_unintern (&amp;attr-&gt;extra-&gt;ecommunity);</a>
<a name="ln821">      UNSET_FLAG(attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES));</a>
<a name="ln822"> </a>
<a name="ln823">      if (attr-&gt;extra-&gt;lcommunity)</a>
<a name="ln824">        lcommunity_unintern (&amp;attr-&gt;extra-&gt;lcommunity);</a>
<a name="ln825">      UNSET_FLAG(attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_LARGE_COMMUNITIES));</a>
<a name="ln826">      </a>
<a name="ln827">      if (attr-&gt;extra-&gt;cluster)</a>
<a name="ln828">        cluster_unintern (&amp;attr-&gt;extra-&gt;cluster);</a>
<a name="ln829">      UNSET_FLAG(attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_CLUSTER_LIST));</a>
<a name="ln830">      </a>
<a name="ln831">      if (attr-&gt;extra-&gt;transit)</a>
<a name="ln832">        transit_unintern (&amp;attr-&gt;extra-&gt;transit);</a>
<a name="ln833">    }</a>
<a name="ln834">}</a>
<a name="ln835"> </a>
<a name="ln836">/* Free bgp attribute and aspath. */</a>
<a name="ln837">void</a>
<a name="ln838">bgp_attr_unintern (struct attr **pattr)</a>
<a name="ln839">{</a>
<a name="ln840">  struct attr *attr = *pattr;</a>
<a name="ln841">  struct attr *ret;</a>
<a name="ln842">  struct attr tmp;</a>
<a name="ln843">  struct attr_extra tmp_extra;</a>
<a name="ln844">  </a>
<a name="ln845">  /* Decrement attribute reference. */</a>
<a name="ln846">  attr-&gt;refcnt--;</a>
<a name="ln847">  </a>
<a name="ln848">  tmp = *attr;</a>
<a name="ln849">  </a>
<a name="ln850">  if (attr-&gt;extra)</a>
<a name="ln851">    {</a>
<a name="ln852">      tmp.extra = &amp;tmp_extra;</a>
<a name="ln853">      memcpy (tmp.extra, attr-&gt;extra, sizeof (struct attr_extra));</a>
<a name="ln854">    }</a>
<a name="ln855">  </a>
<a name="ln856">  /* If reference becomes zero then free attribute object. */</a>
<a name="ln857">  if (attr-&gt;refcnt == 0)</a>
<a name="ln858">    {</a>
<a name="ln859">      ret = hash_release (attrhash, attr);</a>
<a name="ln860">      assert (ret != NULL);</a>
<a name="ln861">      bgp_attr_extra_free (attr);</a>
<a name="ln862">      XFREE (MTYPE_ATTR, attr);</a>
<a name="ln863">      *pattr = NULL;</a>
<a name="ln864">    }</a>
<a name="ln865"> </a>
<a name="ln866">  bgp_attr_unintern_sub (&amp;tmp);</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">void</a>
<a name="ln870">bgp_attr_flush (struct attr *attr)</a>
<a name="ln871">{</a>
<a name="ln872">  if (attr-&gt;aspath &amp;&amp; ! attr-&gt;aspath-&gt;refcnt)</a>
<a name="ln873">    {</a>
<a name="ln874">      aspath_free (attr-&gt;aspath);</a>
<a name="ln875">      attr-&gt;aspath = NULL;</a>
<a name="ln876">    }</a>
<a name="ln877">  if (attr-&gt;community &amp;&amp; ! attr-&gt;community-&gt;refcnt)</a>
<a name="ln878">    {</a>
<a name="ln879">      community_free (attr-&gt;community);</a>
<a name="ln880">      attr-&gt;community = NULL;</a>
<a name="ln881">    }</a>
<a name="ln882">  if (attr-&gt;extra)</a>
<a name="ln883">    {</a>
<a name="ln884">      struct attr_extra *attre = attr-&gt;extra;</a>
<a name="ln885"> </a>
<a name="ln886">      if (attre-&gt;ecommunity &amp;&amp; ! attre-&gt;ecommunity-&gt;refcnt)</a>
<a name="ln887">        ecommunity_free (&amp;attre-&gt;ecommunity);</a>
<a name="ln888">      if (attre-&gt;lcommunity &amp;&amp; ! attre-&gt;lcommunity-&gt;refcnt)</a>
<a name="ln889">	lcommunity_free (&amp;attre-&gt;lcommunity);</a>
<a name="ln890">      if (attre-&gt;cluster &amp;&amp; ! attre-&gt;cluster-&gt;refcnt)</a>
<a name="ln891">        {</a>
<a name="ln892">          cluster_free (attre-&gt;cluster);</a>
<a name="ln893">          attre-&gt;cluster = NULL;</a>
<a name="ln894">        }</a>
<a name="ln895">      if (attre-&gt;transit &amp;&amp; ! attre-&gt;transit-&gt;refcnt)</a>
<a name="ln896">        {</a>
<a name="ln897">          transit_free (attre-&gt;transit);</a>
<a name="ln898">          attre-&gt;transit = NULL;</a>
<a name="ln899">        }</a>
<a name="ln900">      encap_free(attre-&gt;encap_subtlvs);</a>
<a name="ln901">      attre-&gt;encap_subtlvs = NULL;</a>
<a name="ln902">    }</a>
<a name="ln903">}</a>
<a name="ln904"> </a>
<a name="ln905">/* Implement some draft-ietf-idr-error-handling behaviour and</a>
<a name="ln906"> * avoid resetting sessions for malformed attributes which are</a>
<a name="ln907"> * are partial/optional and hence where the error likely was not</a>
<a name="ln908"> * introduced by the sending neighbour.</a>
<a name="ln909"> */</a>
<a name="ln910">static bgp_attr_parse_ret_t</a>
<a name="ln911">bgp_attr_malformed (struct bgp_attr_parser_args *args, u_char subcode,</a>
<a name="ln912">                    bgp_size_t length)</a>
<a name="ln913">{</a>
<a name="ln914">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln915">  const u_int8_t flags = args-&gt;flags;</a>
<a name="ln916">  /* startp and length must be special-cased, as whether or not to</a>
<a name="ln917">   * send the attribute data with the NOTIFY depends on the error,</a>
<a name="ln918">   * the caller therefore signals this with the seperate length argument</a>
<a name="ln919">   */</a>
<a name="ln920">  u_char *notify_datap = (length &gt; 0 ? args-&gt;startp : NULL);</a>
<a name="ln921">  </a>
<a name="ln922">  /* The malformed attribute shouldn't be passed on, should</a>
<a name="ln923">   * we decide to proceed with parsing the UPDATE</a>
<a name="ln924">   */</a>
<a name="ln925">  UNSET_FLAG (args-&gt;attr-&gt;flag,  ATTR_FLAG_BIT (args-&gt;type));</a>
<a name="ln926">  </a>
<a name="ln927">  /* Only relax error handling for eBGP peers */</a>
<a name="ln928">  if (peer-&gt;sort != BGP_PEER_EBGP)</a>
<a name="ln929">    {</a>
<a name="ln930">      bgp_notify_send_with_data (peer, BGP_NOTIFY_UPDATE_ERR, subcode,</a>
<a name="ln931">                                 notify_datap, length);</a>
<a name="ln932">      return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln933"> </a>
<a name="ln934">    }</a>
<a name="ln935">  </a>
<a name="ln936">  /* Adjust the stream getp to the end of the attribute, in case we can</a>
<a name="ln937">   * still proceed but the caller hasn't read all the attribute.</a>
<a name="ln938">   */</a>
<a name="ln939">  stream_set_getp (BGP_INPUT (peer),</a>
<a name="ln940">                   (args-&gt;startp - STREAM_DATA (BGP_INPUT (peer)))</a>
<a name="ln941">                    + args-&gt;total);</a>
<a name="ln942">  </a>
<a name="ln943">  switch (args-&gt;type) {</a>
<a name="ln944">    /* where an attribute is relatively inconsequential, e.g. it does not</a>
<a name="ln945">     * affect route selection, and can be safely ignored, then any such</a>
<a name="ln946">     * attributes which are malformed should just be ignored and the route</a>
<a name="ln947">     * processed as normal.</a>
<a name="ln948">     */</a>
<a name="ln949">    case BGP_ATTR_AS4_AGGREGATOR:</a>
<a name="ln950">    case BGP_ATTR_AGGREGATOR:</a>
<a name="ln951">    case BGP_ATTR_ATOMIC_AGGREGATE:</a>
<a name="ln952">      return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln953">    </a>
<a name="ln954">    /* Core attributes, particularly ones which may influence route</a>
<a name="ln955">     * selection, should always cause session resets</a>
<a name="ln956">     */</a>
<a name="ln957">    case BGP_ATTR_ORIGIN:</a>
<a name="ln958">    case BGP_ATTR_AS_PATH:</a>
<a name="ln959">    case BGP_ATTR_NEXT_HOP:</a>
<a name="ln960">    case BGP_ATTR_MULTI_EXIT_DISC:</a>
<a name="ln961">    case BGP_ATTR_LOCAL_PREF:</a>
<a name="ln962">    case BGP_ATTR_COMMUNITIES:</a>
<a name="ln963">    case BGP_ATTR_ORIGINATOR_ID:</a>
<a name="ln964">    case BGP_ATTR_CLUSTER_LIST:</a>
<a name="ln965">    case BGP_ATTR_MP_REACH_NLRI:</a>
<a name="ln966">    case BGP_ATTR_MP_UNREACH_NLRI:</a>
<a name="ln967">    case BGP_ATTR_EXT_COMMUNITIES:</a>
<a name="ln968">      bgp_notify_send_with_data (peer, BGP_NOTIFY_UPDATE_ERR, subcode,</a>
<a name="ln969">                                 notify_datap, length);</a>
<a name="ln970">      return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln971">  }</a>
<a name="ln972">  </a>
<a name="ln973">  /* Partial optional attributes that are malformed should not cause</a>
<a name="ln974">   * the whole session to be reset. Instead treat it as a withdrawal</a>
<a name="ln975">   * of the routes, if possible.</a>
<a name="ln976">   */</a>
<a name="ln977">  if (CHECK_FLAG (flags, BGP_ATTR_FLAG_TRANS)</a>
<a name="ln978">      &amp;&amp; CHECK_FLAG (flags, BGP_ATTR_FLAG_OPTIONAL)</a>
<a name="ln979">      &amp;&amp; CHECK_FLAG (flags, BGP_ATTR_FLAG_PARTIAL))</a>
<a name="ln980">    return BGP_ATTR_PARSE_WITHDRAW;</a>
<a name="ln981">  </a>
<a name="ln982">  /* default to reset */</a>
<a name="ln983">  bgp_notify_send_with_data (peer, BGP_NOTIFY_UPDATE_ERR, subcode,</a>
<a name="ln984">                             notify_datap, length);</a>
<a name="ln985">  return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">/* Find out what is wrong with the path attribute flag bits and log the error.</a>
<a name="ln989">   &quot;Flag bits&quot; here stand for Optional, Transitive and Partial, but not for</a>
<a name="ln990">   Extended Length. Checking O/T/P bits at once implies, that the attribute</a>
<a name="ln991">   being diagnosed is defined by RFC as either a &quot;well-known&quot; or an &quot;optional,</a>
<a name="ln992">   non-transitive&quot; attribute. */</a>
<a name="ln993">static void</a>
<a name="ln994">bgp_attr_flags_diagnose (struct bgp_attr_parser_args *args,</a>
<a name="ln995">                         u_int8_t desired_flags /* how RFC says it must be */</a>
<a name="ln996">)</a>
<a name="ln997">{</a>
<a name="ln998">  u_char seen = 0, i;</a>
<a name="ln999">  u_char real_flags = args-&gt;flags;</a>
<a name="ln1000">  const u_int8_t attr_code = args-&gt;type;</a>
<a name="ln1001">  </a>
<a name="ln1002">  desired_flags &amp;= ~BGP_ATTR_FLAG_EXTLEN;</a>
<a name="ln1003">  real_flags &amp;= ~BGP_ATTR_FLAG_EXTLEN;</a>
<a name="ln1004">  for (i = 0; i &lt;= 2; i++) /* O,T,P, but not E */</a>
<a name="ln1005">    if</a>
<a name="ln1006">    (</a>
<a name="ln1007">      CHECK_FLAG (desired_flags, attr_flag_str[i].key) !=</a>
<a name="ln1008">      CHECK_FLAG (real_flags,    attr_flag_str[i].key)</a>
<a name="ln1009">    )</a>
<a name="ln1010">    {</a>
<a name="ln1011">      zlog (args-&gt;peer-&gt;log, LOG_ERR, &quot;%s attribute must%s be flagged as \&quot;%s\&quot;&quot;,</a>
<a name="ln1012">            LOOKUP (attr_str, attr_code),</a>
<a name="ln1013">            CHECK_FLAG (desired_flags, attr_flag_str[i].key) ? &quot;&quot; : &quot; not&quot;,</a>
<a name="ln1014">            attr_flag_str[i].str);</a>
<a name="ln1015">      seen = 1;</a>
<a name="ln1016">    }</a>
<a name="ln1017">  if (!seen)</a>
<a name="ln1018">    {</a>
<a name="ln1019">      zlog (args-&gt;peer-&gt;log, LOG_DEBUG,</a>
<a name="ln1020">            &quot;Strange, %s called for attr %s, but no problem found with flags&quot;</a>
<a name="ln1021">            &quot; (real flags 0x%x, desired 0x%x)&quot;,</a>
<a name="ln1022">            __func__, LOOKUP (attr_str, attr_code),</a>
<a name="ln1023">            real_flags, desired_flags);</a>
<a name="ln1024">    }</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">/* Required flags for attributes. EXTLEN will be masked off when testing,</a>
<a name="ln1028"> * as will PARTIAL for optional+transitive attributes.</a>
<a name="ln1029"> */</a>
<a name="ln1030">const u_int8_t attr_flags_values [] = {</a>
<a name="ln1031">  [BGP_ATTR_ORIGIN] =           BGP_ATTR_FLAG_TRANS,</a>
<a name="ln1032">  [BGP_ATTR_AS_PATH] =          BGP_ATTR_FLAG_TRANS,</a>
<a name="ln1033">  [BGP_ATTR_NEXT_HOP] =         BGP_ATTR_FLAG_TRANS,</a>
<a name="ln1034">  [BGP_ATTR_MULTI_EXIT_DISC] =  BGP_ATTR_FLAG_OPTIONAL,</a>
<a name="ln1035">  [BGP_ATTR_LOCAL_PREF] =       BGP_ATTR_FLAG_TRANS,</a>
<a name="ln1036">  [BGP_ATTR_ATOMIC_AGGREGATE] = BGP_ATTR_FLAG_TRANS,</a>
<a name="ln1037">  [BGP_ATTR_AGGREGATOR] =       BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL,</a>
<a name="ln1038">  [BGP_ATTR_COMMUNITIES] =      BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL,</a>
<a name="ln1039">  [BGP_ATTR_ORIGINATOR_ID] =    BGP_ATTR_FLAG_OPTIONAL,</a>
<a name="ln1040">  [BGP_ATTR_CLUSTER_LIST] =     BGP_ATTR_FLAG_OPTIONAL,</a>
<a name="ln1041">  [BGP_ATTR_MP_REACH_NLRI] =    BGP_ATTR_FLAG_OPTIONAL,</a>
<a name="ln1042">  [BGP_ATTR_MP_UNREACH_NLRI] =  BGP_ATTR_FLAG_OPTIONAL,</a>
<a name="ln1043">  [BGP_ATTR_EXT_COMMUNITIES] =  BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,</a>
<a name="ln1044">  [BGP_ATTR_AS4_PATH] =         BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,</a>
<a name="ln1045">  [BGP_ATTR_AS4_AGGREGATOR] =   BGP_ATTR_FLAG_OPTIONAL | BGP_ATTR_FLAG_TRANS,</a>
<a name="ln1046">  [BGP_ATTR_LARGE_COMMUNITIES] = BGP_ATTR_FLAG_TRANS | BGP_ATTR_FLAG_OPTIONAL</a>
<a name="ln1047">};</a>
<a name="ln1048">static const size_t attr_flags_values_max = array_size(attr_flags_values) - 1;</a>
<a name="ln1049"> </a>
<a name="ln1050">static int</a>
<a name="ln1051">bgp_attr_flag_invalid (struct bgp_attr_parser_args *args)</a>
<a name="ln1052">{</a>
<a name="ln1053">  u_int8_t mask = BGP_ATTR_FLAG_EXTLEN;</a>
<a name="ln1054">  const u_int8_t flags = args-&gt;flags;</a>
<a name="ln1055">  const u_int8_t attr_code = args-&gt;type;</a>
<a name="ln1056">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1057">  </a>
<a name="ln1058">  /* there may be attributes we don't know about */</a>
<a name="ln1059">  if (attr_code &gt; attr_flags_values_max)</a>
<a name="ln1060">    return 0;</a>
<a name="ln1061">  if (attr_flags_values[attr_code] == 0)</a>
<a name="ln1062">    return 0;</a>
<a name="ln1063">  </a>
<a name="ln1064">  /* RFC4271, &quot;For well-known attributes, the Transitive bit MUST be set to</a>
<a name="ln1065">   * 1.&quot;</a>
<a name="ln1066">   */</a>
<a name="ln1067">  if (!CHECK_FLAG (BGP_ATTR_FLAG_OPTIONAL, flags)</a>
<a name="ln1068">      &amp;&amp; !CHECK_FLAG (BGP_ATTR_FLAG_TRANS, flags))</a>
<a name="ln1069">    {</a>
<a name="ln1070">      zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln1071">            &quot;%s well-known attributes must have transitive flag set (%x)&quot;,</a>
<a name="ln1072">            LOOKUP (attr_str, attr_code), flags);</a>
<a name="ln1073">      return 1;</a>
<a name="ln1074">    }</a>
<a name="ln1075">  </a>
<a name="ln1076">  /* &quot;For well-known attributes and for optional non-transitive attributes,</a>
<a name="ln1077">   *  the Partial bit MUST be set to 0.&quot; </a>
<a name="ln1078">   */</a>
<a name="ln1079">  if (CHECK_FLAG (flags, BGP_ATTR_FLAG_PARTIAL))</a>
<a name="ln1080">    {</a>
<a name="ln1081">      if (!CHECK_FLAG (flags, BGP_ATTR_FLAG_OPTIONAL))</a>
<a name="ln1082">        {</a>
<a name="ln1083">          zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln1084">                &quot;%s well-known attribute &quot;</a>
<a name="ln1085">                &quot;must NOT have the partial flag set (%x)&quot;,</a>
<a name="ln1086">                 LOOKUP (attr_str, attr_code), flags);</a>
<a name="ln1087">          return 1;</a>
<a name="ln1088">        }</a>
<a name="ln1089">      if (CHECK_FLAG (flags, BGP_ATTR_FLAG_OPTIONAL)</a>
<a name="ln1090">          &amp;&amp; !CHECK_FLAG (flags, BGP_ATTR_FLAG_TRANS))</a>
<a name="ln1091">        {</a>
<a name="ln1092">          zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln1093">                &quot;%s optional + transitive attribute &quot;</a>
<a name="ln1094">                &quot;must NOT have the partial flag set (%x)&quot;,</a>
<a name="ln1095">                 LOOKUP (attr_str, attr_code), flags);</a>
<a name="ln1096">          return 1;</a>
<a name="ln1097">        }</a>
<a name="ln1098">    }</a>
<a name="ln1099">  </a>
<a name="ln1100">  /* Optional transitive attributes may go through speakers that don't</a>
<a name="ln1101">   * reocgnise them and set the Partial bit.</a>
<a name="ln1102">   */</a>
<a name="ln1103">  if (CHECK_FLAG (flags, BGP_ATTR_FLAG_OPTIONAL)</a>
<a name="ln1104">      &amp;&amp; CHECK_FLAG (flags, BGP_ATTR_FLAG_TRANS))</a>
<a name="ln1105">    SET_FLAG (mask, BGP_ATTR_FLAG_PARTIAL);</a>
<a name="ln1106">  </a>
<a name="ln1107">  if ((flags &amp; ~mask)</a>
<a name="ln1108">      == attr_flags_values[attr_code])</a>
<a name="ln1109">    return 0;</a>
<a name="ln1110">  </a>
<a name="ln1111">  bgp_attr_flags_diagnose (args, attr_flags_values[attr_code]);</a>
<a name="ln1112">  return 1;</a>
<a name="ln1113">}</a>
<a name="ln1114"> </a>
<a name="ln1115">/* Get origin attribute of the update message. */</a>
<a name="ln1116">static bgp_attr_parse_ret_t</a>
<a name="ln1117">bgp_attr_origin (struct bgp_attr_parser_args *args)</a>
<a name="ln1118">{</a>
<a name="ln1119">  struct peer *const peer = args-&gt;peer;</a>
<a name="ln1120">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1121">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1122">  </a>
<a name="ln1123">  /* If any recognized attribute has Attribute Length that conflicts</a>
<a name="ln1124">     with the expected length (based on the attribute type code), then</a>
<a name="ln1125">     the Error Subcode is set to Attribute Length Error.  The Data</a>
<a name="ln1126">     field contains the erroneous attribute (type, length and</a>
<a name="ln1127">     value). */</a>
<a name="ln1128">  if (length != 1)</a>
<a name="ln1129">    {</a>
<a name="ln1130">      zlog (peer-&gt;log, LOG_ERR, &quot;Origin attribute length is not one %d&quot;,</a>
<a name="ln1131">	    length);</a>
<a name="ln1132">      return bgp_attr_malformed (args,</a>
<a name="ln1133">                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln1134">                                 args-&gt;total);</a>
<a name="ln1135">    }</a>
<a name="ln1136"> </a>
<a name="ln1137">  /* Fetch origin attribute. */</a>
<a name="ln1138">  attr-&gt;origin = stream_getc (BGP_INPUT (peer));</a>
<a name="ln1139"> </a>
<a name="ln1140">  /* If the ORIGIN attribute has an undefined value, then the Error</a>
<a name="ln1141">     Subcode is set to Invalid Origin Attribute.  The Data field</a>
<a name="ln1142">     contains the unrecognized attribute (type, length and value). */</a>
<a name="ln1143">  if ((attr-&gt;origin != BGP_ORIGIN_IGP)</a>
<a name="ln1144">      &amp;&amp; (attr-&gt;origin != BGP_ORIGIN_EGP)</a>
<a name="ln1145">      &amp;&amp; (attr-&gt;origin != BGP_ORIGIN_INCOMPLETE))</a>
<a name="ln1146">    {</a>
<a name="ln1147">      zlog (peer-&gt;log, LOG_ERR, &quot;Origin attribute value is invalid %d&quot;,</a>
<a name="ln1148">	      attr-&gt;origin);</a>
<a name="ln1149">      return bgp_attr_malformed (args,</a>
<a name="ln1150">                                 BGP_NOTIFY_UPDATE_INVAL_ORIGIN,</a>
<a name="ln1151">                                 args-&gt;total);</a>
<a name="ln1152">    }</a>
<a name="ln1153"> </a>
<a name="ln1154">  /* Set oring attribute flag. */</a>
<a name="ln1155">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGIN);</a>
<a name="ln1156"> </a>
<a name="ln1157">  return 0;</a>
<a name="ln1158">}</a>
<a name="ln1159"> </a>
<a name="ln1160">/* Parse AS path information.  This function is wrapper of</a>
<a name="ln1161">   aspath_parse. */</a>
<a name="ln1162">static int</a>
<a name="ln1163">bgp_attr_aspath (struct bgp_attr_parser_args *args)</a>
<a name="ln1164">{</a>
<a name="ln1165">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1166">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1167">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1168">  </a>
<a name="ln1169">  /*</a>
<a name="ln1170">   * peer with AS4 =&gt; will get 4Byte ASnums</a>
<a name="ln1171">   * otherwise, will get 16 Bit</a>
<a name="ln1172">   */</a>
<a name="ln1173">  attr-&gt;aspath = aspath_parse (peer-&gt;ibuf, length, </a>
<a name="ln1174">                               CHECK_FLAG (peer-&gt;cap, PEER_CAP_AS4_RCV));</a>
<a name="ln1175"> </a>
<a name="ln1176">  /* In case of IBGP, length will be zero. */</a>
<a name="ln1177">  if (! attr-&gt;aspath)</a>
<a name="ln1178">    {</a>
<a name="ln1179">      zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln1180">            &quot;Malformed AS path from %s, length is %d&quot;,</a>
<a name="ln1181">            peer-&gt;host, length);</a>
<a name="ln1182">      return bgp_attr_malformed (args, BGP_NOTIFY_UPDATE_MAL_AS_PATH, 0);</a>
<a name="ln1183">    }</a>
<a name="ln1184"> </a>
<a name="ln1185">  /* Set aspath attribute flag. */</a>
<a name="ln1186">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_AS_PATH);</a>
<a name="ln1187"> </a>
<a name="ln1188">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1189">}</a>
<a name="ln1190"> </a>
<a name="ln1191">static bgp_attr_parse_ret_t</a>
<a name="ln1192">bgp_attr_aspath_check (struct peer *const peer, struct attr *const attr)</a>
<a name="ln1193">{</a>
<a name="ln1194">  /* These checks were part of bgp_attr_aspath, but with</a>
<a name="ln1195">   * as4 we should to check aspath things when</a>
<a name="ln1196">   * aspath synthesizing with as4_path has already taken place.</a>
<a name="ln1197">   * Otherwise we check ASPATH and use the synthesized thing, and that is</a>
<a name="ln1198">   * not right.</a>
<a name="ln1199">   * So do the checks later, i.e. here</a>
<a name="ln1200">   */</a>
<a name="ln1201">  struct bgp *bgp = peer-&gt;bgp;</a>
<a name="ln1202">  struct aspath *aspath;</a>
<a name="ln1203"> </a>
<a name="ln1204">  /* Confederation sanity check. */</a>
<a name="ln1205">  if ((peer-&gt;sort == BGP_PEER_CONFED &amp;&amp; ! aspath_left_confed_check (attr-&gt;aspath)) ||</a>
<a name="ln1206">     (peer-&gt;sort == BGP_PEER_EBGP &amp;&amp; aspath_confed_check (attr-&gt;aspath)))</a>
<a name="ln1207">    {</a>
<a name="ln1208">      zlog (peer-&gt;log, LOG_ERR, &quot;Malformed AS path from %s&quot;, peer-&gt;host);</a>
<a name="ln1209">      bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR,</a>
<a name="ln1210">                       BGP_NOTIFY_UPDATE_MAL_AS_PATH);</a>
<a name="ln1211">      return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln1212">    }</a>
<a name="ln1213"> </a>
<a name="ln1214">  /* First AS check for EBGP. */</a>
<a name="ln1215">  if (bgp != NULL &amp;&amp; bgp_flag_check (bgp, BGP_FLAG_ENFORCE_FIRST_AS))</a>
<a name="ln1216">    {</a>
<a name="ln1217">      if (peer-&gt;sort == BGP_PEER_EBGP</a>
<a name="ln1218">	  &amp;&amp; ! aspath_firstas_check (attr-&gt;aspath, peer-&gt;as))</a>
<a name="ln1219"> 	{</a>
<a name="ln1220"> 	  zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln1221"> 		&quot;%s incorrect first AS (must be %u)&quot;, peer-&gt;host, peer-&gt;as);</a>
<a name="ln1222">          bgp_notify_send (peer, BGP_NOTIFY_UPDATE_ERR,</a>
<a name="ln1223">                           BGP_NOTIFY_UPDATE_MAL_AS_PATH);</a>
<a name="ln1224">          return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln1225"> 	}</a>
<a name="ln1226">    }</a>
<a name="ln1227"> </a>
<a name="ln1228">  /* local-as prepend */</a>
<a name="ln1229">  if (peer-&gt;change_local_as &amp;&amp;</a>
<a name="ln1230">      ! CHECK_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_NO_PREPEND))</a>
<a name="ln1231">    {</a>
<a name="ln1232">      aspath = aspath_dup (attr-&gt;aspath);</a>
<a name="ln1233">      aspath = aspath_add_seq (aspath, peer-&gt;change_local_as);</a>
<a name="ln1234">      aspath_unintern (&amp;attr-&gt;aspath);</a>
<a name="ln1235">      attr-&gt;aspath = aspath_intern (aspath);</a>
<a name="ln1236">    }</a>
<a name="ln1237"> </a>
<a name="ln1238">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241">/* Parse AS4 path information.  This function is another wrapper of</a>
<a name="ln1242">   aspath_parse. */</a>
<a name="ln1243">static int</a>
<a name="ln1244">bgp_attr_as4_path (struct bgp_attr_parser_args *args, struct aspath **as4_path)</a>
<a name="ln1245">{</a>
<a name="ln1246">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1247">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1248">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1249">  </a>
<a name="ln1250">  *as4_path = aspath_parse (peer-&gt;ibuf, length, 1);</a>
<a name="ln1251"> </a>
<a name="ln1252">  /* In case of IBGP, length will be zero. */</a>
<a name="ln1253">  if (!*as4_path)</a>
<a name="ln1254">    {</a>
<a name="ln1255">      zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln1256">            &quot;Malformed AS4 path from %s, length is %d&quot;,</a>
<a name="ln1257">            peer-&gt;host, length);</a>
<a name="ln1258">      return bgp_attr_malformed (args,</a>
<a name="ln1259">                                 BGP_NOTIFY_UPDATE_MAL_AS_PATH,</a>
<a name="ln1260">                                 0);</a>
<a name="ln1261">    }</a>
<a name="ln1262"> </a>
<a name="ln1263">  /* Set aspath attribute flag. */</a>
<a name="ln1264">  if (as4_path)</a>
<a name="ln1265">    attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_AS4_PATH);</a>
<a name="ln1266"> </a>
<a name="ln1267">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1268">}</a>
<a name="ln1269"> </a>
<a name="ln1270">/* Nexthop attribute. */</a>
<a name="ln1271">static bgp_attr_parse_ret_t</a>
<a name="ln1272">bgp_attr_nexthop (struct bgp_attr_parser_args *args)</a>
<a name="ln1273">{</a>
<a name="ln1274">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1275">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1276">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1277">  </a>
<a name="ln1278">  in_addr_t nexthop_h, nexthop_n;</a>
<a name="ln1279"> </a>
<a name="ln1280">  /* Check nexthop attribute length. */</a>
<a name="ln1281">  if (length != 4)</a>
<a name="ln1282">    {</a>
<a name="ln1283">      zlog (peer-&gt;log, LOG_ERR, &quot;Nexthop attribute length isn't four [%d]&quot;,</a>
<a name="ln1284">	      length);</a>
<a name="ln1285"> </a>
<a name="ln1286">      return bgp_attr_malformed (args,</a>
<a name="ln1287">                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln1288">                                 args-&gt;total);</a>
<a name="ln1289">    }</a>
<a name="ln1290"> </a>
<a name="ln1291">  /* According to section 6.3 of RFC4271, syntactically incorrect NEXT_HOP</a>
<a name="ln1292">     attribute must result in a NOTIFICATION message (this is implemented below).</a>
<a name="ln1293">     At the same time, semantically incorrect NEXT_HOP is more likely to be just</a>
<a name="ln1294">     logged locally (this is implemented somewhere else). The UPDATE message</a>
<a name="ln1295">     gets ignored in any of these cases. */</a>
<a name="ln1296">  nexthop_n = stream_get_ipv4 (peer-&gt;ibuf);</a>
<a name="ln1297">  nexthop_h = ntohl (nexthop_n);</a>
<a name="ln1298">  if ((IPV4_NET0 (nexthop_h) || IPV4_NET127 (nexthop_h) || IPV4_CLASS_DE (nexthop_h))</a>
<a name="ln1299">      &amp;&amp; !BGP_DEBUG (allow_martians, ALLOW_MARTIANS)) /* loopbacks may be used in testing */</a>
<a name="ln1300">    {</a>
<a name="ln1301">      char buf[INET_ADDRSTRLEN];</a>
<a name="ln1302">      inet_ntop (AF_INET, &amp;nexthop_n, buf, INET_ADDRSTRLEN);</a>
<a name="ln1303">      zlog (peer-&gt;log, LOG_ERR, &quot;Martian nexthop %s&quot;, buf);</a>
<a name="ln1304">      return bgp_attr_malformed (args,</a>
<a name="ln1305">                                 BGP_NOTIFY_UPDATE_INVAL_NEXT_HOP,</a>
<a name="ln1306">                                 args-&gt;total);</a>
<a name="ln1307">    }</a>
<a name="ln1308"> </a>
<a name="ln1309">  attr-&gt;nexthop.s_addr = nexthop_n;</a>
<a name="ln1310">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);</a>
<a name="ln1311"> </a>
<a name="ln1312">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1313">}</a>
<a name="ln1314"> </a>
<a name="ln1315">/* MED atrribute. */</a>
<a name="ln1316">static bgp_attr_parse_ret_t</a>
<a name="ln1317">bgp_attr_med (struct bgp_attr_parser_args *args)</a>
<a name="ln1318">{</a>
<a name="ln1319">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1320">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1321">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1322">  </a>
<a name="ln1323">  /* Length check. */</a>
<a name="ln1324">  if (length != 4)</a>
<a name="ln1325">    {</a>
<a name="ln1326">      zlog (peer-&gt;log, LOG_ERR, </a>
<a name="ln1327">	    &quot;MED attribute length isn't four [%d]&quot;, length);</a>
<a name="ln1328"> </a>
<a name="ln1329">      return bgp_attr_malformed (args,</a>
<a name="ln1330">                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln1331">                                 args-&gt;total);</a>
<a name="ln1332">    }</a>
<a name="ln1333"> </a>
<a name="ln1334">  attr-&gt;med = stream_getl (peer-&gt;ibuf);</a>
<a name="ln1335"> </a>
<a name="ln1336">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);</a>
<a name="ln1337"> </a>
<a name="ln1338">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1339">}</a>
<a name="ln1340"> </a>
<a name="ln1341">/* Local preference attribute. */</a>
<a name="ln1342">static bgp_attr_parse_ret_t</a>
<a name="ln1343">bgp_attr_local_pref (struct bgp_attr_parser_args *args)</a>
<a name="ln1344">{</a>
<a name="ln1345">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1346">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1347">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1348">  </a>
<a name="ln1349">  /* Length check. */</a>
<a name="ln1350">  if (length != 4)</a>
<a name="ln1351">  {</a>
<a name="ln1352">    zlog (peer-&gt;log, LOG_ERR, &quot;LOCAL_PREF attribute length isn't 4 [%u]&quot;,</a>
<a name="ln1353">          length);</a>
<a name="ln1354">    return bgp_attr_malformed (args,</a>
<a name="ln1355">                               BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln1356">                               args-&gt;total);</a>
<a name="ln1357">  }</a>
<a name="ln1358"> </a>
<a name="ln1359">  /* If it is contained in an UPDATE message that is received from an</a>
<a name="ln1360">     external peer, then this attribute MUST be ignored by the</a>
<a name="ln1361">     receiving speaker. */</a>
<a name="ln1362">  if (peer-&gt;sort == BGP_PEER_EBGP)</a>
<a name="ln1363">    {</a>
<a name="ln1364">      stream_forward_getp (peer-&gt;ibuf, length);</a>
<a name="ln1365">      return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1366">    }</a>
<a name="ln1367"> </a>
<a name="ln1368">  attr-&gt;local_pref = stream_getl (peer-&gt;ibuf);</a>
<a name="ln1369"> </a>
<a name="ln1370">  /* Set atomic aggregate flag. */</a>
<a name="ln1371">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF);</a>
<a name="ln1372"> </a>
<a name="ln1373">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1374">}</a>
<a name="ln1375"> </a>
<a name="ln1376">/* Atomic aggregate. */</a>
<a name="ln1377">static int</a>
<a name="ln1378">bgp_attr_atomic (struct bgp_attr_parser_args *args)</a>
<a name="ln1379">{</a>
<a name="ln1380">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1381">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1382">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1383">  </a>
<a name="ln1384">  /* Length check. */</a>
<a name="ln1385">  if (length != 0)</a>
<a name="ln1386">    {</a>
<a name="ln1387">      zlog (peer-&gt;log, LOG_ERR, &quot;ATOMIC_AGGREGATE attribute length isn't 0 [%u]&quot;,</a>
<a name="ln1388">            length);</a>
<a name="ln1389">      return bgp_attr_malformed (args,</a>
<a name="ln1390">                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln1391">                                 args-&gt;total);</a>
<a name="ln1392">    }</a>
<a name="ln1393"> </a>
<a name="ln1394">  /* Set atomic aggregate flag. */</a>
<a name="ln1395">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);</a>
<a name="ln1396"> </a>
<a name="ln1397">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400">/* Aggregator attribute */</a>
<a name="ln1401">static int</a>
<a name="ln1402">bgp_attr_aggregator (struct bgp_attr_parser_args *args)</a>
<a name="ln1403">{</a>
<a name="ln1404">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1405">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1406">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1407">  </a>
<a name="ln1408">  int wantedlen = 6;</a>
<a name="ln1409">  struct attr_extra *attre = bgp_attr_extra_get (attr);</a>
<a name="ln1410">  </a>
<a name="ln1411">  /* peer with AS4 will send 4 Byte AS, peer without will send 2 Byte */</a>
<a name="ln1412">  if (CHECK_FLAG (peer-&gt;cap, PEER_CAP_AS4_RCV))</a>
<a name="ln1413">    wantedlen = 8;</a>
<a name="ln1414">  </a>
<a name="ln1415">  if (length != wantedlen)</a>
<a name="ln1416">    {</a>
<a name="ln1417">      zlog (peer-&gt;log, LOG_ERR, &quot;AGGREGATOR attribute length isn't %u [%u]&quot;,</a>
<a name="ln1418">            wantedlen, length);</a>
<a name="ln1419">      return bgp_attr_malformed (args,</a>
<a name="ln1420">                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln1421">                                 args-&gt;total);</a>
<a name="ln1422">    }</a>
<a name="ln1423">  </a>
<a name="ln1424">  if ( CHECK_FLAG (peer-&gt;cap, PEER_CAP_AS4_RCV ) )</a>
<a name="ln1425">    attre-&gt;aggregator_as = stream_getl (peer-&gt;ibuf);</a>
<a name="ln1426">  else</a>
<a name="ln1427">    attre-&gt;aggregator_as = stream_getw (peer-&gt;ibuf);</a>
<a name="ln1428">  attre-&gt;aggregator_addr.s_addr = stream_get_ipv4 (peer-&gt;ibuf);</a>
<a name="ln1429"> </a>
<a name="ln1430">  /* Set atomic aggregate flag. */</a>
<a name="ln1431">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR);</a>
<a name="ln1432"> </a>
<a name="ln1433">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1434">}</a>
<a name="ln1435"> </a>
<a name="ln1436">/* New Aggregator attribute */</a>
<a name="ln1437">static bgp_attr_parse_ret_t</a>
<a name="ln1438">bgp_attr_as4_aggregator (struct bgp_attr_parser_args *args,</a>
<a name="ln1439">		         as_t *as4_aggregator_as,</a>
<a name="ln1440">		         struct in_addr *as4_aggregator_addr)</a>
<a name="ln1441">{</a>
<a name="ln1442">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1443">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1444">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1445">      </a>
<a name="ln1446">  if (length != 8)</a>
<a name="ln1447">    {</a>
<a name="ln1448">      zlog (peer-&gt;log, LOG_ERR, &quot;New Aggregator length is not 8 [%d]&quot;,</a>
<a name="ln1449">            length);</a>
<a name="ln1450">      return bgp_attr_malformed (args,</a>
<a name="ln1451">                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln1452">                                 0);</a>
<a name="ln1453">    }</a>
<a name="ln1454">  </a>
<a name="ln1455">  *as4_aggregator_as = stream_getl (peer-&gt;ibuf);</a>
<a name="ln1456">  as4_aggregator_addr-&gt;s_addr = stream_get_ipv4 (peer-&gt;ibuf);</a>
<a name="ln1457"> </a>
<a name="ln1458">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_AS4_AGGREGATOR);</a>
<a name="ln1459"> </a>
<a name="ln1460">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1461">}</a>
<a name="ln1462"> </a>
<a name="ln1463">/* Munge Aggregator and New-Aggregator, AS_PATH and NEW_AS_PATH.</a>
<a name="ln1464"> */</a>
<a name="ln1465">static bgp_attr_parse_ret_t</a>
<a name="ln1466">bgp_attr_munge_as4_attrs (struct peer *const peer,</a>
<a name="ln1467">                          struct attr *const attr,</a>
<a name="ln1468">                          struct aspath *as4_path, as_t as4_aggregator,</a>
<a name="ln1469">                          struct in_addr *as4_aggregator_addr)</a>
<a name="ln1470">{</a>
<a name="ln1471">  int ignore_as4_path = 0;</a>
<a name="ln1472">  struct aspath *newpath;</a>
<a name="ln1473">  struct attr_extra *attre = attr-&gt;extra;</a>
<a name="ln1474">  </a>
<a name="ln1475">  if (!attr-&gt;aspath)</a>
<a name="ln1476">    {</a>
<a name="ln1477">      /* NULL aspath shouldn't be possible as bgp_attr_parse should have</a>
<a name="ln1478">       * checked that all well-known, mandatory attributes were present.</a>
<a name="ln1479">       * </a>
<a name="ln1480">       * Can only be a problem with peer itself - hard error</a>
<a name="ln1481">       */</a>
<a name="ln1482">      return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln1483">    }</a>
<a name="ln1484">  </a>
<a name="ln1485">  if (CHECK_FLAG (peer-&gt;cap, PEER_CAP_AS4_RCV))</a>
<a name="ln1486">    {</a>
<a name="ln1487">      /* peer can do AS4, so we ignore AS4_PATH and AS4_AGGREGATOR</a>
<a name="ln1488">       * if given.</a>
<a name="ln1489">       * It is worth a warning though, because the peer really</a>
<a name="ln1490">       * should not send them</a>
<a name="ln1491">       */</a>
<a name="ln1492">      if (BGP_DEBUG(as4, AS4))</a>
<a name="ln1493">        {</a>
<a name="ln1494">          if (attr-&gt;flag &amp; (ATTR_FLAG_BIT(BGP_ATTR_AS4_PATH)))</a>
<a name="ln1495">            zlog_debug (&quot;[AS4] %s %s AS4_PATH&quot;,</a>
<a name="ln1496">                        peer-&gt;host, &quot;AS4 capable peer, yet it sent&quot;);</a>
<a name="ln1497">          </a>
<a name="ln1498">          if (attr-&gt;flag &amp; (ATTR_FLAG_BIT(BGP_ATTR_AS4_AGGREGATOR)))</a>
<a name="ln1499">            zlog_debug (&quot;[AS4] %s %s AS4_AGGREGATOR&quot;,</a>
<a name="ln1500">                        peer-&gt;host, &quot;AS4 capable peer, yet it sent&quot;);</a>
<a name="ln1501">        }</a>
<a name="ln1502">      </a>
<a name="ln1503">      return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1504">    }</a>
<a name="ln1505">  </a>
<a name="ln1506">  /* We have a asn16 peer.  First, look for AS4_AGGREGATOR</a>
<a name="ln1507">   * because that may override AS4_PATH</a>
<a name="ln1508">   */</a>
<a name="ln1509">  if (attr-&gt;flag &amp; (ATTR_FLAG_BIT (BGP_ATTR_AS4_AGGREGATOR) ) )</a>
<a name="ln1510">    {</a>
<a name="ln1511">      if (attr-&gt;flag &amp; (ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR) ) )</a>
<a name="ln1512">        {</a>
<a name="ln1513">          assert (attre);</a>
<a name="ln1514">          </a>
<a name="ln1515">          /* received both.</a>
<a name="ln1516">           * if the as_number in aggregator is not AS_TRANS,</a>
<a name="ln1517">           *  then AS4_AGGREGATOR and AS4_PATH shall be ignored</a>
<a name="ln1518">           *        and the Aggregator shall be taken as </a>
<a name="ln1519">           *        info on the aggregating node, and the AS_PATH</a>
<a name="ln1520">           *        shall be taken as the AS_PATH</a>
<a name="ln1521">           *  otherwise</a>
<a name="ln1522">           *        the Aggregator shall be ignored and the</a>
<a name="ln1523">           *        AS4_AGGREGATOR shall be taken as the</a>
<a name="ln1524">           *        Aggregating node and the AS_PATH is to be</a>
<a name="ln1525">           *        constructed &quot;as in all other cases&quot;</a>
<a name="ln1526">           */</a>
<a name="ln1527">          if (attre-&gt;aggregator_as != BGP_AS_TRANS)</a>
<a name="ln1528">            {</a>
<a name="ln1529">              /* ignore */</a>
<a name="ln1530">              if ( BGP_DEBUG(as4, AS4))</a>
<a name="ln1531">                zlog_debug (&quot;[AS4] %s BGP not AS4 capable peer&quot; </a>
<a name="ln1532">                            &quot; send AGGREGATOR != AS_TRANS and&quot;</a>
<a name="ln1533">                            &quot; AS4_AGGREGATOR, so ignore&quot;</a>
<a name="ln1534">                            &quot; AS4_AGGREGATOR and AS4_PATH&quot;, peer-&gt;host);</a>
<a name="ln1535">              ignore_as4_path = 1;</a>
<a name="ln1536">            }</a>
<a name="ln1537">          else</a>
<a name="ln1538">            {</a>
<a name="ln1539">              /* &quot;New_aggregator shall be taken as aggregator&quot; */</a>
<a name="ln1540">              attre-&gt;aggregator_as = as4_aggregator;</a>
<a name="ln1541">              attre-&gt;aggregator_addr.s_addr = as4_aggregator_addr-&gt;s_addr;</a>
<a name="ln1542">            }</a>
<a name="ln1543">        }</a>
<a name="ln1544">      else</a>
<a name="ln1545">        {</a>
<a name="ln1546">          /* We received a AS4_AGGREGATOR but no AGGREGATOR.</a>
<a name="ln1547">           * That is bogus - but reading the conditions</a>
<a name="ln1548">           * we have to handle AS4_AGGREGATOR as if it were</a>
<a name="ln1549">           * AGGREGATOR in that case</a>
<a name="ln1550">           */</a>
<a name="ln1551">          if ( BGP_DEBUG(as4, AS4))</a>
<a name="ln1552">            zlog_debug (&quot;[AS4] %s BGP not AS4 capable peer send&quot;</a>
<a name="ln1553">                        &quot; AS4_AGGREGATOR but no AGGREGATOR, will take&quot;</a>
<a name="ln1554">                        &quot; it as if AGGREGATOR with AS_TRANS had been there&quot;, peer-&gt;host);</a>
<a name="ln1555">          (attre = bgp_attr_extra_get (attr))-&gt;aggregator_as = as4_aggregator;</a>
<a name="ln1556">          /* sweep it under the carpet and simulate a &quot;good&quot; AGGREGATOR */</a>
<a name="ln1557">          attr-&gt;flag |= (ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR));</a>
<a name="ln1558">        }</a>
<a name="ln1559">    }</a>
<a name="ln1560"> </a>
<a name="ln1561">  /* need to reconcile NEW_AS_PATH and AS_PATH */</a>
<a name="ln1562">  if (!ignore_as4_path &amp;&amp; (attr-&gt;flag &amp; (ATTR_FLAG_BIT( BGP_ATTR_AS4_PATH))))</a>
<a name="ln1563">    {</a>
<a name="ln1564">      newpath = aspath_reconcile_as4 (attr-&gt;aspath, as4_path);</a>
<a name="ln1565">      aspath_unintern (&amp;attr-&gt;aspath);</a>
<a name="ln1566">      attr-&gt;aspath = aspath_intern (newpath);</a>
<a name="ln1567">    }</a>
<a name="ln1568">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1569">}</a>
<a name="ln1570"> </a>
<a name="ln1571">/* Community attribute. */</a>
<a name="ln1572">static bgp_attr_parse_ret_t</a>
<a name="ln1573">bgp_attr_community (struct bgp_attr_parser_args *args)</a>
<a name="ln1574">{</a>
<a name="ln1575">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1576">  struct attr *const attr = args-&gt;attr;  </a>
<a name="ln1577">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1578">  </a>
<a name="ln1579">  if (length == 0)</a>
<a name="ln1580">    {</a>
<a name="ln1581">      attr-&gt;community = NULL;</a>
<a name="ln1582">      return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1583">    }</a>
<a name="ln1584">  </a>
<a name="ln1585">  attr-&gt;community =</a>
<a name="ln1586">    community_parse ((u_int32_t *)stream_pnt (peer-&gt;ibuf), length);</a>
<a name="ln1587">  </a>
<a name="ln1588">  /* XXX: fix community_parse to use stream API and remove this */</a>
<a name="ln1589">  stream_forward_getp (peer-&gt;ibuf, length);</a>
<a name="ln1590"> </a>
<a name="ln1591">  if (!attr-&gt;community)</a>
<a name="ln1592">    return bgp_attr_malformed (args,</a>
<a name="ln1593">                               BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,</a>
<a name="ln1594">                               args-&gt;total);</a>
<a name="ln1595">  </a>
<a name="ln1596">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);</a>
<a name="ln1597"> </a>
<a name="ln1598">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1599">}</a>
<a name="ln1600"> </a>
<a name="ln1601">/* Originator ID attribute. */</a>
<a name="ln1602">static bgp_attr_parse_ret_t</a>
<a name="ln1603">bgp_attr_originator_id (struct bgp_attr_parser_args *args)</a>
<a name="ln1604">{</a>
<a name="ln1605">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1606">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1607">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1608">  </a>
<a name="ln1609">  /* Length check. */</a>
<a name="ln1610">  if (length != 4)</a>
<a name="ln1611">    {</a>
<a name="ln1612">      zlog (peer-&gt;log, LOG_ERR, &quot;Bad originator ID length %d&quot;, length);</a>
<a name="ln1613"> </a>
<a name="ln1614">      return bgp_attr_malformed (args,</a>
<a name="ln1615">                                 BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln1616">                                 args-&gt;total);</a>
<a name="ln1617">    }</a>
<a name="ln1618"> </a>
<a name="ln1619">  (bgp_attr_extra_get (attr))-&gt;originator_id.s_addr </a>
<a name="ln1620">    = stream_get_ipv4 (peer-&gt;ibuf);</a>
<a name="ln1621"> </a>
<a name="ln1622">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID);</a>
<a name="ln1623"> </a>
<a name="ln1624">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1625">}</a>
<a name="ln1626"> </a>
<a name="ln1627">/* Cluster list attribute. */</a>
<a name="ln1628">static bgp_attr_parse_ret_t</a>
<a name="ln1629">bgp_attr_cluster_list (struct bgp_attr_parser_args *args)</a>
<a name="ln1630">{</a>
<a name="ln1631">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln1632">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1633">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1634">  </a>
<a name="ln1635">  /* Check length. */</a>
<a name="ln1636">  if (length % 4)</a>
<a name="ln1637">    {</a>
<a name="ln1638">      zlog (peer-&gt;log, LOG_ERR, &quot;Bad cluster list length %d&quot;, length);</a>
<a name="ln1639"> </a>
<a name="ln1640">      return bgp_attr_malformed (args, BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln1641">                                 args-&gt;total);</a>
<a name="ln1642">    }</a>
<a name="ln1643"> </a>
<a name="ln1644">  (bgp_attr_extra_get (attr))-&gt;cluster </a>
<a name="ln1645">    = cluster_parse ((struct in_addr *)stream_pnt (peer-&gt;ibuf), length);</a>
<a name="ln1646">  </a>
<a name="ln1647">  /* XXX: Fix cluster_parse to use stream API and then remove this */</a>
<a name="ln1648">  stream_forward_getp (peer-&gt;ibuf, length);</a>
<a name="ln1649"> </a>
<a name="ln1650">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_CLUSTER_LIST);</a>
<a name="ln1651"> </a>
<a name="ln1652">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1653">}</a>
<a name="ln1654"> </a>
<a name="ln1655">/* Multiprotocol reachability information parse. */</a>
<a name="ln1656">int</a>
<a name="ln1657">bgp_mp_reach_parse (struct bgp_attr_parser_args *args,</a>
<a name="ln1658">                    struct bgp_nlri *mp_update)</a>
<a name="ln1659">{</a>
<a name="ln1660">  afi_t afi;</a>
<a name="ln1661">  safi_t safi;</a>
<a name="ln1662">  bgp_size_t nlri_len;</a>
<a name="ln1663">  size_t start;</a>
<a name="ln1664">  struct stream *s;</a>
<a name="ln1665">  struct peer *const peer = args-&gt;peer;  </a>
<a name="ln1666">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1667">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1668">  struct attr_extra *attre = bgp_attr_extra_get(attr);</a>
<a name="ln1669">  </a>
<a name="ln1670">  /* Set end of packet. */</a>
<a name="ln1671">  s = BGP_INPUT(peer);</a>
<a name="ln1672">  start = stream_get_getp(s);</a>
<a name="ln1673">  </a>
<a name="ln1674">  /* safe to read statically sized header? */</a>
<a name="ln1675">#define BGP_MP_REACH_MIN_SIZE 5</a>
<a name="ln1676">#define LEN_LEFT	(length - (stream_get_getp(s) - start))</a>
<a name="ln1677">  if ((length &gt; STREAM_READABLE(s)) || (length &lt; BGP_MP_REACH_MIN_SIZE))</a>
<a name="ln1678">    {</a>
<a name="ln1679">      zlog_info (&quot;%s: %s sent invalid length, %lu&quot;, </a>
<a name="ln1680">		 __func__, peer-&gt;host, (unsigned long)length);</a>
<a name="ln1681">      return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;</a>
<a name="ln1682">    }</a>
<a name="ln1683">  </a>
<a name="ln1684">  /* Load AFI, SAFI. */</a>
<a name="ln1685">  afi = stream_getw (s);</a>
<a name="ln1686">  safi = stream_getc (s);</a>
<a name="ln1687"> </a>
<a name="ln1688">  /* Get nexthop length. */</a>
<a name="ln1689">  attre-&gt;mp_nexthop_len = stream_getc (s);</a>
<a name="ln1690">  </a>
<a name="ln1691">  if (LEN_LEFT &lt; attre-&gt;mp_nexthop_len)</a>
<a name="ln1692">    {</a>
<a name="ln1693">      zlog_info (&quot;%s: %s, MP nexthop length, %u, goes past end of attribute&quot;, </a>
<a name="ln1694">		 __func__, peer-&gt;host, attre-&gt;mp_nexthop_len);</a>
<a name="ln1695">      return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;</a>
<a name="ln1696">    }</a>
<a name="ln1697">  </a>
<a name="ln1698">  /* Nexthop length check. */</a>
<a name="ln1699">  switch (attre-&gt;mp_nexthop_len)</a>
<a name="ln1700">    {</a>
<a name="ln1701">    case 4:</a>
<a name="ln1702">      stream_get (&amp;attre-&gt;mp_nexthop_global_in, s, 4);</a>
<a name="ln1703">      /* Probably needed for RFC 2283 */</a>
<a name="ln1704">      if (attr-&gt;nexthop.s_addr == 0)</a>
<a name="ln1705">        memcpy(&amp;attr-&gt;nexthop.s_addr, &amp;attre-&gt;mp_nexthop_global_in, 4);</a>
<a name="ln1706">      break;</a>
<a name="ln1707">    case 12:</a>
<a name="ln1708">      stream_getl (s); /* RD high */</a>
<a name="ln1709">      stream_getl (s); /* RD low */</a>
<a name="ln1710">      stream_get (&amp;attre-&gt;mp_nexthop_global_in, s, 4);</a>
<a name="ln1711">      break;</a>
<a name="ln1712">    case 24:</a>
<a name="ln1713">      {</a>
<a name="ln1714">        u_int32_t rd_high __attribute__((unused));</a>
<a name="ln1715">        u_int32_t rd_low __attribute__((unused));</a>
<a name="ln1716"> </a>
<a name="ln1717">        rd_high = stream_getl (s);</a>
<a name="ln1718">        rd_low = stream_getl (s);</a>
<a name="ln1719">      }</a>
<a name="ln1720">      /* fall through */</a>
<a name="ln1721">    case 16:</a>
<a name="ln1722">      stream_get (&amp;attre-&gt;mp_nexthop_global, s, 16);</a>
<a name="ln1723">      break;</a>
<a name="ln1724">    case 32:</a>
<a name="ln1725">    case 48:</a>
<a name="ln1726">      if (attre-&gt;mp_nexthop_len == 48) {</a>
<a name="ln1727">        u_int32_t rd_high __attribute__((unused));</a>
<a name="ln1728">        u_int32_t rd_low __attribute__((unused));</a>
<a name="ln1729"> </a>
<a name="ln1730">        rd_high = stream_getl (s);</a>
<a name="ln1731">        rd_low = stream_getl (s);</a>
<a name="ln1732">      }</a>
<a name="ln1733">      stream_get (&amp;attre-&gt;mp_nexthop_global, s, 16);</a>
<a name="ln1734"> </a>
<a name="ln1735">      if (attre-&gt;mp_nexthop_len == 48) {</a>
<a name="ln1736">        u_int32_t rd_high __attribute__((unused));</a>
<a name="ln1737">        u_int32_t rd_low __attribute__((unused));</a>
<a name="ln1738"> </a>
<a name="ln1739">        rd_high = stream_getl (s);</a>
<a name="ln1740">        rd_low = stream_getl (s);</a>
<a name="ln1741">      }</a>
<a name="ln1742">      stream_get (&amp;attre-&gt;mp_nexthop_local, s, 16);</a>
<a name="ln1743">      if (! IN6_IS_ADDR_LINKLOCAL (&amp;attre-&gt;mp_nexthop_local))</a>
<a name="ln1744">	{</a>
<a name="ln1745">	  char buf1[INET6_ADDRSTRLEN];</a>
<a name="ln1746">	  char buf2[INET6_ADDRSTRLEN];</a>
<a name="ln1747"> </a>
<a name="ln1748">	  if (BGP_DEBUG (update, UPDATE_IN))</a>
<a name="ln1749">	    zlog_debug (&quot;%s got two nexthop %s %s but second one is not a link-local nexthop&quot;, peer-&gt;host,</a>
<a name="ln1750">		       inet_ntop (AF_INET6, &amp;attre-&gt;mp_nexthop_global,</a>
<a name="ln1751">				  buf1, INET6_ADDRSTRLEN),</a>
<a name="ln1752">		       inet_ntop (AF_INET6, &amp;attre-&gt;mp_nexthop_local,</a>
<a name="ln1753">				  buf2, INET6_ADDRSTRLEN));</a>
<a name="ln1754"> </a>
<a name="ln1755">	  attre-&gt;mp_nexthop_len = 16;</a>
<a name="ln1756">	}</a>
<a name="ln1757">      break;</a>
<a name="ln1758">    default:</a>
<a name="ln1759">      zlog_info (&quot;%s: (%s) Wrong multiprotocol next hop length: %d&quot;, </a>
<a name="ln1760">		 __func__, peer-&gt;host, attre-&gt;mp_nexthop_len);</a>
<a name="ln1761">      return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;</a>
<a name="ln1762">    }</a>
<a name="ln1763"> </a>
<a name="ln1764">  if (!LEN_LEFT)</a>
<a name="ln1765">    {</a>
<a name="ln1766">      zlog_info (&quot;%s: (%s) Failed to read SNPA and NLRI(s)&quot;,</a>
<a name="ln1767">                 __func__, peer-&gt;host);</a>
<a name="ln1768">      return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;</a>
<a name="ln1769">    }</a>
<a name="ln1770">  </a>
<a name="ln1771">  {</a>
<a name="ln1772">    u_char val; </a>
<a name="ln1773">    if ((val = stream_getc (s)))</a>
<a name="ln1774">    zlog_warn (&quot;%s sent non-zero value, %u, for defunct SNPA-length field&quot;,</a>
<a name="ln1775">                peer-&gt;host, val);</a>
<a name="ln1776">  }</a>
<a name="ln1777">  </a>
<a name="ln1778">  /* must have nrli_len, what is left of the attribute */</a>
<a name="ln1779">  nlri_len = LEN_LEFT;</a>
<a name="ln1780">  if ((!nlri_len) || (nlri_len &gt; STREAM_READABLE(s)))</a>
<a name="ln1781">    {</a>
<a name="ln1782">      zlog_info (&quot;%s: (%s) Failed to read NLRI&quot;,</a>
<a name="ln1783">                 __func__, peer-&gt;host);</a>
<a name="ln1784">      return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;</a>
<a name="ln1785">    }</a>
<a name="ln1786">  </a>
<a name="ln1787">  mp_update-&gt;afi = afi;</a>
<a name="ln1788">  mp_update-&gt;safi = safi;</a>
<a name="ln1789">  mp_update-&gt;nlri = stream_pnt (s);</a>
<a name="ln1790">  mp_update-&gt;length = nlri_len;</a>
<a name="ln1791"> </a>
<a name="ln1792">  stream_forward_getp (s, nlri_len);</a>
<a name="ln1793"> </a>
<a name="ln1794">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_MP_REACH_NLRI);</a>
<a name="ln1795"> </a>
<a name="ln1796">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1797">#undef LEN_LEFT</a>
<a name="ln1798">}</a>
<a name="ln1799"> </a>
<a name="ln1800">/* Multiprotocol unreachable parse */</a>
<a name="ln1801">int</a>
<a name="ln1802">bgp_mp_unreach_parse (struct bgp_attr_parser_args *args,</a>
<a name="ln1803">		      struct bgp_nlri *mp_withdraw)</a>
<a name="ln1804">{</a>
<a name="ln1805">  struct stream *s;</a>
<a name="ln1806">  afi_t afi;</a>
<a name="ln1807">  safi_t safi;</a>
<a name="ln1808">  u_int16_t withdraw_len;</a>
<a name="ln1809">  struct peer *const peer = args-&gt;peer;  </a>
<a name="ln1810">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1811">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1812"> </a>
<a name="ln1813">  s = peer-&gt;ibuf;</a>
<a name="ln1814">  </a>
<a name="ln1815">#define BGP_MP_UNREACH_MIN_SIZE 3</a>
<a name="ln1816">  if ((length &gt; STREAM_READABLE(s)) || (length &lt;  BGP_MP_UNREACH_MIN_SIZE))</a>
<a name="ln1817">    return BGP_ATTR_PARSE_ERROR_NOTIFYPLS;</a>
<a name="ln1818">  </a>
<a name="ln1819">  afi = stream_getw (s);</a>
<a name="ln1820">  safi = stream_getc (s);</a>
<a name="ln1821">  </a>
<a name="ln1822">  withdraw_len = length - BGP_MP_UNREACH_MIN_SIZE;</a>
<a name="ln1823"> </a>
<a name="ln1824">  mp_withdraw-&gt;afi = afi;</a>
<a name="ln1825">  mp_withdraw-&gt;safi = safi;</a>
<a name="ln1826">  mp_withdraw-&gt;nlri = stream_pnt (s);</a>
<a name="ln1827">  mp_withdraw-&gt;length = withdraw_len;</a>
<a name="ln1828"> </a>
<a name="ln1829">  stream_forward_getp (s, withdraw_len);</a>
<a name="ln1830"> </a>
<a name="ln1831">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_MP_UNREACH_NLRI);</a>
<a name="ln1832"> </a>
<a name="ln1833">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1834">}</a>
<a name="ln1835"> </a>
<a name="ln1836">/* Large Community attribute. */</a>
<a name="ln1837">static bgp_attr_parse_ret_t</a>
<a name="ln1838">bgp_attr_large_community (struct bgp_attr_parser_args *args)</a>
<a name="ln1839">{</a>
<a name="ln1840">  struct peer *const peer = args-&gt;peer;</a>
<a name="ln1841">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln1842">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1843"> </a>
<a name="ln1844">  if (length == 0)</a>
<a name="ln1845">    {</a>
<a name="ln1846">      if (attr-&gt;extra)</a>
<a name="ln1847">        attr-&gt;extra-&gt;lcommunity = NULL;</a>
<a name="ln1848">      /* Empty extcomm doesn't seem to be invalid per se */</a>
<a name="ln1849">      return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1850">    }</a>
<a name="ln1851"> </a>
<a name="ln1852">  (bgp_attr_extra_get (attr))-&gt;lcommunity =</a>
<a name="ln1853">    lcommunity_parse ((u_int8_t *)stream_pnt (peer-&gt;ibuf), length);</a>
<a name="ln1854">  /* XXX: fix ecommunity_parse to use stream API */</a>
<a name="ln1855">  stream_forward_getp (peer-&gt;ibuf, length);</a>
<a name="ln1856"> </a>
<a name="ln1857">  if (attr-&gt;extra &amp;&amp; !attr-&gt;extra-&gt;lcommunity)</a>
<a name="ln1858">    return bgp_attr_malformed (args,</a>
<a name="ln1859">                               BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,</a>
<a name="ln1860">                               args-&gt;total);</a>
<a name="ln1861"> </a>
<a name="ln1862">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_LARGE_COMMUNITIES);</a>
<a name="ln1863"> </a>
<a name="ln1864">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1865">}</a>
<a name="ln1866"> </a>
<a name="ln1867">/* Extended Community attribute. */</a>
<a name="ln1868">static bgp_attr_parse_ret_t</a>
<a name="ln1869">bgp_attr_ext_communities (struct bgp_attr_parser_args *args)</a>
<a name="ln1870">{</a>
<a name="ln1871">  struct peer *const peer = args-&gt;peer;  </a>
<a name="ln1872">  struct attr *const attr = args-&gt;attr;  </a>
<a name="ln1873">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln1874">  </a>
<a name="ln1875">  if (length == 0)</a>
<a name="ln1876">    {</a>
<a name="ln1877">      if (attr-&gt;extra)</a>
<a name="ln1878">        attr-&gt;extra-&gt;ecommunity = NULL;</a>
<a name="ln1879">      /* Empty extcomm doesn't seem to be invalid per se */</a>
<a name="ln1880">      return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1881">    }</a>
<a name="ln1882"> </a>
<a name="ln1883">  (bgp_attr_extra_get (attr))-&gt;ecommunity =</a>
<a name="ln1884">    ecommunity_parse ((u_int8_t *)stream_pnt (peer-&gt;ibuf), length);</a>
<a name="ln1885">  /* XXX: fix ecommunity_parse to use stream API */</a>
<a name="ln1886">  stream_forward_getp (peer-&gt;ibuf, length);</a>
<a name="ln1887">  </a>
<a name="ln1888">  if (attr-&gt;extra &amp;&amp; !attr-&gt;extra-&gt;ecommunity)</a>
<a name="ln1889">    return bgp_attr_malformed (args,</a>
<a name="ln1890">                               BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,</a>
<a name="ln1891">                               args-&gt;total);</a>
<a name="ln1892">  </a>
<a name="ln1893">  attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);</a>
<a name="ln1894"> </a>
<a name="ln1895">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln1896">}</a>
<a name="ln1897"> </a>
<a name="ln1898">/* Parse Tunnel Encap attribute in an UPDATE */</a>
<a name="ln1899">static int</a>
<a name="ln1900">bgp_attr_encap(</a>
<a name="ln1901">  uint8_t	type,</a>
<a name="ln1902">  struct peer	*peer,	/* IN */</a>
<a name="ln1903">  bgp_size_t	length,	/* IN: attr's length field */</a>
<a name="ln1904">  struct attr	*attr,	/* IN: caller already allocated */</a>
<a name="ln1905">  u_char	flag,	/* IN: attr's flags field */</a>
<a name="ln1906">  u_char	*startp)</a>
<a name="ln1907">{</a>
<a name="ln1908">  bgp_size_t			total;</a>
<a name="ln1909">  struct attr_extra		*attre = NULL;</a>
<a name="ln1910">  struct bgp_attr_encap_subtlv	*stlv_last = NULL;</a>
<a name="ln1911">  uint16_t			tunneltype;</a>
<a name="ln1912"> </a>
<a name="ln1913">  total = length + (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN) ? 4 : 3);</a>
<a name="ln1914"> </a>
<a name="ln1915">  if (!CHECK_FLAG(flag, BGP_ATTR_FLAG_TRANS)</a>
<a name="ln1916">       || !CHECK_FLAG(flag, BGP_ATTR_FLAG_OPTIONAL))</a>
<a name="ln1917">    {</a>
<a name="ln1918">      zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln1919">	    &quot;Tunnel Encap attribute flag isn't optional and transitive %d&quot;, flag);</a>
<a name="ln1920">      bgp_notify_send_with_data (peer,</a>
<a name="ln1921">				 BGP_NOTIFY_UPDATE_ERR,</a>
<a name="ln1922">				 BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,</a>
<a name="ln1923">				 startp, total);</a>
<a name="ln1924">      return -1;</a>
<a name="ln1925">    }</a>
<a name="ln1926"> </a>
<a name="ln1927">  if (BGP_ATTR_ENCAP == type) {</a>
<a name="ln1928">    /* read outer TLV type and length */</a>
<a name="ln1929">    uint16_t	tlv_length;</a>
<a name="ln1930"> </a>
<a name="ln1931">    if (length &lt; 4) {</a>
<a name="ln1932">	zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln1933">	    &quot;Tunnel Encap attribute not long enough to contain outer T,L&quot;);</a>
<a name="ln1934">	bgp_notify_send_with_data(peer,</a>
<a name="ln1935">				 BGP_NOTIFY_UPDATE_ERR,</a>
<a name="ln1936">				 BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,</a>
<a name="ln1937">				 startp, total);</a>
<a name="ln1938">	return -1;</a>
<a name="ln1939">    }</a>
<a name="ln1940">    tunneltype = stream_getw (BGP_INPUT (peer));</a>
<a name="ln1941">    tlv_length = stream_getw (BGP_INPUT (peer));</a>
<a name="ln1942">    length -= 4;</a>
<a name="ln1943"> </a>
<a name="ln1944">    if (tlv_length != length) {</a>
<a name="ln1945">	zlog (peer-&gt;log, LOG_ERR, &quot;%s: tlv_length(%d) != length(%d)&quot;,</a>
<a name="ln1946">	    __func__, tlv_length, length);</a>
<a name="ln1947">    }</a>
<a name="ln1948">  }</a>
<a name="ln1949"> </a>
<a name="ln1950">  while (length &gt;= 4) {</a>
<a name="ln1951">    uint16_t	subtype = 0;</a>
<a name="ln1952">    uint16_t	sublength = 0;</a>
<a name="ln1953">    struct bgp_attr_encap_subtlv *tlv;</a>
<a name="ln1954"> </a>
<a name="ln1955">    if (BGP_ATTR_ENCAP == type) {</a>
<a name="ln1956">        subtype   = stream_getc (BGP_INPUT (peer));</a>
<a name="ln1957">        sublength = stream_getc (BGP_INPUT (peer));</a>
<a name="ln1958">        length   -= 2;</a>
<a name="ln1959">    }</a>
<a name="ln1960"> </a>
<a name="ln1961">    if (sublength &gt; length) {</a>
<a name="ln1962">      zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln1963">	    &quot;Tunnel Encap attribute sub-tlv length %d exceeds remaining length %d&quot;,</a>
<a name="ln1964">	    sublength, length);</a>
<a name="ln1965">      bgp_notify_send_with_data (peer,</a>
<a name="ln1966">				 BGP_NOTIFY_UPDATE_ERR,</a>
<a name="ln1967">				 BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,</a>
<a name="ln1968">				 startp, total);</a>
<a name="ln1969">      return -1;</a>
<a name="ln1970">    }</a>
<a name="ln1971"> </a>
<a name="ln1972">    /* alloc and copy sub-tlv */</a>
<a name="ln1973">    /* TBD make sure these are freed when attributes are released */</a>
<a name="ln1974">    tlv = XCALLOC (MTYPE_ENCAP_TLV, sizeof(struct bgp_attr_encap_subtlv)-1+sublength);</a>
<a name="ln1975">    tlv-&gt;type = subtype;</a>
<a name="ln1976">    tlv-&gt;length = sublength;</a>
<a name="ln1977">    stream_get(tlv-&gt;value, peer-&gt;ibuf, sublength);</a>
<a name="ln1978">    length -= sublength;</a>
<a name="ln1979"> </a>
<a name="ln1980">    /* attach tlv to encap chain */</a>
<a name="ln1981">    if (!attre) {</a>
<a name="ln1982">	attre = bgp_attr_extra_get(attr);</a>
<a name="ln1983">	if (BGP_ATTR_ENCAP == type) {</a>
<a name="ln1984">	    for (stlv_last = attre-&gt;encap_subtlvs; stlv_last &amp;&amp; stlv_last-&gt;next;</a>
<a name="ln1985">		stlv_last = stlv_last-&gt;next);</a>
<a name="ln1986">	    if (stlv_last) {</a>
<a name="ln1987">		stlv_last-&gt;next = tlv;</a>
<a name="ln1988">	    } else {</a>
<a name="ln1989">		attre-&gt;encap_subtlvs = tlv;</a>
<a name="ln1990">	    }</a>
<a name="ln1991">	}</a>
<a name="ln1992">    } else {</a>
<a name="ln1993">	stlv_last-&gt;next = tlv;</a>
<a name="ln1994">    }</a>
<a name="ln1995">    stlv_last = tlv;</a>
<a name="ln1996">  }</a>
<a name="ln1997"> </a>
<a name="ln1998">  if (attre &amp;&amp; (BGP_ATTR_ENCAP == type)) {</a>
<a name="ln1999">      attre-&gt;encap_tunneltype = tunneltype;</a>
<a name="ln2000">  }</a>
<a name="ln2001"> </a>
<a name="ln2002">  if (length) {</a>
<a name="ln2003">    /* spurious leftover data */</a>
<a name="ln2004">      zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln2005">	    &quot;Tunnel Encap attribute length is bad: %d leftover octets&quot;, length);</a>
<a name="ln2006">      bgp_notify_send_with_data (peer,</a>
<a name="ln2007">				 BGP_NOTIFY_UPDATE_ERR,</a>
<a name="ln2008">				 BGP_NOTIFY_UPDATE_OPT_ATTR_ERR,</a>
<a name="ln2009">				 startp, total);</a>
<a name="ln2010">      return -1;</a>
<a name="ln2011">  }</a>
<a name="ln2012"> </a>
<a name="ln2013">  return 0;</a>
<a name="ln2014">}</a>
<a name="ln2015"> </a>
<a name="ln2016">/* BGP unknown attribute treatment. */</a>
<a name="ln2017">static bgp_attr_parse_ret_t</a>
<a name="ln2018">bgp_attr_unknown (struct bgp_attr_parser_args *args)</a>
<a name="ln2019">{</a>
<a name="ln2020">  bgp_size_t total = args-&gt;total;</a>
<a name="ln2021">  struct transit *transit;</a>
<a name="ln2022">  struct attr_extra *attre;</a>
<a name="ln2023">  struct peer *const peer = args-&gt;peer; </a>
<a name="ln2024">  struct attr *const attr = args-&gt;attr;</a>
<a name="ln2025">  u_char *const startp = args-&gt;startp;</a>
<a name="ln2026">  const u_char type = args-&gt;type;</a>
<a name="ln2027">  const u_char flag = args-&gt;flags;  </a>
<a name="ln2028">  const bgp_size_t length = args-&gt;length;</a>
<a name="ln2029">  </a>
<a name="ln2030"> </a>
<a name="ln2031">  if (BGP_DEBUG (normal, NORMAL))</a>
<a name="ln2032">  zlog_debug (&quot;%s Unknown attribute is received (type %d, length %d)&quot;,</a>
<a name="ln2033">	      peer-&gt;host, type, length);</a>
<a name="ln2034">  </a>
<a name="ln2035">  if (BGP_DEBUG (events, EVENTS))</a>
<a name="ln2036">    zlog (peer-&gt;log, LOG_DEBUG, </a>
<a name="ln2037">	  &quot;Unknown attribute type %d length %d is received&quot;, type, length);</a>
<a name="ln2038"> </a>
<a name="ln2039">  /* Forward read pointer of input stream. */</a>
<a name="ln2040">  stream_forward_getp (peer-&gt;ibuf, length);</a>
<a name="ln2041"> </a>
<a name="ln2042">  /* If any of the mandatory well-known attributes are not recognized,</a>
<a name="ln2043">     then the Error Subcode is set to Unrecognized Well-known</a>
<a name="ln2044">     Attribute.  The Data field contains the unrecognized attribute</a>
<a name="ln2045">     (type, length and value). */</a>
<a name="ln2046">  if (!CHECK_FLAG (flag, BGP_ATTR_FLAG_OPTIONAL))</a>
<a name="ln2047">    {</a>
<a name="ln2048">      return bgp_attr_malformed (args,</a>
<a name="ln2049">                                 BGP_NOTIFY_UPDATE_UNREC_ATTR,</a>
<a name="ln2050">                                 args-&gt;total);</a>
<a name="ln2051">    }</a>
<a name="ln2052"> </a>
<a name="ln2053">  /* Unrecognized non-transitive optional attributes must be quietly</a>
<a name="ln2054">     ignored and not passed along to other BGP peers. */</a>
<a name="ln2055">  if (! CHECK_FLAG (flag, BGP_ATTR_FLAG_TRANS))</a>
<a name="ln2056">    return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln2057"> </a>
<a name="ln2058">  /* If a path with recognized transitive optional attribute is</a>
<a name="ln2059">     accepted and passed along to other BGP peers and the Partial bit</a>
<a name="ln2060">     in the Attribute Flags octet is set to 1 by some previous AS, it</a>
<a name="ln2061">     is not set back to 0 by the current AS. */</a>
<a name="ln2062">  SET_FLAG (*startp, BGP_ATTR_FLAG_PARTIAL);</a>
<a name="ln2063"> </a>
<a name="ln2064">  /* Store transitive attribute to the end of attr-&gt;transit. */</a>
<a name="ln2065">  if (! ((attre = bgp_attr_extra_get(attr))-&gt;transit) )</a>
<a name="ln2066">      attre-&gt;transit = XCALLOC (MTYPE_TRANSIT, sizeof (struct transit));</a>
<a name="ln2067"> </a>
<a name="ln2068">  transit = attre-&gt;transit;</a>
<a name="ln2069"> </a>
<a name="ln2070">  if (transit-&gt;val)</a>
<a name="ln2071">    transit-&gt;val = XREALLOC (MTYPE_TRANSIT_VAL, transit-&gt;val, </a>
<a name="ln2072">			     transit-&gt;length + total);</a>
<a name="ln2073">  else</a>
<a name="ln2074">    transit-&gt;val = XMALLOC (MTYPE_TRANSIT_VAL, total);</a>
<a name="ln2075"> </a>
<a name="ln2076">  memcpy (transit-&gt;val + transit-&gt;length, startp, total);</a>
<a name="ln2077">  transit-&gt;length += total;</a>
<a name="ln2078"> </a>
<a name="ln2079">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln2080">}</a>
<a name="ln2081"> </a>
<a name="ln2082">/* Well-known attribute check. */</a>
<a name="ln2083">static int</a>
<a name="ln2084">bgp_attr_check (struct peer *peer, struct attr *attr)</a>
<a name="ln2085">{</a>
<a name="ln2086">  u_char type = 0;</a>
<a name="ln2087">  </a>
<a name="ln2088">  /* BGP Graceful-Restart End-of-RIB for IPv4 unicast is signaled as an</a>
<a name="ln2089">   * empty UPDATE.  */</a>
<a name="ln2090">  if (CHECK_FLAG (peer-&gt;cap, PEER_CAP_RESTART_RCV) &amp;&amp; !attr-&gt;flag)</a>
<a name="ln2091">    return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln2092">  </a>
<a name="ln2093">  /* &quot;An UPDATE message that contains the MP_UNREACH_NLRI is not required</a>
<a name="ln2094">     to carry any other path attributes.&quot;, though if MP_REACH_NLRI or NLRI</a>
<a name="ln2095">     are present, it should.  Check for any other attribute being present</a>
<a name="ln2096">     instead.</a>
<a name="ln2097">   */</a>
<a name="ln2098">  if (attr-&gt;flag == ATTR_FLAG_BIT (BGP_ATTR_MP_UNREACH_NLRI))</a>
<a name="ln2099">    return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln2100">  </a>
<a name="ln2101">  if (! CHECK_FLAG (attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_ORIGIN)))</a>
<a name="ln2102">    type = BGP_ATTR_ORIGIN;</a>
<a name="ln2103"> </a>
<a name="ln2104">  if (! CHECK_FLAG (attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_AS_PATH)))</a>
<a name="ln2105">    type = BGP_ATTR_AS_PATH;</a>
<a name="ln2106">  </a>
<a name="ln2107">  /* RFC 2858 makes Next-Hop optional/ignored, if MP_REACH_NLRI is present and</a>
<a name="ln2108">   * NLRI is empty. We can't easily check NLRI empty here though.</a>
<a name="ln2109">   */</a>
<a name="ln2110">  if (!CHECK_FLAG (attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP))</a>
<a name="ln2111">      &amp;&amp; !CHECK_FLAG (attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_MP_REACH_NLRI)))</a>
<a name="ln2112">    type = BGP_ATTR_NEXT_HOP;</a>
<a name="ln2113">  </a>
<a name="ln2114">  if (peer-&gt;sort == BGP_PEER_IBGP</a>
<a name="ln2115">      &amp;&amp; ! CHECK_FLAG (attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF)))</a>
<a name="ln2116">    type = BGP_ATTR_LOCAL_PREF;</a>
<a name="ln2117"> </a>
<a name="ln2118">  if (type)</a>
<a name="ln2119">    {</a>
<a name="ln2120">      zlog (peer-&gt;log, LOG_WARNING, </a>
<a name="ln2121">	    &quot;%s Missing well-known attribute %d / %s&quot;,</a>
<a name="ln2122">	    peer-&gt;host, type, LOOKUP (attr_str, type));</a>
<a name="ln2123">      bgp_notify_send_with_data (peer, </a>
<a name="ln2124">				 BGP_NOTIFY_UPDATE_ERR, </a>
<a name="ln2125">				 BGP_NOTIFY_UPDATE_MISS_ATTR,</a>
<a name="ln2126">				 &amp;type, 1);</a>
<a name="ln2127">      return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln2128">    }</a>
<a name="ln2129">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln2130">}</a>
<a name="ln2131"> </a>
<a name="ln2132">/* Read attribute of update packet.  This function is called from</a>
<a name="ln2133">   bgp_update_receive() in bgp_packet.c.  */</a>
<a name="ln2134">bgp_attr_parse_ret_t</a>
<a name="ln2135">bgp_attr_parse (struct peer *peer, struct attr *attr, bgp_size_t size,</a>
<a name="ln2136">		struct bgp_nlri *mp_update, struct bgp_nlri *mp_withdraw)</a>
<a name="ln2137">{</a>
<a name="ln2138">  int ret;</a>
<a name="ln2139">  u_char flag = 0;</a>
<a name="ln2140">  u_char type = 0;</a>
<a name="ln2141">  bgp_size_t length;</a>
<a name="ln2142">  u_char *startp, *endp;</a>
<a name="ln2143">  u_char *attr_endp;</a>
<a name="ln2144">  u_char seen[BGP_ATTR_BITMAP_SIZE];</a>
<a name="ln2145">  /* we need the as4_path only until we have synthesized the as_path with it */</a>
<a name="ln2146">  /* same goes for as4_aggregator */</a>
<a name="ln2147">  struct aspath *as4_path = NULL;</a>
<a name="ln2148">  as_t as4_aggregator = 0;</a>
<a name="ln2149">  struct in_addr as4_aggregator_addr = { .s_addr = 0 };</a>
<a name="ln2150"> </a>
<a name="ln2151">  /* Initialize bitmap. */</a>
<a name="ln2152">  memset (seen, 0, BGP_ATTR_BITMAP_SIZE);</a>
<a name="ln2153"> </a>
<a name="ln2154">  /* End pointer of BGP attribute. */</a>
<a name="ln2155">  assert (size &lt;= stream_get_size (BGP_INPUT (peer)));</a>
<a name="ln2156">  assert (size &lt;= stream_get_endp (BGP_INPUT (peer)));</a>
<a name="ln2157">  endp = BGP_INPUT_PNT (peer) + size;</a>
<a name="ln2158">  </a>
<a name="ln2159">  /* Get attributes to the end of attribute length. */</a>
<a name="ln2160">  while (BGP_INPUT_PNT (peer) &lt; endp)</a>
<a name="ln2161">    {</a>
<a name="ln2162">      /* Check remaining length check.*/</a>
<a name="ln2163">      if (endp - BGP_INPUT_PNT (peer) &lt; BGP_ATTR_MIN_LEN)</a>
<a name="ln2164">	{</a>
<a name="ln2165">	  /* XXX warning: long int format, int arg (arg 5) */</a>
<a name="ln2166">	  zlog (peer-&gt;log, LOG_WARNING, </a>
<a name="ln2167">		&quot;%s: error BGP attribute length %lu is smaller than min len&quot;,</a>
<a name="ln2168">		peer-&gt;host,</a>
<a name="ln2169">		(unsigned long) (endp - STREAM_PNT (BGP_INPUT (peer))));</a>
<a name="ln2170"> </a>
<a name="ln2171">	  bgp_notify_send (peer, </a>
<a name="ln2172">			   BGP_NOTIFY_UPDATE_ERR, </a>
<a name="ln2173">			   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);</a>
<a name="ln2174">	  return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln2175">	}</a>
<a name="ln2176"> </a>
<a name="ln2177">      /* Fetch attribute flag and type. */</a>
<a name="ln2178">      startp = BGP_INPUT_PNT (peer);</a>
<a name="ln2179">      /* &quot;The lower-order four bits of the Attribute Flags octet are</a>
<a name="ln2180">         unused.  They MUST be zero when sent and MUST be ignored when</a>
<a name="ln2181">         received.&quot; */</a>
<a name="ln2182">      flag = 0xF0 &amp; stream_getc (BGP_INPUT (peer));</a>
<a name="ln2183">      type = stream_getc (BGP_INPUT (peer));</a>
<a name="ln2184"> </a>
<a name="ln2185">      /* Check whether Extended-Length applies and is in bounds */</a>
<a name="ln2186">      if (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN)</a>
<a name="ln2187">          &amp;&amp; ((endp - startp) &lt; (BGP_ATTR_MIN_LEN + 1)))</a>
<a name="ln2188">	{</a>
<a name="ln2189">	  zlog (peer-&gt;log, LOG_WARNING, </a>
<a name="ln2190">		&quot;%s: Extended length set, but just %lu bytes of attr header&quot;,</a>
<a name="ln2191">		peer-&gt;host,</a>
<a name="ln2192">		(unsigned long) (endp - STREAM_PNT (BGP_INPUT (peer))));</a>
<a name="ln2193"> </a>
<a name="ln2194">	  bgp_notify_send (peer, </a>
<a name="ln2195">			   BGP_NOTIFY_UPDATE_ERR, </a>
<a name="ln2196">			   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);</a>
<a name="ln2197">	  return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln2198">	}</a>
<a name="ln2199">      </a>
<a name="ln2200">      /* Check extended attribue length bit. */</a>
<a name="ln2201">      if (CHECK_FLAG (flag, BGP_ATTR_FLAG_EXTLEN))</a>
<a name="ln2202">	length = stream_getw (BGP_INPUT (peer));</a>
<a name="ln2203">      else</a>
<a name="ln2204">	length = stream_getc (BGP_INPUT (peer));</a>
<a name="ln2205">      </a>
<a name="ln2206">      /* If any attribute appears more than once in the UPDATE</a>
<a name="ln2207">	 message, then the Error Subcode is set to Malformed Attribute</a>
<a name="ln2208">	 List. */</a>
<a name="ln2209"> </a>
<a name="ln2210">      if (CHECK_BITMAP (seen, type))</a>
<a name="ln2211">	{</a>
<a name="ln2212">	  zlog (peer-&gt;log, LOG_WARNING,</a>
<a name="ln2213">		&quot;%s: error BGP attribute type %d appears twice in a message&quot;,</a>
<a name="ln2214">		peer-&gt;host, type);</a>
<a name="ln2215"> </a>
<a name="ln2216">	  bgp_notify_send (peer, </a>
<a name="ln2217">			   BGP_NOTIFY_UPDATE_ERR, </a>
<a name="ln2218">			   BGP_NOTIFY_UPDATE_MAL_ATTR);</a>
<a name="ln2219">	  return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln2220">	}</a>
<a name="ln2221"> </a>
<a name="ln2222">      /* Set type to bitmap to check duplicate attribute.  `type' is</a>
<a name="ln2223">	 unsigned char so it never overflow bitmap range. */</a>
<a name="ln2224"> </a>
<a name="ln2225">      SET_BITMAP (seen, type);</a>
<a name="ln2226"> </a>
<a name="ln2227">      /* Overflow check. */</a>
<a name="ln2228">      attr_endp =  BGP_INPUT_PNT (peer) + length;</a>
<a name="ln2229"> </a>
<a name="ln2230">      if (attr_endp &gt; endp)</a>
<a name="ln2231">	{</a>
<a name="ln2232">	  zlog (peer-&gt;log, LOG_WARNING, </a>
<a name="ln2233">		&quot;%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p&quot;, peer-&gt;host, type, length, size, attr_endp, endp);</a>
<a name="ln2234">	  zlog_warn (&quot;%s: BGP type %d length %d is too large, attribute total length is %d.  attr_endp is %p.  endp is %p&quot;, peer-&gt;host, type, length, size, attr_endp, endp);</a>
<a name="ln2235">          bgp_notify_send_with_data (peer,</a>
<a name="ln2236">                                     BGP_NOTIFY_UPDATE_ERR,</a>
<a name="ln2237">                                     BGP_NOTIFY_UPDATE_ATTR_LENG_ERR,</a>
<a name="ln2238">                                     startp, endp - startp);</a>
<a name="ln2239">	  return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln2240">	}</a>
<a name="ln2241">	</a>
<a name="ln2242">        struct bgp_attr_parser_args attr_args = {</a>
<a name="ln2243">          .peer = peer,</a>
<a name="ln2244">          .length = length,</a>
<a name="ln2245">          .attr = attr,</a>
<a name="ln2246">          .type = type,</a>
<a name="ln2247">          .flags = flag,</a>
<a name="ln2248">          .startp = startp,</a>
<a name="ln2249">          .total = attr_endp - startp,</a>
<a name="ln2250">        };</a>
<a name="ln2251">      </a>
<a name="ln2252">	</a>
<a name="ln2253">      /* If any recognized attribute has Attribute Flags that conflict</a>
<a name="ln2254">         with the Attribute Type Code, then the Error Subcode is set to</a>
<a name="ln2255">         Attribute Flags Error.  The Data field contains the erroneous</a>
<a name="ln2256">         attribute (type, length and value). */</a>
<a name="ln2257">      if (bgp_attr_flag_invalid (&amp;attr_args))</a>
<a name="ln2258">        {</a>
<a name="ln2259">          bgp_attr_parse_ret_t ret;</a>
<a name="ln2260">          ret = bgp_attr_malformed (&amp;attr_args,</a>
<a name="ln2261">                                    BGP_NOTIFY_UPDATE_ATTR_FLAG_ERR,</a>
<a name="ln2262">                                    attr_args.total);</a>
<a name="ln2263">          if (ret == BGP_ATTR_PARSE_PROCEED)</a>
<a name="ln2264">            continue;</a>
<a name="ln2265">          return ret;</a>
<a name="ln2266">        }</a>
<a name="ln2267"> </a>
<a name="ln2268">      /* OK check attribute and store it's value. */</a>
<a name="ln2269">      switch (type)</a>
<a name="ln2270">	{</a>
<a name="ln2271">	case BGP_ATTR_ORIGIN:</a>
<a name="ln2272">	  ret = bgp_attr_origin (&amp;attr_args);</a>
<a name="ln2273">	  break;</a>
<a name="ln2274">	case BGP_ATTR_AS_PATH:</a>
<a name="ln2275">	  ret = bgp_attr_aspath (&amp;attr_args);</a>
<a name="ln2276">	  break;</a>
<a name="ln2277">	case BGP_ATTR_AS4_PATH:</a>
<a name="ln2278">	  ret = bgp_attr_as4_path (&amp;attr_args, &amp;as4_path);</a>
<a name="ln2279">	  break;</a>
<a name="ln2280">	case BGP_ATTR_NEXT_HOP:	</a>
<a name="ln2281">	  ret = bgp_attr_nexthop (&amp;attr_args);</a>
<a name="ln2282">	  break;</a>
<a name="ln2283">	case BGP_ATTR_MULTI_EXIT_DISC:</a>
<a name="ln2284">	  ret = bgp_attr_med (&amp;attr_args);</a>
<a name="ln2285">	  break;</a>
<a name="ln2286">	case BGP_ATTR_LOCAL_PREF:</a>
<a name="ln2287">	  ret = bgp_attr_local_pref (&amp;attr_args);</a>
<a name="ln2288">	  break;</a>
<a name="ln2289">	case BGP_ATTR_ATOMIC_AGGREGATE:</a>
<a name="ln2290">	  ret = bgp_attr_atomic (&amp;attr_args);</a>
<a name="ln2291">	  break;</a>
<a name="ln2292">	case BGP_ATTR_AGGREGATOR:</a>
<a name="ln2293">	  ret = bgp_attr_aggregator (&amp;attr_args);</a>
<a name="ln2294">	  break;</a>
<a name="ln2295">	case BGP_ATTR_AS4_AGGREGATOR:</a>
<a name="ln2296">	  ret = bgp_attr_as4_aggregator (&amp;attr_args,</a>
<a name="ln2297">	                                 &amp;as4_aggregator,</a>
<a name="ln2298">	                                 &amp;as4_aggregator_addr);</a>
<a name="ln2299">	  break;</a>
<a name="ln2300">	case BGP_ATTR_COMMUNITIES:</a>
<a name="ln2301">	  ret = bgp_attr_community (&amp;attr_args);</a>
<a name="ln2302">	  break;</a>
<a name="ln2303">	case BGP_ATTR_LARGE_COMMUNITIES:</a>
<a name="ln2304">	  ret = bgp_attr_large_community (&amp;attr_args);</a>
<a name="ln2305">	  break;</a>
<a name="ln2306">	case BGP_ATTR_ORIGINATOR_ID:</a>
<a name="ln2307">	  ret = bgp_attr_originator_id (&amp;attr_args);</a>
<a name="ln2308">	  break;</a>
<a name="ln2309">	case BGP_ATTR_CLUSTER_LIST:</a>
<a name="ln2310">	  ret = bgp_attr_cluster_list (&amp;attr_args);</a>
<a name="ln2311">	  break;</a>
<a name="ln2312">	case BGP_ATTR_MP_REACH_NLRI:</a>
<a name="ln2313">	  ret = bgp_mp_reach_parse (&amp;attr_args, mp_update);</a>
<a name="ln2314">	  break;</a>
<a name="ln2315">	case BGP_ATTR_MP_UNREACH_NLRI:</a>
<a name="ln2316">	  ret = bgp_mp_unreach_parse (&amp;attr_args, mp_withdraw);</a>
<a name="ln2317">	  break;</a>
<a name="ln2318">	case BGP_ATTR_EXT_COMMUNITIES:</a>
<a name="ln2319">	  ret = bgp_attr_ext_communities (&amp;attr_args);</a>
<a name="ln2320">	  break;</a>
<a name="ln2321">        case BGP_ATTR_ENCAP:</a>
<a name="ln2322">          ret = bgp_attr_encap (type, peer, length, attr, flag, startp);</a>
<a name="ln2323">          break;</a>
<a name="ln2324">	default:</a>
<a name="ln2325">	  ret = bgp_attr_unknown (&amp;attr_args);</a>
<a name="ln2326">	  break;</a>
<a name="ln2327">	}</a>
<a name="ln2328">      </a>
<a name="ln2329">      if (ret == BGP_ATTR_PARSE_ERROR_NOTIFYPLS)</a>
<a name="ln2330">	{</a>
<a name="ln2331">	  bgp_notify_send (peer, </a>
<a name="ln2332">			   BGP_NOTIFY_UPDATE_ERR,</a>
<a name="ln2333">			   BGP_NOTIFY_UPDATE_MAL_ATTR);</a>
<a name="ln2334">	  ret = BGP_ATTR_PARSE_ERROR;</a>
<a name="ln2335">	}</a>
<a name="ln2336"> </a>
<a name="ln2337">      /* If hard error occurred immediately return to the caller. */</a>
<a name="ln2338">      if (ret == BGP_ATTR_PARSE_ERROR)</a>
<a name="ln2339">        {</a>
<a name="ln2340">          zlog (peer-&gt;log, LOG_WARNING,</a>
<a name="ln2341">                &quot;%s: Attribute %s, parse error&quot;, </a>
<a name="ln2342">                peer-&gt;host, </a>
<a name="ln2343">                LOOKUP (attr_str, type));</a>
<a name="ln2344">          if (as4_path)</a>
<a name="ln2345">            aspath_unintern (&amp;as4_path);</a>
<a name="ln2346">          return ret;</a>
<a name="ln2347">        }</a>
<a name="ln2348">      if (ret == BGP_ATTR_PARSE_WITHDRAW)</a>
<a name="ln2349">        {</a>
<a name="ln2350">          </a>
<a name="ln2351">          zlog (peer-&gt;log, LOG_WARNING,</a>
<a name="ln2352">                &quot;%s: Attribute %s, parse error - treating as withdrawal&quot;,</a>
<a name="ln2353">                peer-&gt;host,</a>
<a name="ln2354">                LOOKUP (attr_str, type));</a>
<a name="ln2355">          if (as4_path)</a>
<a name="ln2356">            aspath_unintern (&amp;as4_path);</a>
<a name="ln2357">          return ret;</a>
<a name="ln2358">        }</a>
<a name="ln2359">      </a>
<a name="ln2360">      /* Check the fetched length. */</a>
<a name="ln2361">      if (BGP_INPUT_PNT (peer) != attr_endp)</a>
<a name="ln2362">	{</a>
<a name="ln2363">	  zlog (peer-&gt;log, LOG_WARNING, </a>
<a name="ln2364">		&quot;%s: BGP attribute %s, fetch error&quot;, </a>
<a name="ln2365">                peer-&gt;host, LOOKUP (attr_str, type));</a>
<a name="ln2366">	  bgp_notify_send (peer, </a>
<a name="ln2367">			   BGP_NOTIFY_UPDATE_ERR, </a>
<a name="ln2368">			   BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);</a>
<a name="ln2369">          if (as4_path)</a>
<a name="ln2370">            aspath_unintern (&amp;as4_path);</a>
<a name="ln2371">	  return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln2372">	}</a>
<a name="ln2373">    }</a>
<a name="ln2374">  /* Check final read pointer is same as end pointer. */</a>
<a name="ln2375">  if (BGP_INPUT_PNT (peer) != endp)</a>
<a name="ln2376">    {</a>
<a name="ln2377">      zlog (peer-&gt;log, LOG_WARNING, </a>
<a name="ln2378">	    &quot;%s: BGP attribute %s, length mismatch&quot;,</a>
<a name="ln2379">	    peer-&gt;host, LOOKUP (attr_str, type));</a>
<a name="ln2380">      bgp_notify_send (peer, </a>
<a name="ln2381">		       BGP_NOTIFY_UPDATE_ERR, </a>
<a name="ln2382">		       BGP_NOTIFY_UPDATE_ATTR_LENG_ERR);</a>
<a name="ln2383">      if (as4_path)</a>
<a name="ln2384">        aspath_unintern (&amp;as4_path);</a>
<a name="ln2385">      return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln2386">    }</a>
<a name="ln2387">  </a>
<a name="ln2388">  /* Check all mandatory well-known attributes are present */</a>
<a name="ln2389">  {</a>
<a name="ln2390">    bgp_attr_parse_ret_t ret;</a>
<a name="ln2391">    if ((ret = bgp_attr_check (peer, attr)) &lt; 0)</a>
<a name="ln2392">      {</a>
<a name="ln2393">        if (as4_path)</a>
<a name="ln2394">          aspath_unintern (&amp;as4_path);</a>
<a name="ln2395">        return ret;</a>
<a name="ln2396">      }</a>
<a name="ln2397">  }</a>
<a name="ln2398">  </a>
<a name="ln2399">  /* </a>
<a name="ln2400">   * At this place we can see whether we got AS4_PATH and/or</a>
<a name="ln2401">   * AS4_AGGREGATOR from a 16Bit peer and act accordingly.</a>
<a name="ln2402">   * We can not do this before we've read all attributes because</a>
<a name="ln2403">   * the as4 handling does not say whether AS4_PATH has to be sent</a>
<a name="ln2404">   * after AS_PATH or not - and when AS4_AGGREGATOR will be send</a>
<a name="ln2405">   * in relationship to AGGREGATOR.</a>
<a name="ln2406">   * So, to be defensive, we are not relying on any order and read</a>
<a name="ln2407">   * all attributes first, including these 32bit ones, and now,</a>
<a name="ln2408">   * afterwards, we look what and if something is to be done for as4.</a>
<a name="ln2409">   *</a>
<a name="ln2410">   * It is possible to not have AS_PATH, e.g. GR EoR and sole</a>
<a name="ln2411">   * MP_UNREACH_NLRI.</a>
<a name="ln2412">   */</a>
<a name="ln2413">  /* actually... this doesn't ever return failure currently, but</a>
<a name="ln2414">   * better safe than sorry */</a>
<a name="ln2415">  if (CHECK_FLAG(attr-&gt;flag, ATTR_FLAG_BIT (BGP_ATTR_AS_PATH))</a>
<a name="ln2416">      &amp;&amp; bgp_attr_munge_as4_attrs (peer, attr, as4_path,</a>
<a name="ln2417">                                as4_aggregator, &amp;as4_aggregator_addr))</a>
<a name="ln2418">    {</a>
<a name="ln2419">      bgp_notify_send (peer, </a>
<a name="ln2420">		       BGP_NOTIFY_UPDATE_ERR,</a>
<a name="ln2421">		       BGP_NOTIFY_UPDATE_MAL_ATTR);</a>
<a name="ln2422">      if (as4_path)</a>
<a name="ln2423">        aspath_unintern (&amp;as4_path);</a>
<a name="ln2424">      return BGP_ATTR_PARSE_ERROR;</a>
<a name="ln2425">    }</a>
<a name="ln2426"> </a>
<a name="ln2427">  /* At this stage, we have done all fiddling with as4, and the</a>
<a name="ln2428">   * resulting info is in attr-&gt;aggregator resp. attr-&gt;aspath</a>
<a name="ln2429">   * so we can chuck as4_aggregator and as4_path alltogether in</a>
<a name="ln2430">   * order to save memory</a>
<a name="ln2431">   */</a>
<a name="ln2432">  if (as4_path)</a>
<a name="ln2433">    {</a>
<a name="ln2434">      aspath_unintern (&amp;as4_path); /* unintern - it is in the hash */</a>
<a name="ln2435">      /* The flag that we got this is still there, but that does not</a>
<a name="ln2436">       * do any trouble</a>
<a name="ln2437">       */</a>
<a name="ln2438">    }</a>
<a name="ln2439">  /*</a>
<a name="ln2440">   * The &quot;rest&quot; of the code does nothing with as4_aggregator.</a>
<a name="ln2441">   * there is no memory attached specifically which is not part</a>
<a name="ln2442">   * of the attr.</a>
<a name="ln2443">   * so ignoring just means do nothing.</a>
<a name="ln2444">   */</a>
<a name="ln2445">  /*</a>
<a name="ln2446">   * Finally do the checks on the aspath we did not do yet</a>
<a name="ln2447">   * because we waited for a potentially synthesized aspath.</a>
<a name="ln2448">   */</a>
<a name="ln2449">  if (attr-&gt;flag &amp; (ATTR_FLAG_BIT(BGP_ATTR_AS_PATH)))</a>
<a name="ln2450">    {</a>
<a name="ln2451">      ret = bgp_attr_aspath_check (peer, attr);</a>
<a name="ln2452">      if (ret != BGP_ATTR_PARSE_PROCEED)</a>
<a name="ln2453">	return ret;</a>
<a name="ln2454">    }</a>
<a name="ln2455"> </a>
<a name="ln2456">  /* Finally intern unknown attribute. */</a>
<a name="ln2457">  if (attr-&gt;extra &amp;&amp; attr-&gt;extra-&gt;transit)</a>
<a name="ln2458">    attr-&gt;extra-&gt;transit = transit_intern (attr-&gt;extra-&gt;transit);</a>
<a name="ln2459"> </a>
<a name="ln2460">  return BGP_ATTR_PARSE_PROCEED;</a>
<a name="ln2461">}</a>
<a name="ln2462"> </a>
<a name="ln2463">int stream_put_prefix (struct stream *, struct prefix *);</a>
<a name="ln2464"> </a>
<a name="ln2465">size_t</a>
<a name="ln2466">bgp_packet_mpattr_start (struct stream *s, afi_t afi, safi_t safi,</a>
<a name="ln2467">			 struct attr *attr)</a>
<a name="ln2468">{</a>
<a name="ln2469">  size_t sizep;</a>
<a name="ln2470"> </a>
<a name="ln2471">  /* Set extended bit always to encode the attribute length as 2 bytes */</a>
<a name="ln2472">  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln2473">  stream_putc (s, BGP_ATTR_MP_REACH_NLRI);</a>
<a name="ln2474">  sizep = stream_get_endp (s);</a>
<a name="ln2475">  stream_putw (s, 0);	/* Marker: Attribute length. */</a>
<a name="ln2476"> </a>
<a name="ln2477">  stream_putw (s, afi);</a>
<a name="ln2478">  stream_putc (s, (safi == SAFI_MPLS_VPN) ? SAFI_MPLS_LABELED_VPN : safi);</a>
<a name="ln2479"> </a>
<a name="ln2480">  /* Nexthop */</a>
<a name="ln2481">  switch (afi)</a>
<a name="ln2482">    {</a>
<a name="ln2483">    case AFI_IP:</a>
<a name="ln2484">      switch (safi)</a>
<a name="ln2485">	{</a>
<a name="ln2486">	case SAFI_MULTICAST:</a>
<a name="ln2487">	  stream_putc (s, 4);</a>
<a name="ln2488">	  stream_put_ipv4 (s, attr-&gt;nexthop.s_addr);</a>
<a name="ln2489">	  break;</a>
<a name="ln2490">	case SAFI_MPLS_VPN:</a>
<a name="ln2491">	  stream_putc (s, 12);</a>
<a name="ln2492">	  stream_putl (s, 0);   /* RD = 0, per RFC */</a>
<a name="ln2493">	  stream_putl (s, 0);</a>
<a name="ln2494">	  stream_put (s, &amp;attr-&gt;extra-&gt;mp_nexthop_global_in, 4);</a>
<a name="ln2495">	  break;</a>
<a name="ln2496">	case SAFI_ENCAP:</a>
<a name="ln2497">	  stream_putc (s, 4);</a>
<a name="ln2498">	  stream_put (s, &amp;attr-&gt;extra-&gt;mp_nexthop_global_in, 4);</a>
<a name="ln2499">	  break;</a>
<a name="ln2500">	case SAFI_UNICAST:      /* invalid for IPv4 */</a>
<a name="ln2501">	default:</a>
<a name="ln2502">	  break;</a>
<a name="ln2503">	}</a>
<a name="ln2504">      break;</a>
<a name="ln2505">    case AFI_IP6:</a>
<a name="ln2506">      switch (safi)</a>
<a name="ln2507">      {</a>
<a name="ln2508">      case SAFI_UNICAST:</a>
<a name="ln2509">      case SAFI_MULTICAST:</a>
<a name="ln2510">	{</a>
<a name="ln2511">	  struct attr_extra *attre = attr-&gt;extra;</a>
<a name="ln2512"> </a>
<a name="ln2513">	  assert (attr-&gt;extra);</a>
<a name="ln2514">	  stream_putc (s, attre-&gt;mp_nexthop_len);</a>
<a name="ln2515">	  stream_put (s, &amp;attre-&gt;mp_nexthop_global, 16);</a>
<a name="ln2516">	  if (attre-&gt;mp_nexthop_len == 32)</a>
<a name="ln2517">	    stream_put (s, &amp;attre-&gt;mp_nexthop_local, 16);</a>
<a name="ln2518">	}</a>
<a name="ln2519">	break;</a>
<a name="ln2520">      case SAFI_MPLS_VPN:</a>
<a name="ln2521">	{</a>
<a name="ln2522">	  struct attr_extra *attre = attr-&gt;extra;</a>
<a name="ln2523"> </a>
<a name="ln2524">	  assert (attr-&gt;extra);</a>
<a name="ln2525">          if (attre-&gt;mp_nexthop_len == 16) {</a>
<a name="ln2526">            stream_putc (s, 24);</a>
<a name="ln2527">            stream_putl (s, 0);   /* RD = 0, per RFC */</a>
<a name="ln2528">            stream_putl (s, 0);</a>
<a name="ln2529">            stream_put (s, &amp;attre-&gt;mp_nexthop_global, 16);</a>
<a name="ln2530">          } else if (attre-&gt;mp_nexthop_len == 32) {</a>
<a name="ln2531">            stream_putc (s, 48);</a>
<a name="ln2532">            stream_putl (s, 0);   /* RD = 0, per RFC */</a>
<a name="ln2533">            stream_putl (s, 0);</a>
<a name="ln2534">            stream_put (s, &amp;attre-&gt;mp_nexthop_global, 16);</a>
<a name="ln2535">            stream_putl (s, 0);   /* RD = 0, per RFC */</a>
<a name="ln2536">            stream_putl (s, 0);</a>
<a name="ln2537">            stream_put (s, &amp;attre-&gt;mp_nexthop_local, 16);</a>
<a name="ln2538">          }</a>
<a name="ln2539">        }</a>
<a name="ln2540">	break;</a>
<a name="ln2541">	case SAFI_ENCAP:</a>
<a name="ln2542">          assert (attr-&gt;extra);</a>
<a name="ln2543">          stream_putc (s, 16);</a>
<a name="ln2544">	  stream_put (s, &amp;attr-&gt;extra-&gt;mp_nexthop_global, 16);</a>
<a name="ln2545">	  break;</a>
<a name="ln2546">      default:</a>
<a name="ln2547">	break;</a>
<a name="ln2548">      }</a>
<a name="ln2549">      break;</a>
<a name="ln2550">    default:</a>
<a name="ln2551">      break;</a>
<a name="ln2552">    }</a>
<a name="ln2553"> </a>
<a name="ln2554">  /* SNPA */</a>
<a name="ln2555">  stream_putc (s, 0);</a>
<a name="ln2556">  return sizep;</a>
<a name="ln2557">}</a>
<a name="ln2558"> </a>
<a name="ln2559">void</a>
<a name="ln2560">bgp_packet_mpattr_prefix (struct stream *s, afi_t afi, safi_t safi,</a>
<a name="ln2561">			  struct prefix *p, struct prefix_rd *prd,</a>
<a name="ln2562">			  u_char *tag)</a>
<a name="ln2563">{</a>
<a name="ln2564">  if (safi == SAFI_MPLS_VPN)</a>
<a name="ln2565">    {</a>
<a name="ln2566">      /* Tag, RD, Prefix write. */</a>
<a name="ln2567">      stream_putc (s, p-&gt;prefixlen + 88);</a>
<a name="ln2568">      stream_put (s, tag, 3);</a>
<a name="ln2569">      stream_put (s, prd-&gt;val, 8);</a>
<a name="ln2570">      stream_put (s, &amp;p-&gt;u.prefix, PSIZE (p-&gt;prefixlen));</a>
<a name="ln2571">    }</a>
<a name="ln2572">  else</a>
<a name="ln2573">    stream_put_prefix (s, p);</a>
<a name="ln2574">}</a>
<a name="ln2575"> </a>
<a name="ln2576">size_t</a>
<a name="ln2577">bgp_packet_mpattr_prefix_size (afi_t afi, safi_t safi, struct prefix *p)</a>
<a name="ln2578">{</a>
<a name="ln2579">  int size = PSIZE (p-&gt;prefixlen);</a>
<a name="ln2580">  if (safi == SAFI_MPLS_VPN)</a>
<a name="ln2581">      size += 88;</a>
<a name="ln2582">  return size;</a>
<a name="ln2583">}</a>
<a name="ln2584"> </a>
<a name="ln2585">/*</a>
<a name="ln2586"> * Encodes the tunnel encapsulation attribute</a>
<a name="ln2587"> */</a>
<a name="ln2588">static void</a>
<a name="ln2589">bgp_packet_mpattr_tea(</a>
<a name="ln2590">    struct bgp		*bgp,</a>
<a name="ln2591">    struct peer		*peer,</a>
<a name="ln2592">    struct stream	*s,</a>
<a name="ln2593">    struct attr		*attr,</a>
<a name="ln2594">    uint8_t		attrtype)</a>
<a name="ln2595">{</a>
<a name="ln2596">    unsigned int			attrlenfield = 0;</a>
<a name="ln2597">    unsigned int			attrhdrlen   = 0;</a>
<a name="ln2598">    struct bgp_attr_encap_subtlv	*subtlvs;</a>
<a name="ln2599">    struct bgp_attr_encap_subtlv	*st;</a>
<a name="ln2600">    const char				*attrname;</a>
<a name="ln2601"> </a>
<a name="ln2602">    if (!attr || !attr-&gt;extra)</a>
<a name="ln2603">	return;</a>
<a name="ln2604"> </a>
<a name="ln2605">    switch (attrtype) {</a>
<a name="ln2606">	case BGP_ATTR_ENCAP:</a>
<a name="ln2607">	    attrname = &quot;Tunnel Encap&quot;;</a>
<a name="ln2608">	    subtlvs = attr-&gt;extra-&gt;encap_subtlvs;</a>
<a name="ln2609"> </a>
<a name="ln2610">	    /*</a>
<a name="ln2611">	     * The tunnel encap attr has an &quot;outer&quot; tlv.</a>
<a name="ln2612">	     * T = tunneltype,</a>
<a name="ln2613">	     * L = total length of subtlvs,</a>
<a name="ln2614">	     * V = concatenated subtlvs.</a>
<a name="ln2615">	     */</a>
<a name="ln2616">	    attrlenfield = 2 + 2;	/* T + L */</a>
<a name="ln2617">            attrhdrlen   = 1 + 1;	/* subTLV T + L */</a>
<a name="ln2618">	    break;</a>
<a name="ln2619"> </a>
<a name="ln2620">	default:</a>
<a name="ln2621">	    assert(0);</a>
<a name="ln2622">    }</a>
<a name="ln2623"> </a>
<a name="ln2624"> </a>
<a name="ln2625">    /* if no tlvs, don't make attr */</a>
<a name="ln2626">    if (subtlvs == NULL)</a>
<a name="ln2627">	return;</a>
<a name="ln2628"> </a>
<a name="ln2629">    /* compute attr length */</a>
<a name="ln2630">    for (st = subtlvs; st; st = st-&gt;next) {</a>
<a name="ln2631">	attrlenfield += (attrhdrlen + st-&gt;length);</a>
<a name="ln2632">    }</a>
<a name="ln2633"> </a>
<a name="ln2634">    if (attrlenfield &gt; 0xffff) {</a>
<a name="ln2635">	zlog (peer-&gt;log, LOG_ERR,</a>
<a name="ln2636">	    &quot;%s attribute is too long (length=%d), can't send it&quot;,</a>
<a name="ln2637">	    attrname,</a>
<a name="ln2638">	    attrlenfield);</a>
<a name="ln2639">	return;</a>
<a name="ln2640">    }</a>
<a name="ln2641"> </a>
<a name="ln2642">    if (attrlenfield &gt; 0xff) {</a>
<a name="ln2643">	/* 2-octet length field */</a>
<a name="ln2644">	stream_putc (s,</a>
<a name="ln2645">	    BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln2646">	stream_putc (s, attrtype);</a>
<a name="ln2647">	stream_putw (s, attrlenfield &amp; 0xffff);</a>
<a name="ln2648">    } else {</a>
<a name="ln2649">	/* 1-octet length field */</a>
<a name="ln2650">	stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_OPTIONAL);</a>
<a name="ln2651">	stream_putc (s, attrtype);</a>
<a name="ln2652">	stream_putc (s, attrlenfield &amp; 0xff);</a>
<a name="ln2653">    }</a>
<a name="ln2654"> </a>
<a name="ln2655">    if (attrtype == BGP_ATTR_ENCAP) {</a>
<a name="ln2656">	/* write outer T+L */</a>
<a name="ln2657">	stream_putw(s, attr-&gt;extra-&gt;encap_tunneltype);</a>
<a name="ln2658">	stream_putw(s, attrlenfield - 4);</a>
<a name="ln2659">    }</a>
<a name="ln2660"> </a>
<a name="ln2661">    /* write each sub-tlv */</a>
<a name="ln2662">    for (st = subtlvs; st; st = st-&gt;next) {</a>
<a name="ln2663">        if (attrtype == BGP_ATTR_ENCAP) {</a>
<a name="ln2664">            stream_putc (s, st-&gt;type);</a>
<a name="ln2665">            stream_putc (s, st-&gt;length);</a>
<a name="ln2666">        }</a>
<a name="ln2667">	stream_put (s, st-&gt;value, st-&gt;length);</a>
<a name="ln2668">    }</a>
<a name="ln2669">}</a>
<a name="ln2670"> </a>
<a name="ln2671">void</a>
<a name="ln2672">bgp_packet_mpattr_end (struct stream *s, size_t sizep)</a>
<a name="ln2673">{</a>
<a name="ln2674">  /* Set MP attribute length. Don't count the (2) bytes used to encode</a>
<a name="ln2675">     the attr length */</a>
<a name="ln2676">  stream_putw_at (s, sizep, (stream_get_endp (s) - sizep) - 2);</a>
<a name="ln2677">}</a>
<a name="ln2678"> </a>
<a name="ln2679">/* Make attribute packet. */</a>
<a name="ln2680">bgp_size_t</a>
<a name="ln2681">bgp_packet_attribute (struct bgp *bgp, struct peer *peer,</a>
<a name="ln2682">		      struct stream *s, struct attr *attr,</a>
<a name="ln2683">		      struct prefix *p, afi_t afi, safi_t safi,</a>
<a name="ln2684">		      struct peer *from, struct prefix_rd *prd, u_char *tag)</a>
<a name="ln2685">{</a>
<a name="ln2686">  size_t cp;</a>
<a name="ln2687">  size_t aspath_sizep;</a>
<a name="ln2688">  struct aspath *aspath;</a>
<a name="ln2689">  int send_as4_path = 0;</a>
<a name="ln2690">  int send_as4_aggregator = 0;</a>
<a name="ln2691">  int use32bit = (CHECK_FLAG (peer-&gt;cap, PEER_CAP_AS4_RCV)) ? 1 : 0;</a>
<a name="ln2692"> </a>
<a name="ln2693">  if (! bgp)</a>
<a name="ln2694">    bgp = bgp_get_default ();</a>
<a name="ln2695"> </a>
<a name="ln2696">  /* Remember current pointer. */</a>
<a name="ln2697">  cp = stream_get_endp (s);</a>
<a name="ln2698"> </a>
<a name="ln2699">  if (p &amp;&amp; !(afi == AFI_IP &amp;&amp; safi == SAFI_UNICAST))</a>
<a name="ln2700">    {</a>
<a name="ln2701">      size_t mpattrlen_pos = 0;</a>
<a name="ln2702">      mpattrlen_pos = bgp_packet_mpattr_start(s, afi, safi, attr);</a>
<a name="ln2703">      bgp_packet_mpattr_prefix(s, afi, safi, p, prd, tag);</a>
<a name="ln2704">      bgp_packet_mpattr_end(s, mpattrlen_pos);</a>
<a name="ln2705">    }</a>
<a name="ln2706"> </a>
<a name="ln2707">  /* Origin attribute. */</a>
<a name="ln2708">  stream_putc (s, BGP_ATTR_FLAG_TRANS);</a>
<a name="ln2709">  stream_putc (s, BGP_ATTR_ORIGIN);</a>
<a name="ln2710">  stream_putc (s, 1);</a>
<a name="ln2711">  stream_putc (s, attr-&gt;origin);</a>
<a name="ln2712"> </a>
<a name="ln2713">  /* AS path attribute. */</a>
<a name="ln2714"> </a>
<a name="ln2715">  /* If remote-peer is EBGP */</a>
<a name="ln2716">  if (peer-&gt;sort == BGP_PEER_EBGP</a>
<a name="ln2717">      &amp;&amp; (! CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_AS_PATH_UNCHANGED)</a>
<a name="ln2718">	  || attr-&gt;aspath-&gt;segments == NULL)</a>
<a name="ln2719">      &amp;&amp; (! CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_RSERVER_CLIENT)))</a>
<a name="ln2720">    {    </a>
<a name="ln2721">      aspath = aspath_dup (attr-&gt;aspath);</a>
<a name="ln2722"> </a>
<a name="ln2723">      if (CHECK_FLAG(bgp-&gt;config, BGP_CONFIG_CONFEDERATION))</a>
<a name="ln2724">	{</a>
<a name="ln2725">	  /* Strip the confed info, and then stuff our path CONFED_ID</a>
<a name="ln2726">	     on the front */</a>
<a name="ln2727">	  aspath = aspath_delete_confed_seq (aspath);</a>
<a name="ln2728">	  aspath = aspath_add_seq (aspath, bgp-&gt;confed_id);</a>
<a name="ln2729">	}</a>
<a name="ln2730">      else</a>
<a name="ln2731">	{</a>
<a name="ln2732">	  if (peer-&gt;change_local_as) {</a>
<a name="ln2733">            /* If replace-as is specified, we only use the change_local_as when</a>
<a name="ln2734">               advertising routes. */</a>
<a name="ln2735">            if( ! CHECK_FLAG (peer-&gt;flags, PEER_FLAG_LOCAL_AS_REPLACE_AS) ) {</a>
<a name="ln2736">              aspath = aspath_add_seq (aspath, peer-&gt;local_as);</a>
<a name="ln2737">            }</a>
<a name="ln2738">	    aspath = aspath_add_seq (aspath, peer-&gt;change_local_as);</a>
<a name="ln2739">          } else {</a>
<a name="ln2740">            aspath = aspath_add_seq (aspath, peer-&gt;local_as);</a>
<a name="ln2741">          }</a>
<a name="ln2742">	}</a>
<a name="ln2743">    }</a>
<a name="ln2744">  else if (peer-&gt;sort == BGP_PEER_CONFED)</a>
<a name="ln2745">    {</a>
<a name="ln2746">      /* A confed member, so we need to do the AS_CONFED_SEQUENCE thing */</a>
<a name="ln2747">      aspath = aspath_dup (attr-&gt;aspath);</a>
<a name="ln2748">      aspath = aspath_add_confed_seq (aspath, peer-&gt;local_as);</a>
<a name="ln2749">    }</a>
<a name="ln2750">  else</a>
<a name="ln2751">    aspath = attr-&gt;aspath;</a>
<a name="ln2752"> </a>
<a name="ln2753">  /* If peer is not AS4 capable, then:</a>
<a name="ln2754">   * - send the created AS_PATH out as AS4_PATH (optional, transitive),</a>
<a name="ln2755">   *   but ensure that no AS_CONFED_SEQUENCE and AS_CONFED_SET path segment</a>
<a name="ln2756">   *   types are in it (i.e. exclude them if they are there)</a>
<a name="ln2757">   *   AND do this only if there is at least one asnum &gt; 65535 in the path!</a>
<a name="ln2758">   * - send an AS_PATH out, but put 16Bit ASnums in it, not 32bit, and change</a>
<a name="ln2759">   *   all ASnums &gt; 65535 to BGP_AS_TRANS</a>
<a name="ln2760">   */</a>
<a name="ln2761"> </a>
<a name="ln2762">  stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln2763">  stream_putc (s, BGP_ATTR_AS_PATH);</a>
<a name="ln2764">  aspath_sizep = stream_get_endp (s);</a>
<a name="ln2765">  stream_putw (s, 0);</a>
<a name="ln2766">  stream_putw_at (s, aspath_sizep, aspath_put (s, aspath, use32bit));</a>
<a name="ln2767">  </a>
<a name="ln2768">  /* OLD session may need NEW_AS_PATH sent, if there are 4-byte ASNs </a>
<a name="ln2769">   * in the path</a>
<a name="ln2770">   */</a>
<a name="ln2771">  if (!use32bit &amp;&amp; aspath_has_as4 (aspath))</a>
<a name="ln2772">      send_as4_path = 1; /* we'll do this later, at the correct place */</a>
<a name="ln2773">  </a>
<a name="ln2774">  /* Nexthop attribute. */</a>
<a name="ln2775">  if (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP) &amp;&amp; afi == AFI_IP &amp;&amp;</a>
<a name="ln2776">    safi ==  SAFI_UNICAST)   /* only write NH attr for unicast safi */</a>
<a name="ln2777">    {</a>
<a name="ln2778">      stream_putc (s, BGP_ATTR_FLAG_TRANS);</a>
<a name="ln2779">      stream_putc (s, BGP_ATTR_NEXT_HOP);</a>
<a name="ln2780">      stream_putc (s, 4);</a>
<a name="ln2781">      if (safi == SAFI_MPLS_VPN)</a>
<a name="ln2782">	{</a>
<a name="ln2783">	  if (attr-&gt;nexthop.s_addr == 0)</a>
<a name="ln2784">	    stream_put_ipv4 (s, peer-&gt;nexthop.v4.s_addr);</a>
<a name="ln2785">	  else</a>
<a name="ln2786">	    stream_put_ipv4 (s, attr-&gt;nexthop.s_addr);</a>
<a name="ln2787">	}</a>
<a name="ln2788">      else</a>
<a name="ln2789">	stream_put_ipv4 (s, attr-&gt;nexthop.s_addr);</a>
<a name="ln2790">    }</a>
<a name="ln2791"> </a>
<a name="ln2792">  /* MED attribute. */</a>
<a name="ln2793">  if (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))</a>
<a name="ln2794">    {</a>
<a name="ln2795">      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);</a>
<a name="ln2796">      stream_putc (s, BGP_ATTR_MULTI_EXIT_DISC);</a>
<a name="ln2797">      stream_putc (s, 4);</a>
<a name="ln2798">      stream_putl (s, attr-&gt;med);</a>
<a name="ln2799">    }</a>
<a name="ln2800"> </a>
<a name="ln2801">  /* Local preference. */</a>
<a name="ln2802">  if (peer-&gt;sort == BGP_PEER_IBGP ||</a>
<a name="ln2803">      peer-&gt;sort == BGP_PEER_CONFED)</a>
<a name="ln2804">    {</a>
<a name="ln2805">      stream_putc (s, BGP_ATTR_FLAG_TRANS);</a>
<a name="ln2806">      stream_putc (s, BGP_ATTR_LOCAL_PREF);</a>
<a name="ln2807">      stream_putc (s, 4);</a>
<a name="ln2808">      stream_putl (s, attr-&gt;local_pref);</a>
<a name="ln2809">    }</a>
<a name="ln2810"> </a>
<a name="ln2811">  /* Atomic aggregate. */</a>
<a name="ln2812">  if (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE))</a>
<a name="ln2813">    {</a>
<a name="ln2814">      stream_putc (s, BGP_ATTR_FLAG_TRANS);</a>
<a name="ln2815">      stream_putc (s, BGP_ATTR_ATOMIC_AGGREGATE);</a>
<a name="ln2816">      stream_putc (s, 0);</a>
<a name="ln2817">    }</a>
<a name="ln2818"> </a>
<a name="ln2819">  /* Aggregator. */</a>
<a name="ln2820">  if (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR))</a>
<a name="ln2821">    {</a>
<a name="ln2822">      assert (attr-&gt;extra);</a>
<a name="ln2823">      </a>
<a name="ln2824">      /* Common to BGP_ATTR_AGGREGATOR, regardless of ASN size */</a>
<a name="ln2825">      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);</a>
<a name="ln2826">      stream_putc (s, BGP_ATTR_AGGREGATOR);</a>
<a name="ln2827">      </a>
<a name="ln2828">      if (use32bit)</a>
<a name="ln2829">        {</a>
<a name="ln2830">          /* AS4 capable peer */</a>
<a name="ln2831">          stream_putc (s, 8);</a>
<a name="ln2832">          stream_putl (s, attr-&gt;extra-&gt;aggregator_as);</a>
<a name="ln2833">        }</a>
<a name="ln2834">      else</a>
<a name="ln2835">        {</a>
<a name="ln2836">          /* 2-byte AS peer */</a>
<a name="ln2837">          stream_putc (s, 6);</a>
<a name="ln2838">          </a>
<a name="ln2839">          /* Is ASN representable in 2-bytes? Or must AS_TRANS be used? */</a>
<a name="ln2840">          if ( attr-&gt;extra-&gt;aggregator_as &gt; 65535 )</a>
<a name="ln2841">            {</a>
<a name="ln2842">              stream_putw (s, BGP_AS_TRANS);</a>
<a name="ln2843">              </a>
<a name="ln2844">              /* we have to send AS4_AGGREGATOR, too.</a>
<a name="ln2845">               * we'll do that later in order to send attributes in ascending</a>
<a name="ln2846">               * order.</a>
<a name="ln2847">               */</a>
<a name="ln2848">              send_as4_aggregator = 1;</a>
<a name="ln2849">            }</a>
<a name="ln2850">          else</a>
<a name="ln2851">            stream_putw (s, (u_int16_t) attr-&gt;extra-&gt;aggregator_as);</a>
<a name="ln2852">        }</a>
<a name="ln2853">      stream_put_ipv4 (s, attr-&gt;extra-&gt;aggregator_addr.s_addr);</a>
<a name="ln2854">    }</a>
<a name="ln2855"> </a>
<a name="ln2856">  /* Community attribute. */</a>
<a name="ln2857">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SEND_COMMUNITY) </a>
<a name="ln2858">      &amp;&amp; (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES)))</a>
<a name="ln2859">    {</a>
<a name="ln2860">      if (attr-&gt;community-&gt;size * 4 &gt; 255)</a>
<a name="ln2861">	{</a>
<a name="ln2862">	  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln2863">	  stream_putc (s, BGP_ATTR_COMMUNITIES);</a>
<a name="ln2864">	  stream_putw (s, attr-&gt;community-&gt;size * 4);</a>
<a name="ln2865">	}</a>
<a name="ln2866">      else</a>
<a name="ln2867">	{</a>
<a name="ln2868">	  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);</a>
<a name="ln2869">	  stream_putc (s, BGP_ATTR_COMMUNITIES);</a>
<a name="ln2870">	  stream_putc (s, attr-&gt;community-&gt;size * 4);</a>
<a name="ln2871">	}</a>
<a name="ln2872">      stream_put (s, attr-&gt;community-&gt;val, attr-&gt;community-&gt;size * 4);</a>
<a name="ln2873">    }</a>
<a name="ln2874"> </a>
<a name="ln2875">  /*</a>
<a name="ln2876">   * Large Community attribute.</a>
<a name="ln2877">   */</a>
<a name="ln2878">  if (attr-&gt;extra &amp;&amp;</a>
<a name="ln2879">      CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SEND_LARGE_COMMUNITY)</a>
<a name="ln2880">      &amp;&amp; (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_LARGE_COMMUNITIES)))</a>
<a name="ln2881">    {</a>
<a name="ln2882">      if (attr-&gt;extra-&gt;lcommunity-&gt;size * 12 &gt; 255)</a>
<a name="ln2883">	{</a>
<a name="ln2884">	  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln2885">	  stream_putc (s, BGP_ATTR_LARGE_COMMUNITIES);</a>
<a name="ln2886">	  stream_putw (s, attr-&gt;extra-&gt;lcommunity-&gt;size * 12);</a>
<a name="ln2887">	}</a>
<a name="ln2888">      else</a>
<a name="ln2889">	{</a>
<a name="ln2890">	  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);</a>
<a name="ln2891">	  stream_putc (s, BGP_ATTR_LARGE_COMMUNITIES);</a>
<a name="ln2892">	  stream_putc (s, attr-&gt;extra-&gt;lcommunity-&gt;size * 12);</a>
<a name="ln2893">	}</a>
<a name="ln2894">      stream_put (s, attr-&gt;extra-&gt;lcommunity-&gt;val, attr-&gt;extra-&gt;lcommunity-&gt;size * 12);</a>
<a name="ln2895">    }</a>
<a name="ln2896"> </a>
<a name="ln2897">  /* Route Reflector. */</a>
<a name="ln2898">  if (peer-&gt;sort == BGP_PEER_IBGP</a>
<a name="ln2899">      &amp;&amp; from</a>
<a name="ln2900">      &amp;&amp; from-&gt;sort == BGP_PEER_IBGP)</a>
<a name="ln2901">    {</a>
<a name="ln2902">      /* Originator ID. */</a>
<a name="ln2903">      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);</a>
<a name="ln2904">      stream_putc (s, BGP_ATTR_ORIGINATOR_ID);</a>
<a name="ln2905">      stream_putc (s, 4);</a>
<a name="ln2906"> </a>
<a name="ln2907">      if (attr-&gt;flag &amp; ATTR_FLAG_BIT(BGP_ATTR_ORIGINATOR_ID))</a>
<a name="ln2908">	stream_put_in_addr (s, &amp;attr-&gt;extra-&gt;originator_id);</a>
<a name="ln2909">      else </a>
<a name="ln2910">        stream_put_in_addr (s, &amp;from-&gt;remote_id);</a>
<a name="ln2911"> </a>
<a name="ln2912">      /* Cluster list. */</a>
<a name="ln2913">      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);</a>
<a name="ln2914">      stream_putc (s, BGP_ATTR_CLUSTER_LIST);</a>
<a name="ln2915">      </a>
<a name="ln2916">      if (attr-&gt;extra &amp;&amp; attr-&gt;extra-&gt;cluster)</a>
<a name="ln2917">	{</a>
<a name="ln2918">	  stream_putc (s, attr-&gt;extra-&gt;cluster-&gt;length + 4);</a>
<a name="ln2919">	  /* If this peer configuration's parent BGP has cluster_id. */</a>
<a name="ln2920">	  if (bgp-&gt;config &amp; BGP_CONFIG_CLUSTER_ID)</a>
<a name="ln2921">	    stream_put_in_addr (s, &amp;bgp-&gt;cluster_id);</a>
<a name="ln2922">	  else</a>
<a name="ln2923">	    stream_put_in_addr (s, &amp;bgp-&gt;router_id);</a>
<a name="ln2924">	  stream_put (s, attr-&gt;extra-&gt;cluster-&gt;list, </a>
<a name="ln2925">	              attr-&gt;extra-&gt;cluster-&gt;length);</a>
<a name="ln2926">	}</a>
<a name="ln2927">      else</a>
<a name="ln2928">	{</a>
<a name="ln2929">	  stream_putc (s, 4);</a>
<a name="ln2930">	  /* If this peer configuration's parent BGP has cluster_id. */</a>
<a name="ln2931">	  if (bgp-&gt;config &amp; BGP_CONFIG_CLUSTER_ID)</a>
<a name="ln2932">	    stream_put_in_addr (s, &amp;bgp-&gt;cluster_id);</a>
<a name="ln2933">	  else</a>
<a name="ln2934">	    stream_put_in_addr (s, &amp;bgp-&gt;router_id);</a>
<a name="ln2935">	}</a>
<a name="ln2936">    }</a>
<a name="ln2937"> </a>
<a name="ln2938">  /* Extended Communities attribute. */</a>
<a name="ln2939">  if (CHECK_FLAG (peer-&gt;af_flags[afi][safi], PEER_FLAG_SEND_EXT_COMMUNITY) </a>
<a name="ln2940">      &amp;&amp; (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES)))</a>
<a name="ln2941">    {</a>
<a name="ln2942">      struct attr_extra *attre = attr-&gt;extra;</a>
<a name="ln2943">      </a>
<a name="ln2944">      assert (attre);</a>
<a name="ln2945">      </a>
<a name="ln2946">      if (peer-&gt;sort == BGP_PEER_IBGP</a>
<a name="ln2947">          || peer-&gt;sort == BGP_PEER_CONFED)</a>
<a name="ln2948">	{</a>
<a name="ln2949">	  if (attre-&gt;ecommunity-&gt;size * 8 &gt; 255)</a>
<a name="ln2950">	    {</a>
<a name="ln2951">	      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln2952">	      stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);</a>
<a name="ln2953">	      stream_putw (s, attre-&gt;ecommunity-&gt;size * 8);</a>
<a name="ln2954">	    }</a>
<a name="ln2955">	  else</a>
<a name="ln2956">	    {</a>
<a name="ln2957">	      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);</a>
<a name="ln2958">	      stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);</a>
<a name="ln2959">	      stream_putc (s, attre-&gt;ecommunity-&gt;size * 8);</a>
<a name="ln2960">	    }</a>
<a name="ln2961">	  stream_put (s, attre-&gt;ecommunity-&gt;val, attre-&gt;ecommunity-&gt;size * 8);</a>
<a name="ln2962">	}</a>
<a name="ln2963">      else</a>
<a name="ln2964">	{</a>
<a name="ln2965">	  u_int8_t *pnt;</a>
<a name="ln2966">	  int tbit;</a>
<a name="ln2967">	  int ecom_tr_size = 0;</a>
<a name="ln2968">	  int i;</a>
<a name="ln2969"> </a>
<a name="ln2970">	  for (i = 0; i &lt; attre-&gt;ecommunity-&gt;size; i++)</a>
<a name="ln2971">	    {</a>
<a name="ln2972">	      pnt = attre-&gt;ecommunity-&gt;val + (i * 8);</a>
<a name="ln2973">	      tbit = *pnt;</a>
<a name="ln2974"> </a>
<a name="ln2975">	      if (CHECK_FLAG (tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE))</a>
<a name="ln2976">		continue;</a>
<a name="ln2977"> </a>
<a name="ln2978">	      ecom_tr_size++;</a>
<a name="ln2979">	    }</a>
<a name="ln2980"> </a>
<a name="ln2981">	  if (ecom_tr_size)</a>
<a name="ln2982">	    {</a>
<a name="ln2983">	      if (ecom_tr_size * 8 &gt; 255)</a>
<a name="ln2984">		{</a>
<a name="ln2985">		  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln2986">		  stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);</a>
<a name="ln2987">		  stream_putw (s, ecom_tr_size * 8);</a>
<a name="ln2988">		}</a>
<a name="ln2989">	      else</a>
<a name="ln2990">		{</a>
<a name="ln2991">		  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);</a>
<a name="ln2992">		  stream_putc (s, BGP_ATTR_EXT_COMMUNITIES);</a>
<a name="ln2993">		  stream_putc (s, ecom_tr_size * 8);</a>
<a name="ln2994">		}</a>
<a name="ln2995"> </a>
<a name="ln2996">	      for (i = 0; i &lt; attre-&gt;ecommunity-&gt;size; i++)</a>
<a name="ln2997">		{</a>
<a name="ln2998">		  pnt = attre-&gt;ecommunity-&gt;val + (i * 8);</a>
<a name="ln2999">		  tbit = *pnt;</a>
<a name="ln3000"> </a>
<a name="ln3001">		  if (CHECK_FLAG (tbit, ECOMMUNITY_FLAG_NON_TRANSITIVE))</a>
<a name="ln3002">		    continue;</a>
<a name="ln3003"> </a>
<a name="ln3004">		  stream_put (s, pnt, 8);</a>
<a name="ln3005">		}</a>
<a name="ln3006">	    }</a>
<a name="ln3007">	}</a>
<a name="ln3008">    }</a>
<a name="ln3009"> </a>
<a name="ln3010">  if ( send_as4_path )</a>
<a name="ln3011">    {</a>
<a name="ln3012">      /* If the peer is NOT As4 capable, AND */</a>
<a name="ln3013">      /* there are ASnums &gt; 65535 in path  THEN</a>
<a name="ln3014">       * give out AS4_PATH */</a>
<a name="ln3015"> </a>
<a name="ln3016">      /* Get rid of all AS_CONFED_SEQUENCE and AS_CONFED_SET</a>
<a name="ln3017">       * path segments!</a>
<a name="ln3018">       * Hm, I wonder...  confederation things *should* only be at</a>
<a name="ln3019">       * the beginning of an aspath, right?  Then we should use</a>
<a name="ln3020">       * aspath_delete_confed_seq for this, because it is already</a>
<a name="ln3021">       * there! (JK) </a>
<a name="ln3022">       * Folks, talk to me: what is reasonable here!?</a>
<a name="ln3023">       */</a>
<a name="ln3024">      aspath = aspath_delete_confed_seq (aspath);</a>
<a name="ln3025"> </a>
<a name="ln3026">      stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln3027">      stream_putc (s, BGP_ATTR_AS4_PATH);</a>
<a name="ln3028">      aspath_sizep = stream_get_endp (s);</a>
<a name="ln3029">      stream_putw (s, 0);</a>
<a name="ln3030">      stream_putw_at (s, aspath_sizep, aspath_put (s, aspath, 1));</a>
<a name="ln3031">    }</a>
<a name="ln3032"> </a>
<a name="ln3033">  if (aspath != attr-&gt;aspath)</a>
<a name="ln3034">    aspath_free (aspath);</a>
<a name="ln3035"> </a>
<a name="ln3036">  if ( send_as4_aggregator ) </a>
<a name="ln3037">    {</a>
<a name="ln3038">      assert (attr-&gt;extra);</a>
<a name="ln3039"> </a>
<a name="ln3040">      /* send AS4_AGGREGATOR, at this place */</a>
<a name="ln3041">      /* this section of code moved here in order to ensure the correct</a>
<a name="ln3042">       * *ascending* order of attributes</a>
<a name="ln3043">       */</a>
<a name="ln3044">      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);</a>
<a name="ln3045">      stream_putc (s, BGP_ATTR_AS4_AGGREGATOR);</a>
<a name="ln3046">      stream_putc (s, 8);</a>
<a name="ln3047">      stream_putl (s, attr-&gt;extra-&gt;aggregator_as);</a>
<a name="ln3048">      stream_put_ipv4 (s, attr-&gt;extra-&gt;aggregator_addr.s_addr);</a>
<a name="ln3049">    }</a>
<a name="ln3050"> </a>
<a name="ln3051">  if ((afi == AFI_IP || afi == AFI_IP6) &amp;&amp;</a>
<a name="ln3052">      (safi == SAFI_ENCAP || safi == SAFI_MPLS_VPN))</a>
<a name="ln3053">    {</a>
<a name="ln3054">	/* Tunnel Encap attribute */</a>
<a name="ln3055">	bgp_packet_mpattr_tea(bgp, peer, s, attr, BGP_ATTR_ENCAP);</a>
<a name="ln3056">    }</a>
<a name="ln3057"> </a>
<a name="ln3058">  /* Unknown transit attribute. */</a>
<a name="ln3059">  if (attr-&gt;extra &amp;&amp; attr-&gt;extra-&gt;transit)</a>
<a name="ln3060">    stream_put (s, attr-&gt;extra-&gt;transit-&gt;val, attr-&gt;extra-&gt;transit-&gt;length);</a>
<a name="ln3061"> </a>
<a name="ln3062">  /* Return total size of attribute. */</a>
<a name="ln3063">  return stream_get_endp (s) - cp;</a>
<a name="ln3064">}</a>
<a name="ln3065"> </a>
<a name="ln3066">size_t</a>
<a name="ln3067">bgp_packet_mpunreach_start (struct stream *s, afi_t afi, safi_t safi)</a>
<a name="ln3068">{</a>
<a name="ln3069">  unsigned long attrlen_pnt;</a>
<a name="ln3070"> </a>
<a name="ln3071">  /* Set extended bit always to encode the attribute length as 2 bytes */</a>
<a name="ln3072">  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln3073">  stream_putc (s, BGP_ATTR_MP_UNREACH_NLRI);</a>
<a name="ln3074"> </a>
<a name="ln3075">  attrlen_pnt = stream_get_endp (s);</a>
<a name="ln3076">  stream_putw (s, 0);		/* Length of this attribute. */</a>
<a name="ln3077"> </a>
<a name="ln3078">  stream_putw (s, afi);</a>
<a name="ln3079">  stream_putc (s, (safi == SAFI_MPLS_VPN) ? SAFI_MPLS_LABELED_VPN : safi);</a>
<a name="ln3080">  return attrlen_pnt;</a>
<a name="ln3081">}</a>
<a name="ln3082"> </a>
<a name="ln3083">void</a>
<a name="ln3084">bgp_packet_mpunreach_prefix (struct stream *s, struct prefix *p,</a>
<a name="ln3085">			     afi_t afi, safi_t safi, struct prefix_rd *prd,</a>
<a name="ln3086">			     u_char *tag)</a>
<a name="ln3087">{</a>
<a name="ln3088">  bgp_packet_mpattr_prefix (s, afi, safi, p, prd, tag);</a>
<a name="ln3089">}</a>
<a name="ln3090"> </a>
<a name="ln3091">void</a>
<a name="ln3092">bgp_packet_mpunreach_end (struct stream *s, size_t attrlen_pnt)</a>
<a name="ln3093">{</a>
<a name="ln3094">  bgp_packet_mpattr_end (s, attrlen_pnt);</a>
<a name="ln3095">}</a>
<a name="ln3096"> </a>
<a name="ln3097">/* Initialization of attribute. */</a>
<a name="ln3098">void</a>
<a name="ln3099">bgp_attr_init (void)</a>
<a name="ln3100">{</a>
<a name="ln3101">  aspath_init ();</a>
<a name="ln3102">  attrhash_init ();</a>
<a name="ln3103">  community_init ();</a>
<a name="ln3104">  ecommunity_init ();</a>
<a name="ln3105">  lcommunity_init ();</a>
<a name="ln3106">  cluster_init ();</a>
<a name="ln3107">  transit_init ();</a>
<a name="ln3108">}</a>
<a name="ln3109"> </a>
<a name="ln3110">void</a>
<a name="ln3111">bgp_attr_finish (void)</a>
<a name="ln3112">{</a>
<a name="ln3113">  aspath_finish ();</a>
<a name="ln3114">  attrhash_finish ();</a>
<a name="ln3115">  community_finish ();</a>
<a name="ln3116">  ecommunity_finish ();</a>
<a name="ln3117">  lcommunity_finish ();</a>
<a name="ln3118">  cluster_finish ();</a>
<a name="ln3119">  transit_finish ();</a>
<a name="ln3120">}</a>
<a name="ln3121"> </a>
<a name="ln3122">/* Make attribute packet. */</a>
<a name="ln3123">void</a>
<a name="ln3124">bgp_dump_routes_attr (struct stream *s, struct attr *attr, </a>
<a name="ln3125">                      struct prefix *prefix)</a>
<a name="ln3126">{</a>
<a name="ln3127">  unsigned long cp;</a>
<a name="ln3128">  unsigned long len;</a>
<a name="ln3129">  size_t aspath_lenp;</a>
<a name="ln3130">  struct aspath *aspath;</a>
<a name="ln3131"> </a>
<a name="ln3132">  /* Remember current pointer. */</a>
<a name="ln3133">  cp = stream_get_endp (s);</a>
<a name="ln3134"> </a>
<a name="ln3135">  /* Place holder of length. */</a>
<a name="ln3136">  stream_putw (s, 0);</a>
<a name="ln3137"> </a>
<a name="ln3138">  /* Origin attribute. */</a>
<a name="ln3139">  stream_putc (s, BGP_ATTR_FLAG_TRANS);</a>
<a name="ln3140">  stream_putc (s, BGP_ATTR_ORIGIN);</a>
<a name="ln3141">  stream_putc (s, 1);</a>
<a name="ln3142">  stream_putc (s, attr-&gt;origin);</a>
<a name="ln3143"> </a>
<a name="ln3144">  aspath = attr-&gt;aspath;</a>
<a name="ln3145">  </a>
<a name="ln3146">  stream_putc (s, BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln3147">  stream_putc (s, BGP_ATTR_AS_PATH);</a>
<a name="ln3148">  aspath_lenp = stream_get_endp (s);</a>
<a name="ln3149">  stream_putw (s, 0);</a>
<a name="ln3150">  </a>
<a name="ln3151">  stream_putw_at (s, aspath_lenp, aspath_put (s, aspath, 1));</a>
<a name="ln3152"> </a>
<a name="ln3153">  /* Nexthop attribute. */</a>
<a name="ln3154">  /* If it's an IPv6 prefix, don't dump the IPv4 nexthop to save space */</a>
<a name="ln3155">  if(prefix != NULL</a>
<a name="ln3156">     &amp;&amp; prefix-&gt;family != AF_INET6</a>
<a name="ln3157">     )</a>
<a name="ln3158">    {</a>
<a name="ln3159">      stream_putc (s, BGP_ATTR_FLAG_TRANS);</a>
<a name="ln3160">      stream_putc (s, BGP_ATTR_NEXT_HOP);</a>
<a name="ln3161">      stream_putc (s, 4);</a>
<a name="ln3162">      stream_put_ipv4 (s, attr-&gt;nexthop.s_addr);</a>
<a name="ln3163">    }</a>
<a name="ln3164"> </a>
<a name="ln3165">  /* MED attribute. */</a>
<a name="ln3166">  if (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))</a>
<a name="ln3167">    {</a>
<a name="ln3168">      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL);</a>
<a name="ln3169">      stream_putc (s, BGP_ATTR_MULTI_EXIT_DISC);</a>
<a name="ln3170">      stream_putc (s, 4);</a>
<a name="ln3171">      stream_putl (s, attr-&gt;med);</a>
<a name="ln3172">    }</a>
<a name="ln3173"> </a>
<a name="ln3174">  /* Local preference. */</a>
<a name="ln3175">  if (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))</a>
<a name="ln3176">    {</a>
<a name="ln3177">      stream_putc (s, BGP_ATTR_FLAG_TRANS);</a>
<a name="ln3178">      stream_putc (s, BGP_ATTR_LOCAL_PREF);</a>
<a name="ln3179">      stream_putc (s, 4);</a>
<a name="ln3180">      stream_putl (s, attr-&gt;local_pref);</a>
<a name="ln3181">    }</a>
<a name="ln3182"> </a>
<a name="ln3183">  /* Atomic aggregate. */</a>
<a name="ln3184">  if (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE))</a>
<a name="ln3185">    {</a>
<a name="ln3186">      stream_putc (s, BGP_ATTR_FLAG_TRANS);</a>
<a name="ln3187">      stream_putc (s, BGP_ATTR_ATOMIC_AGGREGATE);</a>
<a name="ln3188">      stream_putc (s, 0);</a>
<a name="ln3189">    }</a>
<a name="ln3190"> </a>
<a name="ln3191">  /* Aggregator. */</a>
<a name="ln3192">  if (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR))</a>
<a name="ln3193">    {</a>
<a name="ln3194">      assert (attr-&gt;extra);</a>
<a name="ln3195">      stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);</a>
<a name="ln3196">      stream_putc (s, BGP_ATTR_AGGREGATOR);</a>
<a name="ln3197">      stream_putc (s, 8);</a>
<a name="ln3198">      stream_putl (s, attr-&gt;extra-&gt;aggregator_as);</a>
<a name="ln3199">      stream_put_ipv4 (s, attr-&gt;extra-&gt;aggregator_addr.s_addr);</a>
<a name="ln3200">    }</a>
<a name="ln3201"> </a>
<a name="ln3202">  /* Community attribute. */</a>
<a name="ln3203">  if (attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES))</a>
<a name="ln3204">    {</a>
<a name="ln3205">      if (attr-&gt;community-&gt;size * 4 &gt; 255)</a>
<a name="ln3206">	{</a>
<a name="ln3207">	  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln3208">	  stream_putc (s, BGP_ATTR_COMMUNITIES);</a>
<a name="ln3209">	  stream_putw (s, attr-&gt;community-&gt;size * 4);</a>
<a name="ln3210">	}</a>
<a name="ln3211">      else</a>
<a name="ln3212">	{</a>
<a name="ln3213">	  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);</a>
<a name="ln3214">	  stream_putc (s, BGP_ATTR_COMMUNITIES);</a>
<a name="ln3215">	  stream_putc (s, attr-&gt;community-&gt;size * 4);</a>
<a name="ln3216">	}</a>
<a name="ln3217">      stream_put (s, attr-&gt;community-&gt;val, attr-&gt;community-&gt;size * 4);</a>
<a name="ln3218">    }</a>
<a name="ln3219"> </a>
<a name="ln3220">    /* Large Community attribute. */</a>
<a name="ln3221">  if (attr-&gt;extra &amp;&amp; attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_LARGE_COMMUNITIES))</a>
<a name="ln3222">    {</a>
<a name="ln3223">      if (attr-&gt;extra-&gt;lcommunity-&gt;size * 12 &gt; 255)</a>
<a name="ln3224">	{</a>
<a name="ln3225">	  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS|BGP_ATTR_FLAG_EXTLEN);</a>
<a name="ln3226">	  stream_putc (s, BGP_ATTR_COMMUNITIES);</a>
<a name="ln3227">	  stream_putw (s, attr-&gt;extra-&gt;lcommunity-&gt;size * 12);</a>
<a name="ln3228">	}</a>
<a name="ln3229">      else</a>
<a name="ln3230">	{</a>
<a name="ln3231">	  stream_putc (s, BGP_ATTR_FLAG_OPTIONAL|BGP_ATTR_FLAG_TRANS);</a>
<a name="ln3232">	  stream_putc (s, BGP_ATTR_COMMUNITIES);</a>
<a name="ln3233">	  stream_putc (s, attr-&gt;extra-&gt;lcommunity-&gt;size * 12);</a>
<a name="ln3234">	}</a>
<a name="ln3235"> </a>
<a name="ln3236">      stream_put (s, attr-&gt;extra-&gt;lcommunity-&gt;val, attr-&gt;extra-&gt;lcommunity-&gt;size * 12);</a>
<a name="ln3237">    }</a>
<a name="ln3238"> </a>
<a name="ln3239">  /* Add a MP_NLRI attribute to dump the IPv6 next hop */</a>
<a name="ln3240">  if (prefix != NULL &amp;&amp; prefix-&gt;family == AF_INET6 &amp;&amp; attr-&gt;extra &amp;&amp;</a>
<a name="ln3241">     (attr-&gt;extra-&gt;mp_nexthop_len == 16 || attr-&gt;extra-&gt;mp_nexthop_len == 32) )</a>
<a name="ln3242">    {</a>
<a name="ln3243">      int sizep;</a>
<a name="ln3244">      struct attr_extra *attre = attr-&gt;extra;</a>
<a name="ln3245">      </a>
<a name="ln3246">      stream_putc(s, BGP_ATTR_FLAG_OPTIONAL);</a>
<a name="ln3247">      stream_putc(s, BGP_ATTR_MP_REACH_NLRI);</a>
<a name="ln3248">      sizep = stream_get_endp (s);</a>
<a name="ln3249"> </a>
<a name="ln3250">      /* MP header */</a>
<a name="ln3251">      stream_putc (s, 0);		/* Marker: Attribute length. */</a>
<a name="ln3252">      stream_putw(s, AFI_IP6);		/* AFI */</a>
<a name="ln3253">      stream_putc(s, SAFI_UNICAST);	/* SAFI */</a>
<a name="ln3254"> </a>
<a name="ln3255">      /* Next hop */</a>
<a name="ln3256">      stream_putc(s, attre-&gt;mp_nexthop_len);</a>
<a name="ln3257">      stream_put(s, &amp;attre-&gt;mp_nexthop_global, 16);</a>
<a name="ln3258">      if (attre-&gt;mp_nexthop_len == 32)</a>
<a name="ln3259">        stream_put(s, &amp;attre-&gt;mp_nexthop_local, 16);</a>
<a name="ln3260"> </a>
<a name="ln3261">      /* SNPA */</a>
<a name="ln3262">      stream_putc(s, 0);</a>
<a name="ln3263"> </a>
<a name="ln3264">      /* Prefix */</a>
<a name="ln3265">      stream_put_prefix(s, prefix);</a>
<a name="ln3266"> </a>
<a name="ln3267">      /* Set MP attribute length. */</a>
<a name="ln3268">      stream_putc_at (s, sizep, (stream_get_endp (s) - sizep) - 1);</a>
<a name="ln3269">    }</a>
<a name="ln3270"> </a>
<a name="ln3271">  /* Return total size of attribute. */</a>
<a name="ln3272">  len = stream_get_endp (s) - cp - 2;</a>
<a name="ln3273">  stream_putw_at (s, cp, len);</a>
<a name="ln3274">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="1250"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'as4_path' pointer was utilized before it was verified against nullptr. Check lines: 1250, 1264.</p></div>
<div class="balloon" rel="2416"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v768/" target="_blank">V768</a> The expression is of enum type. It is odd that it is used as an expression of a Boolean-type.</p></div>
<div class="balloon" rel="2655"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'attrtype == 23' is always true.</p></div>
<div class="balloon" rel="2663"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'attrtype == 23' is always true.</p></div>
<div class="balloon" rel="2781"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'safi == 4' is always false.</p></div>
<div class="balloon" rel="2908"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'attr->extra' pointer was utilized before it was verified against nullptr. Check lines: 2908, 2916.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
