
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>rip_routemap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* RIPv2 routemap.</a>
<a name="ln2"> * Copyright (C) 2005 6WIND &lt;alain.ritoux@6wind.com&gt;</a>
<a name="ln3"> * Copyright (C) 1999 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.  </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;routemap.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29">#include &quot;filter.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31">#include &quot;sockunion.h&quot;		/* for inet_aton () */</a>
<a name="ln32">#include &quot;plist.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;ripd/ripd.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">struct rip_metric_modifier</a>
<a name="ln37">{</a>
<a name="ln38">  enum </a>
<a name="ln39">  {</a>
<a name="ln40">    metric_increment,</a>
<a name="ln41">    metric_decrement,</a>
<a name="ln42">    metric_absolute</a>
<a name="ln43">  } type;</a>
<a name="ln44"> </a>
<a name="ln45">  u_char metric;</a>
<a name="ln46">};</a>
<a name="ln47"> </a>
<a name="ln48">/* Add rip route map rule. */</a>
<a name="ln49">static int</a>
<a name="ln50">rip_route_match_add (struct vty *vty, struct route_map_index *index,</a>
<a name="ln51">		     const char *command, const char *arg)</a>
<a name="ln52">{</a>
<a name="ln53">  int ret;</a>
<a name="ln54"> </a>
<a name="ln55">  ret = route_map_add_match (index, command, arg);</a>
<a name="ln56">  if (ret)</a>
<a name="ln57">    {</a>
<a name="ln58">      switch (ret)</a>
<a name="ln59">	{</a>
<a name="ln60">	case RMAP_RULE_MISSING:</a>
<a name="ln61">	  vty_out (vty, &quot;%% RIP Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln62">	  return CMD_WARNING;</a>
<a name="ln63">	case RMAP_COMPILE_ERROR:</a>
<a name="ln64">	  vty_out (vty, &quot;%% RIP Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln65">	  return CMD_WARNING;</a>
<a name="ln66">	}</a>
<a name="ln67">    }</a>
<a name="ln68">  return CMD_SUCCESS;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">/* Delete rip route map rule. */</a>
<a name="ln72">static int</a>
<a name="ln73">rip_route_match_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln74">			const char *command, const char *arg)</a>
<a name="ln75">{</a>
<a name="ln76">  int ret;</a>
<a name="ln77"> </a>
<a name="ln78">  ret = route_map_delete_match (index, command, arg);</a>
<a name="ln79">  if (ret)</a>
<a name="ln80">    {</a>
<a name="ln81">      switch (ret)</a>
<a name="ln82">	{</a>
<a name="ln83">	case RMAP_RULE_MISSING:</a>
<a name="ln84">	  vty_out (vty, &quot;%% RIP Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln85">	  return CMD_WARNING;</a>
<a name="ln86">	case RMAP_COMPILE_ERROR:</a>
<a name="ln87">	  vty_out (vty, &quot;%% RIP Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln88">	  return CMD_WARNING;</a>
<a name="ln89">	}</a>
<a name="ln90">    }</a>
<a name="ln91">  return CMD_SUCCESS;</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">/* Add rip route map rule. */</a>
<a name="ln95">static int</a>
<a name="ln96">rip_route_set_add (struct vty *vty, struct route_map_index *index,</a>
<a name="ln97">		   const char *command, const char *arg)</a>
<a name="ln98">{</a>
<a name="ln99">  int ret;</a>
<a name="ln100"> </a>
<a name="ln101">  ret = route_map_add_set (index, command, arg);</a>
<a name="ln102">  if (ret)</a>
<a name="ln103">    {</a>
<a name="ln104">      switch (ret)</a>
<a name="ln105">	{</a>
<a name="ln106">	case RMAP_RULE_MISSING:</a>
<a name="ln107">	  vty_out (vty, &quot;%% RIP Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln108">	  return CMD_WARNING;</a>
<a name="ln109">	case RMAP_COMPILE_ERROR:</a>
<a name="ln110">	  /* rip, ripng and other protocols share the set metric command</a>
<a name="ln111">	     but only values from 0 to 16 are valid for rip and ripng</a>
<a name="ln112">	     if metric is out of range for rip and ripng, it is not for</a>
<a name="ln113">	     other protocols. Do not return an error */</a>
<a name="ln114">	  if (strcmp(command, &quot;metric&quot;)) {</a>
<a name="ln115">	     vty_out (vty, &quot;%% RIP Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln116">	     return CMD_WARNING;</a>
<a name="ln117">	  }</a>
<a name="ln118">	}</a>
<a name="ln119">    }</a>
<a name="ln120">  return CMD_SUCCESS;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">/* Delete rip route map rule. */</a>
<a name="ln124">static int</a>
<a name="ln125">rip_route_set_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln126">		      const char *command, const char *arg)</a>
<a name="ln127">{</a>
<a name="ln128">  int ret;</a>
<a name="ln129"> </a>
<a name="ln130">  ret = route_map_delete_set (index, command, arg);</a>
<a name="ln131">  if (ret)</a>
<a name="ln132">    {</a>
<a name="ln133">      switch (ret)</a>
<a name="ln134">	{</a>
<a name="ln135">	case RMAP_RULE_MISSING:</a>
<a name="ln136">	  vty_out (vty, &quot;%% RIP Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln137">	  return CMD_WARNING;</a>
<a name="ln138">	case RMAP_COMPILE_ERROR:</a>
<a name="ln139">	  vty_out (vty, &quot;%% RIP Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln140">	  return CMD_WARNING;</a>
<a name="ln141">	}</a>
<a name="ln142">    }</a>
<a name="ln143">  return CMD_SUCCESS;</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">/* Hook function for updating route_map assignment. */</a>
<a name="ln147">/* ARGSUSED */</a>
<a name="ln148">static void</a>
<a name="ln149">rip_route_map_update (const char *notused)</a>
<a name="ln150">{</a>
<a name="ln151">  int i;</a>
<a name="ln152"> </a>
<a name="ln153">  if (rip) </a>
<a name="ln154">    {</a>
<a name="ln155">      for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++) </a>
<a name="ln156">	{</a>
<a name="ln157">	  if (rip-&gt;route_map[i].name)</a>
<a name="ln158">	    rip-&gt;route_map[i].map = </a>
<a name="ln159">	      route_map_lookup_by_name (rip-&gt;route_map[i].name);</a>
<a name="ln160">	}</a>
<a name="ln161">    }</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">/* `match metric METRIC' */</a>
<a name="ln165">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln166">static route_map_result_t</a>
<a name="ln167">route_match_metric (void *rule, struct prefix *prefix, </a>
<a name="ln168">		    route_map_object_t type, void *object)</a>
<a name="ln169">{</a>
<a name="ln170">  u_int32_t *metric;</a>
<a name="ln171">  u_int32_t  check;</a>
<a name="ln172">  struct rip_info *rinfo;</a>
<a name="ln173"> </a>
<a name="ln174">  if (type == RMAP_RIP)</a>
<a name="ln175">    {</a>
<a name="ln176">      metric = rule;</a>
<a name="ln177">      rinfo = object;</a>
<a name="ln178">    </a>
<a name="ln179">      /* If external metric is available, the route-map should</a>
<a name="ln180">         work on this one (for redistribute purpose)  */</a>
<a name="ln181">      check = (rinfo-&gt;external_metric) ? rinfo-&gt;external_metric :</a>
<a name="ln182">                                         rinfo-&gt;metric;</a>
<a name="ln183">      if (check == *metric)</a>
<a name="ln184">	return RMAP_MATCH;</a>
<a name="ln185">      else</a>
<a name="ln186">	return RMAP_NOMATCH;</a>
<a name="ln187">    }</a>
<a name="ln188">  return RMAP_NOMATCH;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">/* Route map `match metric' match statement. `arg' is METRIC value */</a>
<a name="ln192">static void *</a>
<a name="ln193">route_match_metric_compile (const char *arg)</a>
<a name="ln194">{</a>
<a name="ln195">  u_int32_t *metric;</a>
<a name="ln196"> </a>
<a name="ln197">  metric = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_int32_t));</a>
<a name="ln198">  *metric = atoi (arg);</a>
<a name="ln199"> </a>
<a name="ln200">  if(*metric &gt; 0)</a>
<a name="ln201">    return metric;</a>
<a name="ln202"> </a>
<a name="ln203">  XFREE (MTYPE_ROUTE_MAP_COMPILED, metric);</a>
<a name="ln204">  return NULL;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">/* Free route map's compiled `match metric' value. */</a>
<a name="ln208">static void</a>
<a name="ln209">route_match_metric_free (void *rule)</a>
<a name="ln210">{</a>
<a name="ln211">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">/* Route map commands for metric matching. */</a>
<a name="ln215">struct route_map_rule_cmd route_match_metric_cmd =</a>
<a name="ln216">{</a>
<a name="ln217">  &quot;metric&quot;,</a>
<a name="ln218">  route_match_metric,</a>
<a name="ln219">  route_match_metric_compile,</a>
<a name="ln220">  route_match_metric_free</a>
<a name="ln221">};</a>
<a name="ln222"> </a>
<a name="ln223">/* `match interface IFNAME' */</a>
<a name="ln224">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln225">static route_map_result_t</a>
<a name="ln226">route_match_interface (void *rule, struct prefix *prefix,</a>
<a name="ln227">		       route_map_object_t type, void *object)</a>
<a name="ln228">{</a>
<a name="ln229">  struct rip_info *rinfo;</a>
<a name="ln230">  struct interface *ifp;</a>
<a name="ln231">  char *ifname;</a>
<a name="ln232"> </a>
<a name="ln233">  if (type == RMAP_RIP)</a>
<a name="ln234">    {</a>
<a name="ln235">      ifname = rule;</a>
<a name="ln236">      ifp = if_lookup_by_name(ifname);</a>
<a name="ln237"> </a>
<a name="ln238">      if (!ifp)</a>
<a name="ln239">	return RMAP_NOMATCH;</a>
<a name="ln240"> </a>
<a name="ln241">      rinfo = object;</a>
<a name="ln242"> </a>
<a name="ln243">      if (rinfo-&gt;ifindex_out == ifp-&gt;ifindex || rinfo-&gt;ifindex == ifp-&gt;ifindex)</a>
<a name="ln244">	return RMAP_MATCH;</a>
<a name="ln245">      else</a>
<a name="ln246">	return RMAP_NOMATCH;</a>
<a name="ln247">    }</a>
<a name="ln248">  return RMAP_NOMATCH;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">/* Route map `match interface' match statement. `arg' is IFNAME value */</a>
<a name="ln252">/* XXX I don`t know if I need to check does interface exist? */</a>
<a name="ln253">static void *</a>
<a name="ln254">route_match_interface_compile (const char *arg)</a>
<a name="ln255">{</a>
<a name="ln256">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">/* Free route map's compiled `match interface' value. */</a>
<a name="ln260">static void</a>
<a name="ln261">route_match_interface_free (void *rule)</a>
<a name="ln262">{</a>
<a name="ln263">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln264">}</a>
<a name="ln265"> </a>
<a name="ln266">/* Route map commands for interface matching. */</a>
<a name="ln267">struct route_map_rule_cmd route_match_interface_cmd =</a>
<a name="ln268">{</a>
<a name="ln269">  &quot;interface&quot;,</a>
<a name="ln270">  route_match_interface,</a>
<a name="ln271">  route_match_interface_compile,</a>
<a name="ln272">  route_match_interface_free</a>
<a name="ln273">};</a>
<a name="ln274"> </a>
<a name="ln275">/* `match ip next-hop IP_ACCESS_LIST' */</a>
<a name="ln276"> </a>
<a name="ln277">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln278">static route_map_result_t</a>
<a name="ln279">route_match_ip_next_hop (void *rule, struct prefix *prefix,</a>
<a name="ln280">			route_map_object_t type, void *object)</a>
<a name="ln281">{</a>
<a name="ln282">  struct access_list *alist;</a>
<a name="ln283">  struct rip_info *rinfo;</a>
<a name="ln284">  struct prefix_ipv4 p;</a>
<a name="ln285"> </a>
<a name="ln286">  if (type == RMAP_RIP)</a>
<a name="ln287">    {</a>
<a name="ln288">      rinfo = object;</a>
<a name="ln289">      p.family = AF_INET;</a>
<a name="ln290">      p.prefix = (rinfo-&gt;nexthop.s_addr) ? rinfo-&gt;nexthop : rinfo-&gt;from;</a>
<a name="ln291">      p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln292"> </a>
<a name="ln293">      alist = access_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln294">      if (alist == NULL)</a>
<a name="ln295">	return RMAP_NOMATCH;</a>
<a name="ln296"> </a>
<a name="ln297">      return (access_list_apply (alist, &amp;p) == FILTER_DENY ?</a>
<a name="ln298">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln299">    }</a>
<a name="ln300">  return RMAP_NOMATCH;</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">/* Route map `ip next-hop' match statement.  `arg' should be</a>
<a name="ln304">   access-list name. */</a>
<a name="ln305">static void *</a>
<a name="ln306">route_match_ip_next_hop_compile (const char *arg)</a>
<a name="ln307">{</a>
<a name="ln308">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln309">}</a>
<a name="ln310"> </a>
<a name="ln311">/* Free route map's compiled `. */</a>
<a name="ln312">static void</a>
<a name="ln313">route_match_ip_next_hop_free (void *rule)</a>
<a name="ln314">{</a>
<a name="ln315">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln316">}</a>
<a name="ln317"> </a>
<a name="ln318">/* Route map commands for ip next-hop matching. */</a>
<a name="ln319">static struct route_map_rule_cmd route_match_ip_next_hop_cmd =</a>
<a name="ln320">{</a>
<a name="ln321">  &quot;ip next-hop&quot;,</a>
<a name="ln322">  route_match_ip_next_hop,</a>
<a name="ln323">  route_match_ip_next_hop_compile,</a>
<a name="ln324">  route_match_ip_next_hop_free</a>
<a name="ln325">};</a>
<a name="ln326"> </a>
<a name="ln327">/* `match ip next-hop prefix-list PREFIX_LIST' */</a>
<a name="ln328"> </a>
<a name="ln329">static route_map_result_t</a>
<a name="ln330">route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,</a>
<a name="ln331">                                    route_map_object_t type, void *object)</a>
<a name="ln332">{</a>
<a name="ln333">  struct prefix_list *plist;</a>
<a name="ln334">  struct rip_info *rinfo;</a>
<a name="ln335">  struct prefix_ipv4 p;</a>
<a name="ln336"> </a>
<a name="ln337">  if (type == RMAP_RIP)</a>
<a name="ln338">    {</a>
<a name="ln339">      rinfo = object;</a>
<a name="ln340">      p.family = AF_INET;</a>
<a name="ln341">      p.prefix = (rinfo-&gt;nexthop.s_addr) ? rinfo-&gt;nexthop : rinfo-&gt;from;</a>
<a name="ln342">      p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln343"> </a>
<a name="ln344">      plist = prefix_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln345">      if (plist == NULL)</a>
<a name="ln346">        return RMAP_NOMATCH;</a>
<a name="ln347"> </a>
<a name="ln348">      return (prefix_list_apply (plist, &amp;p) == PREFIX_DENY ?</a>
<a name="ln349">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln350">    }</a>
<a name="ln351">  return RMAP_NOMATCH;</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">static void *</a>
<a name="ln355">route_match_ip_next_hop_prefix_list_compile (const char *arg)</a>
<a name="ln356">{</a>
<a name="ln357">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">static void</a>
<a name="ln361">route_match_ip_next_hop_prefix_list_free (void *rule)</a>
<a name="ln362">{</a>
<a name="ln363">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">static struct route_map_rule_cmd route_match_ip_next_hop_prefix_list_cmd =</a>
<a name="ln367">{</a>
<a name="ln368">  &quot;ip next-hop prefix-list&quot;,</a>
<a name="ln369">  route_match_ip_next_hop_prefix_list,</a>
<a name="ln370">  route_match_ip_next_hop_prefix_list_compile,</a>
<a name="ln371">  route_match_ip_next_hop_prefix_list_free</a>
<a name="ln372">};</a>
<a name="ln373"> </a>
<a name="ln374">/* `match ip address IP_ACCESS_LIST' */</a>
<a name="ln375"> </a>
<a name="ln376">/* Match function should return 1 if match is success else return</a>
<a name="ln377">   zero. */</a>
<a name="ln378">static route_map_result_t</a>
<a name="ln379">route_match_ip_address (void *rule, struct prefix *prefix, </a>
<a name="ln380">			route_map_object_t type, void *object)</a>
<a name="ln381">{</a>
<a name="ln382">  struct access_list *alist;</a>
<a name="ln383"> </a>
<a name="ln384">  if (type == RMAP_RIP)</a>
<a name="ln385">    {</a>
<a name="ln386">      alist = access_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln387">      if (alist == NULL)</a>
<a name="ln388">	return RMAP_NOMATCH;</a>
<a name="ln389">    </a>
<a name="ln390">      return (access_list_apply (alist, prefix) == FILTER_DENY ?</a>
<a name="ln391">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln392">    }</a>
<a name="ln393">  return RMAP_NOMATCH;</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">/* Route map `ip address' match statement.  `arg' should be</a>
<a name="ln397">   access-list name. */</a>
<a name="ln398">static void *</a>
<a name="ln399">route_match_ip_address_compile (const char *arg)</a>
<a name="ln400">{</a>
<a name="ln401">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">/* Free route map's compiled `ip address' value. */</a>
<a name="ln405">static void</a>
<a name="ln406">route_match_ip_address_free (void *rule)</a>
<a name="ln407">{</a>
<a name="ln408">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">/* Route map commands for ip address matching. */</a>
<a name="ln412">static struct route_map_rule_cmd route_match_ip_address_cmd =</a>
<a name="ln413">{</a>
<a name="ln414">  &quot;ip address&quot;,</a>
<a name="ln415">  route_match_ip_address,</a>
<a name="ln416">  route_match_ip_address_compile,</a>
<a name="ln417">  route_match_ip_address_free</a>
<a name="ln418">};</a>
<a name="ln419"> </a>
<a name="ln420">/* `match ip address prefix-list PREFIX_LIST' */</a>
<a name="ln421"> </a>
<a name="ln422">static route_map_result_t</a>
<a name="ln423">route_match_ip_address_prefix_list (void *rule, struct prefix *prefix, </a>
<a name="ln424">				    route_map_object_t type, void *object)</a>
<a name="ln425">{</a>
<a name="ln426">  struct prefix_list *plist;</a>
<a name="ln427"> </a>
<a name="ln428">  if (type == RMAP_RIP)</a>
<a name="ln429">    {</a>
<a name="ln430">      plist = prefix_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln431">      if (plist == NULL)</a>
<a name="ln432">	return RMAP_NOMATCH;</a>
<a name="ln433">    </a>
<a name="ln434">      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?</a>
<a name="ln435">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln436">    }</a>
<a name="ln437">  return RMAP_NOMATCH;</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">static void *</a>
<a name="ln441">route_match_ip_address_prefix_list_compile (const char *arg)</a>
<a name="ln442">{</a>
<a name="ln443">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln444">}</a>
<a name="ln445"> </a>
<a name="ln446">static void</a>
<a name="ln447">route_match_ip_address_prefix_list_free (void *rule)</a>
<a name="ln448">{</a>
<a name="ln449">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln450">}</a>
<a name="ln451"> </a>
<a name="ln452">static struct route_map_rule_cmd route_match_ip_address_prefix_list_cmd =</a>
<a name="ln453">{</a>
<a name="ln454">  &quot;ip address prefix-list&quot;,</a>
<a name="ln455">  route_match_ip_address_prefix_list,</a>
<a name="ln456">  route_match_ip_address_prefix_list_compile,</a>
<a name="ln457">  route_match_ip_address_prefix_list_free</a>
<a name="ln458">};</a>
<a name="ln459"> </a>
<a name="ln460">/* `match tag TAG' */</a>
<a name="ln461">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln462">static route_map_result_t</a>
<a name="ln463">route_match_tag (void *rule, struct prefix *prefix, </a>
<a name="ln464">		    route_map_object_t type, void *object)</a>
<a name="ln465">{</a>
<a name="ln466">  route_tag_t *tag;</a>
<a name="ln467">  struct rip_info *rinfo;</a>
<a name="ln468"> </a>
<a name="ln469">  if (type == RMAP_RIP)</a>
<a name="ln470">    {</a>
<a name="ln471">      tag = rule;</a>
<a name="ln472">      rinfo = object;</a>
<a name="ln473"> </a>
<a name="ln474">      /* The information stored by rinfo is host ordered. */</a>
<a name="ln475">      if (rinfo-&gt;tag == *tag)</a>
<a name="ln476">	return RMAP_MATCH;</a>
<a name="ln477">      else</a>
<a name="ln478">	return RMAP_NOMATCH;</a>
<a name="ln479">    }</a>
<a name="ln480">  return RMAP_NOMATCH;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">/* Route map commands for tag matching. */</a>
<a name="ln484">static struct route_map_rule_cmd route_match_tag_cmd =</a>
<a name="ln485">{</a>
<a name="ln486">  &quot;tag&quot;,</a>
<a name="ln487">  route_match_tag,</a>
<a name="ln488">  route_map_rule_tag_compile,</a>
<a name="ln489">  route_map_rule_tag_free,</a>
<a name="ln490">};</a>
<a name="ln491"> </a>
<a name="ln492">/* `set metric METRIC' */</a>
<a name="ln493"> </a>
<a name="ln494">/* Set metric to attribute. */</a>
<a name="ln495">static route_map_result_t</a>
<a name="ln496">route_set_metric (void *rule, struct prefix *prefix, </a>
<a name="ln497">		  route_map_object_t type, void *object)</a>
<a name="ln498">{</a>
<a name="ln499">  if (type == RMAP_RIP)</a>
<a name="ln500">    {</a>
<a name="ln501">      struct rip_metric_modifier *mod;</a>
<a name="ln502">      struct rip_info *rinfo;</a>
<a name="ln503"> </a>
<a name="ln504">      mod = rule;</a>
<a name="ln505">      rinfo = object;</a>
<a name="ln506"> </a>
<a name="ln507">      if (mod-&gt;type == metric_increment)</a>
<a name="ln508">	rinfo-&gt;metric_out += mod-&gt;metric;</a>
<a name="ln509">      else if (mod-&gt;type == metric_decrement)</a>
<a name="ln510">	rinfo-&gt;metric_out -= mod-&gt;metric;</a>
<a name="ln511">      else if (mod-&gt;type == metric_absolute)</a>
<a name="ln512">	rinfo-&gt;metric_out = mod-&gt;metric;</a>
<a name="ln513"> </a>
<a name="ln514">      if ((signed int)rinfo-&gt;metric_out &lt; 1)</a>
<a name="ln515">	rinfo-&gt;metric_out = 1;</a>
<a name="ln516">      if (rinfo-&gt;metric_out &gt; RIP_METRIC_INFINITY)</a>
<a name="ln517">	rinfo-&gt;metric_out = RIP_METRIC_INFINITY;</a>
<a name="ln518"> </a>
<a name="ln519">      rinfo-&gt;metric_set = 1;</a>
<a name="ln520">    }</a>
<a name="ln521">  return RMAP_OKAY;</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">/* set metric compilation. */</a>
<a name="ln525">static void *</a>
<a name="ln526">route_set_metric_compile (const char *arg)</a>
<a name="ln527">{</a>
<a name="ln528">  int len;</a>
<a name="ln529">  const char *pnt;</a>
<a name="ln530">  int type;</a>
<a name="ln531">  long metric;</a>
<a name="ln532">  char *endptr = NULL;</a>
<a name="ln533">  struct rip_metric_modifier *mod;</a>
<a name="ln534"> </a>
<a name="ln535">  len = strlen (arg);</a>
<a name="ln536">  pnt = arg;</a>
<a name="ln537"> </a>
<a name="ln538">  if (len == 0)</a>
<a name="ln539">    return NULL;</a>
<a name="ln540"> </a>
<a name="ln541">  /* Examine first character. */</a>
<a name="ln542">  if (arg[0] == '+')</a>
<a name="ln543">    {</a>
<a name="ln544">      type = metric_increment;</a>
<a name="ln545">      pnt++;</a>
<a name="ln546">    }</a>
<a name="ln547">  else if (arg[0] == '-')</a>
<a name="ln548">    {</a>
<a name="ln549">      type = metric_decrement;</a>
<a name="ln550">      pnt++;</a>
<a name="ln551">    }</a>
<a name="ln552">  else</a>
<a name="ln553">    type = metric_absolute;</a>
<a name="ln554"> </a>
<a name="ln555">  /* Check beginning with digit string. */</a>
<a name="ln556">  if (*pnt &lt; '0' || *pnt &gt; '9')</a>
<a name="ln557">    return NULL;</a>
<a name="ln558"> </a>
<a name="ln559">  /* Convert string to integer. */</a>
<a name="ln560">  metric = strtol (pnt, &amp;endptr, 10);</a>
<a name="ln561"> </a>
<a name="ln562">  if (metric == LONG_MAX || *endptr != '\0')</a>
<a name="ln563">    return NULL;</a>
<a name="ln564">  if (metric &lt; 0 || metric &gt; RIP_METRIC_INFINITY)</a>
<a name="ln565">    return NULL;</a>
<a name="ln566"> </a>
<a name="ln567">  mod = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, </a>
<a name="ln568">		 sizeof (struct rip_metric_modifier));</a>
<a name="ln569">  mod-&gt;type = type;</a>
<a name="ln570">  mod-&gt;metric = metric;</a>
<a name="ln571"> </a>
<a name="ln572">  return mod;</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">/* Free route map's compiled `set metric' value. */</a>
<a name="ln576">static void</a>
<a name="ln577">route_set_metric_free (void *rule)</a>
<a name="ln578">{</a>
<a name="ln579">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">/* Set metric rule structure. */</a>
<a name="ln583">static struct route_map_rule_cmd route_set_metric_cmd = </a>
<a name="ln584">{</a>
<a name="ln585">  &quot;metric&quot;,</a>
<a name="ln586">  route_set_metric,</a>
<a name="ln587">  route_set_metric_compile,</a>
<a name="ln588">  route_set_metric_free,</a>
<a name="ln589">};</a>
<a name="ln590"> </a>
<a name="ln591">/* `set ip next-hop IP_ADDRESS' */</a>
<a name="ln592"> </a>
<a name="ln593">/* Set nexthop to object.  ojbect must be pointer to struct attr. */</a>
<a name="ln594">static route_map_result_t</a>
<a name="ln595">route_set_ip_nexthop (void *rule, struct prefix *prefix, </a>
<a name="ln596">		      route_map_object_t type, void *object)</a>
<a name="ln597">{</a>
<a name="ln598">  struct in_addr *address;</a>
<a name="ln599">  struct rip_info *rinfo;</a>
<a name="ln600"> </a>
<a name="ln601">  if(type == RMAP_RIP)</a>
<a name="ln602">    {</a>
<a name="ln603">      /* Fetch routemap's rule information. */</a>
<a name="ln604">      address = rule;</a>
<a name="ln605">      rinfo = object;</a>
<a name="ln606">    </a>
<a name="ln607">      /* Set next hop value. */ </a>
<a name="ln608">      rinfo-&gt;nexthop_out = *address;</a>
<a name="ln609">    }</a>
<a name="ln610"> </a>
<a name="ln611">  return RMAP_OKAY;</a>
<a name="ln612">}</a>
<a name="ln613"> </a>
<a name="ln614">/* Route map `ip nexthop' compile function.  Given string is converted</a>
<a name="ln615">   to struct in_addr structure. */</a>
<a name="ln616">static void *</a>
<a name="ln617">route_set_ip_nexthop_compile (const char *arg)</a>
<a name="ln618">{</a>
<a name="ln619">  int ret;</a>
<a name="ln620">  struct in_addr *address;</a>
<a name="ln621"> </a>
<a name="ln622">  address = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in_addr));</a>
<a name="ln623"> </a>
<a name="ln624">  ret = inet_aton (arg, address);</a>
<a name="ln625"> </a>
<a name="ln626">  if (ret == 0)</a>
<a name="ln627">    {</a>
<a name="ln628">      XFREE (MTYPE_ROUTE_MAP_COMPILED, address);</a>
<a name="ln629">      return NULL;</a>
<a name="ln630">    }</a>
<a name="ln631"> </a>
<a name="ln632">  return address;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">/* Free route map's compiled `ip nexthop' value. */</a>
<a name="ln636">static void</a>
<a name="ln637">route_set_ip_nexthop_free (void *rule)</a>
<a name="ln638">{</a>
<a name="ln639">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">/* Route map commands for ip nexthop set. */</a>
<a name="ln643">static struct route_map_rule_cmd route_set_ip_nexthop_cmd =</a>
<a name="ln644">{</a>
<a name="ln645">  &quot;ip next-hop&quot;,</a>
<a name="ln646">  route_set_ip_nexthop,</a>
<a name="ln647">  route_set_ip_nexthop_compile,</a>
<a name="ln648">  route_set_ip_nexthop_free</a>
<a name="ln649">};</a>
<a name="ln650"> </a>
<a name="ln651">/* `set tag TAG' */</a>
<a name="ln652"> </a>
<a name="ln653">/* Set tag to object.  ojbect must be pointer to struct attr. */</a>
<a name="ln654">static route_map_result_t</a>
<a name="ln655">route_set_tag (void *rule, struct prefix *prefix, </a>
<a name="ln656">		      route_map_object_t type, void *object)</a>
<a name="ln657">{</a>
<a name="ln658">  route_tag_t *tag;</a>
<a name="ln659">  struct rip_info *rinfo;</a>
<a name="ln660"> </a>
<a name="ln661">  if(type == RMAP_RIP)</a>
<a name="ln662">    {</a>
<a name="ln663">      /* Fetch routemap's rule information. */</a>
<a name="ln664">      tag = rule;</a>
<a name="ln665">      rinfo = object;</a>
<a name="ln666">    </a>
<a name="ln667">      /* Set next hop value. */ </a>
<a name="ln668">      rinfo-&gt;tag_out = *tag;</a>
<a name="ln669">    }</a>
<a name="ln670"> </a>
<a name="ln671">  return RMAP_OKAY;</a>
<a name="ln672">}</a>
<a name="ln673"> </a>
<a name="ln674">/* Route map commands for tag set. */</a>
<a name="ln675">static struct route_map_rule_cmd route_set_tag_cmd =</a>
<a name="ln676">{</a>
<a name="ln677">  &quot;tag&quot;,</a>
<a name="ln678">  route_set_tag,</a>
<a name="ln679">  route_map_rule_tag_compile,</a>
<a name="ln680">  route_map_rule_tag_free</a>
<a name="ln681">};</a>
<a name="ln682"> </a>
<a name="ln683">#define MATCH_STR &quot;Match values from routing table\n&quot;</a>
<a name="ln684">#define SET_STR &quot;Set values in destination routing protocol\n&quot;</a>
<a name="ln685"> </a>
<a name="ln686">DEFUN (match_metric, </a>
<a name="ln687">       match_metric_cmd,</a>
<a name="ln688">       &quot;match metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln689">       MATCH_STR</a>
<a name="ln690">       &quot;Match metric of route\n&quot;</a>
<a name="ln691">       &quot;Metric value\n&quot;)</a>
<a name="ln692">{</a>
<a name="ln693">  return rip_route_match_add (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">DEFUN (no_match_metric,</a>
<a name="ln697">       no_match_metric_cmd,</a>
<a name="ln698">       &quot;no match metric&quot;,</a>
<a name="ln699">       NO_STR</a>
<a name="ln700">       MATCH_STR</a>
<a name="ln701">       &quot;Match metric of route\n&quot;)</a>
<a name="ln702">{</a>
<a name="ln703">  if (argc == 0)</a>
<a name="ln704">    return rip_route_match_delete (vty, vty-&gt;index, &quot;metric&quot;, NULL);</a>
<a name="ln705"> </a>
<a name="ln706">  return rip_route_match_delete (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">ALIAS (no_match_metric,</a>
<a name="ln710">       no_match_metric_val_cmd,</a>
<a name="ln711">       &quot;no match metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln712">       NO_STR</a>
<a name="ln713">       MATCH_STR</a>
<a name="ln714">       &quot;Match metric of route\n&quot;</a>
<a name="ln715">       &quot;Metric value\n&quot;)</a>
<a name="ln716"> </a>
<a name="ln717">DEFUN (match_interface,</a>
<a name="ln718">       match_interface_cmd,</a>
<a name="ln719">       &quot;match interface WORD&quot;,</a>
<a name="ln720">       MATCH_STR</a>
<a name="ln721">       &quot;Match first hop interface of route\n&quot;</a>
<a name="ln722">       &quot;Interface name\n&quot;)</a>
<a name="ln723">{</a>
<a name="ln724">  return rip_route_match_add (vty, vty-&gt;index, &quot;interface&quot;, argv[0]);</a>
<a name="ln725">}</a>
<a name="ln726"> </a>
<a name="ln727">DEFUN (no_match_interface,</a>
<a name="ln728">       no_match_interface_cmd,</a>
<a name="ln729">       &quot;no match interface&quot;,</a>
<a name="ln730">       NO_STR</a>
<a name="ln731">       MATCH_STR</a>
<a name="ln732">       &quot;Match first hop interface of route\n&quot;)</a>
<a name="ln733">{</a>
<a name="ln734">  if (argc == 0)</a>
<a name="ln735">    return rip_route_match_delete (vty, vty-&gt;index, &quot;interface&quot;, NULL);</a>
<a name="ln736"> </a>
<a name="ln737">  return rip_route_match_delete (vty, vty-&gt;index, &quot;interface&quot;, argv[0]);</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">ALIAS (no_match_interface,</a>
<a name="ln741">       no_match_interface_val_cmd,</a>
<a name="ln742">       &quot;no match interface WORD&quot;,</a>
<a name="ln743">       NO_STR</a>
<a name="ln744">       MATCH_STR</a>
<a name="ln745">       &quot;Match first hop interface of route\n&quot;</a>
<a name="ln746">       &quot;Interface name\n&quot;)</a>
<a name="ln747"> </a>
<a name="ln748">DEFUN (match_ip_next_hop,</a>
<a name="ln749">       match_ip_next_hop_cmd,</a>
<a name="ln750">       &quot;match ip next-hop (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln751">       MATCH_STR</a>
<a name="ln752">       IP_STR</a>
<a name="ln753">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln754">       &quot;IP access-list number\n&quot;</a>
<a name="ln755">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln756">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln757">{</a>
<a name="ln758">  return rip_route_match_add (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">DEFUN (no_match_ip_next_hop,</a>
<a name="ln762">       no_match_ip_next_hop_cmd,</a>
<a name="ln763">       &quot;no match ip next-hop&quot;,</a>
<a name="ln764">       NO_STR</a>
<a name="ln765">       MATCH_STR</a>
<a name="ln766">       IP_STR</a>
<a name="ln767">       &quot;Match next-hop address of route\n&quot;)</a>
<a name="ln768">{</a>
<a name="ln769">  if (argc == 0)</a>
<a name="ln770">    return rip_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, NULL);</a>
<a name="ln771"> </a>
<a name="ln772">  return rip_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln773">}</a>
<a name="ln774"> </a>
<a name="ln775">ALIAS (no_match_ip_next_hop,</a>
<a name="ln776">       no_match_ip_next_hop_val_cmd,</a>
<a name="ln777">       &quot;no match ip next-hop (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln778">       NO_STR</a>
<a name="ln779">       MATCH_STR</a>
<a name="ln780">       IP_STR</a>
<a name="ln781">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln782">       &quot;IP access-list number\n&quot;</a>
<a name="ln783">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln784">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln785"> </a>
<a name="ln786">DEFUN (match_ip_next_hop_prefix_list,</a>
<a name="ln787">       match_ip_next_hop_prefix_list_cmd,</a>
<a name="ln788">       &quot;match ip next-hop prefix-list WORD&quot;,</a>
<a name="ln789">       MATCH_STR</a>
<a name="ln790">       IP_STR</a>
<a name="ln791">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln792">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln793">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln794">{</a>
<a name="ln795">  return rip_route_match_add (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;, argv[0]);</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">DEFUN (no_match_ip_next_hop_prefix_list,</a>
<a name="ln799">       no_match_ip_next_hop_prefix_list_cmd,</a>
<a name="ln800">       &quot;no match ip next-hop prefix-list&quot;,</a>
<a name="ln801">       NO_STR</a>
<a name="ln802">       MATCH_STR</a>
<a name="ln803">       IP_STR</a>
<a name="ln804">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln805">       &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln806">{</a>
<a name="ln807">  if (argc == 0)</a>
<a name="ln808">    return rip_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;, NULL);</a>
<a name="ln809"> </a>
<a name="ln810">  return rip_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;, argv[0]);</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">ALIAS (no_match_ip_next_hop_prefix_list,</a>
<a name="ln814">       no_match_ip_next_hop_prefix_list_val_cmd,</a>
<a name="ln815">       &quot;no match ip next-hop prefix-list WORD&quot;,</a>
<a name="ln816">       NO_STR</a>
<a name="ln817">       MATCH_STR</a>
<a name="ln818">       IP_STR</a>
<a name="ln819">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln820">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln821">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln822"> </a>
<a name="ln823">DEFUN (match_ip_address,</a>
<a name="ln824">       match_ip_address_cmd,</a>
<a name="ln825">       &quot;match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln826">       MATCH_STR</a>
<a name="ln827">       IP_STR</a>
<a name="ln828">       &quot;Match address of route\n&quot;</a>
<a name="ln829">       &quot;IP access-list number\n&quot;</a>
<a name="ln830">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln831">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln832"> </a>
<a name="ln833">{</a>
<a name="ln834">  return rip_route_match_add (vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln835">}</a>
<a name="ln836"> </a>
<a name="ln837">DEFUN (no_match_ip_address, </a>
<a name="ln838">       no_match_ip_address_cmd,</a>
<a name="ln839">       &quot;no match ip address&quot;,</a>
<a name="ln840">       NO_STR</a>
<a name="ln841">       MATCH_STR</a>
<a name="ln842">       IP_STR</a>
<a name="ln843">       &quot;Match address of route\n&quot;)</a>
<a name="ln844">{</a>
<a name="ln845">  if (argc == 0)</a>
<a name="ln846">    return rip_route_match_delete (vty, vty-&gt;index, &quot;ip address&quot;, NULL);</a>
<a name="ln847"> </a>
<a name="ln848">  return rip_route_match_delete (vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln849">}</a>
<a name="ln850"> </a>
<a name="ln851">ALIAS (no_match_ip_address,</a>
<a name="ln852">       no_match_ip_address_val_cmd,</a>
<a name="ln853">       &quot;no match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln854">       NO_STR</a>
<a name="ln855">       MATCH_STR</a>
<a name="ln856">       IP_STR</a>
<a name="ln857">       &quot;Match address of route\n&quot;</a>
<a name="ln858">       &quot;IP access-list number\n&quot;</a>
<a name="ln859">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln860">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln861"> </a>
<a name="ln862">DEFUN (match_ip_address_prefix_list, </a>
<a name="ln863">       match_ip_address_prefix_list_cmd,</a>
<a name="ln864">       &quot;match ip address prefix-list WORD&quot;,</a>
<a name="ln865">       MATCH_STR</a>
<a name="ln866">       IP_STR</a>
<a name="ln867">       &quot;Match address of route\n&quot;</a>
<a name="ln868">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln869">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln870">{</a>
<a name="ln871">  return rip_route_match_add (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, argv[0]);</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">DEFUN (no_match_ip_address_prefix_list,</a>
<a name="ln875">       no_match_ip_address_prefix_list_cmd,</a>
<a name="ln876">       &quot;no match ip address prefix-list&quot;,</a>
<a name="ln877">       NO_STR</a>
<a name="ln878">       MATCH_STR</a>
<a name="ln879">       IP_STR</a>
<a name="ln880">       &quot;Match address of route\n&quot;</a>
<a name="ln881">       &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln882">{</a>
<a name="ln883">  if (argc == 0)</a>
<a name="ln884">    return rip_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, NULL);</a>
<a name="ln885"> </a>
<a name="ln886">  return rip_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, argv[0]);</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">ALIAS (no_match_ip_address_prefix_list,</a>
<a name="ln890">       no_match_ip_address_prefix_list_val_cmd,</a>
<a name="ln891">       &quot;no match ip address prefix-list WORD&quot;,</a>
<a name="ln892">       NO_STR</a>
<a name="ln893">       MATCH_STR</a>
<a name="ln894">       IP_STR</a>
<a name="ln895">       &quot;Match address of route\n&quot;</a>
<a name="ln896">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln897">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln898"> </a>
<a name="ln899">DEFUN (match_tag, </a>
<a name="ln900">       match_tag_cmd,</a>
<a name="ln901">       &quot;match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln902">       MATCH_STR</a>
<a name="ln903">       &quot;Match tag of route\n&quot;</a>
<a name="ln904">       &quot;Metric value\n&quot;)</a>
<a name="ln905">{</a>
<a name="ln906">  return rip_route_match_add (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">DEFUN (no_match_tag,</a>
<a name="ln910">       no_match_tag_cmd,</a>
<a name="ln911">       &quot;no match tag&quot;,</a>
<a name="ln912">       NO_STR</a>
<a name="ln913">       MATCH_STR</a>
<a name="ln914">       &quot;Match tag of route\n&quot;)</a>
<a name="ln915">{</a>
<a name="ln916">  if (argc == 0)</a>
<a name="ln917">    return rip_route_match_delete (vty, vty-&gt;index, &quot;tag&quot;, NULL);</a>
<a name="ln918"> </a>
<a name="ln919">  return rip_route_match_delete (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln920">}</a>
<a name="ln921"> </a>
<a name="ln922">ALIAS (no_match_tag,</a>
<a name="ln923">       no_match_tag_val_cmd,</a>
<a name="ln924">       &quot;no match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln925">       NO_STR</a>
<a name="ln926">       MATCH_STR</a>
<a name="ln927">       &quot;Match tag of route\n&quot;</a>
<a name="ln928">       &quot;Metric value\n&quot;)</a>
<a name="ln929"> </a>
<a name="ln930">/* set functions */</a>
<a name="ln931"> </a>
<a name="ln932">DEFUN (set_metric,</a>
<a name="ln933">       set_metric_cmd,</a>
<a name="ln934">       &quot;set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln935">       SET_STR</a>
<a name="ln936">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln937">       &quot;Metric value\n&quot;)</a>
<a name="ln938">{</a>
<a name="ln939">  return rip_route_set_add (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln940">}</a>
<a name="ln941"> </a>
<a name="ln942">ALIAS (set_metric,</a>
<a name="ln943">       set_metric_addsub_cmd,</a>
<a name="ln944">       &quot;set metric &lt;+/-metric&gt;&quot;,</a>
<a name="ln945">       SET_STR</a>
<a name="ln946">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln947">       &quot;Add or subtract metric\n&quot;)</a>
<a name="ln948"> </a>
<a name="ln949">DEFUN (no_set_metric,</a>
<a name="ln950">       no_set_metric_cmd,</a>
<a name="ln951">       &quot;no set metric&quot;,</a>
<a name="ln952">       NO_STR</a>
<a name="ln953">       SET_STR</a>
<a name="ln954">       &quot;Metric value for destination routing protocol\n&quot;)</a>
<a name="ln955">{</a>
<a name="ln956">  if (argc == 0)</a>
<a name="ln957">    return rip_route_set_delete (vty, vty-&gt;index, &quot;metric&quot;, NULL);</a>
<a name="ln958"> </a>
<a name="ln959">  return rip_route_set_delete (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln960">}</a>
<a name="ln961"> </a>
<a name="ln962">ALIAS (no_set_metric,</a>
<a name="ln963">       no_set_metric_val_cmd,</a>
<a name="ln964">       &quot;no set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln965">       NO_STR</a>
<a name="ln966">       SET_STR</a>
<a name="ln967">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln968">       &quot;Metric value\n&quot;)</a>
<a name="ln969"> </a>
<a name="ln970">ALIAS (no_set_metric,</a>
<a name="ln971">       no_set_metric_addsub_cmd,</a>
<a name="ln972">       &quot;no set metric &lt;+/-metric&gt;&quot;,</a>
<a name="ln973">       NO_STR</a>
<a name="ln974">       SET_STR</a>
<a name="ln975">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln976">       &quot;Add or subtract metric\n&quot;)</a>
<a name="ln977"> </a>
<a name="ln978">DEFUN (set_ip_nexthop,</a>
<a name="ln979">       set_ip_nexthop_cmd,</a>
<a name="ln980">       &quot;set ip next-hop A.B.C.D&quot;,</a>
<a name="ln981">       SET_STR</a>
<a name="ln982">       IP_STR</a>
<a name="ln983">       &quot;Next hop address\n&quot;</a>
<a name="ln984">       &quot;IP address of next hop\n&quot;)</a>
<a name="ln985">{</a>
<a name="ln986">  union sockunion su;</a>
<a name="ln987">  int ret;</a>
<a name="ln988"> </a>
<a name="ln989">  ret = str2sockunion (argv[0], &amp;su);</a>
<a name="ln990">  if (ret &lt; 0)</a>
<a name="ln991">    {</a>
<a name="ln992">      vty_out (vty, &quot;%% Malformed next-hop address%s&quot;, VTY_NEWLINE);</a>
<a name="ln993">      return CMD_WARNING;</a>
<a name="ln994">    }</a>
<a name="ln995"> </a>
<a name="ln996">  return rip_route_set_add (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln997">}</a>
<a name="ln998"> </a>
<a name="ln999">DEFUN (no_set_ip_nexthop,</a>
<a name="ln1000">       no_set_ip_nexthop_cmd,</a>
<a name="ln1001">       &quot;no set ip next-hop&quot;,</a>
<a name="ln1002">       NO_STR</a>
<a name="ln1003">       SET_STR</a>
<a name="ln1004">       IP_STR</a>
<a name="ln1005">       &quot;Next hop address\n&quot;)</a>
<a name="ln1006">{</a>
<a name="ln1007">  if (argc == 0)</a>
<a name="ln1008">    return rip_route_set_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, NULL);</a>
<a name="ln1009">  </a>
<a name="ln1010">  return rip_route_set_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">ALIAS (no_set_ip_nexthop,</a>
<a name="ln1014">       no_set_ip_nexthop_val_cmd,</a>
<a name="ln1015">       &quot;no set ip next-hop A.B.C.D&quot;,</a>
<a name="ln1016">       NO_STR</a>
<a name="ln1017">       SET_STR</a>
<a name="ln1018">       IP_STR</a>
<a name="ln1019">       &quot;Next hop address\n&quot;</a>
<a name="ln1020">       &quot;IP address of next hop\n&quot;)</a>
<a name="ln1021"> </a>
<a name="ln1022">DEFUN (set_tag,</a>
<a name="ln1023">       set_tag_cmd,</a>
<a name="ln1024">       &quot;set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln1025">       SET_STR</a>
<a name="ln1026">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln1027">       &quot;Tag value\n&quot;)</a>
<a name="ln1028">{</a>
<a name="ln1029">  return rip_route_set_add (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln1030">}</a>
<a name="ln1031"> </a>
<a name="ln1032">DEFUN (no_set_tag,</a>
<a name="ln1033">       no_set_tag_cmd,</a>
<a name="ln1034">       &quot;no set tag&quot;,</a>
<a name="ln1035">       NO_STR</a>
<a name="ln1036">       SET_STR</a>
<a name="ln1037">       &quot;Tag value for routing protocol\n&quot;)</a>
<a name="ln1038">{</a>
<a name="ln1039">  if (argc == 0)</a>
<a name="ln1040">    return rip_route_set_delete (vty, vty-&gt;index, &quot;tag&quot;, NULL);</a>
<a name="ln1041">  </a>
<a name="ln1042">  return rip_route_set_delete (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln1043">}</a>
<a name="ln1044"> </a>
<a name="ln1045">ALIAS (no_set_tag,</a>
<a name="ln1046">       no_set_tag_val_cmd,</a>
<a name="ln1047">       &quot;no set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln1048">       NO_STR</a>
<a name="ln1049">       SET_STR</a>
<a name="ln1050">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln1051">       &quot;Tag value\n&quot;)</a>
<a name="ln1052"> </a>
<a name="ln1053">void</a>
<a name="ln1054">rip_route_map_reset ()</a>
<a name="ln1055">{</a>
<a name="ln1056">  ;</a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>
<a name="ln1059">/* Route-map init */</a>
<a name="ln1060">void</a>
<a name="ln1061">rip_route_map_init ()</a>
<a name="ln1062">{</a>
<a name="ln1063">  route_map_init ();</a>
<a name="ln1064">  route_map_init_vty ();</a>
<a name="ln1065">  route_map_add_hook (rip_route_map_update);</a>
<a name="ln1066">  route_map_delete_hook (rip_route_map_update);</a>
<a name="ln1067"> </a>
<a name="ln1068">  route_map_install_match (&amp;route_match_metric_cmd);</a>
<a name="ln1069">  route_map_install_match (&amp;route_match_interface_cmd);</a>
<a name="ln1070">  route_map_install_match (&amp;route_match_ip_next_hop_cmd);</a>
<a name="ln1071">  route_map_install_match (&amp;route_match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln1072">  route_map_install_match (&amp;route_match_ip_address_cmd);</a>
<a name="ln1073">  route_map_install_match (&amp;route_match_ip_address_prefix_list_cmd);</a>
<a name="ln1074">  route_map_install_match (&amp;route_match_tag_cmd);</a>
<a name="ln1075"> </a>
<a name="ln1076">  route_map_install_set (&amp;route_set_metric_cmd);</a>
<a name="ln1077">  route_map_install_set (&amp;route_set_ip_nexthop_cmd);</a>
<a name="ln1078">  route_map_install_set (&amp;route_set_tag_cmd);</a>
<a name="ln1079"> </a>
<a name="ln1080">  install_element (RMAP_NODE, &amp;match_metric_cmd);</a>
<a name="ln1081">  install_element (RMAP_NODE, &amp;no_match_metric_cmd);</a>
<a name="ln1082">  install_element (RMAP_NODE, &amp;no_match_metric_val_cmd);</a>
<a name="ln1083">  install_element (RMAP_NODE, &amp;match_interface_cmd);</a>
<a name="ln1084">  install_element (RMAP_NODE, &amp;no_match_interface_cmd);</a>
<a name="ln1085">  install_element (RMAP_NODE, &amp;no_match_interface_val_cmd);</a>
<a name="ln1086">  install_element (RMAP_NODE, &amp;match_ip_next_hop_cmd);</a>
<a name="ln1087">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_cmd);</a>
<a name="ln1088">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_val_cmd);</a>
<a name="ln1089">  install_element (RMAP_NODE, &amp;match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln1090">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln1091">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_prefix_list_val_cmd);</a>
<a name="ln1092">  install_element (RMAP_NODE, &amp;match_ip_address_cmd);</a>
<a name="ln1093">  install_element (RMAP_NODE, &amp;no_match_ip_address_cmd);</a>
<a name="ln1094">  install_element (RMAP_NODE, &amp;no_match_ip_address_val_cmd);</a>
<a name="ln1095">  install_element (RMAP_NODE, &amp;match_ip_address_prefix_list_cmd);</a>
<a name="ln1096">  install_element (RMAP_NODE, &amp;no_match_ip_address_prefix_list_cmd);</a>
<a name="ln1097">  install_element (RMAP_NODE, &amp;no_match_ip_address_prefix_list_val_cmd);</a>
<a name="ln1098">  install_element (RMAP_NODE, &amp;match_tag_cmd);</a>
<a name="ln1099">  install_element (RMAP_NODE, &amp;no_match_tag_cmd);</a>
<a name="ln1100">  install_element (RMAP_NODE, &amp;no_match_tag_val_cmd);</a>
<a name="ln1101"> </a>
<a name="ln1102">  install_element (RMAP_NODE, &amp;set_metric_cmd);</a>
<a name="ln1103">  install_element (RMAP_NODE, &amp;set_metric_addsub_cmd);</a>
<a name="ln1104">  install_element (RMAP_NODE, &amp;no_set_metric_cmd);</a>
<a name="ln1105">  install_element (RMAP_NODE, &amp;no_set_metric_val_cmd);</a>
<a name="ln1106">  install_element (RMAP_NODE, &amp;no_set_metric_addsub_cmd);</a>
<a name="ln1107">  install_element (RMAP_NODE, &amp;set_ip_nexthop_cmd);</a>
<a name="ln1108">  install_element (RMAP_NODE, &amp;no_set_ip_nexthop_cmd);</a>
<a name="ln1109">  install_element (RMAP_NODE, &amp;no_set_ip_nexthop_val_cmd);</a>
<a name="ln1110">  install_element (RMAP_NODE, &amp;set_tag_cmd);</a>
<a name="ln1111">  install_element (RMAP_NODE, &amp;no_set_tag_cmd);</a>
<a name="ln1112">  install_element (RMAP_NODE, &amp;no_set_tag_val_cmd);</a>
<a name="ln1113">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
