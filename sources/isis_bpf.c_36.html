
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_bpf.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol - isis_bpf.c</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2001,2002    Sampo Saaristo</a>
<a name="ln5"> *                            Tampere University of Technology      </a>
<a name="ln6"> *                            Institute of Communications Engineering</a>
<a name="ln7"> *</a>
<a name="ln8"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln9"> * under the terms of the GNU General Public Licenseas published by the Free </a>
<a name="ln10"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln11"> * any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln14"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln15"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln16"> * more details.</a>
<a name="ln17"> </a>
<a name="ln18"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln19"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln20"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24">#if ISIS_METHOD == ISIS_METHOD_BPF</a>
<a name="ln25">#include &lt;net/if.h&gt;</a>
<a name="ln26">#include &lt;netinet/if_ether.h&gt;</a>
<a name="ln27">#include &lt;sys/time.h&gt;</a>
<a name="ln28">#include &lt;sys/ioctl.h&gt;</a>
<a name="ln29">#include &lt;net/bpf.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;log.h&quot;</a>
<a name="ln32">#include &quot;network.h&quot;</a>
<a name="ln33">#include &quot;stream.h&quot;</a>
<a name="ln34">#include &quot;if.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;isisd/dict.h&quot;</a>
<a name="ln37">#include &quot;isisd/include-netbsd/iso.h&quot;</a>
<a name="ln38">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln39">#include &quot;isisd/isis_common.h&quot;</a>
<a name="ln40">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln41">#include &quot;isisd/isis_flags.h&quot;</a>
<a name="ln42">#include &quot;isisd/isisd.h&quot;</a>
<a name="ln43">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln44">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln45">#include &quot;isisd/isis_network.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#include &quot;privs.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">extern struct zebra_privs_t isisd_privs;</a>
<a name="ln50"> </a>
<a name="ln51">struct bpf_insn llcfilter[] = {</a>
<a name="ln52">  BPF_STMT (BPF_LD + BPF_B + BPF_ABS, ETHER_HDR_LEN),	/* check first byte */</a>
<a name="ln53">  BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, ISO_SAP, 0, 5),</a>
<a name="ln54">  BPF_STMT (BPF_LD + BPF_B + BPF_ABS, ETHER_HDR_LEN + 1),</a>
<a name="ln55">  BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, ISO_SAP, 0, 3),	/* check second byte */</a>
<a name="ln56">  BPF_STMT (BPF_LD + BPF_B + BPF_ABS, ETHER_HDR_LEN + 2),</a>
<a name="ln57">  BPF_JUMP (BPF_JMP + BPF_JEQ + BPF_K, 0x03, 0, 1),	/* check third byte */</a>
<a name="ln58">  BPF_STMT (BPF_RET + BPF_K, (u_int) - 1),</a>
<a name="ln59">  BPF_STMT (BPF_RET + BPF_K, 0)</a>
<a name="ln60">};</a>
<a name="ln61">u_int readblen = 0;</a>
<a name="ln62">u_char *readbuff = NULL;</a>
<a name="ln63"> </a>
<a name="ln64">/*</a>
<a name="ln65"> * Table 9 - Architectural constants for use with ISO 8802 subnetworks</a>
<a name="ln66"> * ISO 10589 - 8.4.8</a>
<a name="ln67"> */</a>
<a name="ln68"> </a>
<a name="ln69">u_char ALL_L1_ISS[6] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x14 };</a>
<a name="ln70">u_char ALL_L2_ISS[6] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x15 };</a>
<a name="ln71">u_char ALL_ISS[6] = { 0x09, 0x00, 0x2B, 0x00, 0x00, 0x05 };</a>
<a name="ln72">u_char ALL_ESS[6] = { 0x09, 0x00, 0x2B, 0x00, 0x00, 0x04 };</a>
<a name="ln73"> </a>
<a name="ln74">static char sock_buff[8192];</a>
<a name="ln75"> </a>
<a name="ln76">static int</a>
<a name="ln77">open_bpf_dev (struct isis_circuit *circuit)</a>
<a name="ln78">{</a>
<a name="ln79">  int i = 0, fd;</a>
<a name="ln80">  char bpfdev[128];</a>
<a name="ln81">  struct ifreq ifr;</a>
<a name="ln82">  u_int blen, immediate, seesent;</a>
<a name="ln83">  struct timeval timeout;</a>
<a name="ln84">  struct bpf_program bpf_prog;</a>
<a name="ln85"> </a>
<a name="ln86">  do</a>
<a name="ln87">    {</a>
<a name="ln88">      (void) snprintf (bpfdev, sizeof (bpfdev), &quot;/dev/bpf%d&quot;, i++);</a>
<a name="ln89">      fd = open (bpfdev, O_RDWR);</a>
<a name="ln90">    }</a>
<a name="ln91">  while (fd &lt; 0 &amp;&amp; errno == EBUSY);</a>
<a name="ln92"> </a>
<a name="ln93">  if (fd &lt; 0)</a>
<a name="ln94">    {</a>
<a name="ln95">      zlog_warn (&quot;open_bpf_dev(): failed to create bpf socket: %s&quot;,</a>
<a name="ln96">		 safe_strerror (errno));</a>
<a name="ln97">      return ISIS_WARNING;</a>
<a name="ln98">    }</a>
<a name="ln99"> </a>
<a name="ln100">  zlog_debug (&quot;Opened BPF device %s&quot;, bpfdev);</a>
<a name="ln101"> </a>
<a name="ln102">  memcpy (ifr.ifr_name, circuit-&gt;interface-&gt;name, sizeof (ifr.ifr_name));</a>
<a name="ln103">  if (ioctl (fd, BIOCSETIF, (caddr_t) &amp; ifr) &lt; 0)</a>
<a name="ln104">    {</a>
<a name="ln105">      zlog_warn (&quot;open_bpf_dev(): failed to bind to interface: %s&quot;,</a>
<a name="ln106">		 safe_strerror (errno));</a>
<a name="ln107">      return ISIS_WARNING;</a>
<a name="ln108">    }</a>
<a name="ln109"> </a>
<a name="ln110">  if (ioctl (fd, BIOCGBLEN, (caddr_t) &amp; blen) &lt; 0)</a>
<a name="ln111">    {</a>
<a name="ln112">      zlog_warn (&quot;failed to get BPF buffer len&quot;);</a>
<a name="ln113">      blen = circuit-&gt;interface-&gt;mtu;</a>
<a name="ln114">    }</a>
<a name="ln115"> </a>
<a name="ln116">  readblen = blen;</a>
<a name="ln117"> </a>
<a name="ln118">  if (readbuff == NULL)</a>
<a name="ln119">    readbuff = malloc (blen);</a>
<a name="ln120"> </a>
<a name="ln121">  zlog_debug (&quot;BPF buffer len = %u&quot;, blen);</a>
<a name="ln122"> </a>
<a name="ln123">  /*  BPF(4): reads return immediately upon packet reception.</a>
<a name="ln124">   *  Otherwise, a read will block until either the kernel</a>
<a name="ln125">   *  buffer becomes full or a timeout occurs. </a>
<a name="ln126">   */</a>
<a name="ln127">  immediate = 1;</a>
<a name="ln128">  if (ioctl (fd, BIOCIMMEDIATE, (caddr_t) &amp; immediate) &lt; 0)</a>
<a name="ln129">    {</a>
<a name="ln130">      zlog_warn (&quot;failed to set BPF dev to immediate mode&quot;);</a>
<a name="ln131">    }</a>
<a name="ln132"> </a>
<a name="ln133">#ifdef BIOCSSEESENT</a>
<a name="ln134">  /*</a>
<a name="ln135">   * We want to see only incoming packets</a>
<a name="ln136">   */</a>
<a name="ln137">  seesent = 0;</a>
<a name="ln138">  if (ioctl (fd, BIOCSSEESENT, (caddr_t) &amp; seesent) &lt; 0)</a>
<a name="ln139">    {</a>
<a name="ln140">      zlog_warn (&quot;failed to set BPF dev to incoming only mode&quot;);</a>
<a name="ln141">    }</a>
<a name="ln142">#endif</a>
<a name="ln143"> </a>
<a name="ln144">  /*</a>
<a name="ln145">   * ...but all of them</a>
<a name="ln146">   */</a>
<a name="ln147">  if (ioctl (fd, BIOCPROMISC) &lt; 0)</a>
<a name="ln148">    {</a>
<a name="ln149">      zlog_warn (&quot;failed to set BPF dev to promiscuous mode&quot;);</a>
<a name="ln150">    }</a>
<a name="ln151"> </a>
<a name="ln152">  /*</a>
<a name="ln153">   * If the buffer length is smaller than our mtu, lets try to increase it</a>
<a name="ln154">   */</a>
<a name="ln155">  if (blen &lt; circuit-&gt;interface-&gt;mtu)</a>
<a name="ln156">    {</a>
<a name="ln157">      if (ioctl (fd, BIOCSBLEN, &amp;circuit-&gt;interface-&gt;mtu) &lt; 0)</a>
<a name="ln158">	{</a>
<a name="ln159">	  zlog_warn (&quot;failed to set BPF buffer len (%u to %u)&quot;, blen,</a>
<a name="ln160">		     circuit-&gt;interface-&gt;mtu);</a>
<a name="ln161">	}</a>
<a name="ln162">    }</a>
<a name="ln163"> </a>
<a name="ln164">  /*</a>
<a name="ln165">   * Set a timeout parameter - hope this helps select()</a>
<a name="ln166">   */</a>
<a name="ln167">  timeout.tv_sec = 600;</a>
<a name="ln168">  timeout.tv_usec = 0;</a>
<a name="ln169">  if (ioctl (fd, BIOCSRTIMEOUT, (caddr_t) &amp; timeout) &lt; 0)</a>
<a name="ln170">    {</a>
<a name="ln171">      zlog_warn (&quot;failed to set BPF device timeout&quot;);</a>
<a name="ln172">    }</a>
<a name="ln173"> </a>
<a name="ln174">  /*</a>
<a name="ln175">   * And set the filter</a>
<a name="ln176">   */</a>
<a name="ln177">  memset (&amp;bpf_prog, 0, sizeof (struct bpf_program));</a>
<a name="ln178">  bpf_prog.bf_len = 8;</a>
<a name="ln179">  bpf_prog.bf_insns = &amp;(llcfilter[0]);</a>
<a name="ln180">  if (ioctl (fd, BIOCSETF, (caddr_t) &amp; bpf_prog) &lt; 0)</a>
<a name="ln181">    {</a>
<a name="ln182">      zlog_warn (&quot;open_bpf_dev(): failed to install filter: %s&quot;,</a>
<a name="ln183">		 safe_strerror (errno));</a>
<a name="ln184">      return ISIS_WARNING;</a>
<a name="ln185">    }</a>
<a name="ln186"> </a>
<a name="ln187">  assert (fd &gt; 0);</a>
<a name="ln188"> </a>
<a name="ln189">  circuit-&gt;fd = fd;</a>
<a name="ln190"> </a>
<a name="ln191">  return ISIS_OK;</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">/*</a>
<a name="ln195"> * Create the socket and set the tx/rx funcs</a>
<a name="ln196"> */</a>
<a name="ln197">int</a>
<a name="ln198">isis_sock_init (struct isis_circuit *circuit)</a>
<a name="ln199">{</a>
<a name="ln200">  int retval = ISIS_OK;</a>
<a name="ln201"> </a>
<a name="ln202">  if (isisd_privs.change (ZPRIVS_RAISE))</a>
<a name="ln203">    zlog_err (&quot;%s: could not raise privs, %s&quot;, __func__, safe_strerror (errno));</a>
<a name="ln204"> </a>
<a name="ln205">  retval = open_bpf_dev (circuit);</a>
<a name="ln206"> </a>
<a name="ln207">  if (retval != ISIS_OK)</a>
<a name="ln208">    {</a>
<a name="ln209">      zlog_warn (&quot;%s: could not initialize the socket&quot;, __func__);</a>
<a name="ln210">      goto end;</a>
<a name="ln211">    }</a>
<a name="ln212"> </a>
<a name="ln213">  if (circuit-&gt;circ_type == CIRCUIT_T_BROADCAST)</a>
<a name="ln214">    {</a>
<a name="ln215">      circuit-&gt;tx = isis_send_pdu_bcast;</a>
<a name="ln216">      circuit-&gt;rx = isis_recv_pdu_bcast;</a>
<a name="ln217">    }</a>
<a name="ln218">  else if (circuit-&gt;circ_type == CIRCUIT_T_P2P)</a>
<a name="ln219">    {</a>
<a name="ln220">      circuit-&gt;tx = isis_send_pdu_p2p;</a>
<a name="ln221">      circuit-&gt;rx = isis_recv_pdu_p2p;</a>
<a name="ln222">    }</a>
<a name="ln223">  else</a>
<a name="ln224">    {</a>
<a name="ln225">      zlog_warn (&quot;isis_sock_init(): unknown circuit type&quot;);</a>
<a name="ln226">      retval = ISIS_WARNING;</a>
<a name="ln227">      goto end;</a>
<a name="ln228">    }</a>
<a name="ln229"> </a>
<a name="ln230">end:</a>
<a name="ln231">  if (isisd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln232">    zlog_err (&quot;%s: could not lower privs, %s&quot;, __func__, safe_strerror (errno));</a>
<a name="ln233"> </a>
<a name="ln234">  return retval;</a>
<a name="ln235">}</a>
<a name="ln236"> </a>
<a name="ln237">int</a>
<a name="ln238">isis_recv_pdu_bcast (struct isis_circuit *circuit, u_char * ssnpa)</a>
<a name="ln239">{</a>
<a name="ln240">  int bytesread = 0, bytestoread, offset, one = 1;</a>
<a name="ln241">  struct bpf_hdr *bpf_hdr;</a>
<a name="ln242"> </a>
<a name="ln243">  assert (circuit-&gt;fd &gt; 0);</a>
<a name="ln244"> </a>
<a name="ln245">  if (ioctl (circuit-&gt;fd, FIONREAD, (caddr_t) &amp; bytestoread) &lt; 0)</a>
<a name="ln246">    {</a>
<a name="ln247">      zlog_warn (&quot;ioctl() FIONREAD failed: %s&quot;, safe_strerror (errno));</a>
<a name="ln248">    }</a>
<a name="ln249"> </a>
<a name="ln250">  if (bytestoread)</a>
<a name="ln251">    {</a>
<a name="ln252">      bytesread = read (circuit-&gt;fd, readbuff, readblen);</a>
<a name="ln253">    }</a>
<a name="ln254">  if (bytesread &lt; 0)</a>
<a name="ln255">    {</a>
<a name="ln256">      zlog_warn (&quot;isis_recv_pdu_bcast(): read() failed: %s&quot;,</a>
<a name="ln257">		 safe_strerror (errno));</a>
<a name="ln258">      return ISIS_WARNING;</a>
<a name="ln259">    }</a>
<a name="ln260"> </a>
<a name="ln261">  if (bytesread == 0)</a>
<a name="ln262">    return ISIS_WARNING;</a>
<a name="ln263"> </a>
<a name="ln264">  bpf_hdr = (struct bpf_hdr *) readbuff;</a>
<a name="ln265"> </a>
<a name="ln266">  assert (bpf_hdr-&gt;bh_caplen == bpf_hdr-&gt;bh_datalen);</a>
<a name="ln267"> </a>
<a name="ln268">  offset = bpf_hdr-&gt;bh_hdrlen + LLC_LEN + ETHER_HDR_LEN;</a>
<a name="ln269"> </a>
<a name="ln270">  /* then we lose the BPF, LLC and ethernet headers */</a>
<a name="ln271">  stream_write (circuit-&gt;rcv_stream, readbuff + offset, </a>
<a name="ln272">                bpf_hdr-&gt;bh_caplen - LLC_LEN - ETHER_HDR_LEN);</a>
<a name="ln273">  stream_set_getp (circuit-&gt;rcv_stream, 0);</a>
<a name="ln274"> </a>
<a name="ln275">  memcpy (ssnpa, readbuff + bpf_hdr-&gt;bh_hdrlen + ETHER_ADDR_LEN,</a>
<a name="ln276">	  ETHER_ADDR_LEN);</a>
<a name="ln277"> </a>
<a name="ln278">  if (ioctl (circuit-&gt;fd, BIOCFLUSH, &amp;one) &lt; 0)</a>
<a name="ln279">    zlog_warn (&quot;Flushing failed: %s&quot;, safe_strerror (errno));</a>
<a name="ln280"> </a>
<a name="ln281">  return ISIS_OK;</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">int</a>
<a name="ln285">isis_recv_pdu_p2p (struct isis_circuit *circuit, u_char * ssnpa)</a>
<a name="ln286">{</a>
<a name="ln287">  int bytesread;</a>
<a name="ln288"> </a>
<a name="ln289">  bytesread = stream_read (circuit-&gt;rcv_stream, circuit-&gt;fd, </a>
<a name="ln290">                           circuit-&gt;interface-&gt;mtu);</a>
<a name="ln291"> </a>
<a name="ln292">  if (bytesread &lt; 0)</a>
<a name="ln293">    {</a>
<a name="ln294">      zlog_warn (&quot;isis_recv_pdu_p2p(): read () failed: %s&quot;, safe_strerror (errno));</a>
<a name="ln295">      return ISIS_WARNING;</a>
<a name="ln296">    }</a>
<a name="ln297"> </a>
<a name="ln298">  return ISIS_OK;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">int</a>
<a name="ln302">isis_send_pdu_bcast (struct isis_circuit *circuit, int level)</a>
<a name="ln303">{</a>
<a name="ln304">  struct ether_header *eth;</a>
<a name="ln305">  ssize_t written;</a>
<a name="ln306">  size_t buflen;</a>
<a name="ln307"> </a>
<a name="ln308">  buflen = stream_get_endp (circuit-&gt;snd_stream) + LLC_LEN + ETHER_HDR_LEN;</a>
<a name="ln309">  if (buflen &gt; sizeof (sock_buff))</a>
<a name="ln310">    {</a>
<a name="ln311">      zlog_warn (&quot;isis_send_pdu_bcast: sock_buff size %zu is less than &quot;</a>
<a name="ln312">		 &quot;output pdu size %zu on circuit %s&quot;,</a>
<a name="ln313">		 sizeof (sock_buff), buflen, circuit-&gt;interface-&gt;name);</a>
<a name="ln314">      return ISIS_WARNING;</a>
<a name="ln315">    }</a>
<a name="ln316"> </a>
<a name="ln317">  stream_set_getp (circuit-&gt;snd_stream, 0);</a>
<a name="ln318"> </a>
<a name="ln319">  /*</a>
<a name="ln320">   * First the eth header</a>
<a name="ln321">   */</a>
<a name="ln322">  eth = (struct ether_header *) sock_buff;</a>
<a name="ln323">  if (level == 1)</a>
<a name="ln324">    memcpy (eth-&gt;ether_dhost, ALL_L1_ISS, ETHER_ADDR_LEN);</a>
<a name="ln325">  else</a>
<a name="ln326">    memcpy (eth-&gt;ether_dhost, ALL_L2_ISS, ETHER_ADDR_LEN);</a>
<a name="ln327">  memcpy (eth-&gt;ether_shost, circuit-&gt;u.bc.snpa, ETHER_ADDR_LEN);</a>
<a name="ln328">  eth-&gt;ether_type = htons (stream_get_endp (circuit-&gt;snd_stream) + LLC_LEN);</a>
<a name="ln329"> </a>
<a name="ln330">  /*</a>
<a name="ln331">   * Then the LLC</a>
<a name="ln332">   */</a>
<a name="ln333">  sock_buff[ETHER_HDR_LEN] = ISO_SAP;</a>
<a name="ln334">  sock_buff[ETHER_HDR_LEN + 1] = ISO_SAP;</a>
<a name="ln335">  sock_buff[ETHER_HDR_LEN + 2] = 0x03;</a>
<a name="ln336"> </a>
<a name="ln337">  /* then we copy the data */</a>
<a name="ln338">  memcpy (sock_buff + (LLC_LEN + ETHER_HDR_LEN), circuit-&gt;snd_stream-&gt;data,</a>
<a name="ln339">	  stream_get_endp (circuit-&gt;snd_stream));</a>
<a name="ln340"> </a>
<a name="ln341">  /* now we can send this */</a>
<a name="ln342">  written = write (circuit-&gt;fd, sock_buff, buflen);</a>
<a name="ln343">  if (written &lt; 0)</a>
<a name="ln344">    {</a>
<a name="ln345">      zlog_warn(&quot;IS-IS bpf: could not transmit packet on %s: %s&quot;,</a>
<a name="ln346">                circuit-&gt;interface-&gt;name, safe_strerror(errno));</a>
<a name="ln347">      if (ERRNO_IO_RETRY(errno))</a>
<a name="ln348">        return ISIS_WARNING;</a>
<a name="ln349">      return ISIS_ERROR;</a>
<a name="ln350">    }</a>
<a name="ln351"> </a>
<a name="ln352">  return ISIS_OK;</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">int</a>
<a name="ln356">isis_send_pdu_p2p (struct isis_circuit *circuit, int level)</a>
<a name="ln357">{</a>
<a name="ln358">  return ISIS_OK;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">#endif /* ISIS_METHOD == ISIS_METHOD_BPF */</a>

</code></pre>
<div class="balloon" rel="15"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
