
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ripd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* RIP version 1 and 2.</a>
<a name="ln2"> * Copyright (C) 2005 6WIND &lt;alain.ritoux@6wind.com&gt;</a>
<a name="ln3"> * Copyright (C) 1997, 98, 99 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.  </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;if.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;table.h&quot;</a>
<a name="ln29">#include &quot;thread.h&quot;</a>
<a name="ln30">#include &quot;memory.h&quot;</a>
<a name="ln31">#include &quot;log.h&quot;</a>
<a name="ln32">#include &quot;stream.h&quot;</a>
<a name="ln33">#include &quot;filter.h&quot;</a>
<a name="ln34">#include &quot;sockunion.h&quot;</a>
<a name="ln35">#include &quot;sockopt.h&quot;</a>
<a name="ln36">#include &quot;routemap.h&quot;</a>
<a name="ln37">#include &quot;if_rmap.h&quot;</a>
<a name="ln38">#include &quot;plist.h&quot;</a>
<a name="ln39">#include &quot;distribute.h&quot;</a>
<a name="ln40">#include &quot;md5.h&quot;</a>
<a name="ln41">#include &quot;keychain.h&quot;</a>
<a name="ln42">#include &quot;privs.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;ripd/ripd.h&quot;</a>
<a name="ln45">#include &quot;ripd/rip_debug.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">/* UDP receive buffer size */</a>
<a name="ln48">#define RIP_UDP_RCV_BUF 41600</a>
<a name="ln49"> </a>
<a name="ln50">/* privileges global */</a>
<a name="ln51">extern struct zebra_privs_t ripd_privs;</a>
<a name="ln52"> </a>
<a name="ln53">/* RIP Structure. */</a>
<a name="ln54">struct rip *rip = NULL;</a>
<a name="ln55"> </a>
<a name="ln56">/* RIP neighbor address table. */</a>
<a name="ln57">struct route_table *rip_neighbor_table;</a>
<a name="ln58"> </a>
<a name="ln59">/* RIP route changes. */</a>
<a name="ln60">long rip_global_route_changes = 0;</a>
<a name="ln61"> </a>
<a name="ln62">/* RIP queries. */</a>
<a name="ln63">long rip_global_queries = 0;</a>
<a name="ln64"> </a>
<a name="ln65">/* Prototypes. */</a>
<a name="ln66">static void rip_event (enum rip_event, int);</a>
<a name="ln67">static void rip_output_process (struct connected *, struct sockaddr_in *, int, u_char);</a>
<a name="ln68">static int rip_triggered_update (struct thread *);</a>
<a name="ln69">static int rip_update_jitter (unsigned long);</a>
<a name="ln70"> </a>
<a name="ln71">/* RIP output routes type. */</a>
<a name="ln72">enum</a>
<a name="ln73">{</a>
<a name="ln74">  rip_all_route,</a>
<a name="ln75">  rip_changed_route</a>
<a name="ln76">};</a>
<a name="ln77"> </a>
<a name="ln78">/* RIP command strings. */</a>
<a name="ln79">static const struct message rip_msg[] =</a>
<a name="ln80">{</a>
<a name="ln81">  {RIP_REQUEST,    &quot;REQUEST&quot;},</a>
<a name="ln82">  {RIP_RESPONSE,   &quot;RESPONSE&quot;},</a>
<a name="ln83">  {RIP_TRACEON,    &quot;TRACEON&quot;},</a>
<a name="ln84">  {RIP_TRACEOFF,   &quot;TRACEOFF&quot;},</a>
<a name="ln85">  {RIP_POLL,       &quot;POLL&quot;},</a>
<a name="ln86">  {RIP_POLL_ENTRY, &quot;POLL ENTRY&quot;},</a>
<a name="ln87">  {0, NULL},</a>
<a name="ln88">};</a>
<a name="ln89"> </a>
<a name="ln90">/* Utility function to set boradcast option to the socket. */</a>
<a name="ln91">static int</a>
<a name="ln92">sockopt_broadcast (int sock)</a>
<a name="ln93">{</a>
<a name="ln94">  int ret;</a>
<a name="ln95">  int on = 1;</a>
<a name="ln96"> </a>
<a name="ln97">  ret = setsockopt (sock, SOL_SOCKET, SO_BROADCAST, (char *) &amp;on, sizeof on);</a>
<a name="ln98">  if (ret &lt; 0)</a>
<a name="ln99">    {</a>
<a name="ln100">      zlog_warn (&quot;can't set sockopt SO_BROADCAST to socket %d&quot;, sock);</a>
<a name="ln101">      return -1;</a>
<a name="ln102">    }</a>
<a name="ln103">  return 0;</a>
<a name="ln104">}</a>
<a name="ln105"> </a>
<a name="ln106">static int</a>
<a name="ln107">rip_route_rte (struct rip_info *rinfo)</a>
<a name="ln108">{</a>
<a name="ln109">  return (rinfo-&gt;type == ZEBRA_ROUTE_RIP &amp;&amp; rinfo-&gt;sub_type == RIP_ROUTE_RTE);</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">static struct rip_info *</a>
<a name="ln113">rip_info_new (void)</a>
<a name="ln114">{</a>
<a name="ln115">  return XCALLOC (MTYPE_RIP_INFO, sizeof (struct rip_info));</a>
<a name="ln116">}</a>
<a name="ln117"> </a>
<a name="ln118">void</a>
<a name="ln119">rip_info_free (struct rip_info *rinfo)</a>
<a name="ln120">{</a>
<a name="ln121">  XFREE (MTYPE_RIP_INFO, rinfo);</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">/* RIP route garbage collect timer. */</a>
<a name="ln125">static int</a>
<a name="ln126">rip_garbage_collect (struct thread *t)</a>
<a name="ln127">{</a>
<a name="ln128">  struct rip_info *rinfo;</a>
<a name="ln129">  struct route_node *rp;</a>
<a name="ln130"> </a>
<a name="ln131">  rinfo = THREAD_ARG (t);</a>
<a name="ln132">  rinfo-&gt;t_garbage_collect = NULL;</a>
<a name="ln133"> </a>
<a name="ln134">  /* Off timeout timer. */</a>
<a name="ln135">  RIP_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln136">  </a>
<a name="ln137">  /* Get route_node pointer. */</a>
<a name="ln138">  rp = rinfo-&gt;rp;</a>
<a name="ln139"> </a>
<a name="ln140">  /* Unlock route_node. */</a>
<a name="ln141">  listnode_delete (rp-&gt;info, rinfo);</a>
<a name="ln142">  if (list_isempty ((struct list *)rp-&gt;info))</a>
<a name="ln143">    {</a>
<a name="ln144">      list_free (rp-&gt;info);</a>
<a name="ln145">      rp-&gt;info = NULL;</a>
<a name="ln146">      route_unlock_node (rp);</a>
<a name="ln147">    }</a>
<a name="ln148"> </a>
<a name="ln149">  /* Free RIP routing information. */</a>
<a name="ln150">  rip_info_free (rinfo);</a>
<a name="ln151"> </a>
<a name="ln152">  return 0;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">static void rip_timeout_update (struct rip_info *rinfo);</a>
<a name="ln156"> </a>
<a name="ln157">/* Add new route to the ECMP list.</a>
<a name="ln158"> * RETURN: the new entry added in the list, or NULL if it is not the first</a>
<a name="ln159"> *         entry and ECMP is not allowed.</a>
<a name="ln160"> */</a>
<a name="ln161">struct rip_info *</a>
<a name="ln162">rip_ecmp_add (struct rip_info *rinfo_new)</a>
<a name="ln163">{</a>
<a name="ln164">  struct route_node *rp = rinfo_new-&gt;rp;</a>
<a name="ln165">  struct rip_info *rinfo = NULL;</a>
<a name="ln166">  struct list *list = NULL;</a>
<a name="ln167"> </a>
<a name="ln168">  if (rp-&gt;info == NULL)</a>
<a name="ln169">    rp-&gt;info = list_new ();</a>
<a name="ln170">  list = (struct list *)rp-&gt;info;</a>
<a name="ln171"> </a>
<a name="ln172">  /* If ECMP is not allowed and some entry already exists in the list,</a>
<a name="ln173">   * do nothing. */</a>
<a name="ln174">  if (listcount (list) &amp;&amp; !rip-&gt;ecmp)</a>
<a name="ln175">    return NULL;</a>
<a name="ln176"> </a>
<a name="ln177">  rinfo = rip_info_new ();</a>
<a name="ln178">  memcpy (rinfo, rinfo_new, sizeof (struct rip_info));</a>
<a name="ln179">  listnode_add (list, rinfo);</a>
<a name="ln180"> </a>
<a name="ln181">  if (rip_route_rte (rinfo))</a>
<a name="ln182">    {</a>
<a name="ln183">      rip_timeout_update (rinfo);</a>
<a name="ln184">      rip_zebra_ipv4_add (rp);</a>
<a name="ln185">    }</a>
<a name="ln186"> </a>
<a name="ln187">  /* Set the route change flag on the first entry. */</a>
<a name="ln188">  rinfo = listgetdata (listhead (list));</a>
<a name="ln189">  SET_FLAG (rinfo-&gt;flags, RIP_RTF_CHANGED);</a>
<a name="ln190"> </a>
<a name="ln191">  /* Signal the output process to trigger an update (see section 2.5). */</a>
<a name="ln192">  rip_event (RIP_TRIGGERED_UPDATE, 0);</a>
<a name="ln193"> </a>
<a name="ln194">  return rinfo;</a>
<a name="ln195">}</a>
<a name="ln196"> </a>
<a name="ln197">/* Replace the ECMP list with the new route.</a>
<a name="ln198"> * RETURN: the new entry added in the list</a>
<a name="ln199"> */</a>
<a name="ln200">struct rip_info *</a>
<a name="ln201">rip_ecmp_replace (struct rip_info *rinfo_new)</a>
<a name="ln202">{</a>
<a name="ln203">  struct route_node *rp = rinfo_new-&gt;rp;</a>
<a name="ln204">  struct list *list = (struct list *)rp-&gt;info;</a>
<a name="ln205">  struct rip_info *rinfo = NULL, *tmp_rinfo = NULL;</a>
<a name="ln206">  struct listnode *node = NULL, *nextnode = NULL;</a>
<a name="ln207"> </a>
<a name="ln208">  if (list == NULL || listcount (list) == 0)</a>
<a name="ln209">    return rip_ecmp_add (rinfo_new);</a>
<a name="ln210"> </a>
<a name="ln211">  /* Get the first entry */</a>
<a name="ln212">  rinfo = listgetdata (listhead (list));</a>
<a name="ln213"> </a>
<a name="ln214">  /* Learnt route replaced by a local one. Delete it from zebra. */</a>
<a name="ln215">  if (rip_route_rte (rinfo) &amp;&amp; !rip_route_rte (rinfo_new))</a>
<a name="ln216">    if (CHECK_FLAG (rinfo-&gt;flags, RIP_RTF_FIB))</a>
<a name="ln217">      rip_zebra_ipv4_delete (rp);</a>
<a name="ln218"> </a>
<a name="ln219">  /* Re-use the first entry, and delete the others. */</a>
<a name="ln220">  for (ALL_LIST_ELEMENTS (list, node, nextnode, tmp_rinfo))</a>
<a name="ln221">    if (tmp_rinfo != rinfo)</a>
<a name="ln222">      {</a>
<a name="ln223">        RIP_TIMER_OFF (tmp_rinfo-&gt;t_timeout);</a>
<a name="ln224">        RIP_TIMER_OFF (tmp_rinfo-&gt;t_garbage_collect);</a>
<a name="ln225">        list_delete_node (list, node);</a>
<a name="ln226">        rip_info_free (tmp_rinfo);</a>
<a name="ln227">      }</a>
<a name="ln228"> </a>
<a name="ln229">  RIP_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln230">  RIP_TIMER_OFF (rinfo-&gt;t_garbage_collect);</a>
<a name="ln231">  memcpy (rinfo, rinfo_new, sizeof (struct rip_info));</a>
<a name="ln232"> </a>
<a name="ln233">  if (rip_route_rte (rinfo))</a>
<a name="ln234">    {</a>
<a name="ln235">      rip_timeout_update (rinfo);</a>
<a name="ln236">      /* The ADD message implies an update. */</a>
<a name="ln237">      rip_zebra_ipv4_add (rp);</a>
<a name="ln238">    }</a>
<a name="ln239"> </a>
<a name="ln240">  /* Set the route change flag. */</a>
<a name="ln241">  SET_FLAG (rinfo-&gt;flags, RIP_RTF_CHANGED);</a>
<a name="ln242"> </a>
<a name="ln243">  /* Signal the output process to trigger an update (see section 2.5). */</a>
<a name="ln244">  rip_event (RIP_TRIGGERED_UPDATE, 0);</a>
<a name="ln245"> </a>
<a name="ln246">  return rinfo;</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">/* Delete one route from the ECMP list.</a>
<a name="ln250"> * RETURN:</a>
<a name="ln251"> *  null - the entry is freed, and other entries exist in the list</a>
<a name="ln252"> *  the entry - the entry is the last one in the list; its metric is set</a>
<a name="ln253"> *              to INFINITY, and the garbage collector is started for it</a>
<a name="ln254"> */</a>
<a name="ln255">struct rip_info *</a>
<a name="ln256">rip_ecmp_delete (struct rip_info *rinfo)</a>
<a name="ln257">{</a>
<a name="ln258">  struct route_node *rp = rinfo-&gt;rp;</a>
<a name="ln259">  struct list *list = (struct list *)rp-&gt;info;</a>
<a name="ln260"> </a>
<a name="ln261">  RIP_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln262"> </a>
<a name="ln263">  if (listcount (list) &gt; 1)</a>
<a name="ln264">    {</a>
<a name="ln265">      /* Some other ECMP entries still exist. Just delete this entry. */</a>
<a name="ln266">      RIP_TIMER_OFF (rinfo-&gt;t_garbage_collect);</a>
<a name="ln267">      listnode_delete (list, rinfo);</a>
<a name="ln268">      if (rip_route_rte (rinfo) &amp;&amp; CHECK_FLAG (rinfo-&gt;flags, RIP_RTF_FIB))</a>
<a name="ln269">        /* The ADD message implies the update. */</a>
<a name="ln270">        rip_zebra_ipv4_add (rp);</a>
<a name="ln271">      rip_info_free (rinfo);</a>
<a name="ln272">      rinfo = NULL;</a>
<a name="ln273">    }</a>
<a name="ln274">  else</a>
<a name="ln275">    {</a>
<a name="ln276">      assert (rinfo == listgetdata (listhead (list)));</a>
<a name="ln277"> </a>
<a name="ln278">      /* This is the only entry left in the list. We must keep it in</a>
<a name="ln279">       * the list for garbage collection time, with INFINITY metric. */</a>
<a name="ln280"> </a>
<a name="ln281">      rinfo-&gt;metric = RIP_METRIC_INFINITY;</a>
<a name="ln282">      RIP_TIMER_ON (rinfo-&gt;t_garbage_collect,</a>
<a name="ln283">                    rip_garbage_collect, rip-&gt;garbage_time);</a>
<a name="ln284"> </a>
<a name="ln285">      if (rip_route_rte (rinfo) &amp;&amp; CHECK_FLAG (rinfo-&gt;flags, RIP_RTF_FIB))</a>
<a name="ln286">        rip_zebra_ipv4_delete (rp);</a>
<a name="ln287">    }</a>
<a name="ln288"> </a>
<a name="ln289">  /* Set the route change flag on the first entry. */</a>
<a name="ln290">  rinfo = listgetdata (listhead (list));</a>
<a name="ln291">  SET_FLAG (rinfo-&gt;flags, RIP_RTF_CHANGED);</a>
<a name="ln292"> </a>
<a name="ln293">  /* Signal the output process to trigger an update (see section 2.5). */</a>
<a name="ln294">  rip_event (RIP_TRIGGERED_UPDATE, 0);</a>
<a name="ln295"> </a>
<a name="ln296">  return rinfo;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">/* Timeout RIP routes. */</a>
<a name="ln300">static int</a>
<a name="ln301">rip_timeout (struct thread *t)</a>
<a name="ln302">{</a>
<a name="ln303">  rip_ecmp_delete ((struct rip_info *)THREAD_ARG (t));</a>
<a name="ln304">  return 0;</a>
<a name="ln305">}</a>
<a name="ln306"> </a>
<a name="ln307">static void</a>
<a name="ln308">rip_timeout_update (struct rip_info *rinfo)</a>
<a name="ln309">{</a>
<a name="ln310">  if (rinfo-&gt;metric != RIP_METRIC_INFINITY)</a>
<a name="ln311">    {</a>
<a name="ln312">      RIP_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln313">      RIP_TIMER_ON (rinfo-&gt;t_timeout, rip_timeout, rip-&gt;timeout_time);</a>
<a name="ln314">    }</a>
<a name="ln315">}</a>
<a name="ln316"> </a>
<a name="ln317">static int</a>
<a name="ln318">rip_filter (int rip_distribute, struct prefix_ipv4 *p, struct rip_interface *ri)</a>
<a name="ln319">{</a>
<a name="ln320">  struct distribute *dist;</a>
<a name="ln321">  struct access_list *alist;</a>
<a name="ln322">  struct prefix_list *plist;</a>
<a name="ln323">  int distribute = rip_distribute == RIP_FILTER_OUT ?</a>
<a name="ln324">      DISTRIBUTE_V4_OUT : DISTRIBUTE_V4_IN;</a>
<a name="ln325">  const char *inout = rip_distribute == RIP_FILTER_OUT ? &quot;out&quot; : &quot;in&quot;;</a>
<a name="ln326"> </a>
<a name="ln327">  /* Input distribute-list filtering. */</a>
<a name="ln328">  if (ri-&gt;list[rip_distribute])</a>
<a name="ln329">    {</a>
<a name="ln330">      if (access_list_apply (ri-&gt;list[rip_distribute],</a>
<a name="ln331">			     (struct prefix *) p) == FILTER_DENY)</a>
<a name="ln332">	{</a>
<a name="ln333">	  if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln334">	    zlog_debug (&quot;%s/%d filtered by distribute %s&quot;,</a>
<a name="ln335">                        inet_ntoa (p-&gt;prefix), p-&gt;prefixlen, inout);</a>
<a name="ln336">	  return -1;</a>
<a name="ln337">	}</a>
<a name="ln338">    }</a>
<a name="ln339">  if (ri-&gt;prefix[rip_distribute])</a>
<a name="ln340">    {</a>
<a name="ln341">      if (prefix_list_apply (ri-&gt;prefix[rip_distribute],</a>
<a name="ln342">			     (struct prefix *) p) == PREFIX_DENY)</a>
<a name="ln343">	{</a>
<a name="ln344">	  if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln345">	    zlog_debug (&quot;%s/%d filtered by prefix-list %s&quot;,</a>
<a name="ln346">                        inet_ntoa (p-&gt;prefix), p-&gt;prefixlen, inout);</a>
<a name="ln347">	  return -1;</a>
<a name="ln348">	}</a>
<a name="ln349">    }</a>
<a name="ln350"> </a>
<a name="ln351">  /* All interface filter check. */</a>
<a name="ln352">  dist = distribute_lookup (NULL);</a>
<a name="ln353">  if (dist)</a>
<a name="ln354">    {</a>
<a name="ln355">      if (dist-&gt;list[distribute])</a>
<a name="ln356">	{</a>
<a name="ln357">	  alist = access_list_lookup (AFI_IP, dist-&gt;list[distribute]);</a>
<a name="ln358"> </a>
<a name="ln359">	  if (alist)</a>
<a name="ln360">	    {</a>
<a name="ln361">	      if (access_list_apply (alist, (struct prefix *) p) == FILTER_DENY)</a>
<a name="ln362">		{</a>
<a name="ln363">		  if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln364">		    zlog_debug (&quot;%s/%d filtered by distribute %s&quot;,</a>
<a name="ln365">                                inet_ntoa (p-&gt;prefix), p-&gt;prefixlen, inout);</a>
<a name="ln366">		  return -1;</a>
<a name="ln367">		}</a>
<a name="ln368">	    }</a>
<a name="ln369">	}</a>
<a name="ln370">      if (dist-&gt;prefix[distribute])</a>
<a name="ln371">	{</a>
<a name="ln372">	  plist = prefix_list_lookup (AFI_IP, dist-&gt;prefix[distribute]);</a>
<a name="ln373"> </a>
<a name="ln374">	  if (plist)</a>
<a name="ln375">	    {</a>
<a name="ln376">	      if (prefix_list_apply (plist,</a>
<a name="ln377">				     (struct prefix *) p) == PREFIX_DENY)</a>
<a name="ln378">		{</a>
<a name="ln379">		  if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln380">		    zlog_debug (&quot;%s/%d filtered by prefix-list %s&quot;,</a>
<a name="ln381">                                inet_ntoa (p-&gt;prefix), p-&gt;prefixlen, inout);</a>
<a name="ln382">		  return -1;</a>
<a name="ln383">		}</a>
<a name="ln384">	    }</a>
<a name="ln385">	}</a>
<a name="ln386">    }</a>
<a name="ln387">  return 0;</a>
<a name="ln388">}</a>
<a name="ln389"> </a>
<a name="ln390">/* Check nexthop address validity. */</a>
<a name="ln391">static int</a>
<a name="ln392">rip_nexthop_check (struct in_addr *addr)</a>
<a name="ln393">{</a>
<a name="ln394">  struct listnode *node;</a>
<a name="ln395">  struct listnode *cnode;</a>
<a name="ln396">  struct interface *ifp;</a>
<a name="ln397">  struct connected *ifc;</a>
<a name="ln398">  struct prefix *p;</a>
<a name="ln399"> </a>
<a name="ln400">  /* If nexthop address matches local configured address then it is</a>
<a name="ln401">     invalid nexthop. */</a>
<a name="ln402">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln403">    {</a>
<a name="ln404">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, ifc))</a>
<a name="ln405">	{	    </a>
<a name="ln406">	  p = ifc-&gt;address;</a>
<a name="ln407"> </a>
<a name="ln408">	  if (p-&gt;family == AF_INET</a>
<a name="ln409">	      &amp;&amp; IPV4_ADDR_SAME (&amp;p-&gt;u.prefix4, addr))</a>
<a name="ln410">	    return -1;</a>
<a name="ln411">	}</a>
<a name="ln412">    }</a>
<a name="ln413">  return 0;</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">/* RIP add route to routing table. */</a>
<a name="ln417">static void</a>
<a name="ln418">rip_rte_process (struct rte *rte, struct sockaddr_in *from,</a>
<a name="ln419">                 struct interface *ifp)</a>
<a name="ln420">{</a>
<a name="ln421">  int ret;</a>
<a name="ln422">  struct prefix_ipv4 p;</a>
<a name="ln423">  struct route_node *rp;</a>
<a name="ln424">  struct rip_info *rinfo = NULL, newinfo;</a>
<a name="ln425">  struct rip_interface *ri;</a>
<a name="ln426">  struct in_addr *nexthop;</a>
<a name="ln427">  int same = 0;</a>
<a name="ln428">  unsigned char old_dist, new_dist;</a>
<a name="ln429">  struct list *list = NULL;</a>
<a name="ln430">  struct listnode *node = NULL;</a>
<a name="ln431"> </a>
<a name="ln432">  /* Make prefix structure. */</a>
<a name="ln433">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln434">  p.family = AF_INET;</a>
<a name="ln435">  p.prefix = rte-&gt;prefix;</a>
<a name="ln436">  p.prefixlen = ip_masklen (rte-&gt;mask);</a>
<a name="ln437"> </a>
<a name="ln438">  /* Make sure mask is applied. */</a>
<a name="ln439">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln440"> </a>
<a name="ln441">  /* Apply input filters. */</a>
<a name="ln442">  ri = ifp-&gt;info;</a>
<a name="ln443"> </a>
<a name="ln444">  ret = rip_filter (RIP_FILTER_IN, &amp;p, ri);</a>
<a name="ln445">  if (ret &lt; 0)</a>
<a name="ln446">    return;</a>
<a name="ln447"> </a>
<a name="ln448">  memset (&amp;newinfo, 0, sizeof (newinfo));</a>
<a name="ln449">  newinfo.type = ZEBRA_ROUTE_RIP;</a>
<a name="ln450">  newinfo.sub_type = RIP_ROUTE_RTE;</a>
<a name="ln451">  newinfo.nexthop = rte-&gt;nexthop;</a>
<a name="ln452">  newinfo.from = from-&gt;sin_addr;</a>
<a name="ln453">  newinfo.ifindex = ifp-&gt;ifindex;</a>
<a name="ln454">  newinfo.metric = rte-&gt;metric;</a>
<a name="ln455">  newinfo.metric_out = rte-&gt;metric; /* XXX */</a>
<a name="ln456">  newinfo.tag = ntohs (rte-&gt;tag);   /* XXX */</a>
<a name="ln457"> </a>
<a name="ln458">  /* Modify entry according to the interface routemap. */</a>
<a name="ln459">  if (ri-&gt;routemap[RIP_FILTER_IN])</a>
<a name="ln460">    {</a>
<a name="ln461">      int ret;</a>
<a name="ln462"> </a>
<a name="ln463">      /* The object should be of the type of rip_info */</a>
<a name="ln464">      ret = route_map_apply (ri-&gt;routemap[RIP_FILTER_IN],</a>
<a name="ln465">                             (struct prefix *) &amp;p, RMAP_RIP, &amp;newinfo);</a>
<a name="ln466"> </a>
<a name="ln467">      if (ret == RMAP_DENYMATCH)</a>
<a name="ln468">        {</a>
<a name="ln469">          if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln470">            zlog_debug (&quot;RIP %s/%d is filtered by route-map in&quot;,</a>
<a name="ln471">                       inet_ntoa (p.prefix), p.prefixlen);</a>
<a name="ln472">          return;</a>
<a name="ln473">        }</a>
<a name="ln474"> </a>
<a name="ln475">      /* Get back the object */</a>
<a name="ln476">      rte-&gt;nexthop = newinfo.nexthop_out;</a>
<a name="ln477">      rte-&gt;tag = htons (newinfo.tag_out);       /* XXX */</a>
<a name="ln478">      rte-&gt;metric = newinfo.metric_out; /* XXX: the routemap uses the metric_out field */</a>
<a name="ln479">    }</a>
<a name="ln480"> </a>
<a name="ln481">  /* Once the entry has been validated, update the metric by</a>
<a name="ln482">     adding the cost of the network on wich the message</a>
<a name="ln483">     arrived. If the result is greater than infinity, use infinity</a>
<a name="ln484">     (RFC2453 Sec. 3.9.2) */</a>
<a name="ln485">  /* Zebra ripd can handle offset-list in. */</a>
<a name="ln486">  ret = rip_offset_list_apply_in (&amp;p, ifp, &amp;rte-&gt;metric);</a>
<a name="ln487"> </a>
<a name="ln488">  /* If offset-list does not modify the metric use interface's</a>
<a name="ln489">     metric. */</a>
<a name="ln490">  if (!ret)</a>
<a name="ln491">    rte-&gt;metric += ifp-&gt;metric ? ifp-&gt;metric : 1;</a>
<a name="ln492"> </a>
<a name="ln493">  if (rte-&gt;metric &gt; RIP_METRIC_INFINITY)</a>
<a name="ln494">    rte-&gt;metric = RIP_METRIC_INFINITY;</a>
<a name="ln495"> </a>
<a name="ln496">  /* Set nexthop pointer. */</a>
<a name="ln497">  if (rte-&gt;nexthop.s_addr == 0)</a>
<a name="ln498">    nexthop = &amp;from-&gt;sin_addr;</a>
<a name="ln499">  else</a>
<a name="ln500">    nexthop = &amp;rte-&gt;nexthop;</a>
<a name="ln501"> </a>
<a name="ln502">  /* Check if nexthop address is myself, then do nothing. */</a>
<a name="ln503">  if (rip_nexthop_check (nexthop) &lt; 0)</a>
<a name="ln504">    {</a>
<a name="ln505">      if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln506">        zlog_debug (&quot;Nexthop address %s is myself&quot;, inet_ntoa (*nexthop));</a>
<a name="ln507">      return;</a>
<a name="ln508">    }</a>
<a name="ln509"> </a>
<a name="ln510">  /* Get index for the prefix. */</a>
<a name="ln511">  rp = route_node_get (rip-&gt;table, (struct prefix *) &amp;p);</a>
<a name="ln512"> </a>
<a name="ln513">  newinfo.rp = rp;</a>
<a name="ln514">  newinfo.nexthop = *nexthop;</a>
<a name="ln515">  newinfo.metric = rte-&gt;metric;</a>
<a name="ln516">  newinfo.tag = ntohs (rte-&gt;tag);</a>
<a name="ln517">  newinfo.distance = rip_distance_apply (&amp;newinfo);</a>
<a name="ln518"> </a>
<a name="ln519">  new_dist = newinfo.distance ? newinfo.distance : ZEBRA_RIP_DISTANCE_DEFAULT;</a>
<a name="ln520"> </a>
<a name="ln521">  /* Check to see whether there is already RIP route on the table. */</a>
<a name="ln522">  if ((list = rp-&gt;info) != NULL)</a>
<a name="ln523">    for (ALL_LIST_ELEMENTS_RO (list, node, rinfo))</a>
<a name="ln524">      {</a>
<a name="ln525">        /* Need to compare with redistributed entry or local entry */</a>
<a name="ln526">        if (!rip_route_rte (rinfo))</a>
<a name="ln527">          break;</a>
<a name="ln528"> </a>
<a name="ln529">        if (IPV4_ADDR_SAME (&amp;rinfo-&gt;from, &amp;from-&gt;sin_addr) &amp;&amp;</a>
<a name="ln530">            IPV4_ADDR_SAME (&amp;rinfo-&gt;nexthop, nexthop))</a>
<a name="ln531">          break;</a>
<a name="ln532"> </a>
<a name="ln533">        if (!listnextnode (node))</a>
<a name="ln534">          {</a>
<a name="ln535">            /* Not found in the list */</a>
<a name="ln536"> </a>
<a name="ln537">            if (rte-&gt;metric &gt; rinfo-&gt;metric)</a>
<a name="ln538">              {</a>
<a name="ln539">                /* New route has a greater metric. Discard it. */</a>
<a name="ln540">                route_unlock_node (rp);</a>
<a name="ln541">                return;</a>
<a name="ln542">              }</a>
<a name="ln543"> </a>
<a name="ln544">            if (rte-&gt;metric &lt; rinfo-&gt;metric)</a>
<a name="ln545">              /* New route has a smaller metric. Replace the ECMP list</a>
<a name="ln546">               * with the new one in below. */</a>
<a name="ln547">              break;</a>
<a name="ln548"> </a>
<a name="ln549">            /* Metrics are same. We compare the distances. */</a>
<a name="ln550">            old_dist = rinfo-&gt;distance ? \</a>
<a name="ln551">                       rinfo-&gt;distance : ZEBRA_RIP_DISTANCE_DEFAULT;</a>
<a name="ln552"> </a>
<a name="ln553">            if (new_dist &gt; old_dist)</a>
<a name="ln554">              {</a>
<a name="ln555">                /* New route has a greater distance. Discard it. */</a>
<a name="ln556">                route_unlock_node (rp);</a>
<a name="ln557">                return;</a>
<a name="ln558">              }</a>
<a name="ln559"> </a>
<a name="ln560">            if (new_dist &lt; old_dist)</a>
<a name="ln561">              /* New route has a smaller distance. Replace the ECMP list</a>
<a name="ln562">               * with the new one in below. */</a>
<a name="ln563">              break;</a>
<a name="ln564"> </a>
<a name="ln565">            /* Metrics and distances are both same. Keep &quot;rinfo&quot; null and</a>
<a name="ln566">             * the new route is added in the ECMP list in below. */</a>
<a name="ln567">          }</a>
<a name="ln568">      }</a>
<a name="ln569"> </a>
<a name="ln570">  if (rinfo)</a>
<a name="ln571">    {</a>
<a name="ln572">      /* Local static route. */</a>
<a name="ln573">      if (rinfo-&gt;type == ZEBRA_ROUTE_RIP</a>
<a name="ln574">          &amp;&amp; ((rinfo-&gt;sub_type == RIP_ROUTE_STATIC) ||</a>
<a name="ln575">              (rinfo-&gt;sub_type == RIP_ROUTE_DEFAULT))</a>
<a name="ln576">          &amp;&amp; rinfo-&gt;metric != RIP_METRIC_INFINITY)</a>
<a name="ln577">        {</a>
<a name="ln578">          route_unlock_node (rp);</a>
<a name="ln579">          return;</a>
<a name="ln580">        }</a>
<a name="ln581"> </a>
<a name="ln582">      /* Redistributed route check. */</a>
<a name="ln583">      if (rinfo-&gt;type != ZEBRA_ROUTE_RIP</a>
<a name="ln584">          &amp;&amp; rinfo-&gt;metric != RIP_METRIC_INFINITY)</a>
<a name="ln585">        {</a>
<a name="ln586">          old_dist = rinfo-&gt;distance;</a>
<a name="ln587">          /* Only routes directly connected to an interface (nexthop == 0)</a>
<a name="ln588">	   * may have a valid NULL distance */</a>
<a name="ln589">          if (rinfo-&gt;nexthop.s_addr != 0)</a>
<a name="ln590">            old_dist = old_dist ? old_dist : ZEBRA_RIP_DISTANCE_DEFAULT;</a>
<a name="ln591">          /* If imported route does not have STRICT precedence, </a>
<a name="ln592">             mark it as a ghost */</a>
<a name="ln593">          if (new_dist &lt;= old_dist &amp;&amp; rte-&gt;metric != RIP_METRIC_INFINITY)</a>
<a name="ln594">            rip_ecmp_replace (&amp;newinfo);</a>
<a name="ln595"> </a>
<a name="ln596">          route_unlock_node (rp);</a>
<a name="ln597">          return;</a>
<a name="ln598">        }</a>
<a name="ln599">    }</a>
<a name="ln600"> </a>
<a name="ln601">  if (!rinfo)</a>
<a name="ln602">    {</a>
<a name="ln603">      if (rp-&gt;info)</a>
<a name="ln604">        route_unlock_node (rp);</a>
<a name="ln605"> </a>
<a name="ln606">      /* Now, check to see whether there is already an explicit route</a>
<a name="ln607">         for the destination prefix.  If there is no such route, add</a>
<a name="ln608">         this route to the routing table, unless the metric is</a>
<a name="ln609">         infinity (there is no point in adding a route which</a>
<a name="ln610">         unusable). */</a>
<a name="ln611">      if (rte-&gt;metric != RIP_METRIC_INFINITY)</a>
<a name="ln612">        rip_ecmp_add (&amp;newinfo);</a>
<a name="ln613">    }</a>
<a name="ln614">  else</a>
<a name="ln615">    {</a>
<a name="ln616">      /* Route is there but we are not sure the route is RIP or not. */</a>
<a name="ln617"> </a>
<a name="ln618">      /* If there is an existing route, compare the next hop address</a>
<a name="ln619">         to the address of the router from which the datagram came.</a>
<a name="ln620">         If this datagram is from the same router as the existing</a>
<a name="ln621">         route, reinitialize the timeout.  */</a>
<a name="ln622">      same = (IPV4_ADDR_SAME (&amp;rinfo-&gt;from, &amp;from-&gt;sin_addr)</a>
<a name="ln623">              &amp;&amp; (rinfo-&gt;ifindex == ifp-&gt;ifindex));</a>
<a name="ln624"> </a>
<a name="ln625">      old_dist = rinfo-&gt;distance ? \</a>
<a name="ln626">                 rinfo-&gt;distance : ZEBRA_RIP_DISTANCE_DEFAULT;</a>
<a name="ln627"> </a>
<a name="ln628">      /* Next, compare the metrics.  If the datagram is from the same</a>
<a name="ln629">         router as the existing route, and the new metric is different</a>
<a name="ln630">         than the old one; or, if the new metric is lower than the old</a>
<a name="ln631">         one, or if the tag has been changed; or if there is a route</a>
<a name="ln632">         with a lower administrave distance; or an update of the</a>
<a name="ln633">         distance on the actual route; do the following actions: */</a>
<a name="ln634">      if ((same &amp;&amp; rinfo-&gt;metric != rte-&gt;metric)</a>
<a name="ln635">          || (rte-&gt;metric &lt; rinfo-&gt;metric)</a>
<a name="ln636">          || ((same)</a>
<a name="ln637">              &amp;&amp; (rinfo-&gt;metric == rte-&gt;metric)</a>
<a name="ln638">              &amp;&amp; (newinfo.tag != rinfo-&gt;tag))</a>
<a name="ln639">          || (old_dist &gt; new_dist)</a>
<a name="ln640">          || ((old_dist != new_dist) &amp;&amp; same))</a>
<a name="ln641">        {</a>
<a name="ln642">          if (listcount (list) == 1)</a>
<a name="ln643">            {</a>
<a name="ln644">              if (newinfo.metric != RIP_METRIC_INFINITY)</a>
<a name="ln645">                rip_ecmp_replace (&amp;newinfo);</a>
<a name="ln646">              else</a>
<a name="ln647">                rip_ecmp_delete (rinfo);</a>
<a name="ln648">            }</a>
<a name="ln649">          else</a>
<a name="ln650">            {</a>
<a name="ln651">              if (newinfo.metric &lt; rinfo-&gt;metric)</a>
<a name="ln652">                rip_ecmp_replace (&amp;newinfo);</a>
<a name="ln653">              else if (newinfo.metric &gt; rinfo-&gt;metric)</a>
<a name="ln654">                rip_ecmp_delete (rinfo);</a>
<a name="ln655">              else if (new_dist &lt; old_dist)</a>
<a name="ln656">                rip_ecmp_replace (&amp;newinfo);</a>
<a name="ln657">              else if (new_dist &gt; old_dist)</a>
<a name="ln658">                rip_ecmp_delete (rinfo);</a>
<a name="ln659">              else</a>
<a name="ln660">                {</a>
<a name="ln661">                  int update = CHECK_FLAG (rinfo-&gt;flags, RIP_RTF_FIB) ? 1 : 0;</a>
<a name="ln662"> </a>
<a name="ln663">                  assert (newinfo.metric != RIP_METRIC_INFINITY);</a>
<a name="ln664"> </a>
<a name="ln665">                  RIP_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln666">                  RIP_TIMER_OFF (rinfo-&gt;t_garbage_collect);</a>
<a name="ln667">                  memcpy (rinfo, &amp;newinfo, sizeof (struct rip_info));</a>
<a name="ln668">                  rip_timeout_update (rinfo);</a>
<a name="ln669"> </a>
<a name="ln670">                  if (update)</a>
<a name="ln671">                    rip_zebra_ipv4_add (rp);</a>
<a name="ln672"> </a>
<a name="ln673">                  /* - Set the route change flag on the first entry. */</a>
<a name="ln674">                  rinfo = listgetdata (listhead (list));</a>
<a name="ln675">                  SET_FLAG (rinfo-&gt;flags, RIP_RTF_CHANGED);</a>
<a name="ln676">                  rip_event (RIP_TRIGGERED_UPDATE, 0);</a>
<a name="ln677">                }</a>
<a name="ln678">            }</a>
<a name="ln679">        }</a>
<a name="ln680">      else /* same &amp; no change */</a>
<a name="ln681">        rip_timeout_update (rinfo);</a>
<a name="ln682"> </a>
<a name="ln683">      /* Unlock tempolary lock of the route. */</a>
<a name="ln684">      route_unlock_node (rp);</a>
<a name="ln685">    }</a>
<a name="ln686">}</a>
<a name="ln687"> </a>
<a name="ln688">/* Dump RIP packet */</a>
<a name="ln689">static void</a>
<a name="ln690">rip_packet_dump (struct rip_packet *packet, int size, const char *sndrcv)</a>
<a name="ln691">{</a>
<a name="ln692">  caddr_t lim;</a>
<a name="ln693">  struct rte *rte;</a>
<a name="ln694">  const char *command_str;</a>
<a name="ln695">  char pbuf[BUFSIZ], nbuf[BUFSIZ];</a>
<a name="ln696">  u_char netmask = 0;</a>
<a name="ln697">  u_char *p;</a>
<a name="ln698"> </a>
<a name="ln699">  /* Set command string. */</a>
<a name="ln700">  if (packet-&gt;command &gt; 0 &amp;&amp; packet-&gt;command &lt; RIP_COMMAND_MAX)</a>
<a name="ln701">    command_str = lookup (rip_msg, packet-&gt;command);</a>
<a name="ln702">  else</a>
<a name="ln703">    command_str = &quot;unknown&quot;;</a>
<a name="ln704"> </a>
<a name="ln705">  /* Dump packet header. */</a>
<a name="ln706">  zlog_debug (&quot;%s %s version %d packet size %d&quot;,</a>
<a name="ln707">	     sndrcv, command_str, packet-&gt;version, size);</a>
<a name="ln708"> </a>
<a name="ln709">  /* Dump each routing table entry. */</a>
<a name="ln710">  rte = packet-&gt;rte;</a>
<a name="ln711">  </a>
<a name="ln712">  for (lim = (caddr_t) packet + size; (caddr_t) rte &lt; lim; rte++)</a>
<a name="ln713">    {</a>
<a name="ln714">      if (packet-&gt;version == RIPv2)</a>
<a name="ln715">	{</a>
<a name="ln716">	  netmask = ip_masklen (rte-&gt;mask);</a>
<a name="ln717"> </a>
<a name="ln718">          if (rte-&gt;family == htons (RIP_FAMILY_AUTH))</a>
<a name="ln719">            {</a>
<a name="ln720">              if (rte-&gt;tag == htons (RIP_AUTH_SIMPLE_PASSWORD))</a>
<a name="ln721">		{</a>
<a name="ln722">		  p = (u_char *)&amp;rte-&gt;prefix;</a>
<a name="ln723"> </a>
<a name="ln724">		  zlog_debug (&quot;  family 0x%X type %d auth string: %s&quot;,</a>
<a name="ln725">			     ntohs (rte-&gt;family), ntohs (rte-&gt;tag), p);</a>
<a name="ln726">		}</a>
<a name="ln727">              else if (rte-&gt;tag == htons (RIP_AUTH_MD5))</a>
<a name="ln728">		{</a>
<a name="ln729">		  struct rip_md5_info *md5;</a>
<a name="ln730"> </a>
<a name="ln731">		  md5 = (struct rip_md5_info *) &amp;packet-&gt;rte;</a>
<a name="ln732"> </a>
<a name="ln733">		  zlog_debug (&quot;  family 0x%X type %d (MD5 authentication)&quot;,</a>
<a name="ln734">			     ntohs (md5-&gt;family), ntohs (md5-&gt;type));</a>
<a name="ln735">		  zlog_debug (&quot;    RIP-2 packet len %d Key ID %d&quot;</a>
<a name="ln736">                             &quot; Auth Data len %d&quot;,</a>
<a name="ln737">                             ntohs (md5-&gt;packet_len), md5-&gt;keyid,</a>
<a name="ln738">                             md5-&gt;auth_len);</a>
<a name="ln739">                  zlog_debug (&quot;    Sequence Number %ld&quot;,</a>
<a name="ln740">                             (u_long) ntohl (md5-&gt;sequence));</a>
<a name="ln741">		}</a>
<a name="ln742">              else if (rte-&gt;tag == htons (RIP_AUTH_DATA))</a>
<a name="ln743">		{</a>
<a name="ln744">		  p = (u_char *)&amp;rte-&gt;prefix;</a>
<a name="ln745"> </a>
<a name="ln746">		  zlog_debug (&quot;  family 0x%X type %d (MD5 data)&quot;,</a>
<a name="ln747">			     ntohs (rte-&gt;family), ntohs (rte-&gt;tag));</a>
<a name="ln748">		  zlog_debug (&quot;    MD5: %02X%02X%02X%02X%02X%02X%02X%02X&quot;</a>
<a name="ln749">			     &quot;%02X%02X%02X%02X%02X%02X%02X%02X&quot;,</a>
<a name="ln750">                             p[0], p[1], p[2], p[3], p[4], p[5], p[6],</a>
<a name="ln751">                             p[7], p[8], p[9], p[10], p[11], p[12], p[13],</a>
<a name="ln752">                             p[14], p[15]);</a>
<a name="ln753">		}</a>
<a name="ln754">	      else</a>
<a name="ln755">		{</a>
<a name="ln756">		  zlog_debug (&quot;  family 0x%X type %d (Unknown auth type)&quot;,</a>
<a name="ln757">			     ntohs (rte-&gt;family), ntohs (rte-&gt;tag));</a>
<a name="ln758">		}</a>
<a name="ln759">            }</a>
<a name="ln760">	  else</a>
<a name="ln761">	    zlog_debug (&quot;  %s/%d -&gt; %s family %d tag %d metric %ld&quot;,</a>
<a name="ln762">                       inet_ntop (AF_INET, &amp;rte-&gt;prefix, pbuf, BUFSIZ),</a>
<a name="ln763">                       netmask, inet_ntop (AF_INET, &amp;rte-&gt;nexthop, nbuf,</a>
<a name="ln764">                                           BUFSIZ), ntohs (rte-&gt;family),</a>
<a name="ln765">                       ntohs (rte-&gt;tag), (u_long) ntohl (rte-&gt;metric));</a>
<a name="ln766">	}</a>
<a name="ln767">      else</a>
<a name="ln768">	{</a>
<a name="ln769">	  zlog_debug (&quot;  %s family %d tag %d metric %ld&quot;, </a>
<a name="ln770">		     inet_ntop (AF_INET, &amp;rte-&gt;prefix, pbuf, BUFSIZ),</a>
<a name="ln771">		     ntohs (rte-&gt;family), ntohs (rte-&gt;tag),</a>
<a name="ln772">		     (u_long)ntohl (rte-&gt;metric));</a>
<a name="ln773">	}</a>
<a name="ln774">    }</a>
<a name="ln775">}</a>
<a name="ln776"> </a>
<a name="ln777">/* Check if the destination address is valid (unicast; not net 0</a>
<a name="ln778">   or 127) (RFC2453 Section 3.9.2 - Page 26).  But we don't</a>
<a name="ln779">   check net 0 because we accept default route. */</a>
<a name="ln780">static int</a>
<a name="ln781">rip_destination_check (struct in_addr addr)</a>
<a name="ln782">{</a>
<a name="ln783">  u_int32_t destination;</a>
<a name="ln784"> </a>
<a name="ln785">  /* Convert to host byte order. */</a>
<a name="ln786">  destination = ntohl (addr.s_addr);</a>
<a name="ln787"> </a>
<a name="ln788">  if (IPV4_NET127 (destination))</a>
<a name="ln789">    return 0;</a>
<a name="ln790"> </a>
<a name="ln791">  /* Net 0 may match to the default route. */</a>
<a name="ln792">  if (IPV4_NET0 (destination) &amp;&amp; destination != 0)</a>
<a name="ln793">    return 0;</a>
<a name="ln794"> </a>
<a name="ln795">  /* Unicast address must belong to class A, B, C. */</a>
<a name="ln796">  if (IN_CLASSA (destination))</a>
<a name="ln797">    return 1;</a>
<a name="ln798">  if (IN_CLASSB (destination))</a>
<a name="ln799">    return 1;</a>
<a name="ln800">  if (IN_CLASSC (destination))</a>
<a name="ln801">    return 1;</a>
<a name="ln802"> </a>
<a name="ln803">  return 0;</a>
<a name="ln804">}</a>
<a name="ln805"> </a>
<a name="ln806">/* RIP version 2 authentication. */</a>
<a name="ln807">static int</a>
<a name="ln808">rip_auth_simple_password (struct rte *rte, struct sockaddr_in *from,</a>
<a name="ln809">			  struct interface *ifp)</a>
<a name="ln810">{</a>
<a name="ln811">  struct rip_interface *ri;</a>
<a name="ln812">  char *auth_str;</a>
<a name="ln813"> </a>
<a name="ln814">  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln815">    zlog_debug (&quot;RIPv2 simple password authentication from %s&quot;,</a>
<a name="ln816">	       inet_ntoa (from-&gt;sin_addr));</a>
<a name="ln817"> </a>
<a name="ln818">  ri = ifp-&gt;info;</a>
<a name="ln819"> </a>
<a name="ln820">  if (ri-&gt;auth_type != RIP_AUTH_SIMPLE_PASSWORD</a>
<a name="ln821">      || rte-&gt;tag != htons(RIP_AUTH_SIMPLE_PASSWORD))</a>
<a name="ln822">    return 0;</a>
<a name="ln823"> </a>
<a name="ln824">  /* Simple password authentication. */</a>
<a name="ln825">  if (ri-&gt;auth_str)</a>
<a name="ln826">    {</a>
<a name="ln827">      auth_str = (char *) &amp;rte-&gt;prefix;</a>
<a name="ln828">	  </a>
<a name="ln829">      if (strncmp (auth_str, ri-&gt;auth_str, 16) == 0)</a>
<a name="ln830">	return 1;</a>
<a name="ln831">    }</a>
<a name="ln832">  if (ri-&gt;key_chain)</a>
<a name="ln833">    {</a>
<a name="ln834">      struct keychain *keychain;</a>
<a name="ln835">      struct key *key;</a>
<a name="ln836"> </a>
<a name="ln837">      keychain = keychain_lookup (ri-&gt;key_chain);</a>
<a name="ln838">      if (keychain == NULL)</a>
<a name="ln839">	return 0;</a>
<a name="ln840"> </a>
<a name="ln841">      key = key_match_for_accept (keychain, (char *) &amp;rte-&gt;prefix);</a>
<a name="ln842">      if (key)</a>
<a name="ln843">	return 1;</a>
<a name="ln844">    }</a>
<a name="ln845">  return 0;</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848">/* RIP version 2 authentication with MD5. */</a>
<a name="ln849">static int</a>
<a name="ln850">rip_auth_md5 (struct rip_packet *packet, struct sockaddr_in *from,</a>
<a name="ln851">              int length, struct interface *ifp)</a>
<a name="ln852">{</a>
<a name="ln853">  struct rip_interface *ri;</a>
<a name="ln854">  struct rip_md5_info *md5;</a>
<a name="ln855">  struct rip_md5_data *md5data;</a>
<a name="ln856">  struct keychain *keychain;</a>
<a name="ln857">  struct key *key;</a>
<a name="ln858">  MD5_CTX ctx;</a>
<a name="ln859">  u_char digest[RIP_AUTH_MD5_SIZE];</a>
<a name="ln860">  u_int16_t packet_len;</a>
<a name="ln861">  char auth_str[RIP_AUTH_MD5_SIZE];</a>
<a name="ln862">  </a>
<a name="ln863">  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln864">    zlog_debug (&quot;RIPv2 MD5 authentication from %s&quot;,</a>
<a name="ln865">               inet_ntoa (from-&gt;sin_addr));</a>
<a name="ln866"> </a>
<a name="ln867">  ri = ifp-&gt;info;</a>
<a name="ln868">  md5 = (struct rip_md5_info *) &amp;packet-&gt;rte;</a>
<a name="ln869"> </a>
<a name="ln870">  /* Check auth type. */</a>
<a name="ln871">  if (ri-&gt;auth_type != RIP_AUTH_MD5 || md5-&gt;type != htons(RIP_AUTH_MD5))</a>
<a name="ln872">    return 0;</a>
<a name="ln873"> </a>
<a name="ln874">  /* If the authentication length is less than 16, then it must be wrong for</a>
<a name="ln875">   * any interpretation of rfc2082. Some implementations also interpret</a>
<a name="ln876">   * this as RIP_HEADER_SIZE+ RIP_AUTH_MD5_SIZE, aka RIP_AUTH_MD5_COMPAT_SIZE.</a>
<a name="ln877">   */</a>
<a name="ln878">  if ( !((md5-&gt;auth_len == RIP_AUTH_MD5_SIZE)</a>
<a name="ln879">         || (md5-&gt;auth_len == RIP_AUTH_MD5_COMPAT_SIZE)))</a>
<a name="ln880">    {</a>
<a name="ln881">      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln882">        zlog_debug (&quot;RIPv2 MD5 authentication, strange authentication &quot;</a>
<a name="ln883">                   &quot;length field %d&quot;, md5-&gt;auth_len);</a>
<a name="ln884">    return 0;</a>
<a name="ln885">    }</a>
<a name="ln886"> </a>
<a name="ln887">  /* grab and verify check packet length */</a>
<a name="ln888">  packet_len = ntohs (md5-&gt;packet_len);</a>
<a name="ln889"> </a>
<a name="ln890">  if (packet_len &gt; (length - RIP_HEADER_SIZE - RIP_AUTH_MD5_SIZE))</a>
<a name="ln891">    {</a>
<a name="ln892">      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln893">        zlog_debug (&quot;RIPv2 MD5 authentication, packet length field %d &quot;</a>
<a name="ln894">                   &quot;greater than received length %d!&quot;,</a>
<a name="ln895">                   md5-&gt;packet_len, length);</a>
<a name="ln896">      return 0;</a>
<a name="ln897">    }</a>
<a name="ln898"> </a>
<a name="ln899">  /* retrieve authentication data */</a>
<a name="ln900">  md5data = (struct rip_md5_data *) (((u_char *) packet) + packet_len);</a>
<a name="ln901">  </a>
<a name="ln902">  memset (auth_str, 0, RIP_AUTH_MD5_SIZE);</a>
<a name="ln903"> </a>
<a name="ln904">  if (ri-&gt;key_chain)</a>
<a name="ln905">    {</a>
<a name="ln906">      keychain = keychain_lookup (ri-&gt;key_chain);</a>
<a name="ln907">      if (keychain == NULL)</a>
<a name="ln908">	return 0;</a>
<a name="ln909"> </a>
<a name="ln910">      key = key_lookup_for_accept (keychain, md5-&gt;keyid);</a>
<a name="ln911">      if (key == NULL)</a>
<a name="ln912">	return 0;</a>
<a name="ln913"> </a>
<a name="ln914">      strncpy (auth_str, key-&gt;string, RIP_AUTH_MD5_SIZE);</a>
<a name="ln915">    }</a>
<a name="ln916">  else if (ri-&gt;auth_str)</a>
<a name="ln917">    strncpy (auth_str, ri-&gt;auth_str, RIP_AUTH_MD5_SIZE);</a>
<a name="ln918"> </a>
<a name="ln919">  if (auth_str[0] == 0)</a>
<a name="ln920">    return 0;</a>
<a name="ln921">  </a>
<a name="ln922">  /* MD5 digest authentication. */</a>
<a name="ln923">  memset (&amp;ctx, 0, sizeof(ctx));</a>
<a name="ln924">  MD5Init(&amp;ctx);</a>
<a name="ln925">  MD5Update(&amp;ctx, packet, packet_len + RIP_HEADER_SIZE);</a>
<a name="ln926">  MD5Update(&amp;ctx, auth_str, RIP_AUTH_MD5_SIZE);</a>
<a name="ln927">  MD5Final(digest, &amp;ctx);</a>
<a name="ln928">  </a>
<a name="ln929">  if (memcmp (md5data-&gt;digest, digest, RIP_AUTH_MD5_SIZE) == 0)</a>
<a name="ln930">    return packet_len;</a>
<a name="ln931">  else</a>
<a name="ln932">    return 0;</a>
<a name="ln933">}</a>
<a name="ln934"> </a>
<a name="ln935">/* Pick correct auth string for sends, prepare auth_str buffer for use.</a>
<a name="ln936"> * (left justified and padded).</a>
<a name="ln937"> *</a>
<a name="ln938"> * presumes one of ri or key is valid, and that the auth strings they point</a>
<a name="ln939"> * to are nul terminated. If neither are present, auth_str will be fully</a>
<a name="ln940"> * zero padded.</a>
<a name="ln941"> *</a>
<a name="ln942"> */</a>
<a name="ln943">static void</a>
<a name="ln944">rip_auth_prepare_str_send (struct rip_interface *ri, struct key *key, </a>
<a name="ln945">                           char *auth_str, int len)</a>
<a name="ln946">{</a>
<a name="ln947">  assert (ri || key);</a>
<a name="ln948"> </a>
<a name="ln949">  memset (auth_str, 0, len);</a>
<a name="ln950">  if (key &amp;&amp; key-&gt;string)</a>
<a name="ln951">    strncpy (auth_str, key-&gt;string, len);</a>
<a name="ln952">  else if (ri-&gt;auth_str)</a>
<a name="ln953">    strncpy (auth_str, ri-&gt;auth_str, len);</a>
<a name="ln954"> </a>
<a name="ln955">  return;</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">/* Write RIPv2 simple password authentication information</a>
<a name="ln959"> *</a>
<a name="ln960"> * auth_str is presumed to be 2 bytes and correctly prepared </a>
<a name="ln961"> * (left justified and zero padded).</a>
<a name="ln962"> */</a>
<a name="ln963">static void</a>
<a name="ln964">rip_auth_simple_write (struct stream *s, char *auth_str, int len)</a>
<a name="ln965">{</a>
<a name="ln966">  assert (s &amp;&amp; len == RIP_AUTH_SIMPLE_SIZE);</a>
<a name="ln967">  </a>
<a name="ln968">  stream_putw (s, RIP_FAMILY_AUTH);</a>
<a name="ln969">  stream_putw (s, RIP_AUTH_SIMPLE_PASSWORD);</a>
<a name="ln970">  stream_put (s, auth_str, RIP_AUTH_SIMPLE_SIZE);</a>
<a name="ln971">  </a>
<a name="ln972">  return;</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">/* write RIPv2 MD5 &quot;authentication header&quot; </a>
<a name="ln976"> * (uses the auth key data field)</a>
<a name="ln977"> *</a>
<a name="ln978"> * Digest offset field is set to 0.</a>
<a name="ln979"> *</a>
<a name="ln980"> * returns: offset of the digest offset field, which must be set when</a>
<a name="ln981"> * length to the auth-data MD5 digest is known.</a>
<a name="ln982"> */</a>
<a name="ln983">static size_t</a>
<a name="ln984">rip_auth_md5_ah_write (struct stream *s, struct rip_interface *ri, </a>
<a name="ln985">                       struct key *key)</a>
<a name="ln986">{</a>
<a name="ln987">  size_t doff = 0;</a>
<a name="ln988"> </a>
<a name="ln989">  assert (s &amp;&amp; ri &amp;&amp; ri-&gt;auth_type == RIP_AUTH_MD5);</a>
<a name="ln990"> </a>
<a name="ln991">  /* MD5 authentication. */</a>
<a name="ln992">  stream_putw (s, RIP_FAMILY_AUTH);</a>
<a name="ln993">  stream_putw (s, RIP_AUTH_MD5);</a>
<a name="ln994"> </a>
<a name="ln995">  /* MD5 AH digest offset field.</a>
<a name="ln996">   *</a>
<a name="ln997">   * Set to placeholder value here, to true value when RIP-2 Packet length</a>
<a name="ln998">   * is known.  Actual value is set in .....().</a>
<a name="ln999">   */</a>
<a name="ln1000">  doff = stream_get_endp(s);</a>
<a name="ln1001">  stream_putw (s, 0);</a>
<a name="ln1002"> </a>
<a name="ln1003">  /* Key ID. */</a>
<a name="ln1004">  if (key)</a>
<a name="ln1005">    stream_putc (s, key-&gt;index % 256);</a>
<a name="ln1006">  else</a>
<a name="ln1007">    stream_putc (s, 1);</a>
<a name="ln1008"> </a>
<a name="ln1009">  /* Auth Data Len.  Set 16 for MD5 authentication data. Older ripds </a>
<a name="ln1010">   * however expect RIP_HEADER_SIZE + RIP_AUTH_MD5_SIZE so we allow for this</a>
<a name="ln1011">   * to be configurable. </a>
<a name="ln1012">   */</a>
<a name="ln1013">  stream_putc (s, ri-&gt;md5_auth_len);</a>
<a name="ln1014"> </a>
<a name="ln1015">  /* Sequence Number (non-decreasing). */</a>
<a name="ln1016">  /* RFC2080: The value used in the sequence number is</a>
<a name="ln1017">     arbitrary, but two suggestions are the time of the</a>
<a name="ln1018">     message's creation or a simple message counter. */</a>
<a name="ln1019">  stream_putl (s, time (NULL));</a>
<a name="ln1020">	      </a>
<a name="ln1021">  /* Reserved field must be zero. */</a>
<a name="ln1022">  stream_putl (s, 0);</a>
<a name="ln1023">  stream_putl (s, 0);</a>
<a name="ln1024"> </a>
<a name="ln1025">  return doff;</a>
<a name="ln1026">}</a>
<a name="ln1027"> </a>
<a name="ln1028">/* If authentication is in used, write the appropriate header</a>
<a name="ln1029"> * returns stream offset to which length must later be written</a>
<a name="ln1030"> * or 0 if this is not required</a>
<a name="ln1031"> */</a>
<a name="ln1032">static size_t</a>
<a name="ln1033">rip_auth_header_write (struct stream *s, struct rip_interface *ri, </a>
<a name="ln1034">                       struct key *key, char *auth_str, int len)</a>
<a name="ln1035">{</a>
<a name="ln1036">  assert (ri-&gt;auth_type != RIP_NO_AUTH);</a>
<a name="ln1037">  </a>
<a name="ln1038">  switch (ri-&gt;auth_type)</a>
<a name="ln1039">    {</a>
<a name="ln1040">      case RIP_AUTH_SIMPLE_PASSWORD:</a>
<a name="ln1041">        rip_auth_prepare_str_send (ri, key, auth_str, len);</a>
<a name="ln1042">        rip_auth_simple_write (s, auth_str, len);</a>
<a name="ln1043">        return 0;</a>
<a name="ln1044">      case RIP_AUTH_MD5:</a>
<a name="ln1045">        return rip_auth_md5_ah_write (s, ri, key);</a>
<a name="ln1046">    }</a>
<a name="ln1047">  assert (1);</a>
<a name="ln1048">  return 0;</a>
<a name="ln1049">}</a>
<a name="ln1050"> </a>
<a name="ln1051">/* Write RIPv2 MD5 authentication data trailer */</a>
<a name="ln1052">static void</a>
<a name="ln1053">rip_auth_md5_set (struct stream *s, struct rip_interface *ri, size_t doff,</a>
<a name="ln1054">                  char *auth_str, int authlen)</a>
<a name="ln1055">{</a>
<a name="ln1056">  unsigned long len;</a>
<a name="ln1057">  MD5_CTX ctx;</a>
<a name="ln1058">  unsigned char digest[RIP_AUTH_MD5_SIZE];</a>
<a name="ln1059"> </a>
<a name="ln1060">  /* Make it sure this interface is configured as MD5</a>
<a name="ln1061">     authentication. */</a>
<a name="ln1062">  assert ((ri-&gt;auth_type == RIP_AUTH_MD5) &amp;&amp; (authlen == RIP_AUTH_MD5_SIZE));</a>
<a name="ln1063">  assert (doff &gt; 0);</a>
<a name="ln1064">  </a>
<a name="ln1065">  /* Get packet length. */</a>
<a name="ln1066">  len = stream_get_endp(s);</a>
<a name="ln1067"> </a>
<a name="ln1068">  /* Check packet length. */</a>
<a name="ln1069">  if (len &lt; (RIP_HEADER_SIZE + RIP_RTE_SIZE))</a>
<a name="ln1070">    {</a>
<a name="ln1071">      zlog_err (&quot;rip_auth_md5_set(): packet length %ld is less than minimum length.&quot;, len);</a>
<a name="ln1072">      return;</a>
<a name="ln1073">    }</a>
<a name="ln1074"> </a>
<a name="ln1075">  /* Set the digest offset length in the header */</a>
<a name="ln1076">  stream_putw_at (s, doff, len);</a>
<a name="ln1077">  </a>
<a name="ln1078">  /* Set authentication data. */</a>
<a name="ln1079">  stream_putw (s, RIP_FAMILY_AUTH);</a>
<a name="ln1080">  stream_putw (s, RIP_AUTH_DATA);</a>
<a name="ln1081"> </a>
<a name="ln1082">  /* Generate a digest for the RIP packet. */</a>
<a name="ln1083">  memset(&amp;ctx, 0, sizeof(ctx));</a>
<a name="ln1084">  MD5Init(&amp;ctx);</a>
<a name="ln1085">  MD5Update(&amp;ctx, STREAM_DATA (s), stream_get_endp (s));</a>
<a name="ln1086">  MD5Update(&amp;ctx, auth_str, RIP_AUTH_MD5_SIZE);</a>
<a name="ln1087">  MD5Final(digest, &amp;ctx);</a>
<a name="ln1088"> </a>
<a name="ln1089">  /* Copy the digest to the packet. */</a>
<a name="ln1090">  stream_write (s, digest, RIP_AUTH_MD5_SIZE);</a>
<a name="ln1091">}</a>
<a name="ln1092"> </a>
<a name="ln1093">/* RIP routing information. */</a>
<a name="ln1094">static void</a>
<a name="ln1095">rip_response_process (struct rip_packet *packet, int size, </a>
<a name="ln1096">		      struct sockaddr_in *from, struct connected *ifc)</a>
<a name="ln1097">{</a>
<a name="ln1098">  caddr_t lim;</a>
<a name="ln1099">  struct rte *rte;</a>
<a name="ln1100">  struct prefix_ipv4 ifaddr;</a>
<a name="ln1101">  struct prefix_ipv4 ifaddrclass;</a>
<a name="ln1102">  int subnetted;</a>
<a name="ln1103"> </a>
<a name="ln1104">  memset(&amp;ifaddr, 0, sizeof(ifaddr));</a>
<a name="ln1105">  /* We don't know yet. */</a>
<a name="ln1106">  subnetted = -1;</a>
<a name="ln1107"> </a>
<a name="ln1108">  /* The Response must be ignored if it is not from the RIP</a>
<a name="ln1109">     port. (RFC2453 - Sec. 3.9.2)*/</a>
<a name="ln1110">  if (from-&gt;sin_port != htons(RIP_PORT_DEFAULT))</a>
<a name="ln1111">    {</a>
<a name="ln1112">      zlog_info (&quot;response doesn't come from RIP port: %d&quot;,</a>
<a name="ln1113">		 from-&gt;sin_port);</a>
<a name="ln1114">      rip_peer_bad_packet (from);</a>
<a name="ln1115">      return;</a>
<a name="ln1116">    }</a>
<a name="ln1117"> </a>
<a name="ln1118">  /* The datagram's IPv4 source address should be checked to see</a>
<a name="ln1119">     whether the datagram is from a valid neighbor; the source of the</a>
<a name="ln1120">     datagram must be on a directly connected network (RFC2453 - Sec. 3.9.2) */</a>
<a name="ln1121">  if (if_lookup_address(from-&gt;sin_addr) == NULL) </a>
<a name="ln1122">    {</a>
<a name="ln1123">      zlog_info (&quot;This datagram doesn't came from a valid neighbor: %s&quot;,</a>
<a name="ln1124">		 inet_ntoa (from-&gt;sin_addr));</a>
<a name="ln1125">      rip_peer_bad_packet (from);</a>
<a name="ln1126">      return;</a>
<a name="ln1127">    }</a>
<a name="ln1128"> </a>
<a name="ln1129">  /* It is also worth checking to see whether the response is from one</a>
<a name="ln1130">     of the router's own addresses. */</a>
<a name="ln1131"> </a>
<a name="ln1132">  ; /* Alredy done in rip_read () */</a>
<a name="ln1133"> </a>
<a name="ln1134">  /* Update RIP peer. */</a>
<a name="ln1135">  rip_peer_update (from, packet-&gt;version);</a>
<a name="ln1136"> </a>
<a name="ln1137">  /* Set RTE pointer. */</a>
<a name="ln1138">  rte = packet-&gt;rte;</a>
<a name="ln1139"> </a>
<a name="ln1140">  for (lim = (caddr_t) packet + size; (caddr_t) rte &lt; lim; rte++)</a>
<a name="ln1141">    {</a>
<a name="ln1142">      /* RIPv2 authentication check. */</a>
<a name="ln1143">      /* If the Address Family Identifier of the first (and only the</a>
<a name="ln1144">	 first) entry in the message is 0xFFFF, then the remainder of</a>
<a name="ln1145">	 the entry contains the authentication. */</a>
<a name="ln1146">      /* If the packet gets here it means authentication enabled */</a>
<a name="ln1147">      /* Check is done in rip_read(). So, just skipping it */</a>
<a name="ln1148">      if (packet-&gt;version == RIPv2 &amp;&amp;</a>
<a name="ln1149">	  rte == packet-&gt;rte &amp;&amp;</a>
<a name="ln1150">	  rte-&gt;family == htons(RIP_FAMILY_AUTH))</a>
<a name="ln1151">	continue;</a>
<a name="ln1152"> </a>
<a name="ln1153">      if (rte-&gt;family != htons(AF_INET))</a>
<a name="ln1154">	{</a>
<a name="ln1155">	  /* Address family check.  RIP only supports AF_INET. */</a>
<a name="ln1156">	  zlog_info (&quot;Unsupported family %d from %s.&quot;,</a>
<a name="ln1157">		     ntohs (rte-&gt;family), inet_ntoa (from-&gt;sin_addr));</a>
<a name="ln1158">	  continue;</a>
<a name="ln1159">	}</a>
<a name="ln1160"> </a>
<a name="ln1161">      /* - is the destination address valid (e.g., unicast; not net 0</a>
<a name="ln1162">         or 127) */</a>
<a name="ln1163">      if (! rip_destination_check (rte-&gt;prefix))</a>
<a name="ln1164">        {</a>
<a name="ln1165">	  zlog_info (&quot;Network is net 0 or net 127 or it is not unicast network&quot;);</a>
<a name="ln1166">	  rip_peer_bad_route (from);</a>
<a name="ln1167">	  continue;</a>
<a name="ln1168">	} </a>
<a name="ln1169"> </a>
<a name="ln1170">      /* Convert metric value to host byte order. */</a>
<a name="ln1171">      rte-&gt;metric = ntohl (rte-&gt;metric);</a>
<a name="ln1172"> </a>
<a name="ln1173">      /* - is the metric valid (i.e., between 1 and 16, inclusive) */</a>
<a name="ln1174">      if (! (rte-&gt;metric &gt;= 1 &amp;&amp; rte-&gt;metric &lt;= 16))</a>
<a name="ln1175">	{</a>
<a name="ln1176">	  zlog_info (&quot;Route's metric is not in the 1-16 range.&quot;);</a>
<a name="ln1177">	  rip_peer_bad_route (from);</a>
<a name="ln1178">	  continue;</a>
<a name="ln1179">	}</a>
<a name="ln1180"> </a>
<a name="ln1181">      /* RIPv1 does not have nexthop value. */</a>
<a name="ln1182">      if (packet-&gt;version == RIPv1 &amp;&amp; rte-&gt;nexthop.s_addr != 0)</a>
<a name="ln1183">	{</a>
<a name="ln1184">	  zlog_info (&quot;RIPv1 packet with nexthop value %s&quot;,</a>
<a name="ln1185">		     inet_ntoa (rte-&gt;nexthop));</a>
<a name="ln1186">	  rip_peer_bad_route (from);</a>
<a name="ln1187">	  continue;</a>
<a name="ln1188">	}</a>
<a name="ln1189"> </a>
<a name="ln1190">      /* That is, if the provided information is ignored, a possibly</a>
<a name="ln1191">	 sub-optimal, but absolutely valid, route may be taken.  If</a>
<a name="ln1192">	 the received Next Hop is not directly reachable, it should be</a>
<a name="ln1193">	 treated as 0.0.0.0. */</a>
<a name="ln1194">      if (packet-&gt;version == RIPv2 &amp;&amp; rte-&gt;nexthop.s_addr != 0)</a>
<a name="ln1195">	{</a>
<a name="ln1196">	  u_int32_t addrval;</a>
<a name="ln1197"> </a>
<a name="ln1198">	  /* Multicast address check. */</a>
<a name="ln1199">	  addrval = ntohl (rte-&gt;nexthop.s_addr);</a>
<a name="ln1200">	  if (IN_CLASSD (addrval))</a>
<a name="ln1201">	    {</a>
<a name="ln1202">	      zlog_info (&quot;Nexthop %s is multicast address, skip this rte&quot;,</a>
<a name="ln1203">			 inet_ntoa (rte-&gt;nexthop));</a>
<a name="ln1204">	      continue;</a>
<a name="ln1205">	    }</a>
<a name="ln1206"> </a>
<a name="ln1207">	  if (! if_lookup_address (rte-&gt;nexthop))</a>
<a name="ln1208">	    {</a>
<a name="ln1209">	      struct route_node *rn;</a>
<a name="ln1210">	      struct rip_info *rinfo;</a>
<a name="ln1211"> </a>
<a name="ln1212">	      rn = route_node_match_ipv4 (rip-&gt;table, &amp;rte-&gt;nexthop);</a>
<a name="ln1213"> </a>
<a name="ln1214">	      if (rn)</a>
<a name="ln1215">		{</a>
<a name="ln1216">		  rinfo = rn-&gt;info;</a>
<a name="ln1217"> </a>
<a name="ln1218">		  if (rinfo-&gt;type == ZEBRA_ROUTE_RIP</a>
<a name="ln1219">		      &amp;&amp; rinfo-&gt;sub_type == RIP_ROUTE_RTE)</a>
<a name="ln1220">		    {</a>
<a name="ln1221">		      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1222">			zlog_debug (&quot;Next hop %s is on RIP network.  Set nexthop to the packet's originator&quot;, inet_ntoa (rte-&gt;nexthop));</a>
<a name="ln1223">		      rte-&gt;nexthop = rinfo-&gt;from;</a>
<a name="ln1224">		    }</a>
<a name="ln1225">		  else</a>
<a name="ln1226">		    {</a>
<a name="ln1227">		      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1228">			zlog_debug (&quot;Next hop %s is not directly reachable. Treat it as 0.0.0.0&quot;, inet_ntoa (rte-&gt;nexthop));</a>
<a name="ln1229">		      rte-&gt;nexthop.s_addr = 0;</a>
<a name="ln1230">		    }</a>
<a name="ln1231"> </a>
<a name="ln1232">		  route_unlock_node (rn);</a>
<a name="ln1233">		}</a>
<a name="ln1234">	      else</a>
<a name="ln1235">		{</a>
<a name="ln1236">		  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1237">		    zlog_debug (&quot;Next hop %s is not directly reachable. Treat it as 0.0.0.0&quot;, inet_ntoa (rte-&gt;nexthop));</a>
<a name="ln1238">		  rte-&gt;nexthop.s_addr = 0;</a>
<a name="ln1239">		}</a>
<a name="ln1240"> </a>
<a name="ln1241">	    }</a>
<a name="ln1242">	}</a>
<a name="ln1243"> </a>
<a name="ln1244">     /* For RIPv1, there won't be a valid netmask.  </a>
<a name="ln1245"> </a>
<a name="ln1246">	This is a best guess at the masks.  If everyone was using old</a>
<a name="ln1247">	Ciscos before the 'ip subnet zero' option, it would be almost</a>
<a name="ln1248">	right too :-)</a>
<a name="ln1249">      </a>
<a name="ln1250">	Cisco summarize ripv1 advertisments to the classful boundary</a>
<a name="ln1251">	(/16 for class B's) except when the RIP packet does to inside</a>
<a name="ln1252">	the classful network in question.  */</a>
<a name="ln1253"> </a>
<a name="ln1254">      if ((packet-&gt;version == RIPv1 &amp;&amp; rte-&gt;prefix.s_addr != 0) </a>
<a name="ln1255">	  || (packet-&gt;version == RIPv2 </a>
<a name="ln1256">	      &amp;&amp; (rte-&gt;prefix.s_addr != 0 &amp;&amp; rte-&gt;mask.s_addr == 0)))</a>
<a name="ln1257">	{</a>
<a name="ln1258">	  u_int32_t destination;</a>
<a name="ln1259"> </a>
<a name="ln1260">	  if (subnetted == -1)</a>
<a name="ln1261">            {</a>
<a name="ln1262">              memcpy (&amp;ifaddr, ifc-&gt;address, sizeof (struct prefix_ipv4));</a>
<a name="ln1263">              memcpy (&amp;ifaddrclass, &amp;ifaddr, sizeof (struct prefix_ipv4));</a>
<a name="ln1264">              apply_classful_mask_ipv4 (&amp;ifaddrclass);</a>
<a name="ln1265">              subnetted = 0;</a>
<a name="ln1266">              if (ifaddr.prefixlen &gt; ifaddrclass.prefixlen)</a>
<a name="ln1267">                subnetted = 1;</a>
<a name="ln1268">            }</a>
<a name="ln1269"> </a>
<a name="ln1270">	  destination = ntohl (rte-&gt;prefix.s_addr);</a>
<a name="ln1271"> </a>
<a name="ln1272">	  if (IN_CLASSA (destination))</a>
<a name="ln1273">	      masklen2ip (8, &amp;rte-&gt;mask);</a>
<a name="ln1274">	  else if (IN_CLASSB (destination))</a>
<a name="ln1275">	      masklen2ip (16, &amp;rte-&gt;mask);</a>
<a name="ln1276">	  else if (IN_CLASSC (destination))</a>
<a name="ln1277">	      masklen2ip (24, &amp;rte-&gt;mask);</a>
<a name="ln1278"> </a>
<a name="ln1279">	  if (subnetted == 1)</a>
<a name="ln1280">	    masklen2ip (ifaddrclass.prefixlen,</a>
<a name="ln1281">			(struct in_addr *) &amp;destination);</a>
<a name="ln1282">	  if ((subnetted == 1) &amp;&amp; ((rte-&gt;prefix.s_addr &amp; destination) ==</a>
<a name="ln1283">	      ifaddrclass.prefix.s_addr))</a>
<a name="ln1284">	    {</a>
<a name="ln1285">	      masklen2ip (ifaddr.prefixlen, &amp;rte-&gt;mask);</a>
<a name="ln1286">	      if ((rte-&gt;prefix.s_addr &amp; rte-&gt;mask.s_addr) != rte-&gt;prefix.s_addr)</a>
<a name="ln1287">		masklen2ip (32, &amp;rte-&gt;mask);</a>
<a name="ln1288">	      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1289">		zlog_debug (&quot;Subnetted route %s&quot;, inet_ntoa (rte-&gt;prefix));</a>
<a name="ln1290">	    }</a>
<a name="ln1291">	  else</a>
<a name="ln1292">	    {</a>
<a name="ln1293">	      if ((rte-&gt;prefix.s_addr &amp; rte-&gt;mask.s_addr) != rte-&gt;prefix.s_addr)</a>
<a name="ln1294">		continue;</a>
<a name="ln1295">	    }</a>
<a name="ln1296"> </a>
<a name="ln1297">	  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1298">	    {</a>
<a name="ln1299">	      zlog_debug (&quot;Resultant route %s&quot;, inet_ntoa (rte-&gt;prefix));</a>
<a name="ln1300">	      zlog_debug (&quot;Resultant mask %s&quot;, inet_ntoa (rte-&gt;mask));</a>
<a name="ln1301">	    }</a>
<a name="ln1302">	}</a>
<a name="ln1303"> </a>
<a name="ln1304">      /* In case of RIPv2, if prefix in RTE is not netmask applied one</a>
<a name="ln1305">         ignore the entry.  */</a>
<a name="ln1306">      if ((packet-&gt;version == RIPv2) </a>
<a name="ln1307">	  &amp;&amp; (rte-&gt;mask.s_addr != 0) </a>
<a name="ln1308">	  &amp;&amp; ((rte-&gt;prefix.s_addr &amp; rte-&gt;mask.s_addr) != rte-&gt;prefix.s_addr))</a>
<a name="ln1309">	{</a>
<a name="ln1310">	  zlog_warn (&quot;RIPv2 address %s is not mask /%d applied one&quot;,</a>
<a name="ln1311">		     inet_ntoa (rte-&gt;prefix), ip_masklen (rte-&gt;mask));</a>
<a name="ln1312">	  rip_peer_bad_route (from);</a>
<a name="ln1313">	  continue;</a>
<a name="ln1314">	}</a>
<a name="ln1315">      </a>
<a name="ln1316">      /* Default route sanity check */</a>
<a name="ln1317">      if (packet-&gt;version == RIPv2</a>
<a name="ln1318">          &amp;&amp; (rte-&gt;mask.s_addr == 0)</a>
<a name="ln1319">          &amp;&amp; (rte-&gt;prefix.s_addr != 0))</a>
<a name="ln1320">        {</a>
<a name="ln1321">          if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1322">            zlog_warn (&quot;Malformed route, zero netmask &quot;</a>
<a name="ln1323">                       &quot;with non-zero addr - dropping route!&quot;);</a>
<a name="ln1324">          rip_peer_bad_route (from);</a>
<a name="ln1325">          continue;</a>
<a name="ln1326">        }</a>
<a name="ln1327">      </a>
<a name="ln1328">      /* Routing table updates. */</a>
<a name="ln1329">      rip_rte_process (rte, from, ifc-&gt;ifp);</a>
<a name="ln1330">    }</a>
<a name="ln1331">}</a>
<a name="ln1332"> </a>
<a name="ln1333">/* Make socket for RIP protocol. */</a>
<a name="ln1334">static int </a>
<a name="ln1335">rip_create_socket (struct sockaddr_in *from)</a>
<a name="ln1336">{</a>
<a name="ln1337">  int ret;</a>
<a name="ln1338">  int sock;</a>
<a name="ln1339">  struct sockaddr_in addr;</a>
<a name="ln1340">  </a>
<a name="ln1341">  memset (&amp;addr, 0, sizeof (struct sockaddr_in));</a>
<a name="ln1342">  </a>
<a name="ln1343">  if (!from)</a>
<a name="ln1344">    {</a>
<a name="ln1345">      addr.sin_family = AF_INET;</a>
<a name="ln1346">      addr.sin_addr.s_addr = INADDR_ANY;</a>
<a name="ln1347">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln1348">      addr.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln1349">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln1350">    } else {</a>
<a name="ln1351">      memcpy(&amp;addr, from, sizeof(addr));</a>
<a name="ln1352">    }</a>
<a name="ln1353">  </a>
<a name="ln1354">  /* sending port must always be the RIP port */</a>
<a name="ln1355">  addr.sin_port = htons (RIP_PORT_DEFAULT);</a>
<a name="ln1356">  </a>
<a name="ln1357">  /* Make datagram socket. */</a>
<a name="ln1358">  sock = socket (AF_INET, SOCK_DGRAM, 0);</a>
<a name="ln1359">  if (sock &lt; 0) </a>
<a name="ln1360">    {</a>
<a name="ln1361">      zlog_err(&quot;Cannot create UDP socket: %s&quot;, safe_strerror(errno));</a>
<a name="ln1362">      exit (1);</a>
<a name="ln1363">    }</a>
<a name="ln1364"> </a>
<a name="ln1365">  sockopt_broadcast (sock);</a>
<a name="ln1366">  sockopt_reuseaddr (sock);</a>
<a name="ln1367">  sockopt_reuseport (sock);</a>
<a name="ln1368">#ifdef RIP_RECVMSG</a>
<a name="ln1369">  setsockopt_pktinfo (sock);</a>
<a name="ln1370">#endif /* RIP_RECVMSG */</a>
<a name="ln1371">#ifdef IPTOS_PREC_INTERNETCONTROL</a>
<a name="ln1372">  setsockopt_ipv4_tos (sock, IPTOS_PREC_INTERNETCONTROL);</a>
<a name="ln1373">#endif</a>
<a name="ln1374"> </a>
<a name="ln1375">  if (ripd_privs.change (ZPRIVS_RAISE))</a>
<a name="ln1376">      zlog_err (&quot;rip_create_socket: could not raise privs&quot;);</a>
<a name="ln1377">  setsockopt_so_recvbuf (sock, RIP_UDP_RCV_BUF);</a>
<a name="ln1378">  if ( (ret = bind (sock, (struct sockaddr *) &amp; addr, sizeof (addr))) &lt; 0)</a>
<a name="ln1379">  </a>
<a name="ln1380">    {</a>
<a name="ln1381">      int save_errno = errno;</a>
<a name="ln1382">      if (ripd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln1383">        zlog_err (&quot;rip_create_socket: could not lower privs&quot;);</a>
<a name="ln1384">      </a>
<a name="ln1385">      zlog_err(&quot;%s: Can't bind socket %d to %s port %d: %s&quot;, __func__,</a>
<a name="ln1386">	       sock, inet_ntoa(addr.sin_addr), </a>
<a name="ln1387">	       (int) ntohs(addr.sin_port), </a>
<a name="ln1388">	       safe_strerror(save_errno));</a>
<a name="ln1389">      </a>
<a name="ln1390">      close (sock);</a>
<a name="ln1391">      return ret;</a>
<a name="ln1392">    }</a>
<a name="ln1393">  </a>
<a name="ln1394">  if (ripd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln1395">      zlog_err (&quot;rip_create_socket: could not lower privs&quot;);</a>
<a name="ln1396">      </a>
<a name="ln1397">  return sock;</a>
<a name="ln1398">}</a>
<a name="ln1399"> </a>
<a name="ln1400">/* RIP packet send to destination address, on interface denoted by</a>
<a name="ln1401"> * by connected argument. NULL to argument denotes destination should be</a>
<a name="ln1402"> * should be RIP multicast group</a>
<a name="ln1403"> */</a>
<a name="ln1404">static int</a>
<a name="ln1405">rip_send_packet (u_char * buf, int size, struct sockaddr_in *to,</a>
<a name="ln1406">                 struct connected *ifc)</a>
<a name="ln1407">{</a>
<a name="ln1408">  int ret, send_sock;</a>
<a name="ln1409">  struct sockaddr_in sin;</a>
<a name="ln1410">  </a>
<a name="ln1411">  assert (ifc != NULL);</a>
<a name="ln1412">  </a>
<a name="ln1413">  if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln1414">    {</a>
<a name="ln1415">#define ADDRESS_SIZE 20</a>
<a name="ln1416">      char dst[ADDRESS_SIZE];</a>
<a name="ln1417">      dst[ADDRESS_SIZE - 1] = '\0';</a>
<a name="ln1418">      </a>
<a name="ln1419">      if (to)</a>
<a name="ln1420">        {</a>
<a name="ln1421">          strncpy (dst, inet_ntoa(to-&gt;sin_addr), ADDRESS_SIZE - 1);</a>
<a name="ln1422">        }</a>
<a name="ln1423">      else</a>
<a name="ln1424">        {</a>
<a name="ln1425">          sin.sin_addr.s_addr = htonl (INADDR_RIP_GROUP);</a>
<a name="ln1426">          strncpy (dst, inet_ntoa(sin.sin_addr), ADDRESS_SIZE - 1);</a>
<a name="ln1427">        }</a>
<a name="ln1428">#undef ADDRESS_SIZE</a>
<a name="ln1429">      zlog_debug(&quot;rip_send_packet %s &gt; %s (%s)&quot;,</a>
<a name="ln1430">                inet_ntoa(ifc-&gt;address-&gt;u.prefix4),</a>
<a name="ln1431">                dst, ifc-&gt;ifp-&gt;name);</a>
<a name="ln1432">    }</a>
<a name="ln1433">  </a>
<a name="ln1434">  if ( CHECK_FLAG (ifc-&gt;flags, ZEBRA_IFA_SECONDARY) )</a>
<a name="ln1435">    {</a>
<a name="ln1436">      /*</a>
<a name="ln1437">       * ZEBRA_IFA_SECONDARY is set on linux when an interface is configured</a>
<a name="ln1438">       * with multiple addresses on the same subnet: the first address</a>
<a name="ln1439">       * on the subnet is configured &quot;primary&quot;, and all subsequent addresses</a>
<a name="ln1440">       * on that subnet are treated as &quot;secondary&quot; addresses. </a>
<a name="ln1441">       * In order to avoid routing-table bloat on other rip listeners, </a>
<a name="ln1442">       * we do not send out RIP packets with ZEBRA_IFA_SECONDARY source addrs.</a>
<a name="ln1443">       * XXX Since Linux is the only system for which the ZEBRA_IFA_SECONDARY</a>
<a name="ln1444">       * flag is set, we would end up sending a packet for a &quot;secondary&quot;</a>
<a name="ln1445">       * source address on non-linux systems.  </a>
<a name="ln1446">       */</a>
<a name="ln1447">      if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln1448">        zlog_debug(&quot;duplicate dropped&quot;);</a>
<a name="ln1449">      return 0;</a>
<a name="ln1450">    }</a>
<a name="ln1451"> </a>
<a name="ln1452">  /* Make destination address. */</a>
<a name="ln1453">  memset (&amp;sin, 0, sizeof (struct sockaddr_in));</a>
<a name="ln1454">  sin.sin_family = AF_INET;</a>
<a name="ln1455">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln1456">  sin.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln1457">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln1458"> </a>
<a name="ln1459">  /* When destination is specified, use it's port and address. */</a>
<a name="ln1460">  if (to)</a>
<a name="ln1461">    {</a>
<a name="ln1462">      sin.sin_port = to-&gt;sin_port;</a>
<a name="ln1463">      sin.sin_addr = to-&gt;sin_addr;</a>
<a name="ln1464">      send_sock = rip-&gt;sock;</a>
<a name="ln1465">    }</a>
<a name="ln1466">  else</a>
<a name="ln1467">    {</a>
<a name="ln1468">      struct sockaddr_in from;</a>
<a name="ln1469">      </a>
<a name="ln1470">      sin.sin_port = htons (RIP_PORT_DEFAULT);</a>
<a name="ln1471">      sin.sin_addr.s_addr = htonl (INADDR_RIP_GROUP);</a>
<a name="ln1472">      </a>
<a name="ln1473">      /* multicast send should bind to local interface address */</a>
<a name="ln1474">      memset (&amp;from, 0, sizeof (from));</a>
<a name="ln1475">      from.sin_family = AF_INET;</a>
<a name="ln1476">      from.sin_port = htons (RIP_PORT_DEFAULT);</a>
<a name="ln1477">      from.sin_addr = ifc-&gt;address-&gt;u.prefix4;</a>
<a name="ln1478">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln1479">      from.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln1480">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln1481">      </a>
<a name="ln1482">      /*</a>
<a name="ln1483">       * we have to open a new socket for each packet because this</a>
<a name="ln1484">       * is the most portable way to bind to a different source</a>
<a name="ln1485">       * ipv4 address for each packet. </a>
<a name="ln1486">       */</a>
<a name="ln1487">      if ( (send_sock = rip_create_socket (&amp;from)) &lt; 0)</a>
<a name="ln1488">        {</a>
<a name="ln1489">          zlog_warn(&quot;rip_send_packet could not create socket.&quot;);</a>
<a name="ln1490">          return -1;</a>
<a name="ln1491">        }</a>
<a name="ln1492">      rip_interface_multicast_set (send_sock, ifc);</a>
<a name="ln1493">    }</a>
<a name="ln1494"> </a>
<a name="ln1495">  ret = sendto (send_sock, buf, size, 0, (struct sockaddr *)&amp;sin,</a>
<a name="ln1496">		sizeof (struct sockaddr_in));</a>
<a name="ln1497"> </a>
<a name="ln1498">  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1499">      zlog_debug (&quot;SEND to  %s.%d&quot;, inet_ntoa(sin.sin_addr), </a>
<a name="ln1500">                  ntohs (sin.sin_port));</a>
<a name="ln1501"> </a>
<a name="ln1502">  if (ret &lt; 0)</a>
<a name="ln1503">    zlog_warn (&quot;can't send packet : %s&quot;, safe_strerror (errno));</a>
<a name="ln1504"> </a>
<a name="ln1505">  if (!to)</a>
<a name="ln1506">    close(send_sock);</a>
<a name="ln1507"> </a>
<a name="ln1508">  return ret;</a>
<a name="ln1509">}</a>
<a name="ln1510"> </a>
<a name="ln1511">/* Add redistributed route to RIP table. */</a>
<a name="ln1512">void</a>
<a name="ln1513">rip_redistribute_add (int type, int sub_type, struct prefix_ipv4 *p, </a>
<a name="ln1514">		      ifindex_t ifindex, struct in_addr *nexthop,</a>
<a name="ln1515">                      unsigned int metric, unsigned char distance,</a>
<a name="ln1516">                      route_tag_t tag)</a>
<a name="ln1517">{</a>
<a name="ln1518">  int ret;</a>
<a name="ln1519">  struct route_node *rp = NULL;</a>
<a name="ln1520">  struct rip_info *rinfo = NULL, newinfo;</a>
<a name="ln1521">  struct list *list = NULL;</a>
<a name="ln1522"> </a>
<a name="ln1523">  /* Redistribute route  */</a>
<a name="ln1524">  ret = rip_destination_check (p-&gt;prefix);</a>
<a name="ln1525">  if (! ret)</a>
<a name="ln1526">    return;</a>
<a name="ln1527"> </a>
<a name="ln1528">  rp = route_node_get (rip-&gt;table, (struct prefix *) p);</a>
<a name="ln1529"> </a>
<a name="ln1530">  memset (&amp;newinfo, 0, sizeof (struct rip_info));</a>
<a name="ln1531">  newinfo.type = type;</a>
<a name="ln1532">  newinfo.sub_type = sub_type;</a>
<a name="ln1533">  newinfo.ifindex = ifindex;</a>
<a name="ln1534">  newinfo.metric = 1;</a>
<a name="ln1535">  newinfo.external_metric = metric;</a>
<a name="ln1536">  newinfo.distance = distance;</a>
<a name="ln1537">  if (tag &lt;= UINT16_MAX) /* RIP only supports 16 bit tags */</a>
<a name="ln1538">    newinfo.tag = tag;</a>
<a name="ln1539">  newinfo.rp = rp;</a>
<a name="ln1540">  if (nexthop)</a>
<a name="ln1541">    newinfo.nexthop = *nexthop;</a>
<a name="ln1542"> </a>
<a name="ln1543">  if ((list = rp-&gt;info) != NULL &amp;&amp; listcount (list) != 0)</a>
<a name="ln1544">    {</a>
<a name="ln1545">      rinfo = listgetdata (listhead (list));</a>
<a name="ln1546"> </a>
<a name="ln1547">      if (rinfo-&gt;type == ZEBRA_ROUTE_CONNECT </a>
<a name="ln1548">	  &amp;&amp; rinfo-&gt;sub_type == RIP_ROUTE_INTERFACE</a>
<a name="ln1549">	  &amp;&amp; rinfo-&gt;metric != RIP_METRIC_INFINITY)</a>
<a name="ln1550">	{</a>
<a name="ln1551">	  route_unlock_node (rp);</a>
<a name="ln1552">	  return;</a>
<a name="ln1553">	}</a>
<a name="ln1554"> </a>
<a name="ln1555">      /* Manually configured RIP route check. */</a>
<a name="ln1556">      if (rinfo-&gt;type == ZEBRA_ROUTE_RIP </a>
<a name="ln1557">	  &amp;&amp; ((rinfo-&gt;sub_type == RIP_ROUTE_STATIC) ||</a>
<a name="ln1558">	      (rinfo-&gt;sub_type == RIP_ROUTE_DEFAULT)) )</a>
<a name="ln1559">	{</a>
<a name="ln1560">	  if (type != ZEBRA_ROUTE_RIP || ((sub_type != RIP_ROUTE_STATIC) &amp;&amp;</a>
<a name="ln1561">	                                  (sub_type != RIP_ROUTE_DEFAULT)))</a>
<a name="ln1562">	    {</a>
<a name="ln1563">	      route_unlock_node (rp);</a>
<a name="ln1564">	      return;</a>
<a name="ln1565">	    }</a>
<a name="ln1566">	}</a>
<a name="ln1567"> </a>
<a name="ln1568">      rinfo = rip_ecmp_replace (&amp;newinfo);</a>
<a name="ln1569">      route_unlock_node (rp);</a>
<a name="ln1570">    }</a>
<a name="ln1571">  else</a>
<a name="ln1572">    rinfo = rip_ecmp_add (&amp;newinfo);</a>
<a name="ln1573"> </a>
<a name="ln1574">  if (IS_RIP_DEBUG_EVENT) {</a>
<a name="ln1575">    if (!nexthop)</a>
<a name="ln1576">      zlog_debug (&quot;Redistribute new prefix %s/%d on the interface %s&quot;,</a>
<a name="ln1577">                 inet_ntoa(p-&gt;prefix), p-&gt;prefixlen,</a>
<a name="ln1578">                 ifindex2ifname(ifindex));</a>
<a name="ln1579">    else</a>
<a name="ln1580">      zlog_debug (&quot;Redistribute new prefix %s/%d with nexthop %s on the interface %s&quot;,</a>
<a name="ln1581">                 inet_ntoa(p-&gt;prefix), p-&gt;prefixlen, inet_ntoa(rinfo-&gt;nexthop),</a>
<a name="ln1582">                 ifindex2ifname(ifindex));</a>
<a name="ln1583">  }</a>
<a name="ln1584"> </a>
<a name="ln1585">  rip_event (RIP_TRIGGERED_UPDATE, 0);</a>
<a name="ln1586">}</a>
<a name="ln1587"> </a>
<a name="ln1588">/* Delete redistributed route from RIP table. */</a>
<a name="ln1589">void</a>
<a name="ln1590">rip_redistribute_delete (int type, int sub_type, struct prefix_ipv4 *p, </a>
<a name="ln1591">			 ifindex_t ifindex)</a>
<a name="ln1592">{</a>
<a name="ln1593">  int ret;</a>
<a name="ln1594">  struct route_node *rp;</a>
<a name="ln1595">  struct rip_info *rinfo;</a>
<a name="ln1596"> </a>
<a name="ln1597">  ret = rip_destination_check (p-&gt;prefix);</a>
<a name="ln1598">  if (! ret)</a>
<a name="ln1599">    return;</a>
<a name="ln1600"> </a>
<a name="ln1601">  rp = route_node_lookup (rip-&gt;table, (struct prefix *) p);</a>
<a name="ln1602">  if (rp)</a>
<a name="ln1603">    {</a>
<a name="ln1604">      struct list *list = rp-&gt;info;</a>
<a name="ln1605"> </a>
<a name="ln1606">      if (list != NULL &amp;&amp; listcount (list) != 0)</a>
<a name="ln1607">        {</a>
<a name="ln1608">          rinfo = listgetdata (listhead (list));</a>
<a name="ln1609">          if (rinfo != NULL</a>
<a name="ln1610">              &amp;&amp; rinfo-&gt;type == type</a>
<a name="ln1611">              &amp;&amp; rinfo-&gt;sub_type == sub_type</a>
<a name="ln1612">              &amp;&amp; rinfo-&gt;ifindex == ifindex)</a>
<a name="ln1613">            {</a>
<a name="ln1614">              /* Perform poisoned reverse. */</a>
<a name="ln1615">              rinfo-&gt;metric = RIP_METRIC_INFINITY;</a>
<a name="ln1616">              RIP_TIMER_ON (rinfo-&gt;t_garbage_collect,</a>
<a name="ln1617">                            rip_garbage_collect, rip-&gt;garbage_time);</a>
<a name="ln1618">              RIP_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln1619">              rinfo-&gt;flags |= RIP_RTF_CHANGED;</a>
<a name="ln1620"> </a>
<a name="ln1621">              if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1622">                zlog_debug (&quot;Poisone %s/%d on the interface %s with an &quot;</a>
<a name="ln1623">                            &quot;infinity metric [delete]&quot;,</a>
<a name="ln1624">                            inet_ntoa(p-&gt;prefix), p-&gt;prefixlen,</a>
<a name="ln1625">                            ifindex2ifname(ifindex));</a>
<a name="ln1626"> </a>
<a name="ln1627">              rip_event (RIP_TRIGGERED_UPDATE, 0);</a>
<a name="ln1628">            }</a>
<a name="ln1629">        }</a>
<a name="ln1630">      route_unlock_node (rp);</a>
<a name="ln1631">    }</a>
<a name="ln1632">}</a>
<a name="ln1633"> </a>
<a name="ln1634">/* Response to request called from rip_read ().*/</a>
<a name="ln1635">static void</a>
<a name="ln1636">rip_request_process (struct rip_packet *packet, int size, </a>
<a name="ln1637">		     struct sockaddr_in *from, struct connected *ifc)</a>
<a name="ln1638">{</a>
<a name="ln1639">  caddr_t lim;</a>
<a name="ln1640">  struct rte *rte;</a>
<a name="ln1641">  struct prefix_ipv4 p;</a>
<a name="ln1642">  struct route_node *rp;</a>
<a name="ln1643">  struct rip_info *rinfo;</a>
<a name="ln1644">  struct rip_interface *ri;</a>
<a name="ln1645"> </a>
<a name="ln1646">  /* Does not reponse to the requests on the loopback interfaces */</a>
<a name="ln1647">  if (if_is_loopback (ifc-&gt;ifp))</a>
<a name="ln1648">    return;</a>
<a name="ln1649"> </a>
<a name="ln1650">  /* Check RIP process is enabled on this interface. */</a>
<a name="ln1651">  ri = ifc-&gt;ifp-&gt;info;</a>
<a name="ln1652">  if (! ri-&gt;running)</a>
<a name="ln1653">    return;</a>
<a name="ln1654"> </a>
<a name="ln1655">  /* When passive interface is specified, suppress responses */</a>
<a name="ln1656">  if (ri-&gt;passive)</a>
<a name="ln1657">    return;</a>
<a name="ln1658">  </a>
<a name="ln1659">  /* RIP peer update. */</a>
<a name="ln1660">  rip_peer_update (from, packet-&gt;version);</a>
<a name="ln1661"> </a>
<a name="ln1662">  lim = ((caddr_t) packet) + size;</a>
<a name="ln1663">  rte = packet-&gt;rte;</a>
<a name="ln1664"> </a>
<a name="ln1665">  /* The Request is processed entry by entry.  If there are no</a>
<a name="ln1666">     entries, no response is given. */</a>
<a name="ln1667">  if (lim == (caddr_t) rte)</a>
<a name="ln1668">    return;</a>
<a name="ln1669"> </a>
<a name="ln1670">  /* There is one special case.  If there is exactly one entry in the</a>
<a name="ln1671">     request, and it has an address family identifier of zero and a</a>
<a name="ln1672">     metric of infinity (i.e., 16), then this is a request to send the</a>
<a name="ln1673">     entire routing table. */</a>
<a name="ln1674">  if (lim == ((caddr_t) (rte + 1)) &amp;&amp;</a>
<a name="ln1675">      ntohs (rte-&gt;family) == 0 &amp;&amp;</a>
<a name="ln1676">      ntohl (rte-&gt;metric) == RIP_METRIC_INFINITY)</a>
<a name="ln1677">    {	</a>
<a name="ln1678">      /* All route with split horizon */</a>
<a name="ln1679">      rip_output_process (ifc, from, rip_all_route, packet-&gt;version);</a>
<a name="ln1680">    }</a>
<a name="ln1681">  else</a>
<a name="ln1682">    {</a>
<a name="ln1683">      /* Examine the list of RTEs in the Request one by one.  For each</a>
<a name="ln1684">	 entry, look up the destination in the router's routing</a>
<a name="ln1685">	 database and, if there is a route, put that route's metric in</a>
<a name="ln1686">	 the metric field of the RTE.  If there is no explicit route</a>
<a name="ln1687">	 to the specified destination, put infinity in the metric</a>
<a name="ln1688">	 field.  Once all the entries have been filled in, change the</a>
<a name="ln1689">	 command from Request to Response and send the datagram back</a>
<a name="ln1690">	 to the requestor. */</a>
<a name="ln1691">      p.family = AF_INET;</a>
<a name="ln1692"> </a>
<a name="ln1693">      for (; ((caddr_t) rte) &lt; lim; rte++)</a>
<a name="ln1694">	{</a>
<a name="ln1695">	  p.prefix = rte-&gt;prefix;</a>
<a name="ln1696">	  p.prefixlen = ip_masklen (rte-&gt;mask);</a>
<a name="ln1697">	  apply_mask_ipv4 (&amp;p);</a>
<a name="ln1698">	  </a>
<a name="ln1699">	  rp = route_node_lookup (rip-&gt;table, (struct prefix *) &amp;p);</a>
<a name="ln1700">	  if (rp)</a>
<a name="ln1701">	    {</a>
<a name="ln1702">	      rinfo = listgetdata (listhead ((struct list *)rp-&gt;info));</a>
<a name="ln1703">	      rte-&gt;metric = htonl (rinfo-&gt;metric);</a>
<a name="ln1704">	      route_unlock_node (rp);</a>
<a name="ln1705">	    }</a>
<a name="ln1706">	  else</a>
<a name="ln1707">	    rte-&gt;metric = htonl (RIP_METRIC_INFINITY);</a>
<a name="ln1708">	}</a>
<a name="ln1709">      packet-&gt;command = RIP_RESPONSE;</a>
<a name="ln1710"> </a>
<a name="ln1711">      rip_send_packet ((u_char *)packet, size, from, ifc);</a>
<a name="ln1712">    }</a>
<a name="ln1713">  rip_global_queries++;</a>
<a name="ln1714">}</a>
<a name="ln1715"> </a>
<a name="ln1716">#if RIP_RECVMSG</a>
<a name="ln1717">/* Set IPv6 packet info to the socket. */</a>
<a name="ln1718">static int</a>
<a name="ln1719">setsockopt_pktinfo (int sock)</a>
<a name="ln1720">{</a>
<a name="ln1721">  int ret;</a>
<a name="ln1722">  int val = 1;</a>
<a name="ln1723">    </a>
<a name="ln1724">  ret = setsockopt(sock, IPPROTO_IP, IP_PKTINFO, &amp;val, sizeof(val));</a>
<a name="ln1725">  if (ret &lt; 0)</a>
<a name="ln1726">    zlog_warn (&quot;Can't setsockopt IP_PKTINFO : %s&quot;, safe_strerror (errno));</a>
<a name="ln1727">  return ret;</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">/* Read RIP packet by recvmsg function. */</a>
<a name="ln1731">int</a>
<a name="ln1732">rip_recvmsg (int sock, u_char *buf, int size, struct sockaddr_in *from,</a>
<a name="ln1733">	     ifindex_t *ifindex)</a>
<a name="ln1734">{</a>
<a name="ln1735">  int ret;</a>
<a name="ln1736">  struct msghdr msg;</a>
<a name="ln1737">  struct iovec iov;</a>
<a name="ln1738">  struct cmsghdr *ptr;</a>
<a name="ln1739">  char adata[1024];</a>
<a name="ln1740"> </a>
<a name="ln1741">  msg.msg_name = (void *) from;</a>
<a name="ln1742">  msg.msg_namelen = sizeof (struct sockaddr_in);</a>
<a name="ln1743">  msg.msg_iov = &amp;iov;</a>
<a name="ln1744">  msg.msg_iovlen = 1;</a>
<a name="ln1745">  msg.msg_control = (void *) adata;</a>
<a name="ln1746">  msg.msg_controllen = sizeof adata;</a>
<a name="ln1747">  iov.iov_base = buf;</a>
<a name="ln1748">  iov.iov_len = size;</a>
<a name="ln1749"> </a>
<a name="ln1750">  ret = recvmsg (sock, &amp;msg, 0);</a>
<a name="ln1751">  if (ret &lt; 0)</a>
<a name="ln1752">    return ret;</a>
<a name="ln1753"> </a>
<a name="ln1754">  for (ptr = ZCMSG_FIRSTHDR(&amp;msg); ptr != NULL; ptr = CMSG_NXTHDR(&amp;msg, ptr))</a>
<a name="ln1755">    if (ptr-&gt;cmsg_level == IPPROTO_IP &amp;&amp; ptr-&gt;cmsg_type == IP_PKTINFO) </a>
<a name="ln1756">      {</a>
<a name="ln1757">	struct in_pktinfo *pktinfo;</a>
<a name="ln1758">	int i;</a>
<a name="ln1759"> </a>
<a name="ln1760">	pktinfo = (struct in_pktinfo *) CMSG_DATA (ptr);</a>
<a name="ln1761">	i = pktinfo-&gt;ipi_ifindex;</a>
<a name="ln1762">      }</a>
<a name="ln1763">  return ret;</a>
<a name="ln1764">}</a>
<a name="ln1765"> </a>
<a name="ln1766">/* RIP packet read function. */</a>
<a name="ln1767">int</a>
<a name="ln1768">rip_read_new (struct thread *t)</a>
<a name="ln1769">{</a>
<a name="ln1770">  int ret;</a>
<a name="ln1771">  int sock;</a>
<a name="ln1772">  char buf[RIP_PACKET_MAXSIZ];</a>
<a name="ln1773">  struct sockaddr_in from;</a>
<a name="ln1774">  ifindex_t ifindex;</a>
<a name="ln1775">  </a>
<a name="ln1776">  /* Fetch socket then register myself. */</a>
<a name="ln1777">  sock = THREAD_FD (t);</a>
<a name="ln1778">  rip_event (RIP_READ, sock);</a>
<a name="ln1779"> </a>
<a name="ln1780">  /* Read RIP packet. */</a>
<a name="ln1781">  ret = rip_recvmsg (sock, buf, RIP_PACKET_MAXSIZ, &amp;from, (int *)&amp;ifindex);</a>
<a name="ln1782">  if (ret &lt; 0)</a>
<a name="ln1783">    {</a>
<a name="ln1784">      zlog_warn (&quot;Can't read RIP packet: %s&quot;, safe_strerror (errno));</a>
<a name="ln1785">      return ret;</a>
<a name="ln1786">    }</a>
<a name="ln1787"> </a>
<a name="ln1788">  return ret;</a>
<a name="ln1789">}</a>
<a name="ln1790">#endif /* RIP_RECVMSG */</a>
<a name="ln1791"> </a>
<a name="ln1792">/* First entry point of RIP packet. */</a>
<a name="ln1793">static int</a>
<a name="ln1794">rip_read (struct thread *t)</a>
<a name="ln1795">{</a>
<a name="ln1796">  int sock;</a>
<a name="ln1797">  int ret;</a>
<a name="ln1798">  int rtenum;</a>
<a name="ln1799">  union rip_buf rip_buf;</a>
<a name="ln1800">  struct rip_packet *packet;</a>
<a name="ln1801">  struct sockaddr_in from;</a>
<a name="ln1802">  int len;</a>
<a name="ln1803">  int vrecv;</a>
<a name="ln1804">  socklen_t fromlen;</a>
<a name="ln1805">  struct interface *ifp;</a>
<a name="ln1806">  struct connected *ifc;</a>
<a name="ln1807">  struct rip_interface *ri;</a>
<a name="ln1808"> </a>
<a name="ln1809">  /* Fetch socket then register myself. */</a>
<a name="ln1810">  sock = THREAD_FD (t);</a>
<a name="ln1811">  rip-&gt;t_read = NULL;</a>
<a name="ln1812"> </a>
<a name="ln1813">  /* Add myself to tne next event */</a>
<a name="ln1814">  rip_event (RIP_READ, sock);</a>
<a name="ln1815"> </a>
<a name="ln1816">  /* RIPd manages only IPv4. */</a>
<a name="ln1817">  memset (&amp;from, 0, sizeof (struct sockaddr_in));</a>
<a name="ln1818">  fromlen = sizeof (struct sockaddr_in);</a>
<a name="ln1819"> </a>
<a name="ln1820">  len = recvfrom (sock, (char *)&amp;rip_buf.buf, sizeof (rip_buf.buf), 0, </a>
<a name="ln1821">		  (struct sockaddr *) &amp;from, &amp;fromlen);</a>
<a name="ln1822">  if (len &lt; 0) </a>
<a name="ln1823">    {</a>
<a name="ln1824">      zlog_info (&quot;recvfrom failed: %s&quot;, safe_strerror (errno));</a>
<a name="ln1825">      return len;</a>
<a name="ln1826">    }</a>
<a name="ln1827"> </a>
<a name="ln1828">  /* Check is this packet comming from myself? */</a>
<a name="ln1829">  if (if_check_address (from.sin_addr)) </a>
<a name="ln1830">    {</a>
<a name="ln1831">      if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln1832">	zlog_debug (&quot;ignore packet comes from myself&quot;);</a>
<a name="ln1833">      return -1;</a>
<a name="ln1834">    }</a>
<a name="ln1835"> </a>
<a name="ln1836">  /* Which interface is this packet comes from. */</a>
<a name="ln1837">  ifp = if_lookup_address (from.sin_addr);</a>
<a name="ln1838">  </a>
<a name="ln1839">  /* RIP packet received */</a>
<a name="ln1840">  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1841">    zlog_debug (&quot;RECV packet from %s port %d on %s&quot;,</a>
<a name="ln1842">	       inet_ntoa (from.sin_addr), ntohs (from.sin_port),</a>
<a name="ln1843">	       ifp ? ifp-&gt;name : &quot;unknown&quot;);</a>
<a name="ln1844"> </a>
<a name="ln1845">  /* If this packet come from unknown interface, ignore it. */</a>
<a name="ln1846">  if (ifp == NULL)</a>
<a name="ln1847">    {</a>
<a name="ln1848">      zlog_info (&quot;rip_read: cannot find interface for packet from %s port %d&quot;,</a>
<a name="ln1849">		 inet_ntoa(from.sin_addr), ntohs (from.sin_port));</a>
<a name="ln1850">      return -1;</a>
<a name="ln1851">    }</a>
<a name="ln1852">  </a>
<a name="ln1853">  ifc = connected_lookup_address (ifp, from.sin_addr);</a>
<a name="ln1854">  </a>
<a name="ln1855">  if (ifc == NULL)</a>
<a name="ln1856">    {</a>
<a name="ln1857">      zlog_info (&quot;rip_read: cannot find connected address for packet from %s &quot;</a>
<a name="ln1858">		 &quot;port %d on interface %s&quot;,</a>
<a name="ln1859">		 inet_ntoa(from.sin_addr), ntohs (from.sin_port), ifp-&gt;name);</a>
<a name="ln1860">      return -1;</a>
<a name="ln1861">    }</a>
<a name="ln1862"> </a>
<a name="ln1863">  /* Packet length check. */</a>
<a name="ln1864">  if (len &lt; RIP_PACKET_MINSIZ)</a>
<a name="ln1865">    {</a>
<a name="ln1866">      zlog_warn (&quot;packet size %d is smaller than minimum size %d&quot;,</a>
<a name="ln1867">		 len, RIP_PACKET_MINSIZ);</a>
<a name="ln1868">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln1869">      return len;</a>
<a name="ln1870">    }</a>
<a name="ln1871">  if (len &gt; RIP_PACKET_MAXSIZ)</a>
<a name="ln1872">    {</a>
<a name="ln1873">      zlog_warn (&quot;packet size %d is larger than max size %d&quot;,</a>
<a name="ln1874">		 len, RIP_PACKET_MAXSIZ);</a>
<a name="ln1875">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln1876">      return len;</a>
<a name="ln1877">    }</a>
<a name="ln1878"> </a>
<a name="ln1879">  /* Packet alignment check. */</a>
<a name="ln1880">  if ((len - RIP_PACKET_MINSIZ) % 20)</a>
<a name="ln1881">    {</a>
<a name="ln1882">      zlog_warn (&quot;packet size %d is wrong for RIP packet alignment&quot;, len);</a>
<a name="ln1883">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln1884">      return len;</a>
<a name="ln1885">    }</a>
<a name="ln1886"> </a>
<a name="ln1887">  /* Set RTE number. */</a>
<a name="ln1888">  rtenum = ((len - RIP_PACKET_MINSIZ) / 20);</a>
<a name="ln1889"> </a>
<a name="ln1890">  /* For easy to handle. */</a>
<a name="ln1891">  packet = &amp;rip_buf.rip_packet;</a>
<a name="ln1892"> </a>
<a name="ln1893">  /* RIP version check. */</a>
<a name="ln1894">  if (packet-&gt;version == 0)</a>
<a name="ln1895">    {</a>
<a name="ln1896">      zlog_info (&quot;version 0 with command %d received.&quot;, packet-&gt;command);</a>
<a name="ln1897">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln1898">      return -1;</a>
<a name="ln1899">    }</a>
<a name="ln1900"> </a>
<a name="ln1901">  /* Dump RIP packet. */</a>
<a name="ln1902">  if (IS_RIP_DEBUG_RECV)</a>
<a name="ln1903">    rip_packet_dump (packet, len, &quot;RECV&quot;);</a>
<a name="ln1904"> </a>
<a name="ln1905">  /* RIP version adjust.  This code should rethink now.  RFC1058 says</a>
<a name="ln1906">     that &quot;Version 1 implementations are to ignore this extra data and</a>
<a name="ln1907">     process only the fields specified in this document.&quot;. So RIPv3</a>
<a name="ln1908">     packet should be treated as RIPv1 ignoring must be zero field. */</a>
<a name="ln1909">  if (packet-&gt;version &gt; RIPv2)</a>
<a name="ln1910">    packet-&gt;version = RIPv2;</a>
<a name="ln1911"> </a>
<a name="ln1912">  /* Is RIP running or is this RIP neighbor ?*/</a>
<a name="ln1913">  ri = ifp-&gt;info;</a>
<a name="ln1914">  if (! ri-&gt;running &amp;&amp; ! rip_neighbor_lookup (&amp;from))</a>
<a name="ln1915">    {</a>
<a name="ln1916">      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1917">	zlog_debug (&quot;RIP is not enabled on interface %s.&quot;, ifp-&gt;name);</a>
<a name="ln1918">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln1919">      return -1;</a>
<a name="ln1920">    }</a>
<a name="ln1921"> </a>
<a name="ln1922">  /* RIP Version check. RFC2453, 4.6 and 5.1 */</a>
<a name="ln1923">  vrecv = ((ri-&gt;ri_receive == RI_RIP_UNSPEC) ?</a>
<a name="ln1924">           rip-&gt;version_recv : ri-&gt;ri_receive);</a>
<a name="ln1925">  if ((packet-&gt;version == RIPv1) &amp;&amp; !(vrecv &amp; RIPv1))</a>
<a name="ln1926">    {</a>
<a name="ln1927">      if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln1928">        zlog_debug (&quot;  packet's v%d doesn't fit to if version spec&quot;, </a>
<a name="ln1929">                   packet-&gt;version);</a>
<a name="ln1930">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln1931">      return -1;</a>
<a name="ln1932">    }</a>
<a name="ln1933">  if ((packet-&gt;version == RIPv2) &amp;&amp; !(vrecv &amp; RIPv2))</a>
<a name="ln1934">    {</a>
<a name="ln1935">      if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln1936">        zlog_debug (&quot;  packet's v%d doesn't fit to if version spec&quot;, </a>
<a name="ln1937">                   packet-&gt;version);</a>
<a name="ln1938">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln1939">      return -1;</a>
<a name="ln1940">    }</a>
<a name="ln1941">  </a>
<a name="ln1942">  /* RFC2453 5.2 If the router is not configured to authenticate RIP-2</a>
<a name="ln1943">     messages, then RIP-1 and unauthenticated RIP-2 messages will be</a>
<a name="ln1944">     accepted; authenticated RIP-2 messages shall be discarded.  */</a>
<a name="ln1945">  if ((ri-&gt;auth_type == RIP_NO_AUTH) </a>
<a name="ln1946">      &amp;&amp; rtenum </a>
<a name="ln1947">      &amp;&amp; (packet-&gt;version == RIPv2) </a>
<a name="ln1948">      &amp;&amp; (packet-&gt;rte-&gt;family == htons(RIP_FAMILY_AUTH)))</a>
<a name="ln1949">    {</a>
<a name="ln1950">      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln1951">	zlog_debug (&quot;packet RIPv%d is dropped because authentication disabled&quot;, </a>
<a name="ln1952">		   packet-&gt;version);</a>
<a name="ln1953">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln1954">      return -1;</a>
<a name="ln1955">    }</a>
<a name="ln1956">  </a>
<a name="ln1957">  /* RFC:</a>
<a name="ln1958">     If the router is configured to authenticate RIP-2 messages, then</a>
<a name="ln1959">     RIP-1 messages and RIP-2 messages which pass authentication</a>
<a name="ln1960">     testing shall be accepted; unauthenticated and failed</a>
<a name="ln1961">     authentication RIP-2 messages shall be discarded.  For maximum</a>
<a name="ln1962">     security, RIP-1 messages should be ignored when authentication is</a>
<a name="ln1963">     in use (see section 4.1); otherwise, the routing information from</a>
<a name="ln1964">     authenticated messages will be propagated by RIP-1 routers in an</a>
<a name="ln1965">     unauthenticated manner. </a>
<a name="ln1966">  */</a>
<a name="ln1967">  /* We make an exception for RIPv1 REQUEST packets, to which we'll</a>
<a name="ln1968">   * always reply regardless of authentication settings, because:</a>
<a name="ln1969">   *</a>
<a name="ln1970">   * - if there other authorised routers on-link, the REQUESTor can</a>
<a name="ln1971">   *   passively obtain the routing updates anyway</a>
<a name="ln1972">   * - if there are no other authorised routers on-link, RIP can</a>
<a name="ln1973">   *   easily be disabled for the link to prevent giving out information</a>
<a name="ln1974">   *   on state of this routers RIP routing table..</a>
<a name="ln1975">   *</a>
<a name="ln1976">   * I.e. if RIPv1 has any place anymore these days, it's as a very</a>
<a name="ln1977">   * simple way to distribute routing information (e.g. to embedded</a>
<a name="ln1978">   * hosts / appliances) and the ability to give out RIPv1</a>
<a name="ln1979">   * routing-information freely, while still requiring RIPv2</a>
<a name="ln1980">   * authentication for any RESPONSEs might be vaguely useful.</a>
<a name="ln1981">   */</a>
<a name="ln1982">  if (ri-&gt;auth_type != RIP_NO_AUTH </a>
<a name="ln1983">      &amp;&amp; packet-&gt;version == RIPv1)</a>
<a name="ln1984">    {</a>
<a name="ln1985">      /* Discard RIPv1 messages other than REQUESTs */</a>
<a name="ln1986">      if (packet-&gt;command != RIP_REQUEST)</a>
<a name="ln1987">        {</a>
<a name="ln1988">          if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln1989">            zlog_debug (&quot;RIPv1&quot; &quot; dropped because authentication enabled&quot;);</a>
<a name="ln1990">          rip_peer_bad_packet (&amp;from);</a>
<a name="ln1991">          return -1;</a>
<a name="ln1992">        }</a>
<a name="ln1993">    }</a>
<a name="ln1994">  else if (ri-&gt;auth_type != RIP_NO_AUTH)</a>
<a name="ln1995">    {</a>
<a name="ln1996">      const char *auth_desc;</a>
<a name="ln1997">      </a>
<a name="ln1998">      if (rtenum == 0)</a>
<a name="ln1999">        {</a>
<a name="ln2000">          /* There definitely is no authentication in the packet. */</a>
<a name="ln2001">          if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln2002">            zlog_debug (&quot;RIPv2 authentication failed: no auth RTE in packet&quot;);</a>
<a name="ln2003">          rip_peer_bad_packet (&amp;from);</a>
<a name="ln2004">          return -1;</a>
<a name="ln2005">        }</a>
<a name="ln2006">      </a>
<a name="ln2007">      /* First RTE must be an Authentication Family RTE */</a>
<a name="ln2008">      if (packet-&gt;rte-&gt;family != htons(RIP_FAMILY_AUTH))</a>
<a name="ln2009">        {</a>
<a name="ln2010">          if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln2011">            zlog_debug (&quot;RIPv2&quot; &quot; dropped because authentication enabled&quot;);</a>
<a name="ln2012">	  rip_peer_bad_packet (&amp;from);</a>
<a name="ln2013">	  return -1;</a>
<a name="ln2014">        }</a>
<a name="ln2015">      </a>
<a name="ln2016">      /* Check RIPv2 authentication. */</a>
<a name="ln2017">      switch (ntohs(packet-&gt;rte-&gt;tag))</a>
<a name="ln2018">        {</a>
<a name="ln2019">          case RIP_AUTH_SIMPLE_PASSWORD:</a>
<a name="ln2020">            auth_desc = &quot;simple&quot;;</a>
<a name="ln2021">            ret = rip_auth_simple_password (packet-&gt;rte, &amp;from, ifp);</a>
<a name="ln2022">            break;</a>
<a name="ln2023">          </a>
<a name="ln2024">          case RIP_AUTH_MD5:</a>
<a name="ln2025">            auth_desc = &quot;MD5&quot;;</a>
<a name="ln2026">            ret = rip_auth_md5 (packet, &amp;from, len, ifp);</a>
<a name="ln2027">            /* Reset RIP packet length to trim MD5 data. */</a>
<a name="ln2028">            len = ret;</a>
<a name="ln2029">            break;</a>
<a name="ln2030">          </a>
<a name="ln2031">          default:</a>
<a name="ln2032">            ret = 0;</a>
<a name="ln2033">            auth_desc = &quot;unknown type&quot;;</a>
<a name="ln2034">            if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln2035">              zlog_debug (&quot;RIPv2 Unknown authentication type %d&quot;,</a>
<a name="ln2036">                          ntohs (packet-&gt;rte-&gt;tag));</a>
<a name="ln2037">        }</a>
<a name="ln2038">      </a>
<a name="ln2039">      if (ret)</a>
<a name="ln2040">        {</a>
<a name="ln2041">          if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln2042">            zlog_debug (&quot;RIPv2 %s authentication success&quot;, auth_desc);</a>
<a name="ln2043">        }</a>
<a name="ln2044">      else</a>
<a name="ln2045">        {</a>
<a name="ln2046">          if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln2047">            zlog_debug (&quot;RIPv2 %s authentication failure&quot;, auth_desc);</a>
<a name="ln2048">          rip_peer_bad_packet (&amp;from);</a>
<a name="ln2049">          return -1;</a>
<a name="ln2050">        }</a>
<a name="ln2051">    }</a>
<a name="ln2052">  </a>
<a name="ln2053">  /* Process each command. */</a>
<a name="ln2054">  switch (packet-&gt;command)</a>
<a name="ln2055">    {</a>
<a name="ln2056">    case RIP_RESPONSE:</a>
<a name="ln2057">      rip_response_process (packet, len, &amp;from, ifc);</a>
<a name="ln2058">      break;</a>
<a name="ln2059">    case RIP_REQUEST:</a>
<a name="ln2060">    case RIP_POLL:</a>
<a name="ln2061">      rip_request_process (packet, len, &amp;from, ifc);</a>
<a name="ln2062">      break;</a>
<a name="ln2063">    case RIP_TRACEON:</a>
<a name="ln2064">    case RIP_TRACEOFF:</a>
<a name="ln2065">      zlog_info (&quot;Obsolete command %s received, please sent it to routed&quot;, </a>
<a name="ln2066">		 lookup (rip_msg, packet-&gt;command));</a>
<a name="ln2067">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln2068">      break;</a>
<a name="ln2069">    case RIP_POLL_ENTRY:</a>
<a name="ln2070">      zlog_info (&quot;Obsolete command %s received&quot;, </a>
<a name="ln2071">		 lookup (rip_msg, packet-&gt;command));</a>
<a name="ln2072">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln2073">      break;</a>
<a name="ln2074">    default:</a>
<a name="ln2075">      zlog_info (&quot;Unknown RIP command %d received&quot;, packet-&gt;command);</a>
<a name="ln2076">      rip_peer_bad_packet (&amp;from);</a>
<a name="ln2077">      break;</a>
<a name="ln2078">    }</a>
<a name="ln2079"> </a>
<a name="ln2080">  return len;</a>
<a name="ln2081">}</a>
<a name="ln2082"> </a>
<a name="ln2083">/* Write routing table entry to the stream and return next index of</a>
<a name="ln2084">   the routing table entry in the stream. */</a>
<a name="ln2085">static int</a>
<a name="ln2086">rip_write_rte (int num, struct stream *s, struct prefix_ipv4 *p,</a>
<a name="ln2087">               u_char version, struct rip_info *rinfo)</a>
<a name="ln2088">{</a>
<a name="ln2089">  struct in_addr mask;</a>
<a name="ln2090"> </a>
<a name="ln2091">  /* Write routing table entry. */</a>
<a name="ln2092">  if (version == RIPv1)</a>
<a name="ln2093">    {</a>
<a name="ln2094">      stream_putw (s, AF_INET);</a>
<a name="ln2095">      stream_putw (s, 0);</a>
<a name="ln2096">      stream_put_ipv4 (s, p-&gt;prefix.s_addr);</a>
<a name="ln2097">      stream_put_ipv4 (s, 0);</a>
<a name="ln2098">      stream_put_ipv4 (s, 0);</a>
<a name="ln2099">      stream_putl (s, rinfo-&gt;metric_out);</a>
<a name="ln2100">    }</a>
<a name="ln2101">  else</a>
<a name="ln2102">    {</a>
<a name="ln2103">      masklen2ip (p-&gt;prefixlen, &amp;mask);</a>
<a name="ln2104"> </a>
<a name="ln2105">      stream_putw (s, AF_INET);</a>
<a name="ln2106">      stream_putw (s, rinfo-&gt;tag_out);</a>
<a name="ln2107">      stream_put_ipv4 (s, p-&gt;prefix.s_addr);</a>
<a name="ln2108">      stream_put_ipv4 (s, mask.s_addr);</a>
<a name="ln2109">      stream_put_ipv4 (s, rinfo-&gt;nexthop_out.s_addr);</a>
<a name="ln2110">      stream_putl (s, rinfo-&gt;metric_out);</a>
<a name="ln2111">    }</a>
<a name="ln2112"> </a>
<a name="ln2113">  return ++num;</a>
<a name="ln2114">}</a>
<a name="ln2115"> </a>
<a name="ln2116">/* Send update to the ifp or spcified neighbor. */</a>
<a name="ln2117">void</a>
<a name="ln2118">rip_output_process (struct connected *ifc, struct sockaddr_in *to, </a>
<a name="ln2119">                    int route_type, u_char version)</a>
<a name="ln2120">{</a>
<a name="ln2121">  int ret;</a>
<a name="ln2122">  struct stream *s;</a>
<a name="ln2123">  struct route_node *rp;</a>
<a name="ln2124">  struct rip_info *rinfo;</a>
<a name="ln2125">  struct rip_interface *ri;</a>
<a name="ln2126">  struct prefix_ipv4 *p;</a>
<a name="ln2127">  struct prefix_ipv4 classfull;</a>
<a name="ln2128">  struct prefix_ipv4 ifaddrclass;</a>
<a name="ln2129">  struct key *key = NULL;</a>
<a name="ln2130">  /* this might need to made dynamic if RIP ever supported auth methods</a>
<a name="ln2131">     with larger key string sizes */</a>
<a name="ln2132">  char auth_str[RIP_AUTH_SIMPLE_SIZE];</a>
<a name="ln2133">  size_t doff = 0; /* offset of digest offset field */</a>
<a name="ln2134">  int num = 0;</a>
<a name="ln2135">  int rtemax;</a>
<a name="ln2136">  int subnetted = 0;</a>
<a name="ln2137">  struct list *list = NULL;</a>
<a name="ln2138">  struct listnode *listnode = NULL;</a>
<a name="ln2139"> </a>
<a name="ln2140">  /* Logging output event. */</a>
<a name="ln2141">  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln2142">    {</a>
<a name="ln2143">      if (to)</a>
<a name="ln2144">	zlog_debug (&quot;update routes to neighbor %s&quot;, inet_ntoa (to-&gt;sin_addr));</a>
<a name="ln2145">      else</a>
<a name="ln2146">	zlog_debug (&quot;update routes on interface %s ifindex %d&quot;,</a>
<a name="ln2147">		   ifc-&gt;ifp-&gt;name, ifc-&gt;ifp-&gt;ifindex);</a>
<a name="ln2148">    }</a>
<a name="ln2149"> </a>
<a name="ln2150">  /* Set output stream. */</a>
<a name="ln2151">  s = rip-&gt;obuf;</a>
<a name="ln2152"> </a>
<a name="ln2153">  /* Reset stream and RTE counter. */</a>
<a name="ln2154">  stream_reset (s);</a>
<a name="ln2155">  rtemax = RIP_MAX_RTE;</a>
<a name="ln2156"> </a>
<a name="ln2157">  /* Get RIP interface. */</a>
<a name="ln2158">  ri = ifc-&gt;ifp-&gt;info;</a>
<a name="ln2159">    </a>
<a name="ln2160">  /* If output interface is in simple password authentication mode, we</a>
<a name="ln2161">     need space for authentication data.  */</a>
<a name="ln2162">  if (ri-&gt;auth_type == RIP_AUTH_SIMPLE_PASSWORD)</a>
<a name="ln2163">    rtemax -= 1;</a>
<a name="ln2164"> </a>
<a name="ln2165">  /* If output interface is in MD5 authentication mode, we need space</a>
<a name="ln2166">     for authentication header and data. */</a>
<a name="ln2167">  if (ri-&gt;auth_type == RIP_AUTH_MD5)</a>
<a name="ln2168">    rtemax -= 2;</a>
<a name="ln2169"> </a>
<a name="ln2170">  /* If output interface is in simple password authentication mode</a>
<a name="ln2171">     and string or keychain is specified we need space for auth. data */</a>
<a name="ln2172">  if (ri-&gt;auth_type != RIP_NO_AUTH)</a>
<a name="ln2173">    {</a>
<a name="ln2174">      if (ri-&gt;key_chain)</a>
<a name="ln2175">       {</a>
<a name="ln2176">         struct keychain *keychain;</a>
<a name="ln2177"> </a>
<a name="ln2178">         keychain = keychain_lookup (ri-&gt;key_chain);</a>
<a name="ln2179">         if (keychain)</a>
<a name="ln2180">           key = key_lookup_for_send (keychain);</a>
<a name="ln2181">       }</a>
<a name="ln2182">      /* to be passed to auth functions later */</a>
<a name="ln2183">      rip_auth_prepare_str_send (ri, key, auth_str, RIP_AUTH_SIMPLE_SIZE);</a>
<a name="ln2184">    }</a>
<a name="ln2185"> </a>
<a name="ln2186">  if (version == RIPv1)</a>
<a name="ln2187">    {</a>
<a name="ln2188">      memcpy (&amp;ifaddrclass, ifc-&gt;address, sizeof (struct prefix_ipv4));</a>
<a name="ln2189">      apply_classful_mask_ipv4 (&amp;ifaddrclass);</a>
<a name="ln2190">      subnetted = 0;</a>
<a name="ln2191">      if (ifc-&gt;address-&gt;prefixlen &gt; ifaddrclass.prefixlen)</a>
<a name="ln2192">        subnetted = 1;</a>
<a name="ln2193">    }</a>
<a name="ln2194"> </a>
<a name="ln2195">  for (rp = route_top (rip-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln2196">    if ((list = rp-&gt;info) != NULL &amp;&amp; listcount (list) != 0)</a>
<a name="ln2197">      {</a>
<a name="ln2198">        rinfo = listgetdata (listhead (list));</a>
<a name="ln2199">	/* For RIPv1, if we are subnetted, output subnets in our network    */</a>
<a name="ln2200">	/* that have the same mask as the output &quot;interface&quot;. For other     */</a>
<a name="ln2201">	/* networks, only the classfull version is output.                  */</a>
<a name="ln2202">	</a>
<a name="ln2203">	if (version == RIPv1)</a>
<a name="ln2204">	  {</a>
<a name="ln2205">	    p = (struct prefix_ipv4 *) &amp;rp-&gt;p;</a>
<a name="ln2206"> </a>
<a name="ln2207">	    if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln2208">	      zlog_debug(&quot;RIPv1 mask check, %s/%d considered for output&quot;,</a>
<a name="ln2209">			inet_ntoa (rp-&gt;p.u.prefix4), rp-&gt;p.prefixlen);</a>
<a name="ln2210"> </a>
<a name="ln2211">	    if (subnetted &amp;&amp;</a>
<a name="ln2212">		prefix_match ((struct prefix *) &amp;ifaddrclass, &amp;rp-&gt;p))</a>
<a name="ln2213">	      {</a>
<a name="ln2214">		if ((ifc-&gt;address-&gt;prefixlen != rp-&gt;p.prefixlen) &amp;&amp;</a>
<a name="ln2215">		    (rp-&gt;p.prefixlen != 32))</a>
<a name="ln2216">		  continue;</a>
<a name="ln2217">	      }</a>
<a name="ln2218">	    else</a>
<a name="ln2219">	      {</a>
<a name="ln2220">		memcpy (&amp;classfull, &amp;rp-&gt;p, sizeof(struct prefix_ipv4));</a>
<a name="ln2221">		apply_classful_mask_ipv4(&amp;classfull);</a>
<a name="ln2222">		if (rp-&gt;p.u.prefix4.s_addr != 0 &amp;&amp;</a>
<a name="ln2223">		    classfull.prefixlen != rp-&gt;p.prefixlen)</a>
<a name="ln2224">		  continue;</a>
<a name="ln2225">	      }</a>
<a name="ln2226">	    if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln2227">	      zlog_debug(&quot;RIPv1 mask check, %s/%d made it through&quot;,</a>
<a name="ln2228">			inet_ntoa (rp-&gt;p.u.prefix4), rp-&gt;p.prefixlen);</a>
<a name="ln2229">	  }</a>
<a name="ln2230">	else </a>
<a name="ln2231">	  p = (struct prefix_ipv4 *) &amp;rp-&gt;p;</a>
<a name="ln2232"> </a>
<a name="ln2233">	/* Apply output filters. */</a>
<a name="ln2234">	ret = rip_filter (RIP_FILTER_OUT, p, ri);</a>
<a name="ln2235">	if (ret &lt; 0)</a>
<a name="ln2236">	  continue;</a>
<a name="ln2237"> </a>
<a name="ln2238">	/* Changed route only output. */</a>
<a name="ln2239">	if (route_type == rip_changed_route &amp;&amp;</a>
<a name="ln2240">	    (! (rinfo-&gt;flags &amp; RIP_RTF_CHANGED)))</a>
<a name="ln2241">	  continue;</a>
<a name="ln2242"> </a>
<a name="ln2243">	/* Split horizon. */</a>
<a name="ln2244">	/* if (split_horizon == rip_split_horizon) */</a>
<a name="ln2245">	if (ri-&gt;split_horizon == RIP_SPLIT_HORIZON)</a>
<a name="ln2246">	  {</a>
<a name="ln2247">	    /* </a>
<a name="ln2248">	     * We perform split horizon for RIP and connected route. </a>
<a name="ln2249">	     * For rip routes, we want to suppress the route if we would</a>
<a name="ln2250">             * end up sending the route back on the interface that we</a>
<a name="ln2251">             * learned it from, with a higher metric. For connected routes,</a>
<a name="ln2252">             * we suppress the route if the prefix is a subset of the</a>
<a name="ln2253">             * source address that we are going to use for the packet </a>
<a name="ln2254">             * (in order to handle the case when multiple subnets are</a>
<a name="ln2255">             * configured on the same interface).</a>
<a name="ln2256">             */</a>
<a name="ln2257">	    int suppress = 0;</a>
<a name="ln2258">	    struct rip_info *tmp_rinfo = NULL;</a>
<a name="ln2259"> </a>
<a name="ln2260">	    for (ALL_LIST_ELEMENTS_RO (list, listnode, tmp_rinfo))</a>
<a name="ln2261">	      if (tmp_rinfo-&gt;type == ZEBRA_ROUTE_RIP &amp;&amp;</a>
<a name="ln2262">	          tmp_rinfo-&gt;ifindex == ifc-&gt;ifp-&gt;ifindex)</a>
<a name="ln2263">	        {</a>
<a name="ln2264">	          suppress = 1;</a>
<a name="ln2265">	          break;</a>
<a name="ln2266">	        }</a>
<a name="ln2267"> </a>
<a name="ln2268">	    if (!suppress &amp;&amp; rinfo-&gt;type == ZEBRA_ROUTE_CONNECT &amp;&amp;</a>
<a name="ln2269">                 prefix_match((struct prefix *)p, ifc-&gt;address))</a>
<a name="ln2270">	      suppress = 1;</a>
<a name="ln2271"> </a>
<a name="ln2272">	    if (suppress)</a>
<a name="ln2273">	      continue;</a>
<a name="ln2274">	  }</a>
<a name="ln2275"> </a>
<a name="ln2276">	/* Preparation for route-map. */</a>
<a name="ln2277">	rinfo-&gt;metric_set = 0;</a>
<a name="ln2278">	rinfo-&gt;nexthop_out.s_addr = 0;</a>
<a name="ln2279">	rinfo-&gt;metric_out = rinfo-&gt;metric;</a>
<a name="ln2280">	rinfo-&gt;tag_out = rinfo-&gt;tag;</a>
<a name="ln2281">	rinfo-&gt;ifindex_out = ifc-&gt;ifp-&gt;ifindex;</a>
<a name="ln2282"> </a>
<a name="ln2283">	/* In order to avoid some local loops,</a>
<a name="ln2284">	 * if the RIP route has a nexthop via this interface, keep the nexthop,</a>
<a name="ln2285">	 * otherwise set it to 0. The nexthop should not be propagated</a>
<a name="ln2286">	 * beyond the local broadcast/multicast area in order</a>
<a name="ln2287">	 * to avoid an IGP multi-level recursive look-up.</a>
<a name="ln2288">	 * see (4.4)</a>
<a name="ln2289">	 */</a>
<a name="ln2290">	if (rinfo-&gt;ifindex == ifc-&gt;ifp-&gt;ifindex)</a>
<a name="ln2291">	  rinfo-&gt;nexthop_out = rinfo-&gt;nexthop;</a>
<a name="ln2292"> </a>
<a name="ln2293">	/* Interface route-map */</a>
<a name="ln2294">	if (ri-&gt;routemap[RIP_FILTER_OUT])</a>
<a name="ln2295">	  {</a>
<a name="ln2296">	    ret = route_map_apply (ri-&gt;routemap[RIP_FILTER_OUT], </a>
<a name="ln2297">				     (struct prefix *) p, RMAP_RIP, </a>
<a name="ln2298">				     rinfo);</a>
<a name="ln2299"> </a>
<a name="ln2300">	    if (ret == RMAP_DENYMATCH)</a>
<a name="ln2301">	      {</a>
<a name="ln2302">	        if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln2303">	          zlog_debug (&quot;RIP %s/%d is filtered by route-map out&quot;,</a>
<a name="ln2304">			     inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln2305">                continue;</a>
<a name="ln2306">	      }</a>
<a name="ln2307">	  }</a>
<a name="ln2308">           </a>
<a name="ln2309">	/* Apply redistribute route map - continue, if deny */</a>
<a name="ln2310">	if (rip-&gt;route_map[rinfo-&gt;type].name</a>
<a name="ln2311">	    &amp;&amp; rinfo-&gt;sub_type != RIP_ROUTE_INTERFACE)</a>
<a name="ln2312">	  {</a>
<a name="ln2313">	    ret = route_map_apply (rip-&gt;route_map[rinfo-&gt;type].map,</a>
<a name="ln2314">				   (struct prefix *)p, RMAP_RIP, rinfo);</a>
<a name="ln2315"> </a>
<a name="ln2316">	    if (ret == RMAP_DENYMATCH) </a>
<a name="ln2317">	      {</a>
<a name="ln2318">		if (IS_RIP_DEBUG_PACKET)</a>
<a name="ln2319">		  zlog_debug (&quot;%s/%d is filtered by route-map&quot;,</a>
<a name="ln2320">			     inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln2321">		continue;</a>
<a name="ln2322">	      }</a>
<a name="ln2323">	  }</a>
<a name="ln2324"> </a>
<a name="ln2325">	/* When route-map does not set metric. */</a>
<a name="ln2326">	if (! rinfo-&gt;metric_set)</a>
<a name="ln2327">	  {</a>
<a name="ln2328">	    /* If redistribute metric is set. */</a>
<a name="ln2329">	    if (rip-&gt;route_map[rinfo-&gt;type].metric_config</a>
<a name="ln2330">		&amp;&amp; rinfo-&gt;metric != RIP_METRIC_INFINITY)</a>
<a name="ln2331">	      {</a>
<a name="ln2332">		rinfo-&gt;metric_out = rip-&gt;route_map[rinfo-&gt;type].metric;</a>
<a name="ln2333">	      }</a>
<a name="ln2334">	    else</a>
<a name="ln2335">	      {</a>
<a name="ln2336">		/* If the route is not connected or localy generated</a>
<a name="ln2337">		   one, use default-metric value*/</a>
<a name="ln2338">		if (rinfo-&gt;type != ZEBRA_ROUTE_RIP </a>
<a name="ln2339">		    &amp;&amp; rinfo-&gt;type != ZEBRA_ROUTE_CONNECT</a>
<a name="ln2340">		    &amp;&amp; rinfo-&gt;metric != RIP_METRIC_INFINITY)</a>
<a name="ln2341">		  rinfo-&gt;metric_out = rip-&gt;default_metric;</a>
<a name="ln2342">	      }</a>
<a name="ln2343">	  }</a>
<a name="ln2344"> </a>
<a name="ln2345">	/* Apply offset-list */</a>
<a name="ln2346">	if (rinfo-&gt;metric != RIP_METRIC_INFINITY)</a>
<a name="ln2347">	  rip_offset_list_apply_out (p, ifc-&gt;ifp, &amp;rinfo-&gt;metric_out);</a>
<a name="ln2348"> </a>
<a name="ln2349">	if (rinfo-&gt;metric_out &gt; RIP_METRIC_INFINITY)</a>
<a name="ln2350">	  rinfo-&gt;metric_out = RIP_METRIC_INFINITY;</a>
<a name="ln2351"> </a>
<a name="ln2352">	/* Perform split-horizon with poisoned reverse </a>
<a name="ln2353">	 * for RIP and connected routes.</a>
<a name="ln2354">	 **/</a>
<a name="ln2355">	if (ri-&gt;split_horizon == RIP_SPLIT_HORIZON_POISONED_REVERSE) {</a>
<a name="ln2356">	    /* </a>
<a name="ln2357">	     * We perform split horizon for RIP and connected route. </a>
<a name="ln2358">	     * For rip routes, we want to suppress the route if we would</a>
<a name="ln2359">             * end up sending the route back on the interface that we</a>
<a name="ln2360">             * learned it from, with a higher metric. For connected routes,</a>
<a name="ln2361">             * we suppress the route if the prefix is a subset of the</a>
<a name="ln2362">             * source address that we are going to use for the packet </a>
<a name="ln2363">             * (in order to handle the case when multiple subnets are</a>
<a name="ln2364">             * configured on the same interface).</a>
<a name="ln2365">             */</a>
<a name="ln2366">	  struct rip_info *tmp_rinfo = NULL;</a>
<a name="ln2367"> </a>
<a name="ln2368">	  for (ALL_LIST_ELEMENTS_RO (list, listnode, tmp_rinfo))</a>
<a name="ln2369">            {</a>
<a name="ln2370">	      if (tmp_rinfo-&gt;type == ZEBRA_ROUTE_RIP  &amp;&amp;</a>
<a name="ln2371">	          tmp_rinfo-&gt;ifindex == ifc-&gt;ifp-&gt;ifindex)</a>
<a name="ln2372">	        rinfo-&gt;metric_out = RIP_METRIC_INFINITY;</a>
<a name="ln2373">	      if (tmp_rinfo-&gt;type == ZEBRA_ROUTE_CONNECT &amp;&amp;</a>
<a name="ln2374">                prefix_match((struct prefix *)p, ifc-&gt;address))</a>
<a name="ln2375">	        rinfo-&gt;metric_out = RIP_METRIC_INFINITY;</a>
<a name="ln2376">            }</a>
<a name="ln2377">	}</a>
<a name="ln2378">	</a>
<a name="ln2379">	/* Prepare preamble, auth headers, if needs be */</a>
<a name="ln2380">	if (num == 0)</a>
<a name="ln2381">	  {</a>
<a name="ln2382">	    stream_putc (s, RIP_RESPONSE);</a>
<a name="ln2383">	    stream_putc (s, version);</a>
<a name="ln2384">	    stream_putw (s, 0);</a>
<a name="ln2385">	    </a>
<a name="ln2386">	    /* auth header for !v1 &amp;&amp; !no_auth */</a>
<a name="ln2387">            if ( (ri-&gt;auth_type != RIP_NO_AUTH) &amp;&amp; (version != RIPv1) )</a>
<a name="ln2388">              doff = rip_auth_header_write (s, ri, key, auth_str, </a>
<a name="ln2389">                                              RIP_AUTH_SIMPLE_SIZE);</a>
<a name="ln2390">          }</a>
<a name="ln2391">        </a>
<a name="ln2392">	/* Write RTE to the stream. */</a>
<a name="ln2393">	num = rip_write_rte (num, s, p, version, rinfo);</a>
<a name="ln2394">	if (num == rtemax)</a>
<a name="ln2395">	  {</a>
<a name="ln2396">	    if (version == RIPv2 &amp;&amp; ri-&gt;auth_type == RIP_AUTH_MD5)</a>
<a name="ln2397">              rip_auth_md5_set (s, ri, doff, auth_str, RIP_AUTH_SIMPLE_SIZE);</a>
<a name="ln2398"> </a>
<a name="ln2399">	    ret = rip_send_packet (STREAM_DATA (s), stream_get_endp (s),</a>
<a name="ln2400">				   to, ifc);</a>
<a name="ln2401"> </a>
<a name="ln2402">	    if (ret &gt;= 0 &amp;&amp; IS_RIP_DEBUG_SEND)</a>
<a name="ln2403">	      rip_packet_dump ((struct rip_packet *)STREAM_DATA (s),</a>
<a name="ln2404">			       stream_get_endp(s), &quot;SEND&quot;);</a>
<a name="ln2405">	    num = 0;</a>
<a name="ln2406">	    stream_reset (s);</a>
<a name="ln2407">	  }</a>
<a name="ln2408">      }</a>
<a name="ln2409"> </a>
<a name="ln2410">  /* Flush unwritten RTE. */</a>
<a name="ln2411">  if (num != 0)</a>
<a name="ln2412">    {</a>
<a name="ln2413">      if (version == RIPv2 &amp;&amp; ri-&gt;auth_type == RIP_AUTH_MD5)</a>
<a name="ln2414">        rip_auth_md5_set (s, ri, doff, auth_str, RIP_AUTH_SIMPLE_SIZE);</a>
<a name="ln2415"> </a>
<a name="ln2416">      ret = rip_send_packet (STREAM_DATA (s), stream_get_endp (s), to, ifc);</a>
<a name="ln2417"> </a>
<a name="ln2418">      if (ret &gt;= 0 &amp;&amp; IS_RIP_DEBUG_SEND)</a>
<a name="ln2419">	rip_packet_dump ((struct rip_packet *)STREAM_DATA (s),</a>
<a name="ln2420">			 stream_get_endp (s), &quot;SEND&quot;);</a>
<a name="ln2421">      num = 0;</a>
<a name="ln2422">      stream_reset (s);</a>
<a name="ln2423">    }</a>
<a name="ln2424"> </a>
<a name="ln2425">  /* Statistics updates. */</a>
<a name="ln2426">  ri-&gt;sent_updates++;</a>
<a name="ln2427">}</a>
<a name="ln2428"> </a>
<a name="ln2429">/* Send RIP packet to the interface. */</a>
<a name="ln2430">static void</a>
<a name="ln2431">rip_update_interface (struct connected *ifc, u_char version, int route_type)</a>
<a name="ln2432">{</a>
<a name="ln2433">  struct sockaddr_in to;</a>
<a name="ln2434"> </a>
<a name="ln2435">  /* When RIP version is 2 and multicast enable interface. */</a>
<a name="ln2436">  if (version == RIPv2 &amp;&amp; if_is_multicast (ifc-&gt;ifp)) </a>
<a name="ln2437">    {</a>
<a name="ln2438">      if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln2439">	zlog_debug (&quot;multicast announce on %s &quot;, ifc-&gt;ifp-&gt;name);</a>
<a name="ln2440"> </a>
<a name="ln2441">      rip_output_process (ifc, NULL, route_type, version);</a>
<a name="ln2442">      return;</a>
<a name="ln2443">    }</a>
<a name="ln2444">  </a>
<a name="ln2445">  /* If we can't send multicast packet, send it with unicast. */</a>
<a name="ln2446">  if (if_is_broadcast (ifc-&gt;ifp) || if_is_pointopoint (ifc-&gt;ifp))</a>
<a name="ln2447">    {</a>
<a name="ln2448">      if (ifc-&gt;address-&gt;family == AF_INET)</a>
<a name="ln2449">        {</a>
<a name="ln2450">          /* Destination address and port setting. */</a>
<a name="ln2451">          memset (&amp;to, 0, sizeof (struct sockaddr_in));</a>
<a name="ln2452">          if (ifc-&gt;destination)</a>
<a name="ln2453">            /* use specified broadcast or peer destination addr */</a>
<a name="ln2454">            to.sin_addr = ifc-&gt;destination-&gt;u.prefix4;</a>
<a name="ln2455">          else if (ifc-&gt;address-&gt;prefixlen &lt; IPV4_MAX_PREFIXLEN)</a>
<a name="ln2456">            /* calculate the appropriate broadcast address */</a>
<a name="ln2457">            to.sin_addr.s_addr =</a>
<a name="ln2458">              ipv4_broadcast_addr(ifc-&gt;address-&gt;u.prefix4.s_addr,</a>
<a name="ln2459">                                  ifc-&gt;address-&gt;prefixlen);</a>
<a name="ln2460">	  else</a>
<a name="ln2461">	    /* do not know where to send the packet */</a>
<a name="ln2462">	    return;</a>
<a name="ln2463">          to.sin_port = htons (RIP_PORT_DEFAULT);</a>
<a name="ln2464"> </a>
<a name="ln2465">          if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln2466">            zlog_debug(&quot;%s announce to %s on %s&quot;,</a>
<a name="ln2467">		       CONNECTED_PEER(ifc) ? &quot;unicast&quot; : &quot;broadcast&quot;,</a>
<a name="ln2468">		       inet_ntoa (to.sin_addr), ifc-&gt;ifp-&gt;name);</a>
<a name="ln2469"> </a>
<a name="ln2470">          rip_output_process (ifc, &amp;to, route_type, version);</a>
<a name="ln2471">        }</a>
<a name="ln2472">    }</a>
<a name="ln2473">}</a>
<a name="ln2474"> </a>
<a name="ln2475">/* Update send to all interface and neighbor. */</a>
<a name="ln2476">static void</a>
<a name="ln2477">rip_update_process (int route_type)</a>
<a name="ln2478">{</a>
<a name="ln2479">  struct listnode *node;</a>
<a name="ln2480">  struct listnode *ifnode, *ifnnode;</a>
<a name="ln2481">  struct connected *connected;</a>
<a name="ln2482">  struct interface *ifp;</a>
<a name="ln2483">  struct rip_interface *ri;</a>
<a name="ln2484">  struct route_node *rp;</a>
<a name="ln2485">  struct sockaddr_in to;</a>
<a name="ln2486">  struct prefix_ipv4 *p;</a>
<a name="ln2487"> </a>
<a name="ln2488">  /* Send RIP update to each interface. */</a>
<a name="ln2489">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln2490">    {</a>
<a name="ln2491">      if (if_is_loopback (ifp))</a>
<a name="ln2492">	continue;</a>
<a name="ln2493"> </a>
<a name="ln2494">      if (! if_is_operative (ifp))</a>
<a name="ln2495">	continue;</a>
<a name="ln2496"> </a>
<a name="ln2497">      /* Fetch RIP interface information. */</a>
<a name="ln2498">      ri = ifp-&gt;info;</a>
<a name="ln2499"> </a>
<a name="ln2500">      /* When passive interface is specified, suppress announce to the</a>
<a name="ln2501">         interface. */</a>
<a name="ln2502">      if (ri-&gt;passive)</a>
<a name="ln2503">	continue;</a>
<a name="ln2504"> </a>
<a name="ln2505">      if (ri-&gt;running)</a>
<a name="ln2506">	{</a>
<a name="ln2507">	  /* </a>
<a name="ln2508">	   * If there is no version configuration in the interface,</a>
<a name="ln2509">	   * use rip's version setting. </a>
<a name="ln2510">	   */</a>
<a name="ln2511">	  int vsend = ((ri-&gt;ri_send == RI_RIP_UNSPEC) ?</a>
<a name="ln2512">		       rip-&gt;version_send : ri-&gt;ri_send);</a>
<a name="ln2513"> </a>
<a name="ln2514">	  if (IS_RIP_DEBUG_EVENT) </a>
<a name="ln2515">	    zlog_debug(&quot;SEND UPDATE to %s ifindex %d&quot;,</a>
<a name="ln2516">		       ifp-&gt;name, ifp-&gt;ifindex);</a>
<a name="ln2517"> </a>
<a name="ln2518">          /* send update on each connected network */</a>
<a name="ln2519">	  for (ALL_LIST_ELEMENTS (ifp-&gt;connected, ifnode, ifnnode, connected))</a>
<a name="ln2520">	    {</a>
<a name="ln2521">	      if (connected-&gt;address-&gt;family == AF_INET)</a>
<a name="ln2522">	        {</a>
<a name="ln2523">		  if (vsend &amp; RIPv1)</a>
<a name="ln2524">		    rip_update_interface (connected, RIPv1, route_type);</a>
<a name="ln2525">		  if (vsend &amp; RIPv2) </a>
<a name="ln2526">		    rip_update_interface (connected, RIPv2, route_type);</a>
<a name="ln2527">		}</a>
<a name="ln2528">	    }</a>
<a name="ln2529">	}</a>
<a name="ln2530">    }</a>
<a name="ln2531"> </a>
<a name="ln2532">  /* RIP send updates to each neighbor. */</a>
<a name="ln2533">  for (rp = route_top (rip-&gt;neighbor); rp; rp = route_next (rp))</a>
<a name="ln2534">    if (rp-&gt;info != NULL)</a>
<a name="ln2535">      {</a>
<a name="ln2536">	p = (struct prefix_ipv4 *) &amp;rp-&gt;p;</a>
<a name="ln2537"> </a>
<a name="ln2538">	ifp = if_lookup_address (p-&gt;prefix);</a>
<a name="ln2539">	if (! ifp)</a>
<a name="ln2540">	  {</a>
<a name="ln2541">	    zlog_warn (&quot;Neighbor %s doesn't have connected interface!&quot;,</a>
<a name="ln2542">		       inet_ntoa (p-&gt;prefix));</a>
<a name="ln2543">	    continue;</a>
<a name="ln2544">	  }</a>
<a name="ln2545">        </a>
<a name="ln2546">        if ( (connected = connected_lookup_address (ifp, p-&gt;prefix)) == NULL)</a>
<a name="ln2547">          {</a>
<a name="ln2548">            zlog_warn (&quot;Neighbor %s doesn't have connected network&quot;,</a>
<a name="ln2549">                       inet_ntoa (p-&gt;prefix));</a>
<a name="ln2550">            continue;</a>
<a name="ln2551">          }</a>
<a name="ln2552">        </a>
<a name="ln2553">	/* Set destination address and port */</a>
<a name="ln2554">	memset (&amp;to, 0, sizeof (struct sockaddr_in));</a>
<a name="ln2555">	to.sin_addr = p-&gt;prefix;</a>
<a name="ln2556">	to.sin_port = htons (RIP_PORT_DEFAULT);</a>
<a name="ln2557"> </a>
<a name="ln2558">	/* RIP version is rip's configuration. */</a>
<a name="ln2559">	rip_output_process (connected, &amp;to, route_type, rip-&gt;version_send);</a>
<a name="ln2560">      }</a>
<a name="ln2561">}</a>
<a name="ln2562"> </a>
<a name="ln2563">/* RIP's periodical timer. */</a>
<a name="ln2564">static int</a>
<a name="ln2565">rip_update (struct thread *t)</a>
<a name="ln2566">{</a>
<a name="ln2567">  /* Clear timer pointer. */</a>
<a name="ln2568">  rip-&gt;t_update = NULL;</a>
<a name="ln2569"> </a>
<a name="ln2570">  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln2571">    zlog_debug (&quot;update timer fire!&quot;);</a>
<a name="ln2572"> </a>
<a name="ln2573">  /* Process update output. */</a>
<a name="ln2574">  rip_update_process (rip_all_route);</a>
<a name="ln2575"> </a>
<a name="ln2576">  /* Triggered updates may be suppressed if a regular update is due by</a>
<a name="ln2577">     the time the triggered update would be sent. */</a>
<a name="ln2578">  if (rip-&gt;t_triggered_interval)</a>
<a name="ln2579">    {</a>
<a name="ln2580">      thread_cancel (rip-&gt;t_triggered_interval);</a>
<a name="ln2581">      rip-&gt;t_triggered_interval = NULL;</a>
<a name="ln2582">    }</a>
<a name="ln2583">  rip-&gt;trigger = 0;</a>
<a name="ln2584"> </a>
<a name="ln2585">  /* Register myself. */</a>
<a name="ln2586">  rip_event (RIP_UPDATE_EVENT, 0);</a>
<a name="ln2587"> </a>
<a name="ln2588">  return 0;</a>
<a name="ln2589">}</a>
<a name="ln2590"> </a>
<a name="ln2591">/* Walk down the RIP routing table then clear changed flag. */</a>
<a name="ln2592">static void</a>
<a name="ln2593">rip_clear_changed_flag (void)</a>
<a name="ln2594">{</a>
<a name="ln2595">  struct route_node *rp;</a>
<a name="ln2596">  struct rip_info *rinfo = NULL;</a>
<a name="ln2597">  struct list *list = NULL;</a>
<a name="ln2598">  struct listnode *listnode = NULL;</a>
<a name="ln2599"> </a>
<a name="ln2600">  for (rp = route_top (rip-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln2601">    if ((list = rp-&gt;info) != NULL)</a>
<a name="ln2602">      for (ALL_LIST_ELEMENTS_RO (list, listnode, rinfo))</a>
<a name="ln2603">        {</a>
<a name="ln2604">          UNSET_FLAG (rinfo-&gt;flags, RIP_RTF_CHANGED);</a>
<a name="ln2605">          /* This flag can be set only on the first entry. */</a>
<a name="ln2606">          break;</a>
<a name="ln2607">        }</a>
<a name="ln2608">}</a>
<a name="ln2609"> </a>
<a name="ln2610">/* Triggered update interval timer. */</a>
<a name="ln2611">static int</a>
<a name="ln2612">rip_triggered_interval (struct thread *t)</a>
<a name="ln2613">{</a>
<a name="ln2614">  int rip_triggered_update (struct thread *);</a>
<a name="ln2615"> </a>
<a name="ln2616">  rip-&gt;t_triggered_interval = NULL;</a>
<a name="ln2617"> </a>
<a name="ln2618">  if (rip-&gt;trigger)</a>
<a name="ln2619">    {</a>
<a name="ln2620">      rip-&gt;trigger = 0;</a>
<a name="ln2621">      rip_triggered_update (t);</a>
<a name="ln2622">    }</a>
<a name="ln2623">  return 0;</a>
<a name="ln2624">}     </a>
<a name="ln2625"> </a>
<a name="ln2626">/* Execute triggered update. */</a>
<a name="ln2627">static int</a>
<a name="ln2628">rip_triggered_update (struct thread *t)</a>
<a name="ln2629">{</a>
<a name="ln2630">  int interval;</a>
<a name="ln2631"> </a>
<a name="ln2632">  /* Clear thred pointer. */</a>
<a name="ln2633">  rip-&gt;t_triggered_update = NULL;</a>
<a name="ln2634"> </a>
<a name="ln2635">  /* Cancel interval timer. */</a>
<a name="ln2636">  if (rip-&gt;t_triggered_interval)</a>
<a name="ln2637">    {</a>
<a name="ln2638">      thread_cancel (rip-&gt;t_triggered_interval);</a>
<a name="ln2639">      rip-&gt;t_triggered_interval = NULL;</a>
<a name="ln2640">    }</a>
<a name="ln2641">  rip-&gt;trigger = 0;</a>
<a name="ln2642"> </a>
<a name="ln2643">  /* Logging triggered update. */</a>
<a name="ln2644">  if (IS_RIP_DEBUG_EVENT)</a>
<a name="ln2645">    zlog_debug (&quot;triggered update!&quot;);</a>
<a name="ln2646"> </a>
<a name="ln2647">  /* Split Horizon processing is done when generating triggered</a>
<a name="ln2648">     updates as well as normal updates (see section 2.6). */</a>
<a name="ln2649">  rip_update_process (rip_changed_route);</a>
<a name="ln2650"> </a>
<a name="ln2651">  /* Once all of the triggered updates have been generated, the route</a>
<a name="ln2652">     change flags should be cleared. */</a>
<a name="ln2653">  rip_clear_changed_flag ();</a>
<a name="ln2654"> </a>
<a name="ln2655">  /* After a triggered update is sent, a timer should be set for a</a>
<a name="ln2656">   random interval between 1 and 5 seconds.  If other changes that</a>
<a name="ln2657">   would trigger updates occur before the timer expires, a single</a>
<a name="ln2658">   update is triggered when the timer expires. */</a>
<a name="ln2659">  interval = (random () % 5) + 1;</a>
<a name="ln2660"> </a>
<a name="ln2661">  rip-&gt;t_triggered_interval = </a>
<a name="ln2662">    thread_add_timer (master, rip_triggered_interval, NULL, interval);</a>
<a name="ln2663"> </a>
<a name="ln2664">  return 0;</a>
<a name="ln2665">}</a>
<a name="ln2666"> </a>
<a name="ln2667">/* Withdraw redistributed route. */</a>
<a name="ln2668">void</a>
<a name="ln2669">rip_redistribute_withdraw (int type)</a>
<a name="ln2670">{</a>
<a name="ln2671">  struct route_node *rp;</a>
<a name="ln2672">  struct rip_info *rinfo = NULL;</a>
<a name="ln2673">  struct list *list = NULL;</a>
<a name="ln2674"> </a>
<a name="ln2675">  if (!rip)</a>
<a name="ln2676">    return;</a>
<a name="ln2677"> </a>
<a name="ln2678">  for (rp = route_top (rip-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln2679">    if ((list = rp-&gt;info) != NULL)</a>
<a name="ln2680">      {</a>
<a name="ln2681">	rinfo = listgetdata (listhead (list));</a>
<a name="ln2682">	if (rinfo-&gt;type == type</a>
<a name="ln2683">	    &amp;&amp; rinfo-&gt;sub_type != RIP_ROUTE_INTERFACE)</a>
<a name="ln2684">	  {</a>
<a name="ln2685">	    /* Perform poisoned reverse. */</a>
<a name="ln2686">	    rinfo-&gt;metric = RIP_METRIC_INFINITY;</a>
<a name="ln2687">	    RIP_TIMER_ON (rinfo-&gt;t_garbage_collect, </a>
<a name="ln2688">			  rip_garbage_collect, rip-&gt;garbage_time);</a>
<a name="ln2689">	    RIP_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln2690">	    rinfo-&gt;flags |= RIP_RTF_CHANGED;</a>
<a name="ln2691"> </a>
<a name="ln2692">	    if (IS_RIP_DEBUG_EVENT) {</a>
<a name="ln2693">              struct prefix_ipv4 *p = (struct prefix_ipv4 *) &amp;rp-&gt;p;</a>
<a name="ln2694"> </a>
<a name="ln2695">              zlog_debug (&quot;Poisone %s/%d on the interface %s with an infinity metric [withdraw]&quot;,</a>
<a name="ln2696">                         inet_ntoa(p-&gt;prefix), p-&gt;prefixlen,</a>
<a name="ln2697">                         ifindex2ifname(rinfo-&gt;ifindex));</a>
<a name="ln2698">	    }</a>
<a name="ln2699"> </a>
<a name="ln2700">	    rip_event (RIP_TRIGGERED_UPDATE, 0);</a>
<a name="ln2701">	  }</a>
<a name="ln2702">      }</a>
<a name="ln2703">}</a>
<a name="ln2704"> </a>
<a name="ln2705">/* Create new RIP instance and set it to global variable. */</a>
<a name="ln2706">static int</a>
<a name="ln2707">rip_create (void)</a>
<a name="ln2708">{</a>
<a name="ln2709">  rip = XCALLOC (MTYPE_RIP, sizeof (struct rip));</a>
<a name="ln2710"> </a>
<a name="ln2711">  /* Set initial value. */</a>
<a name="ln2712">  rip-&gt;version_send = RI_RIP_VERSION_2;</a>
<a name="ln2713">  rip-&gt;version_recv = RI_RIP_VERSION_1_AND_2;</a>
<a name="ln2714">  rip-&gt;update_time = RIP_UPDATE_TIMER_DEFAULT;</a>
<a name="ln2715">  rip-&gt;timeout_time = RIP_TIMEOUT_TIMER_DEFAULT;</a>
<a name="ln2716">  rip-&gt;garbage_time = RIP_GARBAGE_TIMER_DEFAULT;</a>
<a name="ln2717">  rip-&gt;default_metric = RIP_DEFAULT_METRIC_DEFAULT;</a>
<a name="ln2718"> </a>
<a name="ln2719">  /* Initialize RIP routig table. */</a>
<a name="ln2720">  rip-&gt;table = route_table_init ();</a>
<a name="ln2721">  rip-&gt;route = route_table_init ();</a>
<a name="ln2722">  rip-&gt;neighbor = route_table_init ();</a>
<a name="ln2723"> </a>
<a name="ln2724">  /* Make output stream. */</a>
<a name="ln2725">  rip-&gt;obuf = stream_new (1500);</a>
<a name="ln2726"> </a>
<a name="ln2727">  /* Make socket. */</a>
<a name="ln2728">  rip-&gt;sock = rip_create_socket (NULL);</a>
<a name="ln2729">  if (rip-&gt;sock &lt; 0)</a>
<a name="ln2730">    return rip-&gt;sock;</a>
<a name="ln2731"> </a>
<a name="ln2732">  /* Create read and timer thread. */</a>
<a name="ln2733">  rip_event (RIP_READ, rip-&gt;sock);</a>
<a name="ln2734">  rip_event (RIP_UPDATE_EVENT, 1);</a>
<a name="ln2735"> </a>
<a name="ln2736">  return 0;</a>
<a name="ln2737">}</a>
<a name="ln2738"> </a>
<a name="ln2739">/* Sned RIP request to the destination. */</a>
<a name="ln2740">int</a>
<a name="ln2741">rip_request_send (struct sockaddr_in *to, struct interface *ifp,</a>
<a name="ln2742">		  u_char version, struct connected *connected)</a>
<a name="ln2743">{</a>
<a name="ln2744">  struct rte *rte;</a>
<a name="ln2745">  struct rip_packet rip_packet;</a>
<a name="ln2746">  struct listnode *node, *nnode;</a>
<a name="ln2747"> </a>
<a name="ln2748">  memset (&amp;rip_packet, 0, sizeof (rip_packet));</a>
<a name="ln2749"> </a>
<a name="ln2750">  rip_packet.command = RIP_REQUEST;</a>
<a name="ln2751">  rip_packet.version = version;</a>
<a name="ln2752">  rte = rip_packet.rte;</a>
<a name="ln2753">  rte-&gt;metric = htonl (RIP_METRIC_INFINITY);</a>
<a name="ln2754"> </a>
<a name="ln2755">  if (connected) </a>
<a name="ln2756">    {</a>
<a name="ln2757">      /* </a>
<a name="ln2758">       * connected is only sent for ripv1 case, or when</a>
<a name="ln2759">       * interface does not support multicast.  Caller loops</a>
<a name="ln2760">       * over each connected address for this case.</a>
<a name="ln2761">       */</a>
<a name="ln2762">      if (rip_send_packet ((u_char *) &amp;rip_packet, sizeof (rip_packet), </a>
<a name="ln2763">                            to, connected) != sizeof (rip_packet))</a>
<a name="ln2764">        return -1;</a>
<a name="ln2765">      else</a>
<a name="ln2766">        return sizeof (rip_packet);</a>
<a name="ln2767">    }</a>
<a name="ln2768">	</a>
<a name="ln2769">  /* send request on each connected network */</a>
<a name="ln2770">  for (ALL_LIST_ELEMENTS (ifp-&gt;connected, node, nnode, connected))</a>
<a name="ln2771">    {</a>
<a name="ln2772">      struct prefix_ipv4 *p;</a>
<a name="ln2773"> </a>
<a name="ln2774">      p = (struct prefix_ipv4 *) connected-&gt;address;</a>
<a name="ln2775"> </a>
<a name="ln2776">      if (p-&gt;family != AF_INET)</a>
<a name="ln2777">        continue;</a>
<a name="ln2778"> </a>
<a name="ln2779">      if (rip_send_packet ((u_char *) &amp;rip_packet, sizeof (rip_packet), </a>
<a name="ln2780">                            to, connected) != sizeof (rip_packet))</a>
<a name="ln2781">        return -1;</a>
<a name="ln2782">    }</a>
<a name="ln2783">  return sizeof (rip_packet);</a>
<a name="ln2784">}</a>
<a name="ln2785"> </a>
<a name="ln2786">static int</a>
<a name="ln2787">rip_update_jitter (unsigned long time)</a>
<a name="ln2788">{</a>
<a name="ln2789">#define JITTER_BOUND 4</a>
<a name="ln2790">  /* We want to get the jitter to +/- 1/JITTER_BOUND the interval.</a>
<a name="ln2791">     Given that, we cannot let time be less than JITTER_BOUND seconds.</a>
<a name="ln2792">     The RIPv2 RFC says jitter should be small compared to</a>
<a name="ln2793">     update_time.  We consider 1/JITTER_BOUND to be small.</a>
<a name="ln2794">  */</a>
<a name="ln2795">  </a>
<a name="ln2796">  int jitter_input = time;</a>
<a name="ln2797">  int jitter;</a>
<a name="ln2798">  </a>
<a name="ln2799">  if (jitter_input &lt; JITTER_BOUND)</a>
<a name="ln2800">    jitter_input = JITTER_BOUND;</a>
<a name="ln2801">  </a>
<a name="ln2802">  jitter = (((random () % ((jitter_input * 2) + 1)) - jitter_input));  </a>
<a name="ln2803"> </a>
<a name="ln2804">  return jitter/JITTER_BOUND;</a>
<a name="ln2805">}</a>
<a name="ln2806"> </a>
<a name="ln2807">void</a>
<a name="ln2808">rip_event (enum rip_event event, int sock)</a>
<a name="ln2809">{</a>
<a name="ln2810">  int jitter = 0;</a>
<a name="ln2811"> </a>
<a name="ln2812">  switch (event)</a>
<a name="ln2813">    {</a>
<a name="ln2814">    case RIP_READ:</a>
<a name="ln2815">      rip-&gt;t_read = thread_add_read (master, rip_read, NULL, sock);</a>
<a name="ln2816">      break;</a>
<a name="ln2817">    case RIP_UPDATE_EVENT:</a>
<a name="ln2818">      if (rip-&gt;t_update)</a>
<a name="ln2819">	{</a>
<a name="ln2820">	  thread_cancel (rip-&gt;t_update);</a>
<a name="ln2821">	  rip-&gt;t_update = NULL;</a>
<a name="ln2822">	}</a>
<a name="ln2823">      jitter = rip_update_jitter (rip-&gt;update_time);</a>
<a name="ln2824">      rip-&gt;t_update = </a>
<a name="ln2825">	thread_add_timer (master, rip_update, NULL, </a>
<a name="ln2826">			  sock ? 2 : rip-&gt;update_time + jitter);</a>
<a name="ln2827">      break;</a>
<a name="ln2828">    case RIP_TRIGGERED_UPDATE:</a>
<a name="ln2829">      if (rip-&gt;t_triggered_interval)</a>
<a name="ln2830">	rip-&gt;trigger = 1;</a>
<a name="ln2831">      else if (! rip-&gt;t_triggered_update)</a>
<a name="ln2832">	rip-&gt;t_triggered_update = </a>
<a name="ln2833">	  thread_add_event (master, rip_triggered_update, NULL, 0);</a>
<a name="ln2834">      break;</a>
<a name="ln2835">    default:</a>
<a name="ln2836">      break;</a>
<a name="ln2837">    }</a>
<a name="ln2838">}</a>
<a name="ln2839"> </a>
<a name="ln2840">DEFUN (router_rip,</a>
<a name="ln2841">       router_rip_cmd,</a>
<a name="ln2842">       &quot;router rip&quot;,</a>
<a name="ln2843">       &quot;Enable a routing process\n&quot;</a>
<a name="ln2844">       &quot;Routing Information Protocol (RIP)\n&quot;)</a>
<a name="ln2845">{</a>
<a name="ln2846">  int ret;</a>
<a name="ln2847"> </a>
<a name="ln2848">  /* If rip is not enabled before. */</a>
<a name="ln2849">  if (! rip)</a>
<a name="ln2850">    {</a>
<a name="ln2851">      ret = rip_create ();</a>
<a name="ln2852">      if (ret &lt; 0)</a>
<a name="ln2853">	{</a>
<a name="ln2854">	  zlog_info (&quot;Can't create RIP&quot;);</a>
<a name="ln2855">	  return CMD_WARNING;</a>
<a name="ln2856">	}</a>
<a name="ln2857">    }</a>
<a name="ln2858">  vty-&gt;node = RIP_NODE;</a>
<a name="ln2859">  vty-&gt;index = rip;</a>
<a name="ln2860"> </a>
<a name="ln2861">  return CMD_SUCCESS;</a>
<a name="ln2862">}</a>
<a name="ln2863"> </a>
<a name="ln2864">DEFUN (no_router_rip,</a>
<a name="ln2865">       no_router_rip_cmd,</a>
<a name="ln2866">       &quot;no router rip&quot;,</a>
<a name="ln2867">       NO_STR</a>
<a name="ln2868">       &quot;Enable a routing process\n&quot;</a>
<a name="ln2869">       &quot;Routing Information Protocol (RIP)\n&quot;)</a>
<a name="ln2870">{</a>
<a name="ln2871">  if (rip)</a>
<a name="ln2872">    rip_clean ();</a>
<a name="ln2873">  return CMD_SUCCESS;</a>
<a name="ln2874">}</a>
<a name="ln2875"> </a>
<a name="ln2876">DEFUN (rip_version,</a>
<a name="ln2877">       rip_version_cmd,</a>
<a name="ln2878">       &quot;version &lt;1-2&gt;&quot;,</a>
<a name="ln2879">       &quot;Set routing protocol version\n&quot;</a>
<a name="ln2880">       &quot;version\n&quot;)</a>
<a name="ln2881">{</a>
<a name="ln2882">  int version;</a>
<a name="ln2883"> </a>
<a name="ln2884">  version = atoi (argv[0]);</a>
<a name="ln2885">  if (version != RIPv1 &amp;&amp; version != RIPv2)</a>
<a name="ln2886">    {</a>
<a name="ln2887">      vty_out (vty, &quot;invalid rip version %d%s&quot;, version,</a>
<a name="ln2888">	       VTY_NEWLINE);</a>
<a name="ln2889">      return CMD_WARNING;</a>
<a name="ln2890">    }</a>
<a name="ln2891">  rip-&gt;version_send = version;</a>
<a name="ln2892">  rip-&gt;version_recv = version;</a>
<a name="ln2893"> </a>
<a name="ln2894">  return CMD_SUCCESS;</a>
<a name="ln2895">} </a>
<a name="ln2896"> </a>
<a name="ln2897">DEFUN (no_rip_version,</a>
<a name="ln2898">       no_rip_version_cmd,</a>
<a name="ln2899">       &quot;no version&quot;,</a>
<a name="ln2900">       NO_STR</a>
<a name="ln2901">       &quot;Set routing protocol version\n&quot;)</a>
<a name="ln2902">{</a>
<a name="ln2903">  /* Set RIP version to the default. */</a>
<a name="ln2904">  rip-&gt;version_send = RI_RIP_VERSION_2;</a>
<a name="ln2905">  rip-&gt;version_recv = RI_RIP_VERSION_1_AND_2;</a>
<a name="ln2906"> </a>
<a name="ln2907">  return CMD_SUCCESS;</a>
<a name="ln2908">} </a>
<a name="ln2909"> </a>
<a name="ln2910">ALIAS (no_rip_version,</a>
<a name="ln2911">       no_rip_version_val_cmd,</a>
<a name="ln2912">       &quot;no version &lt;1-2&gt;&quot;,</a>
<a name="ln2913">       NO_STR</a>
<a name="ln2914">       &quot;Set routing protocol version\n&quot;</a>
<a name="ln2915">       &quot;version\n&quot;)</a>
<a name="ln2916"> </a>
<a name="ln2917">DEFUN (rip_route,</a>
<a name="ln2918">       rip_route_cmd,</a>
<a name="ln2919">       &quot;route A.B.C.D/M&quot;,</a>
<a name="ln2920">       &quot;RIP static route configuration\n&quot;</a>
<a name="ln2921">       &quot;IP prefix &lt;network&gt;/&lt;length&gt;\n&quot;)</a>
<a name="ln2922">{</a>
<a name="ln2923">  int ret;</a>
<a name="ln2924">  struct prefix_ipv4 p;</a>
<a name="ln2925">  struct route_node *node;</a>
<a name="ln2926"> </a>
<a name="ln2927">  ret = str2prefix_ipv4 (argv[0], &amp;p);</a>
<a name="ln2928">  if (ret &lt; 0)</a>
<a name="ln2929">    {</a>
<a name="ln2930">      vty_out (vty, &quot;Malformed address%s&quot;, VTY_NEWLINE);</a>
<a name="ln2931">      return CMD_WARNING;</a>
<a name="ln2932">    }</a>
<a name="ln2933">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln2934"> </a>
<a name="ln2935">  /* For router rip configuration. */</a>
<a name="ln2936">  node = route_node_get (rip-&gt;route, (struct prefix *) &amp;p);</a>
<a name="ln2937"> </a>
<a name="ln2938">  if (node-&gt;info)</a>
<a name="ln2939">    {</a>
<a name="ln2940">      vty_out (vty, &quot;There is already same static route.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2941">      route_unlock_node (node);</a>
<a name="ln2942">      return CMD_WARNING;</a>
<a name="ln2943">    }</a>
<a name="ln2944"> </a>
<a name="ln2945">  node-&gt;info = (char *)&quot;static&quot;;</a>
<a name="ln2946"> </a>
<a name="ln2947">  rip_redistribute_add (ZEBRA_ROUTE_RIP, RIP_ROUTE_STATIC, &amp;p, 0, NULL, 0, 0, 0);</a>
<a name="ln2948"> </a>
<a name="ln2949">  return CMD_SUCCESS;</a>
<a name="ln2950">}</a>
<a name="ln2951"> </a>
<a name="ln2952">DEFUN (no_rip_route,</a>
<a name="ln2953">       no_rip_route_cmd,</a>
<a name="ln2954">       &quot;no route A.B.C.D/M&quot;,</a>
<a name="ln2955">       NO_STR</a>
<a name="ln2956">       &quot;RIP static route configuration\n&quot;</a>
<a name="ln2957">       &quot;IP prefix &lt;network&gt;/&lt;length&gt;\n&quot;)</a>
<a name="ln2958">{</a>
<a name="ln2959">  int ret;</a>
<a name="ln2960">  struct prefix_ipv4 p;</a>
<a name="ln2961">  struct route_node *node;</a>
<a name="ln2962"> </a>
<a name="ln2963">  ret = str2prefix_ipv4 (argv[0], &amp;p);</a>
<a name="ln2964">  if (ret &lt; 0)</a>
<a name="ln2965">    {</a>
<a name="ln2966">      vty_out (vty, &quot;Malformed address%s&quot;, VTY_NEWLINE);</a>
<a name="ln2967">      return CMD_WARNING;</a>
<a name="ln2968">    }</a>
<a name="ln2969">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln2970"> </a>
<a name="ln2971">  /* For router rip configuration. */</a>
<a name="ln2972">  node = route_node_lookup (rip-&gt;route, (struct prefix *) &amp;p);</a>
<a name="ln2973">  if (! node)</a>
<a name="ln2974">    {</a>
<a name="ln2975">      vty_out (vty, &quot;Can't find route %s.%s&quot;, argv[0],</a>
<a name="ln2976">	       VTY_NEWLINE);</a>
<a name="ln2977">      return CMD_WARNING;</a>
<a name="ln2978">    }</a>
<a name="ln2979"> </a>
<a name="ln2980">  rip_redistribute_delete (ZEBRA_ROUTE_RIP, RIP_ROUTE_STATIC, &amp;p, 0);</a>
<a name="ln2981">  route_unlock_node (node);</a>
<a name="ln2982"> </a>
<a name="ln2983">  node-&gt;info = NULL;</a>
<a name="ln2984">  route_unlock_node (node);</a>
<a name="ln2985"> </a>
<a name="ln2986">  return CMD_SUCCESS;</a>
<a name="ln2987">}</a>
<a name="ln2988"> </a>
<a name="ln2989">#if 0</a>
<a name="ln2990">static void</a>
<a name="ln2991">rip_update_default_metric (void)</a>
<a name="ln2992">{</a>
<a name="ln2993">  struct route_node *np;</a>
<a name="ln2994">  struct rip_info *rinfo = NULL;</a>
<a name="ln2995">  struct list *list = NULL;</a>
<a name="ln2996">  struct listnode *listnode = NULL;</a>
<a name="ln2997"> </a>
<a name="ln2998">  for (np = route_top (rip-&gt;table); np; np = route_next (np))</a>
<a name="ln2999">    if ((list = np-&gt;info) != NULL)</a>
<a name="ln3000">      for (ALL_LIST_ELEMENTS_RO (list, listnode, rinfo))</a>
<a name="ln3001">        if (rinfo-&gt;type != ZEBRA_ROUTE_RIP &amp;&amp; rinfo-&gt;type != ZEBRA_ROUTE_CONNECT)</a>
<a name="ln3002">          rinfo-&gt;metric = rip-&gt;default_metric;</a>
<a name="ln3003">}</a>
<a name="ln3004">#endif</a>
<a name="ln3005"> </a>
<a name="ln3006">DEFUN (rip_default_metric,</a>
<a name="ln3007">       rip_default_metric_cmd,</a>
<a name="ln3008">       &quot;default-metric &lt;1-16&gt;&quot;,</a>
<a name="ln3009">       &quot;Set a metric of redistribute routes\n&quot;</a>
<a name="ln3010">       &quot;Default metric\n&quot;)</a>
<a name="ln3011">{</a>
<a name="ln3012">  if (rip)</a>
<a name="ln3013">    {</a>
<a name="ln3014">      rip-&gt;default_metric = atoi (argv[0]);</a>
<a name="ln3015">      /* rip_update_default_metric (); */</a>
<a name="ln3016">    }</a>
<a name="ln3017">  return CMD_SUCCESS;</a>
<a name="ln3018">}</a>
<a name="ln3019"> </a>
<a name="ln3020">DEFUN (no_rip_default_metric,</a>
<a name="ln3021">       no_rip_default_metric_cmd,</a>
<a name="ln3022">       &quot;no default-metric&quot;,</a>
<a name="ln3023">       NO_STR</a>
<a name="ln3024">       &quot;Set a metric of redistribute routes\n&quot;</a>
<a name="ln3025">       &quot;Default metric\n&quot;)</a>
<a name="ln3026">{</a>
<a name="ln3027">  if (rip)</a>
<a name="ln3028">    {</a>
<a name="ln3029">      rip-&gt;default_metric = RIP_DEFAULT_METRIC_DEFAULT;</a>
<a name="ln3030">      /* rip_update_default_metric (); */</a>
<a name="ln3031">    }</a>
<a name="ln3032">  return CMD_SUCCESS;</a>
<a name="ln3033">}</a>
<a name="ln3034"> </a>
<a name="ln3035">ALIAS (no_rip_default_metric,</a>
<a name="ln3036">       no_rip_default_metric_val_cmd,</a>
<a name="ln3037">       &quot;no default-metric &lt;1-16&gt;&quot;,</a>
<a name="ln3038">       NO_STR</a>
<a name="ln3039">       &quot;Set a metric of redistribute routes\n&quot;</a>
<a name="ln3040">       &quot;Default metric\n&quot;)</a>
<a name="ln3041"> </a>
<a name="ln3042">DEFUN (rip_timers,</a>
<a name="ln3043">       rip_timers_cmd,</a>
<a name="ln3044">       &quot;timers basic &lt;5-2147483647&gt; &lt;5-2147483647&gt; &lt;5-2147483647&gt;&quot;,</a>
<a name="ln3045">       &quot;Adjust routing timers\n&quot;</a>
<a name="ln3046">       &quot;Basic routing protocol update timers\n&quot;</a>
<a name="ln3047">       &quot;Routing table update timer value in second. Default is 30.\n&quot;</a>
<a name="ln3048">       &quot;Routing information timeout timer. Default is 180.\n&quot;</a>
<a name="ln3049">       &quot;Garbage collection timer. Default is 120.\n&quot;)</a>
<a name="ln3050">{</a>
<a name="ln3051">  unsigned long update;</a>
<a name="ln3052">  unsigned long timeout;</a>
<a name="ln3053">  unsigned long garbage;</a>
<a name="ln3054">  char *endptr = NULL;</a>
<a name="ln3055">  unsigned long RIP_TIMER_MAX = 2147483647;</a>
<a name="ln3056">  unsigned long RIP_TIMER_MIN = 5;</a>
<a name="ln3057"> </a>
<a name="ln3058">  update = strtoul (argv[0], &amp;endptr, 10);</a>
<a name="ln3059">  if (update &gt; RIP_TIMER_MAX || update &lt; RIP_TIMER_MIN || *endptr != '\0')  </a>
<a name="ln3060">    {</a>
<a name="ln3061">      vty_out (vty, &quot;update timer value error%s&quot;, VTY_NEWLINE);</a>
<a name="ln3062">      return CMD_WARNING;</a>
<a name="ln3063">    }</a>
<a name="ln3064">  </a>
<a name="ln3065">  timeout = strtoul (argv[1], &amp;endptr, 10);</a>
<a name="ln3066">  if (timeout &gt; RIP_TIMER_MAX || timeout &lt; RIP_TIMER_MIN || *endptr != '\0') </a>
<a name="ln3067">    {</a>
<a name="ln3068">      vty_out (vty, &quot;timeout timer value error%s&quot;, VTY_NEWLINE);</a>
<a name="ln3069">      return CMD_WARNING;</a>
<a name="ln3070">    }</a>
<a name="ln3071">  </a>
<a name="ln3072">  garbage = strtoul (argv[2], &amp;endptr, 10);</a>
<a name="ln3073">  if (garbage &gt; RIP_TIMER_MAX || garbage &lt; RIP_TIMER_MIN || *endptr != '\0') </a>
<a name="ln3074">    {</a>
<a name="ln3075">      vty_out (vty, &quot;garbage timer value error%s&quot;, VTY_NEWLINE);</a>
<a name="ln3076">      return CMD_WARNING;</a>
<a name="ln3077">    }</a>
<a name="ln3078"> </a>
<a name="ln3079">  /* Set each timer value. */</a>
<a name="ln3080">  rip-&gt;update_time = update;</a>
<a name="ln3081">  rip-&gt;timeout_time = timeout;</a>
<a name="ln3082">  rip-&gt;garbage_time = garbage;</a>
<a name="ln3083"> </a>
<a name="ln3084">  /* Reset update timer thread. */</a>
<a name="ln3085">  rip_event (RIP_UPDATE_EVENT, 0);</a>
<a name="ln3086"> </a>
<a name="ln3087">  return CMD_SUCCESS;</a>
<a name="ln3088">}</a>
<a name="ln3089"> </a>
<a name="ln3090">DEFUN (no_rip_timers,</a>
<a name="ln3091">       no_rip_timers_cmd,</a>
<a name="ln3092">       &quot;no timers basic&quot;,</a>
<a name="ln3093">       NO_STR</a>
<a name="ln3094">       &quot;Adjust routing timers\n&quot;</a>
<a name="ln3095">       &quot;Basic routing protocol update timers\n&quot;)</a>
<a name="ln3096">{</a>
<a name="ln3097">  /* Set each timer value to the default. */</a>
<a name="ln3098">  rip-&gt;update_time = RIP_UPDATE_TIMER_DEFAULT;</a>
<a name="ln3099">  rip-&gt;timeout_time = RIP_TIMEOUT_TIMER_DEFAULT;</a>
<a name="ln3100">  rip-&gt;garbage_time = RIP_GARBAGE_TIMER_DEFAULT;</a>
<a name="ln3101"> </a>
<a name="ln3102">  /* Reset update timer thread. */</a>
<a name="ln3103">  rip_event (RIP_UPDATE_EVENT, 0);</a>
<a name="ln3104"> </a>
<a name="ln3105">  return CMD_SUCCESS;</a>
<a name="ln3106">}</a>
<a name="ln3107"> </a>
<a name="ln3108">ALIAS (no_rip_timers,</a>
<a name="ln3109">       no_rip_timers_val_cmd,</a>
<a name="ln3110">       &quot;no timers basic &lt;0-65535&gt; &lt;0-65535&gt; &lt;0-65535&gt;&quot;,</a>
<a name="ln3111">       NO_STR</a>
<a name="ln3112">       &quot;Adjust routing timers\n&quot;</a>
<a name="ln3113">       &quot;Basic routing protocol update timers\n&quot;</a>
<a name="ln3114">       &quot;Routing table update timer value in second. Default is 30.\n&quot;</a>
<a name="ln3115">       &quot;Routing information timeout timer. Default is 180.\n&quot;</a>
<a name="ln3116">       &quot;Garbage collection timer. Default is 120.\n&quot;)</a>
<a name="ln3117"> </a>
<a name="ln3118"> </a>
<a name="ln3119">struct route_table *rip_distance_table;</a>
<a name="ln3120"> </a>
<a name="ln3121">struct rip_distance</a>
<a name="ln3122">{</a>
<a name="ln3123">  /* Distance value for the IP source prefix. */</a>
<a name="ln3124">  u_char distance;</a>
<a name="ln3125"> </a>
<a name="ln3126">  /* Name of the access-list to be matched. */</a>
<a name="ln3127">  char *access_list;</a>
<a name="ln3128">};</a>
<a name="ln3129"> </a>
<a name="ln3130">static struct rip_distance *</a>
<a name="ln3131">rip_distance_new (void)</a>
<a name="ln3132">{</a>
<a name="ln3133">  return XCALLOC (MTYPE_RIP_DISTANCE, sizeof (struct rip_distance));</a>
<a name="ln3134">}</a>
<a name="ln3135"> </a>
<a name="ln3136">static void</a>
<a name="ln3137">rip_distance_free (struct rip_distance *rdistance)</a>
<a name="ln3138">{</a>
<a name="ln3139">  XFREE (MTYPE_RIP_DISTANCE, rdistance);</a>
<a name="ln3140">}</a>
<a name="ln3141"> </a>
<a name="ln3142">static int</a>
<a name="ln3143">rip_distance_set (struct vty *vty, const char *distance_str, const char *ip_str,</a>
<a name="ln3144">		  const char *access_list_str)</a>
<a name="ln3145">{</a>
<a name="ln3146">  int ret;</a>
<a name="ln3147">  struct prefix_ipv4 p;</a>
<a name="ln3148">  u_char distance;</a>
<a name="ln3149">  struct route_node *rn;</a>
<a name="ln3150">  struct rip_distance *rdistance;</a>
<a name="ln3151"> </a>
<a name="ln3152">  ret = str2prefix_ipv4 (ip_str, &amp;p);</a>
<a name="ln3153">  if (ret == 0)</a>
<a name="ln3154">    {</a>
<a name="ln3155">      vty_out (vty, &quot;Malformed prefix%s&quot;, VTY_NEWLINE);</a>
<a name="ln3156">      return CMD_WARNING;</a>
<a name="ln3157">    }</a>
<a name="ln3158"> </a>
<a name="ln3159">  distance = atoi (distance_str);</a>
<a name="ln3160"> </a>
<a name="ln3161">  /* Get RIP distance node. */</a>
<a name="ln3162">  rn = route_node_get (rip_distance_table, (struct prefix *) &amp;p);</a>
<a name="ln3163">  if (rn-&gt;info)</a>
<a name="ln3164">    {</a>
<a name="ln3165">      rdistance = rn-&gt;info;</a>
<a name="ln3166">      route_unlock_node (rn);</a>
<a name="ln3167">    }</a>
<a name="ln3168">  else</a>
<a name="ln3169">    {</a>
<a name="ln3170">      rdistance = rip_distance_new ();</a>
<a name="ln3171">      rn-&gt;info = rdistance;</a>
<a name="ln3172">    }</a>
<a name="ln3173"> </a>
<a name="ln3174">  /* Set distance value. */</a>
<a name="ln3175">  rdistance-&gt;distance = distance;</a>
<a name="ln3176"> </a>
<a name="ln3177">  /* Reset access-list configuration. */</a>
<a name="ln3178">  if (rdistance-&gt;access_list)</a>
<a name="ln3179">    {</a>
<a name="ln3180">      free (rdistance-&gt;access_list);</a>
<a name="ln3181">      rdistance-&gt;access_list = NULL;</a>
<a name="ln3182">    }</a>
<a name="ln3183">  if (access_list_str)</a>
<a name="ln3184">    rdistance-&gt;access_list = strdup (access_list_str);</a>
<a name="ln3185"> </a>
<a name="ln3186">  return CMD_SUCCESS;</a>
<a name="ln3187">}</a>
<a name="ln3188"> </a>
<a name="ln3189">static int</a>
<a name="ln3190">rip_distance_unset (struct vty *vty, const char *distance_str,</a>
<a name="ln3191">		    const char *ip_str, const char *access_list_str)</a>
<a name="ln3192">{</a>
<a name="ln3193">  int ret;</a>
<a name="ln3194">  struct prefix_ipv4 p;</a>
<a name="ln3195">  struct route_node *rn;</a>
<a name="ln3196">  struct rip_distance *rdistance;</a>
<a name="ln3197"> </a>
<a name="ln3198">  ret = str2prefix_ipv4 (ip_str, &amp;p);</a>
<a name="ln3199">  if (ret == 0)</a>
<a name="ln3200">    {</a>
<a name="ln3201">      vty_out (vty, &quot;Malformed prefix%s&quot;, VTY_NEWLINE);</a>
<a name="ln3202">      return CMD_WARNING;</a>
<a name="ln3203">    }</a>
<a name="ln3204"> </a>
<a name="ln3205">  rn = route_node_lookup (rip_distance_table, (struct prefix *)&amp;p);</a>
<a name="ln3206">  if (! rn)</a>
<a name="ln3207">    {</a>
<a name="ln3208">      vty_out (vty, &quot;Can't find specified prefix%s&quot;, VTY_NEWLINE);</a>
<a name="ln3209">      return CMD_WARNING;</a>
<a name="ln3210">    }</a>
<a name="ln3211"> </a>
<a name="ln3212">  rdistance = rn-&gt;info;</a>
<a name="ln3213"> </a>
<a name="ln3214">  if (rdistance-&gt;access_list)</a>
<a name="ln3215">    free (rdistance-&gt;access_list);</a>
<a name="ln3216">  rip_distance_free (rdistance);</a>
<a name="ln3217"> </a>
<a name="ln3218">  rn-&gt;info = NULL;</a>
<a name="ln3219">  route_unlock_node (rn);</a>
<a name="ln3220">  route_unlock_node (rn);</a>
<a name="ln3221"> </a>
<a name="ln3222">  return CMD_SUCCESS;</a>
<a name="ln3223">}</a>
<a name="ln3224"> </a>
<a name="ln3225">static void</a>
<a name="ln3226">rip_distance_reset (void)</a>
<a name="ln3227">{</a>
<a name="ln3228">  struct route_node *rn;</a>
<a name="ln3229">  struct rip_distance *rdistance;</a>
<a name="ln3230"> </a>
<a name="ln3231">  for (rn = route_top (rip_distance_table); rn; rn = route_next (rn))</a>
<a name="ln3232">    if ((rdistance = rn-&gt;info) != NULL)</a>
<a name="ln3233">      {</a>
<a name="ln3234">	if (rdistance-&gt;access_list)</a>
<a name="ln3235">	  free (rdistance-&gt;access_list);</a>
<a name="ln3236">	rip_distance_free (rdistance);</a>
<a name="ln3237">	rn-&gt;info = NULL;</a>
<a name="ln3238">	route_unlock_node (rn);</a>
<a name="ln3239">      }</a>
<a name="ln3240">}</a>
<a name="ln3241"> </a>
<a name="ln3242">/* Apply RIP information to distance method. */</a>
<a name="ln3243">u_char</a>
<a name="ln3244">rip_distance_apply (struct rip_info *rinfo)</a>
<a name="ln3245">{</a>
<a name="ln3246">  struct route_node *rn;</a>
<a name="ln3247">  struct prefix_ipv4 p;</a>
<a name="ln3248">  struct rip_distance *rdistance;</a>
<a name="ln3249">  struct access_list *alist;</a>
<a name="ln3250"> </a>
<a name="ln3251">  if (! rip)</a>
<a name="ln3252">    return 0;</a>
<a name="ln3253"> </a>
<a name="ln3254">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln3255">  p.family = AF_INET;</a>
<a name="ln3256">  p.prefix = rinfo-&gt;from;</a>
<a name="ln3257">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln3258"> </a>
<a name="ln3259">  /* Check source address. */</a>
<a name="ln3260">  rn = route_node_match (rip_distance_table, (struct prefix *) &amp;p);</a>
<a name="ln3261">  if (rn)</a>
<a name="ln3262">    {</a>
<a name="ln3263">      rdistance = rn-&gt;info;</a>
<a name="ln3264">      route_unlock_node (rn);</a>
<a name="ln3265"> </a>
<a name="ln3266">      if (rdistance-&gt;access_list)</a>
<a name="ln3267">	{</a>
<a name="ln3268">	  alist = access_list_lookup (AFI_IP, rdistance-&gt;access_list);</a>
<a name="ln3269">	  if (alist == NULL)</a>
<a name="ln3270">	    return 0;</a>
<a name="ln3271">	  if (access_list_apply (alist, &amp;rinfo-&gt;rp-&gt;p) == FILTER_DENY)</a>
<a name="ln3272">	    return 0;</a>
<a name="ln3273"> </a>
<a name="ln3274">	  return rdistance-&gt;distance;</a>
<a name="ln3275">	}</a>
<a name="ln3276">      else</a>
<a name="ln3277">	return rdistance-&gt;distance;</a>
<a name="ln3278">    }</a>
<a name="ln3279"> </a>
<a name="ln3280">  if (rip-&gt;distance)</a>
<a name="ln3281">    return rip-&gt;distance;</a>
<a name="ln3282"> </a>
<a name="ln3283">  return 0;</a>
<a name="ln3284">}</a>
<a name="ln3285"> </a>
<a name="ln3286">static void</a>
<a name="ln3287">rip_distance_show (struct vty *vty)</a>
<a name="ln3288">{</a>
<a name="ln3289">  struct route_node *rn;</a>
<a name="ln3290">  struct rip_distance *rdistance;</a>
<a name="ln3291">  int header = 1;</a>
<a name="ln3292">  char buf[BUFSIZ];</a>
<a name="ln3293">  </a>
<a name="ln3294">  vty_out (vty, &quot;  Distance: (default is %d)%s&quot;,</a>
<a name="ln3295">	   rip-&gt;distance ? rip-&gt;distance :ZEBRA_RIP_DISTANCE_DEFAULT,</a>
<a name="ln3296">	   VTY_NEWLINE);</a>
<a name="ln3297"> </a>
<a name="ln3298">  for (rn = route_top (rip_distance_table); rn; rn = route_next (rn))</a>
<a name="ln3299">    if ((rdistance = rn-&gt;info) != NULL)</a>
<a name="ln3300">      {</a>
<a name="ln3301">	if (header)</a>
<a name="ln3302">	  {</a>
<a name="ln3303">	    vty_out (vty, &quot;    Address           Distance  List%s&quot;,</a>
<a name="ln3304">		     VTY_NEWLINE);</a>
<a name="ln3305">	    header = 0;</a>
<a name="ln3306">	  }</a>
<a name="ln3307">	sprintf (buf, &quot;%s/%d&quot;, inet_ntoa (rn-&gt;p.u.prefix4), rn-&gt;p.prefixlen);</a>
<a name="ln3308">	vty_out (vty, &quot;    %-20s  %4d  %s%s&quot;,</a>
<a name="ln3309">		 buf, rdistance-&gt;distance,</a>
<a name="ln3310">		 rdistance-&gt;access_list ? rdistance-&gt;access_list : &quot;&quot;,</a>
<a name="ln3311">		 VTY_NEWLINE);</a>
<a name="ln3312">      }</a>
<a name="ln3313">}</a>
<a name="ln3314"> </a>
<a name="ln3315">DEFUN (rip_distance,</a>
<a name="ln3316">       rip_distance_cmd,</a>
<a name="ln3317">       &quot;distance &lt;1-255&gt;&quot;,</a>
<a name="ln3318">       &quot;Administrative distance\n&quot;</a>
<a name="ln3319">       &quot;Distance value\n&quot;)</a>
<a name="ln3320">{</a>
<a name="ln3321">  rip-&gt;distance = atoi (argv[0]);</a>
<a name="ln3322">  return CMD_SUCCESS;</a>
<a name="ln3323">}</a>
<a name="ln3324"> </a>
<a name="ln3325">DEFUN (no_rip_distance,</a>
<a name="ln3326">       no_rip_distance_cmd,</a>
<a name="ln3327">       &quot;no distance &lt;1-255&gt;&quot;,</a>
<a name="ln3328">       NO_STR</a>
<a name="ln3329">       &quot;Administrative distance\n&quot;</a>
<a name="ln3330">       &quot;Distance value\n&quot;)</a>
<a name="ln3331">{</a>
<a name="ln3332">  rip-&gt;distance = 0;</a>
<a name="ln3333">  return CMD_SUCCESS;</a>
<a name="ln3334">}</a>
<a name="ln3335"> </a>
<a name="ln3336">DEFUN (rip_distance_source,</a>
<a name="ln3337">       rip_distance_source_cmd,</a>
<a name="ln3338">       &quot;distance &lt;1-255&gt; A.B.C.D/M&quot;,</a>
<a name="ln3339">       &quot;Administrative distance\n&quot;</a>
<a name="ln3340">       &quot;Distance value\n&quot;</a>
<a name="ln3341">       &quot;IP source prefix\n&quot;)</a>
<a name="ln3342">{</a>
<a name="ln3343">  rip_distance_set (vty, argv[0], argv[1], NULL);</a>
<a name="ln3344">  return CMD_SUCCESS;</a>
<a name="ln3345">}</a>
<a name="ln3346"> </a>
<a name="ln3347">DEFUN (no_rip_distance_source,</a>
<a name="ln3348">       no_rip_distance_source_cmd,</a>
<a name="ln3349">       &quot;no distance &lt;1-255&gt; A.B.C.D/M&quot;,</a>
<a name="ln3350">       NO_STR</a>
<a name="ln3351">       &quot;Administrative distance\n&quot;</a>
<a name="ln3352">       &quot;Distance value\n&quot;</a>
<a name="ln3353">       &quot;IP source prefix\n&quot;)</a>
<a name="ln3354">{</a>
<a name="ln3355">  rip_distance_unset (vty, argv[0], argv[1], NULL);</a>
<a name="ln3356">  return CMD_SUCCESS;</a>
<a name="ln3357">}</a>
<a name="ln3358"> </a>
<a name="ln3359">DEFUN (rip_distance_source_access_list,</a>
<a name="ln3360">       rip_distance_source_access_list_cmd,</a>
<a name="ln3361">       &quot;distance &lt;1-255&gt; A.B.C.D/M WORD&quot;,</a>
<a name="ln3362">       &quot;Administrative distance\n&quot;</a>
<a name="ln3363">       &quot;Distance value\n&quot;</a>
<a name="ln3364">       &quot;IP source prefix\n&quot;</a>
<a name="ln3365">       &quot;Access list name\n&quot;)</a>
<a name="ln3366">{</a>
<a name="ln3367">  rip_distance_set (vty, argv[0], argv[1], argv[2]);</a>
<a name="ln3368">  return CMD_SUCCESS;</a>
<a name="ln3369">}</a>
<a name="ln3370"> </a>
<a name="ln3371">DEFUN (no_rip_distance_source_access_list,</a>
<a name="ln3372">       no_rip_distance_source_access_list_cmd,</a>
<a name="ln3373">       &quot;no distance &lt;1-255&gt; A.B.C.D/M WORD&quot;,</a>
<a name="ln3374">       NO_STR</a>
<a name="ln3375">       &quot;Administrative distance\n&quot;</a>
<a name="ln3376">       &quot;Distance value\n&quot;</a>
<a name="ln3377">       &quot;IP source prefix\n&quot;</a>
<a name="ln3378">       &quot;Access list name\n&quot;)</a>
<a name="ln3379">{</a>
<a name="ln3380">  rip_distance_unset (vty, argv[0], argv[1], argv[2]);</a>
<a name="ln3381">  return CMD_SUCCESS;</a>
<a name="ln3382">}</a>
<a name="ln3383"> </a>
<a name="ln3384">/* Update ECMP routes to zebra when ECMP is disabled. */</a>
<a name="ln3385">static void</a>
<a name="ln3386">rip_ecmp_disable (void)</a>
<a name="ln3387">{</a>
<a name="ln3388">  struct route_node *rp;</a>
<a name="ln3389">  struct rip_info *rinfo, *tmp_rinfo;</a>
<a name="ln3390">  struct list *list;</a>
<a name="ln3391">  struct listnode *node, *nextnode;</a>
<a name="ln3392"> </a>
<a name="ln3393">  if (!rip)</a>
<a name="ln3394">    return;</a>
<a name="ln3395"> </a>
<a name="ln3396">  for (rp = route_top (rip-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln3397">    if ((list = rp-&gt;info) != NULL &amp;&amp; listcount (list) &gt; 1)</a>
<a name="ln3398">      {</a>
<a name="ln3399">        rinfo = listgetdata (listhead (list));</a>
<a name="ln3400">        if (!rip_route_rte (rinfo))</a>
<a name="ln3401">          continue;</a>
<a name="ln3402"> </a>
<a name="ln3403">        /* Drop all other entries, except the first one. */</a>
<a name="ln3404">        for (ALL_LIST_ELEMENTS (list, node, nextnode, tmp_rinfo))</a>
<a name="ln3405">          if (tmp_rinfo != rinfo)</a>
<a name="ln3406">            {</a>
<a name="ln3407">              RIP_TIMER_OFF (tmp_rinfo-&gt;t_timeout);</a>
<a name="ln3408">              RIP_TIMER_OFF (tmp_rinfo-&gt;t_garbage_collect);</a>
<a name="ln3409">              list_delete_node (list, node);</a>
<a name="ln3410">              rip_info_free (tmp_rinfo);</a>
<a name="ln3411">            }</a>
<a name="ln3412"> </a>
<a name="ln3413">        /* Update zebra. */</a>
<a name="ln3414">        rip_zebra_ipv4_add (rp);</a>
<a name="ln3415"> </a>
<a name="ln3416">        /* Set the route change flag. */</a>
<a name="ln3417">        SET_FLAG (rinfo-&gt;flags, RIP_RTF_CHANGED);</a>
<a name="ln3418"> </a>
<a name="ln3419">        /* Signal the output process to trigger an update. */</a>
<a name="ln3420">        rip_event (RIP_TRIGGERED_UPDATE, 0);</a>
<a name="ln3421">      }</a>
<a name="ln3422">}</a>
<a name="ln3423"> </a>
<a name="ln3424">DEFUN (rip_allow_ecmp,</a>
<a name="ln3425">       rip_allow_ecmp_cmd,</a>
<a name="ln3426">       &quot;allow-ecmp&quot;,</a>
<a name="ln3427">       &quot;Allow Equal Cost MultiPath\n&quot;)</a>
<a name="ln3428">{</a>
<a name="ln3429">  if (rip-&gt;ecmp)</a>
<a name="ln3430">    {</a>
<a name="ln3431">      vty_out (vty, &quot;ECMP is already enabled.%s&quot;, VTY_NEWLINE);</a>
<a name="ln3432">      return CMD_WARNING;</a>
<a name="ln3433">    }</a>
<a name="ln3434"> </a>
<a name="ln3435">  rip-&gt;ecmp = 1;</a>
<a name="ln3436">  zlog_info (&quot;ECMP is enabled.&quot;);</a>
<a name="ln3437">  return CMD_SUCCESS;</a>
<a name="ln3438">}</a>
<a name="ln3439"> </a>
<a name="ln3440">DEFUN (no_rip_allow_ecmp,</a>
<a name="ln3441">       no_rip_allow_ecmp_cmd,</a>
<a name="ln3442">       &quot;no allow-ecmp&quot;,</a>
<a name="ln3443">       NO_STR</a>
<a name="ln3444">       &quot;Allow Equal Cost MultiPath\n&quot;)</a>
<a name="ln3445">{</a>
<a name="ln3446">  if (!rip-&gt;ecmp)</a>
<a name="ln3447">    {</a>
<a name="ln3448">      vty_out (vty, &quot;ECMP is already disabled.%s&quot;, VTY_NEWLINE);</a>
<a name="ln3449">      return CMD_WARNING;</a>
<a name="ln3450">    }</a>
<a name="ln3451"> </a>
<a name="ln3452">  rip-&gt;ecmp = 0;</a>
<a name="ln3453">  zlog_info (&quot;ECMP is disabled.&quot;);</a>
<a name="ln3454">  rip_ecmp_disable ();</a>
<a name="ln3455">  return CMD_SUCCESS;</a>
<a name="ln3456">}</a>
<a name="ln3457"> </a>
<a name="ln3458">/* Print out routes update time. */</a>
<a name="ln3459">static void</a>
<a name="ln3460">rip_vty_out_uptime (struct vty *vty, struct rip_info *rinfo)</a>
<a name="ln3461">{</a>
<a name="ln3462">  time_t clock;</a>
<a name="ln3463">  struct tm *tm;</a>
<a name="ln3464">#define TIME_BUF 25</a>
<a name="ln3465">  char timebuf [TIME_BUF];</a>
<a name="ln3466">  struct thread *thread;</a>
<a name="ln3467"> </a>
<a name="ln3468">  if ((thread = rinfo-&gt;t_timeout) != NULL)</a>
<a name="ln3469">    {</a>
<a name="ln3470">      clock = thread_timer_remain_second (thread);</a>
<a name="ln3471">      tm = gmtime (&amp;clock);</a>
<a name="ln3472">      strftime (timebuf, TIME_BUF, &quot;%M:%S&quot;, tm);</a>
<a name="ln3473">      vty_out (vty, &quot;%5s&quot;, timebuf);</a>
<a name="ln3474">    }</a>
<a name="ln3475">  else if ((thread = rinfo-&gt;t_garbage_collect) != NULL)</a>
<a name="ln3476">    {</a>
<a name="ln3477">      clock = thread_timer_remain_second (thread);</a>
<a name="ln3478">      tm = gmtime (&amp;clock);</a>
<a name="ln3479">      strftime (timebuf, TIME_BUF, &quot;%M:%S&quot;, tm);</a>
<a name="ln3480">      vty_out (vty, &quot;%5s&quot;, timebuf);</a>
<a name="ln3481">    }</a>
<a name="ln3482">}</a>
<a name="ln3483"> </a>
<a name="ln3484">static const char *</a>
<a name="ln3485">rip_route_type_print (int sub_type)</a>
<a name="ln3486">{</a>
<a name="ln3487">  switch (sub_type)</a>
<a name="ln3488">    {</a>
<a name="ln3489">      case RIP_ROUTE_RTE:</a>
<a name="ln3490">	return &quot;n&quot;;</a>
<a name="ln3491">      case RIP_ROUTE_STATIC:</a>
<a name="ln3492">	return &quot;s&quot;;</a>
<a name="ln3493">      case RIP_ROUTE_DEFAULT:</a>
<a name="ln3494">	return &quot;d&quot;;</a>
<a name="ln3495">      case RIP_ROUTE_REDISTRIBUTE:</a>
<a name="ln3496">	return &quot;r&quot;;</a>
<a name="ln3497">      case RIP_ROUTE_INTERFACE:</a>
<a name="ln3498">	return &quot;i&quot;;</a>
<a name="ln3499">      default:</a>
<a name="ln3500">	return &quot;?&quot;;</a>
<a name="ln3501">    }</a>
<a name="ln3502">}</a>
<a name="ln3503"> </a>
<a name="ln3504">DEFUN (show_ip_rip,</a>
<a name="ln3505">       show_ip_rip_cmd,</a>
<a name="ln3506">       &quot;show ip rip&quot;,</a>
<a name="ln3507">       SHOW_STR</a>
<a name="ln3508">       IP_STR</a>
<a name="ln3509">       &quot;Show RIP routes\n&quot;)</a>
<a name="ln3510">{</a>
<a name="ln3511">  struct route_node *np;</a>
<a name="ln3512">  struct rip_info *rinfo = NULL;</a>
<a name="ln3513">  struct list *list = NULL;</a>
<a name="ln3514">  struct listnode *listnode = NULL;</a>
<a name="ln3515"> </a>
<a name="ln3516">  if (! rip)</a>
<a name="ln3517">    return CMD_SUCCESS;</a>
<a name="ln3518"> </a>
<a name="ln3519">  vty_out (vty, &quot;Codes: R - RIP, C - connected, S - Static, O - OSPF, B - BGP%s&quot;</a>
<a name="ln3520">	   &quot;Sub-codes:%s&quot;</a>
<a name="ln3521">           &quot;      (n) - normal, (s) - static, (d) - default, (r) - redistribute,%s&quot;</a>
<a name="ln3522">	   &quot;      (i) - interface%s%s&quot;</a>
<a name="ln3523">	   &quot;     Network            Next Hop         Metric From            Tag Time%s&quot;,</a>
<a name="ln3524">	   VTY_NEWLINE, VTY_NEWLINE,  VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln3525">  </a>
<a name="ln3526">  for (np = route_top (rip-&gt;table); np; np = route_next (np))</a>
<a name="ln3527">    if ((list = np-&gt;info) != NULL)</a>
<a name="ln3528">      for (ALL_LIST_ELEMENTS_RO (list, listnode, rinfo))</a>
<a name="ln3529">      {</a>
<a name="ln3530">	int len;</a>
<a name="ln3531"> </a>
<a name="ln3532">	len = vty_out (vty, &quot;%c(%s) %s/%d&quot;,</a>
<a name="ln3533">		       /* np-&gt;lock, For debugging. */</a>
<a name="ln3534">		       zebra_route_char(rinfo-&gt;type),</a>
<a name="ln3535">		       rip_route_type_print (rinfo-&gt;sub_type),</a>
<a name="ln3536">		       inet_ntoa (np-&gt;p.u.prefix4), np-&gt;p.prefixlen);</a>
<a name="ln3537">	</a>
<a name="ln3538">	len = 24 - len;</a>
<a name="ln3539"> </a>
<a name="ln3540">	if (len &gt; 0)</a>
<a name="ln3541">	  vty_out (vty, &quot;%*s&quot;, len, &quot; &quot;);</a>
<a name="ln3542"> </a>
<a name="ln3543">        if (rinfo-&gt;nexthop.s_addr) </a>
<a name="ln3544">	  vty_out (vty, &quot;%-20s %2d &quot;, inet_ntoa (rinfo-&gt;nexthop),</a>
<a name="ln3545">		   rinfo-&gt;metric);</a>
<a name="ln3546">        else</a>
<a name="ln3547">	  vty_out (vty, &quot;0.0.0.0              %2d &quot;, rinfo-&gt;metric);</a>
<a name="ln3548"> </a>
<a name="ln3549">	/* Route which exist in kernel routing table. */</a>
<a name="ln3550">	if ((rinfo-&gt;type == ZEBRA_ROUTE_RIP) &amp;&amp; </a>
<a name="ln3551">	    (rinfo-&gt;sub_type == RIP_ROUTE_RTE))</a>
<a name="ln3552">	  {</a>
<a name="ln3553">	    vty_out (vty, &quot;%-15s &quot;, inet_ntoa (rinfo-&gt;from));</a>
<a name="ln3554">	    vty_out (vty, &quot;%3d &quot;, rinfo-&gt;tag);</a>
<a name="ln3555">	    rip_vty_out_uptime (vty, rinfo);</a>
<a name="ln3556">	  }</a>
<a name="ln3557">	else if (rinfo-&gt;metric == RIP_METRIC_INFINITY)</a>
<a name="ln3558">	  {</a>
<a name="ln3559">	    vty_out (vty, &quot;self            &quot;);</a>
<a name="ln3560">	    vty_out (vty, &quot;%3d &quot;, rinfo-&gt;tag);</a>
<a name="ln3561">	    rip_vty_out_uptime (vty, rinfo);</a>
<a name="ln3562">	  }</a>
<a name="ln3563">	else</a>
<a name="ln3564">	  {</a>
<a name="ln3565">	    if (rinfo-&gt;external_metric)</a>
<a name="ln3566">	      {</a>
<a name="ln3567">	        len = vty_out (vty, &quot;self (%s:%d)&quot;, </a>
<a name="ln3568">			       zebra_route_string(rinfo-&gt;type),</a>
<a name="ln3569">	                       rinfo-&gt;external_metric);</a>
<a name="ln3570">	        len = 16 - len;</a>
<a name="ln3571">	        if (len &gt; 0)</a>
<a name="ln3572">	          vty_out (vty, &quot;%*s&quot;, len, &quot; &quot;);</a>
<a name="ln3573">	      }</a>
<a name="ln3574">	    else</a>
<a name="ln3575">	      vty_out (vty, &quot;self            &quot;);</a>
<a name="ln3576">	    vty_out (vty, &quot;%3d&quot;, rinfo-&gt;tag);</a>
<a name="ln3577">	  }</a>
<a name="ln3578"> </a>
<a name="ln3579">	vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln3580">      }</a>
<a name="ln3581">  return CMD_SUCCESS;</a>
<a name="ln3582">}</a>
<a name="ln3583"> </a>
<a name="ln3584">/* Vincent: formerly, it was show_ip_protocols_rip: &quot;show ip protocols&quot; */</a>
<a name="ln3585">DEFUN (show_ip_rip_status,</a>
<a name="ln3586">       show_ip_rip_status_cmd,</a>
<a name="ln3587">       &quot;show ip rip status&quot;,</a>
<a name="ln3588">       SHOW_STR</a>
<a name="ln3589">       IP_STR</a>
<a name="ln3590">       &quot;Show RIP routes\n&quot;</a>
<a name="ln3591">       &quot;IP routing protocol process parameters and statistics\n&quot;)</a>
<a name="ln3592">{</a>
<a name="ln3593">  struct listnode *node;</a>
<a name="ln3594">  struct interface *ifp;</a>
<a name="ln3595">  struct rip_interface *ri;</a>
<a name="ln3596">  extern const struct message ri_version_msg[];</a>
<a name="ln3597">  const char *send_version;</a>
<a name="ln3598">  const char *receive_version;</a>
<a name="ln3599"> </a>
<a name="ln3600">  if (! rip)</a>
<a name="ln3601">    return CMD_SUCCESS;</a>
<a name="ln3602"> </a>
<a name="ln3603">  vty_out (vty, &quot;Routing Protocol is \&quot;rip\&quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln3604">  vty_out (vty, &quot;  Sending updates every %ld seconds with +/-50%%,&quot;,</a>
<a name="ln3605">	   rip-&gt;update_time);</a>
<a name="ln3606">  vty_out (vty, &quot; next due in %lu seconds%s&quot;, </a>
<a name="ln3607">	   thread_timer_remain_second(rip-&gt;t_update),</a>
<a name="ln3608">	   VTY_NEWLINE);</a>
<a name="ln3609">  vty_out (vty, &quot;  Timeout after %ld seconds,&quot;, rip-&gt;timeout_time);</a>
<a name="ln3610">  vty_out (vty, &quot; garbage collect after %ld seconds%s&quot;, rip-&gt;garbage_time,</a>
<a name="ln3611">	   VTY_NEWLINE);</a>
<a name="ln3612"> </a>
<a name="ln3613">  /* Filtering status show. */</a>
<a name="ln3614">  config_show_distribute (vty);</a>
<a name="ln3615">		 </a>
<a name="ln3616">  /* Default metric information. */</a>
<a name="ln3617">  vty_out (vty, &quot;  Default redistribution metric is %d%s&quot;,</a>
<a name="ln3618">	   rip-&gt;default_metric, VTY_NEWLINE);</a>
<a name="ln3619"> </a>
<a name="ln3620">  /* Redistribute information. */</a>
<a name="ln3621">  vty_out (vty, &quot;  Redistributing:&quot;);</a>
<a name="ln3622">  config_write_rip_redistribute (vty, 0);</a>
<a name="ln3623">  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln3624"> </a>
<a name="ln3625">  vty_out (vty, &quot;  Default version control: send version %s,&quot;,</a>
<a name="ln3626">	   lookup(ri_version_msg,rip-&gt;version_send));</a>
<a name="ln3627">  if (rip-&gt;version_recv == RI_RIP_VERSION_1_AND_2)</a>
<a name="ln3628">    vty_out (vty, &quot; receive any version %s&quot;, VTY_NEWLINE);</a>
<a name="ln3629">  else</a>
<a name="ln3630">    vty_out (vty, &quot; receive version %s %s&quot;,</a>
<a name="ln3631">	     lookup(ri_version_msg,rip-&gt;version_recv), VTY_NEWLINE);</a>
<a name="ln3632"> </a>
<a name="ln3633">  vty_out (vty, &quot;    Interface        Send  Recv   Key-chain%s&quot;, VTY_NEWLINE);</a>
<a name="ln3634"> </a>
<a name="ln3635">  for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln3636">    {</a>
<a name="ln3637">      ri = ifp-&gt;info;</a>
<a name="ln3638"> </a>
<a name="ln3639">      if (!ri-&gt;running)</a>
<a name="ln3640">	continue;</a>
<a name="ln3641"> </a>
<a name="ln3642">      if (ri-&gt;enable_network || ri-&gt;enable_interface)</a>
<a name="ln3643">	{</a>
<a name="ln3644">	  if (ri-&gt;ri_send == RI_RIP_UNSPEC)</a>
<a name="ln3645">	    send_version = lookup (ri_version_msg, rip-&gt;version_send);</a>
<a name="ln3646">	  else</a>
<a name="ln3647">	    send_version = lookup (ri_version_msg, ri-&gt;ri_send);</a>
<a name="ln3648"> </a>
<a name="ln3649">	  if (ri-&gt;ri_receive == RI_RIP_UNSPEC)</a>
<a name="ln3650">	    receive_version = lookup (ri_version_msg, rip-&gt;version_recv);</a>
<a name="ln3651">	  else</a>
<a name="ln3652">	    receive_version = lookup (ri_version_msg, ri-&gt;ri_receive);</a>
<a name="ln3653">	</a>
<a name="ln3654">	  vty_out (vty, &quot;    %-17s%-3s   %-3s    %s%s&quot;, ifp-&gt;name,</a>
<a name="ln3655">		   send_version,</a>
<a name="ln3656">		   receive_version,</a>
<a name="ln3657">		   ri-&gt;key_chain ? ri-&gt;key_chain : &quot;&quot;,</a>
<a name="ln3658">		   VTY_NEWLINE);</a>
<a name="ln3659">	}</a>
<a name="ln3660">    }</a>
<a name="ln3661"> </a>
<a name="ln3662">  vty_out (vty, &quot;  Routing for Networks:%s&quot;, VTY_NEWLINE);</a>
<a name="ln3663">  config_write_rip_network (vty, 0);  </a>
<a name="ln3664"> </a>
<a name="ln3665">  {</a>
<a name="ln3666">    int found_passive = 0;</a>
<a name="ln3667">    for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln3668">      {</a>
<a name="ln3669">	ri = ifp-&gt;info;</a>
<a name="ln3670"> </a>
<a name="ln3671">	if ((ri-&gt;enable_network || ri-&gt;enable_interface) &amp;&amp; ri-&gt;passive)</a>
<a name="ln3672">	  {</a>
<a name="ln3673">	    if (!found_passive)</a>
<a name="ln3674">	      {</a>
<a name="ln3675">		vty_out (vty, &quot;  Passive Interface(s):%s&quot;, VTY_NEWLINE);</a>
<a name="ln3676">		found_passive = 1;</a>
<a name="ln3677">	      }</a>
<a name="ln3678">	    vty_out (vty, &quot;    %s%s&quot;, ifp-&gt;name, VTY_NEWLINE);</a>
<a name="ln3679">	  }</a>
<a name="ln3680">      }</a>
<a name="ln3681">  }</a>
<a name="ln3682"> </a>
<a name="ln3683">  vty_out (vty, &quot;  Routing Information Sources:%s&quot;, VTY_NEWLINE);</a>
<a name="ln3684">  vty_out (vty, &quot;    Gateway          BadPackets BadRoutes  Distance Last Update%s&quot;, VTY_NEWLINE);</a>
<a name="ln3685">  rip_peer_display (vty);</a>
<a name="ln3686"> </a>
<a name="ln3687">  rip_distance_show (vty);</a>
<a name="ln3688"> </a>
<a name="ln3689">  return CMD_SUCCESS;</a>
<a name="ln3690">}</a>
<a name="ln3691"> </a>
<a name="ln3692">/* RIP configuration write function. */</a>
<a name="ln3693">static int</a>
<a name="ln3694">config_write_rip (struct vty *vty)</a>
<a name="ln3695">{</a>
<a name="ln3696">  int write = 0;</a>
<a name="ln3697">  struct route_node *rn;</a>
<a name="ln3698">  struct rip_distance *rdistance;</a>
<a name="ln3699"> </a>
<a name="ln3700">  if (rip)</a>
<a name="ln3701">    {</a>
<a name="ln3702">      /* Router RIP statement. */</a>
<a name="ln3703">      vty_out (vty, &quot;router rip%s&quot;, VTY_NEWLINE);</a>
<a name="ln3704">      write++;</a>
<a name="ln3705">  </a>
<a name="ln3706">      /* RIP version statement.  Default is RIP version 2. */</a>
<a name="ln3707">      if (rip-&gt;version_send != RI_RIP_VERSION_2</a>
<a name="ln3708">	  || rip-&gt;version_recv != RI_RIP_VERSION_1_AND_2)</a>
<a name="ln3709">	vty_out (vty, &quot; version %d%s&quot;, rip-&gt;version_send,</a>
<a name="ln3710">		 VTY_NEWLINE);</a>
<a name="ln3711"> </a>
<a name="ln3712">      /* RIP timer configuration. */</a>
<a name="ln3713">      if (rip-&gt;update_time != RIP_UPDATE_TIMER_DEFAULT </a>
<a name="ln3714">	  || rip-&gt;timeout_time != RIP_TIMEOUT_TIMER_DEFAULT </a>
<a name="ln3715">	  || rip-&gt;garbage_time != RIP_GARBAGE_TIMER_DEFAULT)</a>
<a name="ln3716">	vty_out (vty, &quot; timers basic %lu %lu %lu%s&quot;,</a>
<a name="ln3717">		 rip-&gt;update_time,</a>
<a name="ln3718">		 rip-&gt;timeout_time,</a>
<a name="ln3719">		 rip-&gt;garbage_time,</a>
<a name="ln3720">		 VTY_NEWLINE);</a>
<a name="ln3721"> </a>
<a name="ln3722">      /* Default information configuration. */</a>
<a name="ln3723">      if (rip-&gt;default_information)</a>
<a name="ln3724">	{</a>
<a name="ln3725">	  if (rip-&gt;default_information_route_map)</a>
<a name="ln3726">	    vty_out (vty, &quot; default-information originate route-map %s%s&quot;,</a>
<a name="ln3727">		     rip-&gt;default_information_route_map, VTY_NEWLINE);</a>
<a name="ln3728">	  else</a>
<a name="ln3729">	    vty_out (vty, &quot; default-information originate%s&quot;,</a>
<a name="ln3730">		     VTY_NEWLINE);</a>
<a name="ln3731">	}</a>
<a name="ln3732"> </a>
<a name="ln3733">      /* Redistribute configuration. */</a>
<a name="ln3734">      config_write_rip_redistribute (vty, 1);</a>
<a name="ln3735"> </a>
<a name="ln3736">      /* RIP offset-list configuration. */</a>
<a name="ln3737">      config_write_rip_offset_list (vty);</a>
<a name="ln3738"> </a>
<a name="ln3739">      /* RIP enabled network and interface configuration. */</a>
<a name="ln3740">      config_write_rip_network (vty, 1);</a>
<a name="ln3741">			</a>
<a name="ln3742">      /* RIP default metric configuration */</a>
<a name="ln3743">      if (rip-&gt;default_metric != RIP_DEFAULT_METRIC_DEFAULT)</a>
<a name="ln3744">        vty_out (vty, &quot; default-metric %d%s&quot;,</a>
<a name="ln3745">		 rip-&gt;default_metric, VTY_NEWLINE);</a>
<a name="ln3746"> </a>
<a name="ln3747">      /* Distribute configuration. */</a>
<a name="ln3748">      write += config_write_distribute (vty);</a>
<a name="ln3749"> </a>
<a name="ln3750">      /* Interface routemap configuration */</a>
<a name="ln3751">      write += config_write_if_rmap (vty);</a>
<a name="ln3752"> </a>
<a name="ln3753">      /* Distance configuration. */</a>
<a name="ln3754">      if (rip-&gt;distance)</a>
<a name="ln3755">	vty_out (vty, &quot; distance %d%s&quot;, rip-&gt;distance, VTY_NEWLINE);</a>
<a name="ln3756"> </a>
<a name="ln3757">      /* RIP source IP prefix distance configuration. */</a>
<a name="ln3758">      for (rn = route_top (rip_distance_table); rn; rn = route_next (rn))</a>
<a name="ln3759">	if ((rdistance = rn-&gt;info) != NULL)</a>
<a name="ln3760">	  vty_out (vty, &quot; distance %d %s/%d %s%s&quot;, rdistance-&gt;distance,</a>
<a name="ln3761">		   inet_ntoa (rn-&gt;p.u.prefix4), rn-&gt;p.prefixlen,</a>
<a name="ln3762">		   rdistance-&gt;access_list ? rdistance-&gt;access_list : &quot;&quot;,</a>
<a name="ln3763">		   VTY_NEWLINE);</a>
<a name="ln3764"> </a>
<a name="ln3765">      /* ECMP configuration. */</a>
<a name="ln3766">      if (rip-&gt;ecmp)</a>
<a name="ln3767">        vty_out (vty, &quot; allow-ecmp%s&quot;, VTY_NEWLINE);</a>
<a name="ln3768"> </a>
<a name="ln3769">      /* RIP static route configuration. */</a>
<a name="ln3770">      for (rn = route_top (rip-&gt;route); rn; rn = route_next (rn))</a>
<a name="ln3771">	if (rn-&gt;info)</a>
<a name="ln3772">	  vty_out (vty, &quot; route %s/%d%s&quot;, </a>
<a name="ln3773">		   inet_ntoa (rn-&gt;p.u.prefix4),</a>
<a name="ln3774">		   rn-&gt;p.prefixlen,</a>
<a name="ln3775">		   VTY_NEWLINE);</a>
<a name="ln3776"> </a>
<a name="ln3777">    }</a>
<a name="ln3778">  return write;</a>
<a name="ln3779">}</a>
<a name="ln3780"> </a>
<a name="ln3781">/* RIP node structure. */</a>
<a name="ln3782">static struct cmd_node rip_node =</a>
<a name="ln3783">{</a>
<a name="ln3784">  RIP_NODE,</a>
<a name="ln3785">  &quot;%s(config-router)# &quot;,</a>
<a name="ln3786">  1</a>
<a name="ln3787">};</a>
<a name="ln3788"> </a>
<a name="ln3789">/* Distribute-list update functions. */</a>
<a name="ln3790">static void</a>
<a name="ln3791">rip_distribute_update (struct distribute *dist)</a>
<a name="ln3792">{</a>
<a name="ln3793">  struct interface *ifp;</a>
<a name="ln3794">  struct rip_interface *ri;</a>
<a name="ln3795">  struct access_list *alist;</a>
<a name="ln3796">  struct prefix_list *plist;</a>
<a name="ln3797"> </a>
<a name="ln3798">  if (! dist-&gt;ifname)</a>
<a name="ln3799">    return;</a>
<a name="ln3800"> </a>
<a name="ln3801">  ifp = if_lookup_by_name (dist-&gt;ifname);</a>
<a name="ln3802">  if (ifp == NULL)</a>
<a name="ln3803">    return;</a>
<a name="ln3804"> </a>
<a name="ln3805">  ri = ifp-&gt;info;</a>
<a name="ln3806"> </a>
<a name="ln3807">  if (dist-&gt;list[DISTRIBUTE_V4_IN])</a>
<a name="ln3808">    {</a>
<a name="ln3809">      alist = access_list_lookup (AFI_IP, dist-&gt;list[DISTRIBUTE_V4_IN]);</a>
<a name="ln3810">      if (alist)</a>
<a name="ln3811">	ri-&gt;list[RIP_FILTER_IN] = alist;</a>
<a name="ln3812">      else</a>
<a name="ln3813">	ri-&gt;list[RIP_FILTER_IN] = NULL;</a>
<a name="ln3814">    }</a>
<a name="ln3815">  else</a>
<a name="ln3816">    ri-&gt;list[RIP_FILTER_IN] = NULL;</a>
<a name="ln3817"> </a>
<a name="ln3818">  if (dist-&gt;list[DISTRIBUTE_V4_OUT])</a>
<a name="ln3819">    {</a>
<a name="ln3820">      alist = access_list_lookup (AFI_IP, dist-&gt;list[DISTRIBUTE_V4_OUT]);</a>
<a name="ln3821">      if (alist)</a>
<a name="ln3822">	ri-&gt;list[RIP_FILTER_OUT] = alist;</a>
<a name="ln3823">      else</a>
<a name="ln3824">	ri-&gt;list[RIP_FILTER_OUT] = NULL;</a>
<a name="ln3825">    }</a>
<a name="ln3826">  else</a>
<a name="ln3827">    ri-&gt;list[RIP_FILTER_OUT] = NULL;</a>
<a name="ln3828"> </a>
<a name="ln3829">  if (dist-&gt;prefix[DISTRIBUTE_V4_IN])</a>
<a name="ln3830">    {</a>
<a name="ln3831">      plist = prefix_list_lookup (AFI_IP, dist-&gt;prefix[DISTRIBUTE_V4_IN]);</a>
<a name="ln3832">      if (plist)</a>
<a name="ln3833">	ri-&gt;prefix[RIP_FILTER_IN] = plist;</a>
<a name="ln3834">      else</a>
<a name="ln3835">	ri-&gt;prefix[RIP_FILTER_IN] = NULL;</a>
<a name="ln3836">    }</a>
<a name="ln3837">  else</a>
<a name="ln3838">    ri-&gt;prefix[RIP_FILTER_IN] = NULL;</a>
<a name="ln3839"> </a>
<a name="ln3840">  if (dist-&gt;prefix[DISTRIBUTE_V4_OUT])</a>
<a name="ln3841">    {</a>
<a name="ln3842">      plist = prefix_list_lookup (AFI_IP, dist-&gt;prefix[DISTRIBUTE_V4_OUT]);</a>
<a name="ln3843">      if (plist)</a>
<a name="ln3844">	ri-&gt;prefix[RIP_FILTER_OUT] = plist;</a>
<a name="ln3845">      else</a>
<a name="ln3846">	ri-&gt;prefix[RIP_FILTER_OUT] = NULL;</a>
<a name="ln3847">    }</a>
<a name="ln3848">  else</a>
<a name="ln3849">    ri-&gt;prefix[RIP_FILTER_OUT] = NULL;</a>
<a name="ln3850">}</a>
<a name="ln3851"> </a>
<a name="ln3852">void</a>
<a name="ln3853">rip_distribute_update_interface (struct interface *ifp)</a>
<a name="ln3854">{</a>
<a name="ln3855">  struct distribute *dist;</a>
<a name="ln3856"> </a>
<a name="ln3857">  dist = distribute_lookup (ifp-&gt;name);</a>
<a name="ln3858">  if (dist)</a>
<a name="ln3859">    rip_distribute_update (dist);</a>
<a name="ln3860">}</a>
<a name="ln3861"> </a>
<a name="ln3862">/* Update all interface's distribute list. */</a>
<a name="ln3863">/* ARGSUSED */</a>
<a name="ln3864">static void</a>
<a name="ln3865">rip_distribute_update_all (struct prefix_list *notused)</a>
<a name="ln3866">{</a>
<a name="ln3867">  struct interface *ifp;</a>
<a name="ln3868">  struct listnode *node, *nnode;</a>
<a name="ln3869"> </a>
<a name="ln3870">  for (ALL_LIST_ELEMENTS (iflist, node, nnode, ifp))</a>
<a name="ln3871">    rip_distribute_update_interface (ifp);</a>
<a name="ln3872">}</a>
<a name="ln3873">/* ARGSUSED */</a>
<a name="ln3874">static void</a>
<a name="ln3875">rip_distribute_update_all_wrapper(const char *unused)</a>
<a name="ln3876">{</a>
<a name="ln3877">        rip_distribute_update_all(NULL);</a>
<a name="ln3878">}</a>
<a name="ln3879"> </a>
<a name="ln3880">/* Delete all added rip route. */</a>
<a name="ln3881">void</a>
<a name="ln3882">rip_clean (void)</a>
<a name="ln3883">{</a>
<a name="ln3884">  int i;</a>
<a name="ln3885">  struct route_node *rp;</a>
<a name="ln3886">  struct rip_info *rinfo = NULL;</a>
<a name="ln3887">  struct list *list = NULL;</a>
<a name="ln3888">  struct listnode *listnode = NULL;</a>
<a name="ln3889"> </a>
<a name="ln3890">  if (rip)</a>
<a name="ln3891">    {</a>
<a name="ln3892">      /* Clear RIP routes */</a>
<a name="ln3893">      for (rp = route_top (rip-&gt;table); rp; rp = route_next (rp))</a>
<a name="ln3894">        if ((list = rp-&gt;info) != NULL)</a>
<a name="ln3895">          {</a>
<a name="ln3896">            rinfo = listgetdata (listhead (list));</a>
<a name="ln3897">            if (rip_route_rte (rinfo))</a>
<a name="ln3898">              rip_zebra_ipv4_delete (rp);</a>
<a name="ln3899"> </a>
<a name="ln3900">            for (ALL_LIST_ELEMENTS_RO (list, listnode, rinfo))</a>
<a name="ln3901">              {</a>
<a name="ln3902">                RIP_TIMER_OFF (rinfo-&gt;t_timeout);</a>
<a name="ln3903">                RIP_TIMER_OFF (rinfo-&gt;t_garbage_collect);</a>
<a name="ln3904">                rip_info_free (rinfo);</a>
<a name="ln3905">              }</a>
<a name="ln3906">            list_delete (list);</a>
<a name="ln3907">            rp-&gt;info = NULL;</a>
<a name="ln3908">            route_unlock_node (rp);</a>
<a name="ln3909">          }</a>
<a name="ln3910"> </a>
<a name="ln3911">      /* Cancel RIP related timers. */</a>
<a name="ln3912">      RIP_TIMER_OFF (rip-&gt;t_update);</a>
<a name="ln3913">      RIP_TIMER_OFF (rip-&gt;t_triggered_update);</a>
<a name="ln3914">      RIP_TIMER_OFF (rip-&gt;t_triggered_interval);</a>
<a name="ln3915"> </a>
<a name="ln3916">      /* Cancel read thread. */</a>
<a name="ln3917">      if (rip-&gt;t_read)</a>
<a name="ln3918">	{</a>
<a name="ln3919">	  thread_cancel (rip-&gt;t_read);</a>
<a name="ln3920">	  rip-&gt;t_read = NULL;</a>
<a name="ln3921">	}</a>
<a name="ln3922"> </a>
<a name="ln3923">      /* Close RIP socket. */</a>
<a name="ln3924">      if (rip-&gt;sock &gt;= 0)</a>
<a name="ln3925">	{</a>
<a name="ln3926">	  close (rip-&gt;sock);</a>
<a name="ln3927">	  rip-&gt;sock = -1;</a>
<a name="ln3928">	}</a>
<a name="ln3929"> </a>
<a name="ln3930">      /* Static RIP route configuration. */</a>
<a name="ln3931">      for (rp = route_top (rip-&gt;route); rp; rp = route_next (rp))</a>
<a name="ln3932">	if (rp-&gt;info)</a>
<a name="ln3933">	  {</a>
<a name="ln3934">	    rp-&gt;info = NULL;</a>
<a name="ln3935">	    route_unlock_node (rp);</a>
<a name="ln3936">	  }</a>
<a name="ln3937"> </a>
<a name="ln3938">      /* RIP neighbor configuration. */</a>
<a name="ln3939">      for (rp = route_top (rip-&gt;neighbor); rp; rp = route_next (rp))</a>
<a name="ln3940">	if (rp-&gt;info)</a>
<a name="ln3941">	  {</a>
<a name="ln3942">	    rp-&gt;info = NULL;</a>
<a name="ln3943">	    route_unlock_node (rp);</a>
<a name="ln3944">	  }</a>
<a name="ln3945"> </a>
<a name="ln3946">      /* Redistribute related clear. */</a>
<a name="ln3947">      if (rip-&gt;default_information_route_map)</a>
<a name="ln3948">	free (rip-&gt;default_information_route_map);</a>
<a name="ln3949"> </a>
<a name="ln3950">      for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln3951">	if (rip-&gt;route_map[i].name)</a>
<a name="ln3952">	  free (rip-&gt;route_map[i].name);</a>
<a name="ln3953"> </a>
<a name="ln3954">      XFREE (MTYPE_ROUTE_TABLE, rip-&gt;table);</a>
<a name="ln3955">      XFREE (MTYPE_ROUTE_TABLE, rip-&gt;route);</a>
<a name="ln3956">      XFREE (MTYPE_ROUTE_TABLE, rip-&gt;neighbor);</a>
<a name="ln3957">      </a>
<a name="ln3958">      XFREE (MTYPE_RIP, rip);</a>
<a name="ln3959">      rip = NULL;</a>
<a name="ln3960">    }</a>
<a name="ln3961"> </a>
<a name="ln3962">  rip_clean_network ();</a>
<a name="ln3963">  rip_passive_nondefault_clean ();</a>
<a name="ln3964">  rip_offset_clean ();</a>
<a name="ln3965">  rip_interfaces_clean ();</a>
<a name="ln3966">  rip_distance_reset ();</a>
<a name="ln3967">  rip_redistribute_clean ();</a>
<a name="ln3968">}</a>
<a name="ln3969"> </a>
<a name="ln3970">/* Reset all values to the default settings. */</a>
<a name="ln3971">void</a>
<a name="ln3972">rip_reset (void)</a>
<a name="ln3973">{</a>
<a name="ln3974">  /* Reset global counters. */</a>
<a name="ln3975">  rip_global_route_changes = 0;</a>
<a name="ln3976">  rip_global_queries = 0;</a>
<a name="ln3977"> </a>
<a name="ln3978">  /* Call ripd related reset functions. */</a>
<a name="ln3979">  rip_debug_reset ();</a>
<a name="ln3980">  rip_route_map_reset ();</a>
<a name="ln3981"> </a>
<a name="ln3982">  /* Call library reset functions. */</a>
<a name="ln3983">  vty_reset ();</a>
<a name="ln3984">  access_list_reset ();</a>
<a name="ln3985">  prefix_list_reset ();</a>
<a name="ln3986"> </a>
<a name="ln3987">  distribute_list_reset ();</a>
<a name="ln3988"> </a>
<a name="ln3989">  rip_interfaces_reset ();</a>
<a name="ln3990">  rip_distance_reset ();</a>
<a name="ln3991"> </a>
<a name="ln3992">  rip_zclient_reset ();</a>
<a name="ln3993">}</a>
<a name="ln3994"> </a>
<a name="ln3995">static void</a>
<a name="ln3996">rip_if_rmap_update (struct if_rmap *if_rmap)</a>
<a name="ln3997">{</a>
<a name="ln3998">  struct interface *ifp;</a>
<a name="ln3999">  struct rip_interface *ri;</a>
<a name="ln4000">  struct route_map *rmap;</a>
<a name="ln4001"> </a>
<a name="ln4002">  ifp = if_lookup_by_name (if_rmap-&gt;ifname);</a>
<a name="ln4003">  if (ifp == NULL)</a>
<a name="ln4004">    return;</a>
<a name="ln4005"> </a>
<a name="ln4006">  ri = ifp-&gt;info;</a>
<a name="ln4007"> </a>
<a name="ln4008">  if (if_rmap-&gt;routemap[IF_RMAP_IN])</a>
<a name="ln4009">    {</a>
<a name="ln4010">      rmap = route_map_lookup_by_name (if_rmap-&gt;routemap[IF_RMAP_IN]);</a>
<a name="ln4011">      if (rmap)</a>
<a name="ln4012">	ri-&gt;routemap[IF_RMAP_IN] = rmap;</a>
<a name="ln4013">      else</a>
<a name="ln4014">	ri-&gt;routemap[IF_RMAP_IN] = NULL;</a>
<a name="ln4015">    }</a>
<a name="ln4016">  else</a>
<a name="ln4017">    ri-&gt;routemap[RIP_FILTER_IN] = NULL;</a>
<a name="ln4018"> </a>
<a name="ln4019">  if (if_rmap-&gt;routemap[IF_RMAP_OUT])</a>
<a name="ln4020">    {</a>
<a name="ln4021">      rmap = route_map_lookup_by_name (if_rmap-&gt;routemap[IF_RMAP_OUT]);</a>
<a name="ln4022">      if (rmap)</a>
<a name="ln4023">	ri-&gt;routemap[IF_RMAP_OUT] = rmap;</a>
<a name="ln4024">      else</a>
<a name="ln4025">	ri-&gt;routemap[IF_RMAP_OUT] = NULL;</a>
<a name="ln4026">    }</a>
<a name="ln4027">  else</a>
<a name="ln4028">    ri-&gt;routemap[RIP_FILTER_OUT] = NULL;</a>
<a name="ln4029">}</a>
<a name="ln4030"> </a>
<a name="ln4031">void</a>
<a name="ln4032">rip_if_rmap_update_interface (struct interface *ifp)</a>
<a name="ln4033">{</a>
<a name="ln4034">  struct if_rmap *if_rmap;</a>
<a name="ln4035"> </a>
<a name="ln4036">  if_rmap = if_rmap_lookup (ifp-&gt;name);</a>
<a name="ln4037">  if (if_rmap)</a>
<a name="ln4038">    rip_if_rmap_update (if_rmap);</a>
<a name="ln4039">}</a>
<a name="ln4040"> </a>
<a name="ln4041">static void</a>
<a name="ln4042">rip_routemap_update_redistribute (void)</a>
<a name="ln4043">{</a>
<a name="ln4044">  int i;</a>
<a name="ln4045"> </a>
<a name="ln4046">  if (rip)</a>
<a name="ln4047">    {</a>
<a name="ln4048">      for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++) </a>
<a name="ln4049">	{</a>
<a name="ln4050">	  if (rip-&gt;route_map[i].name)</a>
<a name="ln4051">	    rip-&gt;route_map[i].map = </a>
<a name="ln4052">	      route_map_lookup_by_name (rip-&gt;route_map[i].name);</a>
<a name="ln4053">	}</a>
<a name="ln4054">    }</a>
<a name="ln4055">}</a>
<a name="ln4056"> </a>
<a name="ln4057">/* ARGSUSED */</a>
<a name="ln4058">static void</a>
<a name="ln4059">rip_routemap_update (const char *notused)</a>
<a name="ln4060">{</a>
<a name="ln4061">  struct interface *ifp;</a>
<a name="ln4062">  struct listnode *node, *nnode;</a>
<a name="ln4063"> </a>
<a name="ln4064">  for (ALL_LIST_ELEMENTS (iflist, node, nnode, ifp))</a>
<a name="ln4065">    rip_if_rmap_update_interface (ifp);</a>
<a name="ln4066"> </a>
<a name="ln4067">  rip_routemap_update_redistribute ();</a>
<a name="ln4068">}</a>
<a name="ln4069"> </a>
<a name="ln4070">/* Allocate new rip structure and set default value. */</a>
<a name="ln4071">void</a>
<a name="ln4072">rip_init (void)</a>
<a name="ln4073">{</a>
<a name="ln4074">  /* Randomize for triggered update random(). */</a>
<a name="ln4075">  srandom (time (NULL));</a>
<a name="ln4076"> </a>
<a name="ln4077">  /* Install top nodes. */</a>
<a name="ln4078">  install_node (&amp;rip_node, config_write_rip);</a>
<a name="ln4079"> </a>
<a name="ln4080">  /* Install rip commands. */</a>
<a name="ln4081">  install_element (VIEW_NODE, &amp;show_ip_rip_cmd);</a>
<a name="ln4082">  install_element (VIEW_NODE, &amp;show_ip_rip_status_cmd);</a>
<a name="ln4083">  install_element (CONFIG_NODE, &amp;router_rip_cmd);</a>
<a name="ln4084">  install_element (CONFIG_NODE, &amp;no_router_rip_cmd);</a>
<a name="ln4085"> </a>
<a name="ln4086">  install_default (RIP_NODE);</a>
<a name="ln4087">  install_element (RIP_NODE, &amp;rip_version_cmd);</a>
<a name="ln4088">  install_element (RIP_NODE, &amp;no_rip_version_cmd);</a>
<a name="ln4089">  install_element (RIP_NODE, &amp;no_rip_version_val_cmd);</a>
<a name="ln4090">  install_element (RIP_NODE, &amp;rip_default_metric_cmd);</a>
<a name="ln4091">  install_element (RIP_NODE, &amp;no_rip_default_metric_cmd);</a>
<a name="ln4092">  install_element (RIP_NODE, &amp;no_rip_default_metric_val_cmd);</a>
<a name="ln4093">  install_element (RIP_NODE, &amp;rip_timers_cmd);</a>
<a name="ln4094">  install_element (RIP_NODE, &amp;no_rip_timers_cmd);</a>
<a name="ln4095">  install_element (RIP_NODE, &amp;no_rip_timers_val_cmd);</a>
<a name="ln4096">  install_element (RIP_NODE, &amp;rip_route_cmd);</a>
<a name="ln4097">  install_element (RIP_NODE, &amp;no_rip_route_cmd);</a>
<a name="ln4098">  install_element (RIP_NODE, &amp;rip_distance_cmd);</a>
<a name="ln4099">  install_element (RIP_NODE, &amp;no_rip_distance_cmd);</a>
<a name="ln4100">  install_element (RIP_NODE, &amp;rip_distance_source_cmd);</a>
<a name="ln4101">  install_element (RIP_NODE, &amp;no_rip_distance_source_cmd);</a>
<a name="ln4102">  install_element (RIP_NODE, &amp;rip_distance_source_access_list_cmd);</a>
<a name="ln4103">  install_element (RIP_NODE, &amp;no_rip_distance_source_access_list_cmd);</a>
<a name="ln4104">  install_element (RIP_NODE, &amp;rip_allow_ecmp_cmd);</a>
<a name="ln4105">  install_element (RIP_NODE, &amp;no_rip_allow_ecmp_cmd);</a>
<a name="ln4106"> </a>
<a name="ln4107">  /* Debug related init. */</a>
<a name="ln4108">  rip_debug_init ();</a>
<a name="ln4109"> </a>
<a name="ln4110">  /* SNMP init. */</a>
<a name="ln4111">#ifdef HAVE_SNMP</a>
<a name="ln4112">  rip_snmp_init ();</a>
<a name="ln4113">#endif /* HAVE_SNMP */</a>
<a name="ln4114"> </a>
<a name="ln4115">  /* Access list install. */</a>
<a name="ln4116">  access_list_init ();</a>
<a name="ln4117">  access_list_add_hook (rip_distribute_update_all_wrapper);</a>
<a name="ln4118">  access_list_delete_hook (rip_distribute_update_all_wrapper);</a>
<a name="ln4119"> </a>
<a name="ln4120">  /* Prefix list initialize.*/</a>
<a name="ln4121">  prefix_list_init ();</a>
<a name="ln4122">  prefix_list_add_hook (rip_distribute_update_all);</a>
<a name="ln4123">  prefix_list_delete_hook (rip_distribute_update_all);</a>
<a name="ln4124"> </a>
<a name="ln4125">  /* Distribute list install. */</a>
<a name="ln4126">  distribute_list_init (RIP_NODE);</a>
<a name="ln4127">  distribute_list_add_hook (rip_distribute_update);</a>
<a name="ln4128">  distribute_list_delete_hook (rip_distribute_update);</a>
<a name="ln4129"> </a>
<a name="ln4130">  /* Route-map */</a>
<a name="ln4131">  rip_route_map_init ();</a>
<a name="ln4132">  rip_offset_init ();</a>
<a name="ln4133"> </a>
<a name="ln4134">  route_map_add_hook (rip_routemap_update);</a>
<a name="ln4135">  route_map_delete_hook (rip_routemap_update);</a>
<a name="ln4136"> </a>
<a name="ln4137">  if_rmap_init (RIP_NODE);</a>
<a name="ln4138">  if_rmap_hook_add (rip_if_rmap_update);</a>
<a name="ln4139">  if_rmap_hook_delete (rip_if_rmap_update);</a>
<a name="ln4140"> </a>
<a name="ln4141">  /* Distance control. */</a>
<a name="ln4142">  rip_distance_table = route_table_init ();</a>
<a name="ln4143">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="750"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '4' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="750"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '5' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="750"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '6' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '7' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '8' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '9' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '10' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '11' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '12' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="751"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '13' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="752"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '14' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="752"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The '15' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="2606"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v612/" target="_blank">V612</a> An unconditional 'break' within a loop.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
