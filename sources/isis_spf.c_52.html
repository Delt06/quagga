
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_spf.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol                  - isis_spf.c</a>
<a name="ln3"> *                                              The SPT algorithm</a>
<a name="ln4"> *</a>
<a name="ln5"> * Copyright (C) 2001,2002   Sampo Saaristo</a>
<a name="ln6"> *                           Tampere University of Technology      </a>
<a name="ln7"> *                           Institute of Communications Engineering</a>
<a name="ln8"> *</a>
<a name="ln9"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln10"> * under the terms of the GNU General Public Licenseas published by the Free </a>
<a name="ln11"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln12"> * any later version.</a>
<a name="ln13"> *</a>
<a name="ln14"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln15"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln16"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln17"> * more details.</a>
<a name="ln18"> </a>
<a name="ln19"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln20"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln21"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;thread.h&quot;</a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;vty.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;command.h&quot;</a>
<a name="ln31">#include &quot;memory.h&quot;</a>
<a name="ln32">#include &quot;prefix.h&quot;</a>
<a name="ln33">#include &quot;hash.h&quot;</a>
<a name="ln34">#include &quot;if.h&quot;</a>
<a name="ln35">#include &quot;table.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;isis_constants.h&quot;</a>
<a name="ln38">#include &quot;isis_common.h&quot;</a>
<a name="ln39">#include &quot;isis_flags.h&quot;</a>
<a name="ln40">#include &quot;dict.h&quot;</a>
<a name="ln41">#include &quot;isisd.h&quot;</a>
<a name="ln42">#include &quot;isis_misc.h&quot;</a>
<a name="ln43">#include &quot;isis_adjacency.h&quot;</a>
<a name="ln44">#include &quot;isis_circuit.h&quot;</a>
<a name="ln45">#include &quot;isis_tlv.h&quot;</a>
<a name="ln46">#include &quot;isis_pdu.h&quot;</a>
<a name="ln47">#include &quot;isis_lsp.h&quot;</a>
<a name="ln48">#include &quot;isis_dynhn.h&quot;</a>
<a name="ln49">#include &quot;isis_spf.h&quot;</a>
<a name="ln50">#include &quot;isis_route.h&quot;</a>
<a name="ln51">#include &quot;isis_csm.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">int isis_run_spf_l1 (struct thread *thread);</a>
<a name="ln54">int isis_run_spf_l2 (struct thread *thread);</a>
<a name="ln55"> </a>
<a name="ln56">/* 7.2.7 */</a>
<a name="ln57">static void</a>
<a name="ln58">remove_excess_adjs (struct list *adjs)</a>
<a name="ln59">{</a>
<a name="ln60">  struct listnode *node, *excess = NULL;</a>
<a name="ln61">  struct isis_adjacency *adj, *candidate = NULL;</a>
<a name="ln62">  int comp;</a>
<a name="ln63"> </a>
<a name="ln64">  for (ALL_LIST_ELEMENTS_RO (adjs, node, adj)) </a>
<a name="ln65">    {</a>
<a name="ln66">      if (excess == NULL)</a>
<a name="ln67">	excess = node;</a>
<a name="ln68">      candidate = listgetdata (excess);</a>
<a name="ln69"> </a>
<a name="ln70">      if (candidate-&gt;sys_type &lt; adj-&gt;sys_type)</a>
<a name="ln71">	{</a>
<a name="ln72">	  excess = node;</a>
<a name="ln73">	  candidate = adj;</a>
<a name="ln74">	  continue;</a>
<a name="ln75">	}</a>
<a name="ln76">      if (candidate-&gt;sys_type &gt; adj-&gt;sys_type)</a>
<a name="ln77">	continue;</a>
<a name="ln78"> </a>
<a name="ln79">      comp = memcmp (candidate-&gt;sysid, adj-&gt;sysid, ISIS_SYS_ID_LEN);</a>
<a name="ln80">      if (comp &gt; 0)</a>
<a name="ln81">	{</a>
<a name="ln82">	  excess = node;</a>
<a name="ln83">	  candidate = adj;</a>
<a name="ln84">	  continue;</a>
<a name="ln85">	}</a>
<a name="ln86">      if (comp &lt; 0)</a>
<a name="ln87">	continue;</a>
<a name="ln88"> </a>
<a name="ln89">      if (candidate-&gt;circuit-&gt;circuit_id &gt; adj-&gt;circuit-&gt;circuit_id)</a>
<a name="ln90">	{</a>
<a name="ln91">	  excess = node;</a>
<a name="ln92">	  candidate = adj;</a>
<a name="ln93">	  continue;</a>
<a name="ln94">	}</a>
<a name="ln95"> </a>
<a name="ln96">      if (candidate-&gt;circuit-&gt;circuit_id &lt; adj-&gt;circuit-&gt;circuit_id)</a>
<a name="ln97">	continue;</a>
<a name="ln98"> </a>
<a name="ln99">      comp = memcmp (candidate-&gt;snpa, adj-&gt;snpa, ETH_ALEN);</a>
<a name="ln100">      if (comp &gt; 0)</a>
<a name="ln101">	{</a>
<a name="ln102">	  excess = node;</a>
<a name="ln103">	  candidate = adj;</a>
<a name="ln104">	  continue;</a>
<a name="ln105">	}</a>
<a name="ln106">    }</a>
<a name="ln107"> </a>
<a name="ln108">  list_delete_node (adjs, excess);</a>
<a name="ln109"> </a>
<a name="ln110">  return;</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">static const char *</a>
<a name="ln114">vtype2string (enum vertextype vtype)</a>
<a name="ln115">{</a>
<a name="ln116">  switch (vtype)</a>
<a name="ln117">    {</a>
<a name="ln118">    case VTYPE_PSEUDO_IS:</a>
<a name="ln119">      return &quot;pseudo_IS&quot;;</a>
<a name="ln120">      break;</a>
<a name="ln121">    case VTYPE_PSEUDO_TE_IS:</a>
<a name="ln122">      return &quot;pseudo_TE-IS&quot;;</a>
<a name="ln123">      break;</a>
<a name="ln124">    case VTYPE_NONPSEUDO_IS:</a>
<a name="ln125">      return &quot;IS&quot;;</a>
<a name="ln126">      break;</a>
<a name="ln127">    case VTYPE_NONPSEUDO_TE_IS:</a>
<a name="ln128">      return &quot;TE-IS&quot;;</a>
<a name="ln129">      break;</a>
<a name="ln130">    case VTYPE_ES:</a>
<a name="ln131">      return &quot;ES&quot;;</a>
<a name="ln132">      break;</a>
<a name="ln133">    case VTYPE_IPREACH_INTERNAL:</a>
<a name="ln134">      return &quot;IP internal&quot;;</a>
<a name="ln135">      break;</a>
<a name="ln136">    case VTYPE_IPREACH_EXTERNAL:</a>
<a name="ln137">      return &quot;IP external&quot;;</a>
<a name="ln138">      break;</a>
<a name="ln139">    case VTYPE_IPREACH_TE:</a>
<a name="ln140">      return &quot;IP TE&quot;;</a>
<a name="ln141">      break;</a>
<a name="ln142">#ifdef HAVE_IPV6</a>
<a name="ln143">    case VTYPE_IP6REACH_INTERNAL:</a>
<a name="ln144">      return &quot;IP6 internal&quot;;</a>
<a name="ln145">      break;</a>
<a name="ln146">    case VTYPE_IP6REACH_EXTERNAL:</a>
<a name="ln147">      return &quot;IP6 external&quot;;</a>
<a name="ln148">      break;</a>
<a name="ln149">#endif /* HAVE_IPV6 */</a>
<a name="ln150">    default:</a>
<a name="ln151">      return &quot;UNKNOWN&quot;;</a>
<a name="ln152">    }</a>
<a name="ln153">  return NULL;			/* Not reached */</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">static const char *</a>
<a name="ln157">vid2string (struct isis_vertex *vertex, u_char * buff)</a>
<a name="ln158">{</a>
<a name="ln159">  switch (vertex-&gt;type)</a>
<a name="ln160">    {</a>
<a name="ln161">    case VTYPE_PSEUDO_IS:</a>
<a name="ln162">    case VTYPE_PSEUDO_TE_IS:</a>
<a name="ln163">      return print_sys_hostname (vertex-&gt;N.id);</a>
<a name="ln164">      break;</a>
<a name="ln165">    case VTYPE_NONPSEUDO_IS:</a>
<a name="ln166">    case VTYPE_NONPSEUDO_TE_IS:</a>
<a name="ln167">    case VTYPE_ES:</a>
<a name="ln168">      return print_sys_hostname (vertex-&gt;N.id);</a>
<a name="ln169">      break;</a>
<a name="ln170">    case VTYPE_IPREACH_INTERNAL:</a>
<a name="ln171">    case VTYPE_IPREACH_EXTERNAL:</a>
<a name="ln172">    case VTYPE_IPREACH_TE:</a>
<a name="ln173">#ifdef HAVE_IPV6</a>
<a name="ln174">    case VTYPE_IP6REACH_INTERNAL:</a>
<a name="ln175">    case VTYPE_IP6REACH_EXTERNAL:</a>
<a name="ln176">#endif /* HAVE_IPV6 */</a>
<a name="ln177">      prefix2str ((struct prefix *) &amp;vertex-&gt;N.prefix, (char *) buff, BUFSIZ);</a>
<a name="ln178">      break;</a>
<a name="ln179">    default:</a>
<a name="ln180">      return &quot;UNKNOWN&quot;;</a>
<a name="ln181">    }</a>
<a name="ln182"> </a>
<a name="ln183">  return (char *) buff;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">static struct isis_vertex *</a>
<a name="ln187">isis_vertex_new (void *id, enum vertextype vtype)</a>
<a name="ln188">{</a>
<a name="ln189">  struct isis_vertex *vertex;</a>
<a name="ln190"> </a>
<a name="ln191">  vertex = XCALLOC (MTYPE_ISIS_VERTEX, sizeof (struct isis_vertex));</a>
<a name="ln192"> </a>
<a name="ln193">  vertex-&gt;type = vtype;</a>
<a name="ln194">  switch (vtype)</a>
<a name="ln195">    {</a>
<a name="ln196">    case VTYPE_ES:</a>
<a name="ln197">    case VTYPE_NONPSEUDO_IS:</a>
<a name="ln198">    case VTYPE_NONPSEUDO_TE_IS:</a>
<a name="ln199">      memcpy (vertex-&gt;N.id, (u_char *) id, ISIS_SYS_ID_LEN);</a>
<a name="ln200">      break;</a>
<a name="ln201">    case VTYPE_PSEUDO_IS:</a>
<a name="ln202">    case VTYPE_PSEUDO_TE_IS:</a>
<a name="ln203">      memcpy (vertex-&gt;N.id, (u_char *) id, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln204">      break;</a>
<a name="ln205">    case VTYPE_IPREACH_INTERNAL:</a>
<a name="ln206">    case VTYPE_IPREACH_EXTERNAL:</a>
<a name="ln207">    case VTYPE_IPREACH_TE:</a>
<a name="ln208">#ifdef HAVE_IPV6</a>
<a name="ln209">    case VTYPE_IP6REACH_INTERNAL:</a>
<a name="ln210">    case VTYPE_IP6REACH_EXTERNAL:</a>
<a name="ln211">#endif /* HAVE_IPV6 */</a>
<a name="ln212">      memcpy (&amp;vertex-&gt;N.prefix, (struct prefix *) id,</a>
<a name="ln213">	      sizeof (struct prefix));</a>
<a name="ln214">      break;</a>
<a name="ln215">    default:</a>
<a name="ln216">      zlog_err (&quot;WTF!&quot;);</a>
<a name="ln217">    }</a>
<a name="ln218"> </a>
<a name="ln219">  vertex-&gt;Adj_N = list_new ();</a>
<a name="ln220">  vertex-&gt;parents = list_new ();</a>
<a name="ln221">  vertex-&gt;children = list_new ();</a>
<a name="ln222"> </a>
<a name="ln223">  return vertex;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">static void</a>
<a name="ln227">isis_vertex_del (struct isis_vertex *vertex)</a>
<a name="ln228">{</a>
<a name="ln229">  list_delete (vertex-&gt;Adj_N);</a>
<a name="ln230">  vertex-&gt;Adj_N = NULL;</a>
<a name="ln231">  list_delete (vertex-&gt;parents);</a>
<a name="ln232">  vertex-&gt;parents = NULL;</a>
<a name="ln233">  list_delete (vertex-&gt;children);</a>
<a name="ln234">  vertex-&gt;children = NULL;</a>
<a name="ln235"> </a>
<a name="ln236">  memset(vertex, 0, sizeof(struct isis_vertex));</a>
<a name="ln237">  XFREE (MTYPE_ISIS_VERTEX, vertex);</a>
<a name="ln238"> </a>
<a name="ln239">  return;</a>
<a name="ln240">}</a>
<a name="ln241"> </a>
<a name="ln242">static void</a>
<a name="ln243">isis_vertex_adj_del (struct isis_vertex *vertex, struct isis_adjacency *adj)</a>
<a name="ln244">{</a>
<a name="ln245">  struct listnode *node, *nextnode;</a>
<a name="ln246">  if (!vertex)</a>
<a name="ln247">    return;</a>
<a name="ln248">  for (node = listhead (vertex-&gt;Adj_N); node; node = nextnode)</a>
<a name="ln249">  {</a>
<a name="ln250">    nextnode = listnextnode(node);</a>
<a name="ln251">    if (listgetdata(node) == adj)</a>
<a name="ln252">      list_delete_node(vertex-&gt;Adj_N, node);</a>
<a name="ln253">  }</a>
<a name="ln254">  return;</a>
<a name="ln255">}</a>
<a name="ln256"> </a>
<a name="ln257">struct isis_spftree *</a>
<a name="ln258">isis_spftree_new (struct isis_area *area)</a>
<a name="ln259">{</a>
<a name="ln260">  struct isis_spftree *tree;</a>
<a name="ln261"> </a>
<a name="ln262">  tree = XCALLOC (MTYPE_ISIS_SPFTREE, sizeof (struct isis_spftree));</a>
<a name="ln263">  if (tree == NULL)</a>
<a name="ln264">    {</a>
<a name="ln265">      zlog_err (&quot;ISIS-Spf: isis_spftree_new Out of memory!&quot;);</a>
<a name="ln266">      return NULL;</a>
<a name="ln267">    }</a>
<a name="ln268"> </a>
<a name="ln269">  tree-&gt;tents = list_new ();</a>
<a name="ln270">  tree-&gt;paths = list_new ();</a>
<a name="ln271">  tree-&gt;area = area;</a>
<a name="ln272">  tree-&gt;last_run_timestamp = 0;</a>
<a name="ln273">  tree-&gt;last_run_duration = 0;</a>
<a name="ln274">  tree-&gt;runcount = 0;</a>
<a name="ln275">  tree-&gt;pending = 0;</a>
<a name="ln276">  return tree;</a>
<a name="ln277">}</a>
<a name="ln278"> </a>
<a name="ln279">void</a>
<a name="ln280">isis_spftree_del (struct isis_spftree *spftree)</a>
<a name="ln281">{</a>
<a name="ln282">  THREAD_TIMER_OFF (spftree-&gt;t_spf);</a>
<a name="ln283"> </a>
<a name="ln284">  spftree-&gt;tents-&gt;del = (void (*)(void *)) isis_vertex_del;</a>
<a name="ln285">  list_delete (spftree-&gt;tents);</a>
<a name="ln286">  spftree-&gt;tents = NULL;</a>
<a name="ln287"> </a>
<a name="ln288">  spftree-&gt;paths-&gt;del = (void (*)(void *)) isis_vertex_del;</a>
<a name="ln289">  list_delete (spftree-&gt;paths);</a>
<a name="ln290">  spftree-&gt;paths = NULL;</a>
<a name="ln291"> </a>
<a name="ln292">  XFREE (MTYPE_ISIS_SPFTREE, spftree);</a>
<a name="ln293"> </a>
<a name="ln294">  return;</a>
<a name="ln295">}</a>
<a name="ln296"> </a>
<a name="ln297">void</a>
<a name="ln298">isis_spftree_adj_del (struct isis_spftree *spftree, struct isis_adjacency *adj)</a>
<a name="ln299">{</a>
<a name="ln300">  struct listnode *node;</a>
<a name="ln301">  if (!adj)</a>
<a name="ln302">    return;</a>
<a name="ln303">  for (node = listhead (spftree-&gt;tents); node; node = listnextnode (node))</a>
<a name="ln304">    isis_vertex_adj_del (listgetdata (node), adj);</a>
<a name="ln305">  for (node = listhead (spftree-&gt;paths); node; node = listnextnode (node))</a>
<a name="ln306">    isis_vertex_adj_del (listgetdata (node), adj);</a>
<a name="ln307">  return;</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">void</a>
<a name="ln311">spftree_area_init (struct isis_area *area)</a>
<a name="ln312">{</a>
<a name="ln313">  if (area-&gt;is_type &amp; IS_LEVEL_1)</a>
<a name="ln314">  {</a>
<a name="ln315">    if (area-&gt;spftree[0] == NULL)</a>
<a name="ln316">      area-&gt;spftree[0] = isis_spftree_new (area);</a>
<a name="ln317">#ifdef HAVE_IPV6</a>
<a name="ln318">    if (area-&gt;spftree6[0] == NULL)</a>
<a name="ln319">      area-&gt;spftree6[0] = isis_spftree_new (area);</a>
<a name="ln320">#endif</a>
<a name="ln321">  }</a>
<a name="ln322"> </a>
<a name="ln323">  if (area-&gt;is_type &amp; IS_LEVEL_2)</a>
<a name="ln324">  {</a>
<a name="ln325">    if (area-&gt;spftree[1] == NULL)</a>
<a name="ln326">      area-&gt;spftree[1] = isis_spftree_new (area);</a>
<a name="ln327">#ifdef HAVE_IPV6</a>
<a name="ln328">    if (area-&gt;spftree6[1] == NULL)</a>
<a name="ln329">      area-&gt;spftree6[1] = isis_spftree_new (area);</a>
<a name="ln330">#endif</a>
<a name="ln331">  }</a>
<a name="ln332"> </a>
<a name="ln333">  return;</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">void</a>
<a name="ln337">spftree_area_del (struct isis_area *area)</a>
<a name="ln338">{</a>
<a name="ln339">  if (area-&gt;is_type &amp; IS_LEVEL_1)</a>
<a name="ln340">  {</a>
<a name="ln341">    if (area-&gt;spftree[0] != NULL)</a>
<a name="ln342">    {</a>
<a name="ln343">      isis_spftree_del (area-&gt;spftree[0]);</a>
<a name="ln344">      area-&gt;spftree[0] = NULL;</a>
<a name="ln345">    }</a>
<a name="ln346">#ifdef HAVE_IPV6</a>
<a name="ln347">    if (area-&gt;spftree6[0])</a>
<a name="ln348">    {</a>
<a name="ln349">      isis_spftree_del (area-&gt;spftree6[0]);</a>
<a name="ln350">      area-&gt;spftree6[0] = NULL;</a>
<a name="ln351">    }</a>
<a name="ln352">#endif</a>
<a name="ln353">  }</a>
<a name="ln354"> </a>
<a name="ln355">  if (area-&gt;is_type &amp; IS_LEVEL_2)</a>
<a name="ln356">  {</a>
<a name="ln357">    if (area-&gt;spftree[1] != NULL)</a>
<a name="ln358">    {</a>
<a name="ln359">      isis_spftree_del (area-&gt;spftree[1]);</a>
<a name="ln360">      area-&gt;spftree[1] = NULL;</a>
<a name="ln361">    }</a>
<a name="ln362">#ifdef HAVE_IPV6</a>
<a name="ln363">    if (area-&gt;spftree6[1] != NULL)</a>
<a name="ln364">    {</a>
<a name="ln365">      isis_spftree_del (area-&gt;spftree6[1]);</a>
<a name="ln366">      area-&gt;spftree6[1] = NULL;</a>
<a name="ln367">    }</a>
<a name="ln368">#endif</a>
<a name="ln369">  }</a>
<a name="ln370"> </a>
<a name="ln371">  return;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">void</a>
<a name="ln375">spftree_area_adj_del (struct isis_area *area, struct isis_adjacency *adj)</a>
<a name="ln376">{</a>
<a name="ln377">  if (area-&gt;is_type &amp; IS_LEVEL_1)</a>
<a name="ln378">  {</a>
<a name="ln379">    if (area-&gt;spftree[0] != NULL)</a>
<a name="ln380">      isis_spftree_adj_del (area-&gt;spftree[0], adj);</a>
<a name="ln381">#ifdef HAVE_IPV6</a>
<a name="ln382">    if (area-&gt;spftree6[0] != NULL)</a>
<a name="ln383">      isis_spftree_adj_del (area-&gt;spftree6[0], adj);</a>
<a name="ln384">#endif</a>
<a name="ln385">  }</a>
<a name="ln386"> </a>
<a name="ln387">  if (area-&gt;is_type &amp; IS_LEVEL_2)</a>
<a name="ln388">  {</a>
<a name="ln389">    if (area-&gt;spftree[1] != NULL)</a>
<a name="ln390">      isis_spftree_adj_del (area-&gt;spftree[1], adj);</a>
<a name="ln391">#ifdef HAVE_IPV6</a>
<a name="ln392">    if (area-&gt;spftree6[1] != NULL)</a>
<a name="ln393">      isis_spftree_adj_del (area-&gt;spftree6[1], adj);</a>
<a name="ln394">#endif</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397">  return;</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">/* </a>
<a name="ln401"> * Find the system LSP: returns the LSP in our LSP database </a>
<a name="ln402"> * associated with the given system ID.</a>
<a name="ln403"> */</a>
<a name="ln404">static struct isis_lsp *</a>
<a name="ln405">isis_root_system_lsp (struct isis_area *area, int level, u_char *sysid)</a>
<a name="ln406">{</a>
<a name="ln407">  struct isis_lsp *lsp;</a>
<a name="ln408">  u_char lspid[ISIS_SYS_ID_LEN + 2];</a>
<a name="ln409"> </a>
<a name="ln410">  memcpy (lspid, sysid, ISIS_SYS_ID_LEN);</a>
<a name="ln411">  LSP_PSEUDO_ID (lspid) = 0;</a>
<a name="ln412">  LSP_FRAGMENT (lspid) = 0;</a>
<a name="ln413">  lsp = lsp_search (lspid, area-&gt;lspdb[level - 1]);</a>
<a name="ln414">  if (lsp &amp;&amp; lsp-&gt;lsp_header-&gt;rem_lifetime != 0)</a>
<a name="ln415">    return lsp;</a>
<a name="ln416">  return NULL;</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">/*</a>
<a name="ln420"> * Add this IS to the root of SPT</a>
<a name="ln421"> */</a>
<a name="ln422">static struct isis_vertex *</a>
<a name="ln423">isis_spf_add_root (struct isis_spftree *spftree, int level, u_char *sysid)</a>
<a name="ln424">{</a>
<a name="ln425">  struct isis_vertex *vertex;</a>
<a name="ln426">  struct isis_lsp *lsp;</a>
<a name="ln427">#ifdef EXTREME_DEBUG</a>
<a name="ln428">  u_char buff[BUFSIZ];</a>
<a name="ln429">#endif /* EXTREME_DEBUG */</a>
<a name="ln430"> </a>
<a name="ln431">  lsp = isis_root_system_lsp (spftree-&gt;area, level, sysid);</a>
<a name="ln432">  if (lsp == NULL)</a>
<a name="ln433">    zlog_warn (&quot;ISIS-Spf: could not find own l%d LSP!&quot;, level);</a>
<a name="ln434"> </a>
<a name="ln435">  if (!spftree-&gt;area-&gt;oldmetric)</a>
<a name="ln436">    vertex = isis_vertex_new (sysid, VTYPE_NONPSEUDO_TE_IS);</a>
<a name="ln437">  else</a>
<a name="ln438">    vertex = isis_vertex_new (sysid, VTYPE_NONPSEUDO_IS);</a>
<a name="ln439"> </a>
<a name="ln440">  listnode_add (spftree-&gt;paths, vertex);</a>
<a name="ln441"> </a>
<a name="ln442">#ifdef EXTREME_DEBUG</a>
<a name="ln443">  zlog_debug (&quot;ISIS-Spf: added this IS  %s %s depth %d dist %d to PATHS&quot;,</a>
<a name="ln444">	      vtype2string (vertex-&gt;type), vid2string (vertex, buff),</a>
<a name="ln445">	      vertex-&gt;depth, vertex-&gt;d_N);</a>
<a name="ln446">#endif /* EXTREME_DEBUG */</a>
<a name="ln447"> </a>
<a name="ln448">  return vertex;</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">static struct isis_vertex *</a>
<a name="ln452">isis_find_vertex (struct list *list, void *id, enum vertextype vtype)</a>
<a name="ln453">{</a>
<a name="ln454">  struct listnode *node;</a>
<a name="ln455">  struct isis_vertex *vertex;</a>
<a name="ln456">  struct prefix *p1, *p2;</a>
<a name="ln457"> </a>
<a name="ln458">  for (ALL_LIST_ELEMENTS_RO (list, node, vertex))</a>
<a name="ln459">    {</a>
<a name="ln460">      if (vertex-&gt;type != vtype)</a>
<a name="ln461">	continue;</a>
<a name="ln462">      switch (vtype)</a>
<a name="ln463">	{</a>
<a name="ln464">	case VTYPE_ES:</a>
<a name="ln465">	case VTYPE_NONPSEUDO_IS:</a>
<a name="ln466">	case VTYPE_NONPSEUDO_TE_IS:</a>
<a name="ln467">	  if (memcmp ((u_char *) id, vertex-&gt;N.id, ISIS_SYS_ID_LEN) == 0)</a>
<a name="ln468">	    return vertex;</a>
<a name="ln469">	  break;</a>
<a name="ln470">	case VTYPE_PSEUDO_IS:</a>
<a name="ln471">	case VTYPE_PSEUDO_TE_IS:</a>
<a name="ln472">	  if (memcmp ((u_char *) id, vertex-&gt;N.id, ISIS_SYS_ID_LEN + 1) == 0)</a>
<a name="ln473">	    return vertex;</a>
<a name="ln474">	  break;</a>
<a name="ln475">	case VTYPE_IPREACH_INTERNAL:</a>
<a name="ln476">	case VTYPE_IPREACH_EXTERNAL:</a>
<a name="ln477">	case VTYPE_IPREACH_TE:</a>
<a name="ln478">#ifdef HAVE_IPV6</a>
<a name="ln479">	case VTYPE_IP6REACH_INTERNAL:</a>
<a name="ln480">	case VTYPE_IP6REACH_EXTERNAL:</a>
<a name="ln481">#endif /* HAVE_IPV6 */</a>
<a name="ln482">	  p1 = (struct prefix *) id;</a>
<a name="ln483">	  p2 = (struct prefix *) &amp;vertex-&gt;N.id;</a>
<a name="ln484">	  if (p1-&gt;family == p2-&gt;family &amp;&amp; p1-&gt;prefixlen == p2-&gt;prefixlen &amp;&amp;</a>
<a name="ln485">	      memcmp (&amp;p1-&gt;u.prefix, &amp;p2-&gt;u.prefix,</a>
<a name="ln486">		      PSIZE (p1-&gt;prefixlen)) == 0)</a>
<a name="ln487">	    return vertex;</a>
<a name="ln488">	  break;</a>
<a name="ln489">	}</a>
<a name="ln490">    }</a>
<a name="ln491"> </a>
<a name="ln492">  return NULL;</a>
<a name="ln493">}</a>
<a name="ln494"> </a>
<a name="ln495">/*</a>
<a name="ln496"> * Add a vertex to TENT sorted by cost and by vertextype on tie break situation</a>
<a name="ln497"> */</a>
<a name="ln498">static struct isis_vertex *</a>
<a name="ln499">isis_spf_add2tent (struct isis_spftree *spftree, enum vertextype vtype,</a>
<a name="ln500">		   void *id, uint32_t cost, int depth, int family,</a>
<a name="ln501">		   struct isis_adjacency *adj, struct isis_vertex *parent)</a>
<a name="ln502">{</a>
<a name="ln503">  struct isis_vertex *vertex, *v;</a>
<a name="ln504">  struct listnode *node;</a>
<a name="ln505">  struct isis_adjacency *parent_adj;</a>
<a name="ln506">#ifdef EXTREME_DEBUG</a>
<a name="ln507">  u_char buff[BUFSIZ];</a>
<a name="ln508">#endif</a>
<a name="ln509"> </a>
<a name="ln510">  assert (isis_find_vertex (spftree-&gt;paths, id, vtype) == NULL);</a>
<a name="ln511">  assert (isis_find_vertex (spftree-&gt;tents, id, vtype) == NULL);</a>
<a name="ln512">  vertex = isis_vertex_new (id, vtype);</a>
<a name="ln513">  vertex-&gt;d_N = cost;</a>
<a name="ln514">  vertex-&gt;depth = depth;</a>
<a name="ln515"> </a>
<a name="ln516">  if (parent) {</a>
<a name="ln517">    listnode_add (vertex-&gt;parents, parent);</a>
<a name="ln518">    if (listnode_lookup (parent-&gt;children, vertex) == NULL)</a>
<a name="ln519">      listnode_add (parent-&gt;children, vertex);</a>
<a name="ln520">  }</a>
<a name="ln521"> </a>
<a name="ln522">  if (parent &amp;&amp; parent-&gt;Adj_N &amp;&amp; listcount(parent-&gt;Adj_N) &gt; 0) {</a>
<a name="ln523">    for (ALL_LIST_ELEMENTS_RO (parent-&gt;Adj_N, node, parent_adj))</a>
<a name="ln524">      listnode_add (vertex-&gt;Adj_N, parent_adj);</a>
<a name="ln525">  } else if (adj) {</a>
<a name="ln526">    listnode_add (vertex-&gt;Adj_N, adj);</a>
<a name="ln527">  }</a>
<a name="ln528"> </a>
<a name="ln529">#ifdef EXTREME_DEBUG</a>
<a name="ln530">  zlog_debug (&quot;ISIS-Spf: add to TENT %s %s %s depth %d dist %d adjcount %d&quot;,</a>
<a name="ln531">              print_sys_hostname (vertex-&gt;N.id),</a>
<a name="ln532">	      vtype2string (vertex-&gt;type), vid2string (vertex, buff),</a>
<a name="ln533">	      vertex-&gt;depth, vertex-&gt;d_N, listcount(vertex-&gt;Adj_N));</a>
<a name="ln534">#endif /* EXTREME_DEBUG */</a>
<a name="ln535"> </a>
<a name="ln536">  if (list_isempty (spftree-&gt;tents))</a>
<a name="ln537">    {</a>
<a name="ln538">      listnode_add (spftree-&gt;tents, vertex);</a>
<a name="ln539">      return vertex;</a>
<a name="ln540">    }</a>
<a name="ln541"> </a>
<a name="ln542">  /* XXX: This cant use the standard ALL_LIST_ELEMENTS macro */</a>
<a name="ln543">  for (node = listhead (spftree-&gt;tents); node; node = listnextnode (node))</a>
<a name="ln544">    {</a>
<a name="ln545">      v = listgetdata (node);</a>
<a name="ln546">      if (v-&gt;d_N &gt; vertex-&gt;d_N)</a>
<a name="ln547">	{</a>
<a name="ln548">	  list_add_node_prev (spftree-&gt;tents, node, vertex);</a>
<a name="ln549">	  break;</a>
<a name="ln550">	}</a>
<a name="ln551">      else if (v-&gt;d_N == vertex-&gt;d_N &amp;&amp; v-&gt;type &gt; vertex-&gt;type)</a>
<a name="ln552">	{</a>
<a name="ln553">	  /*  Tie break, add according to type */</a>
<a name="ln554">          list_add_node_prev (spftree-&gt;tents, node, vertex);</a>
<a name="ln555">	  break;</a>
<a name="ln556">	}</a>
<a name="ln557">    }</a>
<a name="ln558"> </a>
<a name="ln559">  if (node == NULL)</a>
<a name="ln560">      listnode_add (spftree-&gt;tents, vertex);</a>
<a name="ln561"> </a>
<a name="ln562">  return vertex;</a>
<a name="ln563">}</a>
<a name="ln564"> </a>
<a name="ln565">static void</a>
<a name="ln566">isis_spf_add_local (struct isis_spftree *spftree, enum vertextype vtype,</a>
<a name="ln567">		    void *id, struct isis_adjacency *adj, uint32_t cost,</a>
<a name="ln568">		    int family, struct isis_vertex *parent)</a>
<a name="ln569">{</a>
<a name="ln570">  struct isis_vertex *vertex;</a>
<a name="ln571"> </a>
<a name="ln572">  vertex = isis_find_vertex (spftree-&gt;tents, id, vtype);</a>
<a name="ln573"> </a>
<a name="ln574">  if (vertex)</a>
<a name="ln575">    {</a>
<a name="ln576">      /* C.2.5   c) */</a>
<a name="ln577">      if (vertex-&gt;d_N == cost)</a>
<a name="ln578">	{</a>
<a name="ln579">	  if (adj)</a>
<a name="ln580">	    listnode_add (vertex-&gt;Adj_N, adj);</a>
<a name="ln581">	  /*       d) */</a>
<a name="ln582">	  if (listcount (vertex-&gt;Adj_N) &gt; ISIS_MAX_PATH_SPLITS)</a>
<a name="ln583">	    remove_excess_adjs (vertex-&gt;Adj_N);</a>
<a name="ln584">	  if (parent &amp;&amp; (listnode_lookup (vertex-&gt;parents, parent) == NULL))</a>
<a name="ln585">	    listnode_add (vertex-&gt;parents, parent);</a>
<a name="ln586">	  if (parent &amp;&amp; (listnode_lookup (parent-&gt;children, vertex) == NULL))</a>
<a name="ln587">	    listnode_add (parent-&gt;children, vertex);</a>
<a name="ln588">	  return;</a>
<a name="ln589">	}</a>
<a name="ln590">      else if (vertex-&gt;d_N &lt; cost)</a>
<a name="ln591">	{</a>
<a name="ln592">	  /*       e) do nothing */</a>
<a name="ln593">	  return;</a>
<a name="ln594">	}</a>
<a name="ln595">      else {  /* vertex-&gt;d_N &gt; cost */</a>
<a name="ln596">	  /*         f) */</a>
<a name="ln597">	  struct listnode *pnode, *pnextnode;</a>
<a name="ln598">	  struct isis_vertex *pvertex;</a>
<a name="ln599">	  listnode_delete (spftree-&gt;tents, vertex);</a>
<a name="ln600">	  assert (listcount (vertex-&gt;children) == 0);</a>
<a name="ln601">	  for (ALL_LIST_ELEMENTS (vertex-&gt;parents, pnode, pnextnode, pvertex))</a>
<a name="ln602">	    listnode_delete(pvertex-&gt;children, vertex);</a>
<a name="ln603">	  isis_vertex_del (vertex);</a>
<a name="ln604">      }</a>
<a name="ln605">    }</a>
<a name="ln606"> </a>
<a name="ln607">  isis_spf_add2tent (spftree, vtype, id, cost, 1, family, adj, parent);</a>
<a name="ln608">  return;</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">static void</a>
<a name="ln612">process_N (struct isis_spftree *spftree, enum vertextype vtype, void *id,</a>
<a name="ln613">	   uint32_t dist, uint16_t depth, int family,</a>
<a name="ln614">	   struct isis_vertex *parent)</a>
<a name="ln615">{</a>
<a name="ln616">  struct isis_vertex *vertex;</a>
<a name="ln617">#ifdef EXTREME_DEBUG</a>
<a name="ln618">  u_char buff[255];</a>
<a name="ln619">#endif</a>
<a name="ln620"> </a>
<a name="ln621">  assert (spftree &amp;&amp; parent);</a>
<a name="ln622"> </a>
<a name="ln623">  /* RFC3787 section 5.1 */</a>
<a name="ln624">  if (spftree-&gt;area-&gt;newmetric == 1)</a>
<a name="ln625">    {</a>
<a name="ln626">      if (dist &gt; MAX_WIDE_PATH_METRIC)</a>
<a name="ln627">        return;</a>
<a name="ln628">    }</a>
<a name="ln629">  /* C.2.6 b)    */</a>
<a name="ln630">  else if (spftree-&gt;area-&gt;oldmetric == 1)</a>
<a name="ln631">    {</a>
<a name="ln632">      if (dist &gt; MAX_NARROW_PATH_METRIC)</a>
<a name="ln633">        return;</a>
<a name="ln634">    }</a>
<a name="ln635"> </a>
<a name="ln636">  /*       c)    */</a>
<a name="ln637">  vertex = isis_find_vertex (spftree-&gt;paths, id, vtype);</a>
<a name="ln638">  if (vertex)</a>
<a name="ln639">    {</a>
<a name="ln640">#ifdef EXTREME_DEBUG</a>
<a name="ln641">      zlog_debug (&quot;ISIS-Spf: process_N %s %s %s dist %d already found from PATH&quot;,</a>
<a name="ln642">	          print_sys_hostname (vertex-&gt;N.id),</a>
<a name="ln643">		  vtype2string (vtype), vid2string (vertex, buff), dist);</a>
<a name="ln644">#endif /* EXTREME_DEBUG */</a>
<a name="ln645">      assert (dist &gt;= vertex-&gt;d_N);</a>
<a name="ln646">      return;</a>
<a name="ln647">    }</a>
<a name="ln648"> </a>
<a name="ln649">  vertex = isis_find_vertex (spftree-&gt;tents, id, vtype);</a>
<a name="ln650">  /*       d)    */</a>
<a name="ln651">  if (vertex)</a>
<a name="ln652">    {</a>
<a name="ln653">      /*        1) */</a>
<a name="ln654">#ifdef EXTREME_DEBUG</a>
<a name="ln655">      zlog_debug (&quot;ISIS-Spf: process_N %s %s %s dist %d parent %s adjcount %d&quot;,</a>
<a name="ln656">	          print_sys_hostname (vertex-&gt;N.id),</a>
<a name="ln657">                  vtype2string (vtype), vid2string (vertex, buff), dist,</a>
<a name="ln658">                  (parent ? print_sys_hostname (parent-&gt;N.id) : &quot;null&quot;),</a>
<a name="ln659">                  (parent ? listcount (parent-&gt;Adj_N) : 0));</a>
<a name="ln660">#endif /* EXTREME_DEBUG */</a>
<a name="ln661">      if (vertex-&gt;d_N == dist)</a>
<a name="ln662">	{</a>
<a name="ln663">	  struct listnode *node;</a>
<a name="ln664">	  struct isis_adjacency *parent_adj;</a>
<a name="ln665">	  for (ALL_LIST_ELEMENTS_RO (parent-&gt;Adj_N, node, parent_adj))</a>
<a name="ln666">	    if (listnode_lookup(vertex-&gt;Adj_N, parent_adj) == NULL)</a>
<a name="ln667">	      listnode_add (vertex-&gt;Adj_N, parent_adj);</a>
<a name="ln668">	  /*      2) */</a>
<a name="ln669">	  if (listcount (vertex-&gt;Adj_N) &gt; ISIS_MAX_PATH_SPLITS)</a>
<a name="ln670">	    remove_excess_adjs (vertex-&gt;Adj_N);</a>
<a name="ln671">	  if (listnode_lookup (vertex-&gt;parents, parent) == NULL)</a>
<a name="ln672">	    listnode_add (vertex-&gt;parents, parent);</a>
<a name="ln673">	  if (listnode_lookup (parent-&gt;children, vertex) == NULL)</a>
<a name="ln674">	    listnode_add (parent-&gt;children, vertex);</a>
<a name="ln675">	  /*      3) */</a>
<a name="ln676">	  return;</a>
<a name="ln677">	}</a>
<a name="ln678">      else if (vertex-&gt;d_N &lt; dist)</a>
<a name="ln679">	{</a>
<a name="ln680">	  return;</a>
<a name="ln681">	  /*      4) */</a>
<a name="ln682">	}</a>
<a name="ln683">      else</a>
<a name="ln684">	{</a>
<a name="ln685">	  struct listnode *pnode, *pnextnode;</a>
<a name="ln686">	  struct isis_vertex *pvertex;</a>
<a name="ln687">	  listnode_delete (spftree-&gt;tents, vertex);</a>
<a name="ln688">	  assert (listcount (vertex-&gt;children) == 0);</a>
<a name="ln689">	  for (ALL_LIST_ELEMENTS (vertex-&gt;parents, pnode, pnextnode, pvertex))</a>
<a name="ln690">	    listnode_delete(pvertex-&gt;children, vertex);</a>
<a name="ln691">	  isis_vertex_del (vertex);</a>
<a name="ln692">	}</a>
<a name="ln693">    }</a>
<a name="ln694"> </a>
<a name="ln695">#ifdef EXTREME_DEBUG</a>
<a name="ln696">  zlog_debug (&quot;ISIS-Spf: process_N add2tent %s %s dist %d parent %s&quot;,</a>
<a name="ln697">              print_sys_hostname(id), vtype2string (vtype), dist,</a>
<a name="ln698">              (parent ? print_sys_hostname (parent-&gt;N.id) : &quot;null&quot;));</a>
<a name="ln699">#endif /* EXTREME_DEBUG */</a>
<a name="ln700"> </a>
<a name="ln701">  isis_spf_add2tent (spftree, vtype, id, dist, depth, family, NULL, parent);</a>
<a name="ln702">  return;</a>
<a name="ln703">}</a>
<a name="ln704"> </a>
<a name="ln705">/*</a>
<a name="ln706"> * C.2.6 Step 1</a>
<a name="ln707"> */</a>
<a name="ln708">static int</a>
<a name="ln709">isis_spf_process_lsp (struct isis_spftree *spftree, struct isis_lsp *lsp,</a>
<a name="ln710">		      uint32_t cost, uint16_t depth, int family,</a>
<a name="ln711">		      u_char *root_sysid, struct isis_vertex *parent)</a>
<a name="ln712">{</a>
<a name="ln713">  struct listnode *node, *fragnode = NULL;</a>
<a name="ln714">  uint32_t dist;</a>
<a name="ln715">  struct is_neigh *is_neigh;</a>
<a name="ln716">  struct te_is_neigh *te_is_neigh;</a>
<a name="ln717">  struct ipv4_reachability *ipreach;</a>
<a name="ln718">  struct te_ipv4_reachability *te_ipv4_reach;</a>
<a name="ln719">  enum vertextype vtype;</a>
<a name="ln720">  struct prefix prefix;</a>
<a name="ln721">#ifdef HAVE_IPV6</a>
<a name="ln722">  struct ipv6_reachability *ip6reach;</a>
<a name="ln723">#endif /* HAVE_IPV6 */</a>
<a name="ln724">  static const u_char null_sysid[ISIS_SYS_ID_LEN];</a>
<a name="ln725"> </a>
<a name="ln726">  if (!speaks (lsp-&gt;tlv_data.nlpids, family))</a>
<a name="ln727">    return ISIS_OK;</a>
<a name="ln728"> </a>
<a name="ln729">lspfragloop:</a>
<a name="ln730">  if (lsp-&gt;lsp_header-&gt;seq_num == 0)</a>
<a name="ln731">    {</a>
<a name="ln732">      zlog_warn (&quot;isis_spf_process_lsp(): lsp with 0 seq_num - ignore&quot;);</a>
<a name="ln733">      return ISIS_WARNING;</a>
<a name="ln734">    }</a>
<a name="ln735"> </a>
<a name="ln736">#ifdef EXTREME_DEBUG</a>
<a name="ln737">      zlog_debug (&quot;ISIS-Spf: process_lsp %s&quot;, print_sys_hostname(lsp-&gt;lsp_header-&gt;lsp_id));</a>
<a name="ln738">#endif /* EXTREME_DEBUG */</a>
<a name="ln739"> </a>
<a name="ln740">  if (!ISIS_MASK_LSP_OL_BIT (lsp-&gt;lsp_header-&gt;lsp_bits))</a>
<a name="ln741">  {</a>
<a name="ln742">    if (lsp-&gt;tlv_data.is_neighs)</a>
<a name="ln743">    {</a>
<a name="ln744">      for (ALL_LIST_ELEMENTS_RO (lsp-&gt;tlv_data.is_neighs, node, is_neigh))</a>
<a name="ln745">      {</a>
<a name="ln746">        /* C.2.6 a) */</a>
<a name="ln747">        /* Two way connectivity */</a>
<a name="ln748">        if (!memcmp (is_neigh-&gt;neigh_id, root_sysid, ISIS_SYS_ID_LEN))</a>
<a name="ln749">          continue;</a>
<a name="ln750">        if (!memcmp (is_neigh-&gt;neigh_id, null_sysid, ISIS_SYS_ID_LEN))</a>
<a name="ln751">          continue;</a>
<a name="ln752">        dist = cost + is_neigh-&gt;metrics.metric_default;</a>
<a name="ln753">        vtype = LSP_PSEUDO_ID (is_neigh-&gt;neigh_id) ? VTYPE_PSEUDO_IS</a>
<a name="ln754">          : VTYPE_NONPSEUDO_IS;</a>
<a name="ln755">        process_N (spftree, vtype, (void *) is_neigh-&gt;neigh_id, dist,</a>
<a name="ln756">            depth + 1, family, parent);</a>
<a name="ln757">      }</a>
<a name="ln758">    }</a>
<a name="ln759">    if (lsp-&gt;tlv_data.te_is_neighs)</a>
<a name="ln760">    {</a>
<a name="ln761">      for (ALL_LIST_ELEMENTS_RO (lsp-&gt;tlv_data.te_is_neighs, node,</a>
<a name="ln762">            te_is_neigh))</a>
<a name="ln763">      {</a>
<a name="ln764">        if (!memcmp (te_is_neigh-&gt;neigh_id, root_sysid, ISIS_SYS_ID_LEN))</a>
<a name="ln765">          continue;</a>
<a name="ln766">        if (!memcmp (te_is_neigh-&gt;neigh_id, null_sysid, ISIS_SYS_ID_LEN))</a>
<a name="ln767">          continue;</a>
<a name="ln768">        dist = cost + GET_TE_METRIC(te_is_neigh);</a>
<a name="ln769">        vtype = LSP_PSEUDO_ID (te_is_neigh-&gt;neigh_id) ? VTYPE_PSEUDO_TE_IS</a>
<a name="ln770">          : VTYPE_NONPSEUDO_TE_IS;</a>
<a name="ln771">        process_N (spftree, vtype, (void *) te_is_neigh-&gt;neigh_id, dist,</a>
<a name="ln772">            depth + 1, family, parent);</a>
<a name="ln773">      }</a>
<a name="ln774">    }</a>
<a name="ln775">  }</a>
<a name="ln776"> </a>
<a name="ln777">  if (family == AF_INET &amp;&amp; lsp-&gt;tlv_data.ipv4_int_reachs)</a>
<a name="ln778">  {</a>
<a name="ln779">    prefix.family = AF_INET;</a>
<a name="ln780">    for (ALL_LIST_ELEMENTS_RO (lsp-&gt;tlv_data.ipv4_int_reachs, node, ipreach))</a>
<a name="ln781">    {</a>
<a name="ln782">      dist = cost + ipreach-&gt;metrics.metric_default;</a>
<a name="ln783">      vtype = VTYPE_IPREACH_INTERNAL;</a>
<a name="ln784">      prefix.u.prefix4 = ipreach-&gt;prefix;</a>
<a name="ln785">      prefix.prefixlen = ip_masklen (ipreach-&gt;mask);</a>
<a name="ln786">      apply_mask (&amp;prefix);</a>
<a name="ln787">      process_N (spftree, vtype, (void *) &amp;prefix, dist, depth + 1,</a>
<a name="ln788">                 family, parent);</a>
<a name="ln789">    }</a>
<a name="ln790">  }</a>
<a name="ln791">  if (family == AF_INET &amp;&amp; lsp-&gt;tlv_data.ipv4_ext_reachs)</a>
<a name="ln792">  {</a>
<a name="ln793">    prefix.family = AF_INET;</a>
<a name="ln794">    for (ALL_LIST_ELEMENTS_RO (lsp-&gt;tlv_data.ipv4_ext_reachs, node, ipreach))</a>
<a name="ln795">    {</a>
<a name="ln796">      dist = cost + ipreach-&gt;metrics.metric_default;</a>
<a name="ln797">      vtype = VTYPE_IPREACH_EXTERNAL;</a>
<a name="ln798">      prefix.u.prefix4 = ipreach-&gt;prefix;</a>
<a name="ln799">      prefix.prefixlen = ip_masklen (ipreach-&gt;mask);</a>
<a name="ln800">      apply_mask (&amp;prefix);</a>
<a name="ln801">      process_N (spftree, vtype, (void *) &amp;prefix, dist, depth + 1,</a>
<a name="ln802">                 family, parent);</a>
<a name="ln803">    }</a>
<a name="ln804">  }</a>
<a name="ln805">  if (family == AF_INET &amp;&amp; lsp-&gt;tlv_data.te_ipv4_reachs)</a>
<a name="ln806">  {</a>
<a name="ln807">    prefix.family = AF_INET;</a>
<a name="ln808">    for (ALL_LIST_ELEMENTS_RO (lsp-&gt;tlv_data.te_ipv4_reachs,</a>
<a name="ln809">                               node, te_ipv4_reach))</a>
<a name="ln810">    {</a>
<a name="ln811">      assert ((te_ipv4_reach-&gt;control &amp; 0x3F) &lt;= IPV4_MAX_BITLEN);</a>
<a name="ln812"> </a>
<a name="ln813">      dist = cost + ntohl (te_ipv4_reach-&gt;te_metric);</a>
<a name="ln814">      vtype = VTYPE_IPREACH_TE;</a>
<a name="ln815">      prefix.u.prefix4 = newprefix2inaddr (&amp;te_ipv4_reach-&gt;prefix_start,</a>
<a name="ln816">                                           te_ipv4_reach-&gt;control);</a>
<a name="ln817">      prefix.prefixlen = (te_ipv4_reach-&gt;control &amp; 0x3F);</a>
<a name="ln818">      apply_mask (&amp;prefix);</a>
<a name="ln819">      process_N (spftree, vtype, (void *) &amp;prefix, dist, depth + 1,</a>
<a name="ln820">                 family, parent);</a>
<a name="ln821">    }</a>
<a name="ln822">  }</a>
<a name="ln823">#ifdef HAVE_IPV6</a>
<a name="ln824">  if (family == AF_INET6 &amp;&amp; lsp-&gt;tlv_data.ipv6_reachs)</a>
<a name="ln825">  {</a>
<a name="ln826">    prefix.family = AF_INET6;</a>
<a name="ln827">    for (ALL_LIST_ELEMENTS_RO (lsp-&gt;tlv_data.ipv6_reachs, node, ip6reach))</a>
<a name="ln828">    {</a>
<a name="ln829">      assert (ip6reach-&gt;prefix_len &lt;= IPV6_MAX_BITLEN);</a>
<a name="ln830"> </a>
<a name="ln831">      dist = cost + ntohl(ip6reach-&gt;metric);</a>
<a name="ln832">      vtype = (ip6reach-&gt;control_info &amp; CTRL_INFO_DISTRIBUTION) ?</a>
<a name="ln833">        VTYPE_IP6REACH_EXTERNAL : VTYPE_IP6REACH_INTERNAL;</a>
<a name="ln834">      prefix.prefixlen = ip6reach-&gt;prefix_len;</a>
<a name="ln835">      memcpy (&amp;prefix.u.prefix6.s6_addr, ip6reach-&gt;prefix,</a>
<a name="ln836">              PSIZE (ip6reach-&gt;prefix_len));</a>
<a name="ln837">      apply_mask (&amp;prefix);</a>
<a name="ln838">      process_N (spftree, vtype, (void *) &amp;prefix, dist, depth + 1,</a>
<a name="ln839">                 family, parent);</a>
<a name="ln840">    }</a>
<a name="ln841">  }</a>
<a name="ln842">#endif /* HAVE_IPV6 */</a>
<a name="ln843"> </a>
<a name="ln844">  if (fragnode == NULL)</a>
<a name="ln845">    fragnode = listhead (lsp-&gt;lspu.frags);</a>
<a name="ln846">  else</a>
<a name="ln847">    fragnode = listnextnode (fragnode);</a>
<a name="ln848"> </a>
<a name="ln849">  if (fragnode)</a>
<a name="ln850">    {</a>
<a name="ln851">      lsp = listgetdata (fragnode);</a>
<a name="ln852">      goto lspfragloop;</a>
<a name="ln853">    }</a>
<a name="ln854"> </a>
<a name="ln855">  return ISIS_OK;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">static int</a>
<a name="ln859">isis_spf_process_pseudo_lsp (struct isis_spftree *spftree,</a>
<a name="ln860">			     struct isis_lsp *lsp, uint32_t cost,</a>
<a name="ln861">			     uint16_t depth, int family,</a>
<a name="ln862">			     u_char *root_sysid,</a>
<a name="ln863">			     struct isis_vertex *parent)</a>
<a name="ln864">{</a>
<a name="ln865">  struct listnode *node, *fragnode = NULL;</a>
<a name="ln866">  struct is_neigh *is_neigh;</a>
<a name="ln867">  struct te_is_neigh *te_is_neigh;</a>
<a name="ln868">  enum vertextype vtype;</a>
<a name="ln869">  uint32_t dist;</a>
<a name="ln870"> </a>
<a name="ln871">pseudofragloop:</a>
<a name="ln872"> </a>
<a name="ln873">  if (lsp-&gt;lsp_header-&gt;seq_num == 0)</a>
<a name="ln874">    {</a>
<a name="ln875">      zlog_warn (&quot;isis_spf_process_pseudo_lsp(): lsp with 0 seq_num&quot;</a>
<a name="ln876">		 &quot; - do not process&quot;);</a>
<a name="ln877">      return ISIS_WARNING;</a>
<a name="ln878">    }</a>
<a name="ln879"> </a>
<a name="ln880">#ifdef EXTREME_DEBUG</a>
<a name="ln881">      zlog_debug (&quot;ISIS-Spf: process_pseudo_lsp %s&quot;,</a>
<a name="ln882">                  print_sys_hostname(lsp-&gt;lsp_header-&gt;lsp_id));</a>
<a name="ln883">#endif /* EXTREME_DEBUG */</a>
<a name="ln884"> </a>
<a name="ln885">  /* RFC3787 section 4 SHOULD ignore overload bit in pseudo LSPs */</a>
<a name="ln886"> </a>
<a name="ln887">  if (lsp-&gt;tlv_data.is_neighs)</a>
<a name="ln888">    for (ALL_LIST_ELEMENTS_RO (lsp-&gt;tlv_data.is_neighs, node, is_neigh))</a>
<a name="ln889">      {</a>
<a name="ln890">	/* Two way connectivity */</a>
<a name="ln891">	if (!memcmp (is_neigh-&gt;neigh_id, root_sysid, ISIS_SYS_ID_LEN))</a>
<a name="ln892">	  continue;</a>
<a name="ln893">        dist = cost + is_neigh-&gt;metrics.metric_default;</a>
<a name="ln894">        vtype = LSP_PSEUDO_ID (is_neigh-&gt;neigh_id) ? VTYPE_PSEUDO_IS</a>
<a name="ln895">          : VTYPE_NONPSEUDO_IS;</a>
<a name="ln896">        process_N (spftree, vtype, (void *) is_neigh-&gt;neigh_id, dist,</a>
<a name="ln897">            depth + 1, family, parent);</a>
<a name="ln898">      }</a>
<a name="ln899">  if (lsp-&gt;tlv_data.te_is_neighs)</a>
<a name="ln900">    for (ALL_LIST_ELEMENTS_RO (lsp-&gt;tlv_data.te_is_neighs, node, te_is_neigh))</a>
<a name="ln901">      {</a>
<a name="ln902">	/* Two way connectivity */</a>
<a name="ln903">	if (!memcmp (te_is_neigh-&gt;neigh_id, root_sysid, ISIS_SYS_ID_LEN))</a>
<a name="ln904">	  continue;</a>
<a name="ln905">        dist = cost + GET_TE_METRIC(te_is_neigh);</a>
<a name="ln906">        vtype = LSP_PSEUDO_ID (te_is_neigh-&gt;neigh_id) ? VTYPE_PSEUDO_TE_IS</a>
<a name="ln907">          : VTYPE_NONPSEUDO_TE_IS;</a>
<a name="ln908">        process_N (spftree, vtype, (void *) te_is_neigh-&gt;neigh_id, dist,</a>
<a name="ln909">            depth + 1, family, parent);</a>
<a name="ln910">      }</a>
<a name="ln911"> </a>
<a name="ln912">  if (fragnode == NULL)</a>
<a name="ln913">    fragnode = listhead (lsp-&gt;lspu.frags);</a>
<a name="ln914">  else</a>
<a name="ln915">    fragnode = listnextnode (fragnode);</a>
<a name="ln916"> </a>
<a name="ln917">  if (fragnode)</a>
<a name="ln918">    {</a>
<a name="ln919">      lsp = listgetdata (fragnode);</a>
<a name="ln920">      goto pseudofragloop;</a>
<a name="ln921">    }</a>
<a name="ln922"> </a>
<a name="ln923">  return ISIS_OK;</a>
<a name="ln924">}</a>
<a name="ln925"> </a>
<a name="ln926">static int</a>
<a name="ln927">isis_spf_preload_tent (struct isis_spftree *spftree, int level,</a>
<a name="ln928">		       int family, u_char *root_sysid,</a>
<a name="ln929">		       struct isis_vertex *parent)</a>
<a name="ln930">{</a>
<a name="ln931">  struct isis_circuit *circuit;</a>
<a name="ln932">  struct listnode *cnode, *anode, *ipnode;</a>
<a name="ln933">  struct isis_adjacency *adj;</a>
<a name="ln934">  struct isis_lsp *lsp;</a>
<a name="ln935">  struct list *adj_list;</a>
<a name="ln936">  struct list *adjdb;</a>
<a name="ln937">  struct prefix_ipv4 *ipv4;</a>
<a name="ln938">  struct prefix prefix;</a>
<a name="ln939">  int retval = ISIS_OK;</a>
<a name="ln940">  u_char lsp_id[ISIS_SYS_ID_LEN + 2];</a>
<a name="ln941">  static u_char null_lsp_id[ISIS_SYS_ID_LEN + 2];</a>
<a name="ln942">#ifdef HAVE_IPV6</a>
<a name="ln943">  struct prefix_ipv6 *ipv6;</a>
<a name="ln944">#endif /* HAVE_IPV6 */</a>
<a name="ln945"> </a>
<a name="ln946">  for (ALL_LIST_ELEMENTS_RO (spftree-&gt;area-&gt;circuit_list, cnode, circuit))</a>
<a name="ln947">    {</a>
<a name="ln948">      if (circuit-&gt;state != C_STATE_UP)</a>
<a name="ln949">	continue;</a>
<a name="ln950">      if (!(circuit-&gt;is_type &amp; level))</a>
<a name="ln951">	continue;</a>
<a name="ln952">      if (family == AF_INET &amp;&amp; !circuit-&gt;ip_router)</a>
<a name="ln953">	continue;</a>
<a name="ln954">#ifdef HAVE_IPV6</a>
<a name="ln955">      if (family == AF_INET6 &amp;&amp; !circuit-&gt;ipv6_router)</a>
<a name="ln956">	continue;</a>
<a name="ln957">#endif /* HAVE_IPV6 */</a>
<a name="ln958">      /* </a>
<a name="ln959">       * Add IP(v6) addresses of this circuit</a>
<a name="ln960">       */</a>
<a name="ln961">      if (family == AF_INET)</a>
<a name="ln962">	{</a>
<a name="ln963">	  prefix.family = AF_INET;</a>
<a name="ln964">          for (ALL_LIST_ELEMENTS_RO (circuit-&gt;ip_addrs, ipnode, ipv4))</a>
<a name="ln965">	    {</a>
<a name="ln966">	      prefix.u.prefix4 = ipv4-&gt;prefix;</a>
<a name="ln967">	      prefix.prefixlen = ipv4-&gt;prefixlen;</a>
<a name="ln968">              apply_mask (&amp;prefix);</a>
<a name="ln969">	      isis_spf_add_local (spftree, VTYPE_IPREACH_INTERNAL, &amp;prefix,</a>
<a name="ln970">				  NULL, 0, family, parent);</a>
<a name="ln971">	    }</a>
<a name="ln972">	}</a>
<a name="ln973">#ifdef HAVE_IPV6</a>
<a name="ln974">      if (family == AF_INET6)</a>
<a name="ln975">	{</a>
<a name="ln976">	  prefix.family = AF_INET6;</a>
<a name="ln977">	  for (ALL_LIST_ELEMENTS_RO (circuit-&gt;ipv6_non_link, ipnode, ipv6))</a>
<a name="ln978">	    {</a>
<a name="ln979">	      prefix.prefixlen = ipv6-&gt;prefixlen;</a>
<a name="ln980">	      prefix.u.prefix6 = ipv6-&gt;prefix;</a>
<a name="ln981">              apply_mask (&amp;prefix);</a>
<a name="ln982">	      isis_spf_add_local (spftree, VTYPE_IP6REACH_INTERNAL,</a>
<a name="ln983">				  &amp;prefix, NULL, 0, family, parent);</a>
<a name="ln984">	    }</a>
<a name="ln985">	}</a>
<a name="ln986">#endif /* HAVE_IPV6 */</a>
<a name="ln987">      if (circuit-&gt;circ_type == CIRCUIT_T_BROADCAST)</a>
<a name="ln988">	{</a>
<a name="ln989">	  /*</a>
<a name="ln990">	   * Add the adjacencies</a>
<a name="ln991">	   */</a>
<a name="ln992">	  adj_list = list_new ();</a>
<a name="ln993">	  adjdb = circuit-&gt;u.bc.adjdb[level - 1];</a>
<a name="ln994">	  isis_adj_build_up_list (adjdb, adj_list);</a>
<a name="ln995">	  if (listcount (adj_list) == 0)</a>
<a name="ln996">	    {</a>
<a name="ln997">	      list_delete (adj_list);</a>
<a name="ln998">	      if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln999">		zlog_debug (&quot;ISIS-Spf: no L%d adjacencies on circuit %s&quot;,</a>
<a name="ln1000">			    level, circuit-&gt;interface-&gt;name);</a>
<a name="ln1001">	      continue;</a>
<a name="ln1002">	    }</a>
<a name="ln1003">          for (ALL_LIST_ELEMENTS_RO (adj_list, anode, adj))</a>
<a name="ln1004">	    {</a>
<a name="ln1005">	      if (!speaks (&amp;adj-&gt;nlpids, family))</a>
<a name="ln1006">		  continue;</a>
<a name="ln1007">	      switch (adj-&gt;sys_type)</a>
<a name="ln1008">		{</a>
<a name="ln1009">		case ISIS_SYSTYPE_ES:</a>
<a name="ln1010">		  isis_spf_add_local (spftree, VTYPE_ES, adj-&gt;sysid, adj,</a>
<a name="ln1011">				      circuit-&gt;te_metric[level - 1],</a>
<a name="ln1012">				      family, parent);</a>
<a name="ln1013">		  break;</a>
<a name="ln1014">		case ISIS_SYSTYPE_IS:</a>
<a name="ln1015">		case ISIS_SYSTYPE_L1_IS:</a>
<a name="ln1016">		case ISIS_SYSTYPE_L2_IS:</a>
<a name="ln1017">		  isis_spf_add_local (spftree,</a>
<a name="ln1018">                                      spftree-&gt;area-&gt;oldmetric ?</a>
<a name="ln1019">                                      VTYPE_NONPSEUDO_IS :</a>
<a name="ln1020">                                      VTYPE_NONPSEUDO_TE_IS,</a>
<a name="ln1021">                                      adj-&gt;sysid, adj,</a>
<a name="ln1022">                                      circuit-&gt;te_metric[level - 1],</a>
<a name="ln1023">                                      family, parent);</a>
<a name="ln1024">		  memcpy (lsp_id, adj-&gt;sysid, ISIS_SYS_ID_LEN);</a>
<a name="ln1025">		  LSP_PSEUDO_ID (lsp_id) = 0;</a>
<a name="ln1026">		  LSP_FRAGMENT (lsp_id) = 0;</a>
<a name="ln1027">		  lsp = lsp_search (lsp_id, spftree-&gt;area-&gt;lspdb[level - 1]);</a>
<a name="ln1028">                  if (lsp == NULL || lsp-&gt;lsp_header-&gt;rem_lifetime == 0)</a>
<a name="ln1029">                    zlog_warn (&quot;ISIS-Spf: No LSP %s found for IS adjacency &quot;</a>
<a name="ln1030">                        &quot;L%d on %s (ID %u)&quot;,</a>
<a name="ln1031">			rawlspid_print (lsp_id), level,</a>
<a name="ln1032">			circuit-&gt;interface-&gt;name, circuit-&gt;circuit_id);</a>
<a name="ln1033">		  break;</a>
<a name="ln1034">		case ISIS_SYSTYPE_UNKNOWN:</a>
<a name="ln1035">		default:</a>
<a name="ln1036">		  zlog_warn (&quot;isis_spf_preload_tent unknown adj type&quot;);</a>
<a name="ln1037">		}</a>
<a name="ln1038">	    }</a>
<a name="ln1039">	  list_delete (adj_list);</a>
<a name="ln1040">	  /*</a>
<a name="ln1041">	   * Add the pseudonode </a>
<a name="ln1042">	   */</a>
<a name="ln1043">	  if (level == 1)</a>
<a name="ln1044">	    memcpy (lsp_id, circuit-&gt;u.bc.l1_desig_is, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln1045">	  else</a>
<a name="ln1046">	    memcpy (lsp_id, circuit-&gt;u.bc.l2_desig_is, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln1047">	  /* can happen during DR reboot */</a>
<a name="ln1048">	  if (memcmp (lsp_id, null_lsp_id, ISIS_SYS_ID_LEN + 1) == 0)</a>
<a name="ln1049">	    {</a>
<a name="ln1050">	      if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1051">		zlog_debug (&quot;ISIS-Spf: No L%d DR on %s (ID %d)&quot;,</a>
<a name="ln1052">		    level, circuit-&gt;interface-&gt;name, circuit-&gt;circuit_id);</a>
<a name="ln1053">	      continue;</a>
<a name="ln1054">	    }</a>
<a name="ln1055">	  adj = isis_adj_lookup (lsp_id, adjdb);</a>
<a name="ln1056">	  /* if no adj, we are the dis or error */</a>
<a name="ln1057">	  if (!adj &amp;&amp; !circuit-&gt;u.bc.is_dr[level - 1])</a>
<a name="ln1058">	    {</a>
<a name="ln1059">              zlog_warn (&quot;ISIS-Spf: No adjacency found from root &quot;</a>
<a name="ln1060">                  &quot;to L%d DR %s on %s (ID %d)&quot;,</a>
<a name="ln1061">		  level, rawlspid_print (lsp_id),</a>
<a name="ln1062">		  circuit-&gt;interface-&gt;name, circuit-&gt;circuit_id);</a>
<a name="ln1063">              continue;</a>
<a name="ln1064">	    }</a>
<a name="ln1065">	  lsp = lsp_search (lsp_id, spftree-&gt;area-&gt;lspdb[level - 1]);</a>
<a name="ln1066">	  if (lsp == NULL || lsp-&gt;lsp_header-&gt;rem_lifetime == 0)</a>
<a name="ln1067">	    {</a>
<a name="ln1068">	      zlog_warn (&quot;ISIS-Spf: No lsp (%p) found from root &quot;</a>
<a name="ln1069">                  &quot;to L%d DR %s on %s (ID %d)&quot;,</a>
<a name="ln1070">                  (void *)lsp, level, rawlspid_print (lsp_id),</a>
<a name="ln1071">                  circuit-&gt;interface-&gt;name, circuit-&gt;circuit_id);</a>
<a name="ln1072">              continue;</a>
<a name="ln1073">	    }</a>
<a name="ln1074">	  isis_spf_process_pseudo_lsp (spftree, lsp,</a>
<a name="ln1075">                                       circuit-&gt;te_metric[level - 1], 0,</a>
<a name="ln1076">                                       family, root_sysid, parent);</a>
<a name="ln1077">	}</a>
<a name="ln1078">      else if (circuit-&gt;circ_type == CIRCUIT_T_P2P)</a>
<a name="ln1079">	{</a>
<a name="ln1080">	  adj = circuit-&gt;u.p2p.neighbor;</a>
<a name="ln1081">	  if (!adj)</a>
<a name="ln1082">	    continue;</a>
<a name="ln1083">	  switch (adj-&gt;sys_type)</a>
<a name="ln1084">	    {</a>
<a name="ln1085">	    case ISIS_SYSTYPE_ES:</a>
<a name="ln1086">	      isis_spf_add_local (spftree, VTYPE_ES, adj-&gt;sysid, adj,</a>
<a name="ln1087">				  circuit-&gt;te_metric[level - 1], family,</a>
<a name="ln1088">				  parent);</a>
<a name="ln1089">	      break;</a>
<a name="ln1090">	    case ISIS_SYSTYPE_IS:</a>
<a name="ln1091">	    case ISIS_SYSTYPE_L1_IS:</a>
<a name="ln1092">	    case ISIS_SYSTYPE_L2_IS:</a>
<a name="ln1093">	      if (speaks (&amp;adj-&gt;nlpids, family))</a>
<a name="ln1094">		isis_spf_add_local (spftree,</a>
<a name="ln1095">				    spftree-&gt;area-&gt;oldmetric ?</a>
<a name="ln1096">                                    VTYPE_NONPSEUDO_IS :</a>
<a name="ln1097">				    VTYPE_NONPSEUDO_TE_IS,</a>
<a name="ln1098">                                    adj-&gt;sysid,</a>
<a name="ln1099">				    adj, circuit-&gt;te_metric[level - 1],</a>
<a name="ln1100">				    family, parent);</a>
<a name="ln1101">	      break;</a>
<a name="ln1102">	    case ISIS_SYSTYPE_UNKNOWN:</a>
<a name="ln1103">	    default:</a>
<a name="ln1104">	      zlog_warn (&quot;isis_spf_preload_tent unknown adj type&quot;);</a>
<a name="ln1105">	      break;</a>
<a name="ln1106">	    }</a>
<a name="ln1107">	}</a>
<a name="ln1108">      else if (circuit-&gt;circ_type == CIRCUIT_T_LOOPBACK)</a>
<a name="ln1109">	{</a>
<a name="ln1110">          continue;</a>
<a name="ln1111">        }</a>
<a name="ln1112">      else</a>
<a name="ln1113">	{</a>
<a name="ln1114">	  zlog_warn (&quot;isis_spf_preload_tent unsupported media&quot;);</a>
<a name="ln1115">	  retval = ISIS_WARNING;</a>
<a name="ln1116">	}</a>
<a name="ln1117">    }</a>
<a name="ln1118"> </a>
<a name="ln1119">  return retval;</a>
<a name="ln1120">}</a>
<a name="ln1121"> </a>
<a name="ln1122">/*</a>
<a name="ln1123"> * The parent(s) for vertex is set when added to TENT list</a>
<a name="ln1124"> * now we just put the child pointer(s) in place</a>
<a name="ln1125"> */</a>
<a name="ln1126">static void</a>
<a name="ln1127">add_to_paths (struct isis_spftree *spftree, struct isis_vertex *vertex,</a>
<a name="ln1128">	      int level)</a>
<a name="ln1129">{</a>
<a name="ln1130">  u_char buff[BUFSIZ];</a>
<a name="ln1131"> </a>
<a name="ln1132">  if (isis_find_vertex (spftree-&gt;paths, vertex-&gt;N.id, vertex-&gt;type))</a>
<a name="ln1133">    return;</a>
<a name="ln1134">  listnode_add (spftree-&gt;paths, vertex);</a>
<a name="ln1135"> </a>
<a name="ln1136">#ifdef EXTREME_DEBUG</a>
<a name="ln1137">  zlog_debug (&quot;ISIS-Spf: added %s %s %s depth %d dist %d to PATHS&quot;,</a>
<a name="ln1138">              print_sys_hostname (vertex-&gt;N.id),</a>
<a name="ln1139">	      vtype2string (vertex-&gt;type), vid2string (vertex, buff),</a>
<a name="ln1140">	      vertex-&gt;depth, vertex-&gt;d_N);</a>
<a name="ln1141">#endif /* EXTREME_DEBUG */</a>
<a name="ln1142"> </a>
<a name="ln1143">  if (vertex-&gt;type &gt; VTYPE_ES)</a>
<a name="ln1144">    {</a>
<a name="ln1145">      if (listcount (vertex-&gt;Adj_N) &gt; 0)</a>
<a name="ln1146">	isis_route_create ((struct prefix *) &amp;vertex-&gt;N.prefix, vertex-&gt;d_N,</a>
<a name="ln1147">			   vertex-&gt;depth, vertex-&gt;Adj_N, spftree-&gt;area, level);</a>
<a name="ln1148">      else if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1149">	zlog_debug (&quot;ISIS-Spf: no adjacencies do not install route for &quot;</a>
<a name="ln1150">                    &quot;%s depth %d dist %d&quot;, vid2string (vertex, buff),</a>
<a name="ln1151">                    vertex-&gt;depth, vertex-&gt;d_N);</a>
<a name="ln1152">    }</a>
<a name="ln1153"> </a>
<a name="ln1154">  return;</a>
<a name="ln1155">}</a>
<a name="ln1156"> </a>
<a name="ln1157">static void</a>
<a name="ln1158">init_spt (struct isis_spftree *spftree)</a>
<a name="ln1159">{</a>
<a name="ln1160">  spftree-&gt;tents-&gt;del = spftree-&gt;paths-&gt;del = (void (*)(void *)) isis_vertex_del;</a>
<a name="ln1161">  list_delete_all_node (spftree-&gt;tents);</a>
<a name="ln1162">  list_delete_all_node (spftree-&gt;paths);</a>
<a name="ln1163">  spftree-&gt;tents-&gt;del = spftree-&gt;paths-&gt;del = NULL;</a>
<a name="ln1164">  return;</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167">static int</a>
<a name="ln1168">isis_run_spf (struct isis_area *area, int level, int family, u_char *sysid)</a>
<a name="ln1169">{</a>
<a name="ln1170">  int retval = ISIS_OK;</a>
<a name="ln1171">  struct listnode *node;</a>
<a name="ln1172">  struct isis_vertex *vertex;</a>
<a name="ln1173">  struct isis_vertex *root_vertex;</a>
<a name="ln1174">  struct isis_spftree *spftree = NULL;</a>
<a name="ln1175">  u_char lsp_id[ISIS_SYS_ID_LEN + 2];</a>
<a name="ln1176">  struct isis_lsp *lsp;</a>
<a name="ln1177">  struct route_table *table = NULL;</a>
<a name="ln1178">  struct timeval time_now;</a>
<a name="ln1179">  unsigned long long start_time, end_time;</a>
<a name="ln1180"> </a>
<a name="ln1181">  /* Get time that can't roll backwards. */</a>
<a name="ln1182">  quagga_gettime(QUAGGA_CLK_MONOTONIC, &amp;time_now);</a>
<a name="ln1183">  start_time = time_now.tv_sec;</a>
<a name="ln1184">  start_time = (start_time * 1000000) + time_now.tv_usec;</a>
<a name="ln1185"> </a>
<a name="ln1186">  if (family == AF_INET)</a>
<a name="ln1187">    spftree = area-&gt;spftree[level - 1];</a>
<a name="ln1188">#ifdef HAVE_IPV6</a>
<a name="ln1189">  else if (family == AF_INET6)</a>
<a name="ln1190">    spftree = area-&gt;spftree6[level - 1];</a>
<a name="ln1191">#endif</a>
<a name="ln1192">  assert (spftree);</a>
<a name="ln1193">  assert (sysid);</a>
<a name="ln1194"> </a>
<a name="ln1195">  /* Make all routes in current route table inactive. */</a>
<a name="ln1196">  if (family == AF_INET)</a>
<a name="ln1197">    table = area-&gt;route_table[level - 1];</a>
<a name="ln1198">#ifdef HAVE_IPV6</a>
<a name="ln1199">  else if (family == AF_INET6)</a>
<a name="ln1200">    table = area-&gt;route_table6[level - 1];</a>
<a name="ln1201">#endif</a>
<a name="ln1202"> </a>
<a name="ln1203">  isis_route_invalidate_table (area, table);</a>
<a name="ln1204"> </a>
<a name="ln1205">  /*</a>
<a name="ln1206">   * C.2.5 Step 0</a>
<a name="ln1207">   */</a>
<a name="ln1208">  init_spt (spftree);</a>
<a name="ln1209">  /*              a) */</a>
<a name="ln1210">  root_vertex = isis_spf_add_root (spftree, level, sysid);</a>
<a name="ln1211">  /*              b) */</a>
<a name="ln1212">  retval = isis_spf_preload_tent (spftree, level, family, sysid, root_vertex);</a>
<a name="ln1213">  if (retval != ISIS_OK)</a>
<a name="ln1214">    {</a>
<a name="ln1215">      zlog_warn (&quot;ISIS-Spf: failed to load TENT SPF-root:%s&quot;, print_sys_hostname(sysid));</a>
<a name="ln1216">      goto out;</a>
<a name="ln1217">    }</a>
<a name="ln1218"> </a>
<a name="ln1219">  /*</a>
<a name="ln1220">   * C.2.7 Step 2</a>
<a name="ln1221">   */</a>
<a name="ln1222">  if (listcount (spftree-&gt;tents) == 0)</a>
<a name="ln1223">    {</a>
<a name="ln1224">      zlog_warn (&quot;ISIS-Spf: TENT is empty SPF-root:%s&quot;, print_sys_hostname(sysid));</a>
<a name="ln1225">      goto out;</a>
<a name="ln1226">    }</a>
<a name="ln1227"> </a>
<a name="ln1228">  while (listcount (spftree-&gt;tents) &gt; 0)</a>
<a name="ln1229">    {</a>
<a name="ln1230">      node = listhead (spftree-&gt;tents);</a>
<a name="ln1231">      vertex = listgetdata (node);</a>
<a name="ln1232"> </a>
<a name="ln1233">#ifdef EXTREME_DEBUG</a>
<a name="ln1234">  zlog_debug (&quot;ISIS-Spf: get TENT node %s %s depth %d dist %d to PATHS&quot;,</a>
<a name="ln1235">              print_sys_hostname (vertex-&gt;N.id),</a>
<a name="ln1236">	      vtype2string (vertex-&gt;type), vertex-&gt;depth, vertex-&gt;d_N);</a>
<a name="ln1237">#endif /* EXTREME_DEBUG */</a>
<a name="ln1238"> </a>
<a name="ln1239">      /* Remove from tent list and add to paths list */</a>
<a name="ln1240">      list_delete_node (spftree-&gt;tents, node);</a>
<a name="ln1241">      add_to_paths (spftree, vertex, level);</a>
<a name="ln1242">      switch (vertex-&gt;type)</a>
<a name="ln1243">        {</a>
<a name="ln1244">	case VTYPE_PSEUDO_IS:</a>
<a name="ln1245">	case VTYPE_NONPSEUDO_IS:</a>
<a name="ln1246">	case VTYPE_PSEUDO_TE_IS:</a>
<a name="ln1247">	case VTYPE_NONPSEUDO_TE_IS:</a>
<a name="ln1248">	  memcpy (lsp_id, vertex-&gt;N.id, ISIS_SYS_ID_LEN + 1);</a>
<a name="ln1249">	  LSP_FRAGMENT (lsp_id) = 0;</a>
<a name="ln1250">	  lsp = lsp_search (lsp_id, area-&gt;lspdb[level - 1]);</a>
<a name="ln1251">	  if (lsp &amp;&amp; lsp-&gt;lsp_header-&gt;rem_lifetime != 0)</a>
<a name="ln1252">	    {</a>
<a name="ln1253">	      if (LSP_PSEUDO_ID (lsp_id))</a>
<a name="ln1254">		{</a>
<a name="ln1255">		  isis_spf_process_pseudo_lsp (spftree, lsp, vertex-&gt;d_N,</a>
<a name="ln1256">					       vertex-&gt;depth, family, sysid,</a>
<a name="ln1257">					       vertex);</a>
<a name="ln1258">		}</a>
<a name="ln1259">	      else</a>
<a name="ln1260">		{</a>
<a name="ln1261">		  isis_spf_process_lsp (spftree, lsp, vertex-&gt;d_N,</a>
<a name="ln1262">					vertex-&gt;depth, family, sysid, vertex);</a>
<a name="ln1263">		}</a>
<a name="ln1264">	    }</a>
<a name="ln1265">	  else</a>
<a name="ln1266">	    {</a>
<a name="ln1267">	      zlog_warn (&quot;ISIS-Spf: No LSP found for %s&quot;,</a>
<a name="ln1268">			 rawlspid_print (lsp_id));</a>
<a name="ln1269">	    }</a>
<a name="ln1270">	  break;</a>
<a name="ln1271">	default:;</a>
<a name="ln1272">	}</a>
<a name="ln1273">    }</a>
<a name="ln1274"> </a>
<a name="ln1275">out:</a>
<a name="ln1276">  isis_route_validate (area);</a>
<a name="ln1277">  spftree-&gt;pending = 0;</a>
<a name="ln1278">  spftree-&gt;runcount++;</a>
<a name="ln1279">  spftree-&gt;last_run_timestamp = time (NULL);</a>
<a name="ln1280">  quagga_gettime(QUAGGA_CLK_MONOTONIC, &amp;time_now);</a>
<a name="ln1281">  end_time = time_now.tv_sec;</a>
<a name="ln1282">  end_time = (end_time * 1000000) + time_now.tv_usec;</a>
<a name="ln1283">  spftree-&gt;last_run_duration = end_time - start_time;</a>
<a name="ln1284"> </a>
<a name="ln1285"> </a>
<a name="ln1286">  return retval;</a>
<a name="ln1287">}</a>
<a name="ln1288"> </a>
<a name="ln1289">int</a>
<a name="ln1290">isis_run_spf_l1 (struct thread *thread)</a>
<a name="ln1291">{</a>
<a name="ln1292">  struct isis_area *area;</a>
<a name="ln1293">  int retval = ISIS_OK;</a>
<a name="ln1294"> </a>
<a name="ln1295">  area = THREAD_ARG (thread);</a>
<a name="ln1296">  assert (area);</a>
<a name="ln1297"> </a>
<a name="ln1298">  area-&gt;spftree[0]-&gt;t_spf = NULL;</a>
<a name="ln1299">  area-&gt;spftree[0]-&gt;pending = 0;</a>
<a name="ln1300"> </a>
<a name="ln1301">  if (!(area-&gt;is_type &amp; IS_LEVEL_1))</a>
<a name="ln1302">    {</a>
<a name="ln1303">      if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1304">	zlog_warn (&quot;ISIS-SPF (%s) area does not share level&quot;,</a>
<a name="ln1305">		   area-&gt;area_tag);</a>
<a name="ln1306">      return ISIS_WARNING;</a>
<a name="ln1307">    }</a>
<a name="ln1308"> </a>
<a name="ln1309">  if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1310">    zlog_debug (&quot;ISIS-Spf (%s) L1 SPF needed, periodic SPF&quot;, area-&gt;area_tag);</a>
<a name="ln1311"> </a>
<a name="ln1312">  if (area-&gt;ip_circuits)</a>
<a name="ln1313">    retval = isis_run_spf (area, 1, AF_INET, isis-&gt;sysid);</a>
<a name="ln1314"> </a>
<a name="ln1315">  return retval;</a>
<a name="ln1316">}</a>
<a name="ln1317"> </a>
<a name="ln1318">int</a>
<a name="ln1319">isis_run_spf_l2 (struct thread *thread)</a>
<a name="ln1320">{</a>
<a name="ln1321">  struct isis_area *area;</a>
<a name="ln1322">  int retval = ISIS_OK;</a>
<a name="ln1323"> </a>
<a name="ln1324">  area = THREAD_ARG (thread);</a>
<a name="ln1325">  assert (area);</a>
<a name="ln1326"> </a>
<a name="ln1327">  area-&gt;spftree[1]-&gt;t_spf = NULL;</a>
<a name="ln1328">  area-&gt;spftree[1]-&gt;pending = 0;</a>
<a name="ln1329"> </a>
<a name="ln1330">  if (!(area-&gt;is_type &amp; IS_LEVEL_2))</a>
<a name="ln1331">    {</a>
<a name="ln1332">      if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1333">	zlog_warn (&quot;ISIS-SPF (%s) area does not share level&quot;, area-&gt;area_tag);</a>
<a name="ln1334">      return ISIS_WARNING;</a>
<a name="ln1335">    }</a>
<a name="ln1336"> </a>
<a name="ln1337">  if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1338">    zlog_debug (&quot;ISIS-Spf (%s) L2 SPF needed, periodic SPF&quot;, area-&gt;area_tag);</a>
<a name="ln1339"> </a>
<a name="ln1340">  if (area-&gt;ip_circuits)</a>
<a name="ln1341">    retval = isis_run_spf (area, 2, AF_INET, isis-&gt;sysid);</a>
<a name="ln1342"> </a>
<a name="ln1343">  return retval;</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">int</a>
<a name="ln1347">isis_spf_schedule (struct isis_area *area, int level)</a>
<a name="ln1348">{</a>
<a name="ln1349">  struct isis_spftree *spftree = area-&gt;spftree[level - 1];</a>
<a name="ln1350">  time_t now = time (NULL);</a>
<a name="ln1351">  int diff = now - spftree-&gt;last_run_timestamp;</a>
<a name="ln1352"> </a>
<a name="ln1353">  assert (diff &gt;= 0);</a>
<a name="ln1354">  assert (area-&gt;is_type &amp; level);</a>
<a name="ln1355"> </a>
<a name="ln1356">  if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1357">    zlog_debug (&quot;ISIS-Spf (%s) L%d SPF schedule called, lastrun %d sec ago&quot;,</a>
<a name="ln1358">                area-&gt;area_tag, level, diff);</a>
<a name="ln1359"> </a>
<a name="ln1360">  if (spftree-&gt;pending)</a>
<a name="ln1361">    return ISIS_OK;</a>
<a name="ln1362"> </a>
<a name="ln1363">  THREAD_TIMER_OFF (spftree-&gt;t_spf);</a>
<a name="ln1364"> </a>
<a name="ln1365">  /* wait configured min_spf_interval before doing the SPF */</a>
<a name="ln1366">  if (diff &gt;= area-&gt;min_spf_interval[level-1])</a>
<a name="ln1367">      return isis_run_spf (area, level, AF_INET, isis-&gt;sysid);</a>
<a name="ln1368"> </a>
<a name="ln1369">  if (level == 1)</a>
<a name="ln1370">    THREAD_TIMER_ON (master, spftree-&gt;t_spf, isis_run_spf_l1, area,</a>
<a name="ln1371">                     area-&gt;min_spf_interval[0] - diff);</a>
<a name="ln1372">  else</a>
<a name="ln1373">    THREAD_TIMER_ON (master, spftree-&gt;t_spf, isis_run_spf_l2, area,</a>
<a name="ln1374">                     area-&gt;min_spf_interval[1] - diff);</a>
<a name="ln1375"> </a>
<a name="ln1376">  if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1377">    zlog_debug (&quot;ISIS-Spf (%s) L%d SPF scheduled %d sec from now&quot;,</a>
<a name="ln1378">                area-&gt;area_tag, level, area-&gt;min_spf_interval[level-1] - diff);</a>
<a name="ln1379"> </a>
<a name="ln1380">  spftree-&gt;pending = 1;</a>
<a name="ln1381"> </a>
<a name="ln1382">  return ISIS_OK;</a>
<a name="ln1383">}</a>
<a name="ln1384"> </a>
<a name="ln1385">#ifdef HAVE_IPV6</a>
<a name="ln1386">static int</a>
<a name="ln1387">isis_run_spf6_l1 (struct thread *thread)</a>
<a name="ln1388">{</a>
<a name="ln1389">  struct isis_area *area;</a>
<a name="ln1390">  int retval = ISIS_OK;</a>
<a name="ln1391"> </a>
<a name="ln1392">  area = THREAD_ARG (thread);</a>
<a name="ln1393">  assert (area);</a>
<a name="ln1394"> </a>
<a name="ln1395">  area-&gt;spftree6[0]-&gt;t_spf = NULL;</a>
<a name="ln1396">  area-&gt;spftree6[0]-&gt;pending = 0;</a>
<a name="ln1397"> </a>
<a name="ln1398">  if (!(area-&gt;is_type &amp; IS_LEVEL_1))</a>
<a name="ln1399">    {</a>
<a name="ln1400">      if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1401">        zlog_warn (&quot;ISIS-SPF (%s) area does not share level&quot;, area-&gt;area_tag);</a>
<a name="ln1402">      return ISIS_WARNING;</a>
<a name="ln1403">    }</a>
<a name="ln1404"> </a>
<a name="ln1405">  if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1406">    zlog_debug (&quot;ISIS-Spf (%s) L1 SPF needed, periodic SPF&quot;, area-&gt;area_tag);</a>
<a name="ln1407"> </a>
<a name="ln1408">  if (area-&gt;ipv6_circuits)</a>
<a name="ln1409">    retval = isis_run_spf (area, 1, AF_INET6, isis-&gt;sysid);</a>
<a name="ln1410"> </a>
<a name="ln1411">  return retval;</a>
<a name="ln1412">}</a>
<a name="ln1413"> </a>
<a name="ln1414">static int</a>
<a name="ln1415">isis_run_spf6_l2 (struct thread *thread)</a>
<a name="ln1416">{</a>
<a name="ln1417">  struct isis_area *area;</a>
<a name="ln1418">  int retval = ISIS_OK;</a>
<a name="ln1419"> </a>
<a name="ln1420">  area = THREAD_ARG (thread);</a>
<a name="ln1421">  assert (area);</a>
<a name="ln1422"> </a>
<a name="ln1423">  area-&gt;spftree6[1]-&gt;t_spf = NULL;</a>
<a name="ln1424">  area-&gt;spftree6[1]-&gt;pending = 0;</a>
<a name="ln1425"> </a>
<a name="ln1426">  if (!(area-&gt;is_type &amp; IS_LEVEL_2))</a>
<a name="ln1427">    {</a>
<a name="ln1428">      if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1429">        zlog_warn (&quot;ISIS-SPF (%s) area does not share level&quot;, area-&gt;area_tag);</a>
<a name="ln1430">      return ISIS_WARNING;</a>
<a name="ln1431">    }</a>
<a name="ln1432"> </a>
<a name="ln1433">  if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1434">    zlog_debug (&quot;ISIS-Spf (%s) L2 SPF needed, periodic SPF.&quot;, area-&gt;area_tag);</a>
<a name="ln1435"> </a>
<a name="ln1436">  if (area-&gt;ipv6_circuits)</a>
<a name="ln1437">    retval = isis_run_spf (area, 2, AF_INET6, isis-&gt;sysid);</a>
<a name="ln1438"> </a>
<a name="ln1439">  return retval;</a>
<a name="ln1440">}</a>
<a name="ln1441"> </a>
<a name="ln1442">int</a>
<a name="ln1443">isis_spf_schedule6 (struct isis_area *area, int level)</a>
<a name="ln1444">{</a>
<a name="ln1445">  int retval = ISIS_OK;</a>
<a name="ln1446">  struct isis_spftree *spftree = area-&gt;spftree6[level - 1];</a>
<a name="ln1447">  time_t now = time (NULL);</a>
<a name="ln1448">  time_t diff = now - spftree-&gt;last_run_timestamp;</a>
<a name="ln1449"> </a>
<a name="ln1450">  assert (diff &gt;= 0);</a>
<a name="ln1451">  assert (area-&gt;is_type &amp; level);</a>
<a name="ln1452"> </a>
<a name="ln1453">  if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1454">    zlog_debug (&quot;ISIS-Spf (%s) L%d SPF schedule called, lastrun %lld sec ago&quot;,</a>
<a name="ln1455">                area-&gt;area_tag, level, (long long)diff);</a>
<a name="ln1456"> </a>
<a name="ln1457">  if (spftree-&gt;pending)</a>
<a name="ln1458">    return ISIS_OK;</a>
<a name="ln1459"> </a>
<a name="ln1460">  THREAD_TIMER_OFF (spftree-&gt;t_spf);</a>
<a name="ln1461"> </a>
<a name="ln1462">  /* wait configured min_spf_interval before doing the SPF */</a>
<a name="ln1463">  if (diff &gt;= area-&gt;min_spf_interval[level-1])</a>
<a name="ln1464">      return isis_run_spf (area, level, AF_INET6, isis-&gt;sysid);</a>
<a name="ln1465"> </a>
<a name="ln1466">  if (level == 1)</a>
<a name="ln1467">    THREAD_TIMER_ON (master, spftree-&gt;t_spf, isis_run_spf6_l1, area,</a>
<a name="ln1468">                     area-&gt;min_spf_interval[0] - diff);</a>
<a name="ln1469">  else</a>
<a name="ln1470">    THREAD_TIMER_ON (master, spftree-&gt;t_spf, isis_run_spf6_l2, area,</a>
<a name="ln1471">                     area-&gt;min_spf_interval[1] - diff);</a>
<a name="ln1472"> </a>
<a name="ln1473">  if (isis-&gt;debugs &amp; DEBUG_SPF_EVENTS)</a>
<a name="ln1474">    zlog_debug (&quot;ISIS-Spf (%s) L%d SPF scheduled %lld sec from now&quot;,</a>
<a name="ln1475">                area-&gt;area_tag, level,</a>
<a name="ln1476">                (long long)(area-&gt;min_spf_interval[level-1] - diff));</a>
<a name="ln1477"> </a>
<a name="ln1478">  spftree-&gt;pending = 1;</a>
<a name="ln1479"> </a>
<a name="ln1480">  return retval;</a>
<a name="ln1481">}</a>
<a name="ln1482">#endif</a>
<a name="ln1483"> </a>
<a name="ln1484">static void</a>
<a name="ln1485">isis_print_paths (struct vty *vty, struct list *paths, u_char *root_sysid)</a>
<a name="ln1486">{</a>
<a name="ln1487">  struct listnode *node;</a>
<a name="ln1488">  struct listnode *anode;</a>
<a name="ln1489">  struct isis_vertex *vertex;</a>
<a name="ln1490">  struct isis_adjacency *adj;</a>
<a name="ln1491">  u_char buff[BUFSIZ];</a>
<a name="ln1492"> </a>
<a name="ln1493">  vty_out (vty, &quot;Vertex               Type         Metric &quot;</a>
<a name="ln1494">                &quot;Next-Hop             Interface Parent%s&quot;, VTY_NEWLINE);</a>
<a name="ln1495"> </a>
<a name="ln1496">  for (ALL_LIST_ELEMENTS_RO (paths, node, vertex)) {</a>
<a name="ln1497">      if (memcmp (vertex-&gt;N.id, root_sysid, ISIS_SYS_ID_LEN) == 0) {</a>
<a name="ln1498">	vty_out (vty, &quot;%-20s %-12s %-6s&quot;, print_sys_hostname (root_sysid),</a>
<a name="ln1499">	         &quot;&quot;, &quot;&quot;);</a>
<a name="ln1500">	vty_out (vty, &quot;%-30s&quot;, &quot;&quot;);</a>
<a name="ln1501">      } else {</a>
<a name="ln1502">	int rows = 0;</a>
<a name="ln1503">	vty_out (vty, &quot;%-20s %-12s %-6u &quot;, vid2string (vertex, buff),</a>
<a name="ln1504">	         vtype2string (vertex-&gt;type), vertex-&gt;d_N);</a>
<a name="ln1505">	for (ALL_LIST_ELEMENTS_RO (vertex-&gt;Adj_N, anode, adj)) {</a>
<a name="ln1506">	  if (adj) {</a>
<a name="ln1507">	    if (rows) {</a>
<a name="ln1508">		vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1509">		vty_out (vty, &quot;%-20s %-12s %-6s &quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;);</a>
<a name="ln1510">	    }</a>
<a name="ln1511">	    vty_out (vty, &quot;%-20s %-9s &quot;,</a>
<a name="ln1512">		     print_sys_hostname (adj-&gt;sysid),</a>
<a name="ln1513">		     adj-&gt;circuit-&gt;interface-&gt;name);</a>
<a name="ln1514">	    ++rows;</a>
<a name="ln1515">	  }</a>
<a name="ln1516">	}</a>
<a name="ln1517">	if (rows == 0)</a>
<a name="ln1518">	  vty_out (vty, &quot;%-30s &quot;, &quot;&quot;);</a>
<a name="ln1519">      }</a>
<a name="ln1520"> </a>
<a name="ln1521">      /* Print list of parents for the ECMP DAG */</a>
<a name="ln1522">      if (listcount (vertex-&gt;parents) &gt; 0) {</a>
<a name="ln1523">	struct listnode *pnode;</a>
<a name="ln1524">	struct isis_vertex *pvertex;</a>
<a name="ln1525">	int rows = 0;</a>
<a name="ln1526">	for (ALL_LIST_ELEMENTS_RO (vertex-&gt;parents, pnode, pvertex)) {</a>
<a name="ln1527">	  if (rows) {</a>
<a name="ln1528">	    vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1529">	    vty_out (vty, &quot;%-72s&quot;, &quot;&quot;);</a>
<a name="ln1530">	  }</a>
<a name="ln1531">	  vty_out (vty, &quot;%s(%d)&quot;,</a>
<a name="ln1532">	           vid2string (pvertex, buff), pvertex-&gt;type);</a>
<a name="ln1533">	  ++rows;</a>
<a name="ln1534">	}</a>
<a name="ln1535">      } else {</a>
<a name="ln1536">	vty_out (vty, &quot;  NULL &quot;);</a>
<a name="ln1537">      }</a>
<a name="ln1538"> </a>
<a name="ln1539">#if 0</a>
<a name="ln1540">      if (listcount (vertex-&gt;children) &gt; 0) {</a>
<a name="ln1541">	  struct listnode *cnode;</a>
<a name="ln1542">	  struct isis_vertex *cvertex;</a>
<a name="ln1543">	  for (ALL_LIST_ELEMENTS_RO (vertex-&gt;children, cnode, cvertex)) {</a>
<a name="ln1544">	      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1545">	      vty_out (vty, &quot;%-72s&quot;, &quot;&quot;);</a>
<a name="ln1546">	      vty_out (vty, &quot;%s(%d) &quot;, </a>
<a name="ln1547">	               vid2string (cvertex, buff), cvertex-&gt;type);</a>
<a name="ln1548">	    }</a>
<a name="ln1549">	}</a>
<a name="ln1550">#endif</a>
<a name="ln1551">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1552">    }</a>
<a name="ln1553">}</a>
<a name="ln1554"> </a>
<a name="ln1555">DEFUN (show_isis_topology,</a>
<a name="ln1556">       show_isis_topology_cmd,</a>
<a name="ln1557">       &quot;show isis topology&quot;,</a>
<a name="ln1558">       SHOW_STR</a>
<a name="ln1559">       &quot;IS-IS information\n&quot;</a>
<a name="ln1560">       &quot;IS-IS paths to Intermediate Systems\n&quot;)</a>
<a name="ln1561">{</a>
<a name="ln1562">  struct listnode *node;</a>
<a name="ln1563">  struct isis_area *area;</a>
<a name="ln1564">  int level;</a>
<a name="ln1565"> </a>
<a name="ln1566">  if (!isis-&gt;area_list || isis-&gt;area_list-&gt;count == 0)</a>
<a name="ln1567">    return CMD_SUCCESS;</a>
<a name="ln1568"> </a>
<a name="ln1569">  for (ALL_LIST_ELEMENTS_RO (isis-&gt;area_list, node, area))</a>
<a name="ln1570">    {</a>
<a name="ln1571">      vty_out (vty, &quot;Area %s:%s&quot;, area-&gt;area_tag ? area-&gt;area_tag : &quot;null&quot;,</a>
<a name="ln1572">	       VTY_NEWLINE);</a>
<a name="ln1573"> </a>
<a name="ln1574">      for (level = 0; level &lt; ISIS_LEVELS; level++)</a>
<a name="ln1575">	{</a>
<a name="ln1576">	  if (area-&gt;ip_circuits &gt; 0 &amp;&amp; area-&gt;spftree[level]</a>
<a name="ln1577">	      &amp;&amp; area-&gt;spftree[level]-&gt;paths-&gt;count &gt; 0)</a>
<a name="ln1578">	    {</a>
<a name="ln1579">	      vty_out (vty, &quot;IS-IS paths to level-%d routers that speak IP%s&quot;,</a>
<a name="ln1580">		       level + 1, VTY_NEWLINE);</a>
<a name="ln1581">	      isis_print_paths (vty, area-&gt;spftree[level]-&gt;paths, isis-&gt;sysid);</a>
<a name="ln1582">	      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1583">	    }</a>
<a name="ln1584">#ifdef HAVE_IPV6</a>
<a name="ln1585">	  if (area-&gt;ipv6_circuits &gt; 0 &amp;&amp; area-&gt;spftree6[level]</a>
<a name="ln1586">	      &amp;&amp; area-&gt;spftree6[level]-&gt;paths-&gt;count &gt; 0)</a>
<a name="ln1587">	    {</a>
<a name="ln1588">	      vty_out (vty,</a>
<a name="ln1589">		       &quot;IS-IS paths to level-%d routers that speak IPv6%s&quot;,</a>
<a name="ln1590">		       level + 1, VTY_NEWLINE);</a>
<a name="ln1591">	      isis_print_paths (vty, area-&gt;spftree6[level]-&gt;paths, isis-&gt;sysid);</a>
<a name="ln1592">	      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1593">	    }</a>
<a name="ln1594">#endif /* HAVE_IPV6 */</a>
<a name="ln1595">	}</a>
<a name="ln1596"> </a>
<a name="ln1597">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1598">    }</a>
<a name="ln1599"> </a>
<a name="ln1600">  return CMD_SUCCESS;</a>
<a name="ln1601">}</a>
<a name="ln1602"> </a>
<a name="ln1603">DEFUN (show_isis_topology_l1,</a>
<a name="ln1604">       show_isis_topology_l1_cmd,</a>
<a name="ln1605">       &quot;show isis topology level-1&quot;,</a>
<a name="ln1606">       SHOW_STR</a>
<a name="ln1607">       &quot;IS-IS information\n&quot;</a>
<a name="ln1608">       &quot;IS-IS paths to Intermediate Systems\n&quot;</a>
<a name="ln1609">       &quot;Paths to all level-1 routers in the area\n&quot;)</a>
<a name="ln1610">{</a>
<a name="ln1611">  struct listnode *node;</a>
<a name="ln1612">  struct isis_area *area;</a>
<a name="ln1613"> </a>
<a name="ln1614">  if (!isis-&gt;area_list || isis-&gt;area_list-&gt;count == 0)</a>
<a name="ln1615">    return CMD_SUCCESS;</a>
<a name="ln1616"> </a>
<a name="ln1617">  for (ALL_LIST_ELEMENTS_RO (isis-&gt;area_list, node, area))</a>
<a name="ln1618">    {</a>
<a name="ln1619">      vty_out (vty, &quot;Area %s:%s&quot;, area-&gt;area_tag ? area-&gt;area_tag : &quot;null&quot;,</a>
<a name="ln1620">	       VTY_NEWLINE);</a>
<a name="ln1621"> </a>
<a name="ln1622">      if (area-&gt;ip_circuits &gt; 0 &amp;&amp; area-&gt;spftree[0]</a>
<a name="ln1623">	  &amp;&amp; area-&gt;spftree[0]-&gt;paths-&gt;count &gt; 0)</a>
<a name="ln1624">	{</a>
<a name="ln1625">	  vty_out (vty, &quot;IS-IS paths to level-1 routers that speak IP%s&quot;,</a>
<a name="ln1626">		   VTY_NEWLINE);</a>
<a name="ln1627">	  isis_print_paths (vty, area-&gt;spftree[0]-&gt;paths, isis-&gt;sysid);</a>
<a name="ln1628">	  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1629">	}</a>
<a name="ln1630">#ifdef HAVE_IPV6</a>
<a name="ln1631">      if (area-&gt;ipv6_circuits &gt; 0 &amp;&amp; area-&gt;spftree6[0]</a>
<a name="ln1632">	  &amp;&amp; area-&gt;spftree6[0]-&gt;paths-&gt;count &gt; 0)</a>
<a name="ln1633">	{</a>
<a name="ln1634">	  vty_out (vty, &quot;IS-IS paths to level-1 routers that speak IPv6%s&quot;,</a>
<a name="ln1635">		   VTY_NEWLINE);</a>
<a name="ln1636">	  isis_print_paths (vty, area-&gt;spftree6[0]-&gt;paths, isis-&gt;sysid);</a>
<a name="ln1637">	  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1638">	}</a>
<a name="ln1639">#endif /* HAVE_IPV6 */</a>
<a name="ln1640">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1641">    }</a>
<a name="ln1642"> </a>
<a name="ln1643">  return CMD_SUCCESS;</a>
<a name="ln1644">}</a>
<a name="ln1645"> </a>
<a name="ln1646">DEFUN (show_isis_topology_l2,</a>
<a name="ln1647">       show_isis_topology_l2_cmd,</a>
<a name="ln1648">       &quot;show isis topology level-2&quot;,</a>
<a name="ln1649">       SHOW_STR</a>
<a name="ln1650">       &quot;IS-IS information\n&quot;</a>
<a name="ln1651">       &quot;IS-IS paths to Intermediate Systems\n&quot;</a>
<a name="ln1652">       &quot;Paths to all level-2 routers in the domain\n&quot;)</a>
<a name="ln1653">{</a>
<a name="ln1654">  struct listnode *node;</a>
<a name="ln1655">  struct isis_area *area;</a>
<a name="ln1656"> </a>
<a name="ln1657">  if (!isis-&gt;area_list || isis-&gt;area_list-&gt;count == 0)</a>
<a name="ln1658">    return CMD_SUCCESS;</a>
<a name="ln1659"> </a>
<a name="ln1660">  for (ALL_LIST_ELEMENTS_RO (isis-&gt;area_list, node, area))</a>
<a name="ln1661">    {</a>
<a name="ln1662">      vty_out (vty, &quot;Area %s:%s&quot;, area-&gt;area_tag ? area-&gt;area_tag : &quot;null&quot;,</a>
<a name="ln1663">	       VTY_NEWLINE);</a>
<a name="ln1664"> </a>
<a name="ln1665">      if (area-&gt;ip_circuits &gt; 0 &amp;&amp; area-&gt;spftree[1]</a>
<a name="ln1666">	  &amp;&amp; area-&gt;spftree[1]-&gt;paths-&gt;count &gt; 0)</a>
<a name="ln1667">	{</a>
<a name="ln1668">	  vty_out (vty, &quot;IS-IS paths to level-2 routers that speak IP%s&quot;,</a>
<a name="ln1669">		   VTY_NEWLINE);</a>
<a name="ln1670">	  isis_print_paths (vty, area-&gt;spftree[1]-&gt;paths, isis-&gt;sysid);</a>
<a name="ln1671">	  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1672">	}</a>
<a name="ln1673">#ifdef HAVE_IPV6</a>
<a name="ln1674">      if (area-&gt;ipv6_circuits &gt; 0 &amp;&amp; area-&gt;spftree6[1]</a>
<a name="ln1675">	  &amp;&amp; area-&gt;spftree6[1]-&gt;paths-&gt;count &gt; 0)</a>
<a name="ln1676">	{</a>
<a name="ln1677">	  vty_out (vty, &quot;IS-IS paths to level-2 routers that speak IPv6%s&quot;,</a>
<a name="ln1678">		   VTY_NEWLINE);</a>
<a name="ln1679">	  isis_print_paths (vty, area-&gt;spftree6[1]-&gt;paths, isis-&gt;sysid);</a>
<a name="ln1680">	  vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1681">	}</a>
<a name="ln1682">#endif /* HAVE_IPV6 */</a>
<a name="ln1683">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln1684">    }</a>
<a name="ln1685"> </a>
<a name="ln1686">  return CMD_SUCCESS;</a>
<a name="ln1687">}</a>
<a name="ln1688"> </a>
<a name="ln1689">void</a>
<a name="ln1690">isis_spf_cmds_init ()</a>
<a name="ln1691">{</a>
<a name="ln1692">  install_element (VIEW_NODE, &amp;show_isis_topology_cmd);</a>
<a name="ln1693">  install_element (VIEW_NODE, &amp;show_isis_topology_l1_cmd);</a>
<a name="ln1694">  install_element (VIEW_NODE, &amp;show_isis_topology_l2_cmd);</a>
<a name="ln1695">}</a>

</code></pre>
<div class="balloon" rel="16"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="163"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 163, 168</p></div>
<div class="balloon" rel="483"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& vertex->N.id' buffer is not a multiple of the element size of the type 'struct prefix'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
