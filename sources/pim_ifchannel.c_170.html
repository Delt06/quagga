
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_ifchannel.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;linklist.h&quot;</a>
<a name="ln26">#include &quot;thread.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;pimd.h&quot;</a>
<a name="ln30">#include &quot;pim_str.h&quot;</a>
<a name="ln31">#include &quot;pim_iface.h&quot;</a>
<a name="ln32">#include &quot;pim_ifchannel.h&quot;</a>
<a name="ln33">#include &quot;pim_zebra.h&quot;</a>
<a name="ln34">#include &quot;pim_time.h&quot;</a>
<a name="ln35">#include &quot;pim_msg.h&quot;</a>
<a name="ln36">#include &quot;pim_pim.h&quot;</a>
<a name="ln37">#include &quot;pim_join.h&quot;</a>
<a name="ln38">#include &quot;pim_rpf.h&quot;</a>
<a name="ln39">#include &quot;pim_macro.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">void pim_ifchannel_free(struct pim_ifchannel *ch)</a>
<a name="ln42">{</a>
<a name="ln43">  zassert(!ch-&gt;t_ifjoin_expiry_timer);</a>
<a name="ln44">  zassert(!ch-&gt;t_ifjoin_prune_pending_timer);</a>
<a name="ln45">  zassert(!ch-&gt;t_ifassert_timer);</a>
<a name="ln46"> </a>
<a name="ln47">  XFREE(MTYPE_PIM_IFCHANNEL, ch);</a>
<a name="ln48">}</a>
<a name="ln49"> </a>
<a name="ln50">void pim_ifchannel_delete(struct pim_ifchannel *ch)</a>
<a name="ln51">{</a>
<a name="ln52">  struct pim_interface *pim_ifp;</a>
<a name="ln53"> </a>
<a name="ln54">  pim_ifp = ch-&gt;interface-&gt;info;</a>
<a name="ln55">  zassert(pim_ifp);</a>
<a name="ln56"> </a>
<a name="ln57">  if (ch-&gt;ifjoin_state != PIM_IFJOIN_NOINFO) {</a>
<a name="ln58">    pim_upstream_update_join_desired(ch-&gt;upstream);</a>
<a name="ln59">  }</a>
<a name="ln60"> </a>
<a name="ln61">  pim_upstream_del(ch-&gt;upstream);</a>
<a name="ln62"> </a>
<a name="ln63">  THREAD_OFF(ch-&gt;t_ifjoin_expiry_timer);</a>
<a name="ln64">  THREAD_OFF(ch-&gt;t_ifjoin_prune_pending_timer);</a>
<a name="ln65">  THREAD_OFF(ch-&gt;t_ifassert_timer);</a>
<a name="ln66"> </a>
<a name="ln67">  /*</a>
<a name="ln68">    notice that listnode_delete() can't be moved</a>
<a name="ln69">    into pim_ifchannel_free() because the later is</a>
<a name="ln70">    called by list_delete_all_node()</a>
<a name="ln71">  */</a>
<a name="ln72">  listnode_delete(pim_ifp-&gt;pim_ifchannel_list, ch);</a>
<a name="ln73"> </a>
<a name="ln74">  pim_ifchannel_free(ch);</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">#define IFCHANNEL_NOINFO(ch)					\</a>
<a name="ln78">  (								\</a>
<a name="ln79">   ((ch)-&gt;local_ifmembership == PIM_IFMEMBERSHIP_NOINFO)	\</a>
<a name="ln80">   &amp;&amp;								\</a>
<a name="ln81">   ((ch)-&gt;ifjoin_state == PIM_IFJOIN_NOINFO)			\</a>
<a name="ln82">   &amp;&amp;								\</a>
<a name="ln83">   ((ch)-&gt;ifassert_state == PIM_IFASSERT_NOINFO)		\</a>
<a name="ln84">   )</a>
<a name="ln85">   </a>
<a name="ln86">static void delete_on_noinfo(struct pim_ifchannel *ch)</a>
<a name="ln87">{</a>
<a name="ln88">  if (IFCHANNEL_NOINFO(ch)) {</a>
<a name="ln89"> </a>
<a name="ln90">    /* In NOINFO state, timers should have been cleared */</a>
<a name="ln91">    zassert(!ch-&gt;t_ifjoin_expiry_timer);</a>
<a name="ln92">    zassert(!ch-&gt;t_ifjoin_prune_pending_timer);</a>
<a name="ln93">    zassert(!ch-&gt;t_ifassert_timer);</a>
<a name="ln94">    </a>
<a name="ln95">    pim_ifchannel_delete(ch);</a>
<a name="ln96">  }</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">void pim_ifchannel_ifjoin_switch(const char *caller,</a>
<a name="ln100">				 struct pim_ifchannel *ch,</a>
<a name="ln101">				 enum pim_ifjoin_state new_state)</a>
<a name="ln102">{</a>
<a name="ln103">  enum pim_ifjoin_state old_state = ch-&gt;ifjoin_state;</a>
<a name="ln104"> </a>
<a name="ln105">  if (old_state == new_state) {</a>
<a name="ln106">    if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln107">      zlog_debug(&quot;%s calledby %s: non-transition on state %d (%s)&quot;,</a>
<a name="ln108">		 __PRETTY_FUNCTION__, caller, new_state,</a>
<a name="ln109">		 pim_ifchannel_ifjoin_name(new_state));</a>
<a name="ln110">    }</a>
<a name="ln111">    return;</a>
<a name="ln112">  }</a>
<a name="ln113"> </a>
<a name="ln114">  zassert(old_state != new_state);</a>
<a name="ln115"> </a>
<a name="ln116">  ch-&gt;ifjoin_state = new_state;</a>
<a name="ln117"> </a>
<a name="ln118">  /* Transition to/from NOINFO ? */</a>
<a name="ln119">  if (</a>
<a name="ln120">      (old_state == PIM_IFJOIN_NOINFO)</a>
<a name="ln121">      ||</a>
<a name="ln122">      (new_state == PIM_IFJOIN_NOINFO)</a>
<a name="ln123">      ) {</a>
<a name="ln124"> </a>
<a name="ln125">    if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln126">      char src_str[100];</a>
<a name="ln127">      char grp_str[100];</a>
<a name="ln128">      pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln129">      pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln130">      zlog_debug(&quot;PIM_IFCHANNEL_%s: (S,G)=(%s,%s) on interface %s&quot;,</a>
<a name="ln131">		 ((new_state == PIM_IFJOIN_NOINFO) ? &quot;DOWN&quot; : &quot;UP&quot;),</a>
<a name="ln132">		 src_str, grp_str, ch-&gt;interface-&gt;name);</a>
<a name="ln133">    }</a>
<a name="ln134"> </a>
<a name="ln135">    /*</a>
<a name="ln136">      Record uptime of state transition to/from NOINFO</a>
<a name="ln137">    */</a>
<a name="ln138">    ch-&gt;ifjoin_creation = pim_time_monotonic_sec();</a>
<a name="ln139"> </a>
<a name="ln140">    pim_upstream_update_join_desired(ch-&gt;upstream);</a>
<a name="ln141">    pim_ifchannel_update_could_assert(ch);</a>
<a name="ln142">    pim_ifchannel_update_assert_tracking_desired(ch);</a>
<a name="ln143">  }</a>
<a name="ln144">}</a>
<a name="ln145"> </a>
<a name="ln146">const char *pim_ifchannel_ifjoin_name(enum pim_ifjoin_state ifjoin_state)</a>
<a name="ln147">{</a>
<a name="ln148">  switch (ifjoin_state) {</a>
<a name="ln149">  case PIM_IFJOIN_NOINFO:        return &quot;NOINFO&quot;;</a>
<a name="ln150">  case PIM_IFJOIN_JOIN:          return &quot;JOIN&quot;;</a>
<a name="ln151">  case PIM_IFJOIN_PRUNE_PENDING: return &quot;PRUNEP&quot;;</a>
<a name="ln152">  }</a>
<a name="ln153"> </a>
<a name="ln154">  return &quot;ifjoin_bad_state&quot;;</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">const char *pim_ifchannel_ifassert_name(enum pim_ifassert_state ifassert_state)</a>
<a name="ln158">{</a>
<a name="ln159">  switch (ifassert_state) {</a>
<a name="ln160">  case PIM_IFASSERT_NOINFO:      return &quot;NOINFO&quot;;</a>
<a name="ln161">  case PIM_IFASSERT_I_AM_WINNER: return &quot;WINNER&quot;;</a>
<a name="ln162">  case PIM_IFASSERT_I_AM_LOSER:  return &quot;LOSER&quot;;</a>
<a name="ln163">  }</a>
<a name="ln164"> </a>
<a name="ln165">  return &quot;ifassert_bad_state&quot;;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">/*</a>
<a name="ln169">  RFC 4601: 4.6.5.  Assert State Macros</a>
<a name="ln170"> </a>
<a name="ln171">  AssertWinner(S,G,I) defaults to NULL and AssertWinnerMetric(S,G,I)</a>
<a name="ln172">  defaults to Infinity when in the NoInfo state.</a>
<a name="ln173">*/</a>
<a name="ln174">void reset_ifassert_state(struct pim_ifchannel *ch)</a>
<a name="ln175">{</a>
<a name="ln176">  THREAD_OFF(ch-&gt;t_ifassert_timer);</a>
<a name="ln177"> </a>
<a name="ln178">  pim_ifassert_winner_set(ch,</a>
<a name="ln179">			  PIM_IFASSERT_NOINFO,</a>
<a name="ln180">			  qpim_inaddr_any,</a>
<a name="ln181">			  qpim_infinite_assert_metric);</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">static struct pim_ifchannel *pim_ifchannel_new(struct interface *ifp,</a>
<a name="ln185">					       struct in_addr source_addr,</a>
<a name="ln186">					       struct in_addr group_addr)</a>
<a name="ln187">{</a>
<a name="ln188">  struct pim_ifchannel *ch;</a>
<a name="ln189">  struct pim_interface *pim_ifp;</a>
<a name="ln190">  struct pim_upstream  *up;</a>
<a name="ln191"> </a>
<a name="ln192">  pim_ifp = ifp-&gt;info;</a>
<a name="ln193">  zassert(pim_ifp);</a>
<a name="ln194"> </a>
<a name="ln195">  up = pim_upstream_add(source_addr, group_addr);</a>
<a name="ln196">  if (!up) {</a>
<a name="ln197">    char src_str[100];</a>
<a name="ln198">    char grp_str[100];</a>
<a name="ln199">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, src_str, sizeof(src_str));</a>
<a name="ln200">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln201">    zlog_err(&quot;%s: could not attach upstream (S,G)=(%s,%s) on interface %s&quot;,</a>
<a name="ln202">	     __PRETTY_FUNCTION__,</a>
<a name="ln203">	     src_str, grp_str, ifp-&gt;name);</a>
<a name="ln204">    return 0;</a>
<a name="ln205">  }</a>
<a name="ln206"> </a>
<a name="ln207">  ch = XMALLOC(MTYPE_PIM_IFCHANNEL, sizeof(*ch));</a>
<a name="ln208">  if (!ch) {</a>
<a name="ln209">    zlog_err(&quot;%s: PIM XMALLOC(%zu) failure&quot;,</a>
<a name="ln210">	     __PRETTY_FUNCTION__, sizeof(*ch));</a>
<a name="ln211">    return 0;</a>
<a name="ln212">  }</a>
<a name="ln213"> </a>
<a name="ln214">  ch-&gt;flags                        = 0;</a>
<a name="ln215">  ch-&gt;upstream                     = up;</a>
<a name="ln216">  ch-&gt;interface                    = ifp;</a>
<a name="ln217">  ch-&gt;source_addr                  = source_addr;</a>
<a name="ln218">  ch-&gt;group_addr                   = group_addr;</a>
<a name="ln219">  ch-&gt;local_ifmembership           = PIM_IFMEMBERSHIP_NOINFO;</a>
<a name="ln220"> </a>
<a name="ln221">  ch-&gt;ifjoin_state                 = PIM_IFJOIN_NOINFO;</a>
<a name="ln222">  ch-&gt;t_ifjoin_expiry_timer        = 0;</a>
<a name="ln223">  ch-&gt;t_ifjoin_prune_pending_timer = 0;</a>
<a name="ln224">  ch-&gt;ifjoin_creation              = 0;</a>
<a name="ln225"> </a>
<a name="ln226">  ch-&gt;ifassert_my_metric = pim_macro_ch_my_assert_metric_eval(ch);</a>
<a name="ln227">  ch-&gt;ifassert_winner_metric = pim_macro_ch_my_assert_metric_eval (ch);</a>
<a name="ln228"> </a>
<a name="ln229">  ch-&gt;ifassert_winner.s_addr = 0;</a>
<a name="ln230"> </a>
<a name="ln231">  /* Assert state */</a>
<a name="ln232">  ch-&gt;t_ifassert_timer   = 0;</a>
<a name="ln233">  reset_ifassert_state(ch);</a>
<a name="ln234">  if (pim_macro_ch_could_assert_eval(ch))</a>
<a name="ln235">    PIM_IF_FLAG_SET_COULD_ASSERT(ch-&gt;flags);</a>
<a name="ln236">  else</a>
<a name="ln237">    PIM_IF_FLAG_UNSET_COULD_ASSERT(ch-&gt;flags);</a>
<a name="ln238"> </a>
<a name="ln239">  if (pim_macro_assert_tracking_desired_eval(ch))</a>
<a name="ln240">    PIM_IF_FLAG_SET_ASSERT_TRACKING_DESIRED(ch-&gt;flags);</a>
<a name="ln241">  else</a>
<a name="ln242">    PIM_IF_FLAG_UNSET_ASSERT_TRACKING_DESIRED(ch-&gt;flags);</a>
<a name="ln243"> </a>
<a name="ln244">  /* Attach to list */</a>
<a name="ln245">  listnode_add(pim_ifp-&gt;pim_ifchannel_list, ch);</a>
<a name="ln246"> </a>
<a name="ln247">  zassert(IFCHANNEL_NOINFO(ch));</a>
<a name="ln248"> </a>
<a name="ln249">  return ch;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">struct pim_ifchannel *pim_ifchannel_find(struct interface *ifp,</a>
<a name="ln253">					 struct in_addr source_addr,</a>
<a name="ln254">					 struct in_addr group_addr)</a>
<a name="ln255">{</a>
<a name="ln256">  struct pim_interface *pim_ifp;</a>
<a name="ln257">  struct listnode      *ch_node;</a>
<a name="ln258">  struct pim_ifchannel *ch;</a>
<a name="ln259"> </a>
<a name="ln260">  zassert(ifp);</a>
<a name="ln261"> </a>
<a name="ln262">  pim_ifp = ifp-&gt;info;</a>
<a name="ln263"> </a>
<a name="ln264">  if (!pim_ifp) {</a>
<a name="ln265">    char src_str[100];</a>
<a name="ln266">    char grp_str[100];</a>
<a name="ln267">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, src_str, sizeof(src_str));</a>
<a name="ln268">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln269">    zlog_warn(&quot;%s: (S,G)=(%s,%s): multicast not enabled on interface %s&quot;,</a>
<a name="ln270">	      __PRETTY_FUNCTION__,</a>
<a name="ln271">	      src_str, grp_str,</a>
<a name="ln272">	      ifp-&gt;name);</a>
<a name="ln273">    return 0;</a>
<a name="ln274">  }</a>
<a name="ln275"> </a>
<a name="ln276">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_ifchannel_list, ch_node, ch)) {</a>
<a name="ln277">    if (</a>
<a name="ln278">	(source_addr.s_addr == ch-&gt;source_addr.s_addr) &amp;&amp;</a>
<a name="ln279">	(group_addr.s_addr == ch-&gt;group_addr.s_addr)</a>
<a name="ln280">	) {</a>
<a name="ln281">      return ch;</a>
<a name="ln282">    }</a>
<a name="ln283">  }</a>
<a name="ln284"> </a>
<a name="ln285">  return 0;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">static void ifmembership_set(struct pim_ifchannel *ch,</a>
<a name="ln289">			     enum pim_ifmembership membership)</a>
<a name="ln290">{</a>
<a name="ln291">  if (ch-&gt;local_ifmembership == membership)</a>
<a name="ln292">    return;</a>
<a name="ln293"> </a>
<a name="ln294">  if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln295">    char src_str[100];</a>
<a name="ln296">    char grp_str[100];</a>
<a name="ln297">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln298">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln299">    zlog_debug(&quot;%s: (S,G)=(%s,%s) membership now is %s on interface %s&quot;,</a>
<a name="ln300">	       __PRETTY_FUNCTION__,</a>
<a name="ln301">	       src_str, grp_str,</a>
<a name="ln302">	       membership == PIM_IFMEMBERSHIP_INCLUDE ? &quot;INCLUDE&quot; : &quot;NOINFO&quot;,</a>
<a name="ln303">	       ch-&gt;interface-&gt;name);</a>
<a name="ln304">  }</a>
<a name="ln305">  </a>
<a name="ln306">  ch-&gt;local_ifmembership = membership;</a>
<a name="ln307"> </a>
<a name="ln308">  pim_upstream_update_join_desired(ch-&gt;upstream);</a>
<a name="ln309">  pim_ifchannel_update_could_assert(ch);</a>
<a name="ln310">  pim_ifchannel_update_assert_tracking_desired(ch);</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313"> </a>
<a name="ln314">void pim_ifchannel_membership_clear(struct interface *ifp)</a>
<a name="ln315">{</a>
<a name="ln316">  struct pim_interface *pim_ifp;</a>
<a name="ln317">  struct listnode      *ch_node;</a>
<a name="ln318">  struct pim_ifchannel *ch;</a>
<a name="ln319"> </a>
<a name="ln320">  pim_ifp = ifp-&gt;info;</a>
<a name="ln321">  zassert(pim_ifp);</a>
<a name="ln322"> </a>
<a name="ln323">  for (ALL_LIST_ELEMENTS_RO(pim_ifp-&gt;pim_ifchannel_list, ch_node, ch)) {</a>
<a name="ln324">    ifmembership_set(ch, PIM_IFMEMBERSHIP_NOINFO);</a>
<a name="ln325">  }</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">void pim_ifchannel_delete_on_noinfo(struct interface *ifp)</a>
<a name="ln329">{</a>
<a name="ln330">  struct pim_interface *pim_ifp;</a>
<a name="ln331">  struct listnode      *node;</a>
<a name="ln332">  struct listnode      *next_node;</a>
<a name="ln333">  struct pim_ifchannel *ch;</a>
<a name="ln334"> </a>
<a name="ln335">  pim_ifp = ifp-&gt;info;</a>
<a name="ln336">  zassert(pim_ifp);</a>
<a name="ln337"> </a>
<a name="ln338">  for (ALL_LIST_ELEMENTS(pim_ifp-&gt;pim_ifchannel_list, node, next_node, ch)) {</a>
<a name="ln339">    delete_on_noinfo(ch);</a>
<a name="ln340">  }</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">struct pim_ifchannel *pim_ifchannel_add(struct interface *ifp,</a>
<a name="ln344">					struct in_addr source_addr,</a>
<a name="ln345">					struct in_addr group_addr)</a>
<a name="ln346">{</a>
<a name="ln347">  struct pim_ifchannel *ch;</a>
<a name="ln348">  char src_str[100];</a>
<a name="ln349">  char grp_str[100];</a>
<a name="ln350"> </a>
<a name="ln351">  ch = pim_ifchannel_find(ifp, source_addr, group_addr);</a>
<a name="ln352">  if (ch)</a>
<a name="ln353">    return ch;</a>
<a name="ln354"> </a>
<a name="ln355">  ch = pim_ifchannel_new(ifp, source_addr, group_addr);</a>
<a name="ln356">  if (ch)</a>
<a name="ln357">    return ch;</a>
<a name="ln358">    </a>
<a name="ln359">  pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, src_str, sizeof(src_str));</a>
<a name="ln360">  pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln361">  zlog_warn(&quot;%s: pim_ifchannel_new() failure for (S,G)=(%s,%s) on interface %s&quot;,</a>
<a name="ln362">	    __PRETTY_FUNCTION__,</a>
<a name="ln363">	    src_str, grp_str, ifp-&gt;name);</a>
<a name="ln364"> </a>
<a name="ln365">  return 0;</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">static void ifjoin_to_noinfo(struct pim_ifchannel *ch)</a>
<a name="ln369">{</a>
<a name="ln370">  pim_forward_stop(ch);</a>
<a name="ln371">  pim_ifchannel_ifjoin_switch(__PRETTY_FUNCTION__, ch, PIM_IFJOIN_NOINFO);</a>
<a name="ln372">  delete_on_noinfo(ch);</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">static int on_ifjoin_expiry_timer(struct thread *t)</a>
<a name="ln376">{</a>
<a name="ln377">  struct pim_ifchannel *ch;</a>
<a name="ln378"> </a>
<a name="ln379">  zassert(t);</a>
<a name="ln380">  ch = THREAD_ARG(t);</a>
<a name="ln381">  zassert(ch);</a>
<a name="ln382"> </a>
<a name="ln383">  ch-&gt;t_ifjoin_expiry_timer = 0;</a>
<a name="ln384"> </a>
<a name="ln385">  zassert(ch-&gt;ifjoin_state == PIM_IFJOIN_JOIN);</a>
<a name="ln386"> </a>
<a name="ln387">  ifjoin_to_noinfo(ch);</a>
<a name="ln388">  /* ch may have been deleted */</a>
<a name="ln389"> </a>
<a name="ln390">  return 0;</a>
<a name="ln391">}</a>
<a name="ln392"> </a>
<a name="ln393">static void prune_echo(struct interface *ifp,</a>
<a name="ln394">		       struct in_addr source_addr,</a>
<a name="ln395">		       struct in_addr group_addr)</a>
<a name="ln396">{</a>
<a name="ln397">  struct pim_interface *pim_ifp;</a>
<a name="ln398">  struct in_addr neigh_dst_addr;</a>
<a name="ln399"> </a>
<a name="ln400">  pim_ifp = ifp-&gt;info;</a>
<a name="ln401">  zassert(pim_ifp);</a>
<a name="ln402"> </a>
<a name="ln403">  neigh_dst_addr = pim_ifp-&gt;primary_address;</a>
<a name="ln404"> </a>
<a name="ln405">  if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln406">    char source_str[100];</a>
<a name="ln407">    char group_str[100];</a>
<a name="ln408">    char neigh_dst_str[100];</a>
<a name="ln409">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln410">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln411">    pim_inet4_dump(&quot;&lt;neigh?&gt;&quot;, neigh_dst_addr, neigh_dst_str, sizeof(neigh_dst_str));</a>
<a name="ln412">    zlog_debug(&quot;%s: sending PruneEcho(S,G)=(%s,%s) to upstream=%s on interface %s&quot;,</a>
<a name="ln413">	       __PRETTY_FUNCTION__, source_str, group_str, neigh_dst_str, ifp-&gt;name);</a>
<a name="ln414">  }</a>
<a name="ln415"> </a>
<a name="ln416">  pim_joinprune_send(ifp, neigh_dst_addr, source_addr, group_addr,</a>
<a name="ln417">		     0 /* boolean: send_join=false (prune) */);</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">static int on_ifjoin_prune_pending_timer(struct thread *t)</a>
<a name="ln421">{</a>
<a name="ln422">  struct pim_ifchannel *ch;</a>
<a name="ln423">  int send_prune_echo; /* boolean */</a>
<a name="ln424">  struct interface *ifp;</a>
<a name="ln425">  struct pim_interface *pim_ifp;</a>
<a name="ln426">  struct in_addr ch_source;</a>
<a name="ln427">  struct in_addr ch_group;</a>
<a name="ln428"> </a>
<a name="ln429">  zassert(t);</a>
<a name="ln430">  ch = THREAD_ARG(t);</a>
<a name="ln431">  zassert(ch);</a>
<a name="ln432"> </a>
<a name="ln433">  ch-&gt;t_ifjoin_prune_pending_timer = 0;</a>
<a name="ln434"> </a>
<a name="ln435">  zassert(ch-&gt;ifjoin_state == PIM_IFJOIN_PRUNE_PENDING);</a>
<a name="ln436"> </a>
<a name="ln437">  /* Send PruneEcho(S,G) ? */</a>
<a name="ln438">  ifp = ch-&gt;interface;</a>
<a name="ln439">  pim_ifp = ifp-&gt;info;</a>
<a name="ln440">  send_prune_echo = (listcount(pim_ifp-&gt;pim_neighbor_list) &gt; 1);</a>
<a name="ln441"> </a>
<a name="ln442">  /* Save (S,G) */</a>
<a name="ln443">  ch_source = ch-&gt;source_addr;</a>
<a name="ln444">  ch_group = ch-&gt;group_addr;</a>
<a name="ln445"> </a>
<a name="ln446">  ifjoin_to_noinfo(ch);</a>
<a name="ln447">  /* from here ch may have been deleted */</a>
<a name="ln448"> </a>
<a name="ln449">  if (send_prune_echo)</a>
<a name="ln450">    prune_echo(ifp, ch_source, ch_group);</a>
<a name="ln451"> </a>
<a name="ln452">  return 0;</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">static void check_recv_upstream(int is_join,</a>
<a name="ln456">				struct interface *recv_ifp,</a>
<a name="ln457">				struct in_addr upstream,</a>
<a name="ln458">				struct in_addr source_addr,</a>
<a name="ln459">				struct in_addr group_addr,</a>
<a name="ln460">				uint8_t source_flags,</a>
<a name="ln461">				int holdtime)</a>
<a name="ln462">{</a>
<a name="ln463">  struct pim_upstream *up;</a>
<a name="ln464"> </a>
<a name="ln465">  /* Upstream (S,G) in Joined state ? */</a>
<a name="ln466">  up = pim_upstream_find(source_addr, group_addr);</a>
<a name="ln467">  if (!up)</a>
<a name="ln468">    return;</a>
<a name="ln469">  if (up-&gt;join_state != PIM_UPSTREAM_JOINED)</a>
<a name="ln470">    return;</a>
<a name="ln471"> </a>
<a name="ln472">  /* Upstream (S,G) in Joined state */</a>
<a name="ln473"> </a>
<a name="ln474">  if (PIM_INADDR_IS_ANY(up-&gt;rpf.rpf_addr)) {</a>
<a name="ln475">    /* RPF'(S,G) not found */</a>
<a name="ln476">    char src_str[100];</a>
<a name="ln477">    char grp_str[100];</a>
<a name="ln478">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, src_str, sizeof(src_str));</a>
<a name="ln479">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln480">    zlog_warn(&quot;%s %s: RPF'(%s,%s) not found&quot;,</a>
<a name="ln481">	      __FILE__, __PRETTY_FUNCTION__, </a>
<a name="ln482">	      src_str, grp_str);</a>
<a name="ln483">    return;</a>
<a name="ln484">  }</a>
<a name="ln485"> </a>
<a name="ln486">  /* upstream directed to RPF'(S,G) ? */</a>
<a name="ln487">  if (upstream.s_addr != up-&gt;rpf.rpf_addr.s_addr) {</a>
<a name="ln488">    char src_str[100];</a>
<a name="ln489">    char grp_str[100];</a>
<a name="ln490">    char up_str[100];</a>
<a name="ln491">    char rpf_str[100];</a>
<a name="ln492">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, src_str, sizeof(src_str));</a>
<a name="ln493">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln494">    pim_inet4_dump(&quot;&lt;up?&gt;&quot;, upstream, up_str, sizeof(up_str));</a>
<a name="ln495">    pim_inet4_dump(&quot;&lt;rpf?&gt;&quot;, up-&gt;rpf.rpf_addr, rpf_str, sizeof(rpf_str));</a>
<a name="ln496">    zlog_warn(&quot;%s %s: (S,G)=(%s,%s) upstream=%s not directed to RPF'(S,G)=%s on interface %s&quot;,</a>
<a name="ln497">	      __FILE__, __PRETTY_FUNCTION__, </a>
<a name="ln498">	      src_str, grp_str,</a>
<a name="ln499">	      up_str, rpf_str, recv_ifp-&gt;name);</a>
<a name="ln500">    return;</a>
<a name="ln501">  }</a>
<a name="ln502">  /* upstream directed to RPF'(S,G) */</a>
<a name="ln503"> </a>
<a name="ln504">  if (is_join) {</a>
<a name="ln505">    /* Join(S,G) to RPF'(S,G) */</a>
<a name="ln506">    pim_upstream_join_suppress(up, up-&gt;rpf.rpf_addr, holdtime);</a>
<a name="ln507">    return;</a>
<a name="ln508">  }</a>
<a name="ln509"> </a>
<a name="ln510">  /* Prune to RPF'(S,G) */</a>
<a name="ln511"> </a>
<a name="ln512">  if (source_flags &amp; PIM_RPT_BIT_MASK) {</a>
<a name="ln513">    if (source_flags &amp; PIM_WILDCARD_BIT_MASK) {</a>
<a name="ln514">      /* Prune(*,G) to RPF'(S,G) */</a>
<a name="ln515">      pim_upstream_join_timer_decrease_to_t_override(&quot;Prune(*,G)&quot;,</a>
<a name="ln516">						     up, up-&gt;rpf.rpf_addr);</a>
<a name="ln517">      return;</a>
<a name="ln518">    }</a>
<a name="ln519"> </a>
<a name="ln520">    /* Prune(S,G,rpt) to RPF'(S,G) */</a>
<a name="ln521">    pim_upstream_join_timer_decrease_to_t_override(&quot;Prune(S,G,rpt)&quot;,</a>
<a name="ln522">						   up, up-&gt;rpf.rpf_addr);</a>
<a name="ln523">    return;</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526">  /* Prune(S,G) to RPF'(S,G) */</a>
<a name="ln527">  pim_upstream_join_timer_decrease_to_t_override(&quot;Prune(S,G)&quot;, up,</a>
<a name="ln528">						 up-&gt;rpf.rpf_addr);</a>
<a name="ln529">}</a>
<a name="ln530"> </a>
<a name="ln531">static int nonlocal_upstream(int is_join,</a>
<a name="ln532">			     struct interface *recv_ifp,</a>
<a name="ln533">			     struct in_addr upstream,</a>
<a name="ln534">			     struct in_addr source_addr,</a>
<a name="ln535">			     struct in_addr group_addr,</a>
<a name="ln536">			     uint8_t source_flags,</a>
<a name="ln537">			     uint16_t holdtime)</a>
<a name="ln538">{</a>
<a name="ln539">  struct pim_interface *recv_pim_ifp;</a>
<a name="ln540">  int is_local; /* boolean */</a>
<a name="ln541"> </a>
<a name="ln542">  recv_pim_ifp = recv_ifp-&gt;info;</a>
<a name="ln543">  zassert(recv_pim_ifp);</a>
<a name="ln544"> </a>
<a name="ln545">  is_local = (upstream.s_addr == recv_pim_ifp-&gt;primary_address.s_addr);</a>
<a name="ln546">  </a>
<a name="ln547">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln548">    char up_str[100];</a>
<a name="ln549">    char src_str[100];</a>
<a name="ln550">    char grp_str[100];</a>
<a name="ln551">    pim_inet4_dump(&quot;&lt;upstream?&gt;&quot;, upstream, up_str, sizeof(up_str));</a>
<a name="ln552">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, src_str, sizeof(src_str));</a>
<a name="ln553">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln554">    zlog_warn(&quot;%s: recv %s (S,G)=(%s,%s) to %s upstream=%s on %s&quot;,</a>
<a name="ln555">	      __PRETTY_FUNCTION__,</a>
<a name="ln556">	      is_join ? &quot;join&quot; : &quot;prune&quot;,</a>
<a name="ln557">	      src_str, grp_str,</a>
<a name="ln558">	      is_local ? &quot;local&quot; : &quot;non-local&quot;,</a>
<a name="ln559">	      up_str, recv_ifp-&gt;name);</a>
<a name="ln560">  }</a>
<a name="ln561"> </a>
<a name="ln562">  if (is_local)</a>
<a name="ln563">    return 0;</a>
<a name="ln564"> </a>
<a name="ln565">  /*</a>
<a name="ln566">    Since recv upstream addr was not directed to our primary</a>
<a name="ln567">    address, check if we should react to it in any way.</a>
<a name="ln568">  */</a>
<a name="ln569">  check_recv_upstream(is_join, recv_ifp, upstream, source_addr, group_addr,</a>
<a name="ln570">		      source_flags, holdtime);</a>
<a name="ln571"> </a>
<a name="ln572">  return 1; /* non-local */</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">void pim_ifchannel_join_add(struct interface *ifp,</a>
<a name="ln576">			    struct in_addr neigh_addr,</a>
<a name="ln577">			    struct in_addr upstream,</a>
<a name="ln578">			    struct in_addr source_addr,</a>
<a name="ln579">			    struct in_addr group_addr,</a>
<a name="ln580">			    uint8_t source_flags,</a>
<a name="ln581">			    uint16_t holdtime)</a>
<a name="ln582">{</a>
<a name="ln583">  struct pim_interface *pim_ifp;</a>
<a name="ln584">  struct pim_ifchannel *ch;</a>
<a name="ln585"> </a>
<a name="ln586">  if (nonlocal_upstream(1 /* join */, ifp, upstream,</a>
<a name="ln587">			source_addr, group_addr, source_flags, holdtime)) {</a>
<a name="ln588">    return;</a>
<a name="ln589">  }</a>
<a name="ln590"> </a>
<a name="ln591">  ch = pim_ifchannel_add(ifp, source_addr, group_addr);</a>
<a name="ln592">  if (!ch)</a>
<a name="ln593">    return;</a>
<a name="ln594"> </a>
<a name="ln595">  /*</a>
<a name="ln596">    RFC 4601: 4.6.1.  (S,G) Assert Message State Machine</a>
<a name="ln597"> </a>
<a name="ln598">    Transitions from &quot;I am Assert Loser&quot; State</a>
<a name="ln599"> </a>
<a name="ln600">    Receive Join(S,G) on Interface I</a>
<a name="ln601"> </a>
<a name="ln602">    We receive a Join(S,G) that has the Upstream Neighbor Address</a>
<a name="ln603">    field set to my primary IP address on interface I.  The action is</a>
<a name="ln604">    to transition to NoInfo state, delete this (S,G) assert state</a>
<a name="ln605">    (Actions A5 below), and allow the normal PIM Join/Prune mechanisms</a>
<a name="ln606">    to operate.</a>
<a name="ln607"> </a>
<a name="ln608">    Notice: The nonlocal_upstream() test above ensures the upstream</a>
<a name="ln609">    address of the join message is our primary address.</a>
<a name="ln610">   */</a>
<a name="ln611">  if (ch-&gt;ifassert_state == PIM_IFASSERT_I_AM_LOSER) {</a>
<a name="ln612">    char src_str[100];</a>
<a name="ln613">    char grp_str[100];</a>
<a name="ln614">    char neigh_str[100];</a>
<a name="ln615">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, src_str, sizeof(src_str));</a>
<a name="ln616">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln617">    pim_inet4_dump(&quot;&lt;neigh?&gt;&quot;, neigh_addr, neigh_str, sizeof(neigh_str));</a>
<a name="ln618">    zlog_warn(&quot;%s: Assert Loser recv Join(%s,%s) from %s on %s&quot;,</a>
<a name="ln619">	      __PRETTY_FUNCTION__,</a>
<a name="ln620">	      src_str, grp_str, neigh_str, ifp-&gt;name);</a>
<a name="ln621"> </a>
<a name="ln622">    assert_action_a5(ch);</a>
<a name="ln623">  }</a>
<a name="ln624"> </a>
<a name="ln625">  pim_ifp = ifp-&gt;info;</a>
<a name="ln626">  zassert(pim_ifp);</a>
<a name="ln627"> </a>
<a name="ln628">  switch (ch-&gt;ifjoin_state) {</a>
<a name="ln629">  case PIM_IFJOIN_NOINFO:</a>
<a name="ln630">    pim_ifchannel_ifjoin_switch(__PRETTY_FUNCTION__, ch, PIM_IFJOIN_JOIN);</a>
<a name="ln631">    if (pim_macro_chisin_oiflist(ch)) {</a>
<a name="ln632">      pim_forward_start(ch);</a>
<a name="ln633">    }</a>
<a name="ln634">    break;</a>
<a name="ln635">  case PIM_IFJOIN_JOIN:</a>
<a name="ln636">    zassert(!ch-&gt;t_ifjoin_prune_pending_timer);</a>
<a name="ln637"> </a>
<a name="ln638">    /*</a>
<a name="ln639">      In the JOIN state ch-&gt;t_ifjoin_expiry_timer may be NULL due to a</a>
<a name="ln640">      previously received join message with holdtime=0xFFFF.</a>
<a name="ln641">     */</a>
<a name="ln642">    if (ch-&gt;t_ifjoin_expiry_timer) {</a>
<a name="ln643">      unsigned long remain =</a>
<a name="ln644">	thread_timer_remain_second(ch-&gt;t_ifjoin_expiry_timer);</a>
<a name="ln645">      if (remain &gt; holdtime) {</a>
<a name="ln646">	/*</a>
<a name="ln647">	  RFC 4601: 4.5.3.  Receiving (S,G) Join/Prune Messages</a>
<a name="ln648"> </a>
<a name="ln649">	  Transitions from Join State</a>
<a name="ln650"> </a>
<a name="ln651">          The (S,G) downstream state machine on interface I remains in</a>
<a name="ln652">          Join state, and the Expiry Timer (ET) is restarted, set to</a>
<a name="ln653">          maximum of its current value and the HoldTime from the</a>
<a name="ln654">          triggering Join/Prune message.</a>
<a name="ln655"> </a>
<a name="ln656">	  Conclusion: Do not change the ET if the current value is</a>
<a name="ln657">	  higher than the received join holdtime.</a>
<a name="ln658">	 */</a>
<a name="ln659">	return;</a>
<a name="ln660">      }</a>
<a name="ln661">    }</a>
<a name="ln662">    THREAD_OFF(ch-&gt;t_ifjoin_expiry_timer);</a>
<a name="ln663">    break;</a>
<a name="ln664">  case PIM_IFJOIN_PRUNE_PENDING:</a>
<a name="ln665">    zassert(!ch-&gt;t_ifjoin_expiry_timer);</a>
<a name="ln666">    zassert(ch-&gt;t_ifjoin_prune_pending_timer);</a>
<a name="ln667">    THREAD_OFF(ch-&gt;t_ifjoin_prune_pending_timer);</a>
<a name="ln668">    pim_ifchannel_ifjoin_switch(__PRETTY_FUNCTION__, ch, PIM_IFJOIN_JOIN);</a>
<a name="ln669">    break;</a>
<a name="ln670">  }</a>
<a name="ln671"> </a>
<a name="ln672">  zassert(!IFCHANNEL_NOINFO(ch));</a>
<a name="ln673"> </a>
<a name="ln674">  if (holdtime != 0xFFFF) {</a>
<a name="ln675">    THREAD_TIMER_ON(master, ch-&gt;t_ifjoin_expiry_timer,</a>
<a name="ln676">		    on_ifjoin_expiry_timer,</a>
<a name="ln677">		    ch, holdtime);</a>
<a name="ln678">  }</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">void pim_ifchannel_prune(struct interface *ifp,</a>
<a name="ln682">			 struct in_addr upstream,</a>
<a name="ln683">			 struct in_addr source_addr,</a>
<a name="ln684">			 struct in_addr group_addr,</a>
<a name="ln685">			 uint8_t source_flags,</a>
<a name="ln686">			 uint16_t holdtime)</a>
<a name="ln687">{</a>
<a name="ln688">  struct pim_ifchannel *ch;</a>
<a name="ln689">  int jp_override_interval_msec;</a>
<a name="ln690"> </a>
<a name="ln691">  if (nonlocal_upstream(0 /* prune */, ifp, upstream,</a>
<a name="ln692">			source_addr, group_addr, source_flags, holdtime)) {</a>
<a name="ln693">    return;</a>
<a name="ln694">  }</a>
<a name="ln695"> </a>
<a name="ln696">  ch = pim_ifchannel_add(ifp, source_addr, group_addr);</a>
<a name="ln697">  if (!ch)</a>
<a name="ln698">    return;</a>
<a name="ln699"> </a>
<a name="ln700">  switch (ch-&gt;ifjoin_state) {</a>
<a name="ln701">  case PIM_IFJOIN_NOINFO:</a>
<a name="ln702">  case PIM_IFJOIN_PRUNE_PENDING:</a>
<a name="ln703">    /* nothing to do */</a>
<a name="ln704">    break;</a>
<a name="ln705">  case PIM_IFJOIN_JOIN:</a>
<a name="ln706">    {</a>
<a name="ln707">      struct pim_interface *pim_ifp;</a>
<a name="ln708"> </a>
<a name="ln709">      pim_ifp = ifp-&gt;info;</a>
<a name="ln710"> </a>
<a name="ln711">      zassert(ch-&gt;t_ifjoin_expiry_timer);</a>
<a name="ln712">      zassert(!ch-&gt;t_ifjoin_prune_pending_timer);</a>
<a name="ln713"> </a>
<a name="ln714">      THREAD_OFF(ch-&gt;t_ifjoin_expiry_timer);</a>
<a name="ln715">      </a>
<a name="ln716">      pim_ifchannel_ifjoin_switch(__PRETTY_FUNCTION__, ch, PIM_IFJOIN_PRUNE_PENDING);</a>
<a name="ln717">      </a>
<a name="ln718">      if (listcount(pim_ifp-&gt;pim_neighbor_list) &gt; 1) {</a>
<a name="ln719">	jp_override_interval_msec = pim_if_jp_override_interval_msec(ifp);</a>
<a name="ln720">      }</a>
<a name="ln721">      else {</a>
<a name="ln722">	jp_override_interval_msec = 0; /* schedule to expire immediately */</a>
<a name="ln723">	/* If we called ifjoin_prune() directly instead, care should</a>
<a name="ln724">	   be taken not to use &quot;ch&quot; afterwards since it would be</a>
<a name="ln725">	   deleted. */</a>
<a name="ln726">      }</a>
<a name="ln727">      </a>
<a name="ln728">      THREAD_TIMER_MSEC_ON(master, ch-&gt;t_ifjoin_prune_pending_timer,</a>
<a name="ln729">			   on_ifjoin_prune_pending_timer,</a>
<a name="ln730">			   ch, jp_override_interval_msec);</a>
<a name="ln731">      </a>
<a name="ln732">      zassert(!ch-&gt;t_ifjoin_expiry_timer);</a>
<a name="ln733">      zassert(ch-&gt;t_ifjoin_prune_pending_timer);</a>
<a name="ln734">    }</a>
<a name="ln735">    break;</a>
<a name="ln736">  }</a>
<a name="ln737"> </a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">void pim_ifchannel_local_membership_add(struct interface *ifp,</a>
<a name="ln741">					struct in_addr source_addr,</a>
<a name="ln742">					struct in_addr group_addr)</a>
<a name="ln743">{</a>
<a name="ln744">  struct pim_ifchannel *ch;</a>
<a name="ln745">  struct pim_interface *pim_ifp;</a>
<a name="ln746"> </a>
<a name="ln747">  /* PIM enabled on interface? */</a>
<a name="ln748">  pim_ifp = ifp-&gt;info;</a>
<a name="ln749">  if (!pim_ifp)</a>
<a name="ln750">    return;</a>
<a name="ln751">  if (!PIM_IF_TEST_PIM(pim_ifp-&gt;options))</a>
<a name="ln752">    return;</a>
<a name="ln753"> </a>
<a name="ln754">  ch = pim_ifchannel_add(ifp, source_addr, group_addr);</a>
<a name="ln755">  if (!ch) {</a>
<a name="ln756">    return;</a>
<a name="ln757">  }</a>
<a name="ln758"> </a>
<a name="ln759">  ifmembership_set(ch, PIM_IFMEMBERSHIP_INCLUDE);</a>
<a name="ln760"> </a>
<a name="ln761">  zassert(!IFCHANNEL_NOINFO(ch));</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">void pim_ifchannel_local_membership_del(struct interface *ifp,</a>
<a name="ln765">					struct in_addr source_addr,</a>
<a name="ln766">					struct in_addr group_addr)</a>
<a name="ln767">{</a>
<a name="ln768">  struct pim_ifchannel *ch;</a>
<a name="ln769">  struct pim_interface *pim_ifp;</a>
<a name="ln770"> </a>
<a name="ln771">  /* PIM enabled on interface? */</a>
<a name="ln772">  pim_ifp = ifp-&gt;info;</a>
<a name="ln773">  if (!pim_ifp)</a>
<a name="ln774">    return;</a>
<a name="ln775">  if (!PIM_IF_TEST_PIM(pim_ifp-&gt;options))</a>
<a name="ln776">    return;</a>
<a name="ln777"> </a>
<a name="ln778">  ch = pim_ifchannel_find(ifp, source_addr, group_addr);</a>
<a name="ln779">  if (!ch)</a>
<a name="ln780">    return;</a>
<a name="ln781"> </a>
<a name="ln782">  ifmembership_set(ch, PIM_IFMEMBERSHIP_NOINFO);</a>
<a name="ln783"> </a>
<a name="ln784">  delete_on_noinfo(ch);</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">void pim_ifchannel_update_could_assert(struct pim_ifchannel *ch)</a>
<a name="ln788">{</a>
<a name="ln789">  int old_couldassert = PIM_FORCE_BOOLEAN(PIM_IF_FLAG_TEST_COULD_ASSERT(ch-&gt;flags));</a>
<a name="ln790">  int new_couldassert = PIM_FORCE_BOOLEAN(pim_macro_ch_could_assert_eval(ch));</a>
<a name="ln791"> </a>
<a name="ln792">  if (new_couldassert == old_couldassert)</a>
<a name="ln793">    return;</a>
<a name="ln794"> </a>
<a name="ln795">  if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln796">    char src_str[100];</a>
<a name="ln797">    char grp_str[100];</a>
<a name="ln798">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln799">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln800">    zlog_debug(&quot;%s: CouldAssert(%s,%s,%s) changed from %d to %d&quot;,</a>
<a name="ln801">	       __PRETTY_FUNCTION__,</a>
<a name="ln802">	       src_str, grp_str, ch-&gt;interface-&gt;name,</a>
<a name="ln803">	       old_couldassert, new_couldassert);</a>
<a name="ln804">  }</a>
<a name="ln805"> </a>
<a name="ln806">  if (new_couldassert) {</a>
<a name="ln807">    /* CouldAssert(S,G,I) switched from FALSE to TRUE */</a>
<a name="ln808">    PIM_IF_FLAG_SET_COULD_ASSERT(ch-&gt;flags);</a>
<a name="ln809">  }</a>
<a name="ln810">  else {</a>
<a name="ln811">    /* CouldAssert(S,G,I) switched from TRUE to FALSE */</a>
<a name="ln812">    PIM_IF_FLAG_UNSET_COULD_ASSERT(ch-&gt;flags);</a>
<a name="ln813"> </a>
<a name="ln814">    if (ch-&gt;ifassert_state == PIM_IFASSERT_I_AM_WINNER) {</a>
<a name="ln815">      assert_action_a4(ch);</a>
<a name="ln816">    }</a>
<a name="ln817">  }</a>
<a name="ln818"> </a>
<a name="ln819">  pim_ifchannel_update_my_assert_metric(ch);</a>
<a name="ln820">}</a>
<a name="ln821"> </a>
<a name="ln822">/*</a>
<a name="ln823">  my_assert_metric may be affected by:</a>
<a name="ln824"> </a>
<a name="ln825">  CouldAssert(S,G)</a>
<a name="ln826">  pim_ifp-&gt;primary_address</a>
<a name="ln827">  rpf-&gt;source_nexthop.mrib_metric_preference;</a>
<a name="ln828">  rpf-&gt;source_nexthop.mrib_route_metric;</a>
<a name="ln829"> */</a>
<a name="ln830">void pim_ifchannel_update_my_assert_metric(struct pim_ifchannel *ch)</a>
<a name="ln831">{</a>
<a name="ln832">  struct pim_assert_metric my_metric_new = pim_macro_ch_my_assert_metric_eval(ch);</a>
<a name="ln833"> </a>
<a name="ln834">  if (pim_assert_metric_match(&amp;my_metric_new, &amp;ch-&gt;ifassert_my_metric))</a>
<a name="ln835">      return;</a>
<a name="ln836"> </a>
<a name="ln837">  if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln838">    char src_str[100];</a>
<a name="ln839">    char grp_str[100];</a>
<a name="ln840">    char old_addr_str[100];</a>
<a name="ln841">    char new_addr_str[100];</a>
<a name="ln842">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln843">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln844">    pim_inet4_dump(&quot;&lt;old_addr?&gt;&quot;, ch-&gt;ifassert_my_metric.ip_address, old_addr_str, sizeof(old_addr_str));</a>
<a name="ln845">    pim_inet4_dump(&quot;&lt;new_addr?&gt;&quot;, my_metric_new.ip_address, new_addr_str, sizeof(new_addr_str));</a>
<a name="ln846">    zlog_debug(&quot;%s: my_assert_metric(%s,%s,%s) changed from %u,%u,%u,%s to %u,%u,%u,%s&quot;,</a>
<a name="ln847">	       __PRETTY_FUNCTION__,</a>
<a name="ln848">	       src_str, grp_str, ch-&gt;interface-&gt;name,</a>
<a name="ln849">	       ch-&gt;ifassert_my_metric.rpt_bit_flag,</a>
<a name="ln850">	       ch-&gt;ifassert_my_metric.metric_preference,</a>
<a name="ln851">	       ch-&gt;ifassert_my_metric.route_metric,</a>
<a name="ln852">	       old_addr_str,</a>
<a name="ln853">	       my_metric_new.rpt_bit_flag,</a>
<a name="ln854">	       my_metric_new.metric_preference,</a>
<a name="ln855">	       my_metric_new.route_metric,</a>
<a name="ln856">	       new_addr_str);</a>
<a name="ln857">  }</a>
<a name="ln858"> </a>
<a name="ln859">  ch-&gt;ifassert_my_metric = my_metric_new;</a>
<a name="ln860"> </a>
<a name="ln861">  if (pim_assert_metric_better(&amp;ch-&gt;ifassert_my_metric,</a>
<a name="ln862">			       &amp;ch-&gt;ifassert_winner_metric)) {</a>
<a name="ln863">    assert_action_a5(ch);</a>
<a name="ln864">  }</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867">void pim_ifchannel_update_assert_tracking_desired(struct pim_ifchannel *ch)</a>
<a name="ln868">{</a>
<a name="ln869">  int old_atd = PIM_FORCE_BOOLEAN(PIM_IF_FLAG_TEST_ASSERT_TRACKING_DESIRED(ch-&gt;flags));</a>
<a name="ln870">  int new_atd = PIM_FORCE_BOOLEAN(pim_macro_assert_tracking_desired_eval(ch));</a>
<a name="ln871"> </a>
<a name="ln872">  if (new_atd == old_atd)</a>
<a name="ln873">    return;</a>
<a name="ln874"> </a>
<a name="ln875">  if (PIM_DEBUG_PIM_EVENTS) {</a>
<a name="ln876">    char src_str[100];</a>
<a name="ln877">    char grp_str[100];</a>
<a name="ln878">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ch-&gt;source_addr, src_str, sizeof(src_str));</a>
<a name="ln879">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, ch-&gt;group_addr, grp_str, sizeof(grp_str));</a>
<a name="ln880">    zlog_debug(&quot;%s: AssertTrackingDesired(%s,%s,%s) changed from %d to %d&quot;,</a>
<a name="ln881">	       __PRETTY_FUNCTION__,</a>
<a name="ln882">	       src_str, grp_str, ch-&gt;interface-&gt;name,</a>
<a name="ln883">	       old_atd, new_atd);</a>
<a name="ln884">  }</a>
<a name="ln885"> </a>
<a name="ln886">  if (new_atd) {</a>
<a name="ln887">    /* AssertTrackingDesired(S,G,I) switched from FALSE to TRUE */</a>
<a name="ln888">    PIM_IF_FLAG_SET_ASSERT_TRACKING_DESIRED(ch-&gt;flags);</a>
<a name="ln889">  }</a>
<a name="ln890">  else {</a>
<a name="ln891">    /* AssertTrackingDesired(S,G,I) switched from TRUE to FALSE */</a>
<a name="ln892">    PIM_IF_FLAG_UNSET_ASSERT_TRACKING_DESIRED(ch-&gt;flags);</a>
<a name="ln893"> </a>
<a name="ln894">    if (ch-&gt;ifassert_state == PIM_IFASSERT_I_AM_LOSER) {</a>
<a name="ln895">      assert_action_a5(ch);</a>
<a name="ln896">    }</a>
<a name="ln897">  }</a>
<a name="ln898">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
