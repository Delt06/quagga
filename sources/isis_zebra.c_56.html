
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_zebra.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol - isis_zebra.c   </a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2001,2002   Sampo Saaristo</a>
<a name="ln5"> *                           Tampere University of Technology      </a>
<a name="ln6"> *                           Institute of Communications Engineering</a>
<a name="ln7"> * Copyright (C) 2013-2015   Christian Franke &lt;chris@opensourcerouting.org&gt;</a>
<a name="ln8"> *</a>
<a name="ln9"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln10"> * under the terms of the GNU General Public Licenseas published by the Free </a>
<a name="ln11"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln12"> * any later version.</a>
<a name="ln13"> *</a>
<a name="ln14"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln15"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln16"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln17"> * more details.</a>
<a name="ln18"> </a>
<a name="ln19"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln20"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln21"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;thread.h&quot;</a>
<a name="ln27">#include &quot;command.h&quot;</a>
<a name="ln28">#include &quot;memory.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;if.h&quot;</a>
<a name="ln31">#include &quot;network.h&quot;</a>
<a name="ln32">#include &quot;prefix.h&quot;</a>
<a name="ln33">#include &quot;zclient.h&quot;</a>
<a name="ln34">#include &quot;stream.h&quot;</a>
<a name="ln35">#include &quot;linklist.h&quot;</a>
<a name="ln36">#include &quot;vrf.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;isisd/dict.h&quot;</a>
<a name="ln39">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln40">#include &quot;isisd/isis_common.h&quot;</a>
<a name="ln41">#include &quot;isisd/isis_flags.h&quot;</a>
<a name="ln42">#include &quot;isisd/isis_misc.h&quot;</a>
<a name="ln43">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln44">#include &quot;isisd/isis_tlv.h&quot;</a>
<a name="ln45">#include &quot;isisd/isisd.h&quot;</a>
<a name="ln46">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln47">#include &quot;isisd/isis_csm.h&quot;</a>
<a name="ln48">#include &quot;isisd/isis_lsp.h&quot;</a>
<a name="ln49">#include &quot;isisd/isis_route.h&quot;</a>
<a name="ln50">#include &quot;isisd/isis_zebra.h&quot;</a>
<a name="ln51">#include &quot;isisd/isis_te.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">struct zclient *zclient = NULL;</a>
<a name="ln54"> </a>
<a name="ln55">/* Router-id update message from zebra. */</a>
<a name="ln56">static int</a>
<a name="ln57">isis_router_id_update_zebra (int command, struct zclient *zclient,</a>
<a name="ln58">			     zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln59">{</a>
<a name="ln60">  struct isis_area *area;</a>
<a name="ln61">  struct listnode *node;</a>
<a name="ln62">  struct prefix router_id;</a>
<a name="ln63"> </a>
<a name="ln64">  /*</a>
<a name="ln65">   * If ISIS TE is enable, TE Router ID is set through specific command.</a>
<a name="ln66">   * See mpls_te_router_addr() command in isis_te.c</a>
<a name="ln67">   */</a>
<a name="ln68">  if (IS_MPLS_TE(isisMplsTE))</a>
<a name="ln69">    return 0;</a>
<a name="ln70"> </a>
<a name="ln71">  zebra_router_id_update_read (zclient-&gt;ibuf, &amp;router_id);</a>
<a name="ln72">  if (isis-&gt;router_id == router_id.u.prefix4.s_addr)</a>
<a name="ln73">    return 0;</a>
<a name="ln74"> </a>
<a name="ln75">  isis-&gt;router_id = router_id.u.prefix4.s_addr;</a>
<a name="ln76">  for (ALL_LIST_ELEMENTS_RO (isis-&gt;area_list, node, area))</a>
<a name="ln77">    if (listcount (area-&gt;area_addrs) &gt; 0)</a>
<a name="ln78">      lsp_regenerate_schedule (area, area-&gt;is_type, 0);</a>
<a name="ln79"> </a>
<a name="ln80">  return 0;</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">static int</a>
<a name="ln84">isis_zebra_if_add (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln85">    vrf_id_t vrf_id)</a>
<a name="ln86">{</a>
<a name="ln87">  struct interface *ifp;</a>
<a name="ln88"> </a>
<a name="ln89">  ifp = zebra_interface_add_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln90"> </a>
<a name="ln91">  if (isis-&gt;debugs &amp; DEBUG_ZEBRA)</a>
<a name="ln92">    zlog_debug (&quot;Zebra I/F add: %s index %d flags %ld metric %d mtu %d&quot;,</a>
<a name="ln93">		ifp-&gt;name, ifp-&gt;ifindex, (long)ifp-&gt;flags, ifp-&gt;metric, ifp-&gt;mtu);</a>
<a name="ln94"> </a>
<a name="ln95">  if (if_is_operative (ifp))</a>
<a name="ln96">    isis_csm_state_change (IF_UP_FROM_Z, circuit_scan_by_ifp (ifp), ifp);</a>
<a name="ln97"> </a>
<a name="ln98">  return 0;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">static int</a>
<a name="ln102">isis_zebra_if_del (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln103">    vrf_id_t vrf_id)</a>
<a name="ln104">{</a>
<a name="ln105">  struct interface *ifp;</a>
<a name="ln106">  struct stream *s;</a>
<a name="ln107"> </a>
<a name="ln108">  s = zclient-&gt;ibuf;</a>
<a name="ln109">  ifp = zebra_interface_state_read (s, vrf_id);</a>
<a name="ln110"> </a>
<a name="ln111">  if (!ifp)</a>
<a name="ln112">    return 0;</a>
<a name="ln113"> </a>
<a name="ln114">  if (if_is_operative (ifp))</a>
<a name="ln115">    zlog_warn (&quot;Zebra: got delete of %s, but interface is still up&quot;,</a>
<a name="ln116">	       ifp-&gt;name);</a>
<a name="ln117"> </a>
<a name="ln118">  if (isis-&gt;debugs &amp; DEBUG_ZEBRA)</a>
<a name="ln119">    zlog_debug (&quot;Zebra I/F delete: %s index %d flags %ld metric %d mtu %d&quot;,</a>
<a name="ln120">		ifp-&gt;name, ifp-&gt;ifindex, (long)ifp-&gt;flags, ifp-&gt;metric, ifp-&gt;mtu);</a>
<a name="ln121"> </a>
<a name="ln122">  isis_csm_state_change (IF_DOWN_FROM_Z, circuit_scan_by_ifp (ifp), ifp);</a>
<a name="ln123"> </a>
<a name="ln124">  /* Cannot call if_delete because we should retain the pseudo interface</a>
<a name="ln125">     in case there is configuration info attached to it. */</a>
<a name="ln126">  if_delete_retain(ifp);</a>
<a name="ln127"> </a>
<a name="ln128">  ifp-&gt;ifindex = IFINDEX_INTERNAL;</a>
<a name="ln129"> </a>
<a name="ln130">  return 0;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">static int</a>
<a name="ln134">isis_zebra_if_state_up (int command, struct zclient *zclient,</a>
<a name="ln135">			zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln136">{</a>
<a name="ln137">  struct interface *ifp;</a>
<a name="ln138"> </a>
<a name="ln139">  ifp = zebra_interface_state_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln140"> </a>
<a name="ln141">  if (ifp == NULL)</a>
<a name="ln142">    return 0;</a>
<a name="ln143"> </a>
<a name="ln144">  isis_csm_state_change (IF_UP_FROM_Z, circuit_scan_by_ifp (ifp), ifp);</a>
<a name="ln145"> </a>
<a name="ln146">  return 0;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">static int</a>
<a name="ln150">isis_zebra_if_state_down (int command, struct zclient *zclient,</a>
<a name="ln151">			  zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln152">{</a>
<a name="ln153">  struct interface *ifp;</a>
<a name="ln154">  struct isis_circuit *circuit;</a>
<a name="ln155"> </a>
<a name="ln156">  ifp = zebra_interface_state_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln157"> </a>
<a name="ln158">  if (ifp == NULL)</a>
<a name="ln159">    return 0;</a>
<a name="ln160"> </a>
<a name="ln161">  circuit = isis_csm_state_change (IF_DOWN_FROM_Z, circuit_scan_by_ifp (ifp),</a>
<a name="ln162">                                   ifp);</a>
<a name="ln163">  if (circuit)</a>
<a name="ln164">    SET_FLAG(circuit-&gt;flags, ISIS_CIRCUIT_FLAPPED_AFTER_SPF);</a>
<a name="ln165"> </a>
<a name="ln166">  return 0;</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">static int</a>
<a name="ln170">isis_zebra_if_address_add (int command, struct zclient *zclient,</a>
<a name="ln171">			   zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln172">{</a>
<a name="ln173">  struct connected *c;</a>
<a name="ln174">  struct prefix *p;</a>
<a name="ln175">  char buf[BUFSIZ];</a>
<a name="ln176"> </a>
<a name="ln177">  c = zebra_interface_address_read (ZEBRA_INTERFACE_ADDRESS_ADD,</a>
<a name="ln178">				    zclient-&gt;ibuf, vrf_id);</a>
<a name="ln179"> </a>
<a name="ln180">  if (c == NULL)</a>
<a name="ln181">    return 0;</a>
<a name="ln182"> </a>
<a name="ln183">  p = c-&gt;address;</a>
<a name="ln184"> </a>
<a name="ln185">  prefix2str (p, buf, BUFSIZ);</a>
<a name="ln186">#ifdef EXTREME_DEBUG</a>
<a name="ln187">  if (p-&gt;family == AF_INET)</a>
<a name="ln188">    zlog_debug (&quot;connected IP address %s&quot;, buf);</a>
<a name="ln189">#ifdef HAVE_IPV6</a>
<a name="ln190">  if (p-&gt;family == AF_INET6)</a>
<a name="ln191">    zlog_debug (&quot;connected IPv6 address %s&quot;, buf);</a>
<a name="ln192">#endif /* HAVE_IPV6 */</a>
<a name="ln193">#endif /* EXTREME_DEBUG */</a>
<a name="ln194">  if (if_is_operative (c-&gt;ifp))</a>
<a name="ln195">    isis_circuit_add_addr (circuit_scan_by_ifp (c-&gt;ifp), c);</a>
<a name="ln196"> </a>
<a name="ln197">  return 0;</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">static int</a>
<a name="ln201">isis_zebra_if_address_del (int command, struct zclient *client,</a>
<a name="ln202">			   zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln203">{</a>
<a name="ln204">  struct connected *c;</a>
<a name="ln205">  struct interface *ifp;</a>
<a name="ln206">#ifdef EXTREME_DEBUG</a>
<a name="ln207">  struct prefix *p;</a>
<a name="ln208">  u_char buf[BUFSIZ];</a>
<a name="ln209">#endif /* EXTREME_DEBUG */</a>
<a name="ln210"> </a>
<a name="ln211">  c = zebra_interface_address_read (ZEBRA_INTERFACE_ADDRESS_DELETE,</a>
<a name="ln212">				    zclient-&gt;ibuf, vrf_id);</a>
<a name="ln213"> </a>
<a name="ln214">  if (c == NULL)</a>
<a name="ln215">    return 0;</a>
<a name="ln216"> </a>
<a name="ln217">  ifp = c-&gt;ifp;</a>
<a name="ln218"> </a>
<a name="ln219">#ifdef EXTREME_DEBUG</a>
<a name="ln220">  p = c-&gt;address;</a>
<a name="ln221">  prefix2str (p, buf, BUFSIZ);</a>
<a name="ln222"> </a>
<a name="ln223">  if (p-&gt;family == AF_INET)</a>
<a name="ln224">    zlog_debug (&quot;disconnected IP address %s&quot;, buf);</a>
<a name="ln225">#ifdef HAVE_IPV6</a>
<a name="ln226">  if (p-&gt;family == AF_INET6)</a>
<a name="ln227">    zlog_debug (&quot;disconnected IPv6 address %s&quot;, buf);</a>
<a name="ln228">#endif /* HAVE_IPV6 */</a>
<a name="ln229">#endif /* EXTREME_DEBUG */</a>
<a name="ln230"> </a>
<a name="ln231">  if (if_is_operative (ifp))</a>
<a name="ln232">    isis_circuit_del_addr (circuit_scan_by_ifp (ifp), c);</a>
<a name="ln233">  connected_free (c);</a>
<a name="ln234"> </a>
<a name="ln235">  return 0;</a>
<a name="ln236">}</a>
<a name="ln237"> </a>
<a name="ln238">static int</a>
<a name="ln239">isis_zebra_link_params (int command, struct zclient *zclient,</a>
<a name="ln240">                        zebra_size_t length)</a>
<a name="ln241">{</a>
<a name="ln242">  struct interface *ifp;</a>
<a name="ln243"> </a>
<a name="ln244">  ifp = zebra_interface_link_params_read (zclient-&gt;ibuf);</a>
<a name="ln245"> </a>
<a name="ln246">  if (ifp == NULL)</a>
<a name="ln247">    return 0;</a>
<a name="ln248"> </a>
<a name="ln249">  /* Update TE TLV */</a>
<a name="ln250">  isis_mpls_te_update(ifp);</a>
<a name="ln251"> </a>
<a name="ln252">  return 0;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">static void</a>
<a name="ln256">isis_zebra_route_add_ipv4 (struct prefix *prefix,</a>
<a name="ln257">			   struct isis_route_info *route_info)</a>
<a name="ln258">{</a>
<a name="ln259">  u_char message, flags;</a>
<a name="ln260">  int psize;</a>
<a name="ln261">  struct stream *stream;</a>
<a name="ln262">  struct isis_nexthop *nexthop;</a>
<a name="ln263">  struct listnode *node;</a>
<a name="ln264"> </a>
<a name="ln265">  if (CHECK_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED))</a>
<a name="ln266">    return;</a>
<a name="ln267"> </a>
<a name="ln268">  if (vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_ISIS], VRF_DEFAULT))</a>
<a name="ln269">    {</a>
<a name="ln270">      message = 0;</a>
<a name="ln271">      flags = 0;</a>
<a name="ln272"> </a>
<a name="ln273">      SET_FLAG (message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln274">      SET_FLAG (message, ZAPI_MESSAGE_METRIC);</a>
<a name="ln275">#if 0</a>
<a name="ln276">      SET_FLAG (message, ZAPI_MESSAGE_DISTANCE);</a>
<a name="ln277">#endif</a>
<a name="ln278"> </a>
<a name="ln279">      stream = zclient-&gt;obuf;</a>
<a name="ln280">      stream_reset (stream);</a>
<a name="ln281">      zclient_create_header (stream, ZEBRA_IPV4_ROUTE_ADD, VRF_DEFAULT);</a>
<a name="ln282">      /* type */</a>
<a name="ln283">      stream_putc (stream, ZEBRA_ROUTE_ISIS);</a>
<a name="ln284">      /* flags */</a>
<a name="ln285">      stream_putc (stream, flags);</a>
<a name="ln286">      /* message */</a>
<a name="ln287">      stream_putc (stream, message);</a>
<a name="ln288">      /* SAFI */</a>
<a name="ln289">      stream_putw (stream, SAFI_UNICAST);</a>
<a name="ln290">      /* prefix information */</a>
<a name="ln291">      psize = PSIZE (prefix-&gt;prefixlen);</a>
<a name="ln292">      stream_putc (stream, prefix-&gt;prefixlen);</a>
<a name="ln293">      stream_write (stream, (u_char *) &amp; prefix-&gt;u.prefix4, psize);</a>
<a name="ln294"> </a>
<a name="ln295">      stream_putc (stream, listcount (route_info-&gt;nexthops));</a>
<a name="ln296"> </a>
<a name="ln297">      /* Nexthop, ifindex, distance and metric information */</a>
<a name="ln298">      for (ALL_LIST_ELEMENTS_RO (route_info-&gt;nexthops, node, nexthop))</a>
<a name="ln299">	{</a>
<a name="ln300">	  /* FIXME: can it be ? */</a>
<a name="ln301">	  if (nexthop-&gt;ip.s_addr != INADDR_ANY)</a>
<a name="ln302">	    {</a>
<a name="ln303">	      stream_putc (stream, ZEBRA_NEXTHOP_IPV4);</a>
<a name="ln304">	      stream_put_in_addr (stream, &amp;nexthop-&gt;ip);</a>
<a name="ln305">	    }</a>
<a name="ln306">	  else</a>
<a name="ln307">	    {</a>
<a name="ln308">	      stream_putc (stream, ZEBRA_NEXTHOP_IFINDEX);</a>
<a name="ln309">	      stream_putl (stream, nexthop-&gt;ifindex);</a>
<a name="ln310">	    }</a>
<a name="ln311">	}</a>
<a name="ln312">#if 0</a>
<a name="ln313">      if (CHECK_FLAG (message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln314">	stream_putc (stream, route_info-&gt;depth);</a>
<a name="ln315">#endif</a>
<a name="ln316">      if (CHECK_FLAG (message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln317">	stream_putl (stream, route_info-&gt;cost);</a>
<a name="ln318"> </a>
<a name="ln319">      stream_putw_at (stream, 0, stream_get_endp (stream));</a>
<a name="ln320">      zclient_send_message(zclient);</a>
<a name="ln321">      SET_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);</a>
<a name="ln322">      UNSET_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_RESYNC);</a>
<a name="ln323">    }</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">static void</a>
<a name="ln327">isis_zebra_route_del_ipv4 (struct prefix *prefix,</a>
<a name="ln328">			   struct isis_route_info *route_info)</a>
<a name="ln329">{</a>
<a name="ln330">  struct zapi_ipv4 api;</a>
<a name="ln331">  struct prefix_ipv4 prefix4;</a>
<a name="ln332"> </a>
<a name="ln333">  if (vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_ISIS], VRF_DEFAULT))</a>
<a name="ln334">    {</a>
<a name="ln335">      api.vrf_id = VRF_DEFAULT;</a>
<a name="ln336">      api.type = ZEBRA_ROUTE_ISIS;</a>
<a name="ln337">      api.flags = 0;</a>
<a name="ln338">      api.message = 0;</a>
<a name="ln339">      api.safi = SAFI_UNICAST;</a>
<a name="ln340">      prefix4.family = AF_INET;</a>
<a name="ln341">      prefix4.prefixlen = prefix-&gt;prefixlen;</a>
<a name="ln342">      prefix4.prefix = prefix-&gt;u.prefix4;</a>
<a name="ln343">      zapi_ipv4_route (ZEBRA_IPV4_ROUTE_DELETE, zclient, &amp;prefix4, &amp;api);</a>
<a name="ln344">    }</a>
<a name="ln345">  UNSET_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);</a>
<a name="ln346"> </a>
<a name="ln347">  return;</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">#ifdef HAVE_IPV6</a>
<a name="ln351">static void</a>
<a name="ln352">isis_zebra_route_add_ipv6 (struct prefix *prefix,</a>
<a name="ln353">			   struct isis_route_info *route_info)</a>
<a name="ln354">{</a>
<a name="ln355">  struct zapi_ipv6 api;</a>
<a name="ln356">  struct in6_addr **nexthop_list;</a>
<a name="ln357">  ifindex_t *ifindex_list;</a>
<a name="ln358">  struct isis_nexthop6 *nexthop6;</a>
<a name="ln359">  int i, size;</a>
<a name="ln360">  struct listnode *node;</a>
<a name="ln361">  struct prefix_ipv6 prefix6;</a>
<a name="ln362"> </a>
<a name="ln363">  if (CHECK_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED))</a>
<a name="ln364">    return;</a>
<a name="ln365"> </a>
<a name="ln366">  api.vrf_id = VRF_DEFAULT;</a>
<a name="ln367">  api.type = ZEBRA_ROUTE_ISIS;</a>
<a name="ln368">  api.flags = 0;</a>
<a name="ln369">  api.message = 0;</a>
<a name="ln370">  api.safi = SAFI_UNICAST;</a>
<a name="ln371">  SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln372">  SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);</a>
<a name="ln373">  SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);</a>
<a name="ln374">  api.metric = route_info-&gt;cost;</a>
<a name="ln375">#if 0</a>
<a name="ln376">  SET_FLAG (api.message, ZAPI_MESSAGE_DISTANCE);</a>
<a name="ln377">  api.distance = route_info-&gt;depth;</a>
<a name="ln378">#endif</a>
<a name="ln379">  api.nexthop_num = listcount (route_info-&gt;nexthops6);</a>
<a name="ln380">  api.ifindex_num = listcount (route_info-&gt;nexthops6);</a>
<a name="ln381"> </a>
<a name="ln382">  /* allocate memory for nexthop_list */</a>
<a name="ln383">  size = sizeof (struct isis_nexthop6 *) * listcount (route_info-&gt;nexthops6);</a>
<a name="ln384">  nexthop_list = (struct in6_addr **) XMALLOC (MTYPE_ISIS_TMP, size);</a>
<a name="ln385">  if (!nexthop_list)</a>
<a name="ln386">    {</a>
<a name="ln387">      zlog_err (&quot;isis_zebra_add_route_ipv6: out of memory!&quot;);</a>
<a name="ln388">      return;</a>
<a name="ln389">    }</a>
<a name="ln390"> </a>
<a name="ln391">  /* allocate memory for ifindex_list */</a>
<a name="ln392">  size = sizeof (unsigned int) * listcount (route_info-&gt;nexthops6);</a>
<a name="ln393">  ifindex_list = (ifindex_t *) XMALLOC (MTYPE_ISIS_TMP, size);</a>
<a name="ln394">  if (!ifindex_list)</a>
<a name="ln395">    {</a>
<a name="ln396">      zlog_err (&quot;isis_zebra_add_route_ipv6: out of memory!&quot;);</a>
<a name="ln397">      XFREE (MTYPE_ISIS_TMP, nexthop_list);</a>
<a name="ln398">      return;</a>
<a name="ln399">    }</a>
<a name="ln400"> </a>
<a name="ln401">  /* for each nexthop */</a>
<a name="ln402">  i = 0;</a>
<a name="ln403">  for (ALL_LIST_ELEMENTS_RO (route_info-&gt;nexthops6, node, nexthop6))</a>
<a name="ln404">    {</a>
<a name="ln405">      if (!IN6_IS_ADDR_LINKLOCAL (&amp;nexthop6-&gt;ip6) &amp;&amp;</a>
<a name="ln406">	  !IN6_IS_ADDR_UNSPECIFIED (&amp;nexthop6-&gt;ip6))</a>
<a name="ln407">	{</a>
<a name="ln408">	  api.nexthop_num--;</a>
<a name="ln409">	  api.ifindex_num--;</a>
<a name="ln410">	  continue;</a>
<a name="ln411">	}</a>
<a name="ln412"> </a>
<a name="ln413">      nexthop_list[i] = &amp;nexthop6-&gt;ip6;</a>
<a name="ln414">      ifindex_list[i] = nexthop6-&gt;ifindex;</a>
<a name="ln415">      i++;</a>
<a name="ln416">    }</a>
<a name="ln417"> </a>
<a name="ln418">  api.nexthop = nexthop_list;</a>
<a name="ln419">  api.ifindex = ifindex_list;</a>
<a name="ln420"> </a>
<a name="ln421">  if (api.nexthop_num &amp;&amp; api.ifindex_num)</a>
<a name="ln422">    {</a>
<a name="ln423">      prefix6.family = AF_INET6;</a>
<a name="ln424">      prefix6.prefixlen = prefix-&gt;prefixlen;</a>
<a name="ln425">      memcpy (&amp;prefix6.prefix, &amp;prefix-&gt;u.prefix6, sizeof (struct in6_addr));</a>
<a name="ln426">      zapi_ipv6_route (ZEBRA_IPV6_ROUTE_ADD, zclient, &amp;prefix6, &amp;api);</a>
<a name="ln427">      SET_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);</a>
<a name="ln428">      UNSET_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_RESYNC);</a>
<a name="ln429">    }</a>
<a name="ln430"> </a>
<a name="ln431">  XFREE (MTYPE_ISIS_TMP, nexthop_list);</a>
<a name="ln432">  XFREE (MTYPE_ISIS_TMP, ifindex_list);</a>
<a name="ln433"> </a>
<a name="ln434">  return;</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">static void</a>
<a name="ln438">isis_zebra_route_del_ipv6 (struct prefix *prefix,</a>
<a name="ln439">			   struct isis_route_info *route_info)</a>
<a name="ln440">{</a>
<a name="ln441">  struct zapi_ipv6 api;</a>
<a name="ln442">  struct in6_addr **nexthop_list;</a>
<a name="ln443">  ifindex_t *ifindex_list;</a>
<a name="ln444">  struct isis_nexthop6 *nexthop6;</a>
<a name="ln445">  int i, size;</a>
<a name="ln446">  struct listnode *node;</a>
<a name="ln447">  struct prefix_ipv6 prefix6;</a>
<a name="ln448"> </a>
<a name="ln449">  if (!CHECK_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED))</a>
<a name="ln450">    return;</a>
<a name="ln451"> </a>
<a name="ln452">  api.vrf_id = VRF_DEFAULT;</a>
<a name="ln453">  api.type = ZEBRA_ROUTE_ISIS;</a>
<a name="ln454">  api.flags = 0;</a>
<a name="ln455">  api.message = 0;</a>
<a name="ln456">  api.safi = SAFI_UNICAST;</a>
<a name="ln457">  SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln458">  SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);</a>
<a name="ln459">  api.nexthop_num = listcount (route_info-&gt;nexthops6);</a>
<a name="ln460">  api.ifindex_num = listcount (route_info-&gt;nexthops6);</a>
<a name="ln461"> </a>
<a name="ln462">  /* allocate memory for nexthop_list */</a>
<a name="ln463">  size = sizeof (struct isis_nexthop6 *) * listcount (route_info-&gt;nexthops6);</a>
<a name="ln464">  nexthop_list = (struct in6_addr **) XMALLOC (MTYPE_ISIS_TMP, size);</a>
<a name="ln465">  if (!nexthop_list)</a>
<a name="ln466">    {</a>
<a name="ln467">      zlog_err (&quot;isis_zebra_route_del_ipv6: out of memory!&quot;);</a>
<a name="ln468">      return;</a>
<a name="ln469">    }</a>
<a name="ln470"> </a>
<a name="ln471">  /* allocate memory for ifindex_list */</a>
<a name="ln472">  size = sizeof (unsigned int) * listcount (route_info-&gt;nexthops6);</a>
<a name="ln473">  ifindex_list = (ifindex_t *) XMALLOC (MTYPE_ISIS_TMP, size);</a>
<a name="ln474">  if (!ifindex_list)</a>
<a name="ln475">    {</a>
<a name="ln476">      zlog_err (&quot;isis_zebra_route_del_ipv6: out of memory!&quot;);</a>
<a name="ln477">      XFREE (MTYPE_ISIS_TMP, nexthop_list);</a>
<a name="ln478">      return;</a>
<a name="ln479">    }</a>
<a name="ln480"> </a>
<a name="ln481">  /* for each nexthop */</a>
<a name="ln482">  i = 0;</a>
<a name="ln483">  for (ALL_LIST_ELEMENTS_RO (route_info-&gt;nexthops6, node, nexthop6))</a>
<a name="ln484">    {</a>
<a name="ln485">      if (!IN6_IS_ADDR_LINKLOCAL (&amp;nexthop6-&gt;ip6) &amp;&amp;</a>
<a name="ln486">	  !IN6_IS_ADDR_UNSPECIFIED (&amp;nexthop6-&gt;ip6))</a>
<a name="ln487">	{</a>
<a name="ln488">	  api.nexthop_num--;</a>
<a name="ln489">	  api.ifindex_num--;</a>
<a name="ln490">	  continue;</a>
<a name="ln491">	}</a>
<a name="ln492"> </a>
<a name="ln493">      nexthop_list[i] = &amp;nexthop6-&gt;ip6;</a>
<a name="ln494">      ifindex_list[i] = nexthop6-&gt;ifindex;</a>
<a name="ln495">      i++;</a>
<a name="ln496">    }</a>
<a name="ln497"> </a>
<a name="ln498">  api.nexthop = nexthop_list;</a>
<a name="ln499">  api.ifindex = ifindex_list;</a>
<a name="ln500"> </a>
<a name="ln501">  if (api.nexthop_num &amp;&amp; api.ifindex_num)</a>
<a name="ln502">    {</a>
<a name="ln503">      prefix6.family = AF_INET6;</a>
<a name="ln504">      prefix6.prefixlen = prefix-&gt;prefixlen;</a>
<a name="ln505">      memcpy (&amp;prefix6.prefix, &amp;prefix-&gt;u.prefix6, sizeof (struct in6_addr));</a>
<a name="ln506">      zapi_ipv6_route (ZEBRA_IPV6_ROUTE_DELETE, zclient, &amp;prefix6, &amp;api);</a>
<a name="ln507">      UNSET_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ZEBRA_SYNCED);</a>
<a name="ln508">    }</a>
<a name="ln509"> </a>
<a name="ln510">  XFREE (MTYPE_ISIS_TMP, nexthop_list);</a>
<a name="ln511">  XFREE (MTYPE_ISIS_TMP, ifindex_list);</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">#endif /* HAVE_IPV6 */</a>
<a name="ln515"> </a>
<a name="ln516">void</a>
<a name="ln517">isis_zebra_route_update (struct prefix *prefix,</a>
<a name="ln518">			 struct isis_route_info *route_info)</a>
<a name="ln519">{</a>
<a name="ln520">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln521">    return;</a>
<a name="ln522"> </a>
<a name="ln523">  if (!vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_ISIS], VRF_DEFAULT))</a>
<a name="ln524">    return;</a>
<a name="ln525"> </a>
<a name="ln526">  if (CHECK_FLAG (route_info-&gt;flag, ISIS_ROUTE_FLAG_ACTIVE))</a>
<a name="ln527">    {</a>
<a name="ln528">      if (prefix-&gt;family == AF_INET)</a>
<a name="ln529">	isis_zebra_route_add_ipv4 (prefix, route_info);</a>
<a name="ln530">#ifdef HAVE_IPV6</a>
<a name="ln531">      else if (prefix-&gt;family == AF_INET6)</a>
<a name="ln532">	isis_zebra_route_add_ipv6 (prefix, route_info);</a>
<a name="ln533">#endif /* HAVE_IPV6 */</a>
<a name="ln534">    }</a>
<a name="ln535">  else</a>
<a name="ln536">    {</a>
<a name="ln537">      if (prefix-&gt;family == AF_INET)</a>
<a name="ln538">	isis_zebra_route_del_ipv4 (prefix, route_info);</a>
<a name="ln539">#ifdef HAVE_IPV6</a>
<a name="ln540">      else if (prefix-&gt;family == AF_INET6)</a>
<a name="ln541">	isis_zebra_route_del_ipv6 (prefix, route_info);</a>
<a name="ln542">#endif /* HAVE_IPV6 */</a>
<a name="ln543">    }</a>
<a name="ln544">  return;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">static int</a>
<a name="ln548">isis_zebra_read_ipv4 (int command, struct zclient *zclient,</a>
<a name="ln549">		      zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln550">{</a>
<a name="ln551">  struct stream *stream;</a>
<a name="ln552">  struct zapi_ipv4 api;</a>
<a name="ln553">  struct prefix_ipv4 p;</a>
<a name="ln554">  struct prefix *p_generic = (struct prefix*)&amp;p;</a>
<a name="ln555">  unsigned long ifindex __attribute__ ((unused));</a>
<a name="ln556">  struct in_addr nexthop __attribute__ ((unused));</a>
<a name="ln557">  unsigned char plength = 0;</a>
<a name="ln558"> </a>
<a name="ln559">  stream = zclient-&gt;ibuf;</a>
<a name="ln560">  memset(&amp;api, 0, sizeof(api));</a>
<a name="ln561">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln562">  memset(&amp;nexthop, 0, sizeof(nexthop));</a>
<a name="ln563">  ifindex = 0;</a>
<a name="ln564"> </a>
<a name="ln565">  api.type = stream_getc (stream);</a>
<a name="ln566">  api.flags = stream_getc (stream);</a>
<a name="ln567">  api.message = stream_getc (stream);</a>
<a name="ln568"> </a>
<a name="ln569">  p.family = AF_INET;</a>
<a name="ln570">  plength = stream_getc (stream);</a>
<a name="ln571">  p.prefixlen = MIN(IPV4_MAX_PREFIXLEN, plength);</a>
<a name="ln572">  stream_get (&amp;p.prefix, stream, PSIZE (p.prefixlen));</a>
<a name="ln573"> </a>
<a name="ln574">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln575">    {</a>
<a name="ln576">      api.nexthop_num = stream_getc (stream);</a>
<a name="ln577">      nexthop.s_addr = stream_get_ipv4 (stream);</a>
<a name="ln578">    }</a>
<a name="ln579">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))</a>
<a name="ln580">    {</a>
<a name="ln581">      api.ifindex_num = stream_getc (stream);</a>
<a name="ln582">      ifindex = stream_getl (stream);</a>
<a name="ln583">    }</a>
<a name="ln584">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln585">    api.distance = stream_getc (stream);</a>
<a name="ln586">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln587">    api.metric = stream_getl (stream);</a>
<a name="ln588"> </a>
<a name="ln589">  /*</a>
<a name="ln590">   * Avoid advertising a false default reachability. (A default</a>
<a name="ln591">   * route installed by IS-IS gets redistributed from zebra back</a>
<a name="ln592">   * into IS-IS causing us to start advertising default reachabity</a>
<a name="ln593">   * without this check)</a>
<a name="ln594">   */</a>
<a name="ln595">  if (p.prefixlen == 0 &amp;&amp; api.type == ZEBRA_ROUTE_ISIS)</a>
<a name="ln596">    command = ZEBRA_IPV4_ROUTE_DELETE;</a>
<a name="ln597"> </a>
<a name="ln598">  if (command == ZEBRA_IPV4_ROUTE_ADD)</a>
<a name="ln599">    isis_redist_add(api.type, p_generic, api.distance, api.metric);</a>
<a name="ln600">  else</a>
<a name="ln601">    isis_redist_delete(api.type, p_generic);</a>
<a name="ln602"> </a>
<a name="ln603">  return 0;</a>
<a name="ln604">}</a>
<a name="ln605"> </a>
<a name="ln606">static int</a>
<a name="ln607">isis_zebra_read_ipv6 (int command, struct zclient *zclient,</a>
<a name="ln608">		      zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln609">{</a>
<a name="ln610">  struct stream *stream;</a>
<a name="ln611">  struct zapi_ipv6 api;</a>
<a name="ln612">  struct prefix_ipv6 p;</a>
<a name="ln613">  struct prefix *p_generic = (struct prefix*)&amp;p;</a>
<a name="ln614">  struct in6_addr nexthop;</a>
<a name="ln615">  unsigned long ifindex __attribute__((unused));</a>
<a name="ln616"> </a>
<a name="ln617">  stream = zclient-&gt;ibuf;</a>
<a name="ln618">  memset(&amp;api, 0, sizeof(api));</a>
<a name="ln619">  memset(&amp;p, 0, sizeof(struct prefix_ipv6));</a>
<a name="ln620">  memset(&amp;nexthop, 0, sizeof(nexthop));</a>
<a name="ln621">  ifindex = 0;</a>
<a name="ln622"> </a>
<a name="ln623">  api.type = stream_getc(stream);</a>
<a name="ln624">  api.flags = stream_getc(stream);</a>
<a name="ln625">  api.message = stream_getc(stream);</a>
<a name="ln626"> </a>
<a name="ln627">  p.family = AF_INET6;</a>
<a name="ln628">  p.prefixlen = stream_getc(stream);</a>
<a name="ln629">  stream_get(&amp;p.prefix, stream, PSIZE(p.prefixlen));</a>
<a name="ln630"> </a>
<a name="ln631">  if (CHECK_FLAG(api.message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln632">    {</a>
<a name="ln633">      api.nexthop_num = stream_getc(stream); /* this is always 1 */</a>
<a name="ln634">      stream_get(&amp;nexthop, stream, sizeof(nexthop));</a>
<a name="ln635">    }</a>
<a name="ln636">  if (CHECK_FLAG(api.message, ZAPI_MESSAGE_IFINDEX))</a>
<a name="ln637">    {</a>
<a name="ln638">      api.ifindex_num = stream_getc(stream);</a>
<a name="ln639">      ifindex = stream_getl(stream);</a>
<a name="ln640">    }</a>
<a name="ln641">  if (CHECK_FLAG(api.message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln642">    api.distance = stream_getc(stream);</a>
<a name="ln643">  if (CHECK_FLAG(api.message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln644">    api.metric = stream_getl(stream);</a>
<a name="ln645"> </a>
<a name="ln646">  /*</a>
<a name="ln647">   * Avoid advertising a false default reachability. (A default</a>
<a name="ln648">   * route installed by IS-IS gets redistributed from zebra back</a>
<a name="ln649">   * into IS-IS causing us to start advertising default reachabity</a>
<a name="ln650">   * without this check)</a>
<a name="ln651">   */</a>
<a name="ln652">  if (p.prefixlen == 0 &amp;&amp; api.type == ZEBRA_ROUTE_ISIS)</a>
<a name="ln653">    command = ZEBRA_IPV6_ROUTE_DELETE;</a>
<a name="ln654"> </a>
<a name="ln655">  if (command == ZEBRA_IPV6_ROUTE_ADD)</a>
<a name="ln656">    isis_redist_add(api.type, p_generic, api.distance, api.metric);</a>
<a name="ln657">  else</a>
<a name="ln658">    isis_redist_delete(api.type, p_generic);</a>
<a name="ln659"> </a>
<a name="ln660">  return 0;</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">int</a>
<a name="ln664">isis_distribute_list_update (int routetype)</a>
<a name="ln665">{</a>
<a name="ln666">  return 0;</a>
<a name="ln667">}</a>
<a name="ln668"> </a>
<a name="ln669">void</a>
<a name="ln670">isis_zebra_redistribute_set(int type)</a>
<a name="ln671">{</a>
<a name="ln672">  if (type == DEFAULT_ROUTE)</a>
<a name="ln673">    zclient_redistribute_default(ZEBRA_REDISTRIBUTE_DEFAULT_ADD, zclient, VRF_DEFAULT);</a>
<a name="ln674">  else</a>
<a name="ln675">    zclient_redistribute(ZEBRA_REDISTRIBUTE_ADD, zclient, type, VRF_DEFAULT);</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">void</a>
<a name="ln679">isis_zebra_redistribute_unset(int type)</a>
<a name="ln680">{</a>
<a name="ln681">  if (type == DEFAULT_ROUTE)</a>
<a name="ln682">    zclient_redistribute_default(ZEBRA_REDISTRIBUTE_DEFAULT_DELETE, zclient, VRF_DEFAULT);</a>
<a name="ln683">  else</a>
<a name="ln684">    zclient_redistribute(ZEBRA_REDISTRIBUTE_DELETE, zclient, type, VRF_DEFAULT);</a>
<a name="ln685">}</a>
<a name="ln686"> </a>
<a name="ln687">static void</a>
<a name="ln688">isis_zebra_connected (struct zclient *zclient)</a>
<a name="ln689">{</a>
<a name="ln690">  zclient_send_requests (zclient, VRF_DEFAULT);</a>
<a name="ln691">}</a>
<a name="ln692"> </a>
<a name="ln693">void</a>
<a name="ln694">isis_zebra_init (struct thread_master *master)</a>
<a name="ln695">{</a>
<a name="ln696">  zclient = zclient_new (master);</a>
<a name="ln697">  zclient_init (zclient, ZEBRA_ROUTE_ISIS);</a>
<a name="ln698">  zclient-&gt;zebra_connected = isis_zebra_connected;</a>
<a name="ln699">  zclient-&gt;router_id_update = isis_router_id_update_zebra;</a>
<a name="ln700">  zclient-&gt;interface_add = isis_zebra_if_add;</a>
<a name="ln701">  zclient-&gt;interface_delete = isis_zebra_if_del;</a>
<a name="ln702">  zclient-&gt;interface_up = isis_zebra_if_state_up;</a>
<a name="ln703">  zclient-&gt;interface_down = isis_zebra_if_state_down;</a>
<a name="ln704">  zclient-&gt;interface_address_add = isis_zebra_if_address_add;</a>
<a name="ln705">  zclient-&gt;interface_address_delete = isis_zebra_if_address_del;</a>
<a name="ln706">  zclient-&gt;interface_link_params = isis_zebra_link_params;</a>
<a name="ln707">  zclient-&gt;ipv4_route_add = isis_zebra_read_ipv4;</a>
<a name="ln708">  zclient-&gt;ipv4_route_delete = isis_zebra_read_ipv4;</a>
<a name="ln709">#ifdef HAVE_IPV6</a>
<a name="ln710">  zclient-&gt;ipv6_route_add = isis_zebra_read_ipv6;</a>
<a name="ln711">  zclient-&gt;ipv6_route_delete = isis_zebra_read_ipv6;</a>
<a name="ln712">#endif /* HAVE_IPV6 */</a>
<a name="ln713"> </a>
<a name="ln714">  return;</a>
<a name="ln715">}</a>

</code></pre>
<div class="balloon" rel="16"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="295"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'route_info->nexthops' pointer was utilized before it was verified against nullptr. Check lines: 295, 298.</p></div>
<div class="balloon" rel="379"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'route_info->nexthops6' pointer was utilized before it was verified against nullptr. Check lines: 379, 403.</p></div>
<div class="balloon" rel="459"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'route_info->nexthops6' pointer was utilized before it was verified against nullptr. Check lines: 459, 483.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
