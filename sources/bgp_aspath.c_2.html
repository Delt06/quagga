
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_aspath.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* AS path management routines.</a>
<a name="ln2">   Copyright (C) 1996, 97, 98, 99 Kunihiro Ishiguro</a>
<a name="ln3">   Copyright (C) 2005 Sun Microsystems, Inc.</a>
<a name="ln4"> </a>
<a name="ln5">This file is part of GNU Zebra.</a>
<a name="ln6"> </a>
<a name="ln7">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8">under the terms of the GNU General Public License as published by the</a>
<a name="ln9">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10">later version.</a>
<a name="ln11"> </a>
<a name="ln12">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15">General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">You should have received a copy of the GNU General Public License</a>
<a name="ln18">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20">02111-1307, USA.  */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;hash.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;vector.h&quot;</a>
<a name="ln27">#include &quot;vty.h&quot;</a>
<a name="ln28">#include &quot;str.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;stream.h&quot;</a>
<a name="ln31">#include &quot;jhash.h&quot;</a>
<a name="ln32">#include &quot;filter.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln35">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_debug.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">/* Attr. Flags and Attr. Type Code. */</a>
<a name="ln40">#define AS_HEADER_SIZE        2	 </a>
<a name="ln41"> </a>
<a name="ln42">/* Now FOUR octets are used for AS value. */</a>
<a name="ln43">#define AS_VALUE_SIZE         sizeof (as_t)</a>
<a name="ln44">/* This is the old one */</a>
<a name="ln45">#define AS16_VALUE_SIZE	      sizeof (as16_t)</a>
<a name="ln46"> </a>
<a name="ln47">/* Maximum protocol segment length value */</a>
<a name="ln48">#define AS_SEGMENT_MAX		255</a>
<a name="ln49"> </a>
<a name="ln50">/* The following length and size macros relate specifically to Quagga's</a>
<a name="ln51"> * internal representation of AS-Segments, not per se to the on-wire</a>
<a name="ln52"> * sizes and lengths.  At present (200508) they sort of match, however</a>
<a name="ln53"> * the ONLY functions which should now about the on-wire syntax are</a>
<a name="ln54"> * aspath_put, assegment_put and assegment_parse.</a>
<a name="ln55"> *</a>
<a name="ln56"> * aspath_put returns bytes written, the only definitive record of</a>
<a name="ln57"> * size of wire-format attribute..</a>
<a name="ln58"> */</a>
<a name="ln59"> </a>
<a name="ln60">/* Calculated size in bytes of ASN segment data to hold N ASN's */</a>
<a name="ln61">#define ASSEGMENT_DATA_SIZE(N,S) \</a>
<a name="ln62">	((N) * ( (S) ? AS_VALUE_SIZE : AS16_VALUE_SIZE) )</a>
<a name="ln63"> </a>
<a name="ln64">/* Calculated size of segment struct to hold N ASN's */</a>
<a name="ln65">#define ASSEGMENT_SIZE(N,S)  (AS_HEADER_SIZE + ASSEGMENT_DATA_SIZE (N,S))</a>
<a name="ln66"> </a>
<a name="ln67">/* AS segment octet length. */</a>
<a name="ln68">#define ASSEGMENT_LEN(X,S) ASSEGMENT_SIZE((X)-&gt;length,S)</a>
<a name="ln69"> </a>
<a name="ln70">/* AS_SEQUENCE segments can be packed together */</a>
<a name="ln71">/* Can the types of X and Y be considered for packing? */</a>
<a name="ln72">#define ASSEGMENT_TYPES_PACKABLE(X,Y) \</a>
<a name="ln73">  ( ((X)-&gt;type == (Y)-&gt;type) \</a>
<a name="ln74">   &amp;&amp; ((X)-&gt;type == AS_SEQUENCE))</a>
<a name="ln75">/* Types and length of X,Y suitable for packing? */</a>
<a name="ln76">#define ASSEGMENTS_PACKABLE(X,Y) \</a>
<a name="ln77">  ( ASSEGMENT_TYPES_PACKABLE( (X), (Y)) \</a>
<a name="ln78">   &amp;&amp; ( ((X)-&gt;length + (Y)-&gt;length) &lt;= AS_SEGMENT_MAX ) )</a>
<a name="ln79"> </a>
<a name="ln80">/* As segment header - the on-wire representation </a>
<a name="ln81"> * NOT the internal representation!</a>
<a name="ln82"> */</a>
<a name="ln83">struct assegment_header</a>
<a name="ln84">{</a>
<a name="ln85">  u_char type;</a>
<a name="ln86">  u_char length;</a>
<a name="ln87">};</a>
<a name="ln88"> </a>
<a name="ln89">/* Hash for aspath.  This is the top level structure of AS path. */</a>
<a name="ln90">static struct hash *ashash;</a>
<a name="ln91"> </a>
<a name="ln92">/* Stream for SNMP. See aspath_snmp_pathseg */</a>
<a name="ln93">static struct stream *snmp_stream;</a>
<a name="ln94"> </a>
<a name="ln95">/* Callers are required to initialize the memory */</a>
<a name="ln96">static as_t *</a>
<a name="ln97">assegment_data_new (int num)</a>
<a name="ln98">{</a>
<a name="ln99">  return (XMALLOC (MTYPE_AS_SEG_DATA, ASSEGMENT_DATA_SIZE (num, 1)));</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">static void</a>
<a name="ln103">assegment_data_free (as_t *asdata)</a>
<a name="ln104">{</a>
<a name="ln105">  XFREE (MTYPE_AS_SEG_DATA, asdata);</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">/* Get a new segment. Note that 0 is an allowed length,</a>
<a name="ln109"> * and will result in a segment with no allocated data segment.</a>
<a name="ln110"> * the caller should immediately assign data to the segment, as the segment</a>
<a name="ln111"> * otherwise is not generally valid</a>
<a name="ln112"> */</a>
<a name="ln113">static struct assegment *</a>
<a name="ln114">assegment_new (u_char type, u_short length)</a>
<a name="ln115">{</a>
<a name="ln116">  struct assegment *new;</a>
<a name="ln117">  </a>
<a name="ln118">  new = XCALLOC (MTYPE_AS_SEG, sizeof (struct assegment));</a>
<a name="ln119">  </a>
<a name="ln120">  if (length)</a>
<a name="ln121">    new-&gt;as = assegment_data_new (length);</a>
<a name="ln122">  </a>
<a name="ln123">  new-&gt;length = length;</a>
<a name="ln124">  new-&gt;type = type;</a>
<a name="ln125">  </a>
<a name="ln126">  return new;</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">static void</a>
<a name="ln130">assegment_free (struct assegment *seg)</a>
<a name="ln131">{</a>
<a name="ln132">  if (!seg)</a>
<a name="ln133">    return;</a>
<a name="ln134">  </a>
<a name="ln135">  if (seg-&gt;as)</a>
<a name="ln136">    assegment_data_free (seg-&gt;as);</a>
<a name="ln137">  memset (seg, 0xfe, sizeof(struct assegment));</a>
<a name="ln138">  XFREE (MTYPE_AS_SEG, seg);</a>
<a name="ln139">  </a>
<a name="ln140">  return;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">/* free entire chain of segments */</a>
<a name="ln144">static void</a>
<a name="ln145">assegment_free_all (struct assegment *seg)</a>
<a name="ln146">{</a>
<a name="ln147">  struct assegment *prev;</a>
<a name="ln148">  </a>
<a name="ln149">  while (seg)</a>
<a name="ln150">    {</a>
<a name="ln151">      prev = seg;</a>
<a name="ln152">      seg = seg-&gt;next;</a>
<a name="ln153">      assegment_free (prev);</a>
<a name="ln154">    }</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">/* Duplicate just the given assegment and its data */</a>
<a name="ln158">static struct assegment *</a>
<a name="ln159">assegment_dup (struct assegment *seg)</a>
<a name="ln160">{</a>
<a name="ln161">  struct assegment *new;</a>
<a name="ln162">  </a>
<a name="ln163">  new = assegment_new (seg-&gt;type, seg-&gt;length);</a>
<a name="ln164">  memcpy (new-&gt;as, seg-&gt;as, ASSEGMENT_DATA_SIZE (new-&gt;length, 1) );</a>
<a name="ln165">    </a>
<a name="ln166">  return new;</a>
<a name="ln167">}</a>
<a name="ln168"> </a>
<a name="ln169">/* Duplicate entire chain of assegments, return the head */</a>
<a name="ln170">static struct assegment *</a>
<a name="ln171">assegment_dup_all (struct assegment *seg)</a>
<a name="ln172">{</a>
<a name="ln173">  struct assegment *new = NULL;</a>
<a name="ln174">  struct assegment *head = NULL;</a>
<a name="ln175">  </a>
<a name="ln176">  while (seg)</a>
<a name="ln177">    {</a>
<a name="ln178">      if (head)</a>
<a name="ln179">        {</a>
<a name="ln180">          new-&gt;next = assegment_dup (seg);</a>
<a name="ln181">          new = new-&gt;next;</a>
<a name="ln182">        }</a>
<a name="ln183">      else</a>
<a name="ln184">        head = new = assegment_dup (seg);</a>
<a name="ln185">      </a>
<a name="ln186">      seg = seg-&gt;next;</a>
<a name="ln187">    }</a>
<a name="ln188">  return head;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">/* prepend the as number to given segment, given num of times */</a>
<a name="ln192">static struct assegment *</a>
<a name="ln193">assegment_prepend_asns (struct assegment *seg, as_t asnum, int num)</a>
<a name="ln194">{</a>
<a name="ln195">  as_t *newas;</a>
<a name="ln196">  int i;</a>
<a name="ln197">  </a>
<a name="ln198">  if (!num)</a>
<a name="ln199">    return seg;</a>
<a name="ln200">  </a>
<a name="ln201">  if (num &gt;= AS_SEGMENT_MAX)</a>
<a name="ln202">    return seg; /* we don't do huge prepends */</a>
<a name="ln203">  </a>
<a name="ln204">  if ((newas = assegment_data_new (seg-&gt;length + num)) == NULL)</a>
<a name="ln205">    return seg;</a>
<a name="ln206">  </a>
<a name="ln207">  for (i = 0; i &lt; num; i++)</a>
<a name="ln208">    newas[i] = asnum;</a>
<a name="ln209"> </a>
<a name="ln210">  memcpy (newas + num, seg-&gt;as, ASSEGMENT_DATA_SIZE (seg-&gt;length, 1));</a>
<a name="ln211">  assegment_data_free (seg-&gt;as);</a>
<a name="ln212">  seg-&gt;as = newas;</a>
<a name="ln213">  seg-&gt;length += num;</a>
<a name="ln214"> </a>
<a name="ln215">  return seg;</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">/* append given array of as numbers to the segment */</a>
<a name="ln219">static struct assegment *</a>
<a name="ln220">assegment_append_asns (struct assegment *seg, as_t *asnos, int num)</a>
<a name="ln221">{</a>
<a name="ln222">  as_t *newas;</a>
<a name="ln223">  </a>
<a name="ln224">  newas = XREALLOC (MTYPE_AS_SEG_DATA, seg-&gt;as,</a>
<a name="ln225">		      ASSEGMENT_DATA_SIZE (seg-&gt;length + num, 1));</a>
<a name="ln226"> </a>
<a name="ln227">  if (newas)</a>
<a name="ln228">    {</a>
<a name="ln229">      seg-&gt;as = newas;</a>
<a name="ln230">      memcpy (seg-&gt;as + seg-&gt;length, asnos, ASSEGMENT_DATA_SIZE(num, 1));</a>
<a name="ln231">      seg-&gt;length += num;</a>
<a name="ln232">      return seg;</a>
<a name="ln233">    }</a>
<a name="ln234"> </a>
<a name="ln235">  assegment_free_all (seg);</a>
<a name="ln236">  return NULL;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">static int</a>
<a name="ln240">int_cmp (const void *p1, const void *p2)</a>
<a name="ln241">{</a>
<a name="ln242">  const as_t *as1 = p1;</a>
<a name="ln243">  const as_t *as2 = p2;</a>
<a name="ln244">  </a>
<a name="ln245">  return (*as1 == *as2) </a>
<a name="ln246">          ? 0 : ( (*as1 &gt; *as2) ? 1 : -1);</a>
<a name="ln247">}</a>
<a name="ln248"> </a>
<a name="ln249">/* normalise the segment.</a>
<a name="ln250"> * In particular, merge runs of AS_SEQUENCEs into one segment</a>
<a name="ln251"> * Internally, we do not care about the wire segment length limit, and</a>
<a name="ln252"> * we want each distinct AS_PATHs to have the exact same internal</a>
<a name="ln253"> * representation - eg, so that our hashing actually works..</a>
<a name="ln254"> */</a>
<a name="ln255">static struct assegment *</a>
<a name="ln256">assegment_normalise (struct assegment *head)</a>
<a name="ln257">{</a>
<a name="ln258">  struct assegment *seg = head, *pin;</a>
<a name="ln259">  struct assegment *tmp;</a>
<a name="ln260">  </a>
<a name="ln261">  if (!head)</a>
<a name="ln262">    return head;</a>
<a name="ln263">  </a>
<a name="ln264">  while (seg)</a>
<a name="ln265">    {</a>
<a name="ln266">      pin = seg;</a>
<a name="ln267">      </a>
<a name="ln268">      /* Sort values SET segments, for determinism in paths to aid</a>
<a name="ln269">       * creation of hash values / path comparisons</a>
<a name="ln270">       * and because it helps other lesser implementations ;)</a>
<a name="ln271">       */</a>
<a name="ln272">      if (seg-&gt;type == AS_SET || seg-&gt;type == AS_CONFED_SET)</a>
<a name="ln273">      	{</a>
<a name="ln274">	  int tail = 0;</a>
<a name="ln275">	  int i;</a>
<a name="ln276">	  </a>
<a name="ln277">	  qsort (seg-&gt;as, seg-&gt;length, sizeof(as_t), int_cmp);</a>
<a name="ln278">	  </a>
<a name="ln279">	  /* weed out dupes */</a>
<a name="ln280">	  for (i=1; i &lt; seg-&gt;length; i++)</a>
<a name="ln281">	    {</a>
<a name="ln282">	      if (seg-&gt;as[tail] == seg-&gt;as[i])</a>
<a name="ln283">	      	continue;</a>
<a name="ln284">	      </a>
<a name="ln285">	      tail++;</a>
<a name="ln286">	      if (tail &lt; i)</a>
<a name="ln287">	      	seg-&gt;as[tail] = seg-&gt;as[i];</a>
<a name="ln288">	    }</a>
<a name="ln289">	  /* seg-&gt;length can be 0.. */</a>
<a name="ln290">	  if (seg-&gt;length)</a>
<a name="ln291">	    seg-&gt;length = tail + 1;</a>
<a name="ln292">	}</a>
<a name="ln293"> </a>
<a name="ln294">      /* read ahead from the current, pinned segment while the segments</a>
<a name="ln295">       * are packable/mergeable. Append all following packable segments</a>
<a name="ln296">       * to the segment we have pinned and remove these appended</a>
<a name="ln297">       * segments.</a>
<a name="ln298">       */      </a>
<a name="ln299">      while (pin-&gt;next &amp;&amp; ASSEGMENT_TYPES_PACKABLE(pin, pin-&gt;next))</a>
<a name="ln300">        {</a>
<a name="ln301">          tmp = pin-&gt;next;</a>
<a name="ln302">          seg = pin-&gt;next;</a>
<a name="ln303">          </a>
<a name="ln304">          /* append the next sequence to the pinned sequence */</a>
<a name="ln305">          pin = assegment_append_asns (pin, seg-&gt;as, seg-&gt;length);</a>
<a name="ln306">          </a>
<a name="ln307">          /* bypass the next sequence */</a>
<a name="ln308">          pin-&gt;next = seg-&gt;next;</a>
<a name="ln309">          </a>
<a name="ln310">          /* get rid of the now referenceless segment */</a>
<a name="ln311">          assegment_free (tmp);</a>
<a name="ln312">          </a>
<a name="ln313">        }</a>
<a name="ln314"> </a>
<a name="ln315">      seg = pin-&gt;next;</a>
<a name="ln316">    }</a>
<a name="ln317">  return head;</a>
<a name="ln318">}</a>
<a name="ln319"> </a>
<a name="ln320">static struct aspath *</a>
<a name="ln321">aspath_new (void)</a>
<a name="ln322">{</a>
<a name="ln323">  return XCALLOC (MTYPE_AS_PATH, sizeof (struct aspath));</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">/* Free AS path structure. */</a>
<a name="ln327">void</a>
<a name="ln328">aspath_free (struct aspath *aspath)</a>
<a name="ln329">{</a>
<a name="ln330">  if (!aspath)</a>
<a name="ln331">    return;</a>
<a name="ln332">  if (aspath-&gt;segments)</a>
<a name="ln333">    assegment_free_all (aspath-&gt;segments);</a>
<a name="ln334">  if (aspath-&gt;str)</a>
<a name="ln335">    XFREE (MTYPE_AS_STR, aspath-&gt;str);</a>
<a name="ln336">  XFREE (MTYPE_AS_PATH, aspath);</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">/* Unintern aspath from AS path bucket. */</a>
<a name="ln340">void</a>
<a name="ln341">aspath_unintern (struct aspath **aspath)</a>
<a name="ln342">{</a>
<a name="ln343">  struct aspath *ret;</a>
<a name="ln344">  struct aspath *asp = *aspath;</a>
<a name="ln345">  </a>
<a name="ln346">  if (asp-&gt;refcnt)</a>
<a name="ln347">    asp-&gt;refcnt--;</a>
<a name="ln348"> </a>
<a name="ln349">  if (asp-&gt;refcnt == 0)</a>
<a name="ln350">    {</a>
<a name="ln351">      /* This aspath must exist in aspath hash table. */</a>
<a name="ln352">      ret = hash_release (ashash, asp);</a>
<a name="ln353">      assert (ret != NULL);</a>
<a name="ln354">      aspath_free (asp);</a>
<a name="ln355">      *aspath = NULL;</a>
<a name="ln356">    }</a>
<a name="ln357">}</a>
<a name="ln358"> </a>
<a name="ln359">/* Return the start or end delimiters for a particular Segment type */</a>
<a name="ln360">#define AS_SEG_START 0</a>
<a name="ln361">#define AS_SEG_END 1</a>
<a name="ln362">static char</a>
<a name="ln363">aspath_delimiter_char (u_char type, u_char which)</a>
<a name="ln364">{</a>
<a name="ln365">  int i;</a>
<a name="ln366">  struct</a>
<a name="ln367">  {</a>
<a name="ln368">    int type;</a>
<a name="ln369">    char start;</a>
<a name="ln370">    char end;</a>
<a name="ln371">  } aspath_delim_char [] =</a>
<a name="ln372">    {</a>
<a name="ln373">      { AS_SET,             '{', '}' },</a>
<a name="ln374">      { AS_CONFED_SET,      '[', ']' },</a>
<a name="ln375">      { AS_CONFED_SEQUENCE, '(', ')' },</a>
<a name="ln376">      { 0 }</a>
<a name="ln377">    };</a>
<a name="ln378"> </a>
<a name="ln379">  for (i = 0; aspath_delim_char[i].type != 0; i++)</a>
<a name="ln380">    {</a>
<a name="ln381">      if (aspath_delim_char[i].type == type)</a>
<a name="ln382">	{</a>
<a name="ln383">	  if (which == AS_SEG_START)</a>
<a name="ln384">	    return aspath_delim_char[i].start;</a>
<a name="ln385">	  else if (which == AS_SEG_END)</a>
<a name="ln386">	    return aspath_delim_char[i].end;</a>
<a name="ln387">	}</a>
<a name="ln388">    }</a>
<a name="ln389">  return ' ';</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">/* countup asns from this segment and index onward */</a>
<a name="ln393">static int</a>
<a name="ln394">assegment_count_asns (struct assegment *seg, int from)</a>
<a name="ln395">{</a>
<a name="ln396">  int count = 0;</a>
<a name="ln397">  while (seg)</a>
<a name="ln398">    {</a>
<a name="ln399">      if (!from)</a>
<a name="ln400">        count += seg-&gt;length;</a>
<a name="ln401">      else</a>
<a name="ln402">        {</a>
<a name="ln403">          count += (seg-&gt;length - from);</a>
<a name="ln404">          from = 0;</a>
<a name="ln405">        }</a>
<a name="ln406">      seg = seg-&gt;next;</a>
<a name="ln407">    }</a>
<a name="ln408">  return count;</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">unsigned int</a>
<a name="ln412">aspath_count_confeds (struct aspath *aspath)</a>
<a name="ln413">{</a>
<a name="ln414">  int count = 0;</a>
<a name="ln415">  struct assegment *seg = aspath-&gt;segments;</a>
<a name="ln416">  </a>
<a name="ln417">  while (seg)</a>
<a name="ln418">    {</a>
<a name="ln419">      if (seg-&gt;type == AS_CONFED_SEQUENCE)</a>
<a name="ln420">        count += seg-&gt;length;</a>
<a name="ln421">      else if (seg-&gt;type == AS_CONFED_SET)</a>
<a name="ln422">        count++;</a>
<a name="ln423">      </a>
<a name="ln424">      seg = seg-&gt;next;</a>
<a name="ln425">    }</a>
<a name="ln426">  return count;</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">unsigned int</a>
<a name="ln430">aspath_count_hops (const struct aspath *aspath)</a>
<a name="ln431">{</a>
<a name="ln432">  int count = 0;</a>
<a name="ln433">  struct assegment *seg = aspath-&gt;segments;</a>
<a name="ln434">  </a>
<a name="ln435">  while (seg)</a>
<a name="ln436">    {</a>
<a name="ln437">      if (seg-&gt;type == AS_SEQUENCE)</a>
<a name="ln438">        count += seg-&gt;length;</a>
<a name="ln439">      else if (seg-&gt;type == AS_SET)</a>
<a name="ln440">        count++;</a>
<a name="ln441">      </a>
<a name="ln442">      seg = seg-&gt;next;</a>
<a name="ln443">    }</a>
<a name="ln444">  return count;</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">/* Estimate size aspath /might/ take if encoded into an</a>
<a name="ln448"> * ASPATH attribute.</a>
<a name="ln449"> *</a>
<a name="ln450"> * This is a quick estimate, not definitive! aspath_put()</a>
<a name="ln451"> * may return a different number!!</a>
<a name="ln452"> */</a>
<a name="ln453">unsigned int</a>
<a name="ln454">aspath_size (struct aspath *aspath)</a>
<a name="ln455">{</a>
<a name="ln456">  int size = 0;</a>
<a name="ln457">  struct assegment *seg = aspath-&gt;segments;</a>
<a name="ln458">  </a>
<a name="ln459">  while (seg)</a>
<a name="ln460">    {</a>
<a name="ln461">      size += ASSEGMENT_SIZE(seg-&gt;length, 1);</a>
<a name="ln462">      seg = seg-&gt;next;</a>
<a name="ln463">    }</a>
<a name="ln464">  return size;</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">/* Return highest public ASN in path */</a>
<a name="ln468">as_t</a>
<a name="ln469">aspath_highest (struct aspath *aspath)</a>
<a name="ln470">{</a>
<a name="ln471">  struct assegment *seg = aspath-&gt;segments;</a>
<a name="ln472">  as_t highest = 0;</a>
<a name="ln473">  unsigned int i;</a>
<a name="ln474">  </a>
<a name="ln475">  while (seg)</a>
<a name="ln476">    {</a>
<a name="ln477">      for (i = 0; i &lt; seg-&gt;length; i++)</a>
<a name="ln478">        if (seg-&gt;as[i] &gt; highest </a>
<a name="ln479">            &amp;&amp; !BGP_AS_IS_PRIVATE(seg-&gt;as[i]))</a>
<a name="ln480">	  highest = seg-&gt;as[i];</a>
<a name="ln481">      seg = seg-&gt;next;</a>
<a name="ln482">    }</a>
<a name="ln483">  return highest;</a>
<a name="ln484">}</a>
<a name="ln485"> </a>
<a name="ln486">/* Return the left-most ASN in path */</a>
<a name="ln487">as_t</a>
<a name="ln488">aspath_leftmost (struct aspath *aspath)</a>
<a name="ln489">{</a>
<a name="ln490">  struct assegment *seg = aspath-&gt;segments;</a>
<a name="ln491">  as_t leftmost = 0;</a>
<a name="ln492"> </a>
<a name="ln493">  if (seg &amp;&amp; seg-&gt;length &amp;&amp; seg-&gt;type == AS_SEQUENCE)</a>
<a name="ln494">    leftmost = seg-&gt;as[0];</a>
<a name="ln495"> </a>
<a name="ln496">  return leftmost;</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">/* Return 1 if there are any 4-byte ASes in the path */</a>
<a name="ln500">unsigned int</a>
<a name="ln501">aspath_has_as4 (struct aspath *aspath)</a>
<a name="ln502">{</a>
<a name="ln503">  struct assegment *seg = aspath-&gt;segments;</a>
<a name="ln504">  unsigned int i;</a>
<a name="ln505">  </a>
<a name="ln506">  while (seg)</a>
<a name="ln507">    {</a>
<a name="ln508">      for (i = 0; i &lt; seg-&gt;length; i++)</a>
<a name="ln509">        if (seg-&gt;as[i] &gt; BGP_AS_MAX)</a>
<a name="ln510">	  return 1;</a>
<a name="ln511">      seg = seg-&gt;next;</a>
<a name="ln512">    }</a>
<a name="ln513">  return 0;</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">/* Convert aspath structure to string expression. */</a>
<a name="ln517">static void</a>
<a name="ln518">aspath_make_str_count (struct aspath *as)</a>
<a name="ln519">{</a>
<a name="ln520">  struct assegment *seg;</a>
<a name="ln521">  int str_size;</a>
<a name="ln522">  int len = 0;</a>
<a name="ln523">  char *str_buf;</a>
<a name="ln524"> </a>
<a name="ln525">  /* Empty aspath. */</a>
<a name="ln526">  if (!as-&gt;segments)</a>
<a name="ln527">    {</a>
<a name="ln528">      as-&gt;str = XMALLOC (MTYPE_AS_STR, 1);</a>
<a name="ln529">      as-&gt;str[0] = '\0';</a>
<a name="ln530">      as-&gt;str_len = 0;</a>
<a name="ln531">      return;</a>
<a name="ln532">    }</a>
<a name="ln533">  </a>
<a name="ln534">  seg = as-&gt;segments;</a>
<a name="ln535">  </a>
<a name="ln536">  /* ASN takes 5 to 10 chars plus seperator, see below.</a>
<a name="ln537">   * If there is one differing segment type, we need an additional</a>
<a name="ln538">   * 2 chars for segment delimiters, and the final '\0'.</a>
<a name="ln539">   * Hopefully this is large enough to avoid hitting the realloc</a>
<a name="ln540">   * code below for most common sequences.</a>
<a name="ln541">   *</a>
<a name="ln542">   * This was changed to 10 after the well-known BGP assertion, which</a>
<a name="ln543">   * had hit some parts of the Internet in May of 2009.</a>
<a name="ln544">   */</a>
<a name="ln545">#define ASN_STR_LEN (10 + 1)</a>
<a name="ln546">  str_size = MAX (assegment_count_asns (seg, 0) * ASN_STR_LEN + 2 + 1,</a>
<a name="ln547">                  ASPATH_STR_DEFAULT_LEN);</a>
<a name="ln548">  str_buf = XMALLOC (MTYPE_AS_STR, str_size);</a>
<a name="ln549"> </a>
<a name="ln550">  while (seg)</a>
<a name="ln551">    {</a>
<a name="ln552">      int i;</a>
<a name="ln553">      char seperator;</a>
<a name="ln554">      </a>
<a name="ln555">      /* Check AS type validity. Set seperator for segment */</a>
<a name="ln556">      switch (seg-&gt;type)</a>
<a name="ln557">        {</a>
<a name="ln558">          case AS_SET:</a>
<a name="ln559">          case AS_CONFED_SET:</a>
<a name="ln560">            seperator = ',';</a>
<a name="ln561">            break;</a>
<a name="ln562">          case AS_SEQUENCE:</a>
<a name="ln563">          case AS_CONFED_SEQUENCE:</a>
<a name="ln564">            seperator = ' ';</a>
<a name="ln565">            break;</a>
<a name="ln566">          default:</a>
<a name="ln567">            XFREE (MTYPE_AS_STR, str_buf);</a>
<a name="ln568">            as-&gt;str = NULL;</a>
<a name="ln569">            as-&gt;str_len = 0;</a>
<a name="ln570">            return;</a>
<a name="ln571">        }</a>
<a name="ln572">      </a>
<a name="ln573">      /* We might need to increase str_buf, particularly if path has</a>
<a name="ln574">       * differing segments types, our initial guesstimate above will</a>
<a name="ln575">       * have been wrong. Need 10 chars for ASN, a seperator each and</a>
<a name="ln576">       * potentially two segment delimiters, plus a space between each</a>
<a name="ln577">       * segment and trailing zero.</a>
<a name="ln578">       *</a>
<a name="ln579">       * This definitely didn't work with the value of 5 bytes and</a>
<a name="ln580">       * 32-bit ASNs.</a>
<a name="ln581">       */</a>
<a name="ln582">#define SEGMENT_STR_LEN(X) (((X)-&gt;length * ASN_STR_LEN) + 2 + 1 + 1)</a>
<a name="ln583">      if ( (len + SEGMENT_STR_LEN(seg)) &gt; str_size)</a>
<a name="ln584">        {</a>
<a name="ln585">          str_size = len + SEGMENT_STR_LEN(seg);</a>
<a name="ln586">          str_buf = XREALLOC (MTYPE_AS_STR, str_buf, str_size);</a>
<a name="ln587">        }</a>
<a name="ln588">#undef ASN_STR_LEN</a>
<a name="ln589">#undef SEGMENT_STR_LEN</a>
<a name="ln590">      </a>
<a name="ln591">      if (seg-&gt;type != AS_SEQUENCE)</a>
<a name="ln592">        len += snprintf (str_buf + len, str_size - len, </a>
<a name="ln593">			 &quot;%c&quot;, </a>
<a name="ln594">                         aspath_delimiter_char (seg-&gt;type, AS_SEG_START));</a>
<a name="ln595">      </a>
<a name="ln596">      /* write out the ASNs, with their seperators, bar the last one*/</a>
<a name="ln597">      for (i = 0; i &lt; seg-&gt;length; i++)</a>
<a name="ln598">        {</a>
<a name="ln599">          len += snprintf (str_buf + len, str_size - len, &quot;%u&quot;, seg-&gt;as[i]);</a>
<a name="ln600">          </a>
<a name="ln601">          if (i &lt; (seg-&gt;length - 1))</a>
<a name="ln602">            len += snprintf (str_buf + len, str_size - len, &quot;%c&quot;, seperator);</a>
<a name="ln603">        }</a>
<a name="ln604">      </a>
<a name="ln605">      if (seg-&gt;type != AS_SEQUENCE)</a>
<a name="ln606">        len += snprintf (str_buf + len, str_size - len, &quot;%c&quot;, </a>
<a name="ln607">                        aspath_delimiter_char (seg-&gt;type, AS_SEG_END));</a>
<a name="ln608">      if (seg-&gt;next)</a>
<a name="ln609">        len += snprintf (str_buf + len, str_size - len, &quot; &quot;);</a>
<a name="ln610">      </a>
<a name="ln611">      seg = seg-&gt;next;</a>
<a name="ln612">    }</a>
<a name="ln613">  </a>
<a name="ln614">  assert (len &lt; str_size);</a>
<a name="ln615">  </a>
<a name="ln616">  str_buf[len] = '\0';</a>
<a name="ln617">  as-&gt;str = str_buf;</a>
<a name="ln618">  as-&gt;str_len = len;</a>
<a name="ln619"> </a>
<a name="ln620">  return;</a>
<a name="ln621">}</a>
<a name="ln622"> </a>
<a name="ln623">static void</a>
<a name="ln624">aspath_str_update (struct aspath *as)</a>
<a name="ln625">{</a>
<a name="ln626">  if (as-&gt;str)</a>
<a name="ln627">    XFREE (MTYPE_AS_STR, as-&gt;str);</a>
<a name="ln628">  aspath_make_str_count (as);</a>
<a name="ln629">}</a>
<a name="ln630"> </a>
<a name="ln631">/* Intern allocated AS path. */</a>
<a name="ln632">struct aspath *</a>
<a name="ln633">aspath_intern (struct aspath *aspath)</a>
<a name="ln634">{</a>
<a name="ln635">  struct aspath *find;</a>
<a name="ln636"> </a>
<a name="ln637">  /* Assert this AS path structure is not interned and has the string</a>
<a name="ln638">     representation built. */</a>
<a name="ln639">  assert (aspath-&gt;refcnt == 0);</a>
<a name="ln640">  assert (aspath-&gt;str);</a>
<a name="ln641"> </a>
<a name="ln642">  /* Check AS path hash. */</a>
<a name="ln643">  find = hash_get (ashash, aspath, hash_alloc_intern);</a>
<a name="ln644">  if (find != aspath)</a>
<a name="ln645">    aspath_free (aspath);</a>
<a name="ln646"> </a>
<a name="ln647">  find-&gt;refcnt++;</a>
<a name="ln648"> </a>
<a name="ln649">  return find;</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">/* Duplicate aspath structure.  Created same aspath structure but</a>
<a name="ln653">   reference count and AS path string is cleared. */</a>
<a name="ln654">struct aspath *</a>
<a name="ln655">aspath_dup (struct aspath *aspath)</a>
<a name="ln656">{</a>
<a name="ln657">  unsigned short buflen = aspath-&gt;str_len + 1;</a>
<a name="ln658">  struct aspath *new;</a>
<a name="ln659"> </a>
<a name="ln660">  new = XCALLOC (MTYPE_AS_PATH, sizeof (struct aspath));</a>
<a name="ln661"> </a>
<a name="ln662">  if (aspath-&gt;segments)</a>
<a name="ln663">    new-&gt;segments = assegment_dup_all (aspath-&gt;segments);</a>
<a name="ln664"> </a>
<a name="ln665">  if (!aspath-&gt;str)</a>
<a name="ln666">    return new;</a>
<a name="ln667"> </a>
<a name="ln668">  new-&gt;str = XMALLOC (MTYPE_AS_STR, buflen);</a>
<a name="ln669">  new-&gt;str_len = aspath-&gt;str_len;</a>
<a name="ln670"> </a>
<a name="ln671">  /* copy the string data */</a>
<a name="ln672">  if (aspath-&gt;str_len &gt; 0)</a>
<a name="ln673">    memcpy (new-&gt;str, aspath-&gt;str, buflen);</a>
<a name="ln674">  else</a>
<a name="ln675">    new-&gt;str[0] = '\0';</a>
<a name="ln676"> </a>
<a name="ln677">  return new;</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">static void *</a>
<a name="ln681">aspath_hash_alloc (void *arg)</a>
<a name="ln682">{</a>
<a name="ln683">  const struct aspath *aspath = arg;</a>
<a name="ln684">  struct aspath *new;</a>
<a name="ln685"> </a>
<a name="ln686">  /* Malformed AS path value. */</a>
<a name="ln687">  assert (aspath-&gt;str);</a>
<a name="ln688">  if (! aspath-&gt;str)</a>
<a name="ln689">    return NULL;</a>
<a name="ln690"> </a>
<a name="ln691">  /* New aspath structure is needed. */</a>
<a name="ln692">  new = XMALLOC (MTYPE_AS_PATH, sizeof (struct aspath));</a>
<a name="ln693"> </a>
<a name="ln694">  /* Reuse segments and string representation */</a>
<a name="ln695">  new-&gt;refcnt = 0;</a>
<a name="ln696">  new-&gt;segments = aspath-&gt;segments;</a>
<a name="ln697">  new-&gt;str = aspath-&gt;str;</a>
<a name="ln698">  new-&gt;str_len = aspath-&gt;str_len;</a>
<a name="ln699"> </a>
<a name="ln700">  return new;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">/* parse as-segment byte stream in struct assegment */</a>
<a name="ln704">static int</a>
<a name="ln705">assegments_parse (struct stream *s, size_t length, </a>
<a name="ln706">                  struct assegment **result, int use32bit)</a>
<a name="ln707">{</a>
<a name="ln708">  struct assegment_header segh;</a>
<a name="ln709">  struct assegment *seg, *prev = NULL, *head = NULL;</a>
<a name="ln710">  size_t bytes = 0;</a>
<a name="ln711">  </a>
<a name="ln712">  /* empty aspath (ie iBGP or somesuch) */</a>
<a name="ln713">  if (length == 0)</a>
<a name="ln714">    return 0;</a>
<a name="ln715">  </a>
<a name="ln716">  if (BGP_DEBUG (as4, AS4_SEGMENT))</a>
<a name="ln717">    zlog_debug (&quot;[AS4SEG] Parse aspath segment: got total byte length %lu&quot;,</a>
<a name="ln718">		(unsigned long) length);</a>
<a name="ln719">  /* basic checks */</a>
<a name="ln720">  if ((STREAM_READABLE(s) &lt; length)</a>
<a name="ln721">      || (STREAM_READABLE(s) &lt; AS_HEADER_SIZE) </a>
<a name="ln722">      || (length % AS16_VALUE_SIZE ))</a>
<a name="ln723">    return -1;</a>
<a name="ln724">  </a>
<a name="ln725">  while (bytes &lt; length)</a>
<a name="ln726">    {</a>
<a name="ln727">      int i;</a>
<a name="ln728">      size_t seg_size;</a>
<a name="ln729">      </a>
<a name="ln730">      if ((length - bytes) &lt;= AS_HEADER_SIZE)</a>
<a name="ln731">        {</a>
<a name="ln732">          if (head)</a>
<a name="ln733">            assegment_free_all (head);</a>
<a name="ln734">          return -1;</a>
<a name="ln735">        }</a>
<a name="ln736">      </a>
<a name="ln737">      /* softly softly, get the header first on its own */</a>
<a name="ln738">      segh.type = stream_getc (s);</a>
<a name="ln739">      segh.length = stream_getc (s);</a>
<a name="ln740">      </a>
<a name="ln741">      seg_size = ASSEGMENT_SIZE(segh.length, use32bit);</a>
<a name="ln742"> </a>
<a name="ln743">      if (BGP_DEBUG (as4, AS4_SEGMENT))</a>
<a name="ln744">	zlog_debug (&quot;[AS4SEG] Parse aspath segment: got type %d, length %d&quot;,</a>
<a name="ln745">                    segh.type, segh.length);</a>
<a name="ln746">      </a>
<a name="ln747">      /* check it.. */</a>
<a name="ln748">      if ( ((bytes + seg_size) &gt; length)</a>
<a name="ln749">          /* 1771bis 4.3b: seg length contains one or more */</a>
<a name="ln750">          || (segh.length == 0) </a>
<a name="ln751">          /* Paranoia in case someone changes type of segment length.</a>
<a name="ln752">           * Shift both values by 0x10 to make the comparison operate</a>
<a name="ln753">           * on more, than 8 bits (otherwise it's a warning, bug #564).</a>
<a name="ln754">           */</a>
<a name="ln755">          || ((sizeof segh.length &gt; 1) </a>
<a name="ln756">              &amp;&amp; (0x10 + segh.length &gt; 0x10 + AS_SEGMENT_MAX)))</a>
<a name="ln757">        {</a>
<a name="ln758">          if (head)</a>
<a name="ln759">            assegment_free_all (head);</a>
<a name="ln760">          return -1;</a>
<a name="ln761">        }</a>
<a name="ln762">      </a>
<a name="ln763">      switch (segh.type)</a>
<a name="ln764">        {</a>
<a name="ln765">          case AS_SEQUENCE:</a>
<a name="ln766">          case AS_SET:</a>
<a name="ln767">          case AS_CONFED_SEQUENCE:</a>
<a name="ln768">          case AS_CONFED_SET:</a>
<a name="ln769">            break;</a>
<a name="ln770">          default:</a>
<a name="ln771">            if (head)</a>
<a name="ln772">              assegment_free_all (head);</a>
<a name="ln773">            return -1;</a>
<a name="ln774">        }</a>
<a name="ln775">      </a>
<a name="ln776">      /* now its safe to trust lengths */</a>
<a name="ln777">      seg = assegment_new (segh.type, segh.length);</a>
<a name="ln778">      </a>
<a name="ln779">      if (head)</a>
<a name="ln780">        prev-&gt;next = seg;</a>
<a name="ln781">      else /* it's the first segment */</a>
<a name="ln782">        head = prev = seg;</a>
<a name="ln783">      </a>
<a name="ln784">      for (i = 0; i &lt; segh.length; i++)</a>
<a name="ln785">	seg-&gt;as[i] = (use32bit) ? stream_getl (s) : stream_getw (s);</a>
<a name="ln786"> </a>
<a name="ln787">      bytes += seg_size;</a>
<a name="ln788">      </a>
<a name="ln789">      if (BGP_DEBUG (as4, AS4_SEGMENT))</a>
<a name="ln790">	zlog_debug (&quot;[AS4SEG] Parse aspath segment: Bytes now: %lu&quot;,</a>
<a name="ln791">	            (unsigned long) bytes);</a>
<a name="ln792">      </a>
<a name="ln793">      prev = seg;</a>
<a name="ln794">    }</a>
<a name="ln795"> </a>
<a name="ln796">  *result = assegment_normalise (head);</a>
<a name="ln797">  return 0;</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">/* AS path parse function.  pnt is a pointer to byte stream and length</a>
<a name="ln801">   is length of byte stream.  If there is same AS path in the the AS</a>
<a name="ln802">   path hash then return it else make new AS path structure. </a>
<a name="ln803">   </a>
<a name="ln804">   On error NULL is returned.</a>
<a name="ln805"> */</a>
<a name="ln806">struct aspath *</a>
<a name="ln807">aspath_parse (struct stream *s, size_t length, int use32bit)</a>
<a name="ln808">{</a>
<a name="ln809">  struct aspath as;</a>
<a name="ln810">  struct aspath *find;</a>
<a name="ln811"> </a>
<a name="ln812">  /* If length is odd it's malformed AS path. */</a>
<a name="ln813">  /* Nit-picking: if (use32bit == 0) it is malformed if odd,</a>
<a name="ln814">   * otherwise its malformed when length is larger than 2 and (length-2) </a>
<a name="ln815">   * is not dividable by 4.</a>
<a name="ln816">   * But... this time we're lazy</a>
<a name="ln817">   */</a>
<a name="ln818">  if (length % AS16_VALUE_SIZE )</a>
<a name="ln819">    return NULL;</a>
<a name="ln820"> </a>
<a name="ln821">  memset (&amp;as, 0, sizeof (struct aspath));</a>
<a name="ln822">  if (assegments_parse (s, length, &amp;as.segments, use32bit) &lt; 0)</a>
<a name="ln823">    return NULL;</a>
<a name="ln824"> </a>
<a name="ln825">  /* If already same aspath exist then return it. */</a>
<a name="ln826">  find = hash_get (ashash, &amp;as, aspath_hash_alloc);</a>
<a name="ln827"> </a>
<a name="ln828">  /* bug! should not happen, let the daemon crash below */</a>
<a name="ln829">  assert (find);</a>
<a name="ln830"> </a>
<a name="ln831">  /* if the aspath was already hashed free temporary memory. */</a>
<a name="ln832">  if (find-&gt;refcnt)</a>
<a name="ln833">    {</a>
<a name="ln834">      assegment_free_all (as.segments);</a>
<a name="ln835">      /* aspath_key_make() always updates the string */</a>
<a name="ln836">      XFREE (MTYPE_AS_STR, as.str);</a>
<a name="ln837">    }</a>
<a name="ln838"> </a>
<a name="ln839">  find-&gt;refcnt++;</a>
<a name="ln840"> </a>
<a name="ln841">  return find;</a>
<a name="ln842">}</a>
<a name="ln843"> </a>
<a name="ln844">static void</a>
<a name="ln845">assegment_data_put (struct stream *s, as_t *as, int num, int use32bit)</a>
<a name="ln846">{</a>
<a name="ln847">  int i;</a>
<a name="ln848">  assert (num &lt;= AS_SEGMENT_MAX);</a>
<a name="ln849">  </a>
<a name="ln850">  for (i = 0; i &lt; num; i++)</a>
<a name="ln851">    if ( use32bit )</a>
<a name="ln852">      stream_putl (s, as[i]);</a>
<a name="ln853">    else</a>
<a name="ln854">      {</a>
<a name="ln855">        if ( as[i] &lt;= BGP_AS_MAX )</a>
<a name="ln856">	  stream_putw(s, as[i]);</a>
<a name="ln857">	else</a>
<a name="ln858">	  stream_putw(s, BGP_AS_TRANS);</a>
<a name="ln859">      }</a>
<a name="ln860">}</a>
<a name="ln861"> </a>
<a name="ln862">static size_t</a>
<a name="ln863">assegment_header_put (struct stream *s, u_char type, int length)</a>
<a name="ln864">{</a>
<a name="ln865">  size_t lenp;</a>
<a name="ln866">  assert (length &lt;= AS_SEGMENT_MAX);</a>
<a name="ln867">  stream_putc (s, type);</a>
<a name="ln868">  lenp = stream_get_endp (s);</a>
<a name="ln869">  stream_putc (s, length);</a>
<a name="ln870">  return lenp;</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873">/* write aspath data to stream */</a>
<a name="ln874">size_t</a>
<a name="ln875">aspath_put (struct stream *s, struct aspath *as, int use32bit )</a>
<a name="ln876">{</a>
<a name="ln877">  struct assegment *seg = as-&gt;segments;</a>
<a name="ln878">  size_t bytes = 0;</a>
<a name="ln879">  </a>
<a name="ln880">  if (!seg || seg-&gt;length == 0)</a>
<a name="ln881">    return 0;</a>
<a name="ln882">  </a>
<a name="ln883">  if (seg)</a>
<a name="ln884">    {</a>
<a name="ln885">      /*</a>
<a name="ln886">       * Hey, what do we do when we have &gt; STREAM_WRITABLE(s) here?</a>
<a name="ln887">       * At the moment, we would write out a partial aspath, and our peer</a>
<a name="ln888">       * will complain and drop the session :-/</a>
<a name="ln889">       *</a>
<a name="ln890">       * The general assumption here is that many things tested will</a>
<a name="ln891">       * never happen.  And, in real live, up to now, they have not.</a>
<a name="ln892">       */</a>
<a name="ln893">      while (seg &amp;&amp; (ASSEGMENT_LEN(seg, use32bit) &lt;= STREAM_WRITEABLE(s)))</a>
<a name="ln894">        {</a>
<a name="ln895">          struct assegment *next = seg-&gt;next;</a>
<a name="ln896">          int written = 0;</a>
<a name="ln897">          int asns_packed = 0;</a>
<a name="ln898">          size_t lenp;</a>
<a name="ln899">          </a>
<a name="ln900">          /* Overlength segments have to be split up */</a>
<a name="ln901">          while ( (seg-&gt;length - written) &gt; AS_SEGMENT_MAX)</a>
<a name="ln902">            {</a>
<a name="ln903">              assegment_header_put (s, seg-&gt;type, AS_SEGMENT_MAX);</a>
<a name="ln904">              assegment_data_put (s, (seg-&gt;as+written), AS_SEGMENT_MAX, use32bit);</a>
<a name="ln905">              written += AS_SEGMENT_MAX;</a>
<a name="ln906">              bytes += ASSEGMENT_SIZE (AS_SEGMENT_MAX, use32bit);</a>
<a name="ln907">            }</a>
<a name="ln908">          </a>
<a name="ln909">          /* write the final segment, probably is also the first */</a>
<a name="ln910">          lenp = assegment_header_put (s, seg-&gt;type, seg-&gt;length - written);</a>
<a name="ln911">          assegment_data_put (s, (seg-&gt;as + written), seg-&gt;length - written, </a>
<a name="ln912">                              use32bit);</a>
<a name="ln913">          </a>
<a name="ln914">          /* Sequence-type segments can be 'packed' together</a>
<a name="ln915">           * Case of a segment which was overlength and split up</a>
<a name="ln916">           * will be missed here, but that doesn't matter.</a>
<a name="ln917">           */</a>
<a name="ln918">          while (next &amp;&amp; ASSEGMENTS_PACKABLE (seg, next))</a>
<a name="ln919">            {</a>
<a name="ln920">              /* NB: We should never normally get here given we</a>
<a name="ln921">               * normalise aspath data when parse them. However, better</a>
<a name="ln922">               * safe than sorry. We potentially could call</a>
<a name="ln923">               * assegment_normalise here instead, but it's cheaper and</a>
<a name="ln924">               * easier to do it on the fly here rather than go through</a>
<a name="ln925">               * the segment list twice every time we write out</a>
<a name="ln926">               * aspath's.</a>
<a name="ln927">               */</a>
<a name="ln928">              </a>
<a name="ln929">              /* Next segment's data can fit in this one */</a>
<a name="ln930">              assegment_data_put (s, next-&gt;as, next-&gt;length, use32bit);</a>
<a name="ln931">              </a>
<a name="ln932">              /* update the length of the segment header */</a>
<a name="ln933">	      stream_putc_at (s, lenp, seg-&gt;length - written + next-&gt;length);</a>
<a name="ln934">              asns_packed += next-&gt;length;</a>
<a name="ln935">               </a>
<a name="ln936">	      next = next-&gt;next;</a>
<a name="ln937">	    }</a>
<a name="ln938">          </a>
<a name="ln939">          bytes += ASSEGMENT_SIZE (seg-&gt;length - written + asns_packed, </a>
<a name="ln940">				   use32bit);</a>
<a name="ln941">          seg = next;</a>
<a name="ln942">        }</a>
<a name="ln943">    }</a>
<a name="ln944">  return bytes;</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">/* This is for SNMP BGP4PATHATTRASPATHSEGMENT</a>
<a name="ln948"> * We have no way to manage the storage, so we use a static stream</a>
<a name="ln949"> * wrapper around aspath_put.</a>
<a name="ln950"> */</a>
<a name="ln951">u_char *</a>
<a name="ln952">aspath_snmp_pathseg (struct aspath *as, size_t *varlen)</a>
<a name="ln953">{</a>
<a name="ln954">#define SNMP_PATHSEG_MAX 1024</a>
<a name="ln955"> </a>
<a name="ln956">  if (!snmp_stream)</a>
<a name="ln957">    snmp_stream = stream_new (SNMP_PATHSEG_MAX);</a>
<a name="ln958">  else</a>
<a name="ln959">    stream_reset (snmp_stream);</a>
<a name="ln960">  </a>
<a name="ln961">  if (!as)</a>
<a name="ln962">    {</a>
<a name="ln963">      *varlen = 0;</a>
<a name="ln964">      return NULL;</a>
<a name="ln965">    }</a>
<a name="ln966">  aspath_put (snmp_stream, as, 0); /* use 16 bit for now here */</a>
<a name="ln967">  </a>
<a name="ln968">  *varlen = stream_get_endp (snmp_stream);</a>
<a name="ln969">  return stream_pnt(snmp_stream);</a>
<a name="ln970">}</a>
<a name="ln971">      </a>
<a name="ln972">#define min(A,B) ((A) &lt; (B) ? (A) : (B))</a>
<a name="ln973"> </a>
<a name="ln974">static struct assegment *</a>
<a name="ln975">aspath_aggregate_as_set_add (struct aspath *aspath, struct assegment *asset,</a>
<a name="ln976">			     as_t as)</a>
<a name="ln977">{</a>
<a name="ln978">  int i;</a>
<a name="ln979"> </a>
<a name="ln980">  /* If this is first AS set member, create new as-set segment. */</a>
<a name="ln981">  if (asset == NULL)</a>
<a name="ln982">    {</a>
<a name="ln983">      asset = assegment_new (AS_SET, 1);</a>
<a name="ln984">      if (! aspath-&gt;segments)</a>
<a name="ln985">	aspath-&gt;segments = asset;</a>
<a name="ln986">      else</a>
<a name="ln987">        {</a>
<a name="ln988">          struct assegment *seg = aspath-&gt;segments;</a>
<a name="ln989">          while (seg-&gt;next)</a>
<a name="ln990">            seg = seg-&gt;next;</a>
<a name="ln991">          seg-&gt;next = asset;</a>
<a name="ln992">        }</a>
<a name="ln993">      asset-&gt;type = AS_SET;</a>
<a name="ln994">      asset-&gt;length = 1;</a>
<a name="ln995">      asset-&gt;as[0] = as;</a>
<a name="ln996">    }</a>
<a name="ln997">  else</a>
<a name="ln998">    {</a>
<a name="ln999">      /* Check this AS value already exists or not. */</a>
<a name="ln1000">      for (i = 0; i &lt; asset-&gt;length; i++)</a>
<a name="ln1001">	if (asset-&gt;as[i] == as)</a>
<a name="ln1002">	  return asset;</a>
<a name="ln1003">      </a>
<a name="ln1004">      asset-&gt;length++;</a>
<a name="ln1005">      asset-&gt;as = XREALLOC (MTYPE_AS_SEG_DATA, asset-&gt;as, </a>
<a name="ln1006">                            asset-&gt;length * AS_VALUE_SIZE);</a>
<a name="ln1007">      asset-&gt;as[asset-&gt;length - 1] = as;</a>
<a name="ln1008">    }</a>
<a name="ln1009">  </a>
<a name="ln1010"> </a>
<a name="ln1011">  return asset;</a>
<a name="ln1012">}</a>
<a name="ln1013"> </a>
<a name="ln1014">/* Modify as1 using as2 for aggregation. */</a>
<a name="ln1015">struct aspath *</a>
<a name="ln1016">aspath_aggregate (struct aspath *as1, struct aspath *as2)</a>
<a name="ln1017">{</a>
<a name="ln1018">  int i;</a>
<a name="ln1019">  int minlen;</a>
<a name="ln1020">  int match;</a>
<a name="ln1021">  int from;</a>
<a name="ln1022">  struct assegment *seg1 = as1-&gt;segments;</a>
<a name="ln1023">  struct assegment *seg2 = as2-&gt;segments;</a>
<a name="ln1024">  struct aspath *aspath = NULL;</a>
<a name="ln1025">  struct assegment *asset;</a>
<a name="ln1026">  struct assegment *prevseg = NULL;</a>
<a name="ln1027"> </a>
<a name="ln1028">  match = 0;</a>
<a name="ln1029">  minlen = 0;</a>
<a name="ln1030">  aspath = NULL;</a>
<a name="ln1031">  asset = NULL;</a>
<a name="ln1032"> </a>
<a name="ln1033">  /* First of all check common leading sequence. */</a>
<a name="ln1034">  while (seg1 &amp;&amp; seg2)</a>
<a name="ln1035">    {      </a>
<a name="ln1036">      /* Check segment type. */</a>
<a name="ln1037">      if (seg1-&gt;type != seg2-&gt;type)</a>
<a name="ln1038">	break;</a>
<a name="ln1039"> </a>
<a name="ln1040">      /* Minimum segment length. */</a>
<a name="ln1041">      minlen = min (seg1-&gt;length, seg2-&gt;length);</a>
<a name="ln1042"> </a>
<a name="ln1043">      for (match = 0; match &lt; minlen; match++)</a>
<a name="ln1044">	if (seg1-&gt;as[match] != seg2-&gt;as[match])</a>
<a name="ln1045">	  break;</a>
<a name="ln1046"> </a>
<a name="ln1047">      if (match)</a>
<a name="ln1048">	{</a>
<a name="ln1049">	  struct assegment *seg = assegment_new (seg1-&gt;type, 0);</a>
<a name="ln1050">	  </a>
<a name="ln1051">	  seg = assegment_append_asns (seg, seg1-&gt;as, match);</a>
<a name="ln1052"> </a>
<a name="ln1053">	  if (! aspath)</a>
<a name="ln1054">	    {</a>
<a name="ln1055">	      aspath = aspath_new ();</a>
<a name="ln1056">	      aspath-&gt;segments = seg;</a>
<a name="ln1057">	     }</a>
<a name="ln1058">	  else</a>
<a name="ln1059">	    prevseg-&gt;next = seg;</a>
<a name="ln1060">	  </a>
<a name="ln1061">	  prevseg = seg;</a>
<a name="ln1062">	}</a>
<a name="ln1063"> </a>
<a name="ln1064">      if (match != minlen || match != seg1-&gt;length </a>
<a name="ln1065">	  || seg1-&gt;length != seg2-&gt;length)</a>
<a name="ln1066">	break;</a>
<a name="ln1067">      /* We are moving on to the next segment to reset match */</a>
<a name="ln1068">      else</a>
<a name="ln1069">        match = 0;</a>
<a name="ln1070">      </a>
<a name="ln1071">      seg1 = seg1-&gt;next;</a>
<a name="ln1072">      seg2 = seg2-&gt;next;</a>
<a name="ln1073">    }</a>
<a name="ln1074"> </a>
<a name="ln1075">  if (! aspath)</a>
<a name="ln1076">    aspath = aspath_new();</a>
<a name="ln1077"> </a>
<a name="ln1078">  /* Make as-set using rest of all information. */</a>
<a name="ln1079">  from = match;</a>
<a name="ln1080">  while (seg1)</a>
<a name="ln1081">    {</a>
<a name="ln1082">      for (i = from; i &lt; seg1-&gt;length; i++)</a>
<a name="ln1083">	asset = aspath_aggregate_as_set_add (aspath, asset, seg1-&gt;as[i]);</a>
<a name="ln1084">      </a>
<a name="ln1085">      from = 0;</a>
<a name="ln1086">      seg1 = seg1-&gt;next;</a>
<a name="ln1087">    }</a>
<a name="ln1088"> </a>
<a name="ln1089">  from = match;</a>
<a name="ln1090">  while (seg2)</a>
<a name="ln1091">    {</a>
<a name="ln1092">      for (i = from; i &lt; seg2-&gt;length; i++)</a>
<a name="ln1093">	asset = aspath_aggregate_as_set_add (aspath, asset, seg2-&gt;as[i]);</a>
<a name="ln1094"> </a>
<a name="ln1095">      from = 0;</a>
<a name="ln1096">      seg2 = seg2-&gt;next;</a>
<a name="ln1097">    }</a>
<a name="ln1098">  </a>
<a name="ln1099">  assegment_normalise (aspath-&gt;segments);</a>
<a name="ln1100">  aspath_str_update (aspath);</a>
<a name="ln1101">  return aspath;</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">/* Modify as1 using as2 for aggregation for multipath, keeping the</a>
<a name="ln1105"> * AS-Path length the same, and so minimising change to the preference</a>
<a name="ln1106"> * of the mpath aggregrate route.</a>
<a name="ln1107"> */</a>
<a name="ln1108">struct aspath *</a>
<a name="ln1109">aspath_aggregate_mpath (struct aspath *as1, struct aspath *as2)</a>
<a name="ln1110">{</a>
<a name="ln1111">  int i;</a>
<a name="ln1112">  int minlen;</a>
<a name="ln1113">  int match;</a>
<a name="ln1114">  int from1,from2;</a>
<a name="ln1115">  struct assegment *seg1 = as1-&gt;segments;</a>
<a name="ln1116">  struct assegment *seg2 = as2-&gt;segments;</a>
<a name="ln1117">  struct aspath *aspath = NULL;</a>
<a name="ln1118">  struct assegment *asset;</a>
<a name="ln1119">  struct assegment *prevseg = NULL;</a>
<a name="ln1120"> </a>
<a name="ln1121">  match = 0;</a>
<a name="ln1122">  minlen = 0;</a>
<a name="ln1123">  aspath = NULL;</a>
<a name="ln1124">  asset = NULL;</a>
<a name="ln1125"> </a>
<a name="ln1126">  /* First of all check common leading sequence. */</a>
<a name="ln1127">  while (seg1 &amp;&amp; seg2)</a>
<a name="ln1128">    {</a>
<a name="ln1129">      /* Check segment type. */</a>
<a name="ln1130">      if (seg1-&gt;type != seg2-&gt;type)</a>
<a name="ln1131">	break;</a>
<a name="ln1132"> </a>
<a name="ln1133">      /* Minimum segment length. */</a>
<a name="ln1134">      minlen = min (seg1-&gt;length, seg2-&gt;length);</a>
<a name="ln1135"> </a>
<a name="ln1136">      for (match = 0; match &lt; minlen; match++)</a>
<a name="ln1137">	if (seg1-&gt;as[match] != seg2-&gt;as[match])</a>
<a name="ln1138">	  break;</a>
<a name="ln1139"> </a>
<a name="ln1140">      if (match)</a>
<a name="ln1141">	{</a>
<a name="ln1142">	  struct assegment *seg = assegment_new (seg1-&gt;type, 0);</a>
<a name="ln1143"> </a>
<a name="ln1144">	  seg = assegment_append_asns (seg, seg1-&gt;as, match);</a>
<a name="ln1145"> </a>
<a name="ln1146">	  if (! aspath)</a>
<a name="ln1147">	    {</a>
<a name="ln1148">	      aspath = aspath_new ();</a>
<a name="ln1149">	      aspath-&gt;segments = seg;</a>
<a name="ln1150">	     }</a>
<a name="ln1151">	  else</a>
<a name="ln1152">	    prevseg-&gt;next = seg;</a>
<a name="ln1153"> </a>
<a name="ln1154">	  prevseg = seg;</a>
<a name="ln1155">	}</a>
<a name="ln1156"> </a>
<a name="ln1157">      if (match != minlen || match != seg1-&gt;length</a>
<a name="ln1158">	  || seg1-&gt;length != seg2-&gt;length)</a>
<a name="ln1159">	break;</a>
<a name="ln1160"> </a>
<a name="ln1161">      seg1 = seg1-&gt;next;</a>
<a name="ln1162">      seg2 = seg2-&gt;next;</a>
<a name="ln1163">    }</a>
<a name="ln1164"> </a>
<a name="ln1165">  if (! aspath)</a>
<a name="ln1166">    aspath = aspath_new();</a>
<a name="ln1167"> </a>
<a name="ln1168">  /* Make as-set using rest of all information. */</a>
<a name="ln1169">  from1 = from2 = match;</a>
<a name="ln1170">  while (seg1 || seg2)</a>
<a name="ln1171">    {</a>
<a name="ln1172">      if (seg1)</a>
<a name="ln1173">	{</a>
<a name="ln1174">	  if (seg1-&gt;type == AS_SEQUENCE)</a>
<a name="ln1175">	    {</a>
<a name="ln1176">	      asset = aspath_aggregate_as_set_add (aspath, asset, seg1-&gt;as[from1]);</a>
<a name="ln1177">	      from1++;</a>
<a name="ln1178">	      if (from1 &gt;= seg1-&gt;length)</a>
<a name="ln1179">		{</a>
<a name="ln1180">		  from1 = 0;</a>
<a name="ln1181">		  seg1 = seg1-&gt;next;</a>
<a name="ln1182">		}</a>
<a name="ln1183">	    }</a>
<a name="ln1184">	  else</a>
<a name="ln1185">	    {</a>
<a name="ln1186">	      for (i = from1; i &lt; seg1-&gt;length; i++)</a>
<a name="ln1187">		asset = aspath_aggregate_as_set_add (aspath, asset, seg1-&gt;as[i]);</a>
<a name="ln1188"> </a>
<a name="ln1189">	      from1 = 0;</a>
<a name="ln1190">	      seg1 = seg1-&gt;next;</a>
<a name="ln1191">	    }</a>
<a name="ln1192">	  }</a>
<a name="ln1193"> </a>
<a name="ln1194">      if (seg2)</a>
<a name="ln1195">	{</a>
<a name="ln1196">	  if (seg2-&gt;type == AS_SEQUENCE)</a>
<a name="ln1197">	    {</a>
<a name="ln1198">	      asset = aspath_aggregate_as_set_add (aspath, asset, seg2-&gt;as[from2]);</a>
<a name="ln1199">	      from2++;</a>
<a name="ln1200">	      if (from2 &gt;= seg2-&gt;length)</a>
<a name="ln1201">		{</a>
<a name="ln1202">		  from2 = 0;</a>
<a name="ln1203">		  seg2 = seg2-&gt;next;</a>
<a name="ln1204">		}</a>
<a name="ln1205">	    }</a>
<a name="ln1206">	  else</a>
<a name="ln1207">	    {</a>
<a name="ln1208">	      for (i = from2; i &lt; seg2-&gt;length; i++)</a>
<a name="ln1209">		asset = aspath_aggregate_as_set_add (aspath, asset, seg2-&gt;as[i]);</a>
<a name="ln1210"> </a>
<a name="ln1211">	      from2 = 0;</a>
<a name="ln1212">	      seg2 = seg2-&gt;next;</a>
<a name="ln1213">	    }</a>
<a name="ln1214">	}</a>
<a name="ln1215"> </a>
<a name="ln1216">      if (asset-&gt;length == 1)</a>
<a name="ln1217">	asset-&gt;type = AS_SEQUENCE;</a>
<a name="ln1218">      asset = NULL;</a>
<a name="ln1219">    }</a>
<a name="ln1220"> </a>
<a name="ln1221">  assegment_normalise (aspath-&gt;segments);</a>
<a name="ln1222">  aspath_str_update (aspath);</a>
<a name="ln1223">  return aspath;</a>
<a name="ln1224">}</a>
<a name="ln1225"> </a>
<a name="ln1226">/* When a BGP router receives an UPDATE with an MP_REACH_NLRI</a>
<a name="ln1227">   attribute, check the leftmost AS number in the AS_PATH attribute is</a>
<a name="ln1228">   or not the peer's AS number. */ </a>
<a name="ln1229">int</a>
<a name="ln1230">aspath_firstas_check (struct aspath *aspath, as_t asno)</a>
<a name="ln1231">{</a>
<a name="ln1232">  if ( (aspath == NULL) || (aspath-&gt;segments == NULL) )</a>
<a name="ln1233">    return 0;</a>
<a name="ln1234">  </a>
<a name="ln1235">  if (aspath-&gt;segments</a>
<a name="ln1236">      &amp;&amp; (aspath-&gt;segments-&gt;type == AS_SEQUENCE)</a>
<a name="ln1237">      &amp;&amp; (aspath-&gt;segments-&gt;as[0] == asno ))</a>
<a name="ln1238">    return 1;</a>
<a name="ln1239"> </a>
<a name="ln1240">  return 0;</a>
<a name="ln1241">}</a>
<a name="ln1242"> </a>
<a name="ln1243">/* AS path loop check.  If aspath contains asno then return &gt;= 1. */</a>
<a name="ln1244">int</a>
<a name="ln1245">aspath_loop_check (struct aspath *aspath, as_t asno)</a>
<a name="ln1246">{</a>
<a name="ln1247">  struct assegment *seg;</a>
<a name="ln1248">  int count = 0;</a>
<a name="ln1249"> </a>
<a name="ln1250">  if ( (aspath == NULL) || (aspath-&gt;segments == NULL) )</a>
<a name="ln1251">    return 0;</a>
<a name="ln1252">  </a>
<a name="ln1253">  seg = aspath-&gt;segments;</a>
<a name="ln1254">  </a>
<a name="ln1255">  while (seg)</a>
<a name="ln1256">    {</a>
<a name="ln1257">      int i;</a>
<a name="ln1258">      </a>
<a name="ln1259">      for (i = 0; i &lt; seg-&gt;length; i++)</a>
<a name="ln1260">	if (seg-&gt;as[i] == asno)</a>
<a name="ln1261">	  count++;</a>
<a name="ln1262">      </a>
<a name="ln1263">      seg = seg-&gt;next;</a>
<a name="ln1264">    }</a>
<a name="ln1265">  return count;</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268">/* When all of AS path is private AS return 1.  */</a>
<a name="ln1269">int</a>
<a name="ln1270">aspath_private_as_check (struct aspath *aspath)</a>
<a name="ln1271">{</a>
<a name="ln1272">  struct assegment *seg;</a>
<a name="ln1273">  </a>
<a name="ln1274">  if ( !(aspath &amp;&amp; aspath-&gt;segments) )</a>
<a name="ln1275">    return 0;</a>
<a name="ln1276">    </a>
<a name="ln1277">  seg = aspath-&gt;segments;</a>
<a name="ln1278"> </a>
<a name="ln1279">  while (seg)</a>
<a name="ln1280">    {</a>
<a name="ln1281">      int i;</a>
<a name="ln1282">      </a>
<a name="ln1283">      for (i = 0; i &lt; seg-&gt;length; i++)</a>
<a name="ln1284">	{</a>
<a name="ln1285">	  if (!BGP_AS_IS_PRIVATE(seg-&gt;as[i]))</a>
<a name="ln1286">	    return 0;</a>
<a name="ln1287">	}</a>
<a name="ln1288">      seg = seg-&gt;next;</a>
<a name="ln1289">    }</a>
<a name="ln1290">  return 1;</a>
<a name="ln1291">}</a>
<a name="ln1292"> </a>
<a name="ln1293">/* AS path confed check.  If aspath contains confed set or sequence then return 1. */</a>
<a name="ln1294">int</a>
<a name="ln1295">aspath_confed_check (struct aspath *aspath)</a>
<a name="ln1296">{</a>
<a name="ln1297">  struct assegment *seg;</a>
<a name="ln1298"> </a>
<a name="ln1299">  if ( !(aspath &amp;&amp; aspath-&gt;segments) )</a>
<a name="ln1300">    return 0;</a>
<a name="ln1301"> </a>
<a name="ln1302">  seg = aspath-&gt;segments;</a>
<a name="ln1303"> </a>
<a name="ln1304">  while (seg)</a>
<a name="ln1305">    {</a>
<a name="ln1306">      if (seg-&gt;type == AS_CONFED_SET || seg-&gt;type == AS_CONFED_SEQUENCE)</a>
<a name="ln1307">	  return 1;</a>
<a name="ln1308">      seg = seg-&gt;next;</a>
<a name="ln1309">    }</a>
<a name="ln1310">  return 0;</a>
<a name="ln1311">}</a>
<a name="ln1312"> </a>
<a name="ln1313">/* Leftmost AS path segment confed check.  If leftmost AS segment is of type</a>
<a name="ln1314">  AS_CONFED_SEQUENCE or AS_CONFED_SET then return 1.  */</a>
<a name="ln1315">int</a>
<a name="ln1316">aspath_left_confed_check (struct aspath *aspath)</a>
<a name="ln1317">{</a>
<a name="ln1318"> </a>
<a name="ln1319">  if ( !(aspath &amp;&amp; aspath-&gt;segments) )</a>
<a name="ln1320">    return 0;</a>
<a name="ln1321"> </a>
<a name="ln1322">  if ( (aspath-&gt;segments-&gt;type == AS_CONFED_SEQUENCE)</a>
<a name="ln1323">      || (aspath-&gt;segments-&gt;type == AS_CONFED_SET) )</a>
<a name="ln1324">    return 1;</a>
<a name="ln1325"> </a>
<a name="ln1326">  return 0;</a>
<a name="ln1327">}</a>
<a name="ln1328"> </a>
<a name="ln1329">/* Merge as1 to as2.  as2 should be uninterned aspath. */</a>
<a name="ln1330">static struct aspath *</a>
<a name="ln1331">aspath_merge (struct aspath *as1, struct aspath *as2)</a>
<a name="ln1332">{</a>
<a name="ln1333">  struct assegment *last, *new;</a>
<a name="ln1334"> </a>
<a name="ln1335">  if (! as1 || ! as2)</a>
<a name="ln1336">    return NULL;</a>
<a name="ln1337"> </a>
<a name="ln1338">  last = new = assegment_dup_all (as1-&gt;segments);</a>
<a name="ln1339">  </a>
<a name="ln1340">  /* find the last valid segment */</a>
<a name="ln1341">  while (last &amp;&amp; last-&gt;next)</a>
<a name="ln1342">    last = last-&gt;next;</a>
<a name="ln1343">  </a>
<a name="ln1344">  last-&gt;next = as2-&gt;segments;</a>
<a name="ln1345">  as2-&gt;segments = new;</a>
<a name="ln1346">  aspath_str_update (as2);</a>
<a name="ln1347">  return as2;</a>
<a name="ln1348">}</a>
<a name="ln1349"> </a>
<a name="ln1350">/* Prepend as1 to as2.  as2 should be uninterned aspath. */</a>
<a name="ln1351">struct aspath *</a>
<a name="ln1352">aspath_prepend (struct aspath *as1, struct aspath *as2)</a>
<a name="ln1353">{</a>
<a name="ln1354">  struct assegment *seg1;</a>
<a name="ln1355">  struct assegment *seg2;</a>
<a name="ln1356"> </a>
<a name="ln1357">  if (! as1 || ! as2)</a>
<a name="ln1358">    return NULL;</a>
<a name="ln1359">  </a>
<a name="ln1360">  seg1 = as1-&gt;segments;</a>
<a name="ln1361">  seg2 = as2-&gt;segments;</a>
<a name="ln1362">  </a>
<a name="ln1363">  /* If as2 is empty, only need to dupe as1's chain onto as2 */</a>
<a name="ln1364">  if (seg2 == NULL)</a>
<a name="ln1365">    {</a>
<a name="ln1366">      as2-&gt;segments = assegment_dup_all (as1-&gt;segments);</a>
<a name="ln1367">      aspath_str_update (as2);</a>
<a name="ln1368">      return as2;</a>
<a name="ln1369">    }</a>
<a name="ln1370">  </a>
<a name="ln1371">  /* If as1 is empty AS, no prepending to do. */</a>
<a name="ln1372">  if (seg1 == NULL)</a>
<a name="ln1373">    return as2;</a>
<a name="ln1374">  </a>
<a name="ln1375">  /* find the tail as1's segment chain. */</a>
<a name="ln1376">  while (seg1 &amp;&amp; seg1-&gt;next)</a>
<a name="ln1377">    seg1 = seg1-&gt;next;</a>
<a name="ln1378"> </a>
<a name="ln1379">  /* Delete any AS_CONFED_SEQUENCE segment from as2. */</a>
<a name="ln1380">  if (seg1-&gt;type == AS_SEQUENCE &amp;&amp; seg2-&gt;type == AS_CONFED_SEQUENCE)</a>
<a name="ln1381">    as2 = aspath_delete_confed_seq (as2);</a>
<a name="ln1382">  </a>
<a name="ln1383">  /* as2 may have been updated */</a>
<a name="ln1384">  seg2 = as2-&gt;segments;</a>
<a name="ln1385">  </a>
<a name="ln1386">  /* as2 may be empty now due to aspath_delete_confed_seq, recheck */</a>
<a name="ln1387">  if (seg2 == NULL)</a>
<a name="ln1388">    {</a>
<a name="ln1389">      as2-&gt;segments = assegment_dup_all (as1-&gt;segments);</a>
<a name="ln1390">      aspath_str_update (as2);</a>
<a name="ln1391">      return as2;</a>
<a name="ln1392">    }</a>
<a name="ln1393">  </a>
<a name="ln1394">  /* Compare last segment type of as1 and first segment type of as2. */</a>
<a name="ln1395">  if (seg1-&gt;type != seg2-&gt;type)</a>
<a name="ln1396">    return aspath_merge (as1, as2);</a>
<a name="ln1397"> </a>
<a name="ln1398">  if (seg1-&gt;type == AS_SEQUENCE)</a>
<a name="ln1399">    {</a>
<a name="ln1400">      /* We have two chains of segments, as1-&gt;segments and seg2, </a>
<a name="ln1401">       * and we have to attach them together, merging the attaching</a>
<a name="ln1402">       * segments together into one.</a>
<a name="ln1403">       * </a>
<a name="ln1404">       * 1. dupe as1-&gt;segments onto head of as2</a>
<a name="ln1405">       * 2. merge seg2's asns onto last segment of this new chain</a>
<a name="ln1406">       * 3. attach chain after seg2</a>
<a name="ln1407">       */</a>
<a name="ln1408">      </a>
<a name="ln1409">      /* dupe as1 onto as2's head */</a>
<a name="ln1410">      seg1 = as2-&gt;segments = assegment_dup_all (as1-&gt;segments);</a>
<a name="ln1411">      </a>
<a name="ln1412">      /* refind the tail of as2, reusing seg1 */</a>
<a name="ln1413">      while (seg1 &amp;&amp; seg1-&gt;next)</a>
<a name="ln1414">        seg1 = seg1-&gt;next;</a>
<a name="ln1415">      </a>
<a name="ln1416">      /* merge the old head, seg2, into tail, seg1 */</a>
<a name="ln1417">      seg1 = assegment_append_asns (seg1, seg2-&gt;as, seg2-&gt;length);</a>
<a name="ln1418">      </a>
<a name="ln1419">      /* bypass the merged seg2, and attach any chain after it to</a>
<a name="ln1420">       * chain descending from as2's head</a>
<a name="ln1421">       */</a>
<a name="ln1422">      seg1-&gt;next = seg2-&gt;next;</a>
<a name="ln1423">      </a>
<a name="ln1424">      /* seg2 is now referenceless and useless*/</a>
<a name="ln1425">      assegment_free (seg2);</a>
<a name="ln1426">      </a>
<a name="ln1427">      /* we've now prepended as1's segment chain to as2, merging</a>
<a name="ln1428">       * the inbetween AS_SEQUENCE of seg2 in the process </a>
<a name="ln1429">       */</a>
<a name="ln1430">      aspath_str_update (as2);</a>
<a name="ln1431">      return as2;</a>
<a name="ln1432">    }</a>
<a name="ln1433">  else</a>
<a name="ln1434">    {</a>
<a name="ln1435">      /* AS_SET merge code is needed at here. */</a>
<a name="ln1436">      return aspath_merge (as1, as2);</a>
<a name="ln1437">    }</a>
<a name="ln1438">  /* XXX: Ermmm, what if as1 has multiple segments?? */</a>
<a name="ln1439">  </a>
<a name="ln1440">  /* Not reached */</a>
<a name="ln1441">}</a>
<a name="ln1442"> </a>
<a name="ln1443">/* Iterate over AS_PATH segments and wipe all occurences of the</a>
<a name="ln1444"> * listed AS numbers. Hence some segments may lose some or even</a>
<a name="ln1445"> * all data on the way, the operation is implemented as a smarter</a>
<a name="ln1446"> * version of aspath_dup(), which allocates memory to hold the new</a>
<a name="ln1447"> * data, not the original. The new AS path is returned.</a>
<a name="ln1448"> */</a>
<a name="ln1449">struct aspath *</a>
<a name="ln1450">aspath_filter_exclude (struct aspath * source, struct aspath * exclude_list)</a>
<a name="ln1451">{</a>
<a name="ln1452">  struct assegment * srcseg, * exclseg, * lastseg;</a>
<a name="ln1453">  struct aspath * newpath;</a>
<a name="ln1454"> </a>
<a name="ln1455">  newpath = aspath_new();</a>
<a name="ln1456">  lastseg = NULL;</a>
<a name="ln1457"> </a>
<a name="ln1458">  for (srcseg = source-&gt;segments; srcseg; srcseg = srcseg-&gt;next)</a>
<a name="ln1459">  {</a>
<a name="ln1460">    unsigned i, y, newlen = 0, done = 0, skip_as;</a>
<a name="ln1461">    struct assegment * newseg;</a>
<a name="ln1462"> </a>
<a name="ln1463">    /* Find out, how much ASns are we going to pick from this segment.</a>
<a name="ln1464">     * We can't perform filtering right inline, because the size of</a>
<a name="ln1465">     * the new segment isn't known at the moment yet.</a>
<a name="ln1466">     */</a>
<a name="ln1467">    for (i = 0; i &lt; srcseg-&gt;length; i++)</a>
<a name="ln1468">    {</a>
<a name="ln1469">      skip_as = 0;</a>
<a name="ln1470">      for (exclseg = exclude_list-&gt;segments; exclseg &amp;&amp; !skip_as; exclseg = exclseg-&gt;next)</a>
<a name="ln1471">        for (y = 0; y &lt; exclseg-&gt;length; y++)</a>
<a name="ln1472">          if (srcseg-&gt;as[i] == exclseg-&gt;as[y])</a>
<a name="ln1473">          {</a>
<a name="ln1474">            skip_as = 1;</a>
<a name="ln1475">            // There's no sense in testing the rest of exclusion list, bail out.</a>
<a name="ln1476">            break;</a>
<a name="ln1477">          }</a>
<a name="ln1478">      if (!skip_as)</a>
<a name="ln1479">        newlen++;</a>
<a name="ln1480">    }</a>
<a name="ln1481">    /* newlen is now the number of ASns to copy */</a>
<a name="ln1482">    if (!newlen)</a>
<a name="ln1483">      continue;</a>
<a name="ln1484"> </a>
<a name="ln1485">    /* Actual copying. Allocate memory and iterate once more, performing filtering. */</a>
<a name="ln1486">    newseg = assegment_new (srcseg-&gt;type, newlen);</a>
<a name="ln1487">    for (i = 0; i &lt; srcseg-&gt;length; i++)</a>
<a name="ln1488">    {</a>
<a name="ln1489">      skip_as = 0;</a>
<a name="ln1490">      for (exclseg = exclude_list-&gt;segments; exclseg &amp;&amp; !skip_as; exclseg = exclseg-&gt;next)</a>
<a name="ln1491">        for (y = 0; y &lt; exclseg-&gt;length; y++)</a>
<a name="ln1492">          if (srcseg-&gt;as[i] == exclseg-&gt;as[y])</a>
<a name="ln1493">          {</a>
<a name="ln1494">            skip_as = 1;</a>
<a name="ln1495">            break;</a>
<a name="ln1496">          }</a>
<a name="ln1497">      if (skip_as)</a>
<a name="ln1498">        continue;</a>
<a name="ln1499">      newseg-&gt;as[done++] = srcseg-&gt;as[i];</a>
<a name="ln1500">    }</a>
<a name="ln1501">    /* At his point newlen must be equal to done, and both must be positive. Append</a>
<a name="ln1502">     * the filtered segment to the gross result. */</a>
<a name="ln1503">    if (!lastseg)</a>
<a name="ln1504">      newpath-&gt;segments = newseg;</a>
<a name="ln1505">    else</a>
<a name="ln1506">      lastseg-&gt;next = newseg;</a>
<a name="ln1507">    lastseg = newseg;</a>
<a name="ln1508">  }</a>
<a name="ln1509">  aspath_str_update (newpath);</a>
<a name="ln1510">  /* We are happy returning even an empty AS_PATH, because the administrator</a>
<a name="ln1511">   * might expect this very behaviour. There's a mean to avoid this, if necessary,</a>
<a name="ln1512">   * by having a match rule against certain AS_PATH regexps in the route-map index.</a>
<a name="ln1513">   */</a>
<a name="ln1514">  aspath_free (source);</a>
<a name="ln1515">  return newpath;</a>
<a name="ln1516">}</a>
<a name="ln1517"> </a>
<a name="ln1518">/* Add specified AS to the leftmost of aspath. */</a>
<a name="ln1519">static struct aspath *</a>
<a name="ln1520">aspath_add_asns (struct aspath *aspath, as_t asno, u_char type, unsigned num)</a>
<a name="ln1521">{</a>
<a name="ln1522">  struct assegment *assegment = aspath-&gt;segments;</a>
<a name="ln1523">  unsigned i;</a>
<a name="ln1524"> </a>
<a name="ln1525">  if (assegment &amp;&amp; assegment-&gt;type == type)</a>
<a name="ln1526">    {</a>
<a name="ln1527">      /* extend existing segment */</a>
<a name="ln1528">      aspath-&gt;segments = assegment_prepend_asns (aspath-&gt;segments, asno, num);</a>
<a name="ln1529">    }</a>
<a name="ln1530">  else </a>
<a name="ln1531">    {</a>
<a name="ln1532">      /* prepend with new segment */</a>
<a name="ln1533">      struct assegment *newsegment = assegment_new (type, num);</a>
<a name="ln1534">      for (i = 0; i &lt; num; i++)</a>
<a name="ln1535">	newsegment-&gt;as[i] = asno;</a>
<a name="ln1536"> </a>
<a name="ln1537">      /* insert potentially replacing empty segment */</a>
<a name="ln1538">      if (assegment &amp;&amp; assegment-&gt;length == 0)</a>
<a name="ln1539">	{</a>
<a name="ln1540">	  newsegment-&gt;next = assegment-&gt;next;</a>
<a name="ln1541">	  assegment_free (assegment);</a>
<a name="ln1542">	}</a>
<a name="ln1543">       else</a>
<a name="ln1544">	  newsegment-&gt;next = assegment;</a>
<a name="ln1545">      aspath-&gt;segments = newsegment;</a>
<a name="ln1546">    }</a>
<a name="ln1547"> </a>
<a name="ln1548">  aspath_str_update (aspath);</a>
<a name="ln1549">  return aspath;</a>
<a name="ln1550">}</a>
<a name="ln1551"> </a>
<a name="ln1552">/* Add specified AS to the leftmost of aspath num times. */</a>
<a name="ln1553">struct aspath *</a>
<a name="ln1554">aspath_add_seq_n (struct aspath *aspath, as_t asno, unsigned num)</a>
<a name="ln1555">{</a>
<a name="ln1556">  return aspath_add_asns (aspath, asno, AS_SEQUENCE, num);</a>
<a name="ln1557">}</a>
<a name="ln1558"> </a>
<a name="ln1559">/* Add specified AS to the leftmost of aspath. */</a>
<a name="ln1560">struct aspath *</a>
<a name="ln1561">aspath_add_seq (struct aspath *aspath, as_t asno)</a>
<a name="ln1562">{</a>
<a name="ln1563">  return aspath_add_asns (aspath, asno, AS_SEQUENCE, 1);</a>
<a name="ln1564">}</a>
<a name="ln1565"> </a>
<a name="ln1566">/* Compare leftmost AS value for MED check.  If as1's leftmost AS and</a>
<a name="ln1567">   as2's leftmost AS is same return 1. */</a>
<a name="ln1568">int</a>
<a name="ln1569">aspath_cmp_left (const struct aspath *aspath1, const struct aspath *aspath2)</a>
<a name="ln1570">{</a>
<a name="ln1571">  const struct assegment *seg1;</a>
<a name="ln1572">  const struct assegment *seg2;</a>
<a name="ln1573"> </a>
<a name="ln1574">  if (!(aspath1 &amp;&amp; aspath2))</a>
<a name="ln1575">    return 0;</a>
<a name="ln1576"> </a>
<a name="ln1577">  seg1 = aspath1-&gt;segments;</a>
<a name="ln1578">  seg2 = aspath2-&gt;segments;</a>
<a name="ln1579"> </a>
<a name="ln1580">  /* If both paths are originated in this AS then we do want to compare MED */</a>
<a name="ln1581">  if (!seg1 &amp;&amp; !seg2)</a>
<a name="ln1582">    return 1;</a>
<a name="ln1583"> </a>
<a name="ln1584">  /* find first non-confed segments for each */</a>
<a name="ln1585">  while (seg1 &amp;&amp; ((seg1-&gt;type == AS_CONFED_SEQUENCE)</a>
<a name="ln1586">		  || (seg1-&gt;type == AS_CONFED_SET)))</a>
<a name="ln1587">    seg1 = seg1-&gt;next;</a>
<a name="ln1588"> </a>
<a name="ln1589">  while (seg2 &amp;&amp; ((seg2-&gt;type == AS_CONFED_SEQUENCE)</a>
<a name="ln1590">		  || (seg2-&gt;type == AS_CONFED_SET)))</a>
<a name="ln1591">    seg2 = seg2-&gt;next;</a>
<a name="ln1592"> </a>
<a name="ln1593">  /* Check as1's */</a>
<a name="ln1594">  if (!(seg1 &amp;&amp; seg2</a>
<a name="ln1595">	&amp;&amp; (seg1-&gt;type == AS_SEQUENCE) &amp;&amp; (seg2-&gt;type == AS_SEQUENCE)))</a>
<a name="ln1596">    return 0;</a>
<a name="ln1597">  </a>
<a name="ln1598">  if (seg1-&gt;as[0] == seg2-&gt;as[0])</a>
<a name="ln1599">    return 1;</a>
<a name="ln1600"> </a>
<a name="ln1601">  return 0;</a>
<a name="ln1602">}</a>
<a name="ln1603"> </a>
<a name="ln1604">/* Truncate an aspath after a number of hops, and put the hops remaining</a>
<a name="ln1605"> * at the front of another aspath.  Needed for AS4 compat.</a>
<a name="ln1606"> *</a>
<a name="ln1607"> * Returned aspath is a /new/ aspath, which should either by free'd or</a>
<a name="ln1608"> * interned by the caller, as desired.</a>
<a name="ln1609"> */</a>
<a name="ln1610">struct aspath *</a>
<a name="ln1611">aspath_reconcile_as4 ( struct aspath *aspath, struct aspath *as4path)</a>
<a name="ln1612">{</a>
<a name="ln1613">  struct assegment *seg, *newseg, *prevseg = NULL;</a>
<a name="ln1614">  struct aspath *newpath = NULL, *mergedpath;</a>
<a name="ln1615">  int hops, cpasns = 0;</a>
<a name="ln1616">  </a>
<a name="ln1617">  if (!aspath)</a>
<a name="ln1618">    return NULL;</a>
<a name="ln1619">  </a>
<a name="ln1620">  seg = aspath-&gt;segments;</a>
<a name="ln1621">  </a>
<a name="ln1622">  /* CONFEDs should get reconciled too.. */</a>
<a name="ln1623">  hops = (aspath_count_hops (aspath) + aspath_count_confeds (aspath))</a>
<a name="ln1624">         - aspath_count_hops (as4path);</a>
<a name="ln1625">  </a>
<a name="ln1626">  if (hops &lt; 0)</a>
<a name="ln1627">    {</a>
<a name="ln1628">      if (BGP_DEBUG (as4, AS4))</a>
<a name="ln1629">        zlog_warn (&quot;[AS4] Fewer hops in AS_PATH than NEW_AS_PATH&quot;);</a>
<a name="ln1630">      /* Something's gone wrong. The RFC says we should now ignore AS4_PATH,</a>
<a name="ln1631">       * which is daft behaviour - it contains vital loop-detection</a>
<a name="ln1632">       * information which must have been removed from AS_PATH.</a>
<a name="ln1633">       */</a>
<a name="ln1634">       hops = aspath_count_hops (aspath);</a>
<a name="ln1635">    }</a>
<a name="ln1636">  </a>
<a name="ln1637">  if (!hops)</a>
<a name="ln1638">   return aspath_dup (as4path);</a>
<a name="ln1639">  </a>
<a name="ln1640">  if ( BGP_DEBUG(as4, AS4))</a>
<a name="ln1641">    zlog_debug(&quot;[AS4] got AS_PATH %s and AS4_PATH %s synthesizing now&quot;,</a>
<a name="ln1642">               aspath-&gt;str, as4path-&gt;str);</a>
<a name="ln1643"> </a>
<a name="ln1644">  while (seg &amp;&amp; hops &gt; 0)</a>
<a name="ln1645">    {</a>
<a name="ln1646">      switch (seg-&gt;type)</a>
<a name="ln1647">        {</a>
<a name="ln1648">          case AS_SET:</a>
<a name="ln1649">          case AS_CONFED_SET:</a>
<a name="ln1650">            hops--;</a>
<a name="ln1651">            cpasns = seg-&gt;length;</a>
<a name="ln1652">            break;</a>
<a name="ln1653">          case AS_CONFED_SEQUENCE:</a>
<a name="ln1654">	    /* Should never split a confed-sequence, if hop-count</a>
<a name="ln1655">	     * suggests we must then something's gone wrong somewhere.</a>
<a name="ln1656">	     *</a>
<a name="ln1657">	     * Most important goal is to preserve AS_PATHs prime function</a>
<a name="ln1658">	     * as loop-detector, so we fudge the numbers so that the entire</a>
<a name="ln1659">	     * confed-sequence is merged in.</a>
<a name="ln1660">	     */</a>
<a name="ln1661">	    if (hops &lt; seg-&gt;length)</a>
<a name="ln1662">	      {</a>
<a name="ln1663">	        if (BGP_DEBUG (as4, AS4))</a>
<a name="ln1664">	          zlog_debug (&quot;[AS4] AS4PATHmangle: AS_CONFED_SEQUENCE falls&quot;</a>
<a name="ln1665">	                      &quot; across 2/4 ASN boundary somewhere, broken..&quot;);</a>
<a name="ln1666">	        hops = seg-&gt;length;</a>
<a name="ln1667">	      }</a>
<a name="ln1668">	  case AS_SEQUENCE:</a>
<a name="ln1669">	    cpasns = MIN(seg-&gt;length, hops);</a>
<a name="ln1670">	    hops -= seg-&gt;length;</a>
<a name="ln1671">	}</a>
<a name="ln1672">      </a>
<a name="ln1673">      assert (cpasns &lt;= seg-&gt;length);</a>
<a name="ln1674">      </a>
<a name="ln1675">      newseg = assegment_new (seg-&gt;type, 0);</a>
<a name="ln1676">      newseg = assegment_append_asns (newseg, seg-&gt;as, cpasns);</a>
<a name="ln1677"> </a>
<a name="ln1678">      if (!newpath)</a>
<a name="ln1679">        {</a>
<a name="ln1680">          newpath = aspath_new ();</a>
<a name="ln1681">          newpath-&gt;segments = newseg;</a>
<a name="ln1682">        }</a>
<a name="ln1683">      else</a>
<a name="ln1684">        prevseg-&gt;next = newseg;</a>
<a name="ln1685"> </a>
<a name="ln1686">      prevseg = newseg;</a>
<a name="ln1687">      seg = seg-&gt;next;</a>
<a name="ln1688">    }</a>
<a name="ln1689">    </a>
<a name="ln1690">  /* We may be able to join some segments here, and we must</a>
<a name="ln1691">   * do this because... we want normalised aspaths in out hash</a>
<a name="ln1692">   * and we do not want to stumble in aspath_put.</a>
<a name="ln1693">   */</a>
<a name="ln1694">  mergedpath = aspath_merge (newpath, aspath_dup(as4path));</a>
<a name="ln1695">  aspath_free (newpath);</a>
<a name="ln1696">  mergedpath-&gt;segments = assegment_normalise (mergedpath-&gt;segments);</a>
<a name="ln1697">  aspath_str_update (mergedpath);</a>
<a name="ln1698">  </a>
<a name="ln1699">  if ( BGP_DEBUG(as4, AS4))</a>
<a name="ln1700">    zlog_debug (&quot;[AS4] result of synthesizing is %s&quot;,</a>
<a name="ln1701">                mergedpath-&gt;str);</a>
<a name="ln1702">  </a>
<a name="ln1703">  return mergedpath;</a>
<a name="ln1704">}</a>
<a name="ln1705"> </a>
<a name="ln1706">/* Compare leftmost AS value for MED check.  If as1's leftmost AS and</a>
<a name="ln1707">   as2's leftmost AS is same return 1. (confederation as-path</a>
<a name="ln1708">   only).  */</a>
<a name="ln1709">int</a>
<a name="ln1710">aspath_cmp_left_confed (const struct aspath *aspath1, const struct aspath *aspath2)</a>
<a name="ln1711">{</a>
<a name="ln1712">  if (! (aspath1 &amp;&amp; aspath2) )</a>
<a name="ln1713">    return 0;</a>
<a name="ln1714">  </a>
<a name="ln1715">  if ( !(aspath1-&gt;segments &amp;&amp; aspath2-&gt;segments) )</a>
<a name="ln1716">    return 0;</a>
<a name="ln1717">  </a>
<a name="ln1718">  if ( (aspath1-&gt;segments-&gt;type != AS_CONFED_SEQUENCE)</a>
<a name="ln1719">      || (aspath2-&gt;segments-&gt;type != AS_CONFED_SEQUENCE) )</a>
<a name="ln1720">    return 0;</a>
<a name="ln1721">  </a>
<a name="ln1722">  if (aspath1-&gt;segments-&gt;as[0] == aspath2-&gt;segments-&gt;as[0])</a>
<a name="ln1723">    return 1;</a>
<a name="ln1724"> </a>
<a name="ln1725">  return 0;</a>
<a name="ln1726">}</a>
<a name="ln1727"> </a>
<a name="ln1728">/* Delete all leading AS_CONFED_SEQUENCE/SET segments from aspath.</a>
<a name="ln1729"> * See RFC3065, 6.1 c1 */</a>
<a name="ln1730">struct aspath *</a>
<a name="ln1731">aspath_delete_confed_seq (struct aspath *aspath)</a>
<a name="ln1732">{</a>
<a name="ln1733">  struct assegment *seg;</a>
<a name="ln1734"> </a>
<a name="ln1735">  if (!(aspath &amp;&amp; aspath-&gt;segments))</a>
<a name="ln1736">    return aspath;</a>
<a name="ln1737"> </a>
<a name="ln1738">  seg = aspath-&gt;segments;</a>
<a name="ln1739">  </a>
<a name="ln1740">  /* &quot;if the first path segment of the AS_PATH is </a>
<a name="ln1741">   *  of type AS_CONFED_SEQUENCE,&quot;</a>
<a name="ln1742">   */</a>
<a name="ln1743">  if (aspath-&gt;segments-&gt;type != AS_CONFED_SEQUENCE)</a>
<a name="ln1744">    return aspath;</a>
<a name="ln1745"> </a>
<a name="ln1746">  /* &quot;... that segment and any immediately following segments </a>
<a name="ln1747">   *  of the type AS_CONFED_SET or AS_CONFED_SEQUENCE are removed </a>
<a name="ln1748">   *  from the AS_PATH attribute,&quot;</a>
<a name="ln1749">   */</a>
<a name="ln1750">  while (seg &amp;&amp; </a>
<a name="ln1751">         (seg-&gt;type == AS_CONFED_SEQUENCE || seg-&gt;type == AS_CONFED_SET))</a>
<a name="ln1752">    {</a>
<a name="ln1753">      aspath-&gt;segments = seg-&gt;next;</a>
<a name="ln1754">      assegment_free (seg);</a>
<a name="ln1755">      seg = aspath-&gt;segments;</a>
<a name="ln1756">    }</a>
<a name="ln1757">  aspath_str_update (aspath);</a>
<a name="ln1758">  return aspath;</a>
<a name="ln1759">}</a>
<a name="ln1760"> </a>
<a name="ln1761">/* Add new AS number to the leftmost part of the aspath as</a>
<a name="ln1762">   AS_CONFED_SEQUENCE.  */</a>
<a name="ln1763">struct aspath*</a>
<a name="ln1764">aspath_add_confed_seq (struct aspath *aspath, as_t asno)</a>
<a name="ln1765">{</a>
<a name="ln1766">  return aspath_add_asns (aspath, asno, AS_CONFED_SEQUENCE, 1);</a>
<a name="ln1767">}</a>
<a name="ln1768"> </a>
<a name="ln1769">/* Add new as value to as path structure. */</a>
<a name="ln1770">static void</a>
<a name="ln1771">aspath_as_add (struct aspath *as, as_t asno)</a>
<a name="ln1772">{</a>
<a name="ln1773">  struct assegment *seg = as-&gt;segments;</a>
<a name="ln1774"> </a>
<a name="ln1775">  if (!seg)</a>
<a name="ln1776">    return;</a>
<a name="ln1777">  </a>
<a name="ln1778">  /* Last segment search procedure. */</a>
<a name="ln1779">  while (seg-&gt;next)</a>
<a name="ln1780">    seg = seg-&gt;next;</a>
<a name="ln1781"> </a>
<a name="ln1782">  assegment_append_asns (seg, &amp;asno, 1);</a>
<a name="ln1783">}</a>
<a name="ln1784"> </a>
<a name="ln1785">/* Add new as segment to the as path. */</a>
<a name="ln1786">static void</a>
<a name="ln1787">aspath_segment_add (struct aspath *as, int type)</a>
<a name="ln1788">{</a>
<a name="ln1789">  struct assegment *seg = as-&gt;segments;</a>
<a name="ln1790">  struct assegment *new = assegment_new (type, 0);</a>
<a name="ln1791"> </a>
<a name="ln1792">  if (seg)</a>
<a name="ln1793">    {</a>
<a name="ln1794">      while (seg-&gt;next)</a>
<a name="ln1795">	seg = seg-&gt;next;</a>
<a name="ln1796">      seg-&gt;next = new;</a>
<a name="ln1797">    }</a>
<a name="ln1798">  else</a>
<a name="ln1799">    as-&gt;segments = new;</a>
<a name="ln1800">}</a>
<a name="ln1801"> </a>
<a name="ln1802">struct aspath *</a>
<a name="ln1803">aspath_empty (void)</a>
<a name="ln1804">{</a>
<a name="ln1805">  return aspath_parse (NULL, 0, 1); /* 32Bit ;-) */</a>
<a name="ln1806">}</a>
<a name="ln1807"> </a>
<a name="ln1808">struct aspath *</a>
<a name="ln1809">aspath_empty_get (void)</a>
<a name="ln1810">{</a>
<a name="ln1811">  struct aspath *aspath;</a>
<a name="ln1812"> </a>
<a name="ln1813">  aspath = aspath_new ();</a>
<a name="ln1814">  aspath_make_str_count (aspath);</a>
<a name="ln1815">  return aspath;</a>
<a name="ln1816">}</a>
<a name="ln1817"> </a>
<a name="ln1818">unsigned long</a>
<a name="ln1819">aspath_count (void)</a>
<a name="ln1820">{</a>
<a name="ln1821">  return ashash-&gt;count;</a>
<a name="ln1822">}     </a>
<a name="ln1823"> </a>
<a name="ln1824">/* </a>
<a name="ln1825">   Theoretically, one as path can have:</a>
<a name="ln1826"> </a>
<a name="ln1827">   One BGP packet size should be less than 4096.</a>
<a name="ln1828">   One BGP attribute size should be less than 4096 - BGP header size.</a>
<a name="ln1829">   One BGP aspath size should be less than 4096 - BGP header size -</a>
<a name="ln1830">       BGP mandantry attribute size.</a>
<a name="ln1831">*/</a>
<a name="ln1832"> </a>
<a name="ln1833">/* AS path string lexical token enum. */</a>
<a name="ln1834">enum as_token</a>
<a name="ln1835">{</a>
<a name="ln1836">  as_token_asval,</a>
<a name="ln1837">  as_token_set_start,</a>
<a name="ln1838">  as_token_set_end,</a>
<a name="ln1839">  as_token_confed_seq_start,</a>
<a name="ln1840">  as_token_confed_seq_end,</a>
<a name="ln1841">  as_token_confed_set_start,</a>
<a name="ln1842">  as_token_confed_set_end,</a>
<a name="ln1843">  as_token_unknown</a>
<a name="ln1844">};</a>
<a name="ln1845"> </a>
<a name="ln1846">/* Return next token and point for string parse. */</a>
<a name="ln1847">static const char *</a>
<a name="ln1848">aspath_gettoken (const char *buf, enum as_token *token, u_long *asno)</a>
<a name="ln1849">{</a>
<a name="ln1850">  const char *p = buf;</a>
<a name="ln1851"> </a>
<a name="ln1852">  /* Skip seperators (space for sequences, ',' for sets). */</a>
<a name="ln1853">  while (isspace ((int) *p) || *p == ',')</a>
<a name="ln1854">    p++;</a>
<a name="ln1855"> </a>
<a name="ln1856">  /* Check the end of the string and type specify characters</a>
<a name="ln1857">     (e.g. {}()). */</a>
<a name="ln1858">  switch (*p)</a>
<a name="ln1859">    {</a>
<a name="ln1860">    case '\0':</a>
<a name="ln1861">      return NULL;</a>
<a name="ln1862">    case '{':</a>
<a name="ln1863">      *token = as_token_set_start;</a>
<a name="ln1864">      p++;</a>
<a name="ln1865">      return p;</a>
<a name="ln1866">    case '}':</a>
<a name="ln1867">      *token = as_token_set_end;</a>
<a name="ln1868">      p++;</a>
<a name="ln1869">      return p;</a>
<a name="ln1870">    case '(':</a>
<a name="ln1871">      *token = as_token_confed_seq_start;</a>
<a name="ln1872">      p++;</a>
<a name="ln1873">      return p;</a>
<a name="ln1874">    case ')':</a>
<a name="ln1875">      *token = as_token_confed_seq_end;</a>
<a name="ln1876">      p++;</a>
<a name="ln1877">      return p;</a>
<a name="ln1878">    case '[':</a>
<a name="ln1879">      *token = as_token_confed_set_start;</a>
<a name="ln1880">      p++;</a>
<a name="ln1881">      return p;</a>
<a name="ln1882">    case ']':</a>
<a name="ln1883">      *token = as_token_confed_set_end;</a>
<a name="ln1884">      p++;</a>
<a name="ln1885">      return p;</a>
<a name="ln1886">    }</a>
<a name="ln1887"> </a>
<a name="ln1888">  /* Check actual AS value. */</a>
<a name="ln1889">  if (isdigit ((int) *p)) </a>
<a name="ln1890">    {</a>
<a name="ln1891">      as_t asval;</a>
<a name="ln1892">      </a>
<a name="ln1893">      *token = as_token_asval;</a>
<a name="ln1894">      asval = (*p - '0');</a>
<a name="ln1895">      p++;</a>
<a name="ln1896">      </a>
<a name="ln1897">      while (isdigit ((int) *p)) </a>
<a name="ln1898">        {</a>
<a name="ln1899">          asval *= 10;</a>
<a name="ln1900">          asval += (*p - '0');</a>
<a name="ln1901">          p++;</a>
<a name="ln1902">        }</a>
<a name="ln1903">      *asno = asval;</a>
<a name="ln1904">      return p;</a>
<a name="ln1905">    }</a>
<a name="ln1906">  </a>
<a name="ln1907">  /* There is no match then return unknown token. */</a>
<a name="ln1908">  *token = as_token_unknown;</a>
<a name="ln1909">  return  p++;</a>
<a name="ln1910">}</a>
<a name="ln1911"> </a>
<a name="ln1912">struct aspath *</a>
<a name="ln1913">aspath_str2aspath (const char *str)</a>
<a name="ln1914">{</a>
<a name="ln1915">  enum as_token token = as_token_unknown;</a>
<a name="ln1916">  u_short as_type;</a>
<a name="ln1917">  u_long asno = 0;</a>
<a name="ln1918">  struct aspath *aspath;</a>
<a name="ln1919">  int needtype;</a>
<a name="ln1920"> </a>
<a name="ln1921">  aspath = aspath_new ();</a>
<a name="ln1922"> </a>
<a name="ln1923">  /* We start default type as AS_SEQUENCE. */</a>
<a name="ln1924">  as_type = AS_SEQUENCE;</a>
<a name="ln1925">  needtype = 1;</a>
<a name="ln1926"> </a>
<a name="ln1927">  while ((str = aspath_gettoken (str, &amp;token, &amp;asno)) != NULL)</a>
<a name="ln1928">    {</a>
<a name="ln1929">      switch (token)</a>
<a name="ln1930">	{</a>
<a name="ln1931">	case as_token_asval:</a>
<a name="ln1932">	  if (needtype)</a>
<a name="ln1933">	    {</a>
<a name="ln1934">	      aspath_segment_add (aspath, as_type);</a>
<a name="ln1935">	      needtype = 0;</a>
<a name="ln1936">	    }</a>
<a name="ln1937">	  aspath_as_add (aspath, asno);</a>
<a name="ln1938">	  break;</a>
<a name="ln1939">	case as_token_set_start:</a>
<a name="ln1940">	  as_type = AS_SET;</a>
<a name="ln1941">	  aspath_segment_add (aspath, as_type);</a>
<a name="ln1942">	  needtype = 0;</a>
<a name="ln1943">	  break;</a>
<a name="ln1944">	case as_token_set_end:</a>
<a name="ln1945">	  as_type = AS_SEQUENCE;</a>
<a name="ln1946">	  needtype = 1;</a>
<a name="ln1947">	  break;</a>
<a name="ln1948">	case as_token_confed_seq_start:</a>
<a name="ln1949">	  as_type = AS_CONFED_SEQUENCE;</a>
<a name="ln1950">	  aspath_segment_add (aspath, as_type);</a>
<a name="ln1951">	  needtype = 0;</a>
<a name="ln1952">	  break;</a>
<a name="ln1953">	case as_token_confed_seq_end:</a>
<a name="ln1954">	  as_type = AS_SEQUENCE;</a>
<a name="ln1955">	  needtype = 1;</a>
<a name="ln1956">	  break;</a>
<a name="ln1957">	case as_token_confed_set_start:</a>
<a name="ln1958">	  as_type = AS_CONFED_SET;</a>
<a name="ln1959">	  aspath_segment_add (aspath, as_type);</a>
<a name="ln1960">	  needtype = 0;</a>
<a name="ln1961">	  break;</a>
<a name="ln1962">	case as_token_confed_set_end:</a>
<a name="ln1963">	  as_type = AS_SEQUENCE;</a>
<a name="ln1964">	  needtype = 1;</a>
<a name="ln1965">	  break;</a>
<a name="ln1966">	case as_token_unknown:</a>
<a name="ln1967">	default:</a>
<a name="ln1968">	  aspath_free (aspath);</a>
<a name="ln1969">	  return NULL;</a>
<a name="ln1970">	}</a>
<a name="ln1971">    }</a>
<a name="ln1972"> </a>
<a name="ln1973">  aspath_make_str_count (aspath);</a>
<a name="ln1974"> </a>
<a name="ln1975">  return aspath;</a>
<a name="ln1976">}</a>
<a name="ln1977"> </a>
<a name="ln1978">/* Make hash value by raw aspath data. */</a>
<a name="ln1979">unsigned int</a>
<a name="ln1980">aspath_key_make (void *p)</a>
<a name="ln1981">{</a>
<a name="ln1982">  struct aspath *aspath = (struct aspath *) p;</a>
<a name="ln1983">  unsigned int key = 0;</a>
<a name="ln1984"> </a>
<a name="ln1985">  if (!aspath-&gt;str)</a>
<a name="ln1986">    aspath_str_update (aspath);</a>
<a name="ln1987"> </a>
<a name="ln1988">  key = jhash (aspath-&gt;str, aspath-&gt;str_len, 2334325);</a>
<a name="ln1989"> </a>
<a name="ln1990">  return key;</a>
<a name="ln1991">}</a>
<a name="ln1992"> </a>
<a name="ln1993">/* If two aspath have same value then return 1 else return 0 */</a>
<a name="ln1994">int</a>
<a name="ln1995">aspath_cmp (const void *arg1, const void *arg2)</a>
<a name="ln1996">{</a>
<a name="ln1997">  const struct assegment *seg1 = ((const struct aspath *)arg1)-&gt;segments;</a>
<a name="ln1998">  const struct assegment *seg2 = ((const struct aspath *)arg2)-&gt;segments;</a>
<a name="ln1999">  </a>
<a name="ln2000">  while (seg1 || seg2)</a>
<a name="ln2001">    {</a>
<a name="ln2002">      int i;</a>
<a name="ln2003">      if ((!seg1 &amp;&amp; seg2) || (seg1 &amp;&amp; !seg2))</a>
<a name="ln2004">	return 0;</a>
<a name="ln2005">      if (seg1-&gt;type != seg2-&gt;type)</a>
<a name="ln2006">        return 0;      </a>
<a name="ln2007">      if (seg1-&gt;length != seg2-&gt;length)</a>
<a name="ln2008">        return 0;</a>
<a name="ln2009">      for (i = 0; i &lt; seg1-&gt;length; i++)</a>
<a name="ln2010">        if (seg1-&gt;as[i] != seg2-&gt;as[i])</a>
<a name="ln2011">          return 0;</a>
<a name="ln2012">      seg1 = seg1-&gt;next;</a>
<a name="ln2013">      seg2 = seg2-&gt;next;</a>
<a name="ln2014">    }</a>
<a name="ln2015">  return 1;</a>
<a name="ln2016">}</a>
<a name="ln2017"> </a>
<a name="ln2018">/* AS path hash initialize. */</a>
<a name="ln2019">void</a>
<a name="ln2020">aspath_init (void)</a>
<a name="ln2021">{</a>
<a name="ln2022">  ashash = hash_create_size (32768, aspath_key_make, aspath_cmp);</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025">void</a>
<a name="ln2026">aspath_finish (void)</a>
<a name="ln2027">{</a>
<a name="ln2028">  hash_clean (ashash, (void (*)(void *))aspath_free);</a>
<a name="ln2029">  hash_free (ashash);</a>
<a name="ln2030">  ashash = NULL;</a>
<a name="ln2031">  </a>
<a name="ln2032">  if (snmp_stream)</a>
<a name="ln2033">    stream_free (snmp_stream);</a>
<a name="ln2034">}</a>
<a name="ln2035"> </a>
<a name="ln2036">/* return and as path value */</a>
<a name="ln2037">const char *</a>
<a name="ln2038">aspath_print (struct aspath *as)</a>
<a name="ln2039">{</a>
<a name="ln2040">  return (as ? as-&gt;str : NULL);</a>
<a name="ln2041">}</a>
<a name="ln2042"> </a>
<a name="ln2043">/* Printing functions */</a>
<a name="ln2044">/* Feed the AS_PATH to the vty; the suffix string follows it only in case</a>
<a name="ln2045"> * AS_PATH wasn't empty.</a>
<a name="ln2046"> */</a>
<a name="ln2047">void</a>
<a name="ln2048">aspath_print_vty (struct vty *vty, const char *format, struct aspath *as, const char * suffix)</a>
<a name="ln2049">{</a>
<a name="ln2050">  assert (format);</a>
<a name="ln2051">  vty_out (vty, format, as-&gt;str);</a>
<a name="ln2052">  if (as-&gt;str_len &amp;&amp; strlen (suffix))</a>
<a name="ln2053">    vty_out (vty, &quot;%s&quot;, suffix);</a>
<a name="ln2054">}</a>
<a name="ln2055"> </a>
<a name="ln2056">static void</a>
<a name="ln2057">aspath_show_all_iterator (struct hash_backet *backet, struct vty *vty)</a>
<a name="ln2058">{</a>
<a name="ln2059">  struct aspath *as;</a>
<a name="ln2060"> </a>
<a name="ln2061">  as = (struct aspath *) backet-&gt;data;</a>
<a name="ln2062"> </a>
<a name="ln2063">  vty_out (vty, &quot;[%p:%u] (%ld) &quot;, (void *)backet, backet-&gt;key, as-&gt;refcnt);</a>
<a name="ln2064">  vty_out (vty, &quot;%s%s&quot;, as-&gt;str, VTY_NEWLINE);</a>
<a name="ln2065">}</a>
<a name="ln2066"> </a>
<a name="ln2067">/* Print all aspath and hash information.  This function is used from</a>
<a name="ln2068">   `show ip bgp paths' command. */</a>
<a name="ln2069">void</a>
<a name="ln2070">aspath_print_all_vty (struct vty *vty)</a>
<a name="ln2071">{</a>
<a name="ln2072">  hash_iterate (ashash, </a>
<a name="ln2073">		(void (*) (struct hash_backet *, void *))</a>
<a name="ln2074">		aspath_show_all_iterator,</a>
<a name="ln2075">		vty);</a>
<a name="ln2076">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="688"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!aspath->str' is always false.</p></div>
<div class="balloon" rel="756"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always false: (0x10 + segh.length > 0x10 + 255).</p></div>
<div class="balloon" rel="793"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v519/" target="_blank">V519</a> The 'prev' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 782, 793.</p></div>
<div class="balloon" rel="883"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'seg' is always true.</p></div>
<div class="balloon" rel="1235"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: aspath->segments.</p></div>
<div class="balloon" rel="1945"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1945, 1954, 1963</p></div>
<div class="balloon" rel="2003"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v728/" target="_blank">V728</a> An excessive check can be simplified. The '(A && !B) || (!A && B)' expression is equivalent to the 'bool(A) != bool(B)' expression.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
