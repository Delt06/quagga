
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>redistribute.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Redistribution Handler</a>
<a name="ln2"> * Copyright (C) 1998 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;vector.h&quot;</a>
<a name="ln25">#include &quot;vty.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;table.h&quot;</a>
<a name="ln29">#include &quot;stream.h&quot;</a>
<a name="ln30">#include &quot;zclient.h&quot;</a>
<a name="ln31">#include &quot;linklist.h&quot;</a>
<a name="ln32">#include &quot;log.h&quot;</a>
<a name="ln33">#include &quot;vrf.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;zebra/rib.h&quot;</a>
<a name="ln36">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln37">#include &quot;zebra/redistribute.h&quot;</a>
<a name="ln38">#include &quot;zebra/debug.h&quot;</a>
<a name="ln39">#include &quot;zebra/router-id.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">/* master zebra server structure */</a>
<a name="ln42">extern struct zebra_t zebrad;</a>
<a name="ln43"> </a>
<a name="ln44">int</a>
<a name="ln45">zebra_check_addr (struct prefix *p)</a>
<a name="ln46">{</a>
<a name="ln47">  if (p-&gt;family == AF_INET)</a>
<a name="ln48">    {</a>
<a name="ln49">      u_int32_t addr;</a>
<a name="ln50"> </a>
<a name="ln51">      addr = p-&gt;u.prefix4.s_addr;</a>
<a name="ln52">      addr = ntohl (addr);</a>
<a name="ln53"> </a>
<a name="ln54">      if (IPV4_NET127 (addr)</a>
<a name="ln55">          || IN_CLASSD (addr)</a>
<a name="ln56">          || IPV4_LINKLOCAL(addr))</a>
<a name="ln57">	return 0;</a>
<a name="ln58">    }</a>
<a name="ln59">#ifdef HAVE_IPV6</a>
<a name="ln60">  if (p-&gt;family == AF_INET6)</a>
<a name="ln61">    {</a>
<a name="ln62">      if (IN6_IS_ADDR_LOOPBACK (&amp;p-&gt;u.prefix6))</a>
<a name="ln63">	return 0;</a>
<a name="ln64">      if (IN6_IS_ADDR_LINKLOCAL(&amp;p-&gt;u.prefix6))</a>
<a name="ln65">	return 0;</a>
<a name="ln66">    }</a>
<a name="ln67">#endif /* HAVE_IPV6 */</a>
<a name="ln68">  return 1;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">int</a>
<a name="ln72">is_default (struct prefix *p)</a>
<a name="ln73">{</a>
<a name="ln74">  if (p-&gt;family == AF_INET)</a>
<a name="ln75">    if (p-&gt;u.prefix4.s_addr == 0 &amp;&amp; p-&gt;prefixlen == 0)</a>
<a name="ln76">      return 1;</a>
<a name="ln77">#ifdef HAVE_IPV6</a>
<a name="ln78">#if 0  /* IPv6 default separation is now pending until protocol daemon</a>
<a name="ln79">          can handle that. */</a>
<a name="ln80">  if (p-&gt;family == AF_INET6)</a>
<a name="ln81">    if (IN6_IS_ADDR_UNSPECIFIED (&amp;p-&gt;u.prefix6) &amp;&amp; p-&gt;prefixlen == 0)</a>
<a name="ln82">      return 1;</a>
<a name="ln83">#endif /* 0 */</a>
<a name="ln84">#endif /* HAVE_IPV6 */</a>
<a name="ln85">  return 0;</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">static void</a>
<a name="ln89">zebra_redistribute_default (struct zserv *client, vrf_id_t vrf_id)</a>
<a name="ln90">{</a>
<a name="ln91">  struct prefix_ipv4 p;</a>
<a name="ln92">  struct route_table *table;</a>
<a name="ln93">  struct route_node *rn;</a>
<a name="ln94">  struct rib *newrib;</a>
<a name="ln95">#ifdef HAVE_IPV6</a>
<a name="ln96">  struct prefix_ipv6 p6;</a>
<a name="ln97">#endif /* HAVE_IPV6 */</a>
<a name="ln98"> </a>
<a name="ln99"> </a>
<a name="ln100">  /* Lookup default route. */</a>
<a name="ln101">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln102">  p.family = AF_INET;</a>
<a name="ln103"> </a>
<a name="ln104">  /* Lookup table.  */</a>
<a name="ln105">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, vrf_id);</a>
<a name="ln106">  if (table)</a>
<a name="ln107">    {</a>
<a name="ln108">      rn = route_node_lookup (table, (struct prefix *)&amp;p);</a>
<a name="ln109">      if (rn)</a>
<a name="ln110">	{</a>
<a name="ln111">	  RNODE_FOREACH_RIB (rn, newrib)</a>
<a name="ln112">	    if (CHECK_FLAG (newrib-&gt;flags, ZEBRA_FLAG_SELECTED)</a>
<a name="ln113">		&amp;&amp; newrib-&gt;distance != DISTANCE_INFINITY)</a>
<a name="ln114">	      zsend_route_multipath (ZEBRA_IPV4_ROUTE_ADD, client, &amp;rn-&gt;p, newrib);</a>
<a name="ln115">	  route_unlock_node (rn);</a>
<a name="ln116">	}</a>
<a name="ln117">    }</a>
<a name="ln118"> </a>
<a name="ln119">#ifdef HAVE_IPV6</a>
<a name="ln120">  /* Lookup default route. */</a>
<a name="ln121">  memset (&amp;p6, 0, sizeof (struct prefix_ipv6));</a>
<a name="ln122">  p6.family = AF_INET6;</a>
<a name="ln123"> </a>
<a name="ln124">  /* Lookup table.  */</a>
<a name="ln125">  table = zebra_vrf_table (AFI_IP6, SAFI_UNICAST, vrf_id);</a>
<a name="ln126">  if (table)</a>
<a name="ln127">    {</a>
<a name="ln128">      rn = route_node_lookup (table, (struct prefix *)&amp;p6);</a>
<a name="ln129">      if (rn)</a>
<a name="ln130">	{</a>
<a name="ln131">	  RNODE_FOREACH_RIB (rn, newrib)</a>
<a name="ln132">	    if (CHECK_FLAG (newrib-&gt;flags, ZEBRA_FLAG_SELECTED)</a>
<a name="ln133">		&amp;&amp; newrib-&gt;distance != DISTANCE_INFINITY)</a>
<a name="ln134">	      zsend_route_multipath (ZEBRA_IPV6_ROUTE_ADD, client, &amp;rn-&gt;p, newrib);</a>
<a name="ln135">	  route_unlock_node (rn);</a>
<a name="ln136">	}</a>
<a name="ln137">    }</a>
<a name="ln138">#endif /* HAVE_IPV6 */</a>
<a name="ln139">}</a>
<a name="ln140"> </a>
<a name="ln141">/* Redistribute routes. */</a>
<a name="ln142">static void</a>
<a name="ln143">zebra_redistribute (struct zserv *client, int type, vrf_id_t vrf_id)</a>
<a name="ln144">{</a>
<a name="ln145">  struct rib *newrib;</a>
<a name="ln146">  struct route_table *table;</a>
<a name="ln147">  struct route_node *rn;</a>
<a name="ln148"> </a>
<a name="ln149">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, vrf_id);</a>
<a name="ln150">  if (table)</a>
<a name="ln151">    for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln152">      RNODE_FOREACH_RIB (rn, newrib)</a>
<a name="ln153">        {</a>
<a name="ln154">          if (IS_ZEBRA_DEBUG_EVENT)</a>
<a name="ln155">            zlog_debug(&quot;%s: checking: selected=%d, type=%d, distance=%d, zebra_check_addr=%d&quot;,</a>
<a name="ln156">                       __func__, CHECK_FLAG (newrib-&gt;flags, ZEBRA_FLAG_SELECTED),</a>
<a name="ln157">                       newrib-&gt;type, newrib-&gt;distance, zebra_check_addr (&amp;rn-&gt;p));</a>
<a name="ln158">          if (CHECK_FLAG (newrib-&gt;flags, ZEBRA_FLAG_SELECTED)</a>
<a name="ln159">              &amp;&amp; newrib-&gt;type == type</a>
<a name="ln160">              &amp;&amp; newrib-&gt;distance != DISTANCE_INFINITY</a>
<a name="ln161">              &amp;&amp; zebra_check_addr (&amp;rn-&gt;p))</a>
<a name="ln162">	    {</a>
<a name="ln163">	      client-&gt;redist_v4_add_cnt++;</a>
<a name="ln164">              zsend_route_multipath (ZEBRA_IPV4_ROUTE_ADD, client, &amp;rn-&gt;p, newrib);</a>
<a name="ln165">            }</a>
<a name="ln166">        }</a>
<a name="ln167"> </a>
<a name="ln168">#ifdef HAVE_IPV6</a>
<a name="ln169">  table = zebra_vrf_table (AFI_IP6, SAFI_UNICAST, vrf_id);</a>
<a name="ln170">  if (table)</a>
<a name="ln171">    for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln172">      RNODE_FOREACH_RIB (rn, newrib)</a>
<a name="ln173">	if (CHECK_FLAG (newrib-&gt;flags, ZEBRA_FLAG_SELECTED)</a>
<a name="ln174">	    &amp;&amp; newrib-&gt;type == type </a>
<a name="ln175">	    &amp;&amp; newrib-&gt;distance != DISTANCE_INFINITY</a>
<a name="ln176">	    &amp;&amp; zebra_check_addr (&amp;rn-&gt;p))</a>
<a name="ln177">	  {</a>
<a name="ln178">	    client-&gt;redist_v6_add_cnt++;</a>
<a name="ln179">	    zsend_route_multipath (ZEBRA_IPV6_ROUTE_ADD, client, &amp;rn-&gt;p, newrib);</a>
<a name="ln180">	  }</a>
<a name="ln181">#endif /* HAVE_IPV6 */</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">void</a>
<a name="ln185">redistribute_add (struct prefix *p, struct rib *rib, struct rib *rib_old)</a>
<a name="ln186">{</a>
<a name="ln187">  struct listnode *node, *nnode;</a>
<a name="ln188">  struct zserv *client;</a>
<a name="ln189">  </a>
<a name="ln190">  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))</a>
<a name="ln191">    {</a>
<a name="ln192">      if ((is_default (p) &amp;&amp;</a>
<a name="ln193">           vrf_bitmap_check (client-&gt;redist_default, rib-&gt;vrf_id))</a>
<a name="ln194">          || vrf_bitmap_check (client-&gt;redist[rib-&gt;type], rib-&gt;vrf_id))</a>
<a name="ln195">        {</a>
<a name="ln196">          if (p-&gt;family == AF_INET)</a>
<a name="ln197">	    {</a>
<a name="ln198">	      client-&gt;redist_v4_add_cnt++;</a>
<a name="ln199">	      zsend_route_multipath (ZEBRA_IPV4_ROUTE_ADD, client, p, rib);</a>
<a name="ln200">	    }</a>
<a name="ln201">          if (p-&gt;family == AF_INET6)</a>
<a name="ln202">	    {</a>
<a name="ln203">	      client-&gt;redist_v6_add_cnt++;</a>
<a name="ln204">	      zsend_route_multipath (ZEBRA_IPV6_ROUTE_ADD, client, p, rib);</a>
<a name="ln205">	    }</a>
<a name="ln206">        }</a>
<a name="ln207">      else if (rib_old &amp;&amp; vrf_bitmap_check (client-&gt;redist[rib_old-&gt;type], </a>
<a name="ln208">                                            rib_old-&gt;vrf_id))</a>
<a name="ln209">        {</a>
<a name="ln210">          /* redistribute_add has implicit withdraw semantics, so there</a>
<a name="ln211">           * may be an old route already redistributed that is being updated.</a>
<a name="ln212">           *</a>
<a name="ln213">           * However, if the new route is of a type that is /not/ redistributed</a>
<a name="ln214">           * to the client, then we must ensure the old route is explicitly</a>
<a name="ln215">           * withdrawn.</a>
<a name="ln216">           */</a>
<a name="ln217">          if (p-&gt;family == AF_INET)</a>
<a name="ln218">            zsend_route_multipath (ZEBRA_IPV4_ROUTE_DELETE, client, p, rib_old);</a>
<a name="ln219">          if (p-&gt;family == AF_INET6)</a>
<a name="ln220">            zsend_route_multipath (ZEBRA_IPV6_ROUTE_DELETE, client, p, rib_old);</a>
<a name="ln221">        }</a>
<a name="ln222">    }</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">void</a>
<a name="ln226">redistribute_delete (struct prefix *p, struct rib *rib)</a>
<a name="ln227">{</a>
<a name="ln228">  struct listnode *node, *nnode;</a>
<a name="ln229">  struct zserv *client;</a>
<a name="ln230"> </a>
<a name="ln231">  /* Add DISTANCE_INFINITY check. */</a>
<a name="ln232">  if (rib-&gt;distance == DISTANCE_INFINITY)</a>
<a name="ln233">    return;</a>
<a name="ln234"> </a>
<a name="ln235">  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))</a>
<a name="ln236">    {</a>
<a name="ln237">      if ((is_default (p) &amp;&amp;</a>
<a name="ln238">           vrf_bitmap_check (client-&gt;redist_default, rib-&gt;vrf_id))</a>
<a name="ln239">          || vrf_bitmap_check (client-&gt;redist[rib-&gt;type], rib-&gt;vrf_id))</a>
<a name="ln240">	{</a>
<a name="ln241">	  if (p-&gt;family == AF_INET)</a>
<a name="ln242">	    zsend_route_multipath (ZEBRA_IPV4_ROUTE_DELETE, client, p, rib);</a>
<a name="ln243">#ifdef HAVE_IPV6</a>
<a name="ln244">	  if (p-&gt;family == AF_INET6)</a>
<a name="ln245">	    zsend_route_multipath (ZEBRA_IPV6_ROUTE_DELETE, client, p, rib);</a>
<a name="ln246">#endif /* HAVE_IPV6 */</a>
<a name="ln247">	}</a>
<a name="ln248">    }</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">void</a>
<a name="ln252">zebra_redistribute_add (int command, struct zserv *client, int length,</a>
<a name="ln253">    vrf_id_t vrf_id)</a>
<a name="ln254">{</a>
<a name="ln255">  int type;</a>
<a name="ln256"> </a>
<a name="ln257">  type = stream_getc (client-&gt;ibuf);</a>
<a name="ln258"> </a>
<a name="ln259">  if (type == 0 || type &gt;= ZEBRA_ROUTE_MAX)</a>
<a name="ln260">    return;</a>
<a name="ln261"> </a>
<a name="ln262">  if (! vrf_bitmap_check (client-&gt;redist[type], vrf_id))</a>
<a name="ln263">    {</a>
<a name="ln264">      vrf_bitmap_set (client-&gt;redist[type], vrf_id);</a>
<a name="ln265">      zebra_redistribute (client, type, vrf_id);</a>
<a name="ln266">    }</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">void</a>
<a name="ln270">zebra_redistribute_delete (int command, struct zserv *client, int length,</a>
<a name="ln271">    vrf_id_t vrf_id)</a>
<a name="ln272">{</a>
<a name="ln273">  int type;</a>
<a name="ln274"> </a>
<a name="ln275">  type = stream_getc (client-&gt;ibuf);</a>
<a name="ln276"> </a>
<a name="ln277">  if (type == 0 || type &gt;= ZEBRA_ROUTE_MAX)</a>
<a name="ln278">    return;</a>
<a name="ln279"> </a>
<a name="ln280">  vrf_bitmap_unset (client-&gt;redist[type], vrf_id);</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">void</a>
<a name="ln284">zebra_redistribute_default_add (int command, struct zserv *client, int length,</a>
<a name="ln285">    vrf_id_t vrf_id)</a>
<a name="ln286">{</a>
<a name="ln287">  vrf_bitmap_set (client-&gt;redist_default, vrf_id);</a>
<a name="ln288">  zebra_redistribute_default (client, vrf_id);</a>
<a name="ln289">}     </a>
<a name="ln290"> </a>
<a name="ln291">void</a>
<a name="ln292">zebra_redistribute_default_delete (int command, struct zserv *client,</a>
<a name="ln293">    int length, vrf_id_t vrf_id)</a>
<a name="ln294">{</a>
<a name="ln295">  vrf_bitmap_unset (client-&gt;redist_default, vrf_id);</a>
<a name="ln296">}     </a>
<a name="ln297"> </a>
<a name="ln298">/* Interface up information. */</a>
<a name="ln299">void</a>
<a name="ln300">zebra_interface_up_update (struct interface *ifp)</a>
<a name="ln301">{</a>
<a name="ln302">  struct listnode *node, *nnode;</a>
<a name="ln303">  struct zserv *client;</a>
<a name="ln304"> </a>
<a name="ln305">  if (IS_ZEBRA_DEBUG_EVENT)</a>
<a name="ln306">    zlog_debug (&quot;MESSAGE: ZEBRA_INTERFACE_UP %s&quot;, ifp-&gt;name);</a>
<a name="ln307"> </a>
<a name="ln308">  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))</a>
<a name="ln309">    if (client-&gt;ifinfo)</a>
<a name="ln310">      {</a>
<a name="ln311">        zsend_interface_update (ZEBRA_INTERFACE_UP, client, ifp);</a>
<a name="ln312">        zsend_interface_link_params (client, ifp);</a>
<a name="ln313">      }</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">/* Interface down information. */</a>
<a name="ln317">void</a>
<a name="ln318">zebra_interface_down_update (struct interface *ifp)</a>
<a name="ln319">{</a>
<a name="ln320">  struct listnode *node, *nnode;</a>
<a name="ln321">  struct zserv *client;</a>
<a name="ln322"> </a>
<a name="ln323">  if (IS_ZEBRA_DEBUG_EVENT)</a>
<a name="ln324">    zlog_debug (&quot;MESSAGE: ZEBRA_INTERFACE_DOWN %s&quot;, ifp-&gt;name);</a>
<a name="ln325"> </a>
<a name="ln326">  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))</a>
<a name="ln327">    {</a>
<a name="ln328">      zsend_interface_update (ZEBRA_INTERFACE_DOWN, client, ifp);</a>
<a name="ln329">    }</a>
<a name="ln330">}</a>
<a name="ln331"> </a>
<a name="ln332">/* Interface information update. */</a>
<a name="ln333">void</a>
<a name="ln334">zebra_interface_add_update (struct interface *ifp)</a>
<a name="ln335">{</a>
<a name="ln336">  struct listnode *node, *nnode;</a>
<a name="ln337">  struct zserv *client;</a>
<a name="ln338"> </a>
<a name="ln339">  if (IS_ZEBRA_DEBUG_EVENT)</a>
<a name="ln340">    zlog_debug (&quot;MESSAGE: ZEBRA_INTERFACE_ADD %s&quot;, ifp-&gt;name);</a>
<a name="ln341">    </a>
<a name="ln342">  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))</a>
<a name="ln343">    if (client-&gt;ifinfo)</a>
<a name="ln344">      {</a>
<a name="ln345">	client-&gt;ifadd_cnt++;</a>
<a name="ln346">	zsend_interface_add (client, ifp);</a>
<a name="ln347">        zsend_interface_link_params (client, ifp);</a>
<a name="ln348">      }</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">void</a>
<a name="ln352">zebra_interface_delete_update (struct interface *ifp)</a>
<a name="ln353">{</a>
<a name="ln354">  struct listnode *node, *nnode;</a>
<a name="ln355">  struct zserv *client;</a>
<a name="ln356"> </a>
<a name="ln357">  if (IS_ZEBRA_DEBUG_EVENT)</a>
<a name="ln358">    zlog_debug (&quot;MESSAGE: ZEBRA_INTERFACE_DELETE %s&quot;, ifp-&gt;name);</a>
<a name="ln359"> </a>
<a name="ln360">  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))</a>
<a name="ln361">    if (client-&gt;ifinfo)</a>
<a name="ln362">      {</a>
<a name="ln363">	client-&gt;ifdel_cnt++;</a>
<a name="ln364">	zsend_interface_delete (client, ifp);</a>
<a name="ln365">      }</a>
<a name="ln366">}</a>
<a name="ln367"> </a>
<a name="ln368">/* Interface address addition. */</a>
<a name="ln369">void</a>
<a name="ln370">zebra_interface_address_add_update (struct interface *ifp,</a>
<a name="ln371">				    struct connected *ifc)</a>
<a name="ln372">{</a>
<a name="ln373">  struct listnode *node, *nnode;</a>
<a name="ln374">  struct zserv *client;</a>
<a name="ln375">  struct prefix *p;</a>
<a name="ln376"> </a>
<a name="ln377">  if (IS_ZEBRA_DEBUG_EVENT)</a>
<a name="ln378">    {</a>
<a name="ln379">      char buf[PREFIX_STRLEN];</a>
<a name="ln380"> </a>
<a name="ln381">      p = ifc-&gt;address;</a>
<a name="ln382">      zlog_debug (&quot;MESSAGE: ZEBRA_INTERFACE_ADDRESS_ADD %s on %s&quot;,</a>
<a name="ln383">		  prefix2str (p, buf, sizeof(buf)),</a>
<a name="ln384">		  ifc-&gt;ifp-&gt;name);</a>
<a name="ln385">    }</a>
<a name="ln386"> </a>
<a name="ln387">  if (!CHECK_FLAG(ifc-&gt;conf, ZEBRA_IFC_REAL))</a>
<a name="ln388">    zlog_warn(&quot;WARNING: advertising address to clients that is not yet usable.&quot;);</a>
<a name="ln389"> </a>
<a name="ln390">  router_id_add_address(ifc);</a>
<a name="ln391"> </a>
<a name="ln392">  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))</a>
<a name="ln393">    if (client-&gt;ifinfo &amp;&amp; CHECK_FLAG (ifc-&gt;conf, ZEBRA_IFC_REAL))</a>
<a name="ln394">      {</a>
<a name="ln395">	client-&gt;connected_rt_add_cnt++;</a>
<a name="ln396">	zsend_interface_address (ZEBRA_INTERFACE_ADDRESS_ADD, client, ifp, ifc);</a>
<a name="ln397">      }</a>
<a name="ln398">}</a>
<a name="ln399"> </a>
<a name="ln400">/* Interface address deletion. */</a>
<a name="ln401">void</a>
<a name="ln402">zebra_interface_address_delete_update (struct interface *ifp,</a>
<a name="ln403">				       struct connected *ifc)</a>
<a name="ln404">{</a>
<a name="ln405">  struct listnode *node, *nnode;</a>
<a name="ln406">  struct zserv *client;</a>
<a name="ln407">  struct prefix *p;</a>
<a name="ln408"> </a>
<a name="ln409">  if (IS_ZEBRA_DEBUG_EVENT)</a>
<a name="ln410">    {</a>
<a name="ln411">      char buf[PREFIX_STRLEN];</a>
<a name="ln412"> </a>
<a name="ln413">      p = ifc-&gt;address;</a>
<a name="ln414">      zlog_debug (&quot;MESSAGE: ZEBRA_INTERFACE_ADDRESS_DELETE %s on %s&quot;,</a>
<a name="ln415">		  prefix2str (p, buf, sizeof(buf)),</a>
<a name="ln416">		  ifc-&gt;ifp-&gt;name);</a>
<a name="ln417">    }</a>
<a name="ln418"> </a>
<a name="ln419">  router_id_del_address(ifc);</a>
<a name="ln420"> </a>
<a name="ln421">  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))</a>
<a name="ln422">    if (client-&gt;ifinfo &amp;&amp; CHECK_FLAG (ifc-&gt;conf, ZEBRA_IFC_REAL))</a>
<a name="ln423">      {</a>
<a name="ln424">	client-&gt;connected_rt_del_cnt++;</a>
<a name="ln425">	zsend_interface_address (ZEBRA_INTERFACE_ADDRESS_DELETE, client, ifp, ifc);</a>
<a name="ln426">      }</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">/* Interface parameters update */</a>
<a name="ln430">void</a>
<a name="ln431">zebra_interface_parameters_update (struct interface *ifp)</a>
<a name="ln432">{</a>
<a name="ln433">  struct listnode *node, *nnode;</a>
<a name="ln434">  struct zserv *client;</a>
<a name="ln435"> </a>
<a name="ln436">  if (IS_ZEBRA_DEBUG_EVENT)</a>
<a name="ln437">    zlog_debug (&quot;MESSAGE: ZEBRA_INTERFACE_LINK_PARAMS %s&quot;, ifp-&gt;name);</a>
<a name="ln438"> </a>
<a name="ln439">  for (ALL_LIST_ELEMENTS (zebrad.client_list, node, nnode, client))</a>
<a name="ln440">    if (client-&gt;ifinfo)</a>
<a name="ln441">      zsend_interface_link_params (client, ifp);</a>
<a name="ln442">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
