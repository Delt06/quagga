
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospfd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* OSPF version 2 daemon program.</a>
<a name="ln2">   Copyright (C) 1999, 2000 Toshiaki Takada</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;thread.h&quot;</a>
<a name="ln24">#include &quot;vty.h&quot;</a>
<a name="ln25">#include &quot;command.h&quot;</a>
<a name="ln26">#include &quot;linklist.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;table.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;memory.h&quot;</a>
<a name="ln31">#include &quot;stream.h&quot;</a>
<a name="ln32">#include &quot;log.h&quot;</a>
<a name="ln33">#include &quot;sockunion.h&quot;          /* for inet_aton () */</a>
<a name="ln34">#include &quot;zclient.h&quot;</a>
<a name="ln35">#include &quot;plist.h&quot;</a>
<a name="ln36">#include &quot;sockopt.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_network.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln48">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln49">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln50">#include &quot;ospfd/ospf_zebra.h&quot;</a>
<a name="ln51">#include &quot;ospfd/ospf_abr.h&quot;</a>
<a name="ln52">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln53">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln54">#include &quot;ospfd/ospf_ase.h&quot;</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57"> </a>
<a name="ln58">/* OSPF process wide configuration. */</a>
<a name="ln59">static struct ospf_master ospf_master;</a>
<a name="ln60"> </a>
<a name="ln61">/* OSPF process wide configuration pointer to export. */</a>
<a name="ln62">struct ospf_master *om;</a>
<a name="ln63"> </a>
<a name="ln64">extern struct zclient *zclient;</a>
<a name="ln65">extern struct in_addr router_id_zebra;</a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68">static void ospf_remove_vls_through_area (struct ospf *, struct ospf_area *);</a>
<a name="ln69">static void ospf_network_free (struct ospf *, struct ospf_network *);</a>
<a name="ln70">static void ospf_area_free (struct ospf_area *);</a>
<a name="ln71">static void ospf_network_run (struct prefix *, struct ospf_area *);</a>
<a name="ln72">static void ospf_network_run_interface (struct ospf *, struct interface *, </a>
<a name="ln73">                                        struct prefix *, struct ospf_area *);</a>
<a name="ln74">static void ospf_network_run_subnet (struct ospf *, struct connected *, </a>
<a name="ln75">                                     struct prefix *, struct ospf_area *);</a>
<a name="ln76">static int ospf_network_match_iface (const struct connected *,</a>
<a name="ln77">				     const struct prefix *);</a>
<a name="ln78">static void ospf_finish_final (struct ospf *);</a>
<a name="ln79"> </a>
<a name="ln80">#define OSPF_EXTERNAL_LSA_ORIGINATE_DELAY 1</a>
<a name="ln81"> </a>
<a name="ln82">void</a>
<a name="ln83">ospf_router_id_update (struct ospf *ospf)</a>
<a name="ln84">{</a>
<a name="ln85">  struct in_addr router_id, router_id_old;</a>
<a name="ln86">  struct ospf_interface *oi;</a>
<a name="ln87">  struct interface *ifp;</a>
<a name="ln88">  struct listnode *node;</a>
<a name="ln89"> </a>
<a name="ln90">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln91">    zlog_debug (&quot;Router-ID[OLD:%s]: Update&quot;, inet_ntoa (ospf-&gt;router_id));</a>
<a name="ln92"> </a>
<a name="ln93">  router_id_old = ospf-&gt;router_id;</a>
<a name="ln94"> </a>
<a name="ln95">  /* Select the router ID based on these priorities:</a>
<a name="ln96">       1. Statically assigned router ID is always the first choice.</a>
<a name="ln97">       2. If there is no statically assigned router ID, then try to stick</a>
<a name="ln98">          with the most recent value, since changing router ID's is very</a>
<a name="ln99">	  disruptive.</a>
<a name="ln100">       3. Last choice: just go with whatever the zebra daemon recommends.</a>
<a name="ln101">  */</a>
<a name="ln102">  if (ospf-&gt;router_id_static.s_addr != 0)</a>
<a name="ln103">    router_id = ospf-&gt;router_id_static;</a>
<a name="ln104">  else if (ospf-&gt;router_id.s_addr != 0)</a>
<a name="ln105">    router_id = ospf-&gt;router_id;</a>
<a name="ln106">  else</a>
<a name="ln107">    router_id = router_id_zebra;</a>
<a name="ln108"> </a>
<a name="ln109">  ospf-&gt;router_id = router_id;</a>
<a name="ln110">  </a>
<a name="ln111">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln112">    zlog_debug (&quot;Router-ID[NEW:%s]: Update&quot;, inet_ntoa (ospf-&gt;router_id));</a>
<a name="ln113"> </a>
<a name="ln114">  if (!IPV4_ADDR_SAME (&amp;router_id_old, &amp;router_id))</a>
<a name="ln115">    {</a>
<a name="ln116">      for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, node, oi))</a>
<a name="ln117">	{</a>
<a name="ln118">	  /* Some nbrs are identified by router_id, these needs</a>
<a name="ln119">	   * to be rebuilt. Possible optimization would be to do</a>
<a name="ln120">	   * oi-&gt;nbr_self-&gt;router_id = router_id for</a>
<a name="ln121">	   * !(virtual | ptop) links</a>
<a name="ln122">	   */</a>
<a name="ln123">	  ospf_nbr_self_reset (oi);</a>
<a name="ln124">	}</a>
<a name="ln125"> </a>
<a name="ln126">      /* If AS-external-LSA is queued, then flush those LSAs. */</a>
<a name="ln127">      if (router_id_old.s_addr == 0 &amp;&amp; ospf-&gt;external_origin)</a>
<a name="ln128">	{</a>
<a name="ln129">	  int type;</a>
<a name="ln130">	  /* Originate each redistributed external route. */</a>
<a name="ln131">	  for (type = 0; type &lt; ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln132">	    if (ospf-&gt;external_origin &amp; (1 &lt;&lt; type))</a>
<a name="ln133">	      thread_add_event (master, ospf_external_lsa_originate_timer,</a>
<a name="ln134">				ospf, type);</a>
<a name="ln135">	  /* Originate Deafult. */</a>
<a name="ln136">	  if (ospf-&gt;external_origin &amp; (1 &lt;&lt; ZEBRA_ROUTE_MAX))</a>
<a name="ln137">	    thread_add_event (master, ospf_default_originate_timer, ospf, 0);</a>
<a name="ln138"> </a>
<a name="ln139">	  ospf-&gt;external_origin = 0;</a>
<a name="ln140">	}</a>
<a name="ln141"> </a>
<a name="ln142">      /* update router-lsa's for each area */</a>
<a name="ln143">      ospf_router_lsa_update (ospf);</a>
<a name="ln144">      </a>
<a name="ln145">      /* update ospf_interface's */</a>
<a name="ln146">      for (ALL_LIST_ELEMENTS_RO (om-&gt;iflist, node, ifp))</a>
<a name="ln147">        ospf_if_update (ospf, ifp);</a>
<a name="ln148">    }</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">/* For OSPF area sort by area id. */</a>
<a name="ln152">static int</a>
<a name="ln153">ospf_area_id_cmp (struct ospf_area *a1, struct ospf_area *a2)</a>
<a name="ln154">{</a>
<a name="ln155">  if (ntohl (a1-&gt;area_id.s_addr) &gt; ntohl (a2-&gt;area_id.s_addr))</a>
<a name="ln156">    return 1;</a>
<a name="ln157">  if (ntohl (a1-&gt;area_id.s_addr) &lt; ntohl (a2-&gt;area_id.s_addr))</a>
<a name="ln158">    return -1;</a>
<a name="ln159">  return 0;</a>
<a name="ln160">}</a>
<a name="ln161"> </a>
<a name="ln162">/* Allocate new ospf structure. */</a>
<a name="ln163">static struct ospf *</a>
<a name="ln164">ospf_new (void)</a>
<a name="ln165">{</a>
<a name="ln166">  int i;</a>
<a name="ln167"> </a>
<a name="ln168">  struct ospf *new = XCALLOC (MTYPE_OSPF_TOP, sizeof (struct ospf));</a>
<a name="ln169"> </a>
<a name="ln170">  new-&gt;router_id.s_addr = htonl (0);</a>
<a name="ln171">  new-&gt;router_id_static.s_addr = htonl (0);</a>
<a name="ln172"> </a>
<a name="ln173">  new-&gt;abr_type = OSPF_ABR_DEFAULT;</a>
<a name="ln174">  new-&gt;oiflist = list_new ();</a>
<a name="ln175">  new-&gt;vlinks = list_new ();</a>
<a name="ln176">  new-&gt;areas = list_new ();</a>
<a name="ln177">  new-&gt;areas-&gt;cmp = (int (*)(void *, void *)) ospf_area_id_cmp;</a>
<a name="ln178">  new-&gt;networks = route_table_init ();</a>
<a name="ln179">  new-&gt;nbr_nbma = route_table_init ();</a>
<a name="ln180"> </a>
<a name="ln181">  new-&gt;lsdb = ospf_lsdb_new ();</a>
<a name="ln182"> </a>
<a name="ln183">  new-&gt;default_originate = DEFAULT_ORIGINATE_NONE;</a>
<a name="ln184"> </a>
<a name="ln185">  new-&gt;passive_interface_default = OSPF_IF_ACTIVE;</a>
<a name="ln186">  </a>
<a name="ln187">  new-&gt;new_external_route = route_table_init ();</a>
<a name="ln188">  new-&gt;old_external_route = route_table_init ();</a>
<a name="ln189">  new-&gt;external_lsas = route_table_init ();</a>
<a name="ln190">  </a>
<a name="ln191">  new-&gt;stub_router_startup_time = OSPF_STUB_ROUTER_UNCONFIGURED;</a>
<a name="ln192">  new-&gt;stub_router_shutdown_time = OSPF_STUB_ROUTER_UNCONFIGURED;</a>
<a name="ln193">  new-&gt;stub_router_admin_set     = OSPF_STUB_ROUTER_ADMINISTRATIVE_UNSET;</a>
<a name="ln194"> </a>
<a name="ln195">  /* Distribute parameter init. */</a>
<a name="ln196">  for (i = 0; i &lt;= ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln197">    {</a>
<a name="ln198">      new-&gt;dmetric[i].type = -1;</a>
<a name="ln199">      new-&gt;dmetric[i].value = -1;</a>
<a name="ln200">      new-&gt;dtag[i] = 0;</a>
<a name="ln201">    }</a>
<a name="ln202">  new-&gt;default_metric = -1;</a>
<a name="ln203">  new-&gt;ref_bandwidth = OSPF_DEFAULT_REF_BANDWIDTH;</a>
<a name="ln204"> </a>
<a name="ln205">  /* LSA timers */</a>
<a name="ln206">  new-&gt;min_ls_interval = OSPF_MIN_LS_INTERVAL;</a>
<a name="ln207">  new-&gt;min_ls_arrival = OSPF_MIN_LS_ARRIVAL;</a>
<a name="ln208"> </a>
<a name="ln209">  /* SPF timer value init. */</a>
<a name="ln210">  new-&gt;spf_delay = OSPF_SPF_DELAY_DEFAULT;</a>
<a name="ln211">  new-&gt;spf_holdtime = OSPF_SPF_HOLDTIME_DEFAULT;</a>
<a name="ln212">  new-&gt;spf_max_holdtime = OSPF_SPF_MAX_HOLDTIME_DEFAULT;</a>
<a name="ln213">  new-&gt;spf_hold_multiplier = 1;</a>
<a name="ln214"> </a>
<a name="ln215">  /* MaxAge init. */</a>
<a name="ln216">  new-&gt;maxage_delay = OSPF_LSA_MAXAGE_REMOVE_DELAY_DEFAULT;</a>
<a name="ln217">  new-&gt;maxage_lsa = route_table_init();</a>
<a name="ln218">  new-&gt;t_maxage_walker =</a>
<a name="ln219">    thread_add_timer (master, ospf_lsa_maxage_walker,</a>
<a name="ln220">                      new, OSPF_LSA_MAXAGE_CHECK_INTERVAL);</a>
<a name="ln221"> </a>
<a name="ln222">  /* Distance table init. */</a>
<a name="ln223">  new-&gt;distance_table = route_table_init ();</a>
<a name="ln224"> </a>
<a name="ln225">  new-&gt;lsa_refresh_queue.index = 0;</a>
<a name="ln226">  new-&gt;lsa_refresh_interval = OSPF_LSA_REFRESH_INTERVAL_DEFAULT;</a>
<a name="ln227">  new-&gt;t_lsa_refresher = thread_add_timer (master, ospf_lsa_refresh_walker,</a>
<a name="ln228">					   new, new-&gt;lsa_refresh_interval);</a>
<a name="ln229">  new-&gt;lsa_refresher_started = quagga_time (NULL);</a>
<a name="ln230"> </a>
<a name="ln231">  if ((new-&gt;fd = ospf_sock_init()) &lt; 0)</a>
<a name="ln232">    {</a>
<a name="ln233">      zlog_err(&quot;ospf_new: fatal error: ospf_sock_init was unable to open &quot;</a>
<a name="ln234">	       &quot;a socket&quot;);</a>
<a name="ln235">      exit(1);</a>
<a name="ln236">    }</a>
<a name="ln237">  new-&gt;maxsndbuflen = getsockopt_so_sendbuf (new-&gt;fd);</a>
<a name="ln238">  if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln239">    zlog_debug (&quot;%s: starting with OSPF send buffer size %u&quot;,</a>
<a name="ln240">      __func__, new-&gt;maxsndbuflen);</a>
<a name="ln241">  if ((new-&gt;ibuf = stream_new(OSPF_MAX_PACKET_SIZE+1)) == NULL)</a>
<a name="ln242">    {</a>
<a name="ln243">      zlog_err(&quot;ospf_new: fatal error: stream_new(%u) failed allocating ibuf&quot;,</a>
<a name="ln244">	       OSPF_MAX_PACKET_SIZE+1);</a>
<a name="ln245">      exit(1);</a>
<a name="ln246">    }</a>
<a name="ln247">  new-&gt;t_read = thread_add_read (master, ospf_read, new, new-&gt;fd);</a>
<a name="ln248">  new-&gt;oi_write_q = list_new ();</a>
<a name="ln249">  </a>
<a name="ln250">  return new;</a>
<a name="ln251">}</a>
<a name="ln252"> </a>
<a name="ln253">struct ospf *</a>
<a name="ln254">ospf_lookup ()</a>
<a name="ln255">{</a>
<a name="ln256">  if (listcount (om-&gt;ospf) == 0)</a>
<a name="ln257">    return NULL;</a>
<a name="ln258"> </a>
<a name="ln259">  return listgetdata ((struct listnode *)listhead (om-&gt;ospf));</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">static int</a>
<a name="ln263">ospf_is_ready (struct ospf *ospf)</a>
<a name="ln264">{</a>
<a name="ln265">  /* OSPF must be on and Router-ID must be configured. */</a>
<a name="ln266">  if (!ospf || ospf-&gt;router_id.s_addr == 0)</a>
<a name="ln267">    return 0;</a>
<a name="ln268">  </a>
<a name="ln269">  return 1;</a>
<a name="ln270">}</a>
<a name="ln271"> </a>
<a name="ln272">static void</a>
<a name="ln273">ospf_add (struct ospf *ospf)</a>
<a name="ln274">{</a>
<a name="ln275">  listnode_add (om-&gt;ospf, ospf);</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">static void</a>
<a name="ln279">ospf_delete (struct ospf *ospf)</a>
<a name="ln280">{</a>
<a name="ln281">  listnode_delete (om-&gt;ospf, ospf);</a>
<a name="ln282">}</a>
<a name="ln283"> </a>
<a name="ln284">struct ospf *</a>
<a name="ln285">ospf_get ()</a>
<a name="ln286">{</a>
<a name="ln287">  struct ospf *ospf;</a>
<a name="ln288"> </a>
<a name="ln289">  ospf = ospf_lookup ();</a>
<a name="ln290">  if (ospf == NULL)</a>
<a name="ln291">    {</a>
<a name="ln292">      ospf = ospf_new ();</a>
<a name="ln293">      ospf_add (ospf);</a>
<a name="ln294"> </a>
<a name="ln295">      if (ospf-&gt;router_id_static.s_addr == 0)</a>
<a name="ln296">	ospf_router_id_update (ospf);</a>
<a name="ln297"> </a>
<a name="ln298">      ospf_opaque_type11_lsa_init (ospf);</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">  return ospf;</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">/* Handle the second half of deferred shutdown. This is called either</a>
<a name="ln305"> * from the deferred-shutdown timer thread, or directly through</a>
<a name="ln306"> * ospf_deferred_shutdown_check.</a>
<a name="ln307"> *</a>
<a name="ln308"> * Function is to cleanup G-R state, if required then call ospf_finish_final</a>
<a name="ln309"> * to complete shutdown of this ospf instance. Possibly exit if the</a>
<a name="ln310"> * whole process is being shutdown and this was the last OSPF instance.</a>
<a name="ln311"> */</a>
<a name="ln312">static void</a>
<a name="ln313">ospf_deferred_shutdown_finish (struct ospf *ospf)</a>
<a name="ln314">{</a>
<a name="ln315">  ospf-&gt;stub_router_shutdown_time = OSPF_STUB_ROUTER_UNCONFIGURED;  </a>
<a name="ln316">  OSPF_TIMER_OFF (ospf-&gt;t_deferred_shutdown);</a>
<a name="ln317">  </a>
<a name="ln318">  ospf_finish_final (ospf);</a>
<a name="ln319">  </a>
<a name="ln320">  /* *ospf is now invalid */</a>
<a name="ln321">  </a>
<a name="ln322">  /* ospfd being shut-down? If so, was this the last ospf instance? */</a>
<a name="ln323">  if (CHECK_FLAG (om-&gt;options, OSPF_MASTER_SHUTDOWN)</a>
<a name="ln324">      &amp;&amp; (listcount (om-&gt;ospf) == 0))</a>
<a name="ln325">    exit (0);</a>
<a name="ln326"> </a>
<a name="ln327">  return;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">/* Timer thread for G-R */</a>
<a name="ln331">static int</a>
<a name="ln332">ospf_deferred_shutdown_timer (struct thread *t)</a>
<a name="ln333">{</a>
<a name="ln334">  struct ospf *ospf = THREAD_ARG(t);</a>
<a name="ln335">  </a>
<a name="ln336">  ospf_deferred_shutdown_finish (ospf);</a>
<a name="ln337">  </a>
<a name="ln338">  return 0;</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">/* Check whether deferred-shutdown must be scheduled, otherwise call</a>
<a name="ln342"> * down directly into second-half of instance shutdown.</a>
<a name="ln343"> */</a>
<a name="ln344">static void</a>
<a name="ln345">ospf_deferred_shutdown_check (struct ospf *ospf)</a>
<a name="ln346">{</a>
<a name="ln347">  unsigned long timeout;</a>
<a name="ln348">  struct listnode *ln;</a>
<a name="ln349">  struct ospf_area *area;</a>
<a name="ln350">  </a>
<a name="ln351">  /* deferred shutdown already running? */</a>
<a name="ln352">  if (ospf-&gt;t_deferred_shutdown)</a>
<a name="ln353">    return;</a>
<a name="ln354">  </a>
<a name="ln355">  /* Should we try push out max-metric LSAs? */</a>
<a name="ln356">  if (ospf-&gt;stub_router_shutdown_time != OSPF_STUB_ROUTER_UNCONFIGURED)</a>
<a name="ln357">    {</a>
<a name="ln358">      for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, ln, area))</a>
<a name="ln359">        {</a>
<a name="ln360">          SET_FLAG (area-&gt;stub_router_state, OSPF_AREA_ADMIN_STUB_ROUTED);</a>
<a name="ln361">          </a>
<a name="ln362">          if (!CHECK_FLAG (area-&gt;stub_router_state, OSPF_AREA_IS_STUB_ROUTED))</a>
<a name="ln363">            ospf_router_lsa_update_area (area);</a>
<a name="ln364">        }</a>
<a name="ln365">      timeout = ospf-&gt;stub_router_shutdown_time;</a>
<a name="ln366">    }</a>
<a name="ln367">  else</a>
<a name="ln368">    {</a>
<a name="ln369">      /* No timer needed */</a>
<a name="ln370">      ospf_deferred_shutdown_finish (ospf);</a>
<a name="ln371">      return;</a>
<a name="ln372">    }</a>
<a name="ln373">  </a>
<a name="ln374">  OSPF_TIMER_ON (ospf-&gt;t_deferred_shutdown, ospf_deferred_shutdown_timer,</a>
<a name="ln375">                 timeout);</a>
<a name="ln376">  return;</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">/* Shut down the entire process */</a>
<a name="ln380">void</a>
<a name="ln381">ospf_terminate (void)</a>
<a name="ln382">{</a>
<a name="ln383">  struct ospf *ospf;</a>
<a name="ln384">  struct listnode *node, *nnode;</a>
<a name="ln385">  </a>
<a name="ln386">  /* shutdown already in progress */</a>
<a name="ln387">  if (CHECK_FLAG (om-&gt;options, OSPF_MASTER_SHUTDOWN))</a>
<a name="ln388">    return;</a>
<a name="ln389">  </a>
<a name="ln390">  SET_FLAG (om-&gt;options, OSPF_MASTER_SHUTDOWN);</a>
<a name="ln391"> </a>
<a name="ln392">  /* exit immediately if OSPF not actually running */</a>
<a name="ln393">  if (listcount(om-&gt;ospf) == 0)</a>
<a name="ln394">    exit(0);</a>
<a name="ln395"> </a>
<a name="ln396">  for (ALL_LIST_ELEMENTS (om-&gt;ospf, node, nnode, ospf))</a>
<a name="ln397">    ospf_finish (ospf);</a>
<a name="ln398"> </a>
<a name="ln399">  /* Deliberately go back up, hopefully to thread scheduler, as</a>
<a name="ln400">   * One or more ospf_finish()'s may have deferred shutdown to a timer</a>
<a name="ln401">   * thread</a>
<a name="ln402">   */</a>
<a name="ln403">}</a>
<a name="ln404"> </a>
<a name="ln405">void</a>
<a name="ln406">ospf_finish (struct ospf *ospf)</a>
<a name="ln407">{</a>
<a name="ln408">  /* let deferred shutdown decide */</a>
<a name="ln409">  ospf_deferred_shutdown_check (ospf);</a>
<a name="ln410">      </a>
<a name="ln411">  /* if ospf_deferred_shutdown returns, then ospf_finish_final is</a>
<a name="ln412">   * deferred to expiry of G-S timer thread. Return back up, hopefully</a>
<a name="ln413">   * to thread scheduler.</a>
<a name="ln414">   */</a>
<a name="ln415">  return;</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">/* Final cleanup of ospf instance */</a>
<a name="ln419">static void</a>
<a name="ln420">ospf_finish_final (struct ospf *ospf)</a>
<a name="ln421">{</a>
<a name="ln422">  struct route_node *rn;</a>
<a name="ln423">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln424">  struct ospf_lsa *lsa;</a>
<a name="ln425">  struct ospf_interface *oi;</a>
<a name="ln426">  struct ospf_area *area;</a>
<a name="ln427">  struct ospf_vl_data *vl_data;</a>
<a name="ln428">  struct listnode *node, *nnode;</a>
<a name="ln429">  int i;</a>
<a name="ln430"> </a>
<a name="ln431">  ospf_opaque_type11_lsa_term (ospf);</a>
<a name="ln432">  </a>
<a name="ln433">  /* be nice if this worked, but it doesn't */</a>
<a name="ln434">  /*ospf_flush_self_originated_lsas_now (ospf);*/</a>
<a name="ln435">  </a>
<a name="ln436">  /* Unregister redistribution */</a>
<a name="ln437">  for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln438">    ospf_redistribute_unset (ospf, i);</a>
<a name="ln439">  ospf_redistribute_default_unset (ospf);</a>
<a name="ln440"> </a>
<a name="ln441">  for (ALL_LIST_ELEMENTS (ospf-&gt;areas, node, nnode, area))</a>
<a name="ln442">    ospf_remove_vls_through_area (ospf, area);</a>
<a name="ln443">  </a>
<a name="ln444">  for (ALL_LIST_ELEMENTS (ospf-&gt;vlinks, node, nnode, vl_data))</a>
<a name="ln445">    ospf_vl_delete (ospf, vl_data);</a>
<a name="ln446">  </a>
<a name="ln447">  list_delete (ospf-&gt;vlinks);</a>
<a name="ln448"> </a>
<a name="ln449">  /* Reset interface. */</a>
<a name="ln450">  for (ALL_LIST_ELEMENTS (ospf-&gt;oiflist, node, nnode, oi))</a>
<a name="ln451">    ospf_if_free (oi);</a>
<a name="ln452"> </a>
<a name="ln453">  /* Clear static neighbors */</a>
<a name="ln454">  for (rn = route_top (ospf-&gt;nbr_nbma); rn; rn = route_next (rn))</a>
<a name="ln455">    if ((nbr_nbma = rn-&gt;info))</a>
<a name="ln456">      {</a>
<a name="ln457">	OSPF_POLL_TIMER_OFF (nbr_nbma-&gt;t_poll);</a>
<a name="ln458"> </a>
<a name="ln459">	if (nbr_nbma-&gt;nbr)</a>
<a name="ln460">	  {</a>
<a name="ln461">	    nbr_nbma-&gt;nbr-&gt;nbr_nbma = NULL;</a>
<a name="ln462">	    nbr_nbma-&gt;nbr = NULL;</a>
<a name="ln463">	  }</a>
<a name="ln464"> </a>
<a name="ln465">	if (nbr_nbma-&gt;oi)</a>
<a name="ln466">	  {</a>
<a name="ln467">	    listnode_delete (nbr_nbma-&gt;oi-&gt;nbr_nbma, nbr_nbma);</a>
<a name="ln468">	    nbr_nbma-&gt;oi = NULL;</a>
<a name="ln469">	  }</a>
<a name="ln470"> </a>
<a name="ln471">	XFREE (MTYPE_OSPF_NEIGHBOR_STATIC, nbr_nbma);</a>
<a name="ln472">      }</a>
<a name="ln473"> </a>
<a name="ln474">  route_table_finish (ospf-&gt;nbr_nbma);</a>
<a name="ln475"> </a>
<a name="ln476">  /* Clear networks and Areas. */</a>
<a name="ln477">  for (rn = route_top (ospf-&gt;networks); rn; rn = route_next (rn))</a>
<a name="ln478">    {</a>
<a name="ln479">      struct ospf_network *network;</a>
<a name="ln480"> </a>
<a name="ln481">      if ((network = rn-&gt;info) != NULL)</a>
<a name="ln482">	{</a>
<a name="ln483">	  ospf_network_free (ospf, network);</a>
<a name="ln484">	  rn-&gt;info = NULL;</a>
<a name="ln485">	  route_unlock_node (rn);</a>
<a name="ln486">	}</a>
<a name="ln487">    }</a>
<a name="ln488"> </a>
<a name="ln489">  for (ALL_LIST_ELEMENTS (ospf-&gt;areas, node, nnode, area))</a>
<a name="ln490">    {</a>
<a name="ln491">      listnode_delete (ospf-&gt;areas, area);</a>
<a name="ln492">      ospf_area_free (area);</a>
<a name="ln493">    }</a>
<a name="ln494"> </a>
<a name="ln495">  /* Cancel all timers. */</a>
<a name="ln496">  OSPF_TIMER_OFF (ospf-&gt;t_external_lsa);</a>
<a name="ln497">  OSPF_TIMER_OFF (ospf-&gt;t_spf_calc);</a>
<a name="ln498">  OSPF_TIMER_OFF (ospf-&gt;t_ase_calc);</a>
<a name="ln499">  OSPF_TIMER_OFF (ospf-&gt;t_maxage);</a>
<a name="ln500">  OSPF_TIMER_OFF (ospf-&gt;t_maxage_walker);</a>
<a name="ln501">  OSPF_TIMER_OFF (ospf-&gt;t_abr_task);</a>
<a name="ln502">  OSPF_TIMER_OFF (ospf-&gt;t_asbr_check);</a>
<a name="ln503">  OSPF_TIMER_OFF (ospf-&gt;t_distribute_update);</a>
<a name="ln504">  OSPF_TIMER_OFF (ospf-&gt;t_lsa_refresher);</a>
<a name="ln505">  OSPF_TIMER_OFF (ospf-&gt;t_read);</a>
<a name="ln506">  OSPF_TIMER_OFF (ospf-&gt;t_write);</a>
<a name="ln507">  OSPF_TIMER_OFF (ospf-&gt;t_opaque_lsa_self);</a>
<a name="ln508"> </a>
<a name="ln509">  close (ospf-&gt;fd);</a>
<a name="ln510">  stream_free(ospf-&gt;ibuf);</a>
<a name="ln511">   </a>
<a name="ln512">  LSDB_LOOP (OPAQUE_AS_LSDB (ospf), rn, lsa)</a>
<a name="ln513">    ospf_discard_from_db (ospf, ospf-&gt;lsdb, lsa);</a>
<a name="ln514">  LSDB_LOOP (EXTERNAL_LSDB (ospf), rn, lsa)</a>
<a name="ln515">    ospf_discard_from_db (ospf, ospf-&gt;lsdb, lsa);</a>
<a name="ln516"> </a>
<a name="ln517">  ospf_lsdb_delete_all (ospf-&gt;lsdb);</a>
<a name="ln518">  ospf_lsdb_free (ospf-&gt;lsdb);</a>
<a name="ln519"> </a>
<a name="ln520">  for (rn = route_top (ospf-&gt;maxage_lsa); rn; rn = route_next (rn))</a>
<a name="ln521">    {</a>
<a name="ln522">      struct ospf_lsa *lsa;</a>
<a name="ln523"> </a>
<a name="ln524">      if ((lsa = rn-&gt;info) != NULL)</a>
<a name="ln525">	{</a>
<a name="ln526">	  ospf_lsa_unlock (&amp;lsa);</a>
<a name="ln527">	  rn-&gt;info = NULL;</a>
<a name="ln528">	}</a>
<a name="ln529">      route_unlock_node (rn);</a>
<a name="ln530">    }</a>
<a name="ln531">  route_table_finish (ospf-&gt;maxage_lsa);</a>
<a name="ln532"> </a>
<a name="ln533">  if (ospf-&gt;old_table)</a>
<a name="ln534">    ospf_route_table_free (ospf-&gt;old_table);</a>
<a name="ln535">  if (ospf-&gt;new_table)</a>
<a name="ln536">    {</a>
<a name="ln537">      ospf_route_delete (ospf-&gt;new_table);</a>
<a name="ln538">      ospf_route_table_free (ospf-&gt;new_table);</a>
<a name="ln539">    }</a>
<a name="ln540">  if (ospf-&gt;old_rtrs)</a>
<a name="ln541">    ospf_rtrs_free (ospf-&gt;old_rtrs);</a>
<a name="ln542">  if (ospf-&gt;new_rtrs)</a>
<a name="ln543">    ospf_rtrs_free (ospf-&gt;new_rtrs);</a>
<a name="ln544">  if (ospf-&gt;new_external_route)</a>
<a name="ln545">    {</a>
<a name="ln546">      ospf_route_delete (ospf-&gt;new_external_route);</a>
<a name="ln547">      ospf_route_table_free (ospf-&gt;new_external_route);</a>
<a name="ln548">    }</a>
<a name="ln549">  if (ospf-&gt;old_external_route)</a>
<a name="ln550">    {</a>
<a name="ln551">      ospf_route_delete (ospf-&gt;old_external_route);</a>
<a name="ln552">      ospf_route_table_free (ospf-&gt;old_external_route);</a>
<a name="ln553">    }</a>
<a name="ln554">  if (ospf-&gt;external_lsas)</a>
<a name="ln555">    {</a>
<a name="ln556">      ospf_ase_external_lsas_finish (ospf-&gt;external_lsas);</a>
<a name="ln557">    }</a>
<a name="ln558"> </a>
<a name="ln559">  list_delete (ospf-&gt;areas);</a>
<a name="ln560">  </a>
<a name="ln561">  for (i = ZEBRA_ROUTE_SYSTEM; i &lt;= ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln562">    if (EXTERNAL_INFO (i) != NULL)</a>
<a name="ln563">      for (rn = route_top (EXTERNAL_INFO (i)); rn; rn = route_next (rn))</a>
<a name="ln564">	{</a>
<a name="ln565">	  if (rn-&gt;info == NULL)</a>
<a name="ln566">	    continue;</a>
<a name="ln567">	  </a>
<a name="ln568">	  XFREE (MTYPE_OSPF_EXTERNAL_INFO, rn-&gt;info);</a>
<a name="ln569">	  rn-&gt;info = NULL;</a>
<a name="ln570">	  route_unlock_node (rn);</a>
<a name="ln571">	}</a>
<a name="ln572"> </a>
<a name="ln573">  ospf_distance_reset (ospf);</a>
<a name="ln574">  route_table_finish (ospf-&gt;distance_table);</a>
<a name="ln575"> </a>
<a name="ln576">  ospf_delete (ospf);</a>
<a name="ln577"> </a>
<a name="ln578">  XFREE (MTYPE_OSPF_TOP, ospf);</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">/* allocate new OSPF Area object */</a>
<a name="ln583">static struct ospf_area *</a>
<a name="ln584">ospf_area_new (struct ospf *ospf, struct in_addr area_id)</a>
<a name="ln585">{</a>
<a name="ln586">  struct ospf_area *new;</a>
<a name="ln587"> </a>
<a name="ln588">  /* Allocate new config_network. */</a>
<a name="ln589">  new = XCALLOC (MTYPE_OSPF_AREA, sizeof (struct ospf_area));</a>
<a name="ln590"> </a>
<a name="ln591">  new-&gt;ospf = ospf;</a>
<a name="ln592"> </a>
<a name="ln593">  new-&gt;area_id = area_id;</a>
<a name="ln594"> </a>
<a name="ln595">  new-&gt;external_routing = OSPF_AREA_DEFAULT;</a>
<a name="ln596">  new-&gt;default_cost = 1;</a>
<a name="ln597">  new-&gt;auth_type = OSPF_AUTH_NULL;</a>
<a name="ln598">  </a>
<a name="ln599">  /* New LSDB init. */</a>
<a name="ln600">  new-&gt;lsdb = ospf_lsdb_new ();</a>
<a name="ln601"> </a>
<a name="ln602">  /* Self-originated LSAs initialize. */</a>
<a name="ln603">  new-&gt;router_lsa_self = NULL;</a>
<a name="ln604"> </a>
<a name="ln605">  ospf_opaque_type10_lsa_init (new);</a>
<a name="ln606"> </a>
<a name="ln607">  new-&gt;oiflist = list_new ();</a>
<a name="ln608">  new-&gt;ranges = route_table_init ();</a>
<a name="ln609"> </a>
<a name="ln610">  if (area_id.s_addr == OSPF_AREA_BACKBONE)</a>
<a name="ln611">    ospf-&gt;backbone = new;</a>
<a name="ln612"> </a>
<a name="ln613">  return new;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">static void</a>
<a name="ln617">ospf_area_free (struct ospf_area *area)</a>
<a name="ln618">{</a>
<a name="ln619">  struct route_node *rn;</a>
<a name="ln620">  struct ospf_lsa *lsa;</a>
<a name="ln621"> </a>
<a name="ln622">  /* Free LSDBs. */</a>
<a name="ln623">  LSDB_LOOP (ROUTER_LSDB (area), rn, lsa)</a>
<a name="ln624">    ospf_discard_from_db (area-&gt;ospf, area-&gt;lsdb, lsa);</a>
<a name="ln625">  LSDB_LOOP (NETWORK_LSDB (area), rn, lsa)</a>
<a name="ln626">    ospf_discard_from_db (area-&gt;ospf, area-&gt;lsdb, lsa);</a>
<a name="ln627">  LSDB_LOOP (SUMMARY_LSDB (area), rn, lsa)</a>
<a name="ln628">    ospf_discard_from_db (area-&gt;ospf, area-&gt;lsdb, lsa);</a>
<a name="ln629">  LSDB_LOOP (ASBR_SUMMARY_LSDB (area), rn, lsa)</a>
<a name="ln630">    ospf_discard_from_db (area-&gt;ospf, area-&gt;lsdb, lsa);</a>
<a name="ln631"> </a>
<a name="ln632">  LSDB_LOOP (NSSA_LSDB (area), rn, lsa)</a>
<a name="ln633">    ospf_discard_from_db (area-&gt;ospf, area-&gt;lsdb, lsa);</a>
<a name="ln634">  LSDB_LOOP (OPAQUE_AREA_LSDB (area), rn, lsa)</a>
<a name="ln635">    ospf_discard_from_db (area-&gt;ospf, area-&gt;lsdb, lsa);</a>
<a name="ln636">  LSDB_LOOP (OPAQUE_LINK_LSDB (area), rn, lsa)</a>
<a name="ln637">    ospf_discard_from_db (area-&gt;ospf, area-&gt;lsdb, lsa);</a>
<a name="ln638"> </a>
<a name="ln639">  ospf_lsdb_delete_all (area-&gt;lsdb);</a>
<a name="ln640">  ospf_lsdb_free (area-&gt;lsdb);</a>
<a name="ln641"> </a>
<a name="ln642">  ospf_lsa_unlock (&amp;area-&gt;router_lsa_self);</a>
<a name="ln643">  </a>
<a name="ln644">  route_table_finish (area-&gt;ranges);</a>
<a name="ln645">  list_delete (area-&gt;oiflist);</a>
<a name="ln646"> </a>
<a name="ln647">  if (EXPORT_NAME (area))</a>
<a name="ln648">    free (EXPORT_NAME (area));</a>
<a name="ln649"> </a>
<a name="ln650">  if (IMPORT_NAME (area))</a>
<a name="ln651">    free (IMPORT_NAME (area));</a>
<a name="ln652"> </a>
<a name="ln653">  /* Cancel timer. */</a>
<a name="ln654">  OSPF_TIMER_OFF (area-&gt;t_stub_router);</a>
<a name="ln655">  OSPF_TIMER_OFF (area-&gt;t_opaque_lsa_self);</a>
<a name="ln656">  </a>
<a name="ln657">  if (OSPF_IS_AREA_BACKBONE (area))</a>
<a name="ln658">    area-&gt;ospf-&gt;backbone = NULL;</a>
<a name="ln659"> </a>
<a name="ln660">  XFREE (MTYPE_OSPF_AREA, area);</a>
<a name="ln661">}</a>
<a name="ln662"> </a>
<a name="ln663">void</a>
<a name="ln664">ospf_area_check_free (struct ospf *ospf, struct in_addr area_id)</a>
<a name="ln665">{</a>
<a name="ln666">  struct ospf_area *area;</a>
<a name="ln667"> </a>
<a name="ln668">  area = ospf_area_lookup_by_area_id (ospf, area_id);</a>
<a name="ln669">  if (area &amp;&amp;</a>
<a name="ln670">      listcount (area-&gt;oiflist) == 0 &amp;&amp;</a>
<a name="ln671">      area-&gt;ranges-&gt;top == NULL &amp;&amp;</a>
<a name="ln672">      area-&gt;shortcut_configured == OSPF_SHORTCUT_DEFAULT &amp;&amp;</a>
<a name="ln673">      area-&gt;external_routing == OSPF_AREA_DEFAULT &amp;&amp;</a>
<a name="ln674">      area-&gt;no_summary == 0 &amp;&amp;</a>
<a name="ln675">      area-&gt;default_cost == 1 &amp;&amp;</a>
<a name="ln676">      EXPORT_NAME (area) == NULL &amp;&amp;</a>
<a name="ln677">      IMPORT_NAME (area) == NULL &amp;&amp;</a>
<a name="ln678">      area-&gt;auth_type == OSPF_AUTH_NULL)</a>
<a name="ln679">    {</a>
<a name="ln680">      listnode_delete (ospf-&gt;areas, area);</a>
<a name="ln681">      ospf_area_free (area);</a>
<a name="ln682">    }</a>
<a name="ln683">}</a>
<a name="ln684"> </a>
<a name="ln685">struct ospf_area *</a>
<a name="ln686">ospf_area_get (struct ospf *ospf, struct in_addr area_id, int format)</a>
<a name="ln687">{</a>
<a name="ln688">  struct ospf_area *area;</a>
<a name="ln689">  </a>
<a name="ln690">  area = ospf_area_lookup_by_area_id (ospf, area_id);</a>
<a name="ln691">  if (!area)</a>
<a name="ln692">    {</a>
<a name="ln693">      area = ospf_area_new (ospf, area_id);</a>
<a name="ln694">      area-&gt;format = format;</a>
<a name="ln695">      listnode_add_sort (ospf-&gt;areas, area);</a>
<a name="ln696">      ospf_check_abr_status (ospf);  </a>
<a name="ln697">      if (ospf-&gt;stub_router_admin_set == OSPF_STUB_ROUTER_ADMINISTRATIVE_SET)</a>
<a name="ln698">        {</a>
<a name="ln699">          SET_FLAG (area-&gt;stub_router_state, OSPF_AREA_ADMIN_STUB_ROUTED);</a>
<a name="ln700">        }</a>
<a name="ln701">    }</a>
<a name="ln702"> </a>
<a name="ln703">  return area;</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">struct ospf_area *</a>
<a name="ln707">ospf_area_lookup_by_area_id (struct ospf *ospf, struct in_addr area_id)</a>
<a name="ln708">{</a>
<a name="ln709">  struct ospf_area *area;</a>
<a name="ln710">  struct listnode *node;</a>
<a name="ln711"> </a>
<a name="ln712">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln713">    if (IPV4_ADDR_SAME (&amp;area-&gt;area_id, &amp;area_id))</a>
<a name="ln714">      return area;</a>
<a name="ln715"> </a>
<a name="ln716">  return NULL;</a>
<a name="ln717">}</a>
<a name="ln718"> </a>
<a name="ln719">void</a>
<a name="ln720">ospf_area_add_if (struct ospf_area *area, struct ospf_interface *oi)</a>
<a name="ln721">{</a>
<a name="ln722">  listnode_add (area-&gt;oiflist, oi);</a>
<a name="ln723">}</a>
<a name="ln724"> </a>
<a name="ln725">void</a>
<a name="ln726">ospf_area_del_if (struct ospf_area *area, struct ospf_interface *oi)</a>
<a name="ln727">{</a>
<a name="ln728">  listnode_delete (area-&gt;oiflist, oi);</a>
<a name="ln729">}</a>
<a name="ln730"> </a>
<a name="ln731"> </a>
<a name="ln732">/* Config network statement related functions. */</a>
<a name="ln733">static struct ospf_network *</a>
<a name="ln734">ospf_network_new (struct in_addr area_id, int format)</a>
<a name="ln735">{</a>
<a name="ln736">  struct ospf_network *new;</a>
<a name="ln737">  new = XCALLOC (MTYPE_OSPF_NETWORK, sizeof (struct ospf_network));</a>
<a name="ln738"> </a>
<a name="ln739">  new-&gt;area_id = area_id;</a>
<a name="ln740">  new-&gt;format = format;</a>
<a name="ln741">  </a>
<a name="ln742">  return new;</a>
<a name="ln743">}</a>
<a name="ln744"> </a>
<a name="ln745">static void </a>
<a name="ln746">add_ospf_interface (struct connected *co, struct ospf_area *area)</a>
<a name="ln747">{</a>
<a name="ln748">  struct ospf_interface *oi;</a>
<a name="ln749"> </a>
<a name="ln750">  oi = ospf_if_new (area-&gt;ospf, co-&gt;ifp, co-&gt;address);</a>
<a name="ln751">  oi-&gt;connected = co;</a>
<a name="ln752"> </a>
<a name="ln753">  oi-&gt;area = area;</a>
<a name="ln754"> </a>
<a name="ln755">  oi-&gt;params = ospf_lookup_if_params (co-&gt;ifp, oi-&gt;address-&gt;u.prefix4);</a>
<a name="ln756">  oi-&gt;output_cost = ospf_if_get_output_cost (oi);</a>
<a name="ln757"> </a>
<a name="ln758">  /* Relate ospf interface to ospf instance. */</a>
<a name="ln759">  oi-&gt;ospf = area-&gt;ospf;</a>
<a name="ln760"> </a>
<a name="ln761">  /* update network type as interface flag */</a>
<a name="ln762">  /* If network type is specified previously,</a>
<a name="ln763">     skip network type setting. */</a>
<a name="ln764">  oi-&gt;type = IF_DEF_PARAMS (co-&gt;ifp)-&gt;type;</a>
<a name="ln765"> </a>
<a name="ln766">  /* Add pseudo neighbor. */</a>
<a name="ln767">  ospf_nbr_self_reset (oi);</a>
<a name="ln768"> </a>
<a name="ln769">  ospf_area_add_if (oi-&gt;area, oi);</a>
<a name="ln770"> </a>
<a name="ln771">  /* if router_id is not configured, dont bring up</a>
<a name="ln772">   * interfaces.</a>
<a name="ln773">   * ospf_router_id_update() will call ospf_if_update</a>
<a name="ln774">   * whenever r-id is configured instead.</a>
<a name="ln775">   */</a>
<a name="ln776">  if ((area-&gt;ospf-&gt;router_id.s_addr != 0)</a>
<a name="ln777">      &amp;&amp; if_is_operative (co-&gt;ifp)) </a>
<a name="ln778">    ospf_if_up (oi);</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">static void</a>
<a name="ln782">update_redistributed (struct ospf *ospf, int add_to_ospf)</a>
<a name="ln783">{</a>
<a name="ln784">  struct route_node *rn;</a>
<a name="ln785">  struct external_info *ei;</a>
<a name="ln786"> </a>
<a name="ln787">  if (ospf_is_type_redistributed (ZEBRA_ROUTE_CONNECT))</a>
<a name="ln788">    if (EXTERNAL_INFO (ZEBRA_ROUTE_CONNECT))</a>
<a name="ln789">      for (rn = route_top (EXTERNAL_INFO (ZEBRA_ROUTE_CONNECT));</a>
<a name="ln790">	   rn; rn = route_next (rn))</a>
<a name="ln791">	if ((ei = rn-&gt;info) != NULL)</a>
<a name="ln792">	  {</a>
<a name="ln793">            if (add_to_ospf)</a>
<a name="ln794">              {</a>
<a name="ln795">                if (ospf_external_info_find_lsa (ospf, &amp;ei-&gt;p))</a>
<a name="ln796">                  if (!ospf_distribute_check_connected (ospf, ei))</a>
<a name="ln797">                    ospf_external_lsa_flush (ospf, ei-&gt;type, &amp;ei-&gt;p,</a>
<a name="ln798">                                              ei-&gt;ifindex /*, ei-&gt;nexthop */);</a>
<a name="ln799">              }</a>
<a name="ln800">            else</a>
<a name="ln801">              {</a>
<a name="ln802">                if (!ospf_external_info_find_lsa (ospf, &amp;ei-&gt;p))</a>
<a name="ln803">                  if (ospf_distribute_check_connected (ospf, ei))</a>
<a name="ln804">                    ospf_external_lsa_originate (ospf, ei);</a>
<a name="ln805">              }</a>
<a name="ln806">          }</a>
<a name="ln807">}</a>
<a name="ln808"> </a>
<a name="ln809">static void</a>
<a name="ln810">ospf_network_free (struct ospf *ospf, struct ospf_network *network)</a>
<a name="ln811">{</a>
<a name="ln812">  ospf_area_check_free (ospf, network-&gt;area_id);</a>
<a name="ln813">  ospf_schedule_abr_task (ospf);</a>
<a name="ln814">  XFREE (MTYPE_OSPF_NETWORK, network);</a>
<a name="ln815">}</a>
<a name="ln816"> </a>
<a name="ln817">int</a>
<a name="ln818">ospf_network_set (struct ospf *ospf, struct prefix_ipv4 *p,</a>
<a name="ln819">		  struct in_addr area_id)</a>
<a name="ln820">{</a>
<a name="ln821">  struct ospf_network *network;</a>
<a name="ln822">  struct ospf_area *area;</a>
<a name="ln823">  struct route_node *rn;</a>
<a name="ln824">  int ret = OSPF_AREA_ID_FORMAT_ADDRESS;</a>
<a name="ln825"> </a>
<a name="ln826">  rn = route_node_get (ospf-&gt;networks, (struct prefix *)p);</a>
<a name="ln827">  if (rn-&gt;info)</a>
<a name="ln828">    {</a>
<a name="ln829">      /* There is already same network statement. */</a>
<a name="ln830">      route_unlock_node (rn);</a>
<a name="ln831">      return 0;</a>
<a name="ln832">    }</a>
<a name="ln833"> </a>
<a name="ln834">  rn-&gt;info = network = ospf_network_new (area_id, ret);</a>
<a name="ln835">  area = ospf_area_get (ospf, area_id, ret);</a>
<a name="ln836"> </a>
<a name="ln837">  /* Run network config now. */</a>
<a name="ln838">  ospf_network_run ((struct prefix *)p, area);</a>
<a name="ln839"> </a>
<a name="ln840">  /* Update connected redistribute. */</a>
<a name="ln841">  update_redistributed(ospf, 1);</a>
<a name="ln842">  </a>
<a name="ln843">  ospf_area_check_free (ospf, area_id);</a>
<a name="ln844"> </a>
<a name="ln845">  return 1;</a>
<a name="ln846">}</a>
<a name="ln847"> </a>
<a name="ln848">int</a>
<a name="ln849">ospf_network_unset (struct ospf *ospf, struct prefix_ipv4 *p,</a>
<a name="ln850">		    struct in_addr area_id)</a>
<a name="ln851">{</a>
<a name="ln852">  struct route_node *rn;</a>
<a name="ln853">  struct ospf_network *network;</a>
<a name="ln854">  struct listnode *node, *nnode;</a>
<a name="ln855">  struct ospf_interface *oi;</a>
<a name="ln856"> </a>
<a name="ln857">  rn = route_node_lookup (ospf-&gt;networks, (struct prefix *)p);</a>
<a name="ln858">  if (rn == NULL)</a>
<a name="ln859">    return 0;</a>
<a name="ln860"> </a>
<a name="ln861">  network = rn-&gt;info;</a>
<a name="ln862">  route_unlock_node (rn);</a>
<a name="ln863">  if (!IPV4_ADDR_SAME (&amp;area_id, &amp;network-&gt;area_id))</a>
<a name="ln864">    return 0;</a>
<a name="ln865"> </a>
<a name="ln866">  ospf_network_free (ospf, rn-&gt;info);</a>
<a name="ln867">  rn-&gt;info = NULL;</a>
<a name="ln868">  route_unlock_node (rn);	/* initial reference */</a>
<a name="ln869"> </a>
<a name="ln870">  /* Find interfaces that not configured already.  */</a>
<a name="ln871">  for (ALL_LIST_ELEMENTS (ospf-&gt;oiflist, node, nnode, oi))</a>
<a name="ln872">    {</a>
<a name="ln873">      if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln874">        continue;</a>
<a name="ln875">      </a>
<a name="ln876">      ospf_network_run_subnet (ospf, oi-&gt;connected, NULL, NULL);</a>
<a name="ln877">    }</a>
<a name="ln878">  </a>
<a name="ln879">  /* Update connected redistribute. */</a>
<a name="ln880">  update_redistributed(ospf, 0);</a>
<a name="ln881">  </a>
<a name="ln882">  ospf_area_check_free (ospf, area_id);</a>
<a name="ln883">  </a>
<a name="ln884">  return 1;</a>
<a name="ln885">}</a>
<a name="ln886"> </a>
<a name="ln887">/* Ensure there's an OSPF instance, as &quot;ip ospf area&quot; enabled OSPF means</a>
<a name="ln888"> * there might not be any 'router ospf' config.</a>
<a name="ln889"> *</a>
<a name="ln890"> * Otherwise, doesn't do anything different to ospf_if_update for now</a>
<a name="ln891"> */</a>
<a name="ln892">void</a>
<a name="ln893">ospf_interface_area_set (struct interface *ifp)</a>
<a name="ln894">{</a>
<a name="ln895">  struct ospf *ospf = ospf_get();</a>
<a name="ln896">  </a>
<a name="ln897">  ospf_if_update (ospf, ifp);</a>
<a name="ln898">  /* if_update does a update_redistributed */</a>
<a name="ln899">  </a>
<a name="ln900">  return;</a>
<a name="ln901">}</a>
<a name="ln902"> </a>
<a name="ln903">void</a>
<a name="ln904">ospf_interface_area_unset (struct interface *ifp)</a>
<a name="ln905">{</a>
<a name="ln906">  struct route_node *rn_oi;</a>
<a name="ln907">  struct ospf *ospf;</a>
<a name="ln908"> </a>
<a name="ln909">  if ((ospf = ospf_lookup ()) == NULL)</a>
<a name="ln910">    return; /* Ospf not ready yet */</a>
<a name="ln911">  </a>
<a name="ln912">  /* Find interfaces that may need to be removed. */</a>
<a name="ln913">  for (rn_oi = route_top (IF_OIFS (ifp)); rn_oi; rn_oi = route_next (rn_oi))</a>
<a name="ln914">    {</a>
<a name="ln915">      struct ospf_interface *oi;</a>
<a name="ln916"> </a>
<a name="ln917">      if ( (oi = rn_oi-&gt;info) == NULL)</a>
<a name="ln918">	continue;</a>
<a name="ln919">      </a>
<a name="ln920">      if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln921">	continue;</a>
<a name="ln922">      </a>
<a name="ln923">      ospf_network_run_subnet (ospf, oi-&gt;connected, NULL, NULL);</a>
<a name="ln924">    }</a>
<a name="ln925"> </a>
<a name="ln926">  /* Update connected redistribute. */</a>
<a name="ln927">  update_redistributed (ospf, 0); /* interfaces possibly removed */</a>
<a name="ln928">  </a>
<a name="ln929">  return;</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932"> </a>
<a name="ln933">/* Check whether interface matches given network</a>
<a name="ln934"> * returns: 1, true. 0, false</a>
<a name="ln935"> */</a>
<a name="ln936">static int</a>
<a name="ln937">ospf_network_match_iface(const struct connected *co, const struct prefix *net)</a>
<a name="ln938">{</a>
<a name="ln939">  /* new approach: more elegant and conceptually clean */</a>
<a name="ln940">  return prefix_match(net, CONNECTED_PREFIX(co));</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">static void</a>
<a name="ln944">ospf_update_interface_area (struct connected *co, struct ospf_area *area)</a>
<a name="ln945">{</a>
<a name="ln946">  struct ospf_interface *oi = ospf_if_table_lookup (co-&gt;ifp, co-&gt;address);</a>
<a name="ln947">  </a>
<a name="ln948">  /* nothing to be done case */</a>
<a name="ln949">  if (oi &amp;&amp; oi-&gt;area == area)</a>
<a name="ln950">    return;</a>
<a name="ln951">  </a>
<a name="ln952">  if (oi) </a>
<a name="ln953">    ospf_if_free (oi);</a>
<a name="ln954">  </a>
<a name="ln955">  add_ospf_interface (co, area);</a>
<a name="ln956">}</a>
<a name="ln957"> </a>
<a name="ln958">/* Run OSPF for the given subnet, taking into account the following</a>
<a name="ln959"> * possible sources of area configuration, in the given order of preference:</a>
<a name="ln960"> *</a>
<a name="ln961"> * - Whether there is interface+address specific area configuration</a>
<a name="ln962"> * - Whether there is a default area for the interface</a>
<a name="ln963"> * - Whether there is an area given as a parameter.</a>
<a name="ln964"> * - If no specific network prefix/area is supplied, whether there's</a>
<a name="ln965"> *   a matching network configured.</a>
<a name="ln966"> */</a>
<a name="ln967">static void</a>
<a name="ln968">ospf_network_run_subnet (struct ospf *ospf, struct connected *co,</a>
<a name="ln969">                         struct prefix *p, struct ospf_area *given_area)</a>
<a name="ln970">{</a>
<a name="ln971">  struct ospf_interface *oi;</a>
<a name="ln972">  struct ospf_if_params *params;</a>
<a name="ln973">  struct ospf_area *area = NULL;</a>
<a name="ln974">  struct route_node *rn;</a>
<a name="ln975">  int configed = 0;</a>
<a name="ln976">  </a>
<a name="ln977">  if (CHECK_FLAG(co-&gt;flags, ZEBRA_IFA_SECONDARY))</a>
<a name="ln978">    return;</a>
<a name="ln979">  </a>
<a name="ln980">  if (co-&gt;address-&gt;family != AF_INET)</a>
<a name="ln981">    return;</a>
<a name="ln982">  </a>
<a name="ln983">  /* Try determine the appropriate area for this interface + address</a>
<a name="ln984">   * Start by checking interface config </a>
<a name="ln985">   */   </a>
<a name="ln986">  if (!(params = ospf_lookup_if_params (co-&gt;ifp, co-&gt;address-&gt;u.prefix4)))</a>
<a name="ln987">    params = IF_DEF_PARAMS (co-&gt;ifp);</a>
<a name="ln988">  </a>
<a name="ln989">  if (OSPF_IF_PARAM_CONFIGURED(params, if_area))</a>
<a name="ln990">    area = (ospf_area_get (ospf, params-&gt;if_area,</a>
<a name="ln991">                           OSPF_AREA_ID_FORMAT_ADDRESS));</a>
<a name="ln992">  </a>
<a name="ln993">  /* If we've found an interface and/or addr specific area, then we're</a>
<a name="ln994">   * done</a>
<a name="ln995">   */</a>
<a name="ln996">  if (area)</a>
<a name="ln997">    {</a>
<a name="ln998">      ospf_update_interface_area (co, area);</a>
<a name="ln999">      return;</a>
<a name="ln1000">    }</a>
<a name="ln1001">  </a>
<a name="ln1002">  /* Otherwise, only remaining possibility is a matching network statement */</a>
<a name="ln1003">  if (p)</a>
<a name="ln1004">    {</a>
<a name="ln1005">      assert (given_area != NULL);</a>
<a name="ln1006">      </a>
<a name="ln1007">      /* Which either was supplied as a parameter.. (e.g. cause a new</a>
<a name="ln1008">       * network/area was just added)..</a>
<a name="ln1009">       */</a>
<a name="ln1010">      if (p-&gt;family == co-&gt;address-&gt;family </a>
<a name="ln1011">          &amp;&amp; ospf_network_match_iface (co, p))</a>
<a name="ln1012">        ospf_update_interface_area (co, given_area);</a>
<a name="ln1013">      </a>
<a name="ln1014">      return;</a>
<a name="ln1015">    }</a>
<a name="ln1016">  </a>
<a name="ln1017">  /* Else we have to search the existing network/area config to see</a>
<a name="ln1018">   * if any match..</a>
<a name="ln1019">   */</a>
<a name="ln1020">  for (rn = route_top (ospf-&gt;networks); rn; rn = route_next (rn))</a>
<a name="ln1021">    if (rn-&gt;info != NULL</a>
<a name="ln1022">        &amp;&amp; ospf_network_match_iface (co, &amp;rn-&gt;p))</a>
<a name="ln1023">      {</a>
<a name="ln1024">        struct ospf_network *network = (struct ospf_network *) rn-&gt;info;</a>
<a name="ln1025">        area = ospf_area_get (ospf, network-&gt;area_id, network-&gt;format);</a>
<a name="ln1026">        ospf_update_interface_area (co, area);</a>
<a name="ln1027">        configed = 1;</a>
<a name="ln1028">      }</a>
<a name="ln1029">  </a>
<a name="ln1030">  /* If the subnet isn't in any area, deconfigure */</a>
<a name="ln1031">  if (!configed &amp;&amp; (oi = ospf_if_table_lookup (co-&gt;ifp, co-&gt;address)))</a>
<a name="ln1032">    ospf_if_free (oi);</a>
<a name="ln1033">}</a>
<a name="ln1034"> </a>
<a name="ln1035">static void</a>
<a name="ln1036">ospf_network_run_interface (struct ospf *ospf, struct interface *ifp,</a>
<a name="ln1037">                            struct prefix *p,</a>
<a name="ln1038">                            struct ospf_area *given_area)</a>
<a name="ln1039">{</a>
<a name="ln1040">  struct listnode *cnode;</a>
<a name="ln1041">  struct connected *co;</a>
<a name="ln1042">  </a>
<a name="ln1043">  if (memcmp (ifp-&gt;name, &quot;VLINK&quot;, 5) == 0)</a>
<a name="ln1044">    return;</a>
<a name="ln1045">  </a>
<a name="ln1046">  /* Network prefix without area is nonsensical */</a>
<a name="ln1047">  if (p)</a>
<a name="ln1048">    assert (given_area != NULL);</a>
<a name="ln1049">  </a>
<a name="ln1050">  /* if interface prefix is match specified prefix,</a>
<a name="ln1051">     then create socket and join multicast group. */</a>
<a name="ln1052">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, co))</a>
<a name="ln1053">    ospf_network_run_subnet (ospf, co, p, given_area);  </a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056">static void</a>
<a name="ln1057">ospf_network_run (struct prefix *p, struct ospf_area *area)</a>
<a name="ln1058">{</a>
<a name="ln1059">  struct interface *ifp;</a>
<a name="ln1060">  struct listnode *node;</a>
<a name="ln1061"> </a>
<a name="ln1062">  /* Schedule Router ID Update. */</a>
<a name="ln1063">  if (area-&gt;ospf-&gt;router_id.s_addr == 0)</a>
<a name="ln1064">    ospf_router_id_update (area-&gt;ospf);</a>
<a name="ln1065">  </a>
<a name="ln1066">  /* Get target interface. */</a>
<a name="ln1067">  for (ALL_LIST_ELEMENTS_RO (om-&gt;iflist, node, ifp))</a>
<a name="ln1068">    ospf_network_run_interface (area-&gt;ospf, ifp, p, area);</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">void</a>
<a name="ln1072">ospf_ls_upd_queue_empty (struct ospf_interface *oi)</a>
<a name="ln1073">{</a>
<a name="ln1074">  struct route_node *rn;</a>
<a name="ln1075">  struct listnode *node, *nnode;</a>
<a name="ln1076">  struct list *lst;</a>
<a name="ln1077">  struct ospf_lsa *lsa;</a>
<a name="ln1078"> </a>
<a name="ln1079">  /* empty ls update queue */</a>
<a name="ln1080">  for (rn = route_top (oi-&gt;ls_upd_queue); rn;</a>
<a name="ln1081">       rn = route_next (rn))</a>
<a name="ln1082">    if ((lst = (struct list *) rn-&gt;info))</a>
<a name="ln1083">      {</a>
<a name="ln1084">	for (ALL_LIST_ELEMENTS (lst, node, nnode, lsa))</a>
<a name="ln1085">          ospf_lsa_unlock (&amp;lsa); /* oi-&gt;ls_upd_queue */</a>
<a name="ln1086">	list_free (lst);</a>
<a name="ln1087">	rn-&gt;info = NULL;</a>
<a name="ln1088">      }</a>
<a name="ln1089">  </a>
<a name="ln1090">  /* remove update event */</a>
<a name="ln1091">  if (oi-&gt;t_ls_upd_event)</a>
<a name="ln1092">    {</a>
<a name="ln1093">      thread_cancel (oi-&gt;t_ls_upd_event);</a>
<a name="ln1094">      oi-&gt;t_ls_upd_event = NULL;</a>
<a name="ln1095">    }</a>
<a name="ln1096">}</a>
<a name="ln1097"> </a>
<a name="ln1098">void</a>
<a name="ln1099">ospf_if_update (struct ospf *ospf, struct interface *ifp)</a>
<a name="ln1100">{</a>
<a name="ln1101">  if (!ospf)</a>
<a name="ln1102">    ospf = ospf_lookup ();</a>
<a name="ln1103"> </a>
<a name="ln1104">  /* OSPF must be ready. */</a>
<a name="ln1105">  if (!ospf_is_ready (ospf))</a>
<a name="ln1106">    return;</a>
<a name="ln1107">  </a>
<a name="ln1108">  ospf_network_run_interface (ospf, ifp, NULL, NULL);</a>
<a name="ln1109">  </a>
<a name="ln1110">  /* Update connected redistribute. */</a>
<a name="ln1111">  update_redistributed(ospf, 1);</a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114">void</a>
<a name="ln1115">ospf_remove_vls_through_area (struct ospf *ospf, struct ospf_area *area)</a>
<a name="ln1116">{</a>
<a name="ln1117">  struct listnode *node, *nnode;</a>
<a name="ln1118">  struct ospf_vl_data *vl_data;</a>
<a name="ln1119"> </a>
<a name="ln1120">  for (ALL_LIST_ELEMENTS (ospf-&gt;vlinks, node, nnode, vl_data))</a>
<a name="ln1121">    if (IPV4_ADDR_SAME (&amp;vl_data-&gt;vl_area_id, &amp;area-&gt;area_id))</a>
<a name="ln1122">      ospf_vl_delete (ospf, vl_data);</a>
<a name="ln1123">}</a>
<a name="ln1124"> </a>
<a name="ln1125"> </a>
<a name="ln1126">static const struct message ospf_area_type_msg[] =</a>
<a name="ln1127">{</a>
<a name="ln1128">  { OSPF_AREA_DEFAULT,	&quot;Default&quot; },</a>
<a name="ln1129">  { OSPF_AREA_STUB,     &quot;Stub&quot; },</a>
<a name="ln1130">  { OSPF_AREA_NSSA,     &quot;NSSA&quot; },</a>
<a name="ln1131">};</a>
<a name="ln1132">static const int ospf_area_type_msg_max = OSPF_AREA_TYPE_MAX;</a>
<a name="ln1133"> </a>
<a name="ln1134">static void</a>
<a name="ln1135">ospf_area_type_set (struct ospf_area *area, int type)</a>
<a name="ln1136">{</a>
<a name="ln1137">  struct listnode *node;</a>
<a name="ln1138">  struct ospf_interface *oi;</a>
<a name="ln1139"> </a>
<a name="ln1140">  if (area-&gt;external_routing == type)</a>
<a name="ln1141">    {</a>
<a name="ln1142">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1143">	zlog_debug (&quot;Area[%s]: Types are the same, ignored.&quot;,</a>
<a name="ln1144">		   inet_ntoa (area-&gt;area_id));</a>
<a name="ln1145">      return;</a>
<a name="ln1146">    }</a>
<a name="ln1147"> </a>
<a name="ln1148">  area-&gt;external_routing = type;</a>
<a name="ln1149"> </a>
<a name="ln1150">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1151">    zlog_debug (&quot;Area[%s]: Configured as %s&quot;, inet_ntoa (area-&gt;area_id),</a>
<a name="ln1152">	       LOOKUP (ospf_area_type_msg, type));</a>
<a name="ln1153"> </a>
<a name="ln1154">  switch (area-&gt;external_routing)</a>
<a name="ln1155">    {</a>
<a name="ln1156">    case OSPF_AREA_DEFAULT:</a>
<a name="ln1157">      for (ALL_LIST_ELEMENTS_RO (area-&gt;oiflist, node, oi))</a>
<a name="ln1158">        if (oi-&gt;nbr_self != NULL)</a>
<a name="ln1159">          {</a>
<a name="ln1160">	    UNSET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_NP);</a>
<a name="ln1161">	    SET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_E);</a>
<a name="ln1162">          }</a>
<a name="ln1163">      break;</a>
<a name="ln1164">    case OSPF_AREA_STUB:</a>
<a name="ln1165">      for (ALL_LIST_ELEMENTS_RO (area-&gt;oiflist, node, oi))</a>
<a name="ln1166">        if (oi-&gt;nbr_self != NULL)</a>
<a name="ln1167">          {</a>
<a name="ln1168">            if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1169">              zlog_debug (&quot;setting options on %s accordingly&quot;, IF_NAME (oi));</a>
<a name="ln1170">            UNSET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_NP);</a>
<a name="ln1171">            UNSET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_E);</a>
<a name="ln1172">            if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1173">              zlog_debug (&quot;options set on %s: %x&quot;,</a>
<a name="ln1174">                         IF_NAME (oi), OPTIONS (oi));</a>
<a name="ln1175">          }</a>
<a name="ln1176">      break;</a>
<a name="ln1177">    case OSPF_AREA_NSSA:</a>
<a name="ln1178">      for (ALL_LIST_ELEMENTS_RO (area-&gt;oiflist, node, oi))</a>
<a name="ln1179">        if (oi-&gt;nbr_self != NULL)</a>
<a name="ln1180">          {</a>
<a name="ln1181">            zlog_debug (&quot;setting nssa options on %s accordingly&quot;, IF_NAME (oi));</a>
<a name="ln1182">            UNSET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_E);</a>
<a name="ln1183">            SET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_NP);</a>
<a name="ln1184">            zlog_debug (&quot;options set on %s: %x&quot;, IF_NAME (oi), OPTIONS (oi));</a>
<a name="ln1185">          }</a>
<a name="ln1186">      break;</a>
<a name="ln1187">    default:</a>
<a name="ln1188">      break;</a>
<a name="ln1189">    }</a>
<a name="ln1190"> </a>
<a name="ln1191">  ospf_router_lsa_update_area (area);</a>
<a name="ln1192">  ospf_schedule_abr_task (area-&gt;ospf);</a>
<a name="ln1193">}</a>
<a name="ln1194"> </a>
<a name="ln1195">int</a>
<a name="ln1196">ospf_area_shortcut_set (struct ospf *ospf, struct ospf_area *area, int mode)</a>
<a name="ln1197">{</a>
<a name="ln1198">  if (area-&gt;shortcut_configured == mode)</a>
<a name="ln1199">    return 0;</a>
<a name="ln1200"> </a>
<a name="ln1201">  area-&gt;shortcut_configured = mode;</a>
<a name="ln1202">  ospf_router_lsa_update_area (area);</a>
<a name="ln1203">  ospf_schedule_abr_task (ospf);</a>
<a name="ln1204"> </a>
<a name="ln1205">  ospf_area_check_free (ospf, area-&gt;area_id);</a>
<a name="ln1206"> </a>
<a name="ln1207">  return 1;</a>
<a name="ln1208">}</a>
<a name="ln1209"> </a>
<a name="ln1210">int</a>
<a name="ln1211">ospf_area_shortcut_unset (struct ospf *ospf, struct ospf_area *area)</a>
<a name="ln1212">{</a>
<a name="ln1213">  area-&gt;shortcut_configured = OSPF_SHORTCUT_DEFAULT;</a>
<a name="ln1214">  ospf_router_lsa_update_area (area);</a>
<a name="ln1215">  ospf_area_check_free (ospf, area-&gt;area_id);</a>
<a name="ln1216">  ospf_schedule_abr_task (ospf);</a>
<a name="ln1217"> </a>
<a name="ln1218">  return 1;</a>
<a name="ln1219">}</a>
<a name="ln1220"> </a>
<a name="ln1221">static int</a>
<a name="ln1222">ospf_area_vlink_count (struct ospf *ospf, struct ospf_area *area)</a>
<a name="ln1223">{</a>
<a name="ln1224">  struct ospf_vl_data *vl;</a>
<a name="ln1225">  struct listnode *node;</a>
<a name="ln1226">  int count = 0;</a>
<a name="ln1227"> </a>
<a name="ln1228">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;vlinks, node, vl))</a>
<a name="ln1229">    if (IPV4_ADDR_SAME (&amp;vl-&gt;vl_area_id, &amp;area-&gt;area_id))</a>
<a name="ln1230">      count++;</a>
<a name="ln1231"> </a>
<a name="ln1232">  return count;</a>
<a name="ln1233">}</a>
<a name="ln1234"> </a>
<a name="ln1235">int</a>
<a name="ln1236">ospf_area_stub_set (struct ospf *ospf, struct in_addr area_id)</a>
<a name="ln1237">{</a>
<a name="ln1238">  struct ospf_area *area;</a>
<a name="ln1239">  int format = OSPF_AREA_ID_FORMAT_ADDRESS;</a>
<a name="ln1240"> </a>
<a name="ln1241">  area = ospf_area_get (ospf, area_id, format);</a>
<a name="ln1242">  if (ospf_area_vlink_count (ospf, area))</a>
<a name="ln1243">    return 0;</a>
<a name="ln1244"> </a>
<a name="ln1245">  if (area-&gt;external_routing != OSPF_AREA_STUB)</a>
<a name="ln1246">    ospf_area_type_set (area, OSPF_AREA_STUB);</a>
<a name="ln1247"> </a>
<a name="ln1248">  return 1;</a>
<a name="ln1249">}</a>
<a name="ln1250"> </a>
<a name="ln1251">int</a>
<a name="ln1252">ospf_area_stub_unset (struct ospf *ospf, struct in_addr area_id)</a>
<a name="ln1253">{</a>
<a name="ln1254">  struct ospf_area *area;</a>
<a name="ln1255"> </a>
<a name="ln1256">  area = ospf_area_lookup_by_area_id (ospf, area_id);</a>
<a name="ln1257">  if (area == NULL)</a>
<a name="ln1258">    return 1;</a>
<a name="ln1259"> </a>
<a name="ln1260">  if (area-&gt;external_routing == OSPF_AREA_STUB)</a>
<a name="ln1261">    ospf_area_type_set (area, OSPF_AREA_DEFAULT);</a>
<a name="ln1262"> </a>
<a name="ln1263">  ospf_area_check_free (ospf, area_id);</a>
<a name="ln1264"> </a>
<a name="ln1265">  return 1;</a>
<a name="ln1266">}</a>
<a name="ln1267"> </a>
<a name="ln1268">int</a>
<a name="ln1269">ospf_area_no_summary_set (struct ospf *ospf, struct in_addr area_id)</a>
<a name="ln1270">{</a>
<a name="ln1271">  struct ospf_area *area;</a>
<a name="ln1272">  int format = OSPF_AREA_ID_FORMAT_ADDRESS;</a>
<a name="ln1273"> </a>
<a name="ln1274">  area = ospf_area_get (ospf, area_id, format);</a>
<a name="ln1275">  area-&gt;no_summary = 1;</a>
<a name="ln1276"> </a>
<a name="ln1277">  return 1;</a>
<a name="ln1278">}</a>
<a name="ln1279"> </a>
<a name="ln1280">int</a>
<a name="ln1281">ospf_area_no_summary_unset (struct ospf *ospf, struct in_addr area_id)</a>
<a name="ln1282">{</a>
<a name="ln1283">  struct ospf_area *area;</a>
<a name="ln1284"> </a>
<a name="ln1285">  area = ospf_area_lookup_by_area_id (ospf, area_id);</a>
<a name="ln1286">  if (area == NULL)</a>
<a name="ln1287">    return 0;</a>
<a name="ln1288"> </a>
<a name="ln1289">  area-&gt;no_summary = 0;</a>
<a name="ln1290">  ospf_area_check_free (ospf, area_id);</a>
<a name="ln1291"> </a>
<a name="ln1292">  return 1;</a>
<a name="ln1293">}</a>
<a name="ln1294"> </a>
<a name="ln1295">int</a>
<a name="ln1296">ospf_area_nssa_set (struct ospf *ospf, struct in_addr area_id)</a>
<a name="ln1297">{</a>
<a name="ln1298">  struct ospf_area *area;</a>
<a name="ln1299">  int format = OSPF_AREA_ID_FORMAT_ADDRESS;</a>
<a name="ln1300"> </a>
<a name="ln1301">  area = ospf_area_get (ospf, area_id, format);</a>
<a name="ln1302">  if (ospf_area_vlink_count (ospf, area))</a>
<a name="ln1303">    return 0;</a>
<a name="ln1304"> </a>
<a name="ln1305">  if (area-&gt;external_routing != OSPF_AREA_NSSA)</a>
<a name="ln1306">    {</a>
<a name="ln1307">      ospf_area_type_set (area, OSPF_AREA_NSSA);</a>
<a name="ln1308">      ospf-&gt;anyNSSA++;</a>
<a name="ln1309">    }</a>
<a name="ln1310"> </a>
<a name="ln1311">  /* set NSSA area defaults */</a>
<a name="ln1312">  area-&gt;no_summary = 0;</a>
<a name="ln1313">  area-&gt;NSSATranslatorRole = OSPF_NSSA_ROLE_CANDIDATE;</a>
<a name="ln1314">  area-&gt;NSSATranslatorState = OSPF_NSSA_TRANSLATE_DISABLED;</a>
<a name="ln1315">  area-&gt;NSSATranslatorStabilityInterval = OSPF_NSSA_TRANS_STABLE_DEFAULT;</a>
<a name="ln1316"> </a>
<a name="ln1317">  return 1;</a>
<a name="ln1318">}</a>
<a name="ln1319"> </a>
<a name="ln1320">int</a>
<a name="ln1321">ospf_area_nssa_unset (struct ospf *ospf, struct in_addr area_id)</a>
<a name="ln1322">{</a>
<a name="ln1323">  struct ospf_area *area;</a>
<a name="ln1324"> </a>
<a name="ln1325">  area = ospf_area_lookup_by_area_id (ospf, area_id);</a>
<a name="ln1326">  if (area == NULL)</a>
<a name="ln1327">    return 0;</a>
<a name="ln1328"> </a>
<a name="ln1329">  if (area-&gt;external_routing == OSPF_AREA_NSSA)</a>
<a name="ln1330">    {</a>
<a name="ln1331">      ospf-&gt;anyNSSA--;</a>
<a name="ln1332">      ospf_area_type_set (area, OSPF_AREA_DEFAULT);</a>
<a name="ln1333">    }</a>
<a name="ln1334"> </a>
<a name="ln1335">  ospf_area_check_free (ospf, area_id);</a>
<a name="ln1336"> </a>
<a name="ln1337">  return 1;</a>
<a name="ln1338">}</a>
<a name="ln1339"> </a>
<a name="ln1340">int</a>
<a name="ln1341">ospf_area_nssa_translator_role_set (struct ospf *ospf, struct in_addr area_id,</a>
<a name="ln1342">				    int role)</a>
<a name="ln1343">{</a>
<a name="ln1344">  struct ospf_area *area;</a>
<a name="ln1345"> </a>
<a name="ln1346">  area = ospf_area_lookup_by_area_id (ospf, area_id);</a>
<a name="ln1347">  if (area == NULL)</a>
<a name="ln1348">    return 0;</a>
<a name="ln1349"> </a>
<a name="ln1350">  area-&gt;NSSATranslatorRole = role;</a>
<a name="ln1351"> </a>
<a name="ln1352">  return 1;</a>
<a name="ln1353">}</a>
<a name="ln1354"> </a>
<a name="ln1355">#if 0</a>
<a name="ln1356">/* XXX: unused? Leave for symmetry? */</a>
<a name="ln1357">static int</a>
<a name="ln1358">ospf_area_nssa_translator_role_unset (struct ospf *ospf,</a>
<a name="ln1359">				      struct in_addr area_id)</a>
<a name="ln1360">{</a>
<a name="ln1361">  struct ospf_area *area;</a>
<a name="ln1362"> </a>
<a name="ln1363">  area = ospf_area_lookup_by_area_id (ospf, area_id);</a>
<a name="ln1364">  if (area == NULL)</a>
<a name="ln1365">    return 0;</a>
<a name="ln1366"> </a>
<a name="ln1367">  area-&gt;NSSATranslatorRole = OSPF_NSSA_ROLE_CANDIDATE;</a>
<a name="ln1368"> </a>
<a name="ln1369">  ospf_area_check_free (ospf, area_id);</a>
<a name="ln1370"> </a>
<a name="ln1371">  return 1;</a>
<a name="ln1372">}</a>
<a name="ln1373">#endif</a>
<a name="ln1374"> </a>
<a name="ln1375">int</a>
<a name="ln1376">ospf_area_export_list_set (struct ospf *ospf,</a>
<a name="ln1377">			   struct ospf_area *area, const char *list_name)</a>
<a name="ln1378">{</a>
<a name="ln1379">  struct access_list *list;</a>
<a name="ln1380">  list = access_list_lookup (AFI_IP, list_name);</a>
<a name="ln1381"> </a>
<a name="ln1382">  EXPORT_LIST (area) = list;</a>
<a name="ln1383"> </a>
<a name="ln1384">  if (EXPORT_NAME (area))</a>
<a name="ln1385">    free (EXPORT_NAME (area));</a>
<a name="ln1386"> </a>
<a name="ln1387">  EXPORT_NAME (area) = strdup (list_name);</a>
<a name="ln1388">  ospf_schedule_abr_task (ospf);</a>
<a name="ln1389"> </a>
<a name="ln1390">  return 1;</a>
<a name="ln1391">}</a>
<a name="ln1392"> </a>
<a name="ln1393">int</a>
<a name="ln1394">ospf_area_export_list_unset (struct ospf *ospf, struct ospf_area * area)</a>
<a name="ln1395">{</a>
<a name="ln1396"> </a>
<a name="ln1397">  EXPORT_LIST (area) = 0;</a>
<a name="ln1398"> </a>
<a name="ln1399">  if (EXPORT_NAME (area))</a>
<a name="ln1400">    free (EXPORT_NAME (area));</a>
<a name="ln1401"> </a>
<a name="ln1402">  EXPORT_NAME (area) = NULL;</a>
<a name="ln1403"> </a>
<a name="ln1404">  ospf_area_check_free (ospf, area-&gt;area_id);</a>
<a name="ln1405">  </a>
<a name="ln1406">  ospf_schedule_abr_task (ospf);</a>
<a name="ln1407"> </a>
<a name="ln1408">  return 1;</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">int</a>
<a name="ln1412">ospf_area_import_list_set (struct ospf *ospf, struct ospf_area *area, </a>
<a name="ln1413">                           const char *name)</a>
<a name="ln1414">{</a>
<a name="ln1415">  struct access_list *list;</a>
<a name="ln1416">  list = access_list_lookup (AFI_IP, name);</a>
<a name="ln1417"> </a>
<a name="ln1418">  IMPORT_LIST (area) = list;</a>
<a name="ln1419"> </a>
<a name="ln1420">  if (IMPORT_NAME (area))</a>
<a name="ln1421">    free (IMPORT_NAME (area));</a>
<a name="ln1422"> </a>
<a name="ln1423">  IMPORT_NAME (area) = strdup (name);</a>
<a name="ln1424">  ospf_schedule_abr_task (ospf);</a>
<a name="ln1425"> </a>
<a name="ln1426">  return 1;</a>
<a name="ln1427">}</a>
<a name="ln1428"> </a>
<a name="ln1429">int</a>
<a name="ln1430">ospf_area_import_list_unset (struct ospf *ospf, struct ospf_area * area)</a>
<a name="ln1431">{</a>
<a name="ln1432">  IMPORT_LIST (area) = 0;</a>
<a name="ln1433"> </a>
<a name="ln1434">  if (IMPORT_NAME (area))</a>
<a name="ln1435">    free (IMPORT_NAME (area));</a>
<a name="ln1436"> </a>
<a name="ln1437">  IMPORT_NAME (area) = NULL;</a>
<a name="ln1438">  ospf_area_check_free (ospf, area-&gt;area_id);</a>
<a name="ln1439"> </a>
<a name="ln1440">  ospf_schedule_abr_task (ospf);</a>
<a name="ln1441"> </a>
<a name="ln1442">  return 1;</a>
<a name="ln1443">}</a>
<a name="ln1444"> </a>
<a name="ln1445">int</a>
<a name="ln1446">ospf_timers_refresh_set (struct ospf *ospf, int interval)</a>
<a name="ln1447">{</a>
<a name="ln1448">  int time_left;</a>
<a name="ln1449"> </a>
<a name="ln1450">  if (ospf-&gt;lsa_refresh_interval == interval)</a>
<a name="ln1451">    return 1;</a>
<a name="ln1452"> </a>
<a name="ln1453">  time_left = ospf-&gt;lsa_refresh_interval -</a>
<a name="ln1454">    (quagga_time (NULL) - ospf-&gt;lsa_refresher_started);</a>
<a name="ln1455">  </a>
<a name="ln1456">  if (time_left &gt; interval)</a>
<a name="ln1457">    {</a>
<a name="ln1458">      OSPF_TIMER_OFF (ospf-&gt;t_lsa_refresher);</a>
<a name="ln1459">      ospf-&gt;t_lsa_refresher =</a>
<a name="ln1460">	thread_add_timer (master, ospf_lsa_refresh_walker, ospf, interval);</a>
<a name="ln1461">    }</a>
<a name="ln1462">  ospf-&gt;lsa_refresh_interval = interval;</a>
<a name="ln1463"> </a>
<a name="ln1464">  return 1;</a>
<a name="ln1465">}</a>
<a name="ln1466"> </a>
<a name="ln1467">int</a>
<a name="ln1468">ospf_timers_refresh_unset (struct ospf *ospf)</a>
<a name="ln1469">{</a>
<a name="ln1470">  int time_left;</a>
<a name="ln1471"> </a>
<a name="ln1472">  time_left = ospf-&gt;lsa_refresh_interval -</a>
<a name="ln1473">    (quagga_time (NULL) - ospf-&gt;lsa_refresher_started);</a>
<a name="ln1474"> </a>
<a name="ln1475">  if (time_left &gt; OSPF_LSA_REFRESH_INTERVAL_DEFAULT)</a>
<a name="ln1476">    {</a>
<a name="ln1477">      OSPF_TIMER_OFF (ospf-&gt;t_lsa_refresher);</a>
<a name="ln1478">      ospf-&gt;t_lsa_refresher =</a>
<a name="ln1479">	thread_add_timer (master, ospf_lsa_refresh_walker, ospf,</a>
<a name="ln1480">			  OSPF_LSA_REFRESH_INTERVAL_DEFAULT);</a>
<a name="ln1481">    }</a>
<a name="ln1482"> </a>
<a name="ln1483">  ospf-&gt;lsa_refresh_interval = OSPF_LSA_REFRESH_INTERVAL_DEFAULT;</a>
<a name="ln1484"> </a>
<a name="ln1485">  return 1;</a>
<a name="ln1486">}</a>
<a name="ln1487"> </a>
<a name="ln1488"> </a>
<a name="ln1489">static struct ospf_nbr_nbma *</a>
<a name="ln1490">ospf_nbr_nbma_new (void)</a>
<a name="ln1491">{</a>
<a name="ln1492">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1493"> </a>
<a name="ln1494">  nbr_nbma = XCALLOC (MTYPE_OSPF_NEIGHBOR_STATIC,</a>
<a name="ln1495">		      sizeof (struct ospf_nbr_nbma));</a>
<a name="ln1496"> </a>
<a name="ln1497">  nbr_nbma-&gt;priority = OSPF_NEIGHBOR_PRIORITY_DEFAULT;</a>
<a name="ln1498">  nbr_nbma-&gt;v_poll = OSPF_POLL_INTERVAL_DEFAULT;</a>
<a name="ln1499"> </a>
<a name="ln1500">  return nbr_nbma;</a>
<a name="ln1501">}</a>
<a name="ln1502"> </a>
<a name="ln1503">static void</a>
<a name="ln1504">ospf_nbr_nbma_free (struct ospf_nbr_nbma *nbr_nbma)</a>
<a name="ln1505">{</a>
<a name="ln1506">  XFREE (MTYPE_OSPF_NEIGHBOR_STATIC, nbr_nbma);</a>
<a name="ln1507">}</a>
<a name="ln1508"> </a>
<a name="ln1509">static void</a>
<a name="ln1510">ospf_nbr_nbma_delete (struct ospf *ospf, struct ospf_nbr_nbma *nbr_nbma)</a>
<a name="ln1511">{</a>
<a name="ln1512">  struct route_node *rn;</a>
<a name="ln1513">  struct prefix_ipv4 p;</a>
<a name="ln1514"> </a>
<a name="ln1515">  p.family = AF_INET;</a>
<a name="ln1516">  p.prefix = nbr_nbma-&gt;addr;</a>
<a name="ln1517">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln1518"> </a>
<a name="ln1519">  rn = route_node_lookup (ospf-&gt;nbr_nbma, (struct prefix *)&amp;p);</a>
<a name="ln1520">  if (rn)</a>
<a name="ln1521">    {</a>
<a name="ln1522">      ospf_nbr_nbma_free (rn-&gt;info);</a>
<a name="ln1523">      rn-&gt;info = NULL;</a>
<a name="ln1524">      route_unlock_node (rn);</a>
<a name="ln1525">      route_unlock_node (rn);</a>
<a name="ln1526">    }</a>
<a name="ln1527">}</a>
<a name="ln1528"> </a>
<a name="ln1529">static void</a>
<a name="ln1530">ospf_nbr_nbma_down (struct ospf_nbr_nbma *nbr_nbma)</a>
<a name="ln1531">{</a>
<a name="ln1532">  OSPF_TIMER_OFF (nbr_nbma-&gt;t_poll);</a>
<a name="ln1533"> </a>
<a name="ln1534">  if (nbr_nbma-&gt;nbr)</a>
<a name="ln1535">    {</a>
<a name="ln1536">      nbr_nbma-&gt;nbr-&gt;nbr_nbma = NULL;</a>
<a name="ln1537">      OSPF_NSM_EVENT_EXECUTE (nbr_nbma-&gt;nbr, NSM_KillNbr);</a>
<a name="ln1538">    }</a>
<a name="ln1539"> </a>
<a name="ln1540">  if (nbr_nbma-&gt;oi)</a>
<a name="ln1541">    listnode_delete (nbr_nbma-&gt;oi-&gt;nbr_nbma, nbr_nbma);</a>
<a name="ln1542">}</a>
<a name="ln1543"> </a>
<a name="ln1544">static void</a>
<a name="ln1545">ospf_nbr_nbma_add (struct ospf_nbr_nbma *nbr_nbma,</a>
<a name="ln1546">		   struct ospf_interface *oi)</a>
<a name="ln1547">{</a>
<a name="ln1548">  struct ospf_neighbor *nbr;</a>
<a name="ln1549">  struct route_node *rn;</a>
<a name="ln1550">  struct prefix p;</a>
<a name="ln1551"> </a>
<a name="ln1552">  if (oi-&gt;type != OSPF_IFTYPE_NBMA)</a>
<a name="ln1553">    return;</a>
<a name="ln1554"> </a>
<a name="ln1555">  if (nbr_nbma-&gt;nbr != NULL)</a>
<a name="ln1556">    return;</a>
<a name="ln1557"> </a>
<a name="ln1558">  if (IPV4_ADDR_SAME (&amp;oi-&gt;nbr_self-&gt;address.u.prefix4, &amp;nbr_nbma-&gt;addr))</a>
<a name="ln1559">    return;</a>
<a name="ln1560">      </a>
<a name="ln1561">  nbr_nbma-&gt;oi = oi;</a>
<a name="ln1562">  listnode_add (oi-&gt;nbr_nbma, nbr_nbma);</a>
<a name="ln1563"> </a>
<a name="ln1564">  /* Get neighbor information from table. */</a>
<a name="ln1565">  p.family = AF_INET;</a>
<a name="ln1566">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln1567">  p.u.prefix4 = nbr_nbma-&gt;addr;</a>
<a name="ln1568"> </a>
<a name="ln1569">  rn = route_node_get (oi-&gt;nbrs, (struct prefix *)&amp;p);</a>
<a name="ln1570">  if (rn-&gt;info)</a>
<a name="ln1571">    {</a>
<a name="ln1572">      nbr = rn-&gt;info;</a>
<a name="ln1573">      nbr-&gt;nbr_nbma = nbr_nbma;</a>
<a name="ln1574">      nbr_nbma-&gt;nbr = nbr;</a>
<a name="ln1575"> </a>
<a name="ln1576">      route_unlock_node (rn);</a>
<a name="ln1577">    }</a>
<a name="ln1578">  else</a>
<a name="ln1579">    {</a>
<a name="ln1580">      nbr = rn-&gt;info = ospf_nbr_new (oi);</a>
<a name="ln1581">      nbr-&gt;state = NSM_Down;</a>
<a name="ln1582">      nbr-&gt;src = nbr_nbma-&gt;addr;</a>
<a name="ln1583">      nbr-&gt;nbr_nbma = nbr_nbma;</a>
<a name="ln1584">      nbr-&gt;priority = nbr_nbma-&gt;priority;</a>
<a name="ln1585">      nbr-&gt;address = p;</a>
<a name="ln1586"> </a>
<a name="ln1587">      nbr_nbma-&gt;nbr = nbr;</a>
<a name="ln1588"> </a>
<a name="ln1589">      OSPF_NSM_EVENT_EXECUTE (nbr, NSM_Start);</a>
<a name="ln1590">    }</a>
<a name="ln1591">}</a>
<a name="ln1592"> </a>
<a name="ln1593">void</a>
<a name="ln1594">ospf_nbr_nbma_if_update (struct ospf *ospf, struct ospf_interface *oi)</a>
<a name="ln1595">{</a>
<a name="ln1596">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1597">  struct route_node *rn;</a>
<a name="ln1598">  struct prefix_ipv4 p;</a>
<a name="ln1599"> </a>
<a name="ln1600">  if (oi-&gt;type != OSPF_IFTYPE_NBMA)</a>
<a name="ln1601">    return;</a>
<a name="ln1602"> </a>
<a name="ln1603">  for (rn = route_top (ospf-&gt;nbr_nbma); rn; rn = route_next (rn))</a>
<a name="ln1604">    if ((nbr_nbma = rn-&gt;info))</a>
<a name="ln1605">      if (nbr_nbma-&gt;oi == NULL &amp;&amp; nbr_nbma-&gt;nbr == NULL)</a>
<a name="ln1606">	{</a>
<a name="ln1607">	  p.family = AF_INET;</a>
<a name="ln1608">	  p.prefix = nbr_nbma-&gt;addr;</a>
<a name="ln1609">	  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln1610"> </a>
<a name="ln1611">	  if (prefix_match (oi-&gt;address, (struct prefix *)&amp;p))</a>
<a name="ln1612">	    ospf_nbr_nbma_add (nbr_nbma, oi);</a>
<a name="ln1613">	}</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616">struct ospf_nbr_nbma *</a>
<a name="ln1617">ospf_nbr_nbma_lookup (struct ospf *ospf, struct in_addr nbr_addr)</a>
<a name="ln1618">{</a>
<a name="ln1619">  struct route_node *rn;</a>
<a name="ln1620">  struct prefix_ipv4 p;</a>
<a name="ln1621"> </a>
<a name="ln1622">  p.family = AF_INET;</a>
<a name="ln1623">  p.prefix = nbr_addr;</a>
<a name="ln1624">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln1625"> </a>
<a name="ln1626">  rn = route_node_lookup (ospf-&gt;nbr_nbma, (struct prefix *)&amp;p);</a>
<a name="ln1627">  if (rn)</a>
<a name="ln1628">    {</a>
<a name="ln1629">      route_unlock_node (rn);</a>
<a name="ln1630">      return rn-&gt;info;</a>
<a name="ln1631">    }</a>
<a name="ln1632">  return NULL;</a>
<a name="ln1633">}</a>
<a name="ln1634"> </a>
<a name="ln1635">struct ospf_nbr_nbma *</a>
<a name="ln1636">ospf_nbr_nbma_lookup_next (struct ospf *ospf, struct in_addr *addr, int first)</a>
<a name="ln1637">{</a>
<a name="ln1638">#if 0</a>
<a name="ln1639">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1640">  struct listnode *node;</a>
<a name="ln1641">#endif</a>
<a name="ln1642"> </a>
<a name="ln1643">  if (ospf == NULL)</a>
<a name="ln1644">    return NULL;</a>
<a name="ln1645"> </a>
<a name="ln1646">#if 0</a>
<a name="ln1647">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;nbr_nbma, node, nbr_nbma))</a>
<a name="ln1648">    {</a>
<a name="ln1649">      if (first)</a>
<a name="ln1650">	{</a>
<a name="ln1651">	  *addr = nbr_nbma-&gt;addr;</a>
<a name="ln1652">	  return nbr_nbma;</a>
<a name="ln1653">	}</a>
<a name="ln1654">      else if (ntohl (nbr_nbma-&gt;addr.s_addr) &gt; ntohl (addr-&gt;s_addr))</a>
<a name="ln1655">	{</a>
<a name="ln1656">	  *addr = nbr_nbma-&gt;addr;</a>
<a name="ln1657">	  return nbr_nbma;</a>
<a name="ln1658">	}</a>
<a name="ln1659">    }</a>
<a name="ln1660">#endif</a>
<a name="ln1661">  return NULL;</a>
<a name="ln1662">}</a>
<a name="ln1663"> </a>
<a name="ln1664">int</a>
<a name="ln1665">ospf_nbr_nbma_set (struct ospf *ospf, struct in_addr nbr_addr)</a>
<a name="ln1666">{</a>
<a name="ln1667">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1668">  struct ospf_interface *oi;</a>
<a name="ln1669">  struct prefix_ipv4 p;</a>
<a name="ln1670">  struct route_node *rn;</a>
<a name="ln1671">  struct listnode *node;</a>
<a name="ln1672"> </a>
<a name="ln1673">  nbr_nbma = ospf_nbr_nbma_lookup (ospf, nbr_addr);</a>
<a name="ln1674">  if (nbr_nbma)</a>
<a name="ln1675">    return 0;</a>
<a name="ln1676"> </a>
<a name="ln1677">  nbr_nbma = ospf_nbr_nbma_new ();</a>
<a name="ln1678">  nbr_nbma-&gt;addr = nbr_addr;</a>
<a name="ln1679"> </a>
<a name="ln1680">  p.family = AF_INET;</a>
<a name="ln1681">  p.prefix = nbr_addr;</a>
<a name="ln1682">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln1683"> </a>
<a name="ln1684">  rn = route_node_get (ospf-&gt;nbr_nbma, (struct prefix *)&amp;p);</a>
<a name="ln1685">  if (rn-&gt;info)</a>
<a name="ln1686">    route_unlock_node (rn);</a>
<a name="ln1687">  rn-&gt;info = nbr_nbma;</a>
<a name="ln1688"> </a>
<a name="ln1689">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, node, oi))</a>
<a name="ln1690">    {</a>
<a name="ln1691">      if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln1692">	if (prefix_match (oi-&gt;address, (struct prefix *)&amp;p))</a>
<a name="ln1693">	  {</a>
<a name="ln1694">	    ospf_nbr_nbma_add (nbr_nbma, oi);</a>
<a name="ln1695">	    break;</a>
<a name="ln1696">	  }</a>
<a name="ln1697">    }</a>
<a name="ln1698"> </a>
<a name="ln1699">  return 1;</a>
<a name="ln1700">}</a>
<a name="ln1701"> </a>
<a name="ln1702">int</a>
<a name="ln1703">ospf_nbr_nbma_unset (struct ospf *ospf, struct in_addr nbr_addr)</a>
<a name="ln1704">{</a>
<a name="ln1705">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1706"> </a>
<a name="ln1707">  nbr_nbma = ospf_nbr_nbma_lookup (ospf, nbr_addr);</a>
<a name="ln1708">  if (nbr_nbma == NULL)</a>
<a name="ln1709">    return 0;</a>
<a name="ln1710"> </a>
<a name="ln1711">  ospf_nbr_nbma_down (nbr_nbma);</a>
<a name="ln1712">  ospf_nbr_nbma_delete (ospf, nbr_nbma);</a>
<a name="ln1713"> </a>
<a name="ln1714">  return 1;</a>
<a name="ln1715">}</a>
<a name="ln1716"> </a>
<a name="ln1717">int</a>
<a name="ln1718">ospf_nbr_nbma_priority_set (struct ospf *ospf, struct in_addr nbr_addr,</a>
<a name="ln1719">			    u_char priority)</a>
<a name="ln1720">{</a>
<a name="ln1721">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1722"> </a>
<a name="ln1723">  nbr_nbma = ospf_nbr_nbma_lookup (ospf, nbr_addr);</a>
<a name="ln1724">  if (nbr_nbma == NULL)</a>
<a name="ln1725">    return 0;</a>
<a name="ln1726"> </a>
<a name="ln1727">  if (nbr_nbma-&gt;priority != priority)</a>
<a name="ln1728">    nbr_nbma-&gt;priority = priority;</a>
<a name="ln1729"> </a>
<a name="ln1730">  return 1;</a>
<a name="ln1731">}</a>
<a name="ln1732"> </a>
<a name="ln1733">int</a>
<a name="ln1734">ospf_nbr_nbma_priority_unset (struct ospf *ospf, struct in_addr nbr_addr)</a>
<a name="ln1735">{</a>
<a name="ln1736">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1737"> </a>
<a name="ln1738">  nbr_nbma = ospf_nbr_nbma_lookup (ospf, nbr_addr);</a>
<a name="ln1739">  if (nbr_nbma == NULL)</a>
<a name="ln1740">    return 0;</a>
<a name="ln1741"> </a>
<a name="ln1742">  if (nbr_nbma != OSPF_NEIGHBOR_PRIORITY_DEFAULT)</a>
<a name="ln1743">    nbr_nbma-&gt;priority = OSPF_NEIGHBOR_PRIORITY_DEFAULT;</a>
<a name="ln1744"> </a>
<a name="ln1745">  return 1;</a>
<a name="ln1746">}</a>
<a name="ln1747"> </a>
<a name="ln1748">int</a>
<a name="ln1749">ospf_nbr_nbma_poll_interval_set (struct ospf *ospf, struct in_addr nbr_addr,</a>
<a name="ln1750">				 unsigned int interval)</a>
<a name="ln1751">{</a>
<a name="ln1752">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1753"> </a>
<a name="ln1754">  nbr_nbma = ospf_nbr_nbma_lookup (ospf, nbr_addr);</a>
<a name="ln1755">  if (nbr_nbma == NULL)</a>
<a name="ln1756">    return 0;</a>
<a name="ln1757"> </a>
<a name="ln1758">  if (nbr_nbma-&gt;v_poll != interval)</a>
<a name="ln1759">    {</a>
<a name="ln1760">      nbr_nbma-&gt;v_poll = interval;</a>
<a name="ln1761">      if (nbr_nbma-&gt;oi &amp;&amp; ospf_if_is_up (nbr_nbma-&gt;oi))</a>
<a name="ln1762">	{</a>
<a name="ln1763">	  OSPF_TIMER_OFF (nbr_nbma-&gt;t_poll);</a>
<a name="ln1764">	  OSPF_POLL_TIMER_ON (nbr_nbma-&gt;t_poll, ospf_poll_timer,</a>
<a name="ln1765">			      nbr_nbma-&gt;v_poll);</a>
<a name="ln1766">	}</a>
<a name="ln1767">    }</a>
<a name="ln1768"> </a>
<a name="ln1769">  return 1;</a>
<a name="ln1770">}</a>
<a name="ln1771"> </a>
<a name="ln1772">int</a>
<a name="ln1773">ospf_nbr_nbma_poll_interval_unset (struct ospf *ospf, struct in_addr addr)</a>
<a name="ln1774">{</a>
<a name="ln1775">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1776"> </a>
<a name="ln1777">  nbr_nbma = ospf_nbr_nbma_lookup (ospf, addr);</a>
<a name="ln1778">  if (nbr_nbma == NULL)</a>
<a name="ln1779">    return 0;</a>
<a name="ln1780"> </a>
<a name="ln1781">  if (nbr_nbma-&gt;v_poll != OSPF_POLL_INTERVAL_DEFAULT)</a>
<a name="ln1782">    nbr_nbma-&gt;v_poll = OSPF_POLL_INTERVAL_DEFAULT;</a>
<a name="ln1783"> </a>
<a name="ln1784">  return 1;</a>
<a name="ln1785">}</a>
<a name="ln1786"> </a>
<a name="ln1787">void</a>
<a name="ln1788">ospf_master_init ()</a>
<a name="ln1789">{</a>
<a name="ln1790">  memset (&amp;ospf_master, 0, sizeof (struct ospf_master));</a>
<a name="ln1791"> </a>
<a name="ln1792">  om = &amp;ospf_master;</a>
<a name="ln1793">  om-&gt;ospf = list_new ();</a>
<a name="ln1794">  om-&gt;master = thread_master_create ();</a>
<a name="ln1795">  om-&gt;start_time = quagga_time (NULL);</a>
<a name="ln1796">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="62"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v707/" target="_blank">V707</a> Giving short names to global variables is considered to be bad practice. It is suggested to rename 'om' variable.</p></div>
<div class="balloon" rel="1742"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'nbr_nbma != 0' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
