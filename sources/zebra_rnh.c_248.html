
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>zebra_rnh.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Zebra next hop tracking code</a>
<a name="ln2"> * Copyright (C) 2013 Cumulus Networks, Inc.</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.</a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;prefix.h&quot;</a>
<a name="ln25">#include &quot;table.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;str.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29">#include &quot;if.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31">#include &quot;sockunion.h&quot;</a>
<a name="ln32">#include &quot;linklist.h&quot;</a>
<a name="ln33">#include &quot;thread.h&quot;</a>
<a name="ln34">#include &quot;workqueue.h&quot;</a>
<a name="ln35">#include &quot;prefix.h&quot;</a>
<a name="ln36">#include &quot;routemap.h&quot;</a>
<a name="ln37">#include &quot;stream.h&quot;</a>
<a name="ln38">#include &quot;nexthop.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;zebra/rib.h&quot;</a>
<a name="ln41">#include &quot;zebra/rt.h&quot;</a>
<a name="ln42">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln43">#include &quot;zebra/redistribute.h&quot;</a>
<a name="ln44">#include &quot;zebra/debug.h&quot;</a>
<a name="ln45">#include &quot;zebra/zebra_rnh.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">#define lookup_rnh_table(v, f)		         \</a>
<a name="ln48">({						 \</a>
<a name="ln49">  struct zebra_vrf *zvrf;                        \</a>
<a name="ln50">  struct route_table *t = NULL;                  \</a>
<a name="ln51">  zvrf = zebra_vrf_lookup(v);                    \</a>
<a name="ln52">  if (zvrf)                                      \</a>
<a name="ln53">    t = zvrf-&gt;rnh_table[family2afi(f)];	         \</a>
<a name="ln54">  t;                                             \</a>
<a name="ln55">})</a>
<a name="ln56"> </a>
<a name="ln57">static void free_state(struct rib *rib);</a>
<a name="ln58">static void copy_state(struct rnh *rnh, struct rib *rib);</a>
<a name="ln59">static int compare_state(struct rib *r1, struct rib *r2);</a>
<a name="ln60">static int send_client(struct rnh *rnh, struct zserv *client, vrf_id_t vrf_id);</a>
<a name="ln61">static void print_rnh(struct route_node *rn, struct vty *vty);</a>
<a name="ln62"> </a>
<a name="ln63">char *</a>
<a name="ln64">rnh_str (struct rnh *rnh, char *buf, int size)</a>
<a name="ln65">{</a>
<a name="ln66">  prefix2str(&amp;(rnh-&gt;node-&gt;p), buf, size);</a>
<a name="ln67">  return buf;</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70">struct rnh *</a>
<a name="ln71">zebra_add_rnh (struct prefix *p, vrf_id_t vrfid)</a>
<a name="ln72">{</a>
<a name="ln73">  struct route_table *table;</a>
<a name="ln74">  struct route_node *rn;</a>
<a name="ln75">  struct rnh *rnh = NULL;</a>
<a name="ln76"> </a>
<a name="ln77">  if (IS_ZEBRA_DEBUG_NHT)</a>
<a name="ln78">    {</a>
<a name="ln79">      char buf[INET6_ADDRSTRLEN];</a>
<a name="ln80">      prefix2str(p, buf, INET6_ADDRSTRLEN);</a>
<a name="ln81">      zlog_debug(&quot;add rnh %s in vrf %d&quot;, buf, vrfid);</a>
<a name="ln82">    }</a>
<a name="ln83">  table = lookup_rnh_table(vrfid, PREFIX_FAMILY(p));</a>
<a name="ln84">  if (!table)</a>
<a name="ln85">    {</a>
<a name="ln86">      zlog_debug(&quot;add_rnh: rnh table not found\n&quot;);</a>
<a name="ln87">      return NULL;</a>
<a name="ln88">    }</a>
<a name="ln89"> </a>
<a name="ln90">  /* Make it sure prefixlen is applied to the prefix. */</a>
<a name="ln91">  apply_mask (p);</a>
<a name="ln92"> </a>
<a name="ln93">  /* Lookup (or add) route node.*/</a>
<a name="ln94">  rn = route_node_get (table, p);</a>
<a name="ln95"> </a>
<a name="ln96">  if (!rn-&gt;info)</a>
<a name="ln97">    {</a>
<a name="ln98">      rnh = XCALLOC(MTYPE_RNH, sizeof(struct rnh));</a>
<a name="ln99">      rnh-&gt;client_list = list_new();</a>
<a name="ln100">      route_lock_node (rn);</a>
<a name="ln101">      rn-&gt;info = rnh;</a>
<a name="ln102">      rnh-&gt;node = rn;</a>
<a name="ln103">    }</a>
<a name="ln104"> </a>
<a name="ln105">  route_unlock_node (rn);</a>
<a name="ln106">  return (rn-&gt;info);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">struct rnh *</a>
<a name="ln110">zebra_lookup_rnh (struct prefix *p, vrf_id_t vrfid)</a>
<a name="ln111">{</a>
<a name="ln112">  struct route_table *table;</a>
<a name="ln113">  struct route_node *rn;</a>
<a name="ln114"> </a>
<a name="ln115">  table = lookup_rnh_table(vrfid, PREFIX_FAMILY(p));</a>
<a name="ln116">  if (!table)</a>
<a name="ln117">    return NULL;</a>
<a name="ln118"> </a>
<a name="ln119">  /* Make it sure prefixlen is applied to the prefix. */</a>
<a name="ln120">  apply_mask (p);</a>
<a name="ln121"> </a>
<a name="ln122">  /* Lookup route node.*/</a>
<a name="ln123">  rn = route_node_lookup (table, p);</a>
<a name="ln124">  if (!rn)</a>
<a name="ln125">    return NULL;</a>
<a name="ln126"> </a>
<a name="ln127">  route_unlock_node (rn);</a>
<a name="ln128">  return (rn-&gt;info);</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">void</a>
<a name="ln132">zebra_delete_rnh (struct rnh *rnh)</a>
<a name="ln133">{</a>
<a name="ln134">  struct route_node *rn;</a>
<a name="ln135"> </a>
<a name="ln136">  if (!rnh || !(rn = rnh-&gt;node))</a>
<a name="ln137">    return;</a>
<a name="ln138"> </a>
<a name="ln139">  if (IS_ZEBRA_DEBUG_NHT)</a>
<a name="ln140">    {</a>
<a name="ln141">      char buf[INET6_ADDRSTRLEN];</a>
<a name="ln142">      zlog_debug(&quot;delete rnh %s&quot;, rnh_str(rnh, buf, INET6_ADDRSTRLEN));</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">  list_free(rnh-&gt;client_list);</a>
<a name="ln146">  free_state(rnh-&gt;state);</a>
<a name="ln147">  XFREE(MTYPE_RNH, rn-&gt;info);</a>
<a name="ln148">  rn-&gt;info = NULL;</a>
<a name="ln149">  route_unlock_node (rn);</a>
<a name="ln150">  return;</a>
<a name="ln151">}</a>
<a name="ln152"> </a>
<a name="ln153">void</a>
<a name="ln154">zebra_add_rnh_client (struct rnh *rnh, struct zserv *client, vrf_id_t vrf_id)</a>
<a name="ln155">{</a>
<a name="ln156">  if (IS_ZEBRA_DEBUG_NHT)</a>
<a name="ln157">    {</a>
<a name="ln158">      char buf[INET6_ADDRSTRLEN];</a>
<a name="ln159">      zlog_debug(&quot;client %s registers rnh %s&quot;,</a>
<a name="ln160">		 zebra_route_string(client-&gt;proto),</a>
<a name="ln161">		 rnh_str(rnh, buf, INET6_ADDRSTRLEN));</a>
<a name="ln162">    }</a>
<a name="ln163">  if (!listnode_lookup(rnh-&gt;client_list, client))</a>
<a name="ln164">    {</a>
<a name="ln165">      listnode_add(rnh-&gt;client_list, client);</a>
<a name="ln166">      send_client(rnh, client, vrf_id);</a>
<a name="ln167">    }</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">void</a>
<a name="ln171">zebra_remove_rnh_client (struct rnh *rnh, struct zserv *client)</a>
<a name="ln172">{</a>
<a name="ln173">  if (IS_ZEBRA_DEBUG_NHT)</a>
<a name="ln174">    {</a>
<a name="ln175">      char buf[INET6_ADDRSTRLEN];</a>
<a name="ln176">      zlog_debug(&quot;client %s unregisters rnh %s&quot;,</a>
<a name="ln177">		 zebra_route_string(client-&gt;proto),</a>
<a name="ln178">		 rnh_str(rnh, buf, INET6_ADDRSTRLEN));</a>
<a name="ln179">    }</a>
<a name="ln180">  listnode_delete(rnh-&gt;client_list, client);</a>
<a name="ln181">  if (list_isempty(rnh-&gt;client_list))</a>
<a name="ln182">    zebra_delete_rnh(rnh);</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">int</a>
<a name="ln186">zebra_evaluate_rnh_table (vrf_id_t vrfid, int family)</a>
<a name="ln187">{</a>
<a name="ln188">  struct route_table *ptable;</a>
<a name="ln189">  struct route_table *ntable;</a>
<a name="ln190">  struct route_node *prn;</a>
<a name="ln191">  struct route_node *nrn;</a>
<a name="ln192">  struct rnh *rnh;</a>
<a name="ln193">  struct zserv *client;</a>
<a name="ln194">  struct listnode *node;</a>
<a name="ln195">  struct rib *rib;</a>
<a name="ln196"> </a>
<a name="ln197">  ntable = lookup_rnh_table(vrfid, family);</a>
<a name="ln198">  if (!ntable)</a>
<a name="ln199">    {</a>
<a name="ln200">      zlog_debug(&quot;evaluate_rnh_table: rnh table not found\n&quot;);</a>
<a name="ln201">      return -1;</a>
<a name="ln202">    }</a>
<a name="ln203"> </a>
<a name="ln204">  ptable = zebra_vrf_table(family2afi(family), SAFI_UNICAST, vrfid);</a>
<a name="ln205">  if (!ptable)</a>
<a name="ln206">    {</a>
<a name="ln207">      zlog_debug(&quot;evaluate_rnh_table: prefix table not found\n&quot;);</a>
<a name="ln208">      return -1;</a>
<a name="ln209">    }</a>
<a name="ln210"> </a>
<a name="ln211">  for (nrn = route_top (ntable); nrn; nrn = route_next (nrn))</a>
<a name="ln212">    {</a>
<a name="ln213">      if (!nrn-&gt;info)</a>
<a name="ln214">	  continue;</a>
<a name="ln215">      </a>
<a name="ln216">      rnh = nrn-&gt;info;</a>
<a name="ln217">      prn = route_node_match(ptable, &amp;nrn-&gt;p);</a>
<a name="ln218">      if (!prn)</a>
<a name="ln219">	rib = NULL;</a>
<a name="ln220">      else</a>
<a name="ln221">	{</a>
<a name="ln222">	  RNODE_FOREACH_RIB(prn, rib)</a>
<a name="ln223">	    {</a>
<a name="ln224">	      if (CHECK_FLAG (rib-&gt;status, RIB_ENTRY_REMOVED))</a>
<a name="ln225">		continue;</a>
<a name="ln226">	      if (! CHECK_FLAG (rib-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln227">		continue;</a>
<a name="ln228"> </a>
<a name="ln229">	      if (CHECK_FLAG(rnh-&gt;flags, ZEBRA_NHT_CONNECTED))</a>
<a name="ln230">		{</a>
<a name="ln231">		  if (rib-&gt;type == ZEBRA_ROUTE_CONNECT)</a>
<a name="ln232">		    break;</a>
<a name="ln233"> </a>
<a name="ln234">		  if (rib-&gt;type == ZEBRA_ROUTE_NHRP)</a>
<a name="ln235">		    {</a>
<a name="ln236">		      struct nexthop *nexthop;</a>
<a name="ln237">		      for (nexthop = rib-&gt;nexthop; nexthop; nexthop = nexthop-&gt;next)</a>
<a name="ln238">			if (nexthop-&gt;type == NEXTHOP_TYPE_IFINDEX ||</a>
<a name="ln239">			    nexthop-&gt;type == NEXTHOP_TYPE_IFNAME)</a>
<a name="ln240">			  break;</a>
<a name="ln241">		      if (nexthop)</a>
<a name="ln242">			break;</a>
<a name="ln243">		    }</a>
<a name="ln244">		}</a>
<a name="ln245">	      else</a>
<a name="ln246">		break;</a>
<a name="ln247">	    }</a>
<a name="ln248">	}</a>
<a name="ln249"> </a>
<a name="ln250">      if (compare_state(rib, rnh-&gt;state))</a>
<a name="ln251">	{</a>
<a name="ln252">	  if (IS_ZEBRA_DEBUG_NHT)</a>
<a name="ln253">	    {</a>
<a name="ln254">	      char bufn[INET6_ADDRSTRLEN];</a>
<a name="ln255">	      char bufp[INET6_ADDRSTRLEN];</a>
<a name="ln256">	      prefix2str(&amp;nrn-&gt;p, bufn, INET6_ADDRSTRLEN);</a>
<a name="ln257">	      if (prn)</a>
<a name="ln258">		prefix2str(&amp;prn-&gt;p, bufp, INET6_ADDRSTRLEN);</a>
<a name="ln259">	      else</a>
<a name="ln260">		strcpy(bufp, &quot;null&quot;);</a>
<a name="ln261">	      zlog_debug(&quot;rnh %s resolved through route %s - sending &quot;</a>
<a name="ln262">			 &quot;nexthop %s event to clients&quot;, bufn, bufp,</a>
<a name="ln263">			 rib ? &quot;reachable&quot; : &quot;unreachable&quot;);</a>
<a name="ln264">	    }</a>
<a name="ln265">	  copy_state(rnh, rib);</a>
<a name="ln266">	  for (ALL_LIST_ELEMENTS_RO(rnh-&gt;client_list, node, client))</a>
<a name="ln267">	    send_client(rnh, client, vrfid);</a>
<a name="ln268">	}</a>
<a name="ln269">    }</a>
<a name="ln270">  return 1;</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">int</a>
<a name="ln274">zebra_dispatch_rnh_table (vrf_id_t vrfid, int family, struct zserv *client)</a>
<a name="ln275">{</a>
<a name="ln276">  struct route_table *ntable;</a>
<a name="ln277">  struct route_node *nrn;</a>
<a name="ln278">  struct rnh *rnh;</a>
<a name="ln279"> </a>
<a name="ln280">  ntable = lookup_rnh_table(vrfid, family);</a>
<a name="ln281">  if (!ntable)</a>
<a name="ln282">    {</a>
<a name="ln283">      zlog_debug(&quot;dispatch_rnh_table: rnh table not found\n&quot;);</a>
<a name="ln284">      return -1;</a>
<a name="ln285">    }</a>
<a name="ln286"> </a>
<a name="ln287">  for (nrn = route_top (ntable); nrn; nrn = route_next (nrn))</a>
<a name="ln288">    {</a>
<a name="ln289">      if (!nrn-&gt;info)</a>
<a name="ln290">	  continue;</a>
<a name="ln291"> </a>
<a name="ln292">      rnh = nrn-&gt;info;</a>
<a name="ln293">      if (IS_ZEBRA_DEBUG_NHT)</a>
<a name="ln294">	{</a>
<a name="ln295">	  char bufn[INET6_ADDRSTRLEN];</a>
<a name="ln296">	  prefix2str(&amp;nrn-&gt;p, bufn, INET6_ADDRSTRLEN);</a>
<a name="ln297">	  zlog_debug(&quot;rnh %s - sending nexthop %s event to client %s&quot;, bufn,</a>
<a name="ln298">		     rnh-&gt;state ? &quot;reachable&quot; : &quot;unreachable&quot;,</a>
<a name="ln299">		     zebra_route_string(client-&gt;proto));</a>
<a name="ln300">	}</a>
<a name="ln301">      send_client(rnh, client, vrfid);</a>
<a name="ln302">    }</a>
<a name="ln303">  return 1;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">void</a>
<a name="ln307">zebra_print_rnh_table (vrf_id_t vrfid, int af, struct vty *vty)</a>
<a name="ln308">{</a>
<a name="ln309">  struct route_table *table;</a>
<a name="ln310">  struct route_node *rn;</a>
<a name="ln311"> </a>
<a name="ln312">  table = lookup_rnh_table(vrfid, af);</a>
<a name="ln313">  if (!table)</a>
<a name="ln314">    {</a>
<a name="ln315">      zlog_debug(&quot;print_rnhs: rnh table not found\n&quot;);</a>
<a name="ln316">      return;</a>
<a name="ln317">    }</a>
<a name="ln318"> </a>
<a name="ln319">  for (rn = route_top(table); rn; rn = route_next(rn))</a>
<a name="ln320">      if (rn-&gt;info)</a>
<a name="ln321">	print_rnh(rn, vty);</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">int</a>
<a name="ln325">zebra_cleanup_rnh_client (vrf_id_t vrfid, int family, struct zserv *client)</a>
<a name="ln326">{</a>
<a name="ln327">  struct route_table *ntable;</a>
<a name="ln328">  struct route_node *nrn;</a>
<a name="ln329">  struct rnh *rnh;</a>
<a name="ln330"> </a>
<a name="ln331">  ntable = lookup_rnh_table(vrfid, family);</a>
<a name="ln332">  if (!ntable)</a>
<a name="ln333">    {</a>
<a name="ln334">      zlog_debug(&quot;cleanup_rnh_client: rnh table not found\n&quot;);</a>
<a name="ln335">      return -1;</a>
<a name="ln336">    }</a>
<a name="ln337"> </a>
<a name="ln338">  for (nrn = route_top (ntable); nrn; nrn = route_next (nrn))</a>
<a name="ln339">    {</a>
<a name="ln340">      if (!nrn-&gt;info)</a>
<a name="ln341">	  continue;</a>
<a name="ln342"> </a>
<a name="ln343">      rnh = nrn-&gt;info;</a>
<a name="ln344">      if (IS_ZEBRA_DEBUG_NHT)</a>
<a name="ln345">	{</a>
<a name="ln346">	  char bufn[INET6_ADDRSTRLEN];</a>
<a name="ln347">	  prefix2str(&amp;nrn-&gt;p, bufn, INET6_ADDRSTRLEN);</a>
<a name="ln348">	  zlog_debug(&quot;rnh %s - cleaning state for client %s&quot;, bufn,</a>
<a name="ln349">		     zebra_route_string(client-&gt;proto));</a>
<a name="ln350">	}</a>
<a name="ln351">      zebra_remove_rnh_client(rnh, client);</a>
<a name="ln352">    }</a>
<a name="ln353">  return 1;</a>
<a name="ln354">}</a>
<a name="ln355"> </a>
<a name="ln356">/**</a>
<a name="ln357"> * free_state - free up the rib structure associated with the rnh.</a>
<a name="ln358"> */</a>
<a name="ln359">static void</a>
<a name="ln360">free_state (struct rib *rib)</a>
<a name="ln361">{</a>
<a name="ln362">  struct nexthop *nexthop, *next;</a>
<a name="ln363"> </a>
<a name="ln364">  if (!rib)</a>
<a name="ln365">    return;</a>
<a name="ln366"> </a>
<a name="ln367">  /* free RIB and nexthops */</a>
<a name="ln368">  for (nexthop = rib-&gt;nexthop; nexthop; nexthop = next)</a>
<a name="ln369">    {</a>
<a name="ln370">      next = nexthop-&gt;next;</a>
<a name="ln371">      nexthop_free (nexthop);</a>
<a name="ln372">    }</a>
<a name="ln373">  XFREE (MTYPE_RIB, rib);</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">/**</a>
<a name="ln377"> * copy_nexthop - copy a nexthop to the rib structure.</a>
<a name="ln378"> */</a>
<a name="ln379">static void</a>
<a name="ln380">rib_copy_nexthop (struct rib *state, struct nexthop *nh)</a>
<a name="ln381">{</a>
<a name="ln382">  struct nexthop *nexthop;</a>
<a name="ln383"> </a>
<a name="ln384">  nexthop = nexthop_new();</a>
<a name="ln385">  nexthop-&gt;flags = nh-&gt;flags;</a>
<a name="ln386">  nexthop-&gt;type = nh-&gt;type;</a>
<a name="ln387">  nexthop-&gt;ifindex = nh-&gt;ifindex;</a>
<a name="ln388">  if (nh-&gt;ifname)</a>
<a name="ln389">    nexthop-&gt;ifname = XSTRDUP(0, nh-&gt;ifname);</a>
<a name="ln390">  memcpy(&amp;(nexthop-&gt;gate), &amp;(nh-&gt;gate), sizeof(union g_addr));</a>
<a name="ln391">  memcpy(&amp;(nexthop-&gt;src), &amp;(nh-&gt;src), sizeof(union g_addr));</a>
<a name="ln392"> </a>
<a name="ln393">  rib_nexthop_add(state, nexthop);</a>
<a name="ln394">}</a>
<a name="ln395"> </a>
<a name="ln396">static void</a>
<a name="ln397">copy_state (struct rnh *rnh, struct rib *rib)</a>
<a name="ln398">{</a>
<a name="ln399">  struct rib *state;</a>
<a name="ln400">  struct nexthop *nh;</a>
<a name="ln401"> </a>
<a name="ln402">  if (rnh-&gt;state)</a>
<a name="ln403">    {</a>
<a name="ln404">      free_state(rnh-&gt;state);</a>
<a name="ln405">      rnh-&gt;state = NULL;</a>
<a name="ln406">    }</a>
<a name="ln407"> </a>
<a name="ln408">  if (!rib)</a>
<a name="ln409">    return;</a>
<a name="ln410"> </a>
<a name="ln411">  state = XCALLOC (MTYPE_RIB, sizeof (struct rib));</a>
<a name="ln412">  state-&gt;type = rib-&gt;type;</a>
<a name="ln413">  state-&gt;metric = rib-&gt;metric;</a>
<a name="ln414"> </a>
<a name="ln415">  for (nh = rib-&gt;nexthop; nh; nh = nh-&gt;next)</a>
<a name="ln416">    rib_copy_nexthop(state, nh);</a>
<a name="ln417">  rnh-&gt;state = state;</a>
<a name="ln418">}</a>
<a name="ln419"> </a>
<a name="ln420">static int</a>
<a name="ln421">compare_state (struct rib *r1, struct rib *r2)</a>
<a name="ln422">{</a>
<a name="ln423">  struct nexthop *nh1;</a>
<a name="ln424">  struct nexthop *nh2;</a>
<a name="ln425">  u_char found_nh = 0;</a>
<a name="ln426"> </a>
<a name="ln427">  if (!r1 &amp;&amp; !r2)</a>
<a name="ln428">    return 0;</a>
<a name="ln429"> </a>
<a name="ln430">  if ((!r1 &amp;&amp; r2) || (r1 &amp;&amp; !r2))</a>
<a name="ln431">      return 1;</a>
<a name="ln432"> </a>
<a name="ln433">  if (r1-&gt;metric != r2-&gt;metric)</a>
<a name="ln434">      return 1;</a>
<a name="ln435"> </a>
<a name="ln436">  if (r1-&gt;nexthop_num != r2-&gt;nexthop_num)</a>
<a name="ln437">      return 1;</a>
<a name="ln438"> </a>
<a name="ln439">  /* We need to verify that the nexthops for r1 match the nexthops for r2.</a>
<a name="ln440">   * Since it is possible for a rib entry to have the same nexthop multiple</a>
<a name="ln441">   * times (Example: [a,a]) we need to keep track of which r2 nexthops we have</a>
<a name="ln442">   * already used as a match against a r1 nexthop.  We track this</a>
<a name="ln443">   * via NEXTHOP_FLAG_MATCHED. Clear this flag for all r2 nexthops when you</a>
<a name="ln444">   * are finished.</a>
<a name="ln445">   *</a>
<a name="ln446">   * TRUE:  r1 [a,b], r2 [a,b]</a>
<a name="ln447">   * TRUE:  r1 [a,b], r2 [b,a]</a>
<a name="ln448">   * FALSE: r1 [a,b], r2 [a,c]</a>
<a name="ln449">   * FALSE: r1 [a,a], r2 [a,b]</a>
<a name="ln450">   */</a>
<a name="ln451">  for (nh1 = r1-&gt;nexthop; nh1; nh1 = nh1-&gt;next)</a>
<a name="ln452">    {</a>
<a name="ln453">      found_nh = 0;</a>
<a name="ln454">      for (nh2 = r2-&gt;nexthop; nh2; nh2 = nh2-&gt;next)</a>
<a name="ln455">        {</a>
<a name="ln456">          if (CHECK_FLAG (nh2-&gt;flags, NEXTHOP_FLAG_MATCHED))</a>
<a name="ln457">            continue;</a>
<a name="ln458"> </a>
<a name="ln459">          if (nexthop_same_no_recurse(nh1, nh2))</a>
<a name="ln460">            {</a>
<a name="ln461">              SET_FLAG (nh2-&gt;flags, NEXTHOP_FLAG_MATCHED);</a>
<a name="ln462">              found_nh = 1;</a>
<a name="ln463">              break;</a>
<a name="ln464">            }</a>
<a name="ln465">        }</a>
<a name="ln466"> </a>
<a name="ln467">      if (!found_nh)</a>
<a name="ln468">        {</a>
<a name="ln469">          for (nh2 = r2-&gt;nexthop; nh2; nh2 = nh2-&gt;next)</a>
<a name="ln470">            if (CHECK_FLAG (nh2-&gt;flags, NEXTHOP_FLAG_MATCHED))</a>
<a name="ln471">              UNSET_FLAG (nh2-&gt;flags, NEXTHOP_FLAG_MATCHED);</a>
<a name="ln472">          return 1;</a>
<a name="ln473">        }</a>
<a name="ln474">    }</a>
<a name="ln475"> </a>
<a name="ln476">  for (nh2 = r2-&gt;nexthop; nh2; nh2 = nh2-&gt;next)</a>
<a name="ln477">    if (CHECK_FLAG (nh2-&gt;flags, NEXTHOP_FLAG_MATCHED))</a>
<a name="ln478">      UNSET_FLAG (nh2-&gt;flags, NEXTHOP_FLAG_MATCHED);</a>
<a name="ln479"> </a>
<a name="ln480">  return 0;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">static int</a>
<a name="ln484">send_client (struct rnh *rnh, struct zserv *client, vrf_id_t vrf_id)</a>
<a name="ln485">{</a>
<a name="ln486">  struct stream *s;</a>
<a name="ln487">  struct rib *rib;</a>
<a name="ln488">  unsigned long nump;</a>
<a name="ln489">  u_char num;</a>
<a name="ln490">  struct nexthop *nexthop;</a>
<a name="ln491">  struct route_node *rn;</a>
<a name="ln492"> </a>
<a name="ln493">  rn = rnh-&gt;node;</a>
<a name="ln494">  rib = rnh-&gt;state;</a>
<a name="ln495"> </a>
<a name="ln496">  /* Get output stream. */</a>
<a name="ln497">  s = client-&gt;obuf;</a>
<a name="ln498">  stream_reset (s);</a>
<a name="ln499"> </a>
<a name="ln500">  zserv_create_header (s, ZEBRA_NEXTHOP_UPDATE, vrf_id);</a>
<a name="ln501"> </a>
<a name="ln502">  stream_putw(s, rn-&gt;p.family);</a>
<a name="ln503">  stream_put_prefix (s, &amp;rn-&gt;p);</a>
<a name="ln504"> </a>
<a name="ln505">  if (rib)</a>
<a name="ln506">    {</a>
<a name="ln507">      stream_putl (s, rib-&gt;metric);</a>
<a name="ln508">      num = 0;</a>
<a name="ln509">      nump = stream_get_endp(s);</a>
<a name="ln510">      stream_putc (s, 0);</a>
<a name="ln511">      for (nexthop = rib-&gt;nexthop; nexthop; nexthop = nexthop-&gt;next)</a>
<a name="ln512">	if (CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_FIB) &amp;&amp;</a>
<a name="ln513">            ! CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_RECURSIVE) &amp;&amp;</a>
<a name="ln514">	    CHECK_FLAG (nexthop-&gt;flags, NEXTHOP_FLAG_ACTIVE))</a>
<a name="ln515">	  {</a>
<a name="ln516">	    stream_putc (s, nexthop-&gt;type);</a>
<a name="ln517">	    switch (nexthop-&gt;type)</a>
<a name="ln518">	      {</a>
<a name="ln519">	      case ZEBRA_NEXTHOP_IPV4:</a>
<a name="ln520">		stream_put_in_addr (s, &amp;nexthop-&gt;gate.ipv4);</a>
<a name="ln521">		break;</a>
<a name="ln522">	      case ZEBRA_NEXTHOP_IFINDEX:</a>
<a name="ln523">	      case ZEBRA_NEXTHOP_IFNAME:</a>
<a name="ln524">		stream_putl (s, nexthop-&gt;ifindex);</a>
<a name="ln525">		break;</a>
<a name="ln526">	      case ZEBRA_NEXTHOP_IPV4_IFINDEX:</a>
<a name="ln527">	      case ZEBRA_NEXTHOP_IPV4_IFNAME:</a>
<a name="ln528">		stream_put_in_addr (s, &amp;nexthop-&gt;gate.ipv4);</a>
<a name="ln529">		stream_putl (s, nexthop-&gt;ifindex);</a>
<a name="ln530">		break;</a>
<a name="ln531">#ifdef HAVE_IPV6</a>
<a name="ln532">	      case ZEBRA_NEXTHOP_IPV6:</a>
<a name="ln533">		stream_put (s, &amp;nexthop-&gt;gate.ipv6, 16);</a>
<a name="ln534">		break;</a>
<a name="ln535">	      case ZEBRA_NEXTHOP_IPV6_IFINDEX:</a>
<a name="ln536">	      case ZEBRA_NEXTHOP_IPV6_IFNAME:</a>
<a name="ln537">		stream_put (s, &amp;nexthop-&gt;gate.ipv6, 16);</a>
<a name="ln538">		stream_putl (s, nexthop-&gt;ifindex);</a>
<a name="ln539">		break;</a>
<a name="ln540">#endif /* HAVE_IPV6 */</a>
<a name="ln541">	      default:</a>
<a name="ln542">                /* do nothing */</a>
<a name="ln543">		break;</a>
<a name="ln544">	      }</a>
<a name="ln545">	    num++;</a>
<a name="ln546">	  }</a>
<a name="ln547">      stream_putc_at (s, nump, num);</a>
<a name="ln548">    }</a>
<a name="ln549">  else</a>
<a name="ln550">    {</a>
<a name="ln551">      stream_putl (s, 0);</a>
<a name="ln552">      stream_putc (s, 0);</a>
<a name="ln553">    }</a>
<a name="ln554">  stream_putw_at (s, 0, stream_get_endp (s));</a>
<a name="ln555"> </a>
<a name="ln556">  client-&gt;nh_last_upd_time = quagga_time(NULL);</a>
<a name="ln557">  client-&gt;last_write_cmd = ZEBRA_NEXTHOP_UPDATE;</a>
<a name="ln558">  return zebra_server_send_message(client);</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">static void</a>
<a name="ln562">print_nh (struct nexthop *nexthop, struct vty *vty)</a>
<a name="ln563">{</a>
<a name="ln564">  char buf[BUFSIZ];</a>
<a name="ln565"> </a>
<a name="ln566">  switch (nexthop-&gt;type)</a>
<a name="ln567">    {</a>
<a name="ln568">    case NEXTHOP_TYPE_IPV4:</a>
<a name="ln569">    case NEXTHOP_TYPE_IPV4_IFINDEX:</a>
<a name="ln570">      vty_out (vty, &quot; via %s&quot;, inet_ntoa (nexthop-&gt;gate.ipv4));</a>
<a name="ln571">      if (nexthop-&gt;ifindex)</a>
<a name="ln572">	vty_out (vty, &quot;, %s&quot;, ifindex2ifname (nexthop-&gt;ifindex));</a>
<a name="ln573">      break;</a>
<a name="ln574">    case NEXTHOP_TYPE_IPV6:</a>
<a name="ln575">    case NEXTHOP_TYPE_IPV6_IFINDEX:</a>
<a name="ln576">    case NEXTHOP_TYPE_IPV6_IFNAME:</a>
<a name="ln577">      vty_out (vty, &quot; %s&quot;,</a>
<a name="ln578">	       inet_ntop (AF_INET6, &amp;nexthop-&gt;gate.ipv6, buf, BUFSIZ));</a>
<a name="ln579">      if (nexthop-&gt;type == NEXTHOP_TYPE_IPV6_IFNAME)</a>
<a name="ln580">	vty_out (vty, &quot;, %s&quot;, nexthop-&gt;ifname);</a>
<a name="ln581">      else if (nexthop-&gt;ifindex)</a>
<a name="ln582">	vty_out (vty, &quot;, via %s&quot;, ifindex2ifname (nexthop-&gt;ifindex));</a>
<a name="ln583">      break;</a>
<a name="ln584">    case NEXTHOP_TYPE_IFINDEX:</a>
<a name="ln585">      vty_out (vty, &quot; is directly connected, %s&quot;,</a>
<a name="ln586">	       ifindex2ifname (nexthop-&gt;ifindex));</a>
<a name="ln587">      break;</a>
<a name="ln588">    case NEXTHOP_TYPE_IFNAME:</a>
<a name="ln589">      vty_out (vty, &quot; is directly connected, %s&quot;, nexthop-&gt;ifname);</a>
<a name="ln590">      break;</a>
<a name="ln591">    case NEXTHOP_TYPE_BLACKHOLE:</a>
<a name="ln592">      vty_out (vty, &quot; is directly connected, Null0&quot;);</a>
<a name="ln593">      break;</a>
<a name="ln594">    default:</a>
<a name="ln595">      break;</a>
<a name="ln596">    }</a>
<a name="ln597">  vty_out(vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln598">}</a>
<a name="ln599"> </a>
<a name="ln600">static void</a>
<a name="ln601">print_rnh (struct route_node *rn, struct vty *vty)</a>
<a name="ln602">{</a>
<a name="ln603">  struct rnh *rnh;</a>
<a name="ln604">  struct nexthop *nexthop;</a>
<a name="ln605">  struct listnode *node;</a>
<a name="ln606">  struct zserv *client;</a>
<a name="ln607">  char buf[BUFSIZ];</a>
<a name="ln608"> </a>
<a name="ln609">  rnh = rn-&gt;info;</a>
<a name="ln610">  vty_out(vty, &quot;%s%s&quot;, inet_ntop(rn-&gt;p.family, &amp;rn-&gt;p.u.prefix, buf, BUFSIZ),</a>
<a name="ln611">	  VTY_NEWLINE);</a>
<a name="ln612">  if (rnh-&gt;state)</a>
<a name="ln613">    {</a>
<a name="ln614">      vty_out(vty, &quot; resolved via %s%s&quot;,</a>
<a name="ln615">	      zebra_route_string(rnh-&gt;state-&gt;type), VTY_NEWLINE);</a>
<a name="ln616">      for (nexthop = rnh-&gt;state-&gt;nexthop; nexthop; nexthop = nexthop-&gt;next)</a>
<a name="ln617">	print_nh(nexthop, vty);</a>
<a name="ln618">    }</a>
<a name="ln619">  else</a>
<a name="ln620">    vty_out(vty, &quot; unresolved%s%s&quot;,</a>
<a name="ln621">	    CHECK_FLAG(rnh-&gt;flags, ZEBRA_NHT_CONNECTED) ? &quot;(Connected)&quot; : &quot;&quot;,</a>
<a name="ln622">	    VTY_NEWLINE);</a>
<a name="ln623"> </a>
<a name="ln624">  vty_out(vty, &quot; Client list:&quot;);</a>
<a name="ln625">  for (ALL_LIST_ELEMENTS_RO(rnh-&gt;client_list, node, client))</a>
<a name="ln626">    vty_out(vty, &quot; %s(fd %d)&quot;, zebra_route_string(client-&gt;proto),</a>
<a name="ln627">	    client-&gt;sock);</a>
<a name="ln628">  vty_out(vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln629">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="430"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v728/" target="_blank">V728</a> An excessive check can be simplified. The '(A && !B) || (!A && B)' expression is equivalent to the 'bool(A) != bool(B)' expression.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
