
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=windows-1256" />
  <title>irdp_main.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> *</a>
<a name="ln3"> * Copyright (C) 2000  Robert Olsson.</a>
<a name="ln4"> * Swedish University of Agricultural Sciences</a>
<a name="ln5"> *</a>
<a name="ln6"> * This file is part of GNU Zebra.</a>
<a name="ln7"> *</a>
<a name="ln8"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln9"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln10"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln11"> * later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln14"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public License</a>
<a name="ln19"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln20"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln21"> * 02111-1307, USA.  </a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">/* </a>
<a name="ln25"> * This work includes work with the following copywrite:</a>
<a name="ln26"> *</a>
<a name="ln27"> * Copyright (C) 1997, 2000 Kunihiro Ishiguro</a>
<a name="ln28"> *</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31">/* </a>
<a name="ln32"> * Thanks to Jens Låås at Swedish University of Agricultural Sciences</a>
<a name="ln33"> * for reviewing and tests.</a>
<a name="ln34"> */</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;zebra.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39">#ifdef HAVE_IRDP</a>
<a name="ln40"> </a>
<a name="ln41">#include &quot;if.h&quot;</a>
<a name="ln42">#include &quot;vty.h&quot;</a>
<a name="ln43">#include &quot;sockunion.h&quot;</a>
<a name="ln44">#include &quot;sockopt.h&quot;</a>
<a name="ln45">#include &quot;prefix.h&quot;</a>
<a name="ln46">#include &quot;command.h&quot;</a>
<a name="ln47">#include &quot;memory.h&quot;</a>
<a name="ln48">#include &quot;stream.h&quot;</a>
<a name="ln49">#include &quot;ioctl.h&quot;</a>
<a name="ln50">#include &quot;connected.h&quot;</a>
<a name="ln51">#include &quot;log.h&quot;</a>
<a name="ln52">#include &quot;zclient.h&quot;</a>
<a name="ln53">#include &quot;thread.h&quot;</a>
<a name="ln54">#include &quot;privs.h&quot;</a>
<a name="ln55">#include &quot;zebra/interface.h&quot;</a>
<a name="ln56">#include &quot;zebra/rtadv.h&quot;</a>
<a name="ln57">#include &quot;zebra/rib.h&quot;</a>
<a name="ln58">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln59">#include &quot;zebra/redistribute.h&quot;</a>
<a name="ln60">#include &quot;zebra/irdp.h&quot;</a>
<a name="ln61">#include &lt;netinet/ip_icmp.h&gt;</a>
<a name="ln62"> </a>
<a name="ln63">#include &quot;checksum.h&quot;</a>
<a name="ln64">#include &quot;if.h&quot;</a>
<a name="ln65">#include &quot;sockunion.h&quot;</a>
<a name="ln66">#include &quot;log.h&quot;</a>
<a name="ln67"> </a>
<a name="ln68">/* GLOBAL VARS */</a>
<a name="ln69"> </a>
<a name="ln70">extern struct zebra_privs_t zserv_privs;</a>
<a name="ln71"> </a>
<a name="ln72">/* Master of threads. */</a>
<a name="ln73">extern struct zebra_t zebrad;</a>
<a name="ln74">struct thread *t_irdp_raw;</a>
<a name="ln75"> </a>
<a name="ln76">/* Timer interval of irdp. */</a>
<a name="ln77">int irdp_timer_interval = IRDP_DEFAULT_INTERVAL;</a>
<a name="ln78"> </a>
<a name="ln79">int</a>
<a name="ln80">irdp_sock_init (void)</a>
<a name="ln81">{</a>
<a name="ln82">  int ret, i;</a>
<a name="ln83">  int save_errno;</a>
<a name="ln84">  int sock;</a>
<a name="ln85"> </a>
<a name="ln86">  if ( zserv_privs.change (ZPRIVS_RAISE) )</a>
<a name="ln87">       zlog_err (&quot;irdp_sock_init: could not raise privs, %s&quot;,</a>
<a name="ln88">                  safe_strerror (errno) );</a>
<a name="ln89"> </a>
<a name="ln90">  sock = socket (AF_INET, SOCK_RAW, IPPROTO_ICMP);</a>
<a name="ln91">  save_errno = errno;</a>
<a name="ln92"> </a>
<a name="ln93">  if ( zserv_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln94">       zlog_err (&quot;irdp_sock_init: could not lower privs, %s&quot;,</a>
<a name="ln95">             safe_strerror (errno) );</a>
<a name="ln96"> </a>
<a name="ln97">  if (sock &lt; 0) {</a>
<a name="ln98">    zlog_warn (&quot;IRDP: can't create irdp socket %s&quot;, safe_strerror(save_errno));</a>
<a name="ln99">    return sock;</a>
<a name="ln100">  };</a>
<a name="ln101">  </a>
<a name="ln102">  i = 1;</a>
<a name="ln103">  ret = setsockopt (sock, IPPROTO_IP, IP_TTL, </a>
<a name="ln104">                        (void *) &amp;i, sizeof (i));</a>
<a name="ln105">  if (ret &lt; 0) {</a>
<a name="ln106">    zlog_warn (&quot;IRDP: can't do irdp sockopt %s&quot;, safe_strerror(errno));</a>
<a name="ln107">    close(sock);</a>
<a name="ln108">    return ret;</a>
<a name="ln109">  };</a>
<a name="ln110">  </a>
<a name="ln111">  ret = setsockopt_ifindex (AF_INET, sock, 1);</a>
<a name="ln112">  if (ret &lt; 0) {</a>
<a name="ln113">    zlog_warn (&quot;IRDP: can't do irdp sockopt %s&quot;, safe_strerror(errno));</a>
<a name="ln114">    close(sock);</a>
<a name="ln115">    return ret;</a>
<a name="ln116">  };</a>
<a name="ln117"> </a>
<a name="ln118">  t_irdp_raw = thread_add_read (zebrad.master, irdp_read_raw, NULL, sock); </a>
<a name="ln119"> </a>
<a name="ln120">  return sock;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123"> </a>
<a name="ln124">static int</a>
<a name="ln125">get_pref(struct irdp_interface *irdp, struct prefix *p)</a>
<a name="ln126">{</a>
<a name="ln127">  struct listnode *node;</a>
<a name="ln128">  struct Adv *adv;</a>
<a name="ln129"> </a>
<a name="ln130">  /* Use default preference or use the override pref */</a>
<a name="ln131">  </a>
<a name="ln132">  if( irdp-&gt;AdvPrefList == NULL )</a>
<a name="ln133">    return irdp-&gt;Preference;</a>
<a name="ln134">  </a>
<a name="ln135">  for (ALL_LIST_ELEMENTS_RO (irdp-&gt;AdvPrefList, node, adv))</a>
<a name="ln136">    if( p-&gt;u.prefix4.s_addr == adv-&gt;ip.s_addr )</a>
<a name="ln137">      return adv-&gt;pref;</a>
<a name="ln138"> </a>
<a name="ln139">  return irdp-&gt;Preference;</a>
<a name="ln140">}</a>
<a name="ln141"> </a>
<a name="ln142">/* Make ICMP Router Advertisement Message. */</a>
<a name="ln143">static int</a>
<a name="ln144">make_advertisement_packet (struct interface *ifp, </a>
<a name="ln145">			   struct prefix *p,</a>
<a name="ln146">			   struct stream *s)</a>
<a name="ln147">{</a>
<a name="ln148">  struct zebra_if *zi=ifp-&gt;info;</a>
<a name="ln149">  struct irdp_interface *irdp=&amp;zi-&gt;irdp;</a>
<a name="ln150">  int size;</a>
<a name="ln151">  int pref;</a>
<a name="ln152">  u_int16_t checksum;</a>
<a name="ln153"> </a>
<a name="ln154">  pref =  get_pref(irdp, p);</a>
<a name="ln155"> </a>
<a name="ln156">  stream_putc (s, ICMP_ROUTERADVERT); /* Type. */</a>
<a name="ln157">  stream_putc (s, 0);		/* Code. */</a>
<a name="ln158">  stream_putw (s, 0);		/* Checksum. */</a>
<a name="ln159">  stream_putc (s, 1);		/* Num address. */</a>
<a name="ln160">  stream_putc (s, 2);		/* Address Entry Size. */</a>
<a name="ln161"> </a>
<a name="ln162">  if(irdp-&gt;flags &amp; IF_SHUTDOWN)  </a>
<a name="ln163">    stream_putw (s, 0);</a>
<a name="ln164">  else </a>
<a name="ln165">    stream_putw (s, irdp-&gt;Lifetime);</a>
<a name="ln166"> </a>
<a name="ln167">  stream_putl (s, htonl(p-&gt;u.prefix4.s_addr)); /* Router address. */</a>
<a name="ln168">  stream_putl (s, pref);</a>
<a name="ln169"> </a>
<a name="ln170">  /* in_cksum return network byte order value */</a>
<a name="ln171">  size = 16;</a>
<a name="ln172">  checksum = in_cksum (s-&gt;data, size);</a>
<a name="ln173">  stream_putw_at (s, 2, htons(checksum));</a>
<a name="ln174"> </a>
<a name="ln175">  return size;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">static void</a>
<a name="ln179">irdp_send(struct interface *ifp, struct prefix *p, struct stream *s)</a>
<a name="ln180">{</a>
<a name="ln181">  struct zebra_if *zi=ifp-&gt;info;</a>
<a name="ln182">  struct irdp_interface *irdp=&amp;zi-&gt;irdp;</a>
<a name="ln183">  char buf[PREFIX_STRLEN];</a>
<a name="ln184">  u_int32_t dst;</a>
<a name="ln185">  u_int32_t ttl=1;</a>
<a name="ln186"> </a>
<a name="ln187">  if (! (ifp-&gt;flags &amp; IFF_UP)) return; </a>
<a name="ln188"> </a>
<a name="ln189">  if (irdp-&gt;flags &amp; IF_BROADCAST) </a>
<a name="ln190">    dst =INADDR_BROADCAST ;</a>
<a name="ln191">  else </a>
<a name="ln192">    dst = htonl(INADDR_ALLHOSTS_GROUP);</a>
<a name="ln193"> </a>
<a name="ln194">  if(irdp-&gt;flags &amp; IF_DEBUG_MESSAGES) </a>
<a name="ln195">    zlog_debug(&quot;IRDP: TX Advert on %s %s Holdtime=%d Preference=%d&quot;,</a>
<a name="ln196">	      ifp-&gt;name,</a>
<a name="ln197">	      prefix2str(p, buf, sizeof buf),</a>
<a name="ln198">	      irdp-&gt;flags &amp; IF_SHUTDOWN? 0 : irdp-&gt;Lifetime,</a>
<a name="ln199">	      get_pref(irdp, p));</a>
<a name="ln200"> </a>
<a name="ln201">  send_packet (ifp, s, dst, p, ttl);</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">static void irdp_advertisement (struct interface *ifp, struct prefix *p)</a>
<a name="ln205">{</a>
<a name="ln206">  struct stream *s;</a>
<a name="ln207">  s = stream_new (128);</a>
<a name="ln208">  make_advertisement_packet (ifp, p, s);</a>
<a name="ln209">  irdp_send(ifp, p, s);</a>
<a name="ln210">  stream_free (s);</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">int irdp_send_thread(struct thread *t_advert)</a>
<a name="ln214">{</a>
<a name="ln215">  u_int32_t timer, tmp;</a>
<a name="ln216">  struct interface *ifp = THREAD_ARG (t_advert);</a>
<a name="ln217">  struct zebra_if *zi=ifp-&gt;info;</a>
<a name="ln218">  struct irdp_interface *irdp=&amp;zi-&gt;irdp;</a>
<a name="ln219">  struct prefix *p;</a>
<a name="ln220">  struct listnode *node, *nnode;</a>
<a name="ln221">  struct connected *ifc;</a>
<a name="ln222"> </a>
<a name="ln223">  irdp-&gt;flags &amp;= ~IF_SOLICIT;</a>
<a name="ln224"> </a>
<a name="ln225">  if(ifp-&gt;connected) </a>
<a name="ln226">    for (ALL_LIST_ELEMENTS (ifp-&gt;connected, node, nnode, ifc))</a>
<a name="ln227">      {</a>
<a name="ln228">        p = ifc-&gt;address;</a>
<a name="ln229">        </a>
<a name="ln230">        if (p-&gt;family != AF_INET)</a>
<a name="ln231">          continue;</a>
<a name="ln232">        </a>
<a name="ln233">        irdp_advertisement(ifp, p);</a>
<a name="ln234">        irdp-&gt;irdp_sent++;</a>
<a name="ln235">      }</a>
<a name="ln236"> </a>
<a name="ln237">  tmp = irdp-&gt;MaxAdvertInterval-irdp-&gt;MinAdvertInterval;</a>
<a name="ln238">  timer =  (random () % tmp ) + 1;</a>
<a name="ln239">  timer = irdp-&gt;MinAdvertInterval + timer;</a>
<a name="ln240"> </a>
<a name="ln241">  if(irdp-&gt;irdp_sent &lt;  MAX_INITIAL_ADVERTISEMENTS &amp;&amp;</a>
<a name="ln242">     timer &gt; MAX_INITIAL_ADVERT_INTERVAL ) </a>
<a name="ln243">	  timer= MAX_INITIAL_ADVERT_INTERVAL;</a>
<a name="ln244"> </a>
<a name="ln245">  if(irdp-&gt;flags &amp; IF_DEBUG_MISC)</a>
<a name="ln246">    zlog_debug(&quot;IRDP: New timer for %s set to %u\n&quot;, ifp-&gt;name, timer);</a>
<a name="ln247"> </a>
<a name="ln248">  irdp-&gt;t_advertise = thread_add_timer(zebrad.master, irdp_send_thread, ifp, timer);</a>
<a name="ln249">  return 0;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">void irdp_advert_off(struct interface *ifp)</a>
<a name="ln253">{</a>
<a name="ln254">  struct zebra_if *zi=ifp-&gt;info;</a>
<a name="ln255">  struct irdp_interface *irdp=&amp;zi-&gt;irdp;</a>
<a name="ln256">  struct listnode *node, *nnode;</a>
<a name="ln257">  int i;</a>
<a name="ln258">  struct connected *ifc;</a>
<a name="ln259">  struct prefix *p;</a>
<a name="ln260"> </a>
<a name="ln261">  if(irdp-&gt;t_advertise)  thread_cancel(irdp-&gt;t_advertise);</a>
<a name="ln262">  irdp-&gt;t_advertise = NULL;</a>
<a name="ln263">  </a>
<a name="ln264">  if(ifp-&gt;connected) </a>
<a name="ln265">    for (ALL_LIST_ELEMENTS (ifp-&gt;connected, node, nnode, ifc))</a>
<a name="ln266">      {</a>
<a name="ln267">        p = ifc-&gt;address;</a>
<a name="ln268"> </a>
<a name="ln269">        /* Output some packets with Lifetime 0 </a>
<a name="ln270">           we should add a wait...</a>
<a name="ln271">        */</a>
<a name="ln272"> </a>
<a name="ln273">        for(i=0; i&lt; IRDP_LAST_ADVERT_MESSAGES; i++) </a>
<a name="ln274">          {</a>
<a name="ln275">            irdp-&gt;irdp_sent++;</a>
<a name="ln276">            irdp_advertisement(ifp, p);</a>
<a name="ln277">          }</a>
<a name="ln278">      }</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">void process_solicit (struct interface *ifp)</a>
<a name="ln283">{</a>
<a name="ln284">  struct zebra_if *zi=ifp-&gt;info;</a>
<a name="ln285">  struct irdp_interface *irdp=&amp;zi-&gt;irdp;</a>
<a name="ln286">  u_int32_t timer;</a>
<a name="ln287"> </a>
<a name="ln288">  /* When SOLICIT is active we reject further incoming solicits </a>
<a name="ln289">     this keeps down the answering rate so we don't have think</a>
<a name="ln290">     about DoS attacks here. */</a>
<a name="ln291"> </a>
<a name="ln292">  if( irdp-&gt;flags &amp; IF_SOLICIT) return;</a>
<a name="ln293"> </a>
<a name="ln294">  irdp-&gt;flags |= IF_SOLICIT;</a>
<a name="ln295">  if(irdp-&gt;t_advertise)  thread_cancel(irdp-&gt;t_advertise);</a>
<a name="ln296">  irdp-&gt;t_advertise = NULL;</a>
<a name="ln297"> </a>
<a name="ln298">  timer =  (random () % MAX_RESPONSE_DELAY) + 1;</a>
<a name="ln299"> </a>
<a name="ln300">  irdp-&gt;t_advertise = thread_add_timer(zebrad.master, </a>
<a name="ln301">				       irdp_send_thread, </a>
<a name="ln302">				       ifp, </a>
<a name="ln303">				       timer);</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">void irdp_finish()</a>
<a name="ln307">{</a>
<a name="ln308"> </a>
<a name="ln309">  struct listnode *node, *nnode;</a>
<a name="ln310">  struct interface *ifp;</a>
<a name="ln311">  struct zebra_if *zi;</a>
<a name="ln312">  struct irdp_interface *irdp;</a>
<a name="ln313"> </a>
<a name="ln314">  zlog_info(&quot;IRDP: Received shutdown notification.&quot;);</a>
<a name="ln315">  </a>
<a name="ln316">  for (ALL_LIST_ELEMENTS (iflist, node, nnode, ifp))</a>
<a name="ln317">    {</a>
<a name="ln318">      zi = ifp-&gt;info;</a>
<a name="ln319">      </a>
<a name="ln320">      if (!zi) </a>
<a name="ln321">        continue;</a>
<a name="ln322">      irdp = &amp;zi-&gt;irdp;</a>
<a name="ln323">      if (!irdp) </a>
<a name="ln324">        continue;</a>
<a name="ln325"> </a>
<a name="ln326">      if (irdp-&gt;flags &amp; IF_ACTIVE ) </a>
<a name="ln327">        {</a>
<a name="ln328">	  irdp-&gt;flags |= IF_SHUTDOWN;</a>
<a name="ln329">	  irdp_advert_off(ifp);</a>
<a name="ln330">        }</a>
<a name="ln331">    }</a>
<a name="ln332">}</a>
<a name="ln333"> </a>
<a name="ln334">#endif /* HAVE_IRDP */</a>

</code></pre>
<div class="balloon" rel="9"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="323"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!irdp' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
