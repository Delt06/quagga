
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_sock.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24">#include &quot;pim_mroute.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;sys/types.h&gt;</a>
<a name="ln27">#include &lt;sys/socket.h&gt;</a>
<a name="ln28">#include &lt;netinet/in.h&gt;</a>
<a name="ln29">#include &lt;netinet/igmp.h&gt;</a>
<a name="ln30">#include &lt;arpa/inet.h&gt;</a>
<a name="ln31">#include &lt;unistd.h&gt;</a>
<a name="ln32">#include &lt;netdb.h&gt;</a>
<a name="ln33">#include &lt;errno.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;log.h&quot;</a>
<a name="ln36">#include &quot;privs.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38">#include &quot;pimd.h&quot;</a>
<a name="ln39">#include &quot;pim_sock.h&quot;</a>
<a name="ln40">#include &quot;pim_str.h&quot;</a>
<a name="ln41">#include &quot;pim_igmp_join.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">/* GLOBAL VARS */</a>
<a name="ln44">extern struct zebra_privs_t pimd_privs;</a>
<a name="ln45"> </a>
<a name="ln46">int pim_socket_raw(int protocol)</a>
<a name="ln47">{</a>
<a name="ln48">  int fd;</a>
<a name="ln49"> </a>
<a name="ln50">  if ( pimd_privs.change (ZPRIVS_RAISE) )</a>
<a name="ln51">       zlog_err (&quot;pim_sockek_raw: could not raise privs, %s&quot;,</a>
<a name="ln52">                 safe_strerror (errno) );</a>
<a name="ln53"> </a>
<a name="ln54">  fd = socket(AF_INET, SOCK_RAW, protocol);</a>
<a name="ln55"> </a>
<a name="ln56">  if ( pimd_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln57">       zlog_err (&quot;pim_socket_raw: could not lower privs, %s&quot;,</a>
<a name="ln58">                 safe_strerror (errno) );</a>
<a name="ln59"> </a>
<a name="ln60">  if (fd &lt; 0) {</a>
<a name="ln61">    zlog_warn(&quot;Could not create raw socket: errno=%d: %s&quot;,</a>
<a name="ln62">	      errno, safe_strerror(errno));</a>
<a name="ln63">    return PIM_SOCK_ERR_SOCKET;</a>
<a name="ln64">  }</a>
<a name="ln65">  </a>
<a name="ln66">  return fd;</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">int pim_socket_mcast(int protocol, struct in_addr ifaddr, int loop)</a>
<a name="ln70">{</a>
<a name="ln71">  int fd;</a>
<a name="ln72"> </a>
<a name="ln73">  fd = pim_socket_raw(protocol);</a>
<a name="ln74">  if (fd &lt; 0) {</a>
<a name="ln75">    zlog_warn(&quot;Could not create multicast socket: errno=%d: %s&quot;,</a>
<a name="ln76">	      errno, safe_strerror(errno));</a>
<a name="ln77">    return PIM_SOCK_ERR_SOCKET;</a>
<a name="ln78">  }</a>
<a name="ln79"> </a>
<a name="ln80">  /* Needed to obtain destination address from recvmsg() */</a>
<a name="ln81">  {</a>
<a name="ln82">#if defined(HAVE_IP_PKTINFO)</a>
<a name="ln83">    /* Linux and Solaris IP_PKTINFO */</a>
<a name="ln84">    int opt = 1;</a>
<a name="ln85">    if (setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &amp;opt, sizeof(opt))) {</a>
<a name="ln86">      zlog_warn(&quot;Could not set IP_PKTINFO on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln87">		fd, errno, safe_strerror(errno));</a>
<a name="ln88">    }</a>
<a name="ln89">#elif defined(HAVE_IP_RECVDSTADDR)</a>
<a name="ln90">    /* BSD IP_RECVDSTADDR */</a>
<a name="ln91">    int opt = 1;</a>
<a name="ln92">    if (setsockopt(fd, IPPROTO_IP, IP_RECVDSTADDR, &amp;opt, sizeof(opt))) {</a>
<a name="ln93">      zlog_warn(&quot;Could not set IP_RECVDSTADDR on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln94">		fd, errno, safe_strerror(errno));</a>
<a name="ln95">    }</a>
<a name="ln96">#else</a>
<a name="ln97">    zlog_err(&quot;%s %s: Missing IP_PKTINFO and IP_RECVDSTADDR: unable to get dst addr from recvmsg()&quot;,</a>
<a name="ln98">	     __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln99">    close(fd);</a>
<a name="ln100">    return PIM_SOCK_ERR_DSTADDR;</a>
<a name="ln101">#endif</a>
<a name="ln102">  }</a>
<a name="ln103"> </a>
<a name="ln104">  </a>
<a name="ln105">  /* Set router alert (RFC 2113) for all IGMP messages (RFC 3376 4. Message Formats)*/</a>
<a name="ln106">  if (protocol == IPPROTO_IGMP) {</a>
<a name="ln107">    char ra[4];</a>
<a name="ln108">    ra[0] = 148;</a>
<a name="ln109">    ra[1] = 4;</a>
<a name="ln110">    ra[2] = 0;</a>
<a name="ln111">    ra[3] = 0;</a>
<a name="ln112">    if (setsockopt(fd, IPPROTO_IP, IP_OPTIONS, ra, 4)) {</a>
<a name="ln113">      zlog_warn(&quot;Could not set Router Alert Option on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln114">		fd, errno, safe_strerror(errno));</a>
<a name="ln115">      close(fd);</a>
<a name="ln116">      return PIM_SOCK_ERR_RA;</a>
<a name="ln117">    }</a>
<a name="ln118">  }</a>
<a name="ln119"> </a>
<a name="ln120">  {</a>
<a name="ln121">    int reuse = 1;</a>
<a name="ln122">    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,</a>
<a name="ln123">		   (void *) &amp;reuse, sizeof(reuse))) {</a>
<a name="ln124">      zlog_warn(&quot;Could not set Reuse Address Option on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln125">		fd, errno, safe_strerror(errno));</a>
<a name="ln126">      close(fd);</a>
<a name="ln127">      return PIM_SOCK_ERR_REUSE;</a>
<a name="ln128">    }</a>
<a name="ln129">  }</a>
<a name="ln130"> </a>
<a name="ln131">  {</a>
<a name="ln132">    const int MTTL = 1;</a>
<a name="ln133">    int ttl = MTTL;</a>
<a name="ln134">    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,</a>
<a name="ln135">		   (void *) &amp;ttl, sizeof(ttl))) {</a>
<a name="ln136">      zlog_warn(&quot;Could not set multicast TTL=%d on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln137">		MTTL, fd, errno, safe_strerror(errno));</a>
<a name="ln138">      close(fd);</a>
<a name="ln139">      return PIM_SOCK_ERR_TTL;</a>
<a name="ln140">    }</a>
<a name="ln141">  }</a>
<a name="ln142"> </a>
<a name="ln143">  if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,</a>
<a name="ln144">		 (void *) &amp;loop, sizeof(loop))) {</a>
<a name="ln145">    zlog_warn(&quot;Could not %s Multicast Loopback Option on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln146">	      loop ? &quot;enable&quot; : &quot;disable&quot;,</a>
<a name="ln147">	      fd, errno, safe_strerror(errno));</a>
<a name="ln148">    close(fd);</a>
<a name="ln149">    return PIM_SOCK_ERR_LOOP;</a>
<a name="ln150">  }</a>
<a name="ln151"> </a>
<a name="ln152">  if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,</a>
<a name="ln153">		 (void *) &amp;ifaddr, sizeof(ifaddr))) {</a>
<a name="ln154">    zlog_warn(&quot;Could not set Outgoing Interface Option on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln155">	      fd, errno, safe_strerror(errno));</a>
<a name="ln156">    close(fd);</a>
<a name="ln157">    return PIM_SOCK_ERR_IFACE;</a>
<a name="ln158">  }</a>
<a name="ln159"> </a>
<a name="ln160">  {</a>
<a name="ln161">    long flags;</a>
<a name="ln162"> </a>
<a name="ln163">    flags = fcntl(fd, F_GETFL, 0);</a>
<a name="ln164">    if (flags &lt; 0) {</a>
<a name="ln165">      zlog_warn(&quot;Could not get fcntl(F_GETFL,O_NONBLOCK) on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln166">		fd, errno, safe_strerror(errno));</a>
<a name="ln167">      close(fd);</a>
<a name="ln168">      return PIM_SOCK_ERR_NONBLOCK_GETFL;</a>
<a name="ln169">    }</a>
<a name="ln170"> </a>
<a name="ln171">    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK)) {</a>
<a name="ln172">      zlog_warn(&quot;Could not set fcntl(F_SETFL,O_NONBLOCK) on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln173">		fd, errno, safe_strerror(errno));</a>
<a name="ln174">      close(fd);</a>
<a name="ln175">      return PIM_SOCK_ERR_NONBLOCK_SETFL;</a>
<a name="ln176">    }</a>
<a name="ln177">  }</a>
<a name="ln178"> </a>
<a name="ln179">  return fd;</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">int pim_socket_join(int fd, struct in_addr group,</a>
<a name="ln183">		    struct in_addr ifaddr, ifindex_t ifindex)</a>
<a name="ln184">{</a>
<a name="ln185">  int ret;</a>
<a name="ln186"> </a>
<a name="ln187">#ifdef HAVE_STRUCT_IP_MREQN_IMR_IFINDEX</a>
<a name="ln188">  struct ip_mreqn opt;</a>
<a name="ln189">#else</a>
<a name="ln190">  struct ip_mreq opt;</a>
<a name="ln191">#endif</a>
<a name="ln192"> </a>
<a name="ln193">  opt.imr_multiaddr = group;</a>
<a name="ln194"> </a>
<a name="ln195">#ifdef HAVE_STRUCT_IP_MREQN_IMR_IFINDEX</a>
<a name="ln196">  opt.imr_address   = ifaddr;</a>
<a name="ln197">  opt.imr_ifindex   = ifindex;</a>
<a name="ln198">#else</a>
<a name="ln199">  opt.imr_interface = ifaddr;</a>
<a name="ln200">#endif</a>
<a name="ln201"> </a>
<a name="ln202">  ret = setsockopt(fd, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;opt, sizeof(opt));</a>
<a name="ln203">  if (ret) {</a>
<a name="ln204">    char group_str[100];</a>
<a name="ln205">    char ifaddr_str[100];</a>
<a name="ln206">    if (!inet_ntop(AF_INET, &amp;group, group_str , sizeof(group_str)))</a>
<a name="ln207">      sprintf(group_str, &quot;&lt;group?&gt;&quot;);</a>
<a name="ln208">    if (!inet_ntop(AF_INET, &amp;ifaddr, ifaddr_str , sizeof(ifaddr_str)))</a>
<a name="ln209">      sprintf(ifaddr_str, &quot;&lt;ifaddr?&gt;&quot;);</a>
<a name="ln210"> </a>
<a name="ln211">    zlog_err(&quot;Failure socket joining fd=%d group %s on interface address %s: errno=%d: %s&quot;,</a>
<a name="ln212">	     fd, group_str, ifaddr_str, errno, safe_strerror(errno));</a>
<a name="ln213">    return ret;</a>
<a name="ln214">  }</a>
<a name="ln215"> </a>
<a name="ln216">  if (PIM_DEBUG_TRACE) {</a>
<a name="ln217">    char group_str[100];</a>
<a name="ln218">    char ifaddr_str[100];</a>
<a name="ln219">    if (!inet_ntop(AF_INET, &amp;group, group_str , sizeof(group_str)))</a>
<a name="ln220">      sprintf(group_str, &quot;&lt;group?&gt;&quot;);</a>
<a name="ln221">    if (!inet_ntop(AF_INET, &amp;ifaddr, ifaddr_str , sizeof(ifaddr_str)))</a>
<a name="ln222">      sprintf(ifaddr_str, &quot;&lt;ifaddr?&gt;&quot;);</a>
<a name="ln223"> </a>
<a name="ln224">    zlog_debug(&quot;Socket fd=%d joined group %s on interface address %s&quot;,</a>
<a name="ln225">	       fd, group_str, ifaddr_str);</a>
<a name="ln226">  }</a>
<a name="ln227"> </a>
<a name="ln228">  return ret;</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">int pim_socket_join_source(int fd, ifindex_t ifindex,</a>
<a name="ln232">			   struct in_addr group_addr,</a>
<a name="ln233">			   struct in_addr source_addr,</a>
<a name="ln234">			   const char *ifname)</a>
<a name="ln235">{</a>
<a name="ln236">  if (pim_igmp_join_source(fd, ifindex, group_addr, source_addr)) {</a>
<a name="ln237">    int e = errno;</a>
<a name="ln238">    char group_str[100];</a>
<a name="ln239">    char source_str[100];</a>
<a name="ln240">    pim_inet4_dump(&quot;&lt;grp?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln241">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln242">    zlog_warn(&quot;%s: setsockopt(fd=%d) failure for IGMP group %s source %s ifindex %d on interface %s: errno=%d: %s&quot;,</a>
<a name="ln243">	      __PRETTY_FUNCTION__,</a>
<a name="ln244">	      fd, group_str, source_str, ifindex, ifname,</a>
<a name="ln245">	      e, safe_strerror(e));</a>
<a name="ln246">    return -1;</a>
<a name="ln247">  }</a>
<a name="ln248"> </a>
<a name="ln249">  return 0;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">int pim_socket_recvfromto(int fd, uint8_t *buf, size_t len,</a>
<a name="ln253">			  struct sockaddr_in *from, socklen_t *fromlen,</a>
<a name="ln254">			  struct sockaddr_in *to, socklen_t *tolen,</a>
<a name="ln255">			  ifindex_t *ifindex)</a>
<a name="ln256">{</a>
<a name="ln257">  struct msghdr msgh;</a>
<a name="ln258">  struct cmsghdr *cmsg;</a>
<a name="ln259">  struct iovec iov;</a>
<a name="ln260">  char cbuf[1000];</a>
<a name="ln261">  int err;</a>
<a name="ln262"> </a>
<a name="ln263">  /*</a>
<a name="ln264">   * IP_PKTINFO / IP_RECVDSTADDR don't yield sin_port.</a>
<a name="ln265">   * Use getsockname() to get sin_port.</a>
<a name="ln266">   */</a>
<a name="ln267">  if (to) {</a>
<a name="ln268">    struct sockaddr_in si;</a>
<a name="ln269">    socklen_t si_len = sizeof(si);</a>
<a name="ln270">    </a>
<a name="ln271">    ((struct sockaddr_in *) to)-&gt;sin_family = AF_INET;</a>
<a name="ln272"> </a>
<a name="ln273">    if (pim_socket_getsockname(fd, (struct sockaddr *) &amp;si, &amp;si_len)) {</a>
<a name="ln274">      ((struct sockaddr_in *) to)-&gt;sin_port        = ntohs(0);</a>
<a name="ln275">      ((struct sockaddr_in *) to)-&gt;sin_addr.s_addr = ntohl(0);</a>
<a name="ln276">    }</a>
<a name="ln277">    else {</a>
<a name="ln278">      ((struct sockaddr_in *) to)-&gt;sin_port = si.sin_port;</a>
<a name="ln279">      ((struct sockaddr_in *) to)-&gt;sin_addr = si.sin_addr;</a>
<a name="ln280">    }</a>
<a name="ln281"> </a>
<a name="ln282">    if (tolen) </a>
<a name="ln283">      *tolen = sizeof(si);</a>
<a name="ln284">  }</a>
<a name="ln285"> </a>
<a name="ln286">  memset(&amp;msgh, 0, sizeof(struct msghdr));</a>
<a name="ln287">  iov.iov_base = buf;</a>
<a name="ln288">  iov.iov_len  = len;</a>
<a name="ln289">  msgh.msg_control = cbuf;</a>
<a name="ln290">  msgh.msg_controllen = sizeof(cbuf);</a>
<a name="ln291">  msgh.msg_name = from;</a>
<a name="ln292">  msgh.msg_namelen = fromlen ? *fromlen : 0;</a>
<a name="ln293">  msgh.msg_iov  = &amp;iov;</a>
<a name="ln294">  msgh.msg_iovlen = 1;</a>
<a name="ln295">  msgh.msg_flags = 0;</a>
<a name="ln296"> </a>
<a name="ln297">  err = recvmsg(fd, &amp;msgh, 0);</a>
<a name="ln298">  if (err &lt; 0)</a>
<a name="ln299">    return err;</a>
<a name="ln300"> </a>
<a name="ln301">  if (fromlen)</a>
<a name="ln302">    *fromlen = msgh.msg_namelen;</a>
<a name="ln303"> </a>
<a name="ln304">  for (cmsg = CMSG_FIRSTHDR(&amp;msgh);</a>
<a name="ln305">       cmsg != NULL;</a>
<a name="ln306">       cmsg = CMSG_NXTHDR(&amp;msgh,cmsg)) {</a>
<a name="ln307"> </a>
<a name="ln308">#ifdef HAVE_IP_PKTINFO</a>
<a name="ln309">    if ((cmsg-&gt;cmsg_level == IPPROTO_IP) &amp;&amp; (cmsg-&gt;cmsg_type == IP_PKTINFO)) {</a>
<a name="ln310">      struct in_pktinfo *i = (struct in_pktinfo *) CMSG_DATA(cmsg);</a>
<a name="ln311">      if (to)</a>
<a name="ln312">	((struct sockaddr_in *) to)-&gt;sin_addr = i-&gt;ipi_addr;</a>
<a name="ln313">      if (tolen)</a>
<a name="ln314">	*tolen = sizeof(struct sockaddr_in);</a>
<a name="ln315">      if (ifindex)</a>
<a name="ln316">	*ifindex = i-&gt;ipi_ifindex;</a>
<a name="ln317"> </a>
<a name="ln318">      if (to &amp;&amp; PIM_DEBUG_PACKETS) {</a>
<a name="ln319">	char to_str[100];</a>
<a name="ln320">	pim_inet4_dump(&quot;&lt;to?&gt;&quot;, to-&gt;sin_addr, to_str, sizeof(to_str));</a>
<a name="ln321">	zlog_debug(&quot;%s: HAVE_IP_PKTINFO to=%s,%d&quot;,</a>
<a name="ln322">		   __PRETTY_FUNCTION__,</a>
<a name="ln323">		   to_str, ntohs(to-&gt;sin_port));</a>
<a name="ln324">      }</a>
<a name="ln325"> </a>
<a name="ln326">      break;</a>
<a name="ln327">    }</a>
<a name="ln328">#endif</a>
<a name="ln329"> </a>
<a name="ln330">#ifdef HAVE_IP_RECVDSTADDR</a>
<a name="ln331">    if ((cmsg-&gt;cmsg_level == IPPROTO_IP) &amp;&amp; (cmsg-&gt;cmsg_type == IP_RECVDSTADDR)) {</a>
<a name="ln332">      struct in_addr *i = (struct in_addr *) CMSG_DATA(cmsg);</a>
<a name="ln333">      if (to)</a>
<a name="ln334">	((struct sockaddr_in *) to)-&gt;sin_addr = *i;</a>
<a name="ln335">      if (tolen)</a>
<a name="ln336">	*tolen = sizeof(struct sockaddr_in);</a>
<a name="ln337"> </a>
<a name="ln338">      if (to &amp;&amp; PIM_DEBUG_PACKETS) {</a>
<a name="ln339">	char to_str[100];</a>
<a name="ln340">	pim_inet4_dump(&quot;&lt;to?&gt;&quot;, to-&gt;sin_addr, to_str, sizeof(to_str));</a>
<a name="ln341">	zlog_debug(&quot;%s: HAVE_IP_RECVDSTADDR to=%s,%d&quot;,</a>
<a name="ln342">		   __PRETTY_FUNCTION__,</a>
<a name="ln343">		   to_str, ntohs(to-&gt;sin_port));</a>
<a name="ln344">      }</a>
<a name="ln345"> </a>
<a name="ln346">      break;</a>
<a name="ln347">    }</a>
<a name="ln348">#endif</a>
<a name="ln349"> </a>
<a name="ln350">#if defined(HAVE_IP_RECVIF) &amp;&amp; defined(CMSG_IFINDEX)</a>
<a name="ln351">      if (cmsg-&gt;cmsg_type == IP_RECVIF)</a>
<a name="ln352">	if (ifindex)</a>
<a name="ln353">	  *ifindex = CMSG_IFINDEX(cmsg);</a>
<a name="ln354">#endif</a>
<a name="ln355"> </a>
<a name="ln356">  } /* for (cmsg) */</a>
<a name="ln357"> </a>
<a name="ln358">  return err; /* len */</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">int pim_socket_mcastloop_get(int fd)</a>
<a name="ln362">{</a>
<a name="ln363">  int loop;</a>
<a name="ln364">  socklen_t loop_len = sizeof(loop);</a>
<a name="ln365">  </a>
<a name="ln366">  if (getsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,</a>
<a name="ln367">		 &amp;loop, &amp;loop_len)) {</a>
<a name="ln368">    int e = errno;</a>
<a name="ln369">    zlog_warn(&quot;Could not get Multicast Loopback Option on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln370">	      fd, errno, safe_strerror(errno));</a>
<a name="ln371">    errno = e;</a>
<a name="ln372">    return PIM_SOCK_ERR_LOOP;</a>
<a name="ln373">  }</a>
<a name="ln374">  </a>
<a name="ln375">  return loop;</a>
<a name="ln376">}</a>
<a name="ln377"> </a>
<a name="ln378">int pim_socket_getsockname(int fd, struct sockaddr *name, socklen_t *namelen)</a>
<a name="ln379">{</a>
<a name="ln380">  if (getsockname(fd, name, namelen)) {</a>
<a name="ln381">    int e = errno;</a>
<a name="ln382">    zlog_warn(&quot;Could not get Socket Name for socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln383">	      fd, errno, safe_strerror(errno));</a>
<a name="ln384">    errno = e;</a>
<a name="ln385">    return PIM_SOCK_ERR_NAME;</a>
<a name="ln386">  }</a>
<a name="ln387"> </a>
<a name="ln388">  return PIM_SOCK_ERR_NONE;</a>
<a name="ln389">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
