
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_route.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP routing functions</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;nhrpd.h&quot;</a>
<a name="ln11">#include &quot;table.h&quot;</a>
<a name="ln12">#include &quot;memory.h&quot;</a>
<a name="ln13">#include &quot;stream.h&quot;</a>
<a name="ln14">#include &quot;log.h&quot;</a>
<a name="ln15">#include &quot;zclient.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17">static struct zclient *zclient;</a>
<a name="ln18">static struct route_table *zebra_rib[AFI_MAX];</a>
<a name="ln19"> </a>
<a name="ln20">struct route_info {</a>
<a name="ln21">	union sockunion via;</a>
<a name="ln22">	struct interface *ifp;</a>
<a name="ln23">	struct interface *nhrp_ifp;</a>
<a name="ln24">};</a>
<a name="ln25"> </a>
<a name="ln26">static void nhrp_zebra_connected(struct zclient *zclient)</a>
<a name="ln27">{</a>
<a name="ln28">	/* No real VRF support yet -- bind only to the default vrf */</a>
<a name="ln29">	zclient_send_requests (zclient, VRF_DEFAULT);</a>
<a name="ln30">}</a>
<a name="ln31"> </a>
<a name="ln32">static struct route_node *nhrp_route_update_get(const struct prefix *p, int create)</a>
<a name="ln33">{</a>
<a name="ln34">	struct route_node *rn;</a>
<a name="ln35">	afi_t afi = family2afi(PREFIX_FAMILY(p));</a>
<a name="ln36"> </a>
<a name="ln37">	if (!zebra_rib[afi])</a>
<a name="ln38">		return NULL;</a>
<a name="ln39"> </a>
<a name="ln40">	if (create) {</a>
<a name="ln41">		rn = route_node_get(zebra_rib[afi], p);</a>
<a name="ln42">		if (!rn-&gt;info) {</a>
<a name="ln43">			rn-&gt;info = XCALLOC(MTYPE_NHRP_ROUTE, sizeof(struct route_info));</a>
<a name="ln44">			route_lock_node(rn);</a>
<a name="ln45">		}</a>
<a name="ln46">		return rn;</a>
<a name="ln47">	} else {</a>
<a name="ln48">		return route_node_lookup(zebra_rib[afi], p);</a>
<a name="ln49">	}</a>
<a name="ln50">}</a>
<a name="ln51"> </a>
<a name="ln52">static void nhrp_route_update_put(struct route_node *rn)</a>
<a name="ln53">{</a>
<a name="ln54">	struct route_info *ri = rn-&gt;info;</a>
<a name="ln55"> </a>
<a name="ln56">	if (!ri-&gt;ifp &amp;&amp; !ri-&gt;nhrp_ifp &amp;&amp; sockunion_family(&amp;ri-&gt;via) == AF_UNSPEC) {</a>
<a name="ln57">		XFREE(MTYPE_NHRP_ROUTE, rn-&gt;info);</a>
<a name="ln58">		rn-&gt;info = NULL;</a>
<a name="ln59">		route_unlock_node(rn);</a>
<a name="ln60">	}</a>
<a name="ln61">	route_unlock_node(rn);</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">static void nhrp_route_update_zebra(const struct prefix *p, union sockunion *nexthop, struct interface *ifp)</a>
<a name="ln65">{</a>
<a name="ln66">	struct route_node *rn;</a>
<a name="ln67">	struct route_info *ri;</a>
<a name="ln68"> </a>
<a name="ln69">	rn = nhrp_route_update_get(p, (sockunion_family(nexthop) != AF_UNSPEC) || ifp);</a>
<a name="ln70">	if (rn) {</a>
<a name="ln71">		ri = rn-&gt;info;</a>
<a name="ln72">		ri-&gt;via = *nexthop;</a>
<a name="ln73">		ri-&gt;ifp = ifp;</a>
<a name="ln74">		nhrp_route_update_put(rn);</a>
<a name="ln75">	}</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">void nhrp_route_update_nhrp(const struct prefix *p, struct interface *ifp)</a>
<a name="ln79">{</a>
<a name="ln80">	struct route_node *rn;</a>
<a name="ln81">	struct route_info *ri;</a>
<a name="ln82"> </a>
<a name="ln83">	rn = nhrp_route_update_get(p, ifp != NULL);</a>
<a name="ln84">	if (rn) {</a>
<a name="ln85">		ri = rn-&gt;info;</a>
<a name="ln86">		ri-&gt;nhrp_ifp = ifp;</a>
<a name="ln87">		nhrp_route_update_put(rn);</a>
<a name="ln88">	}</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">void nhrp_route_announce(int add, enum nhrp_cache_type type, const struct prefix *p, struct interface *ifp, const union sockunion *nexthop, uint32_t mtu)</a>
<a name="ln92">{</a>
<a name="ln93">	int flags = 0;</a>
<a name="ln94"> </a>
<a name="ln95">	if (zclient-&gt;sock &lt; 0)</a>
<a name="ln96">		return;</a>
<a name="ln97"> </a>
<a name="ln98">	switch (type) {</a>
<a name="ln99">	case NHRP_CACHE_NEGATIVE:</a>
<a name="ln100">		SET_FLAG(flags, ZEBRA_FLAG_REJECT);</a>
<a name="ln101">		break;</a>
<a name="ln102">	case NHRP_CACHE_DYNAMIC:</a>
<a name="ln103">	case NHRP_CACHE_NHS:</a>
<a name="ln104">	case NHRP_CACHE_STATIC:</a>
<a name="ln105">		/* Regular route, so these are announced</a>
<a name="ln106">		 * to other routing daemons */</a>
<a name="ln107">		break;</a>
<a name="ln108">	default:</a>
<a name="ln109">		SET_FLAG(flags, ZEBRA_FLAG_FIB_OVERRIDE);</a>
<a name="ln110">		break;</a>
<a name="ln111">	}</a>
<a name="ln112">	SET_FLAG(flags, ZEBRA_FLAG_INTERNAL);</a>
<a name="ln113"> </a>
<a name="ln114">	if (p-&gt;family == AF_INET) {</a>
<a name="ln115">		struct in_addr *nexthop_ipv4;</a>
<a name="ln116">		struct zapi_ipv4 api;</a>
<a name="ln117"> </a>
<a name="ln118">		memset(&amp;api, 0, sizeof(api));</a>
<a name="ln119">		api.flags = flags;</a>
<a name="ln120">		api.type = ZEBRA_ROUTE_NHRP;</a>
<a name="ln121">		api.safi = SAFI_UNICAST;</a>
<a name="ln122"> </a>
<a name="ln123">		SET_FLAG(api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln124">		if (nexthop) {</a>
<a name="ln125">			nexthop_ipv4 = (struct in_addr *) sockunion_get_addr(nexthop);</a>
<a name="ln126">			api.nexthop_num = 1;</a>
<a name="ln127">			api.nexthop = &amp;nexthop_ipv4;</a>
<a name="ln128">		}</a>
<a name="ln129">		if (ifp) {</a>
<a name="ln130">			SET_FLAG(api.message, ZAPI_MESSAGE_IFINDEX);</a>
<a name="ln131">			api.ifindex_num = 1;</a>
<a name="ln132">			api.ifindex = &amp;ifp-&gt;ifindex;</a>
<a name="ln133">		}</a>
<a name="ln134">		if (mtu) {</a>
<a name="ln135">			SET_FLAG(api.message, ZAPI_MESSAGE_MTU);</a>
<a name="ln136">			api.mtu = mtu;</a>
<a name="ln137">		}</a>
<a name="ln138"> </a>
<a name="ln139">		if (unlikely(debug_flags &amp; NHRP_DEBUG_ROUTE)) {</a>
<a name="ln140">			char buf[2][INET_ADDRSTRLEN];</a>
<a name="ln141">			zlog_debug(&quot;Zebra send: IPv4 route %s %s/%d nexthop %s metric %u&quot;</a>
<a name="ln142">				&quot; count %d dev %s&quot;,</a>
<a name="ln143">				add ? &quot;add&quot; : &quot;del&quot;,</a>
<a name="ln144">				inet_ntop(AF_INET, &amp;p-&gt;u.prefix4, buf[0], sizeof(buf[0])),</a>
<a name="ln145">				p-&gt;prefixlen,</a>
<a name="ln146">				nexthop ? inet_ntop(AF_INET, api.nexthop[0], buf[1], sizeof(buf[1])) : &quot;&lt;onlink&gt;&quot;,</a>
<a name="ln147">				api.metric, api.nexthop_num, ifp-&gt;name);</a>
<a name="ln148">		}</a>
<a name="ln149"> </a>
<a name="ln150">		zapi_ipv4_route(</a>
<a name="ln151">			add ? ZEBRA_IPV4_ROUTE_ADD : ZEBRA_IPV4_ROUTE_DELETE,</a>
<a name="ln152">			zclient, (struct prefix_ipv4 *) p, &amp;api);</a>
<a name="ln153">	} else if (p-&gt;family == AF_INET6) {</a>
<a name="ln154">		struct in6_addr *nexthop_ipv6;</a>
<a name="ln155">		struct zapi_ipv6 api;</a>
<a name="ln156"> </a>
<a name="ln157">		memset(&amp;api, 0, sizeof(api));</a>
<a name="ln158">		api.flags = flags;</a>
<a name="ln159">		api.type = ZEBRA_ROUTE_NHRP;</a>
<a name="ln160">		api.safi = SAFI_UNICAST;</a>
<a name="ln161"> </a>
<a name="ln162">		SET_FLAG(api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln163">		if (nexthop) {</a>
<a name="ln164">			nexthop_ipv6 = (struct in6_addr *) sockunion_get_addr(nexthop);</a>
<a name="ln165">			api.nexthop_num = 1;</a>
<a name="ln166">			api.nexthop = &amp;nexthop_ipv6;</a>
<a name="ln167">		}</a>
<a name="ln168">		if (ifp) {</a>
<a name="ln169">			SET_FLAG(api.message, ZAPI_MESSAGE_IFINDEX);</a>
<a name="ln170">			api.ifindex_num = 1;</a>
<a name="ln171">			api.ifindex = &amp;ifp-&gt;ifindex;</a>
<a name="ln172">		}</a>
<a name="ln173">		if (mtu) {</a>
<a name="ln174">			SET_FLAG(api.message, ZAPI_MESSAGE_MTU);</a>
<a name="ln175">			api.mtu = mtu;</a>
<a name="ln176">		}</a>
<a name="ln177"> </a>
<a name="ln178">		if (unlikely(debug_flags &amp; NHRP_DEBUG_ROUTE)) {</a>
<a name="ln179">			char buf[2][INET6_ADDRSTRLEN];</a>
<a name="ln180">			zlog_debug(&quot;Zebra send: IPv6 route %s %s/%d nexthop %s metric %u&quot;</a>
<a name="ln181">				&quot; count %d dev %s&quot;,</a>
<a name="ln182">				add ? &quot;add&quot; : &quot;del&quot;,</a>
<a name="ln183">				inet_ntop(AF_INET6, &amp;p-&gt;u.prefix6, buf[0], sizeof(buf[0])),</a>
<a name="ln184">				p-&gt;prefixlen,</a>
<a name="ln185">				nexthop ? inet_ntop(AF_INET6, api.nexthop[0], buf[1], sizeof(buf[1])) : &quot;&lt;onlink&gt;&quot;,</a>
<a name="ln186">				api.metric, api.nexthop_num, ifp-&gt;name);</a>
<a name="ln187">		}</a>
<a name="ln188"> </a>
<a name="ln189">		zapi_ipv6_route(</a>
<a name="ln190">			add ? ZEBRA_IPV6_ROUTE_ADD : ZEBRA_IPV6_ROUTE_DELETE,</a>
<a name="ln191">			zclient, (struct prefix_ipv6 *) p, &amp;api);</a>
<a name="ln192">	}</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">int nhrp_route_read(int cmd, struct zclient *zclient, zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln196">{</a>
<a name="ln197">	struct stream *s;</a>
<a name="ln198">	struct interface *ifp = NULL;</a>
<a name="ln199">	struct prefix prefix;</a>
<a name="ln200">	union sockunion nexthop_addr;</a>
<a name="ln201">	unsigned char message, nexthop_num, ifindex_num;</a>
<a name="ln202">	unsigned ifindex;</a>
<a name="ln203">	char buf[2][PREFIX_STRLEN];</a>
<a name="ln204">	int i, afaddrlen, added;</a>
<a name="ln205"> </a>
<a name="ln206">	s = zclient-&gt;ibuf;</a>
<a name="ln207">	memset(&amp;prefix, 0, sizeof(prefix));</a>
<a name="ln208">	sockunion_family(&amp;nexthop_addr) = AF_UNSPEC;</a>
<a name="ln209"> </a>
<a name="ln210">	/* Type, flags, message. */</a>
<a name="ln211">	/*type =*/ stream_getc(s);</a>
<a name="ln212">	/*flags =*/ stream_getc(s);</a>
<a name="ln213">	message = stream_getc(s);</a>
<a name="ln214"> </a>
<a name="ln215">	/* Prefix */</a>
<a name="ln216">	switch (cmd) {</a>
<a name="ln217">	case ZEBRA_IPV4_ROUTE_ADD:</a>
<a name="ln218">	case ZEBRA_IPV4_ROUTE_DELETE:</a>
<a name="ln219">		prefix.family = AF_INET;</a>
<a name="ln220">		break;</a>
<a name="ln221">	case ZEBRA_IPV6_ROUTE_ADD:</a>
<a name="ln222">	case ZEBRA_IPV6_ROUTE_DELETE:</a>
<a name="ln223">		prefix.family = AF_INET6;</a>
<a name="ln224">		break;</a>
<a name="ln225">	default:</a>
<a name="ln226">		return -1;</a>
<a name="ln227">	}</a>
<a name="ln228">	afaddrlen = family2addrsize(prefix.family);</a>
<a name="ln229">	prefix.prefixlen = stream_getc(s);</a>
<a name="ln230">	stream_get(&amp;prefix.u.val, s, PSIZE(prefix.prefixlen));</a>
<a name="ln231"> </a>
<a name="ln232">	/* Nexthop, ifindex, distance, metric. */</a>
<a name="ln233">	if (CHECK_FLAG(message, ZAPI_MESSAGE_NEXTHOP|ZAPI_MESSAGE_IFINDEX)) {</a>
<a name="ln234">		nexthop_num = stream_getc(s);</a>
<a name="ln235">		for (i = 0; i &lt; nexthop_num; i++) {</a>
<a name="ln236">			stream_get(buf[0], s, afaddrlen);</a>
<a name="ln237">			if (i == 0) sockunion_set(&amp;nexthop_addr, prefix.family, (u_char*) buf[0], afaddrlen);</a>
<a name="ln238">		}</a>
<a name="ln239">		ifindex_num = stream_getc(s);</a>
<a name="ln240">		for (i = 0; i &lt; ifindex_num; i++) {</a>
<a name="ln241">			ifindex = stream_getl(s);</a>
<a name="ln242">			if (i == 0 &amp;&amp; ifindex != IFINDEX_INTERNAL)</a>
<a name="ln243">				ifp = if_lookup_by_index(ifindex);</a>
<a name="ln244">		}</a>
<a name="ln245">	}</a>
<a name="ln246">	if (CHECK_FLAG(message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln247">		/*distance =*/ stream_getc(s);</a>
<a name="ln248">	if (CHECK_FLAG(message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln249">		/*metric =*/ stream_getl(s);</a>
<a name="ln250"> </a>
<a name="ln251">	added = (cmd == ZEBRA_IPV4_ROUTE_ADD || cmd == ZEBRA_IPV6_ROUTE_ADD);</a>
<a name="ln252">	debugf(NHRP_DEBUG_ROUTE, &quot;if-route-%s: %s via %s dev %s&quot;,</a>
<a name="ln253">		added ? &quot;add&quot; : &quot;del&quot;,</a>
<a name="ln254">		prefix2str(&amp;prefix, buf[0], sizeof buf[0]),</a>
<a name="ln255">		sockunion2str(&amp;nexthop_addr, buf[1], sizeof buf[1]),</a>
<a name="ln256">		ifp ? ifp-&gt;name : &quot;(none)&quot;);</a>
<a name="ln257"> </a>
<a name="ln258">	nhrp_route_update_zebra(&amp;prefix, &amp;nexthop_addr, ifp);</a>
<a name="ln259">	nhrp_shortcut_prefix_change(&amp;prefix, !added);</a>
<a name="ln260"> </a>
<a name="ln261">	return 0;</a>
<a name="ln262">}</a>
<a name="ln263"> </a>
<a name="ln264">int nhrp_route_get_nexthop(const union sockunion *addr, struct prefix *p, union sockunion *via, struct interface **ifp)</a>
<a name="ln265">{</a>
<a name="ln266">	struct route_node *rn;</a>
<a name="ln267">	struct route_info *ri;</a>
<a name="ln268">	struct prefix lookup;</a>
<a name="ln269">	afi_t afi = family2afi(sockunion_family(addr));</a>
<a name="ln270">	char buf[PREFIX_STRLEN];</a>
<a name="ln271"> </a>
<a name="ln272">	sockunion2hostprefix(addr, &amp;lookup);</a>
<a name="ln273"> </a>
<a name="ln274">	rn = route_node_match(zebra_rib[afi], &amp;lookup);</a>
<a name="ln275">	if (!rn) return 0;</a>
<a name="ln276"> </a>
<a name="ln277">	ri = rn-&gt;info;</a>
<a name="ln278">	if (ri-&gt;nhrp_ifp) {</a>
<a name="ln279">		debugf(NHRP_DEBUG_ROUTE, &quot;lookup %s: nhrp_if=%s&quot;,</a>
<a name="ln280">			prefix2str(&amp;lookup, buf, sizeof buf),</a>
<a name="ln281">			ri-&gt;nhrp_ifp-&gt;name);</a>
<a name="ln282"> </a>
<a name="ln283">		if (via) sockunion_family(via) = AF_UNSPEC;</a>
<a name="ln284">		if (ifp) *ifp = ri-&gt;nhrp_ifp;</a>
<a name="ln285">	} else {</a>
<a name="ln286">		debugf(NHRP_DEBUG_ROUTE, &quot;lookup %s: zebra route dev %s&quot;,</a>
<a name="ln287">			prefix2str(&amp;lookup, buf, sizeof buf),</a>
<a name="ln288">			ri-&gt;ifp ? ri-&gt;ifp-&gt;name : &quot;(none)&quot;);</a>
<a name="ln289"> </a>
<a name="ln290">		if (via) *via = ri-&gt;via;</a>
<a name="ln291">		if (ifp) *ifp = ri-&gt;ifp;</a>
<a name="ln292">	}</a>
<a name="ln293">	if (p) *p = rn-&gt;p;</a>
<a name="ln294">	route_unlock_node(rn);</a>
<a name="ln295">	return 1;</a>
<a name="ln296">}</a>
<a name="ln297"> </a>
<a name="ln298">enum nhrp_route_type nhrp_route_address(struct interface *in_ifp, union sockunion *addr, struct prefix *p, struct nhrp_peer **peer)</a>
<a name="ln299">{</a>
<a name="ln300">	struct interface *ifp = in_ifp;</a>
<a name="ln301">	struct nhrp_interface *nifp;</a>
<a name="ln302">	struct nhrp_cache *c;</a>
<a name="ln303">	union sockunion via[4];</a>
<a name="ln304">	uint32_t network_id = 0;</a>
<a name="ln305">	afi_t afi = family2afi(sockunion_family(addr));</a>
<a name="ln306">	int i;</a>
<a name="ln307"> </a>
<a name="ln308">	if (ifp) {</a>
<a name="ln309">		nifp = ifp-&gt;info;</a>
<a name="ln310">		network_id = nifp-&gt;afi[afi].network_id;</a>
<a name="ln311"> </a>
<a name="ln312">		c = nhrp_cache_get(ifp, addr, 0);</a>
<a name="ln313">		if (c &amp;&amp; c-&gt;cur.type == NHRP_CACHE_LOCAL) {</a>
<a name="ln314">			if (p) memset(p, 0, sizeof(*p));</a>
<a name="ln315">			return NHRP_ROUTE_LOCAL;</a>
<a name="ln316">		}</a>
<a name="ln317">	}</a>
<a name="ln318"> </a>
<a name="ln319">	for (i = 0; i &lt; 4; i++) {</a>
<a name="ln320">		if (!nhrp_route_get_nexthop(addr, p, &amp;via[i], &amp;ifp))</a>
<a name="ln321">			return NHRP_ROUTE_BLACKHOLE;</a>
<a name="ln322">		if (ifp) {</a>
<a name="ln323">			/* Departing from nbma network? */</a>
<a name="ln324">			nifp = ifp-&gt;info;</a>
<a name="ln325">			if (network_id &amp;&amp; network_id != nifp-&gt;afi[afi].network_id)</a>
<a name="ln326">				return NHRP_ROUTE_OFF_NBMA;</a>
<a name="ln327">		}</a>
<a name="ln328">		if (sockunion_family(&amp;via[i]) == AF_UNSPEC)</a>
<a name="ln329">			break;</a>
<a name="ln330">		/* Resolve via node, but return the prefix of first match */</a>
<a name="ln331">		addr = &amp;via[i];</a>
<a name="ln332">		p = NULL;</a>
<a name="ln333">	}</a>
<a name="ln334"> </a>
<a name="ln335">	if (ifp) {</a>
<a name="ln336">		c = nhrp_cache_get(ifp, addr, 0);</a>
<a name="ln337">		if (c &amp;&amp; c-&gt;cur.type &gt;= NHRP_CACHE_DYNAMIC) {</a>
<a name="ln338">			if (p) memset(p, 0, sizeof(*p));</a>
<a name="ln339">			if (c-&gt;cur.type == NHRP_CACHE_LOCAL)</a>
<a name="ln340">				return NHRP_ROUTE_LOCAL;</a>
<a name="ln341">			if (peer) *peer = nhrp_peer_ref(c-&gt;cur.peer);</a>
<a name="ln342">			return NHRP_ROUTE_NBMA_NEXTHOP;</a>
<a name="ln343">		}</a>
<a name="ln344">	}</a>
<a name="ln345"> </a>
<a name="ln346">	return NHRP_ROUTE_BLACKHOLE;</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">void nhrp_zebra_init(void)</a>
<a name="ln350">{</a>
<a name="ln351">	zebra_rib[AFI_IP] = route_table_init();</a>
<a name="ln352">	zebra_rib[AFI_IP6] = route_table_init();</a>
<a name="ln353"> </a>
<a name="ln354">	zclient = zclient_new(master);</a>
<a name="ln355">	zclient-&gt;zebra_connected = nhrp_zebra_connected;</a>
<a name="ln356">	zclient-&gt;interface_add = nhrp_interface_add;</a>
<a name="ln357">	zclient-&gt;interface_delete = nhrp_interface_delete;</a>
<a name="ln358">	zclient-&gt;interface_up = nhrp_interface_up;</a>
<a name="ln359">	zclient-&gt;interface_down = nhrp_interface_down;</a>
<a name="ln360">	zclient-&gt;interface_address_add = nhrp_interface_address_add;</a>
<a name="ln361">	zclient-&gt;interface_address_delete = nhrp_interface_address_delete;</a>
<a name="ln362">	zclient-&gt;ipv4_route_add = nhrp_route_read;</a>
<a name="ln363">	zclient-&gt;ipv4_route_delete = nhrp_route_read;</a>
<a name="ln364">	zclient-&gt;ipv6_route_add = nhrp_route_read;</a>
<a name="ln365">	zclient-&gt;ipv6_route_delete = nhrp_route_read;</a>
<a name="ln366"> </a>
<a name="ln367">	zclient_init(zclient, ZEBRA_ROUTE_NHRP);</a>
<a name="ln368">	zclient_redistribute(ZEBRA_REDISTRIBUTE_ADD, zclient, ZEBRA_ROUTE_KERNEL, VRF_DEFAULT);</a>
<a name="ln369">	zclient_redistribute(ZEBRA_REDISTRIBUTE_ADD, zclient, ZEBRA_ROUTE_CONNECT, VRF_DEFAULT);</a>
<a name="ln370">	zclient_redistribute(ZEBRA_REDISTRIBUTE_ADD, zclient, ZEBRA_ROUTE_STATIC, VRF_DEFAULT);</a>
<a name="ln371">	zclient_redistribute(ZEBRA_REDISTRIBUTE_ADD, zclient, ZEBRA_ROUTE_RIP, VRF_DEFAULT);</a>
<a name="ln372">	zclient_redistribute(ZEBRA_REDISTRIBUTE_ADD, zclient, ZEBRA_ROUTE_OSPF, VRF_DEFAULT);</a>
<a name="ln373">	zclient_redistribute(ZEBRA_REDISTRIBUTE_ADD, zclient, ZEBRA_ROUTE_ISIS, VRF_DEFAULT);</a>
<a name="ln374">	zclient_redistribute(ZEBRA_REDISTRIBUTE_ADD, zclient, ZEBRA_ROUTE_BGP, VRF_DEFAULT);</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">void nhrp_zebra_terminate(void)</a>
<a name="ln378">{</a>
<a name="ln379">	zclient_stop(zclient);</a>
<a name="ln380">	route_table_finish(zebra_rib[AFI_IP]);</a>
<a name="ln381">	route_table_finish(zebra_rib[AFI_IP6]);</a>
<a name="ln382">}</a>
<a name="ln383"> </a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
