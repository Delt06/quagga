
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>connected.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Address linked list routine.</a>
<a name="ln3"> * Copyright (C) 1997, 98 Kunihiro Ishiguro</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.  </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;linklist.h&quot;</a>
<a name="ln27">#include &quot;if.h&quot;</a>
<a name="ln28">#include &quot;table.h&quot;</a>
<a name="ln29">#include &quot;rib.h&quot;</a>
<a name="ln30">#include &quot;table.h&quot;</a>
<a name="ln31">#include &quot;log.h&quot;</a>
<a name="ln32">#include &quot;memory.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln35">#include &quot;zebra/redistribute.h&quot;</a>
<a name="ln36">#include &quot;zebra/interface.h&quot;</a>
<a name="ln37">#include &quot;zebra/connected.h&quot;</a>
<a name="ln38">extern struct zebra_t zebrad;</a>
<a name="ln39"> </a>
<a name="ln40">/* communicate the withdrawal of a connected address */</a>
<a name="ln41">static void</a>
<a name="ln42">connected_withdraw (struct connected *ifc)</a>
<a name="ln43">{</a>
<a name="ln44">  if (! ifc)</a>
<a name="ln45">    return;</a>
<a name="ln46"> </a>
<a name="ln47">  /* Update interface address information to protocol daemon. */</a>
<a name="ln48">  if (CHECK_FLAG (ifc-&gt;conf, ZEBRA_IFC_REAL))</a>
<a name="ln49">    {</a>
<a name="ln50">      zebra_interface_address_delete_update (ifc-&gt;ifp, ifc);</a>
<a name="ln51"> </a>
<a name="ln52">      if (ifc-&gt;address-&gt;family == AF_INET)</a>
<a name="ln53">        if_subnet_delete (ifc-&gt;ifp, ifc);</a>
<a name="ln54"> </a>
<a name="ln55">      if (ifc-&gt;address-&gt;family == AF_INET)</a>
<a name="ln56">        connected_down_ipv4 (ifc-&gt;ifp, ifc);</a>
<a name="ln57">#ifdef HAVE_IPV6</a>
<a name="ln58">      else</a>
<a name="ln59">        connected_down_ipv6 (ifc-&gt;ifp, ifc);</a>
<a name="ln60">#endif</a>
<a name="ln61"> </a>
<a name="ln62">      UNSET_FLAG (ifc-&gt;conf, ZEBRA_IFC_REAL);</a>
<a name="ln63">    }</a>
<a name="ln64"> </a>
<a name="ln65">  /* The address is not in the kernel anymore, so clear the flag */</a>
<a name="ln66">  UNSET_FLAG(ifc-&gt;conf, ZEBRA_IFC_QUEUED);</a>
<a name="ln67"> </a>
<a name="ln68">  if (!CHECK_FLAG (ifc-&gt;conf, ZEBRA_IFC_CONFIGURED))</a>
<a name="ln69">    {</a>
<a name="ln70">      listnode_delete (ifc-&gt;ifp-&gt;connected, ifc);</a>
<a name="ln71">      connected_free (ifc);</a>
<a name="ln72">    }</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">static void</a>
<a name="ln76">connected_announce (struct interface *ifp, struct connected *ifc)</a>
<a name="ln77">{</a>
<a name="ln78">  if (!ifc)</a>
<a name="ln79">    return;</a>
<a name="ln80"> </a>
<a name="ln81">  if (!if_is_loopback(ifp) &amp;&amp; ifc-&gt;address-&gt;family == AF_INET)</a>
<a name="ln82">    {</a>
<a name="ln83">      if (ifc-&gt;address-&gt;prefixlen == 32)</a>
<a name="ln84">        SET_FLAG (ifc-&gt;flags, ZEBRA_IFA_UNNUMBERED);</a>
<a name="ln85">      else</a>
<a name="ln86">        UNSET_FLAG (ifc-&gt;flags, ZEBRA_IFA_UNNUMBERED);</a>
<a name="ln87">    }</a>
<a name="ln88"> </a>
<a name="ln89">  listnode_add (ifp-&gt;connected, ifc);</a>
<a name="ln90"> </a>
<a name="ln91">  /* Update interface address information to protocol daemon. */</a>
<a name="ln92">  if (ifc-&gt;address-&gt;family == AF_INET)</a>
<a name="ln93">    if_subnet_add (ifp, ifc);</a>
<a name="ln94"> </a>
<a name="ln95">  zebra_interface_address_add_update (ifp, ifc);</a>
<a name="ln96"> </a>
<a name="ln97">  if (if_is_operative(ifp))</a>
<a name="ln98">    {</a>
<a name="ln99">      if (ifc-&gt;address-&gt;family == AF_INET)</a>
<a name="ln100">        connected_up_ipv4 (ifp, ifc);</a>
<a name="ln101">#ifdef HAVE_IPV6</a>
<a name="ln102">      else</a>
<a name="ln103">        connected_up_ipv6 (ifp, ifc);</a>
<a name="ln104">#endif</a>
<a name="ln105">    }</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">/* If same interface address is already exist... */</a>
<a name="ln109">struct connected *</a>
<a name="ln110">connected_check (struct interface *ifp, struct prefix *p)</a>
<a name="ln111">{</a>
<a name="ln112">  struct connected *ifc;</a>
<a name="ln113">  struct listnode *node;</a>
<a name="ln114"> </a>
<a name="ln115">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, node, ifc))</a>
<a name="ln116">    if (prefix_same (ifc-&gt;address, p))</a>
<a name="ln117">      return ifc;</a>
<a name="ln118"> </a>
<a name="ln119">  return NULL;</a>
<a name="ln120">}</a>
<a name="ln121"> </a>
<a name="ln122">/* Check if two ifc's describe the same address in the same state */</a>
<a name="ln123">static int</a>
<a name="ln124">connected_same (struct connected *ifc1, struct connected *ifc2)</a>
<a name="ln125">{</a>
<a name="ln126">  if (ifc1-&gt;ifp != ifc2-&gt;ifp)</a>
<a name="ln127">    return 0;</a>
<a name="ln128">  </a>
<a name="ln129">  if (ifc1-&gt;destination)</a>
<a name="ln130">    if (!ifc2-&gt;destination)</a>
<a name="ln131">      return 0;</a>
<a name="ln132">  if (ifc2-&gt;destination)</a>
<a name="ln133">    if (!ifc1-&gt;destination)</a>
<a name="ln134">      return 0;</a>
<a name="ln135">  </a>
<a name="ln136">  if (ifc1-&gt;destination &amp;&amp; ifc2-&gt;destination)</a>
<a name="ln137">    if (!prefix_same (ifc1-&gt;destination, ifc2-&gt;destination))</a>
<a name="ln138">      return 0;</a>
<a name="ln139"> </a>
<a name="ln140">  if (ifc1-&gt;flags != ifc2-&gt;flags)</a>
<a name="ln141">    return 0;</a>
<a name="ln142"> </a>
<a name="ln143">  if (ifc1-&gt;conf != ifc2-&gt;conf)</a>
<a name="ln144">    return 0;</a>
<a name="ln145">  </a>
<a name="ln146">  return 1;</a>
<a name="ln147">}</a>
<a name="ln148"> </a>
<a name="ln149">/* Handle changes to addresses and send the neccesary announcements</a>
<a name="ln150"> * to clients. */</a>
<a name="ln151">static void</a>
<a name="ln152">connected_update(struct interface *ifp, struct connected *ifc)</a>
<a name="ln153">{</a>
<a name="ln154">  struct connected *current;</a>
<a name="ln155">  </a>
<a name="ln156">  /* Check same connected route. */</a>
<a name="ln157">  if ((current = connected_check (ifp, (struct prefix *) ifc-&gt;address)))</a>
<a name="ln158">    {</a>
<a name="ln159">      if (CHECK_FLAG(current-&gt;conf, ZEBRA_IFC_CONFIGURED))</a>
<a name="ln160">        SET_FLAG(ifc-&gt;conf, ZEBRA_IFC_CONFIGURED);</a>
<a name="ln161">	</a>
<a name="ln162">      /* Avoid spurious withdraws, this might be just the kernel 'reflecting'</a>
<a name="ln163">       * back an address we have already added.</a>
<a name="ln164">       */</a>
<a name="ln165">      if (connected_same (current, ifc))</a>
<a name="ln166">        {</a>
<a name="ln167">          /* nothing to do */</a>
<a name="ln168">          connected_free (ifc);</a>
<a name="ln169">          return;</a>
<a name="ln170">        }</a>
<a name="ln171"> </a>
<a name="ln172">      /* Clear the configured flag on the old ifc, so it will be freed by</a>
<a name="ln173">       * connected withdraw. */</a>
<a name="ln174">      UNSET_FLAG(current-&gt;conf, ZEBRA_IFC_CONFIGURED);</a>
<a name="ln175">      connected_withdraw (current); /* implicit withdraw - freebsd does this */</a>
<a name="ln176">    }</a>
<a name="ln177"> </a>
<a name="ln178">  /* If the connected is new or has changed, announce it, if it is usable */</a>
<a name="ln179">  if (CHECK_FLAG(ifc-&gt;conf, ZEBRA_IFC_REAL))</a>
<a name="ln180">    connected_announce(ifp, ifc);</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">/* Called from if_up(). */</a>
<a name="ln184">void</a>
<a name="ln185">connected_up_ipv4 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln186">{</a>
<a name="ln187">  struct prefix_ipv4 p;</a>
<a name="ln188"> </a>
<a name="ln189">  if (! CHECK_FLAG (ifc-&gt;conf, ZEBRA_IFC_REAL))</a>
<a name="ln190">    return;</a>
<a name="ln191"> </a>
<a name="ln192">  PREFIX_COPY_IPV4(&amp;p, CONNECTED_PREFIX(ifc));</a>
<a name="ln193"> </a>
<a name="ln194">  /* Apply mask to the network. */</a>
<a name="ln195">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln196"> </a>
<a name="ln197">  /* In case of connected address is 0.0.0.0/0 we treat it tunnel</a>
<a name="ln198">     address. */</a>
<a name="ln199">  if (prefix_ipv4_any (&amp;p))</a>
<a name="ln200">    return;</a>
<a name="ln201"> </a>
<a name="ln202">  rib_add_ipv4 (ZEBRA_ROUTE_CONNECT, 0, &amp;p, NULL, NULL, ifp-&gt;ifindex,</a>
<a name="ln203">       ifp-&gt;vrf_id, RT_TABLE_MAIN, ifp-&gt;metric, 0, 0, SAFI_UNICAST);</a>
<a name="ln204"> </a>
<a name="ln205">  rib_add_ipv4 (ZEBRA_ROUTE_CONNECT, 0, &amp;p, NULL, NULL, ifp-&gt;ifindex,</a>
<a name="ln206">       ifp-&gt;vrf_id, RT_TABLE_MAIN, ifp-&gt;metric, 0, 0, SAFI_MULTICAST);</a>
<a name="ln207"> </a>
<a name="ln208">  rib_update (ifp-&gt;vrf_id);</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">/* Add connected IPv4 route to the interface. */</a>
<a name="ln212">void</a>
<a name="ln213">connected_add_ipv4 (struct interface *ifp, int flags, struct in_addr *addr, </a>
<a name="ln214">		    u_char prefixlen, struct in_addr *broad, </a>
<a name="ln215">		    const char *label)</a>
<a name="ln216">{</a>
<a name="ln217">  struct prefix_ipv4 *p;</a>
<a name="ln218">  struct connected *ifc;</a>
<a name="ln219"> </a>
<a name="ln220">  /* Make connected structure. */</a>
<a name="ln221">  ifc = connected_new ();</a>
<a name="ln222">  ifc-&gt;ifp = ifp;</a>
<a name="ln223">  ifc-&gt;flags = flags;</a>
<a name="ln224">  /* If we get a notification from the kernel,</a>
<a name="ln225">   * we can safely assume the address is known to the kernel */</a>
<a name="ln226">  SET_FLAG(ifc-&gt;conf, ZEBRA_IFC_QUEUED);</a>
<a name="ln227"> </a>
<a name="ln228">  /* Allocate new connected address. */</a>
<a name="ln229">  p = prefix_ipv4_new ();</a>
<a name="ln230">  p-&gt;family = AF_INET;</a>
<a name="ln231">  p-&gt;prefix = *addr;</a>
<a name="ln232">  p-&gt;prefixlen = prefixlen;</a>
<a name="ln233">  ifc-&gt;address = (struct prefix *) p;</a>
<a name="ln234">  </a>
<a name="ln235">  /* If there is broadcast or peer address. */</a>
<a name="ln236">  if (broad)</a>
<a name="ln237">    {</a>
<a name="ln238">      p = prefix_ipv4_new ();</a>
<a name="ln239">      p-&gt;family = AF_INET;</a>
<a name="ln240">      p-&gt;prefix = *broad;</a>
<a name="ln241">      p-&gt;prefixlen = prefixlen;</a>
<a name="ln242">      ifc-&gt;destination = (struct prefix *) p;</a>
<a name="ln243"> </a>
<a name="ln244">      /* validate the destination address */</a>
<a name="ln245">      if (CONNECTED_PEER(ifc))</a>
<a name="ln246">        {</a>
<a name="ln247">	  if (IPV4_ADDR_SAME(addr,broad))</a>
<a name="ln248">	    zlog_warn(&quot;warning: interface %s has same local and peer &quot;</a>
<a name="ln249">		      &quot;address %s, routing protocols may malfunction&quot;,</a>
<a name="ln250">		      ifp-&gt;name,inet_ntoa(*addr));</a>
<a name="ln251">        }</a>
<a name="ln252">      else</a>
<a name="ln253">        {</a>
<a name="ln254">	  if (broad-&gt;s_addr != ipv4_broadcast_addr(addr-&gt;s_addr,prefixlen))</a>
<a name="ln255">	    {</a>
<a name="ln256">	      char buf[2][INET_ADDRSTRLEN];</a>
<a name="ln257">	      struct in_addr bcalc;</a>
<a name="ln258">	      bcalc.s_addr = ipv4_broadcast_addr(addr-&gt;s_addr,prefixlen);</a>
<a name="ln259">	      zlog_warn(&quot;warning: interface %s broadcast addr %s/%d != &quot;</a>
<a name="ln260">	       		&quot;calculated %s, routing protocols may malfunction&quot;,</a>
<a name="ln261">	    		ifp-&gt;name,</a>
<a name="ln262">			inet_ntop (AF_INET, broad, buf[0], sizeof(buf[0])),</a>
<a name="ln263">			prefixlen,</a>
<a name="ln264">			inet_ntop (AF_INET, &amp;bcalc, buf[1], sizeof(buf[1])));</a>
<a name="ln265">	    }</a>
<a name="ln266">        }</a>
<a name="ln267"> </a>
<a name="ln268">    }</a>
<a name="ln269">  else</a>
<a name="ln270">    {</a>
<a name="ln271">      if (CHECK_FLAG(ifc-&gt;flags, ZEBRA_IFA_PEER))</a>
<a name="ln272">        {</a>
<a name="ln273">	  zlog_warn(&quot;warning: %s called for interface %s &quot;</a>
<a name="ln274">		    &quot;with peer flag set, but no peer address supplied&quot;,</a>
<a name="ln275">		    __func__, ifp-&gt;name);</a>
<a name="ln276">	  UNSET_FLAG(ifc-&gt;flags, ZEBRA_IFA_PEER);</a>
<a name="ln277">	}</a>
<a name="ln278"> </a>
<a name="ln279">      /* no broadcast or destination address was supplied */</a>
<a name="ln280">      if ((prefixlen == IPV4_MAX_PREFIXLEN) &amp;&amp; if_is_pointopoint(ifp))</a>
<a name="ln281">	zlog_warn(&quot;warning: PtP interface %s with addr %s/%d needs a &quot;</a>
<a name="ln282">		  &quot;peer address&quot;,ifp-&gt;name,inet_ntoa(*addr),prefixlen);</a>
<a name="ln283">    }</a>
<a name="ln284"> </a>
<a name="ln285">  /* Label of this address. */</a>
<a name="ln286">  if (label)</a>
<a name="ln287">    ifc-&gt;label = XSTRDUP (MTYPE_CONNECTED_LABEL, label);</a>
<a name="ln288"> </a>
<a name="ln289">  /* For all that I know an IPv4 address is always ready when we receive</a>
<a name="ln290">   * the notification. So it should be safe to set the REAL flag here. */</a>
<a name="ln291">  SET_FLAG(ifc-&gt;conf, ZEBRA_IFC_REAL);</a>
<a name="ln292"> </a>
<a name="ln293">  connected_update(ifp, ifc);</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">void</a>
<a name="ln297">connected_down_ipv4 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln298">{</a>
<a name="ln299">  struct prefix_ipv4 p;</a>
<a name="ln300"> </a>
<a name="ln301">  if (! CHECK_FLAG (ifc-&gt;conf, ZEBRA_IFC_REAL))</a>
<a name="ln302">    return;</a>
<a name="ln303"> </a>
<a name="ln304">  PREFIX_COPY_IPV4(&amp;p, CONNECTED_PREFIX(ifc));</a>
<a name="ln305"> </a>
<a name="ln306">  /* Apply mask to the network. */</a>
<a name="ln307">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln308"> </a>
<a name="ln309">  /* In case of connected address is 0.0.0.0/0 we treat it tunnel</a>
<a name="ln310">     address. */</a>
<a name="ln311">  if (prefix_ipv4_any (&amp;p))</a>
<a name="ln312">    return;</a>
<a name="ln313"> </a>
<a name="ln314">  /* Same logic as for connected_up_ipv4(): push the changes into the head. */</a>
<a name="ln315">  rib_delete_ipv4 (ZEBRA_ROUTE_CONNECT, 0, &amp;p, NULL, ifp-&gt;ifindex, ifp-&gt;vrf_id,</a>
<a name="ln316">                   SAFI_UNICAST);</a>
<a name="ln317"> </a>
<a name="ln318">  rib_delete_ipv4 (ZEBRA_ROUTE_CONNECT, 0, &amp;p, NULL, ifp-&gt;ifindex, ifp-&gt;vrf_id,</a>
<a name="ln319">                   SAFI_MULTICAST);</a>
<a name="ln320"> </a>
<a name="ln321">  rib_update (ifp-&gt;vrf_id);</a>
<a name="ln322">}</a>
<a name="ln323"> </a>
<a name="ln324">/* Delete connected IPv4 route to the interface. */</a>
<a name="ln325">void</a>
<a name="ln326">connected_delete_ipv4 (struct interface *ifp, int flags, struct in_addr *addr,</a>
<a name="ln327">		       u_char prefixlen, struct in_addr *broad)</a>
<a name="ln328">{</a>
<a name="ln329">  struct prefix_ipv4 p;</a>
<a name="ln330">  struct connected *ifc;</a>
<a name="ln331"> </a>
<a name="ln332">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln333">  p.family = AF_INET;</a>
<a name="ln334">  p.prefix = *addr;</a>
<a name="ln335">  p.prefixlen = prefixlen;</a>
<a name="ln336"> </a>
<a name="ln337">  ifc = connected_check (ifp, (struct prefix *) &amp;p);</a>
<a name="ln338">  if (! ifc)</a>
<a name="ln339">    return;</a>
<a name="ln340">    </a>
<a name="ln341">  connected_withdraw (ifc);</a>
<a name="ln342"> </a>
<a name="ln343">  rib_update (ifp-&gt;vrf_id);</a>
<a name="ln344">}</a>
<a name="ln345"> </a>
<a name="ln346">#ifdef HAVE_IPV6</a>
<a name="ln347">void</a>
<a name="ln348">connected_up_ipv6 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln349">{</a>
<a name="ln350">  struct prefix_ipv6 p;</a>
<a name="ln351"> </a>
<a name="ln352">  if (! CHECK_FLAG (ifc-&gt;conf, ZEBRA_IFC_REAL))</a>
<a name="ln353">    return;</a>
<a name="ln354"> </a>
<a name="ln355">  PREFIX_COPY_IPV6(&amp;p, CONNECTED_PREFIX(ifc));</a>
<a name="ln356"> </a>
<a name="ln357">  /* Apply mask to the network. */</a>
<a name="ln358">  apply_mask_ipv6 (&amp;p);</a>
<a name="ln359"> </a>
<a name="ln360">#ifndef LINUX</a>
<a name="ln361">  /* XXX: It is already done by rib_bogus_ipv6 within rib_add_ipv6 */</a>
<a name="ln362">  if (IN6_IS_ADDR_UNSPECIFIED (&amp;p.prefix))</a>
<a name="ln363">    return;</a>
<a name="ln364">#endif</a>
<a name="ln365"> </a>
<a name="ln366">  rib_add_ipv6 (ZEBRA_ROUTE_CONNECT, 0, &amp;p, NULL, ifp-&gt;ifindex, ifp-&gt;vrf_id,</a>
<a name="ln367">                RT_TABLE_MAIN, ifp-&gt;metric, 0, 0, SAFI_UNICAST);</a>
<a name="ln368"> </a>
<a name="ln369">  rib_update (ifp-&gt;vrf_id);</a>
<a name="ln370">}</a>
<a name="ln371"> </a>
<a name="ln372">/* Add connected IPv6 route to the interface. */</a>
<a name="ln373">void</a>
<a name="ln374">connected_add_ipv6 (struct interface *ifp, int flags, struct in6_addr *addr,</a>
<a name="ln375">		    u_char prefixlen, struct in6_addr *broad,</a>
<a name="ln376">		    const char *label)</a>
<a name="ln377">{</a>
<a name="ln378">  struct prefix_ipv6 *p;</a>
<a name="ln379">  struct connected *ifc;</a>
<a name="ln380"> </a>
<a name="ln381">  /* Make connected structure. */</a>
<a name="ln382">  ifc = connected_new ();</a>
<a name="ln383">  ifc-&gt;ifp = ifp;</a>
<a name="ln384">  ifc-&gt;flags = flags;</a>
<a name="ln385">  /* If we get a notification from the kernel,</a>
<a name="ln386">   * we can safely assume the address is known to the kernel */</a>
<a name="ln387">  SET_FLAG(ifc-&gt;conf, ZEBRA_IFC_QUEUED);</a>
<a name="ln388"> </a>
<a name="ln389">  /* Allocate new connected address. */</a>
<a name="ln390">  p = prefix_ipv6_new ();</a>
<a name="ln391">  p-&gt;family = AF_INET6;</a>
<a name="ln392">  IPV6_ADDR_COPY (&amp;p-&gt;prefix, addr);</a>
<a name="ln393">  p-&gt;prefixlen = prefixlen;</a>
<a name="ln394">  ifc-&gt;address = (struct prefix *) p;</a>
<a name="ln395"> </a>
<a name="ln396">  /* If there is broadcast or peer address. */</a>
<a name="ln397">  if (broad)</a>
<a name="ln398">    {</a>
<a name="ln399">      if (IN6_IS_ADDR_UNSPECIFIED(broad))</a>
<a name="ln400">	zlog_warn(&quot;warning: %s called for interface %s with unspecified &quot;</a>
<a name="ln401">		  &quot;destination address; ignoring!&quot;, __func__, ifp-&gt;name);</a>
<a name="ln402">      else</a>
<a name="ln403">	{</a>
<a name="ln404">	  p = prefix_ipv6_new ();</a>
<a name="ln405">	  p-&gt;family = AF_INET6;</a>
<a name="ln406">	  IPV6_ADDR_COPY (&amp;p-&gt;prefix, broad);</a>
<a name="ln407">	  p-&gt;prefixlen = prefixlen;</a>
<a name="ln408">	  ifc-&gt;destination = (struct prefix *) p;</a>
<a name="ln409">	}</a>
<a name="ln410">    }</a>
<a name="ln411">  if (CHECK_FLAG(ifc-&gt;flags, ZEBRA_IFA_PEER) &amp;&amp; !ifc-&gt;destination)</a>
<a name="ln412">    {</a>
<a name="ln413">      zlog_warn(&quot;warning: %s called for interface %s &quot;</a>
<a name="ln414">		&quot;with peer flag set, but no peer address supplied&quot;,</a>
<a name="ln415">		__func__, ifp-&gt;name);</a>
<a name="ln416">      UNSET_FLAG(ifc-&gt;flags, ZEBRA_IFA_PEER);</a>
<a name="ln417">    }</a>
<a name="ln418"> </a>
<a name="ln419">  /* Label of this address. */</a>
<a name="ln420">  if (label)</a>
<a name="ln421">    ifc-&gt;label = XSTRDUP (MTYPE_CONNECTED_LABEL, label);</a>
<a name="ln422"> </a>
<a name="ln423">  /* On Linux, we only get here when DAD is complete, therefore we can set</a>
<a name="ln424">   * ZEBRA_IFC_REAL.</a>
<a name="ln425">   *</a>
<a name="ln426">   * On BSD, there currently doesn't seem to be a way to check for completion of</a>
<a name="ln427">   * DAD, so we replicate the old behaviour and set ZEBRA_IFC_REAL, although DAD</a>
<a name="ln428">   * might still be running.</a>
<a name="ln429">   */</a>
<a name="ln430">  SET_FLAG(ifc-&gt;conf, ZEBRA_IFC_REAL);</a>
<a name="ln431">  connected_update(ifp, ifc);</a>
<a name="ln432">}</a>
<a name="ln433"> </a>
<a name="ln434">void</a>
<a name="ln435">connected_down_ipv6 (struct interface *ifp, struct connected *ifc)</a>
<a name="ln436">{</a>
<a name="ln437">  struct prefix_ipv6 p;</a>
<a name="ln438"> </a>
<a name="ln439">  if (! CHECK_FLAG (ifc-&gt;conf, ZEBRA_IFC_REAL))</a>
<a name="ln440">    return;</a>
<a name="ln441"> </a>
<a name="ln442">  PREFIX_COPY_IPV6(&amp;p, CONNECTED_PREFIX(ifc));</a>
<a name="ln443"> </a>
<a name="ln444">  apply_mask_ipv6 (&amp;p);</a>
<a name="ln445"> </a>
<a name="ln446">  if (IN6_IS_ADDR_UNSPECIFIED (&amp;p.prefix))</a>
<a name="ln447">    return;</a>
<a name="ln448"> </a>
<a name="ln449">  rib_delete_ipv6 (ZEBRA_ROUTE_CONNECT, 0, &amp;p, NULL, ifp-&gt;ifindex, ifp-&gt;vrf_id,</a>
<a name="ln450">                   SAFI_UNICAST);</a>
<a name="ln451"> </a>
<a name="ln452">  rib_update (ifp-&gt;vrf_id);</a>
<a name="ln453">}</a>
<a name="ln454"> </a>
<a name="ln455">void</a>
<a name="ln456">connected_delete_ipv6 (struct interface *ifp, struct in6_addr *address,</a>
<a name="ln457">		       u_char prefixlen, struct in6_addr *broad)</a>
<a name="ln458">{</a>
<a name="ln459">  struct prefix_ipv6 p;</a>
<a name="ln460">  struct connected *ifc;</a>
<a name="ln461">  </a>
<a name="ln462">  memset (&amp;p, 0, sizeof (struct prefix_ipv6));</a>
<a name="ln463">  p.family = AF_INET6;</a>
<a name="ln464">  memcpy (&amp;p.prefix, address, sizeof (struct in6_addr));</a>
<a name="ln465">  p.prefixlen = prefixlen;</a>
<a name="ln466"> </a>
<a name="ln467">  ifc = connected_check (ifp, (struct prefix *) &amp;p);</a>
<a name="ln468">  if (! ifc)</a>
<a name="ln469">    return;</a>
<a name="ln470"> </a>
<a name="ln471">  connected_withdraw (ifc);</a>
<a name="ln472"> </a>
<a name="ln473">  rib_update (ifp-&gt;vrf_id);</a>
<a name="ln474">}</a>
<a name="ln475">#endif /* HAVE_IPV6 */</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
