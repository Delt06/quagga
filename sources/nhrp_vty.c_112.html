
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_vty.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP vty handling</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;zebra.h&quot;</a>
<a name="ln11">#include &quot;command.h&quot;</a>
<a name="ln12">#include &quot;zclient.h&quot;</a>
<a name="ln13">#include &quot;stream.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;nhrpd.h&quot;</a>
<a name="ln16">#include &quot;netlink.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">static struct cmd_node zebra_node = {</a>
<a name="ln19">	.node   = ZEBRA_NODE,</a>
<a name="ln20">	.prompt = &quot;%s(config-router)# &quot;,</a>
<a name="ln21">	.vtysh  = 1,</a>
<a name="ln22">};</a>
<a name="ln23"> </a>
<a name="ln24">static struct cmd_node nhrp_interface_node = {</a>
<a name="ln25">	.node   = INTERFACE_NODE,</a>
<a name="ln26">	.prompt = &quot;%s(config-if)# &quot;,</a>
<a name="ln27">	.vtysh  = 1,</a>
<a name="ln28">};</a>
<a name="ln29"> </a>
<a name="ln30">#define NHRP_DEBUG_FLAGS_CMD &quot;(all|common|event|interface|kernel|route|vici)&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#define NHRP_DEBUG_FLAGS_STR		\</a>
<a name="ln33">	&quot;All messages\n&quot;		\</a>
<a name="ln34">	&quot;Common messages (default)\n&quot;	\</a>
<a name="ln35">	&quot;Event manager messages\n&quot;	\</a>
<a name="ln36">	&quot;Interface messages\n&quot;		\</a>
<a name="ln37">	&quot;Kernel messages\n&quot;		\</a>
<a name="ln38">	&quot;Route messages\n&quot;		\</a>
<a name="ln39">	&quot;VICI messages\n&quot;</a>
<a name="ln40"> </a>
<a name="ln41">static const struct message debug_flags_desc[] = {</a>
<a name="ln42">	{ NHRP_DEBUG_ALL, &quot;all&quot; },</a>
<a name="ln43">	{ NHRP_DEBUG_COMMON, &quot;common&quot; },</a>
<a name="ln44">	{ NHRP_DEBUG_IF, &quot;interface&quot; },</a>
<a name="ln45">	{ NHRP_DEBUG_KERNEL, &quot;kernel&quot; },</a>
<a name="ln46">	{ NHRP_DEBUG_ROUTE, &quot;route&quot; },</a>
<a name="ln47">	{ NHRP_DEBUG_VICI, &quot;vici&quot; },</a>
<a name="ln48">	{ NHRP_DEBUG_EVENT, &quot;event&quot; },</a>
<a name="ln49">	{ 0, NULL },</a>
<a name="ln50">};</a>
<a name="ln51"> </a>
<a name="ln52">static const struct message interface_flags_desc[] = {</a>
<a name="ln53">	{ NHRP_IFF_SHORTCUT, &quot;shortcut&quot; },</a>
<a name="ln54">	{ NHRP_IFF_REDIRECT, &quot;redirect&quot; },</a>
<a name="ln55">	{ NHRP_IFF_REG_NO_UNIQUE, &quot;registration no-unique&quot; },</a>
<a name="ln56">	{ 0, NULL },</a>
<a name="ln57">};</a>
<a name="ln58"> </a>
<a name="ln59">static int nhrp_vty_return(struct vty *vty, int ret)</a>
<a name="ln60">{</a>
<a name="ln61">	static const char * const errmsgs[] = {</a>
<a name="ln62">		[NHRP_ERR_FAIL]				= &quot;Command failed&quot;,</a>
<a name="ln63">		[NHRP_ERR_NO_MEMORY]			= &quot;Out of memory&quot;,</a>
<a name="ln64">		[NHRP_ERR_UNSUPPORTED_INTERFACE]	= &quot;NHRP not supported on this interface&quot;,</a>
<a name="ln65">		[NHRP_ERR_NHRP_NOT_ENABLED]		= &quot;NHRP not enabled (set 'nhrp network-id' first)&quot;,</a>
<a name="ln66">		[NHRP_ERR_ENTRY_EXISTS]			= &quot;Entry exists already&quot;,</a>
<a name="ln67">		[NHRP_ERR_ENTRY_NOT_FOUND]		= &quot;Entry not found&quot;,</a>
<a name="ln68">		[NHRP_ERR_PROTOCOL_ADDRESS_MISMATCH]	= &quot;Protocol address family does not match command (ip/ipv6 mismatch)&quot;,</a>
<a name="ln69">	};</a>
<a name="ln70">	const char *str = NULL;</a>
<a name="ln71">	char buf[256];</a>
<a name="ln72"> </a>
<a name="ln73">	if (ret == NHRP_OK)</a>
<a name="ln74">		return CMD_SUCCESS;</a>
<a name="ln75"> </a>
<a name="ln76">	if (ret &gt; 0 &amp;&amp; ret &lt;= (int)ZEBRA_NUM_OF(errmsgs))</a>
<a name="ln77">		if (errmsgs[ret])</a>
<a name="ln78">			str = errmsgs[ret];</a>
<a name="ln79"> </a>
<a name="ln80">	if (!str) {</a>
<a name="ln81">		str = buf;</a>
<a name="ln82">		snprintf(buf, sizeof(buf), &quot;Unknown error %d&quot;, ret);</a>
<a name="ln83">	}</a>
<a name="ln84"> </a>
<a name="ln85">	vty_out (vty, &quot;%% %s%s&quot;, str, VTY_NEWLINE);</a>
<a name="ln86"> </a>
<a name="ln87">	return CMD_WARNING;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">static int toggle_flag(</a>
<a name="ln91">	struct vty *vty, const struct message *flag_desc,</a>
<a name="ln92">	const char *name, int on_off, unsigned *flags)</a>
<a name="ln93">{</a>
<a name="ln94">	int i;</a>
<a name="ln95"> </a>
<a name="ln96">	for (i = 0; flag_desc[i].str != NULL; i++) {</a>
<a name="ln97">		if (strcmp(flag_desc[i].str, name) != 0)</a>
<a name="ln98">			continue;</a>
<a name="ln99">		if (on_off)</a>
<a name="ln100">			*flags |= flag_desc[i].key;</a>
<a name="ln101">		else</a>
<a name="ln102">			*flags &amp;= ~flag_desc[i].key;</a>
<a name="ln103">		return CMD_SUCCESS;</a>
<a name="ln104">	}</a>
<a name="ln105"> </a>
<a name="ln106">	vty_out(vty, &quot;%% Invalid value %s%s&quot;, name, VTY_NEWLINE);</a>
<a name="ln107">	return CMD_WARNING;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">#ifndef NO_DEBUG</a>
<a name="ln111"> </a>
<a name="ln112">DEFUN(show_debugging_nhrp, show_debugging_nhrp_cmd,</a>
<a name="ln113">	&quot;show debugging nhrp&quot;,</a>
<a name="ln114">	SHOW_STR</a>
<a name="ln115">	&quot;Debugging information\n&quot;</a>
<a name="ln116">	&quot;NHRP configuration\n&quot;)</a>
<a name="ln117">{</a>
<a name="ln118">	int i;</a>
<a name="ln119"> </a>
<a name="ln120">	vty_out(vty, &quot;NHRP debugging status:%s&quot;, VTY_NEWLINE);</a>
<a name="ln121"> </a>
<a name="ln122">	for (i = 0; debug_flags_desc[i].str != NULL; i++) {</a>
<a name="ln123">		if (debug_flags_desc[i].key == NHRP_DEBUG_ALL)</a>
<a name="ln124">			continue;</a>
<a name="ln125">		if (!(debug_flags_desc[i].key &amp; debug_flags))</a>
<a name="ln126">			continue;</a>
<a name="ln127"> </a>
<a name="ln128">		vty_out(vty, &quot;  NHRP %s debugging is on%s&quot;,</a>
<a name="ln129">			debug_flags_desc[i].str, VTY_NEWLINE);</a>
<a name="ln130">	}</a>
<a name="ln131"> </a>
<a name="ln132">	return CMD_SUCCESS;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">DEFUN(debug_nhrp, debug_nhrp_cmd,</a>
<a name="ln136">	&quot;debug nhrp &quot; NHRP_DEBUG_FLAGS_CMD,</a>
<a name="ln137">	&quot;Enable debug messages for specific or all parts.\n&quot;</a>
<a name="ln138">	&quot;NHRP information\n&quot;</a>
<a name="ln139">	NHRP_DEBUG_FLAGS_STR)</a>
<a name="ln140">{</a>
<a name="ln141">	return toggle_flag(vty, debug_flags_desc, argv[0], 1, &amp;debug_flags);</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">DEFUN(no_debug_nhrp, no_debug_nhrp_cmd,</a>
<a name="ln145">	&quot;no debug nhrp &quot; NHRP_DEBUG_FLAGS_CMD,</a>
<a name="ln146">	NO_STR</a>
<a name="ln147">	&quot;Disable debug messages for specific or all parts.\n&quot;</a>
<a name="ln148">	&quot;NHRP information\n&quot;</a>
<a name="ln149">	NHRP_DEBUG_FLAGS_STR)</a>
<a name="ln150">{</a>
<a name="ln151">	return toggle_flag(vty, debug_flags_desc, argv[0], 0, &amp;debug_flags);</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">#endif /* NO_DEBUG */</a>
<a name="ln155"> </a>
<a name="ln156">static int nhrp_config_write(struct vty *vty)</a>
<a name="ln157">{</a>
<a name="ln158">#ifndef NO_DEBUG</a>
<a name="ln159">	if (debug_flags == NHRP_DEBUG_ALL) {</a>
<a name="ln160">		vty_out(vty, &quot;debug nhrp all%s&quot;, VTY_NEWLINE);</a>
<a name="ln161">	} else {</a>
<a name="ln162">		int i;</a>
<a name="ln163"> </a>
<a name="ln164">		for (i = 0; debug_flags_desc[i].str != NULL; i++) {</a>
<a name="ln165">			if (debug_flags_desc[i].key == NHRP_DEBUG_ALL)</a>
<a name="ln166">				continue;</a>
<a name="ln167">			if (!(debug_flags &amp; debug_flags_desc[i].key))</a>
<a name="ln168">				continue;</a>
<a name="ln169">			vty_out(vty, &quot;debug nhrp %s%s&quot;, debug_flags_desc[i].str, VTY_NEWLINE);</a>
<a name="ln170">		}</a>
<a name="ln171">	}</a>
<a name="ln172">	vty_out(vty, &quot;!%s&quot;, VTY_NEWLINE);</a>
<a name="ln173">#endif /* NO_DEBUG */</a>
<a name="ln174"> </a>
<a name="ln175">	if (nhrp_event_socket_path) {</a>
<a name="ln176">		vty_out(vty, &quot;nhrp event socket %s%s&quot;,</a>
<a name="ln177">			nhrp_event_socket_path, VTY_NEWLINE);</a>
<a name="ln178">	}</a>
<a name="ln179">	if (netlink_nflog_group) {</a>
<a name="ln180">		vty_out(vty, &quot;nhrp nflog-group %d%s&quot;,</a>
<a name="ln181">			netlink_nflog_group, VTY_NEWLINE);</a>
<a name="ln182">	}</a>
<a name="ln183"> </a>
<a name="ln184">	return 0;</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">#define IP_STR		&quot;IP information\n&quot;</a>
<a name="ln188">#define IPV6_STR	&quot;IPv6 information\n&quot;</a>
<a name="ln189">#define AFI_CMD		&quot;(ip|ipv6)&quot;</a>
<a name="ln190">#define AFI_STR		IP_STR IPV6_STR</a>
<a name="ln191">#define NHRP_STR	&quot;Next Hop Resolution Protocol functions\n&quot;</a>
<a name="ln192"> </a>
<a name="ln193">static afi_t cmd_to_afi(const char *cmd)</a>
<a name="ln194">{</a>
<a name="ln195">	return strncmp(cmd, &quot;ipv6&quot;, 4) == 0 ? AFI_IP6 : AFI_IP;</a>
<a name="ln196">}</a>
<a name="ln197"> </a>
<a name="ln198">static const char *afi_to_cmd(afi_t afi)</a>
<a name="ln199">{</a>
<a name="ln200">	if (afi == AFI_IP6) return &quot;ipv6&quot;;</a>
<a name="ln201">	return &quot;ip&quot;;</a>
<a name="ln202">}</a>
<a name="ln203"> </a>
<a name="ln204">DEFUN(nhrp_event_socket, nhrp_event_socket_cmd,</a>
<a name="ln205">	&quot;nhrp event socket SOCKET&quot;,</a>
<a name="ln206">	NHRP_STR</a>
<a name="ln207">	&quot;Event Manager commands\n&quot;</a>
<a name="ln208">	&quot;Event Manager unix socket path\n&quot;</a>
<a name="ln209">	&quot;Unix path for the socket\n&quot;)</a>
<a name="ln210">{</a>
<a name="ln211">	evmgr_set_socket(argv[0]);</a>
<a name="ln212">	return CMD_SUCCESS;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">DEFUN(no_nhrp_event_socket, no_nhrp_event_socket_cmd,</a>
<a name="ln216">	&quot;no nhrp event socket [SOCKET]&quot;,</a>
<a name="ln217">	NO_STR</a>
<a name="ln218">	NHRP_STR</a>
<a name="ln219">	&quot;Event Manager commands\n&quot;</a>
<a name="ln220">	&quot;Event Manager unix socket path\n&quot;</a>
<a name="ln221">	&quot;Unix path for the socket\n&quot;)</a>
<a name="ln222">{</a>
<a name="ln223">	evmgr_set_socket(NULL);</a>
<a name="ln224">	return CMD_SUCCESS;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">DEFUN(nhrp_nflog_group, nhrp_nflog_group_cmd,</a>
<a name="ln228">	&quot;nhrp nflog-group &lt;1-65535&gt;&quot;,</a>
<a name="ln229">	NHRP_STR</a>
<a name="ln230">	&quot;Specify NFLOG group number\n&quot;</a>
<a name="ln231">	&quot;NFLOG group number\n&quot;)</a>
<a name="ln232">{</a>
<a name="ln233">	uint32_t nfgroup;</a>
<a name="ln234"> </a>
<a name="ln235">	VTY_GET_INTEGER_RANGE(&quot;nflog-group&quot;, nfgroup, argv[0], 1, 65535);</a>
<a name="ln236">	netlink_set_nflog_group(nfgroup);</a>
<a name="ln237"> </a>
<a name="ln238">	return CMD_SUCCESS;</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">DEFUN(no_nhrp_nflog_group, no_nhrp_nflog_group_cmd,</a>
<a name="ln242">	&quot;no nhrp nflog-group [&lt;1-65535&gt;]&quot;,</a>
<a name="ln243">	NO_STR</a>
<a name="ln244">	NHRP_STR</a>
<a name="ln245">	&quot;Specify NFLOG group number\n&quot;</a>
<a name="ln246">	&quot;NFLOG group number\n&quot;)</a>
<a name="ln247">{</a>
<a name="ln248">	netlink_set_nflog_group(0);</a>
<a name="ln249">	return CMD_SUCCESS;</a>
<a name="ln250">}</a>
<a name="ln251"> </a>
<a name="ln252">DEFUN(tunnel_protection, tunnel_protection_cmd,</a>
<a name="ln253">	&quot;tunnel protection vici profile PROFILE {fallback-profile FALLBACK}&quot;,</a>
<a name="ln254">	&quot;NHRP/GRE integration\n&quot;</a>
<a name="ln255">	&quot;IPsec protection\n&quot;</a>
<a name="ln256">	&quot;VICI (StrongSwan)\n&quot;</a>
<a name="ln257">	&quot;IPsec profile\n&quot;</a>
<a name="ln258">	&quot;IPsec profile name\n&quot;</a>
<a name="ln259">	&quot;Fallback IPsec profile\n&quot;</a>
<a name="ln260">	&quot;Fallback IPsec profile name\n&quot;)</a>
<a name="ln261">{</a>
<a name="ln262">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln263"> </a>
<a name="ln264">	nhrp_interface_set_protection(ifp, argv[0], argv[1]);</a>
<a name="ln265">	return CMD_SUCCESS;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">DEFUN(no_tunnel_protection, no_tunnel_protection_cmd,</a>
<a name="ln269">	&quot;no tunnel protection&quot;,</a>
<a name="ln270">	NO_STR</a>
<a name="ln271">	&quot;NHRP/GRE integration\n&quot;</a>
<a name="ln272">	&quot;IPsec protection\n&quot;)</a>
<a name="ln273">{</a>
<a name="ln274">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln275"> </a>
<a name="ln276">	nhrp_interface_set_protection(ifp, NULL, NULL);</a>
<a name="ln277">	return CMD_SUCCESS;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">DEFUN(tunnel_source, tunnel_source_cmd,</a>
<a name="ln281">	&quot;tunnel source INTERFACE&quot;,</a>
<a name="ln282">	&quot;NHRP/GRE integration\n&quot;</a>
<a name="ln283">	&quot;Tunnel device binding tracking\n&quot;</a>
<a name="ln284">	&quot;Interface name\n&quot;)</a>
<a name="ln285">{</a>
<a name="ln286">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln287">	nhrp_interface_set_source(ifp, argv[0]);</a>
<a name="ln288">	return CMD_SUCCESS;</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">DEFUN(no_tunnel_source, no_tunnel_source_cmd,</a>
<a name="ln292">	&quot;no tunnel source&quot;,</a>
<a name="ln293">	&quot;NHRP/GRE integration\n&quot;</a>
<a name="ln294">	&quot;Tunnel device binding tracking\n&quot;</a>
<a name="ln295">	&quot;Interface name\n&quot;)</a>
<a name="ln296">{</a>
<a name="ln297">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln298">	nhrp_interface_set_source(ifp, NULL);</a>
<a name="ln299">	return CMD_SUCCESS;</a>
<a name="ln300">}</a>
<a name="ln301"> </a>
<a name="ln302">DEFUN(if_nhrp_network_id, if_nhrp_network_id_cmd,</a>
<a name="ln303">	AFI_CMD &quot; nhrp network-id &lt;1-4294967295&gt;&quot;,</a>
<a name="ln304">	AFI_STR</a>
<a name="ln305">	NHRP_STR</a>
<a name="ln306">	&quot;Enable NHRP and specify network-id\n&quot;</a>
<a name="ln307">	&quot;System local ID to specify interface group\n&quot;)</a>
<a name="ln308">{</a>
<a name="ln309">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln310">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln311">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln312"> </a>
<a name="ln313">	VTY_GET_INTEGER_RANGE(&quot;network-id&quot;, nifp-&gt;afi[afi].network_id, argv[1], 1, 4294967295);</a>
<a name="ln314">	nhrp_interface_update(ifp);</a>
<a name="ln315"> </a>
<a name="ln316">	return CMD_SUCCESS;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">DEFUN(if_no_nhrp_network_id, if_no_nhrp_network_id_cmd,</a>
<a name="ln320">	&quot;no &quot; AFI_CMD &quot; nhrp network-id [&lt;1-4294967295&gt;]&quot;,</a>
<a name="ln321">	NO_STR</a>
<a name="ln322">	AFI_STR</a>
<a name="ln323">	NHRP_STR</a>
<a name="ln324">	&quot;Enable NHRP and specify network-id\n&quot;</a>
<a name="ln325">	&quot;System local ID to specify interface group\n&quot;)</a>
<a name="ln326">{</a>
<a name="ln327">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln328">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln329">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln330"> </a>
<a name="ln331">	nifp-&gt;afi[afi].network_id = 0;</a>
<a name="ln332">	nhrp_interface_update(ifp);</a>
<a name="ln333"> </a>
<a name="ln334">	return CMD_SUCCESS;</a>
<a name="ln335">}</a>
<a name="ln336"> </a>
<a name="ln337">DEFUN(if_nhrp_flags, if_nhrp_flags_cmd,</a>
<a name="ln338">	AFI_CMD &quot; nhrp (shortcut|redirect)&quot;,</a>
<a name="ln339">	AFI_STR</a>
<a name="ln340">	NHRP_STR</a>
<a name="ln341">	&quot;Allow shortcut establishment\n&quot;</a>
<a name="ln342">	&quot;Send redirect notifications\n&quot;)</a>
<a name="ln343">{</a>
<a name="ln344">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln345">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln346">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln347"> </a>
<a name="ln348">	return toggle_flag(vty, interface_flags_desc, argv[1], 1, &amp;nifp-&gt;afi[afi].flags);</a>
<a name="ln349">}</a>
<a name="ln350"> </a>
<a name="ln351">DEFUN(if_no_nhrp_flags, if_no_nhrp_flags_cmd,</a>
<a name="ln352">	&quot;no &quot; AFI_CMD &quot; nhrp (shortcut|redirect)&quot;,</a>
<a name="ln353">	NO_STR</a>
<a name="ln354">	AFI_STR</a>
<a name="ln355">	NHRP_STR</a>
<a name="ln356">	&quot;Allow shortcut establishment\n&quot;</a>
<a name="ln357">	&quot;Send redirect notifications\n&quot;)</a>
<a name="ln358">{</a>
<a name="ln359">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln360">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln361">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln362"> </a>
<a name="ln363">	return toggle_flag(vty, interface_flags_desc, argv[1], 0, &amp;nifp-&gt;afi[afi].flags);</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">DEFUN(if_nhrp_reg_flags, if_nhrp_reg_flags_cmd,</a>
<a name="ln367">	AFI_CMD &quot; nhrp registration (no-unique)&quot;,</a>
<a name="ln368">	AFI_STR</a>
<a name="ln369">	NHRP_STR</a>
<a name="ln370">	&quot;Registration configuration\n&quot;</a>
<a name="ln371">	&quot;Don't set unique flag\n&quot;)</a>
<a name="ln372">{</a>
<a name="ln373">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln374">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln375">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln376">	char name[256];</a>
<a name="ln377">	snprintf(name, sizeof(name), &quot;registration %s&quot;, argv[1]);</a>
<a name="ln378">	return toggle_flag(vty, interface_flags_desc, name, 1, &amp;nifp-&gt;afi[afi].flags);</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">DEFUN(if_no_nhrp_reg_flags, if_no_nhrp_reg_flags_cmd,</a>
<a name="ln382">	&quot;no &quot; AFI_CMD &quot; nhrp registration (no-unique)&quot;,</a>
<a name="ln383">	NO_STR</a>
<a name="ln384">	AFI_STR</a>
<a name="ln385">	NHRP_STR</a>
<a name="ln386">	&quot;Registration configuration\n&quot;</a>
<a name="ln387">	&quot;Don't set unique flag\n&quot;)</a>
<a name="ln388">{</a>
<a name="ln389">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln390">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln391">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln392">	char name[256];</a>
<a name="ln393">	snprintf(name, sizeof(name), &quot;registration %s&quot;, argv[1]);</a>
<a name="ln394">	return toggle_flag(vty, interface_flags_desc, name, 0, &amp;nifp-&gt;afi[afi].flags);</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">DEFUN(if_nhrp_holdtime, if_nhrp_holdtime_cmd,</a>
<a name="ln398">	AFI_CMD &quot; nhrp holdtime &lt;1-65000&gt;&quot;,</a>
<a name="ln399">	AFI_STR</a>
<a name="ln400">	NHRP_STR</a>
<a name="ln401">	&quot;Specify NBMA address validity time\n&quot;</a>
<a name="ln402">	&quot;Time in seconds that NBMA addresses are advertised valid\n&quot;)</a>
<a name="ln403">{</a>
<a name="ln404">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln405">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln406">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln407"> </a>
<a name="ln408">	VTY_GET_INTEGER_RANGE(&quot;holdtime&quot;, nifp-&gt;afi[afi].holdtime, argv[1], 1, 65000);</a>
<a name="ln409">	nhrp_interface_update(ifp);</a>
<a name="ln410"> </a>
<a name="ln411">	return CMD_SUCCESS;</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">DEFUN(if_no_nhrp_holdtime, if_no_nhrp_holdtime_cmd,</a>
<a name="ln415">	&quot;no &quot; AFI_CMD &quot; nhrp holdtime [1-65000]&quot;,</a>
<a name="ln416">	NO_STR</a>
<a name="ln417">	AFI_STR</a>
<a name="ln418">	NHRP_STR</a>
<a name="ln419">	&quot;Specify NBMA address validity time\n&quot;</a>
<a name="ln420">	&quot;Time in seconds that NBMA addresses are advertised valid\n&quot;)</a>
<a name="ln421">{</a>
<a name="ln422">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln423">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln424">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln425"> </a>
<a name="ln426">	nifp-&gt;afi[afi].holdtime = NHRPD_DEFAULT_HOLDTIME;</a>
<a name="ln427">	nhrp_interface_update(ifp);</a>
<a name="ln428"> </a>
<a name="ln429">	return CMD_SUCCESS;</a>
<a name="ln430">}</a>
<a name="ln431"> </a>
<a name="ln432">DEFUN(if_nhrp_mtu, if_nhrp_mtu_cmd,</a>
<a name="ln433">	&quot;ip nhrp mtu (&lt;576-1500&gt;|opennhrp)&quot;,</a>
<a name="ln434">	IP_STR</a>
<a name="ln435">	NHRP_STR</a>
<a name="ln436">	&quot;Configure NHRP advertised MTU\n&quot;</a>
<a name="ln437">	&quot;MTU value\n&quot;</a>
<a name="ln438">	&quot;Advertise bound interface MTU similar to OpenNHRP&quot;)</a>
<a name="ln439">{</a>
<a name="ln440">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln441">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln442"> </a>
<a name="ln443">	if (argv[0][0] == 'o') {</a>
<a name="ln444">		nifp-&gt;afi[AFI_IP].configured_mtu = -1;</a>
<a name="ln445">	} else {</a>
<a name="ln446">		VTY_GET_INTEGER_RANGE(&quot;mtu&quot;, nifp-&gt;afi[AFI_IP].configured_mtu, argv[0], 576, 1500);</a>
<a name="ln447">	}</a>
<a name="ln448">	nhrp_interface_update_mtu(ifp, AFI_IP);</a>
<a name="ln449"> </a>
<a name="ln450">	return CMD_SUCCESS;</a>
<a name="ln451">}</a>
<a name="ln452"> </a>
<a name="ln453">DEFUN(if_no_nhrp_mtu, if_no_nhrp_mtu_cmd,</a>
<a name="ln454">	&quot;no ip nhrp mtu [(&lt;576-1500&gt;|opennhrp)]&quot;,</a>
<a name="ln455">	NO_STR</a>
<a name="ln456">	IP_STR</a>
<a name="ln457">	NHRP_STR</a>
<a name="ln458">	&quot;Configure NHRP advertised MTU\n&quot;</a>
<a name="ln459">	&quot;MTU value\n&quot;</a>
<a name="ln460">	&quot;Advertise bound interface MTU similar to OpenNHRP&quot;)</a>
<a name="ln461">{</a>
<a name="ln462">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln463">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln464"> </a>
<a name="ln465">	nifp-&gt;afi[AFI_IP].configured_mtu = 0;</a>
<a name="ln466">	nhrp_interface_update_mtu(ifp, AFI_IP);</a>
<a name="ln467">	return CMD_SUCCESS;</a>
<a name="ln468">}</a>
<a name="ln469"> </a>
<a name="ln470">DEFUN(if_nhrp_map, if_nhrp_map_cmd,</a>
<a name="ln471">	AFI_CMD &quot; nhrp map (A.B.C.D|X:X::X:X) (A.B.C.D|local)&quot;,</a>
<a name="ln472">	AFI_STR</a>
<a name="ln473">	NHRP_STR</a>
<a name="ln474">	&quot;Nexthop Server configuration\n&quot;</a>
<a name="ln475">	&quot;IPv4 protocol address\n&quot;</a>
<a name="ln476">	&quot;IPv6 protocol address\n&quot;</a>
<a name="ln477">	&quot;IPv4 NBMA address\n&quot;</a>
<a name="ln478">	&quot;Handle protocol address locally\n&quot;)</a>
<a name="ln479">{</a>
<a name="ln480">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln481">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln482">	union sockunion proto_addr, nbma_addr;</a>
<a name="ln483">	struct nhrp_cache *c;</a>
<a name="ln484"> </a>
<a name="ln485">	if (str2sockunion(argv[1], &amp;proto_addr) &lt; 0 ||</a>
<a name="ln486">	    afi2family(afi) != sockunion_family(&amp;proto_addr))</a>
<a name="ln487">		return nhrp_vty_return(vty, NHRP_ERR_PROTOCOL_ADDRESS_MISMATCH);</a>
<a name="ln488"> </a>
<a name="ln489">	c = nhrp_cache_get(ifp, &amp;proto_addr, 1);</a>
<a name="ln490">	if (!c)</a>
<a name="ln491">		return nhrp_vty_return(vty, NHRP_ERR_FAIL);</a>
<a name="ln492"> </a>
<a name="ln493">	c-&gt;map = 1;</a>
<a name="ln494">	if (strcmp(argv[2], &quot;local&quot;) == 0) {</a>
<a name="ln495">		nhrp_cache_update_binding(c, NHRP_CACHE_LOCAL, 0, NULL, 0, NULL);</a>
<a name="ln496">	} else{</a>
<a name="ln497">		if (str2sockunion(argv[2], &amp;nbma_addr) &lt; 0)</a>
<a name="ln498">			return nhrp_vty_return(vty, NHRP_ERR_FAIL);</a>
<a name="ln499">		nhrp_cache_update_binding(c, NHRP_CACHE_STATIC, 0,</a>
<a name="ln500">			nhrp_peer_get(ifp, &amp;nbma_addr), 0, NULL);</a>
<a name="ln501">	}</a>
<a name="ln502"> </a>
<a name="ln503">	return CMD_SUCCESS;</a>
<a name="ln504">}</a>
<a name="ln505"> </a>
<a name="ln506">DEFUN(if_no_nhrp_map, if_no_nhrp_map_cmd,</a>
<a name="ln507">	&quot;no &quot; AFI_CMD &quot; nhrp map (A.B.C.D|X:X::X:X)&quot;,</a>
<a name="ln508">	NO_STR</a>
<a name="ln509">	AFI_STR</a>
<a name="ln510">	NHRP_STR</a>
<a name="ln511">	&quot;Nexthop Server configuration\n&quot;</a>
<a name="ln512">	&quot;IPv4 protocol address\n&quot;</a>
<a name="ln513">	&quot;IPv6 protocol address\n&quot;)</a>
<a name="ln514">{</a>
<a name="ln515">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln516">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln517">	union sockunion proto_addr;</a>
<a name="ln518">	struct nhrp_cache *c;</a>
<a name="ln519"> </a>
<a name="ln520">	if (str2sockunion(argv[1], &amp;proto_addr) &lt; 0 ||</a>
<a name="ln521">	    afi2family(afi) != sockunion_family(&amp;proto_addr))</a>
<a name="ln522">		return nhrp_vty_return(vty, NHRP_ERR_PROTOCOL_ADDRESS_MISMATCH);</a>
<a name="ln523"> </a>
<a name="ln524">	c = nhrp_cache_get(ifp, &amp;proto_addr, 0);</a>
<a name="ln525">	if (!c || !c-&gt;map)</a>
<a name="ln526">		return nhrp_vty_return(vty, NHRP_ERR_ENTRY_NOT_FOUND);</a>
<a name="ln527"> </a>
<a name="ln528">	nhrp_cache_update_binding(c, c-&gt;cur.type, -1, NULL, 0, NULL);</a>
<a name="ln529">	return CMD_SUCCESS;</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">DEFUN(if_nhrp_nhs, if_nhrp_nhs_cmd,</a>
<a name="ln533">	AFI_CMD &quot; nhrp nhs (A.B.C.D|X:X::X:X|dynamic) nbma (A.B.C.D|FQDN)&quot;,</a>
<a name="ln534">	AFI_STR</a>
<a name="ln535">	NHRP_STR</a>
<a name="ln536">	&quot;Nexthop Server configuration\n&quot;</a>
<a name="ln537">	&quot;IPv4 protocol address\n&quot;</a>
<a name="ln538">	&quot;IPv6 protocol address\n&quot;</a>
<a name="ln539">	&quot;Automatic detection of protocol address\n&quot;</a>
<a name="ln540">	&quot;IPv4 NBMA address\n&quot;</a>
<a name="ln541">	&quot;Fully qualified domain name for NBMA address(es)\n&quot;)</a>
<a name="ln542">{</a>
<a name="ln543">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln544">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln545">	union sockunion proto_addr;</a>
<a name="ln546">	int ret;</a>
<a name="ln547"> </a>
<a name="ln548">	if (str2sockunion(argv[1], &amp;proto_addr) &lt; 0)</a>
<a name="ln549">		sockunion_family(&amp;proto_addr) = AF_UNSPEC;</a>
<a name="ln550"> </a>
<a name="ln551">	ret = nhrp_nhs_add(ifp, afi, &amp;proto_addr, argv[2]);</a>
<a name="ln552">	return nhrp_vty_return(vty, ret);</a>
<a name="ln553">}</a>
<a name="ln554"> </a>
<a name="ln555">DEFUN(if_no_nhrp_nhs, if_no_nhrp_nhs_cmd,</a>
<a name="ln556">	&quot;no &quot; AFI_CMD &quot; nhrp nhs (A.B.C.D|X:X::X:X|dynamic) nbma (A.B.C.D|FQDN)&quot;,</a>
<a name="ln557">	NO_STR</a>
<a name="ln558">	AFI_STR</a>
<a name="ln559">	NHRP_STR</a>
<a name="ln560">	&quot;Nexthop Server configuration\n&quot;</a>
<a name="ln561">	&quot;IPv4 protocol address\n&quot;</a>
<a name="ln562">	&quot;IPv6 protocol address\n&quot;</a>
<a name="ln563">	&quot;Automatic detection of protocol address\n&quot;</a>
<a name="ln564">	&quot;IPv4 NBMA address\n&quot;</a>
<a name="ln565">	&quot;Fully qualified domain name for NBMA address(es)\n&quot;)</a>
<a name="ln566">{</a>
<a name="ln567">	struct interface *ifp = vty-&gt;index;</a>
<a name="ln568">	afi_t afi = cmd_to_afi(argv[0]);</a>
<a name="ln569">	union sockunion proto_addr;</a>
<a name="ln570">	int ret;</a>
<a name="ln571"> </a>
<a name="ln572">	if (str2sockunion(argv[1], &amp;proto_addr) &lt; 0)</a>
<a name="ln573">		sockunion_family(&amp;proto_addr) = AF_UNSPEC;</a>
<a name="ln574"> </a>
<a name="ln575">	ret = nhrp_nhs_del(ifp, afi, &amp;proto_addr, argv[2]);</a>
<a name="ln576">	return nhrp_vty_return(vty, ret);</a>
<a name="ln577">}</a>
<a name="ln578"> </a>
<a name="ln579">struct info_ctx {</a>
<a name="ln580">	struct vty *vty;</a>
<a name="ln581">	afi_t afi;</a>
<a name="ln582">	int count;</a>
<a name="ln583">};</a>
<a name="ln584"> </a>
<a name="ln585">static void show_ip_nhrp_cache(struct nhrp_cache *c, void *pctx)</a>
<a name="ln586">{</a>
<a name="ln587">	struct info_ctx *ctx = pctx;</a>
<a name="ln588">	struct vty *vty = ctx-&gt;vty;</a>
<a name="ln589">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln590"> </a>
<a name="ln591">	if (ctx-&gt;afi != family2afi(sockunion_family(&amp;c-&gt;remote_addr)))</a>
<a name="ln592">		return;</a>
<a name="ln593"> </a>
<a name="ln594">	if (!ctx-&gt;count) {</a>
<a name="ln595">		vty_out(vty, &quot;%-8s %-8s %-24s %-24s %-6s %s%s&quot;,</a>
<a name="ln596">			&quot;Iface&quot;,</a>
<a name="ln597">			&quot;Type&quot;,</a>
<a name="ln598">			&quot;Protocol&quot;,</a>
<a name="ln599">			&quot;NBMA&quot;,</a>
<a name="ln600">			&quot;Flags&quot;,</a>
<a name="ln601">			&quot;Identity&quot;,</a>
<a name="ln602">			VTY_NEWLINE);</a>
<a name="ln603">	}</a>
<a name="ln604">	ctx-&gt;count++;</a>
<a name="ln605"> </a>
<a name="ln606">	vty_out(ctx-&gt;vty, &quot;%-8s %-8s %-24s %-24s %c%c%c    %s%s&quot;,</a>
<a name="ln607">		c-&gt;ifp-&gt;name,</a>
<a name="ln608">		nhrp_cache_type_str[c-&gt;cur.type],</a>
<a name="ln609">		sockunion2str(&amp;c-&gt;remote_addr, buf[0], sizeof buf[0]),</a>
<a name="ln610">		c-&gt;cur.peer ? sockunion2str(&amp;c-&gt;cur.peer-&gt;vc-&gt;remote.nbma, buf[1], sizeof buf[1]) : &quot;-&quot;,</a>
<a name="ln611">		c-&gt;used ? 'U' : ' ',</a>
<a name="ln612">		c-&gt;t_timeout ? 'T' : ' ',</a>
<a name="ln613">		c-&gt;t_auth ? 'A' : ' ',</a>
<a name="ln614">		c-&gt;cur.peer ? c-&gt;cur.peer-&gt;vc-&gt;remote.id : &quot;-&quot;,</a>
<a name="ln615">		VTY_NEWLINE);</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">static void show_ip_nhrp_nhs(struct nhrp_nhs *n, struct nhrp_registration *reg, void *pctx)</a>
<a name="ln619">{</a>
<a name="ln620">	struct info_ctx *ctx = pctx;</a>
<a name="ln621">	struct vty *vty = ctx-&gt;vty;</a>
<a name="ln622">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln623"> </a>
<a name="ln624">	if (!ctx-&gt;count) {</a>
<a name="ln625">		vty_out(vty, &quot;%-8s %-24s %-16s %-16s%s&quot;,</a>
<a name="ln626">			&quot;Iface&quot;,</a>
<a name="ln627">			&quot;FQDN&quot;,</a>
<a name="ln628">			&quot;NBMA&quot;,</a>
<a name="ln629">			&quot;Protocol&quot;,</a>
<a name="ln630">			VTY_NEWLINE);</a>
<a name="ln631">	}</a>
<a name="ln632">	ctx-&gt;count++;</a>
<a name="ln633"> </a>
<a name="ln634">	vty_out(vty, &quot;%-8s %-24s %-16s %-16s%s&quot;,</a>
<a name="ln635">		n-&gt;ifp-&gt;name,</a>
<a name="ln636">		n-&gt;nbma_fqdn,</a>
<a name="ln637">		(reg &amp;&amp; reg-&gt;peer) ? sockunion2str(&amp;reg-&gt;peer-&gt;vc-&gt;remote.nbma, buf[0], sizeof buf[0]) : &quot;-&quot;,</a>
<a name="ln638">		sockunion2str(reg ? &amp;reg-&gt;proto_addr : &amp;n-&gt;proto_addr, buf[1], sizeof buf[1]),</a>
<a name="ln639">		VTY_NEWLINE);</a>
<a name="ln640">}</a>
<a name="ln641"> </a>
<a name="ln642">static void show_ip_nhrp_shortcut(struct nhrp_shortcut *s, void *pctx)</a>
<a name="ln643">{</a>
<a name="ln644">	struct info_ctx *ctx = pctx;</a>
<a name="ln645">	struct nhrp_cache *c;</a>
<a name="ln646">	struct vty *vty = ctx-&gt;vty;</a>
<a name="ln647">	char buf1[PREFIX_STRLEN], buf2[SU_ADDRSTRLEN];</a>
<a name="ln648"> </a>
<a name="ln649">	if (!ctx-&gt;count) {</a>
<a name="ln650">		vty_out(vty, &quot;%-8s %-24s %-24s %s%s&quot;,</a>
<a name="ln651">			&quot;Type&quot;,</a>
<a name="ln652">			&quot;Prefix&quot;,</a>
<a name="ln653">			&quot;Via&quot;,</a>
<a name="ln654">			&quot;Identity&quot;,</a>
<a name="ln655">			VTY_NEWLINE);</a>
<a name="ln656">	}</a>
<a name="ln657">	ctx-&gt;count++;</a>
<a name="ln658"> </a>
<a name="ln659">	c = s-&gt;cache;</a>
<a name="ln660">	vty_out(ctx-&gt;vty, &quot;%-8s %-24s %-24s %s%s&quot;,</a>
<a name="ln661">		nhrp_cache_type_str[s-&gt;type],</a>
<a name="ln662">		prefix2str(s-&gt;p, buf1, sizeof buf1),</a>
<a name="ln663">		c ? sockunion2str(&amp;c-&gt;remote_addr, buf2, sizeof buf2) : &quot;&quot;,</a>
<a name="ln664">		(c &amp;&amp; c-&gt;cur.peer) ? c-&gt;cur.peer-&gt;vc-&gt;remote.id : &quot;&quot;,</a>
<a name="ln665">		VTY_NEWLINE);</a>
<a name="ln666">}</a>
<a name="ln667"> </a>
<a name="ln668">static void show_ip_opennhrp_cache(struct nhrp_cache *c, void *pctx)</a>
<a name="ln669">{</a>
<a name="ln670">	struct info_ctx *ctx = pctx;</a>
<a name="ln671">	struct vty *vty = ctx-&gt;vty;</a>
<a name="ln672">	char buf[SU_ADDRSTRLEN];</a>
<a name="ln673"> </a>
<a name="ln674">	if (ctx-&gt;afi != family2afi(sockunion_family(&amp;c-&gt;remote_addr)))</a>
<a name="ln675">		return;</a>
<a name="ln676"> </a>
<a name="ln677">	vty_out(ctx-&gt;vty,</a>
<a name="ln678">		&quot;Type: %s%s&quot;</a>
<a name="ln679">		&quot;Flags:%s%s%s&quot;</a>
<a name="ln680">		&quot;Protocol-Address: %s/%zu%s&quot;,</a>
<a name="ln681">		nhrp_cache_type_str[c-&gt;cur.type],</a>
<a name="ln682">		VTY_NEWLINE,</a>
<a name="ln683">		(c-&gt;cur.peer &amp;&amp; c-&gt;cur.peer-&gt;online) ? &quot; up&quot;: &quot;&quot;,</a>
<a name="ln684">		c-&gt;used ? &quot; used&quot;: &quot;&quot;,</a>
<a name="ln685">		VTY_NEWLINE,</a>
<a name="ln686">		sockunion2str(&amp;c-&gt;remote_addr, buf, sizeof buf),</a>
<a name="ln687">		8 * family2addrsize(sockunion_family(&amp;c-&gt;remote_addr)),</a>
<a name="ln688">		VTY_NEWLINE);</a>
<a name="ln689"> </a>
<a name="ln690">	if (c-&gt;cur.peer) {</a>
<a name="ln691">		vty_out(ctx-&gt;vty,</a>
<a name="ln692">			&quot;NBMA-Address: %s%s&quot;,</a>
<a name="ln693">			sockunion2str(&amp;c-&gt;cur.peer-&gt;vc-&gt;remote.nbma, buf, sizeof buf),</a>
<a name="ln694">			VTY_NEWLINE);</a>
<a name="ln695">	}</a>
<a name="ln696"> </a>
<a name="ln697">	if (sockunion_family(&amp;c-&gt;cur.remote_nbma_natoa) != AF_UNSPEC) {</a>
<a name="ln698">		vty_out(ctx-&gt;vty,</a>
<a name="ln699">			&quot;NBMA-NAT-OA-Address: %s%s&quot;,</a>
<a name="ln700">			sockunion2str(&amp;c-&gt;cur.remote_nbma_natoa, buf, sizeof buf),</a>
<a name="ln701">			VTY_NEWLINE);</a>
<a name="ln702">	}</a>
<a name="ln703"> </a>
<a name="ln704">	vty_out(ctx-&gt;vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln705">}</a>
<a name="ln706"> </a>
<a name="ln707">DEFUN(show_ip_nhrp, show_ip_nhrp_cmd,</a>
<a name="ln708">	&quot;show &quot; AFI_CMD &quot; nhrp (cache|nhs|shortcut|opennhrp|)&quot;,</a>
<a name="ln709">	SHOW_STR</a>
<a name="ln710">	AFI_STR</a>
<a name="ln711">	&quot;NHRP information\n&quot;</a>
<a name="ln712">	&quot;Forwarding cache information\n&quot;</a>
<a name="ln713">	&quot;Next hop server information\n&quot;</a>
<a name="ln714">	&quot;Shortcut information\n&quot;</a>
<a name="ln715">	&quot;opennhrpctl style cache dump\n&quot;)</a>
<a name="ln716">{</a>
<a name="ln717">	struct listnode *node;</a>
<a name="ln718">	struct interface *ifp;</a>
<a name="ln719">	struct info_ctx ctx = {</a>
<a name="ln720">		.vty = vty,</a>
<a name="ln721">		.afi = cmd_to_afi(argv[0]),</a>
<a name="ln722">	};</a>
<a name="ln723"> </a>
<a name="ln724">	if (!argv[1] || argv[1][0] == 'c') {</a>
<a name="ln725">		for (ALL_LIST_ELEMENTS_RO(iflist, node, ifp))</a>
<a name="ln726">			nhrp_cache_foreach(ifp, show_ip_nhrp_cache, &amp;ctx);</a>
<a name="ln727">	} else if (argv[1][0] == 'n') {</a>
<a name="ln728">		for (ALL_LIST_ELEMENTS_RO(iflist, node, ifp))</a>
<a name="ln729">			nhrp_nhs_foreach(ifp, ctx.afi, show_ip_nhrp_nhs, &amp;ctx);</a>
<a name="ln730">	} else if (argv[1][0] == 's') {</a>
<a name="ln731">		nhrp_shortcut_foreach(ctx.afi, show_ip_nhrp_shortcut, &amp;ctx);</a>
<a name="ln732">	} else {</a>
<a name="ln733">		vty_out(vty, &quot;Status: ok%s%s&quot;, VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln734">		ctx.count++;</a>
<a name="ln735">		for (ALL_LIST_ELEMENTS_RO(iflist, node, ifp))</a>
<a name="ln736">			nhrp_cache_foreach(ifp, show_ip_opennhrp_cache, &amp;ctx);</a>
<a name="ln737">	}</a>
<a name="ln738"> </a>
<a name="ln739">	if (!ctx.count) {</a>
<a name="ln740">		vty_out(vty, &quot;%% No entries%s&quot;, VTY_NEWLINE);</a>
<a name="ln741">		return CMD_WARNING;</a>
<a name="ln742">	}</a>
<a name="ln743"> </a>
<a name="ln744">	return CMD_SUCCESS;</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">static void show_dmvpn_entry(struct nhrp_vc *vc, void *ctx)</a>
<a name="ln748">{</a>
<a name="ln749">	struct vty *vty = ctx;</a>
<a name="ln750">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln751"> </a>
<a name="ln752">	vty_out(vty, &quot;%-24s %-24s %c      %-4d %-24s%s&quot;,</a>
<a name="ln753">		sockunion2str(&amp;vc-&gt;local.nbma, buf[0], sizeof buf[0]),</a>
<a name="ln754">		sockunion2str(&amp;vc-&gt;remote.nbma, buf[1], sizeof buf[1]),</a>
<a name="ln755">		notifier_active(&amp;vc-&gt;notifier_list) ? 'n' : ' ',</a>
<a name="ln756">		vc-&gt;ipsec,</a>
<a name="ln757">		vc-&gt;remote.id,</a>
<a name="ln758">		VTY_NEWLINE);</a>
<a name="ln759">}</a>
<a name="ln760"> </a>
<a name="ln761">DEFUN(show_dmvpn, show_dmvpn_cmd,</a>
<a name="ln762">	&quot;show dmvpn&quot;,</a>
<a name="ln763">	SHOW_STR</a>
<a name="ln764">	&quot;DMVPN information\n&quot;)</a>
<a name="ln765">{</a>
<a name="ln766">	vty_out(vty, &quot;%-24s %-24s %-6s %-4s %-24s%s&quot;,</a>
<a name="ln767">		&quot;Src&quot;,</a>
<a name="ln768">		&quot;Dst&quot;,</a>
<a name="ln769">		&quot;Flags&quot;,</a>
<a name="ln770">		&quot;SAs&quot;,</a>
<a name="ln771">		&quot;Identity&quot;,</a>
<a name="ln772">		VTY_NEWLINE);</a>
<a name="ln773"> </a>
<a name="ln774">	nhrp_vc_foreach(show_dmvpn_entry, vty);</a>
<a name="ln775"> </a>
<a name="ln776">	return CMD_SUCCESS;</a>
<a name="ln777">}</a>
<a name="ln778"> </a>
<a name="ln779">static void clear_nhrp_cache(struct nhrp_cache *c, void *data)</a>
<a name="ln780">{</a>
<a name="ln781">	struct info_ctx *ctx = data;</a>
<a name="ln782">	if (c-&gt;cur.type &lt;= NHRP_CACHE_CACHED) {</a>
<a name="ln783">		nhrp_cache_update_binding(c, c-&gt;cur.type, -1, NULL, 0, NULL);</a>
<a name="ln784">		ctx-&gt;count++;</a>
<a name="ln785">	}</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">static void clear_nhrp_shortcut(struct nhrp_shortcut *s, void *data)</a>
<a name="ln789">{</a>
<a name="ln790">	struct info_ctx *ctx = data;</a>
<a name="ln791">	nhrp_shortcut_purge(s, 1);</a>
<a name="ln792">	ctx-&gt;count++;</a>
<a name="ln793">}</a>
<a name="ln794"> </a>
<a name="ln795">DEFUN(clear_nhrp, clear_nhrp_cmd,</a>
<a name="ln796">	&quot;clear &quot; AFI_CMD &quot; nhrp (cache|shortcut)&quot;,</a>
<a name="ln797">	CLEAR_STR</a>
<a name="ln798">	AFI_STR</a>
<a name="ln799">	NHRP_STR</a>
<a name="ln800">	&quot;Dynamic cache entries\n&quot;</a>
<a name="ln801">	&quot;Shortcut entries\n&quot;)</a>
<a name="ln802">{</a>
<a name="ln803">	struct listnode *node;</a>
<a name="ln804">	struct interface *ifp;</a>
<a name="ln805">	struct info_ctx ctx = {</a>
<a name="ln806">		.vty = vty,</a>
<a name="ln807">		.afi = cmd_to_afi(argv[0]),</a>
<a name="ln808">		.count = 0,</a>
<a name="ln809">	};</a>
<a name="ln810"> </a>
<a name="ln811">	if (!argv[1] || argv[1][0] == 'c') {</a>
<a name="ln812">		for (ALL_LIST_ELEMENTS_RO(iflist, node, ifp))</a>
<a name="ln813">			nhrp_cache_foreach(ifp, clear_nhrp_cache, &amp;ctx);</a>
<a name="ln814">	} else {</a>
<a name="ln815">		nhrp_shortcut_foreach(ctx.afi, clear_nhrp_shortcut, &amp;ctx);</a>
<a name="ln816">	}</a>
<a name="ln817"> </a>
<a name="ln818">	if (!ctx.count) {</a>
<a name="ln819">		vty_out(vty, &quot;%% No entries%s&quot;, VTY_NEWLINE);</a>
<a name="ln820">		return CMD_WARNING;</a>
<a name="ln821">	}</a>
<a name="ln822"> </a>
<a name="ln823">	vty_out(vty, &quot;%% %d entries cleared%s&quot;, ctx.count, VTY_NEWLINE);</a>
<a name="ln824">	return CMD_SUCCESS;</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">struct write_map_ctx {</a>
<a name="ln828">	struct vty *vty;</a>
<a name="ln829">	int family;</a>
<a name="ln830">	const char *aficmd;</a>
<a name="ln831">};</a>
<a name="ln832"> </a>
<a name="ln833">static void interface_config_write_nhrp_map(struct nhrp_cache *c, void *data)</a>
<a name="ln834">{</a>
<a name="ln835">	struct write_map_ctx *ctx = data;</a>
<a name="ln836">	struct vty *vty = ctx-&gt;vty;</a>
<a name="ln837">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln838"> </a>
<a name="ln839">	if (!c-&gt;map) return;</a>
<a name="ln840">	if (sockunion_family(&amp;c-&gt;remote_addr) != ctx-&gt;family) return;</a>
<a name="ln841"> </a>
<a name="ln842">	vty_out(vty, &quot; %s nhrp map %s %s%s&quot;,</a>
<a name="ln843">		ctx-&gt;aficmd,</a>
<a name="ln844">		sockunion2str(&amp;c-&gt;remote_addr, buf[0], sizeof buf[0]),</a>
<a name="ln845">		c-&gt;cur.type == NHRP_CACHE_LOCAL ? &quot;local&quot; :</a>
<a name="ln846">		sockunion2str(&amp;c-&gt;cur.peer-&gt;vc-&gt;remote.nbma, buf[1], sizeof buf[1]),</a>
<a name="ln847">		VTY_NEWLINE);</a>
<a name="ln848">}</a>
<a name="ln849"> </a>
<a name="ln850">static int interface_config_write(struct vty *vty)</a>
<a name="ln851">{</a>
<a name="ln852">	struct write_map_ctx mapctx;</a>
<a name="ln853">	struct listnode *node;</a>
<a name="ln854">	struct interface *ifp;</a>
<a name="ln855">	struct nhrp_interface *nifp;</a>
<a name="ln856">	struct nhrp_nhs *nhs;</a>
<a name="ln857">	const char *aficmd;</a>
<a name="ln858">	afi_t afi;</a>
<a name="ln859">	char buf[SU_ADDRSTRLEN];</a>
<a name="ln860">	int i;</a>
<a name="ln861"> </a>
<a name="ln862">	for (ALL_LIST_ELEMENTS_RO(iflist, node, ifp)) {</a>
<a name="ln863">		vty_out(vty, &quot;interface %s%s&quot;, ifp-&gt;name, VTY_NEWLINE);</a>
<a name="ln864">		if (ifp-&gt;desc)</a>
<a name="ln865">			vty_out(vty, &quot; description %s%s&quot;, ifp-&gt;desc, VTY_NEWLINE);</a>
<a name="ln866"> </a>
<a name="ln867">		nifp = ifp-&gt;info;</a>
<a name="ln868">		if (nifp-&gt;ipsec_profile) {</a>
<a name="ln869">			vty_out(vty, &quot; tunnel protection vici profile %s&quot;,</a>
<a name="ln870">				nifp-&gt;ipsec_profile);</a>
<a name="ln871">			if (nifp-&gt;ipsec_fallback_profile)</a>
<a name="ln872">				vty_out(vty, &quot; fallback-profile %s&quot;,</a>
<a name="ln873">					nifp-&gt;ipsec_fallback_profile);</a>
<a name="ln874">			vty_out(vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln875">		}</a>
<a name="ln876">		if (nifp-&gt;source)</a>
<a name="ln877">			vty_out(vty, &quot; tunnel source %s%s&quot;,</a>
<a name="ln878">				nifp-&gt;source, VTY_NEWLINE);</a>
<a name="ln879"> </a>
<a name="ln880">		for (afi = 0; afi &lt; AFI_MAX; afi++) {</a>
<a name="ln881">			struct nhrp_afi_data *ad = &amp;nifp-&gt;afi[afi];</a>
<a name="ln882"> </a>
<a name="ln883">			aficmd = afi_to_cmd(afi);</a>
<a name="ln884"> </a>
<a name="ln885">			if (ad-&gt;network_id)</a>
<a name="ln886">				vty_out(vty, &quot; %s nhrp network-id %u%s&quot;,</a>
<a name="ln887">					aficmd, ad-&gt;network_id,</a>
<a name="ln888">					VTY_NEWLINE);</a>
<a name="ln889"> </a>
<a name="ln890">			if (ad-&gt;holdtime != NHRPD_DEFAULT_HOLDTIME)</a>
<a name="ln891">				vty_out(vty, &quot; %s nhrp holdtime %u%s&quot;,</a>
<a name="ln892">					aficmd, ad-&gt;holdtime,</a>
<a name="ln893">					VTY_NEWLINE);</a>
<a name="ln894"> </a>
<a name="ln895">			if (ad-&gt;configured_mtu &lt; 0)</a>
<a name="ln896">				vty_out(vty, &quot; %s nhrp mtu opennhrp%s&quot;,</a>
<a name="ln897">					aficmd, VTY_NEWLINE);</a>
<a name="ln898">			else if (ad-&gt;configured_mtu)</a>
<a name="ln899">				vty_out(vty, &quot; %s nhrp mtu %u%s&quot;,</a>
<a name="ln900">					aficmd, ad-&gt;configured_mtu,</a>
<a name="ln901">					VTY_NEWLINE);</a>
<a name="ln902"> </a>
<a name="ln903">			for (i = 0; interface_flags_desc[i].str != NULL; i++) {</a>
<a name="ln904">				if (!(ad-&gt;flags &amp; interface_flags_desc[i].key))</a>
<a name="ln905">					continue;</a>
<a name="ln906">				vty_out(vty, &quot; %s nhrp %s%s&quot;,</a>
<a name="ln907">					aficmd, interface_flags_desc[i].str, VTY_NEWLINE);</a>
<a name="ln908">			}</a>
<a name="ln909"> </a>
<a name="ln910">			mapctx = (struct write_map_ctx) {</a>
<a name="ln911">				.vty = vty,</a>
<a name="ln912">				.family = afi2family(afi),</a>
<a name="ln913">				.aficmd = aficmd,</a>
<a name="ln914">			};</a>
<a name="ln915">			nhrp_cache_foreach(ifp, interface_config_write_nhrp_map, &amp;mapctx);</a>
<a name="ln916"> </a>
<a name="ln917">			list_for_each_entry(nhs, &amp;ad-&gt;nhslist_head, nhslist_entry) {</a>
<a name="ln918">				vty_out(vty, &quot; %s nhrp nhs %s nbma %s%s&quot;,</a>
<a name="ln919">					aficmd,</a>
<a name="ln920">					sockunion_family(&amp;nhs-&gt;proto_addr) == AF_UNSPEC ? &quot;dynamic&quot; : sockunion2str(&amp;nhs-&gt;proto_addr, buf, sizeof buf),</a>
<a name="ln921">					nhs-&gt;nbma_fqdn,</a>
<a name="ln922">					VTY_NEWLINE);</a>
<a name="ln923">			}</a>
<a name="ln924">		}</a>
<a name="ln925"> </a>
<a name="ln926">		vty_out (vty, &quot;!%s&quot;, VTY_NEWLINE);</a>
<a name="ln927">	}</a>
<a name="ln928"> </a>
<a name="ln929">	return 0;</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">void nhrp_config_init(void)</a>
<a name="ln933">{</a>
<a name="ln934">	install_node(&amp;zebra_node, nhrp_config_write);</a>
<a name="ln935">	install_default(ZEBRA_NODE);</a>
<a name="ln936"> </a>
<a name="ln937">	/* global commands */</a>
<a name="ln938">	install_element(VIEW_NODE, &amp;show_debugging_nhrp_cmd);</a>
<a name="ln939">	install_element(VIEW_NODE, &amp;show_ip_nhrp_cmd);</a>
<a name="ln940">	install_element(VIEW_NODE, &amp;show_dmvpn_cmd);</a>
<a name="ln941">	install_element(ENABLE_NODE, &amp;show_debugging_nhrp_cmd);</a>
<a name="ln942">	install_element(ENABLE_NODE, &amp;show_ip_nhrp_cmd);</a>
<a name="ln943">	install_element(ENABLE_NODE, &amp;show_dmvpn_cmd);</a>
<a name="ln944">	install_element(ENABLE_NODE, &amp;clear_nhrp_cmd);</a>
<a name="ln945"> </a>
<a name="ln946">	install_element(ENABLE_NODE, &amp;debug_nhrp_cmd);</a>
<a name="ln947">	install_element(ENABLE_NODE, &amp;no_debug_nhrp_cmd);</a>
<a name="ln948"> </a>
<a name="ln949">	install_element(CONFIG_NODE, &amp;debug_nhrp_cmd);</a>
<a name="ln950">	install_element(CONFIG_NODE, &amp;no_debug_nhrp_cmd);</a>
<a name="ln951"> </a>
<a name="ln952">	install_element(CONFIG_NODE, &amp;nhrp_event_socket_cmd);</a>
<a name="ln953">	install_element(CONFIG_NODE, &amp;no_nhrp_event_socket_cmd);</a>
<a name="ln954">	install_element(CONFIG_NODE, &amp;nhrp_nflog_group_cmd);</a>
<a name="ln955">	install_element(CONFIG_NODE, &amp;no_nhrp_nflog_group_cmd);</a>
<a name="ln956"> </a>
<a name="ln957">	/* interface specific commands */</a>
<a name="ln958">	install_node(&amp;nhrp_interface_node, interface_config_write);</a>
<a name="ln959">	install_default(INTERFACE_NODE);</a>
<a name="ln960"> </a>
<a name="ln961">	install_element(CONFIG_NODE, &amp;interface_cmd);</a>
<a name="ln962">	install_element(CONFIG_NODE, &amp;no_interface_cmd);</a>
<a name="ln963">	install_element(INTERFACE_NODE, &amp;interface_cmd);</a>
<a name="ln964">	install_element(INTERFACE_NODE, &amp;no_interface_cmd);</a>
<a name="ln965">	install_element(INTERFACE_NODE, &amp;tunnel_protection_cmd);</a>
<a name="ln966">	install_element(INTERFACE_NODE, &amp;no_tunnel_protection_cmd);</a>
<a name="ln967">	install_element(INTERFACE_NODE, &amp;tunnel_source_cmd);</a>
<a name="ln968">	install_element(INTERFACE_NODE, &amp;no_tunnel_source_cmd);</a>
<a name="ln969">	install_element(INTERFACE_NODE, &amp;if_nhrp_network_id_cmd);</a>
<a name="ln970">	install_element(INTERFACE_NODE, &amp;if_no_nhrp_network_id_cmd);</a>
<a name="ln971">	install_element(INTERFACE_NODE, &amp;if_nhrp_holdtime_cmd);</a>
<a name="ln972">	install_element(INTERFACE_NODE, &amp;if_no_nhrp_holdtime_cmd);</a>
<a name="ln973">	install_element(INTERFACE_NODE, &amp;if_nhrp_mtu_cmd);</a>
<a name="ln974">	install_element(INTERFACE_NODE, &amp;if_no_nhrp_mtu_cmd);</a>
<a name="ln975">	install_element(INTERFACE_NODE, &amp;if_nhrp_flags_cmd);</a>
<a name="ln976">	install_element(INTERFACE_NODE, &amp;if_no_nhrp_flags_cmd);</a>
<a name="ln977">	install_element(INTERFACE_NODE, &amp;if_nhrp_reg_flags_cmd);</a>
<a name="ln978">	install_element(INTERFACE_NODE, &amp;if_no_nhrp_reg_flags_cmd);</a>
<a name="ln979">	install_element(INTERFACE_NODE, &amp;if_nhrp_map_cmd);</a>
<a name="ln980">	install_element(INTERFACE_NODE, &amp;if_no_nhrp_map_cmd);</a>
<a name="ln981">	install_element(INTERFACE_NODE, &amp;if_nhrp_nhs_cmd);</a>
<a name="ln982">	install_element(INTERFACE_NODE, &amp;if_no_nhrp_nhs_cmd);</a>
<a name="ln983">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="77"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'ret' index could reach 8.</p></div>
<div class="balloon" rel="78"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v557/" target="_blank">V557</a> Array overrun is possible. The value of 'ret' index could reach 8.</p></div>
<div class="balloon" rel="311"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="329"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="346"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="361"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="375"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="391"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="406"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="424"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="481"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="516"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="544"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="568"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="721"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="807"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'cmd_to_afi' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="883"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1031/" target="_blank">V1031</a> The 'afi_to_cmd' function is not declared. Passing data to or from this function can be affected.</p></div>
<div class="balloon" rel="883"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v647/" target="_blank">V647</a> The value of 'int' type is assigned to the pointer of 'char' type. Consider inspecting the assignment: 'aficmd = afi_to_cmd(afi)'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
