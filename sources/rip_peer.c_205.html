
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>rip_peer.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* RIP peer support</a>
<a name="ln2"> * Copyright (C) 2000 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;if.h&quot;</a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;thread.h&quot;</a>
<a name="ln29">#include &quot;memory.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;ripd/ripd.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">/* Linked list of RIP peer. */</a>
<a name="ln34">struct list *peer_list;</a>
<a name="ln35"> </a>
<a name="ln36">static struct rip_peer *</a>
<a name="ln37">rip_peer_new (void)</a>
<a name="ln38">{</a>
<a name="ln39">  return XCALLOC (MTYPE_RIP_PEER, sizeof (struct rip_peer));</a>
<a name="ln40">}</a>
<a name="ln41"> </a>
<a name="ln42">static void</a>
<a name="ln43">rip_peer_free (struct rip_peer *peer)</a>
<a name="ln44">{</a>
<a name="ln45">  XFREE (MTYPE_RIP_PEER, peer);</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">struct rip_peer *</a>
<a name="ln49">rip_peer_lookup (struct in_addr *addr)</a>
<a name="ln50">{</a>
<a name="ln51">  struct rip_peer *peer;</a>
<a name="ln52">  struct listnode *node, *nnode;</a>
<a name="ln53"> </a>
<a name="ln54">  for (ALL_LIST_ELEMENTS (peer_list, node, nnode, peer))</a>
<a name="ln55">    {</a>
<a name="ln56">      if (IPV4_ADDR_SAME (&amp;peer-&gt;addr, addr))</a>
<a name="ln57">	return peer;</a>
<a name="ln58">    }</a>
<a name="ln59">  return NULL;</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">struct rip_peer *</a>
<a name="ln63">rip_peer_lookup_next (struct in_addr *addr)</a>
<a name="ln64">{</a>
<a name="ln65">  struct rip_peer *peer;</a>
<a name="ln66">  struct listnode *node, *nnode;</a>
<a name="ln67"> </a>
<a name="ln68">  for (ALL_LIST_ELEMENTS (peer_list, node, nnode, peer))</a>
<a name="ln69">    {</a>
<a name="ln70">      if (htonl (peer-&gt;addr.s_addr) &gt; htonl (addr-&gt;s_addr))</a>
<a name="ln71">	return peer;</a>
<a name="ln72">    }</a>
<a name="ln73">  return NULL;</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">/* RIP peer is timeout. */</a>
<a name="ln77">static int</a>
<a name="ln78">rip_peer_timeout (struct thread *t)</a>
<a name="ln79">{</a>
<a name="ln80">  struct rip_peer *peer;</a>
<a name="ln81"> </a>
<a name="ln82">  peer = THREAD_ARG (t);</a>
<a name="ln83">  listnode_delete (peer_list, peer);</a>
<a name="ln84">  rip_peer_free (peer);</a>
<a name="ln85"> </a>
<a name="ln86">  return 0;</a>
<a name="ln87">}</a>
<a name="ln88"> </a>
<a name="ln89">/* Get RIP peer.  At the same time update timeout thread. */</a>
<a name="ln90">static struct rip_peer *</a>
<a name="ln91">rip_peer_get (struct in_addr *addr)</a>
<a name="ln92">{</a>
<a name="ln93">  struct rip_peer *peer;</a>
<a name="ln94"> </a>
<a name="ln95">  peer = rip_peer_lookup (addr);</a>
<a name="ln96"> </a>
<a name="ln97">  if (peer)</a>
<a name="ln98">    {</a>
<a name="ln99">      if (peer-&gt;t_timeout)</a>
<a name="ln100">	thread_cancel (peer-&gt;t_timeout);</a>
<a name="ln101">    }</a>
<a name="ln102">  else</a>
<a name="ln103">    {</a>
<a name="ln104">      peer = rip_peer_new ();</a>
<a name="ln105">      peer-&gt;addr = *addr;</a>
<a name="ln106">      listnode_add_sort (peer_list, peer);</a>
<a name="ln107">    }</a>
<a name="ln108"> </a>
<a name="ln109">  /* Update timeout thread. */</a>
<a name="ln110">  peer-&gt;t_timeout = thread_add_timer (master, rip_peer_timeout, peer,</a>
<a name="ln111">				      RIP_PEER_TIMER_DEFAULT);</a>
<a name="ln112"> </a>
<a name="ln113">  /* Last update time set. */</a>
<a name="ln114">  time (&amp;peer-&gt;uptime);</a>
<a name="ln115">  </a>
<a name="ln116">  return peer;</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">void</a>
<a name="ln120">rip_peer_update (struct sockaddr_in *from, u_char version)</a>
<a name="ln121">{</a>
<a name="ln122">  struct rip_peer *peer;</a>
<a name="ln123">  peer = rip_peer_get (&amp;from-&gt;sin_addr);</a>
<a name="ln124">  peer-&gt;version = version;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">void</a>
<a name="ln128">rip_peer_bad_route (struct sockaddr_in *from)</a>
<a name="ln129">{</a>
<a name="ln130">  struct rip_peer *peer;</a>
<a name="ln131">  peer = rip_peer_get (&amp;from-&gt;sin_addr);</a>
<a name="ln132">  peer-&gt;recv_badroutes++;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">void</a>
<a name="ln136">rip_peer_bad_packet (struct sockaddr_in *from)</a>
<a name="ln137">{</a>
<a name="ln138">  struct rip_peer *peer;</a>
<a name="ln139">  peer = rip_peer_get (&amp;from-&gt;sin_addr);</a>
<a name="ln140">  peer-&gt;recv_badpackets++;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">/* Display peer uptime. */</a>
<a name="ln144">static char *</a>
<a name="ln145">rip_peer_uptime (struct rip_peer *peer, char *buf, size_t len)</a>
<a name="ln146">{</a>
<a name="ln147">  time_t uptime;</a>
<a name="ln148">  struct tm *tm;</a>
<a name="ln149"> </a>
<a name="ln150">  /* If there is no connection has been done before print `never'. */</a>
<a name="ln151">  if (peer-&gt;uptime == 0)</a>
<a name="ln152">    {</a>
<a name="ln153">      snprintf (buf, len, &quot;never   &quot;);</a>
<a name="ln154">      return buf;</a>
<a name="ln155">    }</a>
<a name="ln156"> </a>
<a name="ln157">  /* Get current time. */</a>
<a name="ln158">  uptime = time (NULL);</a>
<a name="ln159">  uptime -= peer-&gt;uptime;</a>
<a name="ln160">  tm = gmtime (&amp;uptime);</a>
<a name="ln161"> </a>
<a name="ln162">  /* Making formatted timer strings. */</a>
<a name="ln163">#define ONE_DAY_SECOND 60*60*24</a>
<a name="ln164">#define ONE_WEEK_SECOND 60*60*24*7</a>
<a name="ln165"> </a>
<a name="ln166">  if (uptime &lt; ONE_DAY_SECOND)</a>
<a name="ln167">    snprintf (buf, len, &quot;%02d:%02d:%02d&quot;, </a>
<a name="ln168">	      tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);</a>
<a name="ln169">  else if (uptime &lt; ONE_WEEK_SECOND)</a>
<a name="ln170">    snprintf (buf, len, &quot;%dd%02dh%02dm&quot;, </a>
<a name="ln171">	      tm-&gt;tm_yday, tm-&gt;tm_hour, tm-&gt;tm_min);</a>
<a name="ln172">  else</a>
<a name="ln173">    snprintf (buf, len, &quot;%02dw%dd%02dh&quot;, </a>
<a name="ln174">	      tm-&gt;tm_yday/7, tm-&gt;tm_yday - ((tm-&gt;tm_yday/7) * 7), tm-&gt;tm_hour);</a>
<a name="ln175">  return buf;</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">void</a>
<a name="ln179">rip_peer_display (struct vty *vty)</a>
<a name="ln180">{</a>
<a name="ln181">  struct rip_peer *peer;</a>
<a name="ln182">  struct listnode *node, *nnode;</a>
<a name="ln183">#define RIP_UPTIME_LEN 25</a>
<a name="ln184">  char timebuf[RIP_UPTIME_LEN];</a>
<a name="ln185"> </a>
<a name="ln186">  for (ALL_LIST_ELEMENTS (peer_list, node, nnode, peer))</a>
<a name="ln187">    {</a>
<a name="ln188">      vty_out (vty, &quot;    %-16s %9d %9d %9d   %s%s&quot;, inet_ntoa (peer-&gt;addr),</a>
<a name="ln189">	       peer-&gt;recv_badpackets, peer-&gt;recv_badroutes,</a>
<a name="ln190">	       ZEBRA_RIP_DISTANCE_DEFAULT,</a>
<a name="ln191">	       rip_peer_uptime (peer, timebuf, RIP_UPTIME_LEN),</a>
<a name="ln192">	       VTY_NEWLINE);</a>
<a name="ln193">    }</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">static int</a>
<a name="ln197">rip_peer_list_cmp (struct rip_peer *p1, struct rip_peer *p2)</a>
<a name="ln198">{</a>
<a name="ln199">  return htonl (p1-&gt;addr.s_addr) &gt; htonl (p2-&gt;addr.s_addr);</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">void</a>
<a name="ln203">rip_peer_init (void)</a>
<a name="ln204">{</a>
<a name="ln205">  peer_list = list_new ();</a>
<a name="ln206">  peer_list-&gt;cmp = (int (*)(void *, void *)) rip_peer_list_cmp;</a>
<a name="ln207">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
