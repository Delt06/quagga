
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_routemap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Route map function of bgpd.</a>
<a name="ln2">   Copyright (C) 1998, 1999 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;prefix.h&quot;</a>
<a name="ln24">#include &quot;filter.h&quot;</a>
<a name="ln25">#include &quot;routemap.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;plist.h&quot;</a>
<a name="ln29">#include &quot;memory.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31">#ifdef HAVE_LIBPCREPOSIX</a>
<a name="ln32"># include &lt;pcreposix.h&gt;</a>
<a name="ln33">#else</a>
<a name="ln34"># ifdef HAVE_GNU_REGEX</a>
<a name="ln35">#  include &lt;regex.h&gt;</a>
<a name="ln36"># else</a>
<a name="ln37">#  include &quot;regex-gnu.h&quot;</a>
<a name="ln38"># endif /* HAVE_GNU_REGEX */</a>
<a name="ln39">#endif /* HAVE_LIBPCREPOSIX */</a>
<a name="ln40">#include &quot;buffer.h&quot;</a>
<a name="ln41">#include &quot;sockunion.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln44">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln45">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln46">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln47">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln48">#include &quot;bgpd/bgp_regex.h&quot;</a>
<a name="ln49">#include &quot;bgpd/bgp_community.h&quot;</a>
<a name="ln50">#include &quot;bgpd/bgp_clist.h&quot;</a>
<a name="ln51">#include &quot;bgpd/bgp_filter.h&quot;</a>
<a name="ln52">#include &quot;bgpd/bgp_mplsvpn.h&quot;</a>
<a name="ln53">#include &quot;bgpd/bgp_ecommunity.h&quot;</a>
<a name="ln54">#include &quot;bgpd/bgp_lcommunity.h&quot;</a>
<a name="ln55">#include &quot;bgpd/bgp_vty.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">/* Memo of route-map commands.</a>
<a name="ln58"> </a>
<a name="ln59">o Cisco route-map</a>
<a name="ln60"> </a>
<a name="ln61"> match as-path          :  Done</a>
<a name="ln62">       community        :  Done</a>
<a name="ln63">       lcommunity       :  Done</a>
<a name="ln64">       interface        :  Not yet</a>
<a name="ln65">       ip address       :  Done</a>
<a name="ln66">       ip next-hop      :  Done</a>
<a name="ln67">       ip route-source  :  Done</a>
<a name="ln68">       ip prefix-list   :  Done</a>
<a name="ln69">       ipv6 address     :  Done</a>
<a name="ln70">       ipv6 next-hop    :  Done</a>
<a name="ln71">       ipv6 route-source:  (This will not be implemented by bgpd)</a>
<a name="ln72">       ipv6 prefix-list :  Done</a>
<a name="ln73">       length           :  (This will not be implemented by bgpd)</a>
<a name="ln74">       metric           :  Done</a>
<a name="ln75">       route-type       :  (This will not be implemented by bgpd)</a>
<a name="ln76">       tag              :  Done</a>
<a name="ln77">       local-preference :  Done</a>
<a name="ln78"> </a>
<a name="ln79"> set  as-path prepend   :  Done</a>
<a name="ln80">      as-path tag       :  Not yet</a>
<a name="ln81">      automatic-tag     :  (This will not be implemented by bgpd)</a>
<a name="ln82">      community         :  Done</a>
<a name="ln83">      large-community   :  Done</a>
<a name="ln84">      large-comm-list   :  Done</a>
<a name="ln85">      comm-list         :  Not yet</a>
<a name="ln86">      dampning          :  Not yet</a>
<a name="ln87">      default           :  (This will not be implemented by bgpd)</a>
<a name="ln88">      interface         :  (This will not be implemented by bgpd)</a>
<a name="ln89">      ip default        :  (This will not be implemented by bgpd)</a>
<a name="ln90">      ip next-hop       :  Done</a>
<a name="ln91">      ip precedence     :  (This will not be implemented by bgpd)</a>
<a name="ln92">      ip tos            :  (This will not be implemented by bgpd)</a>
<a name="ln93">      level             :  (This will not be implemented by bgpd)</a>
<a name="ln94">      local-preference  :  Done</a>
<a name="ln95">      metric            :  Done</a>
<a name="ln96">      metric-type       :  Not yet</a>
<a name="ln97">      origin            :  Done</a>
<a name="ln98">      tag               :  Done</a>
<a name="ln99">      weight            :  Done</a>
<a name="ln100"> </a>
<a name="ln101">o Local extensions</a>
<a name="ln102"> </a>
<a name="ln103">  set ipv6 next-hop global: Done</a>
<a name="ln104">  set ipv6 next-hop local : Done</a>
<a name="ln105">  set as-path exclude     : Done</a>
<a name="ln106"> </a>
<a name="ln107">*/ </a>
<a name="ln108"> </a>
<a name="ln109"> /* generic value manipulation to be shared in multiple rules */</a>
<a name="ln110"> </a>
<a name="ln111">#define RMAP_VALUE_SET 0</a>
<a name="ln112">#define RMAP_VALUE_ADD 1</a>
<a name="ln113">#define RMAP_VALUE_SUB 2</a>
<a name="ln114"> </a>
<a name="ln115">struct rmap_value</a>
<a name="ln116">{</a>
<a name="ln117">  u_int8_t action;</a>
<a name="ln118">  u_int8_t variable;</a>
<a name="ln119">  u_int32_t value;</a>
<a name="ln120">};</a>
<a name="ln121"> </a>
<a name="ln122">static int</a>
<a name="ln123">route_value_match (struct rmap_value *rv, u_int32_t value)</a>
<a name="ln124">{</a>
<a name="ln125">  if (rv-&gt;variable == 0 &amp;&amp; value == rv-&gt;value)</a>
<a name="ln126">    return RMAP_MATCH;</a>
<a name="ln127"> </a>
<a name="ln128">  return RMAP_NOMATCH;</a>
<a name="ln129">}</a>
<a name="ln130"> </a>
<a name="ln131">static u_int32_t</a>
<a name="ln132">route_value_adjust (struct rmap_value *rv, u_int32_t current, struct peer *peer)</a>
<a name="ln133">{</a>
<a name="ln134">  u_int32_t value;</a>
<a name="ln135"> </a>
<a name="ln136">  switch (rv-&gt;variable)</a>
<a name="ln137">    {</a>
<a name="ln138">    case 1:</a>
<a name="ln139">      value = peer-&gt;rtt;</a>
<a name="ln140">      break;</a>
<a name="ln141">    default:</a>
<a name="ln142">      value = rv-&gt;value;</a>
<a name="ln143">      break;</a>
<a name="ln144">    }</a>
<a name="ln145"> </a>
<a name="ln146">  switch (rv-&gt;action)</a>
<a name="ln147">    {</a>
<a name="ln148">    case RMAP_VALUE_ADD:</a>
<a name="ln149">      if (current &gt; UINT32_MAX-value)</a>
<a name="ln150">        return UINT32_MAX;</a>
<a name="ln151">      return current + value;</a>
<a name="ln152">    case RMAP_VALUE_SUB:</a>
<a name="ln153">      if (current &lt;= value)</a>
<a name="ln154">        return 0;</a>
<a name="ln155">      return current - value;</a>
<a name="ln156">    default:</a>
<a name="ln157">      return value;</a>
<a name="ln158">    }</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">static void *</a>
<a name="ln162">route_value_compile (const char *arg)</a>
<a name="ln163">{</a>
<a name="ln164">  u_int8_t action = RMAP_VALUE_SET, var = 0;</a>
<a name="ln165">  unsigned long larg = 0;</a>
<a name="ln166">  char *endptr = NULL;</a>
<a name="ln167">  struct rmap_value *rv;</a>
<a name="ln168"> </a>
<a name="ln169">  if (arg[0] == '+')</a>
<a name="ln170">    {</a>
<a name="ln171">      action = RMAP_VALUE_ADD;</a>
<a name="ln172">      arg++;</a>
<a name="ln173">    }</a>
<a name="ln174">  else if (arg[0] == '-')</a>
<a name="ln175">    {</a>
<a name="ln176">      action = RMAP_VALUE_SUB;</a>
<a name="ln177">      arg++;</a>
<a name="ln178">    }</a>
<a name="ln179"> </a>
<a name="ln180">  if (all_digit(arg))</a>
<a name="ln181">    {</a>
<a name="ln182">      errno = 0;</a>
<a name="ln183">      larg = strtoul (arg, &amp;endptr, 10);</a>
<a name="ln184">      if (*arg == 0 || *endptr != 0 || errno || larg &gt; UINT32_MAX)</a>
<a name="ln185">        return NULL;</a>
<a name="ln186">    }</a>
<a name="ln187">  else</a>
<a name="ln188">    {</a>
<a name="ln189">      if (strcmp(arg, &quot;rtt&quot;) == 0)</a>
<a name="ln190">        var = 1;</a>
<a name="ln191">      else</a>
<a name="ln192">        return NULL;</a>
<a name="ln193">    }</a>
<a name="ln194"> </a>
<a name="ln195">  rv = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof(struct rmap_value));</a>
<a name="ln196">  if (!rv)</a>
<a name="ln197">    return NULL;</a>
<a name="ln198"> </a>
<a name="ln199">  rv-&gt;action = action;</a>
<a name="ln200">  rv-&gt;variable = var;</a>
<a name="ln201">  rv-&gt;value = larg;</a>
<a name="ln202">  return rv;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">static void</a>
<a name="ln206">route_value_free (void *rule)</a>
<a name="ln207">{</a>
<a name="ln208">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211"> /* generic as path object to be shared in multiple rules */</a>
<a name="ln212"> </a>
<a name="ln213">static void *</a>
<a name="ln214">route_aspath_compile (const char *arg)</a>
<a name="ln215">{</a>
<a name="ln216">  struct aspath *aspath;</a>
<a name="ln217"> </a>
<a name="ln218">  aspath = aspath_str2aspath (arg);</a>
<a name="ln219">  if (! aspath)</a>
<a name="ln220">    return NULL;</a>
<a name="ln221">  return aspath;</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">static void</a>
<a name="ln225">route_aspath_free (void *rule)</a>
<a name="ln226">{</a>
<a name="ln227">  struct aspath *aspath = rule;</a>
<a name="ln228">  aspath_free (aspath);</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231"> /* 'match peer (A.B.C.D|X:X::X:X)' */</a>
<a name="ln232"> </a>
<a name="ln233">/* Compares the peer specified in the 'match peer' clause with the peer</a>
<a name="ln234">    received in bgp_info-&gt;peer. If it is the same, or if the peer structure</a>
<a name="ln235">    received is a peer_group containing it, returns RMAP_MATCH. */</a>
<a name="ln236">static route_map_result_t</a>
<a name="ln237">route_match_peer (void *rule, struct prefix *prefix, route_map_object_t type,</a>
<a name="ln238">      void *object)</a>
<a name="ln239">{</a>
<a name="ln240">  union sockunion *su;</a>
<a name="ln241">  union sockunion su_def = { .sin = { .sin_family = AF_INET,</a>
<a name="ln242">                                      .sin_addr.s_addr = INADDR_ANY } };</a>
<a name="ln243">  struct peer_group *group;</a>
<a name="ln244">  struct peer *peer;</a>
<a name="ln245">  struct listnode *node, *nnode;</a>
<a name="ln246"> </a>
<a name="ln247">  if (type == RMAP_BGP)</a>
<a name="ln248">    {</a>
<a name="ln249">      su = rule;</a>
<a name="ln250">      peer = ((struct bgp_info *) object)-&gt;peer;</a>
<a name="ln251"> </a>
<a name="ln252">      if ( ! CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_IMPORT) &amp;&amp;</a>
<a name="ln253">           ! CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_EXPORT) )</a>
<a name="ln254">        return RMAP_NOMATCH;</a>
<a name="ln255"> </a>
<a name="ln256">      /* If su='0.0.0.0' (command 'match peer local'), and it's a NETWORK,</a>
<a name="ln257">          REDISTRIBUTE or DEFAULT_GENERATED route =&gt; return RMAP_MATCH */</a>
<a name="ln258">      if (sockunion_same (su, &amp;su_def))</a>
<a name="ln259">        {</a>
<a name="ln260">          int ret;</a>
<a name="ln261">          if ( CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_NETWORK) ||</a>
<a name="ln262">               CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_REDISTRIBUTE) ||</a>
<a name="ln263">               CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_DEFAULT))</a>
<a name="ln264">            ret = RMAP_MATCH;</a>
<a name="ln265">          else</a>
<a name="ln266">            ret = RMAP_NOMATCH;</a>
<a name="ln267">          return ret;</a>
<a name="ln268">        }</a>
<a name="ln269"> </a>
<a name="ln270">      if (! CHECK_FLAG (peer-&gt;sflags, PEER_STATUS_GROUP))</a>
<a name="ln271">        {</a>
<a name="ln272">          if (sockunion_same (su, &amp;peer-&gt;su))</a>
<a name="ln273">            return RMAP_MATCH;</a>
<a name="ln274"> </a>
<a name="ln275">          return RMAP_NOMATCH;</a>
<a name="ln276">        }</a>
<a name="ln277">      else</a>
<a name="ln278">        {</a>
<a name="ln279">          group = peer-&gt;group;</a>
<a name="ln280">          for (ALL_LIST_ELEMENTS (group-&gt;peer, node, nnode, peer))</a>
<a name="ln281">            {</a>
<a name="ln282">              if (sockunion_same (su, &amp;peer-&gt;su))</a>
<a name="ln283">                return RMAP_MATCH;</a>
<a name="ln284">            }</a>
<a name="ln285">          return RMAP_NOMATCH;</a>
<a name="ln286">        }</a>
<a name="ln287">    }</a>
<a name="ln288">  return RMAP_NOMATCH;</a>
<a name="ln289">}</a>
<a name="ln290"> </a>
<a name="ln291">static void *</a>
<a name="ln292">route_match_peer_compile (const char *arg)</a>
<a name="ln293">{</a>
<a name="ln294">  union sockunion *su;</a>
<a name="ln295">  int ret;</a>
<a name="ln296"> </a>
<a name="ln297">  su = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (union sockunion));</a>
<a name="ln298"> </a>
<a name="ln299">  ret = str2sockunion (strcmp(arg, &quot;local&quot;) ? arg : &quot;0.0.0.0&quot;, su);</a>
<a name="ln300">  if (ret &lt; 0) {</a>
<a name="ln301">    XFREE (MTYPE_ROUTE_MAP_COMPILED, su);</a>
<a name="ln302">    return NULL;</a>
<a name="ln303">  }</a>
<a name="ln304"> </a>
<a name="ln305">  return su;</a>
<a name="ln306">}</a>
<a name="ln307"> </a>
<a name="ln308">/* Free route map's compiled `ip address' value. */</a>
<a name="ln309">static void</a>
<a name="ln310">route_match_peer_free (void *rule)</a>
<a name="ln311">{</a>
<a name="ln312">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln313">}</a>
<a name="ln314"> </a>
<a name="ln315">/* Route map commands for ip address matching. */</a>
<a name="ln316">struct route_map_rule_cmd route_match_peer_cmd =</a>
<a name="ln317">{</a>
<a name="ln318">  &quot;peer&quot;,</a>
<a name="ln319">  route_match_peer,</a>
<a name="ln320">  route_match_peer_compile,</a>
<a name="ln321">  route_match_peer_free</a>
<a name="ln322">};</a>
<a name="ln323"> </a>
<a name="ln324">/* `match ip address IP_ACCESS_LIST' */</a>
<a name="ln325"> </a>
<a name="ln326">/* Match function should return 1 if match is success else return</a>
<a name="ln327">   zero. */</a>
<a name="ln328">static route_map_result_t</a>
<a name="ln329">route_match_ip_address (void *rule, struct prefix *prefix, </a>
<a name="ln330">			route_map_object_t type, void *object)</a>
<a name="ln331">{</a>
<a name="ln332">  struct access_list *alist;</a>
<a name="ln333">  /* struct prefix_ipv4 match; */</a>
<a name="ln334"> </a>
<a name="ln335">  if (type == RMAP_BGP)</a>
<a name="ln336">    {</a>
<a name="ln337">      alist = access_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln338">      if (alist == NULL)</a>
<a name="ln339">	return RMAP_NOMATCH;</a>
<a name="ln340">    </a>
<a name="ln341">      return (access_list_apply (alist, prefix) == FILTER_DENY ?</a>
<a name="ln342">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln343">    }</a>
<a name="ln344">  return RMAP_NOMATCH;</a>
<a name="ln345">}</a>
<a name="ln346"> </a>
<a name="ln347">/* Route map `ip address' match statement.  `arg' should be</a>
<a name="ln348">   access-list name. */</a>
<a name="ln349">static void *</a>
<a name="ln350">route_match_ip_address_compile (const char *arg)</a>
<a name="ln351">{</a>
<a name="ln352">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln353">}</a>
<a name="ln354"> </a>
<a name="ln355">/* Free route map's compiled `ip address' value. */</a>
<a name="ln356">static void</a>
<a name="ln357">route_match_ip_address_free (void *rule)</a>
<a name="ln358">{</a>
<a name="ln359">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">/* Route map commands for ip address matching. */</a>
<a name="ln363">struct route_map_rule_cmd route_match_ip_address_cmd =</a>
<a name="ln364">{</a>
<a name="ln365">  &quot;ip address&quot;,</a>
<a name="ln366">  route_match_ip_address,</a>
<a name="ln367">  route_match_ip_address_compile,</a>
<a name="ln368">  route_match_ip_address_free</a>
<a name="ln369">};</a>
<a name="ln370"> </a>
<a name="ln371">/* `match ip next-hop IP_ADDRESS' */</a>
<a name="ln372"> </a>
<a name="ln373">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln374">static route_map_result_t</a>
<a name="ln375">route_match_ip_next_hop (void *rule, struct prefix *prefix, </a>
<a name="ln376">			 route_map_object_t type, void *object)</a>
<a name="ln377">{</a>
<a name="ln378">  struct access_list *alist;</a>
<a name="ln379">  struct bgp_info *bgp_info;</a>
<a name="ln380">  struct prefix_ipv4 p;</a>
<a name="ln381"> </a>
<a name="ln382">  if (type == RMAP_BGP)</a>
<a name="ln383">    {</a>
<a name="ln384">      bgp_info = object;</a>
<a name="ln385">      p.family = AF_INET;</a>
<a name="ln386">      p.prefix = bgp_info-&gt;attr-&gt;nexthop;</a>
<a name="ln387">      p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln388"> </a>
<a name="ln389">      alist = access_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln390">      if (alist == NULL)</a>
<a name="ln391">	return RMAP_NOMATCH;</a>
<a name="ln392"> </a>
<a name="ln393">      return (access_list_apply (alist, &amp;p) == FILTER_DENY ?</a>
<a name="ln394">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln395">    }</a>
<a name="ln396">  return RMAP_NOMATCH;</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399">/* Route map `ip next-hop' match statement. `arg' is</a>
<a name="ln400">   access-list name. */</a>
<a name="ln401">static void *</a>
<a name="ln402">route_match_ip_next_hop_compile (const char *arg)</a>
<a name="ln403">{</a>
<a name="ln404">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln405">}</a>
<a name="ln406"> </a>
<a name="ln407">/* Free route map's compiled `ip address' value. */</a>
<a name="ln408">static void</a>
<a name="ln409">route_match_ip_next_hop_free (void *rule)</a>
<a name="ln410">{</a>
<a name="ln411">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln412">}</a>
<a name="ln413"> </a>
<a name="ln414">/* Route map commands for ip next-hop matching. */</a>
<a name="ln415">struct route_map_rule_cmd route_match_ip_next_hop_cmd =</a>
<a name="ln416">{</a>
<a name="ln417">  &quot;ip next-hop&quot;,</a>
<a name="ln418">  route_match_ip_next_hop,</a>
<a name="ln419">  route_match_ip_next_hop_compile,</a>
<a name="ln420">  route_match_ip_next_hop_free</a>
<a name="ln421">};</a>
<a name="ln422"> </a>
<a name="ln423">/* `match ip route-source ACCESS-LIST' */</a>
<a name="ln424"> </a>
<a name="ln425">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln426">static route_map_result_t</a>
<a name="ln427">route_match_ip_route_source (void *rule, struct prefix *prefix, </a>
<a name="ln428">			     route_map_object_t type, void *object)</a>
<a name="ln429">{</a>
<a name="ln430">  struct access_list *alist;</a>
<a name="ln431">  struct bgp_info *bgp_info;</a>
<a name="ln432">  struct peer *peer;</a>
<a name="ln433">  struct prefix_ipv4 p;</a>
<a name="ln434"> </a>
<a name="ln435">  if (type == RMAP_BGP)</a>
<a name="ln436">    {</a>
<a name="ln437">      bgp_info = object;</a>
<a name="ln438">      peer = bgp_info-&gt;peer;</a>
<a name="ln439"> </a>
<a name="ln440">      if (! peer || sockunion_family (&amp;peer-&gt;su) != AF_INET)</a>
<a name="ln441">	return RMAP_NOMATCH;</a>
<a name="ln442"> </a>
<a name="ln443">      p.family = AF_INET;</a>
<a name="ln444">      p.prefix = peer-&gt;su.sin.sin_addr;</a>
<a name="ln445">      p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln446"> </a>
<a name="ln447">      alist = access_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln448">      if (alist == NULL)</a>
<a name="ln449">	return RMAP_NOMATCH;</a>
<a name="ln450"> </a>
<a name="ln451">      return (access_list_apply (alist, &amp;p) == FILTER_DENY ?</a>
<a name="ln452">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln453">    }</a>
<a name="ln454">  return RMAP_NOMATCH;</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">/* Route map `ip route-source' match statement. `arg' is</a>
<a name="ln458">   access-list name. */</a>
<a name="ln459">static void *</a>
<a name="ln460">route_match_ip_route_source_compile (const char *arg)</a>
<a name="ln461">{</a>
<a name="ln462">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln463">}</a>
<a name="ln464"> </a>
<a name="ln465">/* Free route map's compiled `ip address' value. */</a>
<a name="ln466">static void</a>
<a name="ln467">route_match_ip_route_source_free (void *rule)</a>
<a name="ln468">{</a>
<a name="ln469">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">/* Route map commands for ip route-source matching. */</a>
<a name="ln473">struct route_map_rule_cmd route_match_ip_route_source_cmd =</a>
<a name="ln474">{</a>
<a name="ln475">  &quot;ip route-source&quot;,</a>
<a name="ln476">  route_match_ip_route_source,</a>
<a name="ln477">  route_match_ip_route_source_compile,</a>
<a name="ln478">  route_match_ip_route_source_free</a>
<a name="ln479">};</a>
<a name="ln480"> </a>
<a name="ln481">/* `match ip address prefix-list PREFIX_LIST' */</a>
<a name="ln482"> </a>
<a name="ln483">static route_map_result_t</a>
<a name="ln484">route_match_ip_address_prefix_list (void *rule, struct prefix *prefix, </a>
<a name="ln485">				    route_map_object_t type, void *object)</a>
<a name="ln486">{</a>
<a name="ln487">  struct prefix_list *plist;</a>
<a name="ln488"> </a>
<a name="ln489">  if (type == RMAP_BGP)</a>
<a name="ln490">    {</a>
<a name="ln491">      plist = prefix_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln492">      if (plist == NULL)</a>
<a name="ln493">	return RMAP_NOMATCH;</a>
<a name="ln494">    </a>
<a name="ln495">      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?</a>
<a name="ln496">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln497">    }</a>
<a name="ln498">  return RMAP_NOMATCH;</a>
<a name="ln499">}</a>
<a name="ln500"> </a>
<a name="ln501">static void *</a>
<a name="ln502">route_match_ip_address_prefix_list_compile (const char *arg)</a>
<a name="ln503">{</a>
<a name="ln504">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln505">}</a>
<a name="ln506"> </a>
<a name="ln507">static void</a>
<a name="ln508">route_match_ip_address_prefix_list_free (void *rule)</a>
<a name="ln509">{</a>
<a name="ln510">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln511">}</a>
<a name="ln512"> </a>
<a name="ln513">struct route_map_rule_cmd route_match_ip_address_prefix_list_cmd =</a>
<a name="ln514">{</a>
<a name="ln515">  &quot;ip address prefix-list&quot;,</a>
<a name="ln516">  route_match_ip_address_prefix_list,</a>
<a name="ln517">  route_match_ip_address_prefix_list_compile,</a>
<a name="ln518">  route_match_ip_address_prefix_list_free</a>
<a name="ln519">};</a>
<a name="ln520"> </a>
<a name="ln521">/* `match ip next-hop prefix-list PREFIX_LIST' */</a>
<a name="ln522"> </a>
<a name="ln523">static route_map_result_t</a>
<a name="ln524">route_match_ip_next_hop_prefix_list (void *rule, struct prefix *prefix,</a>
<a name="ln525">                                    route_map_object_t type, void *object)</a>
<a name="ln526">{</a>
<a name="ln527">  struct prefix_list *plist;</a>
<a name="ln528">  struct bgp_info *bgp_info;</a>
<a name="ln529">  struct prefix_ipv4 p;</a>
<a name="ln530"> </a>
<a name="ln531">  if (type == RMAP_BGP)</a>
<a name="ln532">    {</a>
<a name="ln533">      bgp_info = object;</a>
<a name="ln534">      p.family = AF_INET;</a>
<a name="ln535">      p.prefix = bgp_info-&gt;attr-&gt;nexthop;</a>
<a name="ln536">      p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln537"> </a>
<a name="ln538">      plist = prefix_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln539">      if (plist == NULL)</a>
<a name="ln540">        return RMAP_NOMATCH;</a>
<a name="ln541"> </a>
<a name="ln542">      return (prefix_list_apply (plist, &amp;p) == PREFIX_DENY ?</a>
<a name="ln543">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln544">    }</a>
<a name="ln545">  return RMAP_NOMATCH;</a>
<a name="ln546">}</a>
<a name="ln547"> </a>
<a name="ln548">static void *</a>
<a name="ln549">route_match_ip_next_hop_prefix_list_compile (const char *arg)</a>
<a name="ln550">{</a>
<a name="ln551">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln552">}</a>
<a name="ln553"> </a>
<a name="ln554">static void</a>
<a name="ln555">route_match_ip_next_hop_prefix_list_free (void *rule)</a>
<a name="ln556">{</a>
<a name="ln557">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln558">}</a>
<a name="ln559"> </a>
<a name="ln560">struct route_map_rule_cmd route_match_ip_next_hop_prefix_list_cmd =</a>
<a name="ln561">{</a>
<a name="ln562">  &quot;ip next-hop prefix-list&quot;,</a>
<a name="ln563">  route_match_ip_next_hop_prefix_list,</a>
<a name="ln564">  route_match_ip_next_hop_prefix_list_compile,</a>
<a name="ln565">  route_match_ip_next_hop_prefix_list_free</a>
<a name="ln566">};</a>
<a name="ln567"> </a>
<a name="ln568">/* `match ip route-source prefix-list PREFIX_LIST' */</a>
<a name="ln569"> </a>
<a name="ln570">static route_map_result_t</a>
<a name="ln571">route_match_ip_route_source_prefix_list (void *rule, struct prefix *prefix,</a>
<a name="ln572">					 route_map_object_t type, void *object)</a>
<a name="ln573">{</a>
<a name="ln574">  struct prefix_list *plist;</a>
<a name="ln575">  struct bgp_info *bgp_info;</a>
<a name="ln576">  struct peer *peer;</a>
<a name="ln577">  struct prefix_ipv4 p;</a>
<a name="ln578"> </a>
<a name="ln579">  if (type == RMAP_BGP)</a>
<a name="ln580">    {</a>
<a name="ln581">      bgp_info = object;</a>
<a name="ln582">      peer = bgp_info-&gt;peer;</a>
<a name="ln583"> </a>
<a name="ln584">      if (! peer || sockunion_family (&amp;peer-&gt;su) != AF_INET)</a>
<a name="ln585">	return RMAP_NOMATCH;</a>
<a name="ln586"> </a>
<a name="ln587">      p.family = AF_INET;</a>
<a name="ln588">      p.prefix = peer-&gt;su.sin.sin_addr;</a>
<a name="ln589">      p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln590"> </a>
<a name="ln591">      plist = prefix_list_lookup (AFI_IP, (char *) rule);</a>
<a name="ln592">      if (plist == NULL)</a>
<a name="ln593">        return RMAP_NOMATCH;</a>
<a name="ln594"> </a>
<a name="ln595">      return (prefix_list_apply (plist, &amp;p) == PREFIX_DENY ?</a>
<a name="ln596">              RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln597">    }</a>
<a name="ln598">  return RMAP_NOMATCH;</a>
<a name="ln599">}</a>
<a name="ln600"> </a>
<a name="ln601">static void *</a>
<a name="ln602">route_match_ip_route_source_prefix_list_compile (const char *arg)</a>
<a name="ln603">{</a>
<a name="ln604">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln605">}</a>
<a name="ln606"> </a>
<a name="ln607">static void</a>
<a name="ln608">route_match_ip_route_source_prefix_list_free (void *rule)</a>
<a name="ln609">{</a>
<a name="ln610">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">struct route_map_rule_cmd route_match_ip_route_source_prefix_list_cmd =</a>
<a name="ln614">{</a>
<a name="ln615">  &quot;ip route-source prefix-list&quot;,</a>
<a name="ln616">  route_match_ip_route_source_prefix_list,</a>
<a name="ln617">  route_match_ip_route_source_prefix_list_compile,</a>
<a name="ln618">  route_match_ip_route_source_prefix_list_free</a>
<a name="ln619">};</a>
<a name="ln620"> </a>
<a name="ln621">/* `match local-preference LOCAL-PREF' */</a>
<a name="ln622"> </a>
<a name="ln623">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln624">static route_map_result_t</a>
<a name="ln625">route_match_local_pref (void *rule, struct prefix *prefix,</a>
<a name="ln626">			route_map_object_t type, void *object)</a>
<a name="ln627">{</a>
<a name="ln628">  u_int32_t *local_pref;</a>
<a name="ln629">  struct bgp_info *bgp_info;</a>
<a name="ln630"> </a>
<a name="ln631">  if (type == RMAP_BGP)</a>
<a name="ln632">    {</a>
<a name="ln633">      local_pref = rule;</a>
<a name="ln634">      bgp_info = object;</a>
<a name="ln635"> </a>
<a name="ln636">      if (bgp_info-&gt;attr-&gt;local_pref == *local_pref)</a>
<a name="ln637">	return RMAP_MATCH;</a>
<a name="ln638">      else</a>
<a name="ln639">	return RMAP_NOMATCH;</a>
<a name="ln640">    }</a>
<a name="ln641">  return RMAP_NOMATCH;</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">/* Route map `match local-preference' match statement.</a>
<a name="ln645">   `arg' is local-pref value */</a>
<a name="ln646">static void *</a>
<a name="ln647">route_match_local_pref_compile (const char *arg)</a>
<a name="ln648">{</a>
<a name="ln649">  u_int32_t *local_pref;</a>
<a name="ln650">  char *endptr = NULL;</a>
<a name="ln651">  unsigned long tmpval;</a>
<a name="ln652"> </a>
<a name="ln653">  /* Locpref value shoud be integer. */</a>
<a name="ln654">  if (! all_digit (arg))</a>
<a name="ln655">    return NULL;</a>
<a name="ln656"> </a>
<a name="ln657">  errno = 0;</a>
<a name="ln658">  tmpval = strtoul (arg, &amp;endptr, 10);</a>
<a name="ln659">  if (*endptr != '\0' || errno || tmpval &gt; UINT32_MAX)</a>
<a name="ln660">    return NULL;</a>
<a name="ln661"> </a>
<a name="ln662">  local_pref = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_int32_t));</a>
<a name="ln663"> </a>
<a name="ln664">  if (!local_pref)</a>
<a name="ln665">    return local_pref;</a>
<a name="ln666"> </a>
<a name="ln667">  *local_pref = tmpval;</a>
<a name="ln668">  return local_pref;</a>
<a name="ln669">}</a>
<a name="ln670"> </a>
<a name="ln671">/* Free route map's compiled `match local-preference' value. */</a>
<a name="ln672">static void</a>
<a name="ln673">route_match_local_pref_free (void *rule)</a>
<a name="ln674">{</a>
<a name="ln675">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln676">}</a>
<a name="ln677"> </a>
<a name="ln678">/* Route map commands for metric matching. */</a>
<a name="ln679">struct route_map_rule_cmd route_match_local_pref_cmd =</a>
<a name="ln680">{</a>
<a name="ln681">  &quot;local-preference&quot;,</a>
<a name="ln682">  route_match_local_pref,</a>
<a name="ln683">  route_match_local_pref_compile,</a>
<a name="ln684">  route_match_local_pref_free</a>
<a name="ln685">};</a>
<a name="ln686"> </a>
<a name="ln687">/* `match metric METRIC' */</a>
<a name="ln688"> </a>
<a name="ln689">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln690">static route_map_result_t</a>
<a name="ln691">route_match_metric (void *rule, struct prefix *prefix, </a>
<a name="ln692">		    route_map_object_t type, void *object)</a>
<a name="ln693">{</a>
<a name="ln694">  struct rmap_value *rv;</a>
<a name="ln695">  struct bgp_info *bgp_info;</a>
<a name="ln696"> </a>
<a name="ln697">  if (type == RMAP_BGP)</a>
<a name="ln698">    {</a>
<a name="ln699">      rv = rule;</a>
<a name="ln700">      bgp_info = object;</a>
<a name="ln701">      return route_value_match(rv, bgp_info-&gt;attr-&gt;med);</a>
<a name="ln702">    }</a>
<a name="ln703">  return RMAP_NOMATCH;</a>
<a name="ln704">}</a>
<a name="ln705"> </a>
<a name="ln706">/* Route map commands for metric matching. */</a>
<a name="ln707">struct route_map_rule_cmd route_match_metric_cmd =</a>
<a name="ln708">{</a>
<a name="ln709">  &quot;metric&quot;,</a>
<a name="ln710">  route_match_metric,</a>
<a name="ln711">  route_value_compile,</a>
<a name="ln712">  route_value_free,</a>
<a name="ln713">};</a>
<a name="ln714"> </a>
<a name="ln715">/* `match as-path ASPATH' */</a>
<a name="ln716"> </a>
<a name="ln717">/* Match function for as-path match.  I assume given object is */</a>
<a name="ln718">static route_map_result_t</a>
<a name="ln719">route_match_aspath (void *rule, struct prefix *prefix, </a>
<a name="ln720">		    route_map_object_t type, void *object)</a>
<a name="ln721">{</a>
<a name="ln722">  </a>
<a name="ln723">  struct as_list *as_list;</a>
<a name="ln724">  struct bgp_info *bgp_info;</a>
<a name="ln725"> </a>
<a name="ln726">  if (type == RMAP_BGP)</a>
<a name="ln727">    {</a>
<a name="ln728">      as_list = as_list_lookup ((char *) rule);</a>
<a name="ln729">      if (as_list == NULL)</a>
<a name="ln730">	return RMAP_NOMATCH;</a>
<a name="ln731">    </a>
<a name="ln732">      bgp_info = object;</a>
<a name="ln733">    </a>
<a name="ln734">      /* Perform match. */</a>
<a name="ln735">      return ((as_list_apply (as_list, bgp_info-&gt;attr-&gt;aspath) == AS_FILTER_DENY) ? RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln736">    }</a>
<a name="ln737">  return RMAP_NOMATCH;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">/* Compile function for as-path match. */</a>
<a name="ln741">static void *</a>
<a name="ln742">route_match_aspath_compile (const char *arg)</a>
<a name="ln743">{</a>
<a name="ln744">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747">/* Compile function for as-path match. */</a>
<a name="ln748">static void</a>
<a name="ln749">route_match_aspath_free (void *rule)</a>
<a name="ln750">{</a>
<a name="ln751">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln752">}</a>
<a name="ln753"> </a>
<a name="ln754">/* Route map commands for aspath matching. */</a>
<a name="ln755">struct route_map_rule_cmd route_match_aspath_cmd = </a>
<a name="ln756">{</a>
<a name="ln757">  &quot;as-path&quot;,</a>
<a name="ln758">  route_match_aspath,</a>
<a name="ln759">  route_match_aspath_compile,</a>
<a name="ln760">  route_match_aspath_free</a>
<a name="ln761">};</a>
<a name="ln762"> </a>
<a name="ln763">/* `match community COMMUNIY' */</a>
<a name="ln764">struct rmap_community</a>
<a name="ln765">{</a>
<a name="ln766">  char *name;</a>
<a name="ln767">  int exact;</a>
<a name="ln768">};</a>
<a name="ln769"> </a>
<a name="ln770">/* Match function for community match. */</a>
<a name="ln771">static route_map_result_t</a>
<a name="ln772">route_match_community (void *rule, struct prefix *prefix, </a>
<a name="ln773">		       route_map_object_t type, void *object)</a>
<a name="ln774">{</a>
<a name="ln775">  struct community_list *list;</a>
<a name="ln776">  struct bgp_info *bgp_info;</a>
<a name="ln777">  struct rmap_community *rcom;</a>
<a name="ln778"> </a>
<a name="ln779">  if (type == RMAP_BGP) </a>
<a name="ln780">    {</a>
<a name="ln781">      bgp_info = object;</a>
<a name="ln782">      rcom = rule;</a>
<a name="ln783"> </a>
<a name="ln784">      list = community_list_lookup (bgp_clist, rcom-&gt;name, COMMUNITY_LIST_MASTER);</a>
<a name="ln785">      if (! list)</a>
<a name="ln786">	return RMAP_NOMATCH;</a>
<a name="ln787"> </a>
<a name="ln788">      if (rcom-&gt;exact)</a>
<a name="ln789">	{</a>
<a name="ln790">	  if (community_list_exact_match (bgp_info-&gt;attr-&gt;community, list))</a>
<a name="ln791">	    return RMAP_MATCH;</a>
<a name="ln792">	}</a>
<a name="ln793">      else</a>
<a name="ln794">	{</a>
<a name="ln795">	  if (community_list_match (bgp_info-&gt;attr-&gt;community, list))</a>
<a name="ln796">	    return RMAP_MATCH;</a>
<a name="ln797">	}</a>
<a name="ln798">    }</a>
<a name="ln799">  return RMAP_NOMATCH;</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">/* Compile function for community match. */</a>
<a name="ln803">static void *</a>
<a name="ln804">route_match_community_compile (const char *arg)</a>
<a name="ln805">{</a>
<a name="ln806">  struct rmap_community *rcom;</a>
<a name="ln807">  int len;</a>
<a name="ln808">  char *p;</a>
<a name="ln809"> </a>
<a name="ln810">  rcom = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct rmap_community));</a>
<a name="ln811"> </a>
<a name="ln812">  p = strchr (arg, ' ');</a>
<a name="ln813">  if (p)</a>
<a name="ln814">    {</a>
<a name="ln815">      len = p - arg;</a>
<a name="ln816">      rcom-&gt;name = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, len + 1);</a>
<a name="ln817">      memcpy (rcom-&gt;name, arg, len);</a>
<a name="ln818">      rcom-&gt;exact = 1;</a>
<a name="ln819">    }</a>
<a name="ln820">  else</a>
<a name="ln821">    {</a>
<a name="ln822">      rcom-&gt;name = XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln823">      rcom-&gt;exact = 0;</a>
<a name="ln824">    }</a>
<a name="ln825">  return rcom;</a>
<a name="ln826">}</a>
<a name="ln827"> </a>
<a name="ln828">/* Compile function for community match. */</a>
<a name="ln829">static void</a>
<a name="ln830">route_match_community_free (void *rule)</a>
<a name="ln831">{</a>
<a name="ln832">  struct rmap_community *rcom = rule;</a>
<a name="ln833"> </a>
<a name="ln834">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rcom-&gt;name); </a>
<a name="ln835">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rcom);</a>
<a name="ln836">}</a>
<a name="ln837"> </a>
<a name="ln838">/* Route map commands for community matching. */</a>
<a name="ln839">struct route_map_rule_cmd route_match_community_cmd = </a>
<a name="ln840">{</a>
<a name="ln841">  &quot;community&quot;,</a>
<a name="ln842">  route_match_community,</a>
<a name="ln843">  route_match_community_compile,</a>
<a name="ln844">  route_match_community_free</a>
<a name="ln845">};</a>
<a name="ln846"> </a>
<a name="ln847">/* Match function for lcommunity match. */</a>
<a name="ln848">static route_map_result_t</a>
<a name="ln849">route_match_lcommunity (void *rule, struct prefix *prefix,</a>
<a name="ln850">		       route_map_object_t type, void *object)</a>
<a name="ln851">{</a>
<a name="ln852">  struct community_list *list;</a>
<a name="ln853">  struct bgp_info *bgp_info;</a>
<a name="ln854">  struct rmap_community *rcom;</a>
<a name="ln855"> </a>
<a name="ln856">  if (type == RMAP_BGP)</a>
<a name="ln857">    {</a>
<a name="ln858">      bgp_info = object;</a>
<a name="ln859">      rcom = rule;</a>
<a name="ln860"> </a>
<a name="ln861">      list = community_list_lookup (bgp_clist, rcom-&gt;name,</a>
<a name="ln862">				    LARGE_COMMUNITY_LIST_MASTER);</a>
<a name="ln863">      if (! list)</a>
<a name="ln864">	return RMAP_NOMATCH;</a>
<a name="ln865"> </a>
<a name="ln866">      if (bgp_info-&gt;attr-&gt;extra &amp;&amp;</a>
<a name="ln867">	  lcommunity_list_match (bgp_info-&gt;attr-&gt;extra-&gt;lcommunity, list))</a>
<a name="ln868">	return RMAP_MATCH;</a>
<a name="ln869"> </a>
<a name="ln870">    }</a>
<a name="ln871">  return RMAP_NOMATCH;</a>
<a name="ln872">}</a>
<a name="ln873"> </a>
<a name="ln874">/* Compile function for community match. */</a>
<a name="ln875">static void *</a>
<a name="ln876">route_match_lcommunity_compile (const char *arg)</a>
<a name="ln877">{</a>
<a name="ln878">  struct rmap_community *rcom;</a>
<a name="ln879">  int len;</a>
<a name="ln880">  char *p;</a>
<a name="ln881"> </a>
<a name="ln882">  rcom = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct rmap_community));</a>
<a name="ln883"> </a>
<a name="ln884">  p = strchr (arg, ' ');</a>
<a name="ln885">  if (p)</a>
<a name="ln886">    {</a>
<a name="ln887">      len = p - arg;</a>
<a name="ln888">      rcom-&gt;name = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, len + 1);</a>
<a name="ln889">      memcpy (rcom-&gt;name, arg, len);</a>
<a name="ln890">    }</a>
<a name="ln891">  else</a>
<a name="ln892">    {</a>
<a name="ln893">      rcom-&gt;name = XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln894">      rcom-&gt;exact = 0;</a>
<a name="ln895">    }</a>
<a name="ln896">  return rcom;</a>
<a name="ln897">}</a>
<a name="ln898"> </a>
<a name="ln899">/* Compile function for community match. */</a>
<a name="ln900">static void</a>
<a name="ln901">route_match_lcommunity_free (void *rule)</a>
<a name="ln902">{</a>
<a name="ln903">  struct rmap_community *rcom = rule;</a>
<a name="ln904"> </a>
<a name="ln905">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rcom-&gt;name);</a>
<a name="ln906">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rcom);</a>
<a name="ln907">}</a>
<a name="ln908"> </a>
<a name="ln909">/* Route map commands for community matching. */</a>
<a name="ln910">struct route_map_rule_cmd route_match_lcommunity_cmd =</a>
<a name="ln911">{</a>
<a name="ln912">  &quot;large-community&quot;,</a>
<a name="ln913">  route_match_lcommunity,</a>
<a name="ln914">  route_match_lcommunity_compile,</a>
<a name="ln915">  route_match_lcommunity_free</a>
<a name="ln916">};</a>
<a name="ln917"> </a>
<a name="ln918"> </a>
<a name="ln919">/* Match function for extcommunity match. */</a>
<a name="ln920">static route_map_result_t</a>
<a name="ln921">route_match_ecommunity (void *rule, struct prefix *prefix,</a>
<a name="ln922">			route_map_object_t type, void *object)</a>
<a name="ln923">{</a>
<a name="ln924">  struct community_list *list;</a>
<a name="ln925">  struct bgp_info *bgp_info;</a>
<a name="ln926"> </a>
<a name="ln927">  if (type == RMAP_BGP)</a>
<a name="ln928">    {</a>
<a name="ln929">      bgp_info = object;</a>
<a name="ln930"> </a>
<a name="ln931">      if (!bgp_info-&gt;attr-&gt;extra)</a>
<a name="ln932">        return RMAP_NOMATCH;</a>
<a name="ln933"> </a>
<a name="ln934">      list = community_list_lookup (bgp_clist, (char *) rule,</a>
<a name="ln935">				    EXTCOMMUNITY_LIST_MASTER);</a>
<a name="ln936">      if (! list)</a>
<a name="ln937">	return RMAP_NOMATCH;</a>
<a name="ln938"> </a>
<a name="ln939">      if (ecommunity_list_match (bgp_info-&gt;attr-&gt;extra-&gt;ecommunity, list))</a>
<a name="ln940">	return RMAP_MATCH;</a>
<a name="ln941">    }</a>
<a name="ln942">  return RMAP_NOMATCH;</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945">/* Compile function for extcommunity match. */</a>
<a name="ln946">static void *</a>
<a name="ln947">route_match_ecommunity_compile (const char *arg)</a>
<a name="ln948">{</a>
<a name="ln949">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln950">}</a>
<a name="ln951"> </a>
<a name="ln952">/* Compile function for extcommunity match. */</a>
<a name="ln953">static void</a>
<a name="ln954">route_match_ecommunity_free (void *rule)</a>
<a name="ln955">{</a>
<a name="ln956">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln957">}</a>
<a name="ln958"> </a>
<a name="ln959">/* Route map commands for community matching. */</a>
<a name="ln960">struct route_map_rule_cmd route_match_ecommunity_cmd = </a>
<a name="ln961">{</a>
<a name="ln962">  &quot;extcommunity&quot;,</a>
<a name="ln963">  route_match_ecommunity,</a>
<a name="ln964">  route_match_ecommunity_compile,</a>
<a name="ln965">  route_match_ecommunity_free</a>
<a name="ln966">};</a>
<a name="ln967"> </a>
<a name="ln968">/* `match nlri` and `set nlri` are replaced by `address-family ipv4`</a>
<a name="ln969">   and `address-family vpnv4'.  */</a>
<a name="ln970"> </a>
<a name="ln971">/* `match origin' */</a>
<a name="ln972">static route_map_result_t</a>
<a name="ln973">route_match_origin (void *rule, struct prefix *prefix, </a>
<a name="ln974">		    route_map_object_t type, void *object)</a>
<a name="ln975">{</a>
<a name="ln976">  u_char *origin;</a>
<a name="ln977">  struct bgp_info *bgp_info;</a>
<a name="ln978"> </a>
<a name="ln979">  if (type == RMAP_BGP)</a>
<a name="ln980">    {</a>
<a name="ln981">      origin = rule;</a>
<a name="ln982">      bgp_info = object;</a>
<a name="ln983">    </a>
<a name="ln984">      if (bgp_info-&gt;attr-&gt;origin == *origin)</a>
<a name="ln985">	return RMAP_MATCH;</a>
<a name="ln986">    }</a>
<a name="ln987"> </a>
<a name="ln988">  return RMAP_NOMATCH;</a>
<a name="ln989">}</a>
<a name="ln990"> </a>
<a name="ln991">static void *</a>
<a name="ln992">route_match_origin_compile (const char *arg)</a>
<a name="ln993">{</a>
<a name="ln994">  u_char *origin;</a>
<a name="ln995"> </a>
<a name="ln996">  origin = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_char));</a>
<a name="ln997"> </a>
<a name="ln998">  if (strcmp (arg, &quot;igp&quot;) == 0)</a>
<a name="ln999">    *origin = 0;</a>
<a name="ln1000">  else if (strcmp (arg, &quot;egp&quot;) == 0)</a>
<a name="ln1001">    *origin = 1;</a>
<a name="ln1002">  else</a>
<a name="ln1003">    *origin = 2;</a>
<a name="ln1004"> </a>
<a name="ln1005">  return origin;</a>
<a name="ln1006">}</a>
<a name="ln1007"> </a>
<a name="ln1008">/* Free route map's compiled `ip address' value. */</a>
<a name="ln1009">static void</a>
<a name="ln1010">route_match_origin_free (void *rule)</a>
<a name="ln1011">{</a>
<a name="ln1012">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln1013">}</a>
<a name="ln1014"> </a>
<a name="ln1015">/* Route map commands for origin matching. */</a>
<a name="ln1016">struct route_map_rule_cmd route_match_origin_cmd =</a>
<a name="ln1017">{</a>
<a name="ln1018">  &quot;origin&quot;,</a>
<a name="ln1019">  route_match_origin,</a>
<a name="ln1020">  route_match_origin_compile,</a>
<a name="ln1021">  route_match_origin_free</a>
<a name="ln1022">};</a>
<a name="ln1023"> </a>
<a name="ln1024">/* match probability  { */</a>
<a name="ln1025"> </a>
<a name="ln1026">static route_map_result_t</a>
<a name="ln1027">route_match_probability (void *rule, struct prefix *prefix,</a>
<a name="ln1028">		    route_map_object_t type, void *object)</a>
<a name="ln1029">{</a>
<a name="ln1030">  long r = random();</a>
<a name="ln1031"> </a>
<a name="ln1032">  switch (*(long *) rule)</a>
<a name="ln1033">  {</a>
<a name="ln1034">    case 0: break;</a>
<a name="ln1035">    case RAND_MAX: return RMAP_MATCH;</a>
<a name="ln1036">    default:</a>
<a name="ln1037">      if (r &lt; *(long *) rule)</a>
<a name="ln1038">        {</a>
<a name="ln1039">          return RMAP_MATCH;</a>
<a name="ln1040">        }</a>
<a name="ln1041">  }</a>
<a name="ln1042"> </a>
<a name="ln1043">  return RMAP_NOMATCH;</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">static void *</a>
<a name="ln1047">route_match_probability_compile (const char *arg)</a>
<a name="ln1048">{</a>
<a name="ln1049">  long *lobule;</a>
<a name="ln1050">  unsigned  perc;</a>
<a name="ln1051"> </a>
<a name="ln1052">  perc    = atoi (arg);</a>
<a name="ln1053">  lobule  = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (long));</a>
<a name="ln1054"> </a>
<a name="ln1055">  switch (perc)</a>
<a name="ln1056">    {</a>
<a name="ln1057">      case 0:   *lobule = 0; break;</a>
<a name="ln1058">      case 100: *lobule = RAND_MAX; break;</a>
<a name="ln1059">      default:  *lobule = RAND_MAX / 100 * perc;</a>
<a name="ln1060">    }</a>
<a name="ln1061"> </a>
<a name="ln1062">  return lobule;</a>
<a name="ln1063">}</a>
<a name="ln1064"> </a>
<a name="ln1065">static void</a>
<a name="ln1066">route_match_probability_free (void *rule)</a>
<a name="ln1067">{</a>
<a name="ln1068">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">struct route_map_rule_cmd route_match_probability_cmd =</a>
<a name="ln1072">{</a>
<a name="ln1073">  &quot;probability&quot;,</a>
<a name="ln1074">  route_match_probability,</a>
<a name="ln1075">  route_match_probability_compile,</a>
<a name="ln1076">  route_match_probability_free</a>
<a name="ln1077">};</a>
<a name="ln1078"> </a>
<a name="ln1079">/* } */</a>
<a name="ln1080"> </a>
<a name="ln1081">/* `set ip next-hop IP_ADDRESS' */</a>
<a name="ln1082"> </a>
<a name="ln1083">/* Match function return 1 if match is success else return zero. */</a>
<a name="ln1084">static route_map_result_t</a>
<a name="ln1085">route_match_tag (void *rule, struct prefix *prefix,</a>
<a name="ln1086">                 route_map_object_t type, void *object)</a>
<a name="ln1087">{</a>
<a name="ln1088">  route_tag_t *tag;</a>
<a name="ln1089">  struct bgp_info *bgp_info;</a>
<a name="ln1090"> </a>
<a name="ln1091">  if (type == RMAP_BGP)</a>
<a name="ln1092">    {</a>
<a name="ln1093">      tag = rule;</a>
<a name="ln1094">      bgp_info = object;</a>
<a name="ln1095"> </a>
<a name="ln1096">      if (!bgp_info-&gt;attr-&gt;extra)</a>
<a name="ln1097">         return RMAP_NOMATCH;</a>
<a name="ln1098"> </a>
<a name="ln1099">      return ((bgp_info-&gt;attr-&gt;extra-&gt;tag == *tag)? RMAP_MATCH : RMAP_NOMATCH);</a>
<a name="ln1100">    }</a>
<a name="ln1101"> </a>
<a name="ln1102">  return RMAP_NOMATCH;</a>
<a name="ln1103">}</a>
<a name="ln1104"> </a>
<a name="ln1105">/* Route map commands for tag matching. */</a>
<a name="ln1106">static struct route_map_rule_cmd route_match_tag_cmd =</a>
<a name="ln1107">{</a>
<a name="ln1108">  &quot;tag&quot;,</a>
<a name="ln1109">  route_match_tag,</a>
<a name="ln1110">  route_map_rule_tag_compile,</a>
<a name="ln1111">  route_map_rule_tag_free,</a>
<a name="ln1112">};</a>
<a name="ln1113"> </a>
<a name="ln1114"> </a>
<a name="ln1115">/* Set nexthop to object.  ojbect must be pointer to struct attr. */</a>
<a name="ln1116">struct rmap_ip_nexthop_set</a>
<a name="ln1117">{</a>
<a name="ln1118">  struct in_addr *address;</a>
<a name="ln1119">  int peer_address;</a>
<a name="ln1120">};</a>
<a name="ln1121"> </a>
<a name="ln1122">static route_map_result_t</a>
<a name="ln1123">route_set_ip_nexthop (void *rule, struct prefix *prefix,</a>
<a name="ln1124">		      route_map_object_t type, void *object)</a>
<a name="ln1125">{</a>
<a name="ln1126">  struct rmap_ip_nexthop_set *rins = rule;</a>
<a name="ln1127">  struct bgp_info *bgp_info;</a>
<a name="ln1128">  struct peer *peer;</a>
<a name="ln1129"> </a>
<a name="ln1130">  if (type == RMAP_BGP)</a>
<a name="ln1131">    {</a>
<a name="ln1132">      bgp_info = object;</a>
<a name="ln1133">      peer = bgp_info-&gt;peer;</a>
<a name="ln1134"> </a>
<a name="ln1135">      if (rins-&gt;peer_address)</a>
<a name="ln1136">	{</a>
<a name="ln1137">         if ((CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_IN) ||</a>
<a name="ln1138">           CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_IMPORT))</a>
<a name="ln1139">	      &amp;&amp; peer-&gt;su_remote </a>
<a name="ln1140">	      &amp;&amp; sockunion_family (peer-&gt;su_remote) == AF_INET)</a>
<a name="ln1141">	    {</a>
<a name="ln1142">	      bgp_info-&gt;attr-&gt;nexthop.s_addr = sockunion2ip (peer-&gt;su_remote);</a>
<a name="ln1143">	      bgp_info-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);</a>
<a name="ln1144">	    }</a>
<a name="ln1145">	  else if (CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_OUT)</a>
<a name="ln1146">		   &amp;&amp; peer-&gt;su_local</a>
<a name="ln1147">		   &amp;&amp; sockunion_family (peer-&gt;su_local) == AF_INET)</a>
<a name="ln1148">	    {</a>
<a name="ln1149">	      bgp_info-&gt;attr-&gt;nexthop.s_addr = sockunion2ip (peer-&gt;su_local);</a>
<a name="ln1150">	      bgp_info-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);</a>
<a name="ln1151">	    }</a>
<a name="ln1152">	}</a>
<a name="ln1153">      else</a>
<a name="ln1154">	{</a>
<a name="ln1155">	  /* Set next hop value. */ </a>
<a name="ln1156">	  bgp_info-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_NEXT_HOP);</a>
<a name="ln1157">	  bgp_info-&gt;attr-&gt;nexthop = *rins-&gt;address;</a>
<a name="ln1158">	}</a>
<a name="ln1159">    }</a>
<a name="ln1160"> </a>
<a name="ln1161">  return RMAP_OKAY;</a>
<a name="ln1162">}</a>
<a name="ln1163"> </a>
<a name="ln1164">/* Route map `ip nexthop' compile function.  Given string is converted</a>
<a name="ln1165">   to struct in_addr structure. */</a>
<a name="ln1166">static void *</a>
<a name="ln1167">route_set_ip_nexthop_compile (const char *arg)</a>
<a name="ln1168">{</a>
<a name="ln1169">  struct rmap_ip_nexthop_set *rins;</a>
<a name="ln1170">  struct in_addr *address = NULL;</a>
<a name="ln1171">  int peer_address = 0;</a>
<a name="ln1172">  int ret;</a>
<a name="ln1173"> </a>
<a name="ln1174">  if (strcmp (arg, &quot;peer-address&quot;) == 0)</a>
<a name="ln1175">    peer_address = 1;</a>
<a name="ln1176">  else</a>
<a name="ln1177">    {</a>
<a name="ln1178">      address = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in_addr));</a>
<a name="ln1179">      ret = inet_aton (arg, address);</a>
<a name="ln1180"> </a>
<a name="ln1181">      if (ret == 0)</a>
<a name="ln1182">	{</a>
<a name="ln1183">	  XFREE (MTYPE_ROUTE_MAP_COMPILED, address);</a>
<a name="ln1184">	  return NULL;</a>
<a name="ln1185">	}</a>
<a name="ln1186">    }</a>
<a name="ln1187"> </a>
<a name="ln1188">  rins = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct rmap_ip_nexthop_set));</a>
<a name="ln1189"> </a>
<a name="ln1190">  rins-&gt;address = address;</a>
<a name="ln1191">  rins-&gt;peer_address = peer_address;</a>
<a name="ln1192"> </a>
<a name="ln1193">  return rins;</a>
<a name="ln1194">}</a>
<a name="ln1195"> </a>
<a name="ln1196">/* Free route map's compiled `ip nexthop' value. */</a>
<a name="ln1197">static void</a>
<a name="ln1198">route_set_ip_nexthop_free (void *rule)</a>
<a name="ln1199">{</a>
<a name="ln1200">  struct rmap_ip_nexthop_set *rins = rule;</a>
<a name="ln1201"> </a>
<a name="ln1202">  if (rins-&gt;address)</a>
<a name="ln1203">    XFREE (MTYPE_ROUTE_MAP_COMPILED, rins-&gt;address);</a>
<a name="ln1204">    </a>
<a name="ln1205">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rins);</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">/* Route map commands for ip nexthop set. */</a>
<a name="ln1209">struct route_map_rule_cmd route_set_ip_nexthop_cmd =</a>
<a name="ln1210">{</a>
<a name="ln1211">  &quot;ip next-hop&quot;,</a>
<a name="ln1212">  route_set_ip_nexthop,</a>
<a name="ln1213">  route_set_ip_nexthop_compile,</a>
<a name="ln1214">  route_set_ip_nexthop_free</a>
<a name="ln1215">};</a>
<a name="ln1216"> </a>
<a name="ln1217">/* `set local-preference LOCAL_PREF' */</a>
<a name="ln1218"> </a>
<a name="ln1219">/* Set local preference. */</a>
<a name="ln1220">static route_map_result_t</a>
<a name="ln1221">route_set_local_pref (void *rule, struct prefix *prefix,</a>
<a name="ln1222">		      route_map_object_t type, void *object)</a>
<a name="ln1223">{</a>
<a name="ln1224">  struct rmap_value *rv;</a>
<a name="ln1225">  struct bgp_info *bgp_info;</a>
<a name="ln1226">  u_int32_t locpref = 0;</a>
<a name="ln1227"> </a>
<a name="ln1228">  if (type == RMAP_BGP)</a>
<a name="ln1229">    {</a>
<a name="ln1230">      /* Fetch routemap's rule information. */</a>
<a name="ln1231">      rv = rule;</a>
<a name="ln1232">      bgp_info = object;</a>
<a name="ln1233">    </a>
<a name="ln1234">      /* Set local preference value. */ </a>
<a name="ln1235">      if (bgp_info-&gt;attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF))</a>
<a name="ln1236">	locpref = bgp_info-&gt;attr-&gt;local_pref;</a>
<a name="ln1237"> </a>
<a name="ln1238">      bgp_info-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_LOCAL_PREF);</a>
<a name="ln1239">      bgp_info-&gt;attr-&gt;local_pref = route_value_adjust(rv, locpref, bgp_info-&gt;peer);</a>
<a name="ln1240">    }</a>
<a name="ln1241"> </a>
<a name="ln1242">  return RMAP_OKAY;</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245">/* Set local preference rule structure. */</a>
<a name="ln1246">struct route_map_rule_cmd route_set_local_pref_cmd = </a>
<a name="ln1247">{</a>
<a name="ln1248">  &quot;local-preference&quot;,</a>
<a name="ln1249">  route_set_local_pref,</a>
<a name="ln1250">  route_value_compile,</a>
<a name="ln1251">  route_value_free,</a>
<a name="ln1252">};</a>
<a name="ln1253"> </a>
<a name="ln1254">/* `set weight WEIGHT' */</a>
<a name="ln1255"> </a>
<a name="ln1256">/* Set weight. */</a>
<a name="ln1257">static route_map_result_t</a>
<a name="ln1258">route_set_weight (void *rule, struct prefix *prefix, route_map_object_t type,</a>
<a name="ln1259">		  void *object)</a>
<a name="ln1260">{</a>
<a name="ln1261">  struct rmap_value *rv;</a>
<a name="ln1262">  struct bgp_info *bgp_info;</a>
<a name="ln1263">  u_int32_t weight;</a>
<a name="ln1264"> </a>
<a name="ln1265">  if (type == RMAP_BGP)</a>
<a name="ln1266">    {</a>
<a name="ln1267">      /* Fetch routemap's rule information. */</a>
<a name="ln1268">      rv = rule;</a>
<a name="ln1269">      bgp_info = object;</a>
<a name="ln1270">    </a>
<a name="ln1271">      /* Set weight value. */ </a>
<a name="ln1272">      weight = route_value_adjust(rv, 0, bgp_info-&gt;peer);</a>
<a name="ln1273">      if (weight)</a>
<a name="ln1274">        (bgp_attr_extra_get (bgp_info-&gt;attr))-&gt;weight = weight;</a>
<a name="ln1275">      else if (bgp_info-&gt;attr-&gt;extra)</a>
<a name="ln1276">        bgp_info-&gt;attr-&gt;extra-&gt;weight = 0;</a>
<a name="ln1277">    }</a>
<a name="ln1278"> </a>
<a name="ln1279">  return RMAP_OKAY;</a>
<a name="ln1280">}</a>
<a name="ln1281"> </a>
<a name="ln1282">/* Set local preference rule structure. */</a>
<a name="ln1283">struct route_map_rule_cmd route_set_weight_cmd = </a>
<a name="ln1284">{</a>
<a name="ln1285">  &quot;weight&quot;,</a>
<a name="ln1286">  route_set_weight,</a>
<a name="ln1287">  route_value_compile,</a>
<a name="ln1288">  route_value_free,</a>
<a name="ln1289">};</a>
<a name="ln1290"> </a>
<a name="ln1291">/* `set metric METRIC' */</a>
<a name="ln1292"> </a>
<a name="ln1293">/* Set metric to attribute. */</a>
<a name="ln1294">static route_map_result_t</a>
<a name="ln1295">route_set_metric (void *rule, struct prefix *prefix, </a>
<a name="ln1296">		  route_map_object_t type, void *object)</a>
<a name="ln1297">{</a>
<a name="ln1298">  struct rmap_value *rv;</a>
<a name="ln1299">  struct bgp_info *bgp_info;</a>
<a name="ln1300">  u_int32_t med = 0;</a>
<a name="ln1301"> </a>
<a name="ln1302">  if (type == RMAP_BGP)</a>
<a name="ln1303">    {</a>
<a name="ln1304">      /* Fetch routemap's rule information. */</a>
<a name="ln1305">      rv = rule;</a>
<a name="ln1306">      bgp_info = object;</a>
<a name="ln1307"> </a>
<a name="ln1308">      if (bgp_info-&gt;attr-&gt;flag &amp; ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC))</a>
<a name="ln1309">	med = bgp_info-&gt;attr-&gt;med;</a>
<a name="ln1310"> </a>
<a name="ln1311">      bgp_info-&gt;attr-&gt;med = route_value_adjust(rv, med, bgp_info-&gt;peer);</a>
<a name="ln1312">      bgp_info-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_MULTI_EXIT_DISC);</a>
<a name="ln1313">    }</a>
<a name="ln1314">  return RMAP_OKAY;</a>
<a name="ln1315">}</a>
<a name="ln1316"> </a>
<a name="ln1317">/* Set metric rule structure. */</a>
<a name="ln1318">struct route_map_rule_cmd route_set_metric_cmd = </a>
<a name="ln1319">{</a>
<a name="ln1320">  &quot;metric&quot;,</a>
<a name="ln1321">  route_set_metric,</a>
<a name="ln1322">  route_value_compile,</a>
<a name="ln1323">  route_value_free,</a>
<a name="ln1324">};</a>
<a name="ln1325"> </a>
<a name="ln1326">/* `set as-path prepend ASPATH' */</a>
<a name="ln1327"> </a>
<a name="ln1328">/* For AS path prepend mechanism. */</a>
<a name="ln1329">static route_map_result_t</a>
<a name="ln1330">route_set_aspath_prepend (void *rule, struct prefix *prefix, route_map_object_t type, void *object)</a>
<a name="ln1331">{</a>
<a name="ln1332">  struct aspath *aspath;</a>
<a name="ln1333">  struct aspath *new;</a>
<a name="ln1334">  struct bgp_info *binfo;</a>
<a name="ln1335"> </a>
<a name="ln1336">  if (type == RMAP_BGP)</a>
<a name="ln1337">    {</a>
<a name="ln1338">      binfo = object;</a>
<a name="ln1339">    </a>
<a name="ln1340">      if (binfo-&gt;attr-&gt;aspath-&gt;refcnt)</a>
<a name="ln1341">	new = aspath_dup (binfo-&gt;attr-&gt;aspath);</a>
<a name="ln1342">      else</a>
<a name="ln1343">	new = binfo-&gt;attr-&gt;aspath;</a>
<a name="ln1344"> </a>
<a name="ln1345">      if ((uintptr_t)rule &gt; 10)</a>
<a name="ln1346">      {</a>
<a name="ln1347">	aspath = rule;</a>
<a name="ln1348">	aspath_prepend (aspath, new);</a>
<a name="ln1349">      }</a>
<a name="ln1350">      else</a>
<a name="ln1351">      {</a>
<a name="ln1352">	as_t as = aspath_leftmost(new);</a>
<a name="ln1353">	if (!as) as = binfo-&gt;peer-&gt;as;</a>
<a name="ln1354">	new = aspath_add_seq_n (new, as, (uintptr_t) rule);</a>
<a name="ln1355">      }</a>
<a name="ln1356"> </a>
<a name="ln1357">      binfo-&gt;attr-&gt;aspath = new;</a>
<a name="ln1358">    }</a>
<a name="ln1359"> </a>
<a name="ln1360">  return RMAP_OKAY;</a>
<a name="ln1361">}</a>
<a name="ln1362"> </a>
<a name="ln1363">static void *</a>
<a name="ln1364">route_set_aspath_prepend_compile (const char *arg)</a>
<a name="ln1365">{</a>
<a name="ln1366">  unsigned int num;</a>
<a name="ln1367"> </a>
<a name="ln1368">  if (sscanf(arg, &quot;last-as %u&quot;, &amp;num) == 1 &amp;&amp; num &gt; 0 &amp;&amp; num &lt; 10)</a>
<a name="ln1369">    return (void*)(uintptr_t)num;</a>
<a name="ln1370"> </a>
<a name="ln1371">  return route_aspath_compile(arg);</a>
<a name="ln1372">}</a>
<a name="ln1373"> </a>
<a name="ln1374">static void</a>
<a name="ln1375">route_set_aspath_prepend_free (void *rule)</a>
<a name="ln1376">{</a>
<a name="ln1377">  if ((uintptr_t)rule &gt; 10)</a>
<a name="ln1378">    route_aspath_free(rule);</a>
<a name="ln1379">}</a>
<a name="ln1380"> </a>
<a name="ln1381"> </a>
<a name="ln1382">/* Set as-path prepend rule structure. */</a>
<a name="ln1383">struct route_map_rule_cmd route_set_aspath_prepend_cmd = </a>
<a name="ln1384">{</a>
<a name="ln1385">  &quot;as-path prepend&quot;,</a>
<a name="ln1386">  route_set_aspath_prepend,</a>
<a name="ln1387">  route_set_aspath_prepend_compile,</a>
<a name="ln1388">  route_set_aspath_prepend_free,</a>
<a name="ln1389">};</a>
<a name="ln1390"> </a>
<a name="ln1391">/* `set as-path exclude ASn' */</a>
<a name="ln1392"> </a>
<a name="ln1393">/* For ASN exclude mechanism.</a>
<a name="ln1394"> * Iterate over ASns requested and filter them from the given AS_PATH one by one.</a>
<a name="ln1395"> * Make a deep copy of existing AS_PATH, but for the first ASn only.</a>
<a name="ln1396"> */</a>
<a name="ln1397">static route_map_result_t</a>
<a name="ln1398">route_set_aspath_exclude (void *rule, struct prefix *dummy, route_map_object_t type, void *object)</a>
<a name="ln1399">{</a>
<a name="ln1400">  struct aspath * new_path, * exclude_path;</a>
<a name="ln1401">  struct bgp_info *binfo;</a>
<a name="ln1402"> </a>
<a name="ln1403">  if (type == RMAP_BGP)</a>
<a name="ln1404">  {</a>
<a name="ln1405">    exclude_path = rule;</a>
<a name="ln1406">    binfo = object;</a>
<a name="ln1407">    if (binfo-&gt;attr-&gt;aspath-&gt;refcnt)</a>
<a name="ln1408">      new_path = aspath_dup (binfo-&gt;attr-&gt;aspath);</a>
<a name="ln1409">    else</a>
<a name="ln1410">      new_path = binfo-&gt;attr-&gt;aspath;</a>
<a name="ln1411">    binfo-&gt;attr-&gt;aspath = aspath_filter_exclude (new_path, exclude_path);</a>
<a name="ln1412">  }</a>
<a name="ln1413">  return RMAP_OKAY;</a>
<a name="ln1414">}</a>
<a name="ln1415"> </a>
<a name="ln1416">/* Set ASn exlude rule structure. */</a>
<a name="ln1417">struct route_map_rule_cmd route_set_aspath_exclude_cmd = </a>
<a name="ln1418">{</a>
<a name="ln1419">  &quot;as-path exclude&quot;,</a>
<a name="ln1420">  route_set_aspath_exclude,</a>
<a name="ln1421">  route_aspath_compile,</a>
<a name="ln1422">  route_aspath_free,</a>
<a name="ln1423">};</a>
<a name="ln1424"> </a>
<a name="ln1425">/* `set community COMMUNITY' */</a>
<a name="ln1426">struct rmap_com_set</a>
<a name="ln1427">{</a>
<a name="ln1428">  struct community *com;</a>
<a name="ln1429">  int additive;</a>
<a name="ln1430">  int none;</a>
<a name="ln1431">};</a>
<a name="ln1432"> </a>
<a name="ln1433">/* For community set mechanism. */</a>
<a name="ln1434">static route_map_result_t</a>
<a name="ln1435">route_set_community (void *rule, struct prefix *prefix,</a>
<a name="ln1436">		     route_map_object_t type, void *object)</a>
<a name="ln1437">{</a>
<a name="ln1438">  struct rmap_com_set *rcs;</a>
<a name="ln1439">  struct bgp_info *binfo;</a>
<a name="ln1440">  struct attr *attr;</a>
<a name="ln1441">  struct community *new = NULL;</a>
<a name="ln1442">  struct community *old;</a>
<a name="ln1443">  struct community *merge;</a>
<a name="ln1444">  </a>
<a name="ln1445">  if (type == RMAP_BGP)</a>
<a name="ln1446">    {</a>
<a name="ln1447">      rcs = rule;</a>
<a name="ln1448">      binfo = object;</a>
<a name="ln1449">      attr = binfo-&gt;attr;</a>
<a name="ln1450">      old = attr-&gt;community;</a>
<a name="ln1451"> </a>
<a name="ln1452">      /* &quot;none&quot; case.  */</a>
<a name="ln1453">      if (rcs-&gt;none)</a>
<a name="ln1454">	{</a>
<a name="ln1455">	  attr-&gt;flag &amp;= ~(ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES));</a>
<a name="ln1456">	  attr-&gt;community = NULL;</a>
<a name="ln1457">	  /* See the longer comment down below. */</a>
<a name="ln1458">	  if (old &amp;&amp; old-&gt;refcnt == 0)</a>
<a name="ln1459">	    community_free(old);</a>
<a name="ln1460">	  return RMAP_OKAY;</a>
<a name="ln1461">	}</a>
<a name="ln1462"> </a>
<a name="ln1463">      /* &quot;additive&quot; case.  */</a>
<a name="ln1464">      if (rcs-&gt;additive &amp;&amp; old)</a>
<a name="ln1465">	{</a>
<a name="ln1466">	  merge = community_merge (community_dup (old), rcs-&gt;com);</a>
<a name="ln1467">	  </a>
<a name="ln1468">	  /* HACK: if the old community is not intern'd, </a>
<a name="ln1469">           * we should free it here, or all reference to it may be lost.</a>
<a name="ln1470">           * Really need to cleanup attribute caching sometime.</a>
<a name="ln1471">           */</a>
<a name="ln1472">	  if (old-&gt;refcnt == 0)</a>
<a name="ln1473">	    community_free (old);</a>
<a name="ln1474">	  new = community_uniq_sort (merge);</a>
<a name="ln1475">	  community_free (merge);</a>
<a name="ln1476">	}</a>
<a name="ln1477">      else</a>
<a name="ln1478">	new = community_dup (rcs-&gt;com);</a>
<a name="ln1479">      </a>
<a name="ln1480">      /* will be interned by caller if required */</a>
<a name="ln1481">      attr-&gt;community = new;</a>
<a name="ln1482"> </a>
<a name="ln1483">      attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);</a>
<a name="ln1484">    }</a>
<a name="ln1485"> </a>
<a name="ln1486">  return RMAP_OKAY;</a>
<a name="ln1487">}</a>
<a name="ln1488"> </a>
<a name="ln1489">/* Compile function for set community. */</a>
<a name="ln1490">static void *</a>
<a name="ln1491">route_set_community_compile (const char *arg)</a>
<a name="ln1492">{</a>
<a name="ln1493">  struct rmap_com_set *rcs;</a>
<a name="ln1494">  struct community *com = NULL;</a>
<a name="ln1495">  char *sp;</a>
<a name="ln1496">  int additive = 0;</a>
<a name="ln1497">  int none = 0;</a>
<a name="ln1498">  </a>
<a name="ln1499">  if (strcmp (arg, &quot;none&quot;) == 0)</a>
<a name="ln1500">    none = 1;</a>
<a name="ln1501">  else</a>
<a name="ln1502">    {</a>
<a name="ln1503">      sp = strstr (arg, &quot;additive&quot;);</a>
<a name="ln1504"> </a>
<a name="ln1505">      if (sp &amp;&amp; sp &gt; arg)</a>
<a name="ln1506">  	{</a>
<a name="ln1507">	  /* &quot;additive&quot; keyworkd is included.  */</a>
<a name="ln1508">	  additive = 1;</a>
<a name="ln1509">	  *(sp - 1) = '\0';</a>
<a name="ln1510">	}</a>
<a name="ln1511"> </a>
<a name="ln1512">      com = community_str2com (arg);</a>
<a name="ln1513"> </a>
<a name="ln1514">      if (additive)</a>
<a name="ln1515">	*(sp - 1) = ' ';</a>
<a name="ln1516"> </a>
<a name="ln1517">      if (! com)</a>
<a name="ln1518">	return NULL;</a>
<a name="ln1519">    }</a>
<a name="ln1520">  </a>
<a name="ln1521">  rcs = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct rmap_com_set));</a>
<a name="ln1522">  rcs-&gt;com = com;</a>
<a name="ln1523">  rcs-&gt;additive = additive;</a>
<a name="ln1524">  rcs-&gt;none = none;</a>
<a name="ln1525">  </a>
<a name="ln1526">  return rcs;</a>
<a name="ln1527">}</a>
<a name="ln1528"> </a>
<a name="ln1529">/* Free function for set community. */</a>
<a name="ln1530">static void</a>
<a name="ln1531">route_set_community_free (void *rule)</a>
<a name="ln1532">{</a>
<a name="ln1533">  struct rmap_com_set *rcs = rule;</a>
<a name="ln1534"> </a>
<a name="ln1535">  if (rcs-&gt;com)</a>
<a name="ln1536">    community_free (rcs-&gt;com);</a>
<a name="ln1537">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rcs);</a>
<a name="ln1538">}</a>
<a name="ln1539"> </a>
<a name="ln1540">/* Set community rule structure. */</a>
<a name="ln1541">struct route_map_rule_cmd route_set_community_cmd = </a>
<a name="ln1542">{</a>
<a name="ln1543">  &quot;community&quot;,</a>
<a name="ln1544">  route_set_community,</a>
<a name="ln1545">  route_set_community_compile,</a>
<a name="ln1546">  route_set_community_free,</a>
<a name="ln1547">};</a>
<a name="ln1548"> </a>
<a name="ln1549">/* `set community COMMUNITY' */</a>
<a name="ln1550">struct rmap_lcom_set</a>
<a name="ln1551">{</a>
<a name="ln1552">  struct lcommunity *lcom;</a>
<a name="ln1553">  int additive;</a>
<a name="ln1554">  int none;</a>
<a name="ln1555">};</a>
<a name="ln1556"> </a>
<a name="ln1557"> </a>
<a name="ln1558">/* For lcommunity set mechanism. */</a>
<a name="ln1559">static route_map_result_t</a>
<a name="ln1560">route_set_lcommunity (void *rule, struct prefix *prefix,</a>
<a name="ln1561">		     route_map_object_t type, void *object)</a>
<a name="ln1562">{</a>
<a name="ln1563">  struct rmap_lcom_set *rcs;</a>
<a name="ln1564">  struct bgp_info *binfo;</a>
<a name="ln1565">  struct attr *attr;</a>
<a name="ln1566">  struct lcommunity *new = NULL;</a>
<a name="ln1567">  struct lcommunity *old;</a>
<a name="ln1568">  struct lcommunity *merge;</a>
<a name="ln1569"> </a>
<a name="ln1570">  if (type == RMAP_BGP)</a>
<a name="ln1571">    {</a>
<a name="ln1572">      rcs = rule;</a>
<a name="ln1573">      binfo = object;</a>
<a name="ln1574">      attr = binfo-&gt;attr;</a>
<a name="ln1575">      old = (attr-&gt;extra) ? attr-&gt;extra-&gt;lcommunity : NULL;</a>
<a name="ln1576"> </a>
<a name="ln1577">      /* &quot;none&quot; case.  */</a>
<a name="ln1578">      if (rcs-&gt;none)</a>
<a name="ln1579">	{</a>
<a name="ln1580">	  attr-&gt;flag &amp;= ~(ATTR_FLAG_BIT (BGP_ATTR_LARGE_COMMUNITIES));</a>
<a name="ln1581">	  if (attr-&gt;extra) {</a>
<a name="ln1582">	    attr-&gt;extra-&gt;lcommunity = NULL;</a>
<a name="ln1583">	  }</a>
<a name="ln1584">	  /* See the longer comment down below. */</a>
<a name="ln1585">	  if (old &amp;&amp; old-&gt;refcnt == 0)</a>
<a name="ln1586">	    lcommunity_free(&amp;old);</a>
<a name="ln1587">	  return RMAP_OKAY;</a>
<a name="ln1588">	}</a>
<a name="ln1589"> </a>
<a name="ln1590">      if (rcs-&gt;additive &amp;&amp; old)</a>
<a name="ln1591">	{</a>
<a name="ln1592">	  merge = lcommunity_merge (lcommunity_dup (old), rcs-&gt;lcom);</a>
<a name="ln1593"> </a>
<a name="ln1594">	  /* HACK: if the old large-community is not intern'd,</a>
<a name="ln1595">           * we should free it here, or all reference to it may be lost.</a>
<a name="ln1596">           * Really need to cleanup attribute caching sometime.</a>
<a name="ln1597">           */</a>
<a name="ln1598">	  if (old-&gt;refcnt == 0)</a>
<a name="ln1599">	    lcommunity_free (&amp;old);</a>
<a name="ln1600">	  new = lcommunity_uniq_sort (merge);</a>
<a name="ln1601">	  lcommunity_free (&amp;merge);</a>
<a name="ln1602">	}</a>
<a name="ln1603">      else</a>
<a name="ln1604">        {</a>
<a name="ln1605">          new = lcommunity_dup (rcs-&gt;lcom);</a>
<a name="ln1606">        }</a>
<a name="ln1607"> </a>
<a name="ln1608">      /* will be interned by caller if required */</a>
<a name="ln1609">      bgp_attr_extra_get (attr)-&gt;lcommunity = new;</a>
<a name="ln1610">      attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_LARGE_COMMUNITIES);</a>
<a name="ln1611">    }</a>
<a name="ln1612"> </a>
<a name="ln1613">  return RMAP_OKAY;</a>
<a name="ln1614">}</a>
<a name="ln1615"> </a>
<a name="ln1616">/* Compile function for set community. */</a>
<a name="ln1617">static void *</a>
<a name="ln1618">route_set_lcommunity_compile (const char *arg)</a>
<a name="ln1619">{</a>
<a name="ln1620">  struct rmap_lcom_set *rcs;</a>
<a name="ln1621">  struct lcommunity *lcom = NULL;</a>
<a name="ln1622">  char *sp;</a>
<a name="ln1623">  int additive = 0;</a>
<a name="ln1624">  int none = 0;</a>
<a name="ln1625"> </a>
<a name="ln1626">  if (strcmp (arg, &quot;none&quot;) == 0)</a>
<a name="ln1627">    none = 1;</a>
<a name="ln1628">  else</a>
<a name="ln1629">    {</a>
<a name="ln1630">      sp = strstr (arg, &quot;additive&quot;);</a>
<a name="ln1631"> </a>
<a name="ln1632">      if (sp &amp;&amp; sp &gt; arg)</a>
<a name="ln1633">	{</a>
<a name="ln1634">	  /* &quot;additive&quot; keyworkd is included.  */</a>
<a name="ln1635">	  additive = 1;</a>
<a name="ln1636">	  *(sp - 1) = '\0';</a>
<a name="ln1637">	}</a>
<a name="ln1638"> </a>
<a name="ln1639">      lcom = lcommunity_str2com (arg);</a>
<a name="ln1640"> </a>
<a name="ln1641">     if (additive)</a>
<a name="ln1642">	*(sp - 1) = ' ';</a>
<a name="ln1643"> </a>
<a name="ln1644">     if (! lcom)</a>
<a name="ln1645">	return NULL;</a>
<a name="ln1646">    }</a>
<a name="ln1647"> </a>
<a name="ln1648">  rcs = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct rmap_com_set));</a>
<a name="ln1649">  rcs-&gt;lcom = lcom;</a>
<a name="ln1650">  rcs-&gt;additive = additive;</a>
<a name="ln1651">  rcs-&gt;none = none;</a>
<a name="ln1652"> </a>
<a name="ln1653">  return rcs;</a>
<a name="ln1654">}</a>
<a name="ln1655"> </a>
<a name="ln1656">/* Free function for set lcommunity. */</a>
<a name="ln1657">static void</a>
<a name="ln1658">route_set_lcommunity_free (void *rule)</a>
<a name="ln1659">{</a>
<a name="ln1660">  struct rmap_lcom_set *rcs = rule;</a>
<a name="ln1661"> </a>
<a name="ln1662">  if (rcs-&gt;lcom) {</a>
<a name="ln1663">    lcommunity_free (&amp;rcs-&gt;lcom);</a>
<a name="ln1664">  }</a>
<a name="ln1665">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rcs);</a>
<a name="ln1666">}</a>
<a name="ln1667"> </a>
<a name="ln1668">/* Set community rule structure. */</a>
<a name="ln1669">struct route_map_rule_cmd route_set_lcommunity_cmd =</a>
<a name="ln1670">{</a>
<a name="ln1671">  &quot;large-community&quot;,</a>
<a name="ln1672">  route_set_lcommunity,</a>
<a name="ln1673">  route_set_lcommunity_compile,</a>
<a name="ln1674">  route_set_lcommunity_free,</a>
<a name="ln1675">};</a>
<a name="ln1676"> </a>
<a name="ln1677">/* `set large-comm-list (&lt;1-99&gt;|&lt;100-500&gt;|WORD) delete' */</a>
<a name="ln1678"> </a>
<a name="ln1679">/* For large community set mechanism. */</a>
<a name="ln1680">static route_map_result_t</a>
<a name="ln1681">route_set_lcommunity_delete (void *rule, struct prefix *prefix,</a>
<a name="ln1682">			     route_map_object_t type, void *object)</a>
<a name="ln1683">{</a>
<a name="ln1684">  struct community_list *list;</a>
<a name="ln1685">  struct lcommunity *merge;</a>
<a name="ln1686">  struct lcommunity *new;</a>
<a name="ln1687">  struct lcommunity *old;</a>
<a name="ln1688">  struct bgp_info *binfo;</a>
<a name="ln1689"> </a>
<a name="ln1690">  if (type == RMAP_BGP)</a>
<a name="ln1691">    {</a>
<a name="ln1692">      if (! rule)</a>
<a name="ln1693">	return RMAP_OKAY;</a>
<a name="ln1694"> </a>
<a name="ln1695">      binfo = object;</a>
<a name="ln1696">      list = community_list_lookup (bgp_clist, rule,</a>
<a name="ln1697">				    LARGE_COMMUNITY_LIST_MASTER);</a>
<a name="ln1698">      old = ((binfo-&gt;attr-&gt;extra) ? binfo-&gt;attr-&gt;extra-&gt;lcommunity : NULL);</a>
<a name="ln1699"> </a>
<a name="ln1700">      if (list &amp;&amp; old)</a>
<a name="ln1701">	{</a>
<a name="ln1702">	  merge = lcommunity_list_match_delete (lcommunity_dup (old), list);</a>
<a name="ln1703">	  new = lcommunity_uniq_sort (merge);</a>
<a name="ln1704">	  lcommunity_free (&amp;merge);</a>
<a name="ln1705"> </a>
<a name="ln1706">	  /* HACK: if the old community is not intern'd,</a>
<a name="ln1707">	   * we should free it here, or all reference to it may be lost.</a>
<a name="ln1708">	   * Really need to cleanup attribute caching sometime.</a>
<a name="ln1709">	   */</a>
<a name="ln1710">	  if (old-&gt;refcnt == 0)</a>
<a name="ln1711">	    lcommunity_free (&amp;old);</a>
<a name="ln1712"> </a>
<a name="ln1713">	  if (new-&gt;size == 0)</a>
<a name="ln1714">	    {</a>
<a name="ln1715">	      binfo-&gt;attr-&gt;extra-&gt;lcommunity = NULL;</a>
<a name="ln1716">	      binfo-&gt;attr-&gt;flag &amp;= ~ATTR_FLAG_BIT (BGP_ATTR_LARGE_COMMUNITIES);</a>
<a name="ln1717">	      lcommunity_free (&amp;new);</a>
<a name="ln1718">	    }</a>
<a name="ln1719">	  else</a>
<a name="ln1720">	    {</a>
<a name="ln1721">	      binfo-&gt;attr-&gt;extra-&gt;lcommunity = new;</a>
<a name="ln1722">	      binfo-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_LARGE_COMMUNITIES);</a>
<a name="ln1723">	    }</a>
<a name="ln1724">	}</a>
<a name="ln1725">    }</a>
<a name="ln1726"> </a>
<a name="ln1727">  return RMAP_OKAY;</a>
<a name="ln1728">}</a>
<a name="ln1729"> </a>
<a name="ln1730">/* Compile function for set lcommunity. */</a>
<a name="ln1731">static void *</a>
<a name="ln1732">route_set_lcommunity_delete_compile (const char *arg)</a>
<a name="ln1733">{</a>
<a name="ln1734">  char *p;</a>
<a name="ln1735">  char *str;</a>
<a name="ln1736">  int len;</a>
<a name="ln1737"> </a>
<a name="ln1738">  p = strchr (arg, ' ');</a>
<a name="ln1739">  if (p)</a>
<a name="ln1740">    {</a>
<a name="ln1741">      len = p - arg;</a>
<a name="ln1742">      str = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, len + 1);</a>
<a name="ln1743">      memcpy (str, arg, len);</a>
<a name="ln1744">    }</a>
<a name="ln1745">  else</a>
<a name="ln1746">    str = NULL;</a>
<a name="ln1747"> </a>
<a name="ln1748">  return str;</a>
<a name="ln1749">}</a>
<a name="ln1750"> </a>
<a name="ln1751">/* Free function for set lcommunity. */</a>
<a name="ln1752">static void</a>
<a name="ln1753">route_set_lcommunity_delete_free (void *rule)</a>
<a name="ln1754">{</a>
<a name="ln1755">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln1756">}</a>
<a name="ln1757"> </a>
<a name="ln1758">/* Set lcommunity rule structure. */</a>
<a name="ln1759">struct route_map_rule_cmd route_set_lcommunity_delete_cmd =</a>
<a name="ln1760">{</a>
<a name="ln1761">  &quot;large-comm-list&quot;,</a>
<a name="ln1762">  route_set_lcommunity_delete,</a>
<a name="ln1763">  route_set_lcommunity_delete_compile,</a>
<a name="ln1764">  route_set_lcommunity_delete_free,</a>
<a name="ln1765">};</a>
<a name="ln1766"> </a>
<a name="ln1767"> </a>
<a name="ln1768">/* `set comm-list (&lt;1-99&gt;|&lt;100-500&gt;|WORD) delete' */</a>
<a name="ln1769"> </a>
<a name="ln1770">/* For community set mechanism. */</a>
<a name="ln1771">static route_map_result_t</a>
<a name="ln1772">route_set_community_delete (void *rule, struct prefix *prefix,</a>
<a name="ln1773">			    route_map_object_t type, void *object)</a>
<a name="ln1774">{</a>
<a name="ln1775">  struct community_list *list;</a>
<a name="ln1776">  struct community *merge;</a>
<a name="ln1777">  struct community *new;</a>
<a name="ln1778">  struct community *old;</a>
<a name="ln1779">  struct bgp_info *binfo;</a>
<a name="ln1780"> </a>
<a name="ln1781">  if (type == RMAP_BGP)</a>
<a name="ln1782">    {</a>
<a name="ln1783">      if (! rule)</a>
<a name="ln1784">	return RMAP_OKAY;</a>
<a name="ln1785"> </a>
<a name="ln1786">      binfo = object;</a>
<a name="ln1787">      list = community_list_lookup (bgp_clist, rule, COMMUNITY_LIST_MASTER);</a>
<a name="ln1788">      old = binfo-&gt;attr-&gt;community;</a>
<a name="ln1789"> </a>
<a name="ln1790">      if (list &amp;&amp; old)</a>
<a name="ln1791">	{</a>
<a name="ln1792">	  merge = community_list_match_delete (community_dup (old), list);</a>
<a name="ln1793">	  new = community_uniq_sort (merge);</a>
<a name="ln1794">	  community_free (merge);</a>
<a name="ln1795"> </a>
<a name="ln1796">	  /* HACK: if the old community is not intern'd,</a>
<a name="ln1797">	   * we should free it here, or all reference to it may be lost.</a>
<a name="ln1798">	   * Really need to cleanup attribute caching sometime.</a>
<a name="ln1799">	   */</a>
<a name="ln1800">	  if (old-&gt;refcnt == 0)</a>
<a name="ln1801">	    community_free (old);</a>
<a name="ln1802"> </a>
<a name="ln1803">	  if (new-&gt;size == 0)</a>
<a name="ln1804">	    {</a>
<a name="ln1805">	      binfo-&gt;attr-&gt;community = NULL;</a>
<a name="ln1806">	      binfo-&gt;attr-&gt;flag &amp;= ~ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);</a>
<a name="ln1807">	      community_free (new);</a>
<a name="ln1808">	    }</a>
<a name="ln1809">	  else</a>
<a name="ln1810">	    {</a>
<a name="ln1811">	      binfo-&gt;attr-&gt;community = new;</a>
<a name="ln1812">	      binfo-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);</a>
<a name="ln1813">	    }</a>
<a name="ln1814">	}</a>
<a name="ln1815">    }</a>
<a name="ln1816"> </a>
<a name="ln1817">  return RMAP_OKAY;</a>
<a name="ln1818">}</a>
<a name="ln1819"> </a>
<a name="ln1820">/* Compile function for set community. */</a>
<a name="ln1821">static void *</a>
<a name="ln1822">route_set_community_delete_compile (const char *arg)</a>
<a name="ln1823">{</a>
<a name="ln1824">  char *p;</a>
<a name="ln1825">  char *str;</a>
<a name="ln1826">  int len;</a>
<a name="ln1827"> </a>
<a name="ln1828">  p = strchr (arg, ' ');</a>
<a name="ln1829">  if (p)</a>
<a name="ln1830">    {</a>
<a name="ln1831">      len = p - arg;</a>
<a name="ln1832">      str = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, len + 1);</a>
<a name="ln1833">      memcpy (str, arg, len);</a>
<a name="ln1834">    }</a>
<a name="ln1835">  else</a>
<a name="ln1836">    str = NULL;</a>
<a name="ln1837"> </a>
<a name="ln1838">  return str;</a>
<a name="ln1839">}</a>
<a name="ln1840"> </a>
<a name="ln1841">/* Free function for set community. */</a>
<a name="ln1842">static void</a>
<a name="ln1843">route_set_community_delete_free (void *rule)</a>
<a name="ln1844">{</a>
<a name="ln1845">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln1846">}</a>
<a name="ln1847"> </a>
<a name="ln1848">/* Set community rule structure. */</a>
<a name="ln1849">struct route_map_rule_cmd route_set_community_delete_cmd =</a>
<a name="ln1850">{</a>
<a name="ln1851">  &quot;comm-list&quot;,</a>
<a name="ln1852">  route_set_community_delete,</a>
<a name="ln1853">  route_set_community_delete_compile,</a>
<a name="ln1854">  route_set_community_delete_free,</a>
<a name="ln1855">};</a>
<a name="ln1856"> </a>
<a name="ln1857">/* `set extcommunity rt COMMUNITY' */</a>
<a name="ln1858"> </a>
<a name="ln1859">/* For community set mechanism.  Used by _rt and _soo. */</a>
<a name="ln1860">static route_map_result_t</a>
<a name="ln1861">route_set_ecommunity (void *rule, struct prefix *prefix,</a>
<a name="ln1862">		      route_map_object_t type, void *object)</a>
<a name="ln1863">{</a>
<a name="ln1864">  struct ecommunity *ecom;</a>
<a name="ln1865">  struct ecommunity *new_ecom;</a>
<a name="ln1866">  struct ecommunity *old_ecom;</a>
<a name="ln1867">  struct bgp_info *bgp_info;</a>
<a name="ln1868"> </a>
<a name="ln1869">  if (type == RMAP_BGP)</a>
<a name="ln1870">    {</a>
<a name="ln1871">      ecom = rule;</a>
<a name="ln1872">      bgp_info = object;</a>
<a name="ln1873">    </a>
<a name="ln1874">      if (! ecom)</a>
<a name="ln1875">	return RMAP_OKAY;</a>
<a name="ln1876">    </a>
<a name="ln1877">      /* We assume additive for Extended Community. */</a>
<a name="ln1878">      old_ecom = (bgp_attr_extra_get (bgp_info-&gt;attr))-&gt;ecommunity;</a>
<a name="ln1879"> </a>
<a name="ln1880">      if (old_ecom)</a>
<a name="ln1881">	{</a>
<a name="ln1882">	  new_ecom = ecommunity_merge (ecommunity_dup (old_ecom), ecom);</a>
<a name="ln1883"> </a>
<a name="ln1884">	  /* old_ecom-&gt;refcnt = 1 =&gt; owned elsewhere, e.g. bgp_update_receive()</a>
<a name="ln1885">	   *         -&gt;refcnt = 0 =&gt; set by a previous route-map statement */</a>
<a name="ln1886">	  if (!old_ecom-&gt;refcnt)</a>
<a name="ln1887">	    ecommunity_free (&amp;old_ecom);</a>
<a name="ln1888">	}</a>
<a name="ln1889">      else</a>
<a name="ln1890">	new_ecom = ecommunity_dup (ecom);</a>
<a name="ln1891"> </a>
<a name="ln1892">      /* will be intern()'d or attr_flush()'d by bgp_update_main() */</a>
<a name="ln1893">      bgp_info-&gt;attr-&gt;extra-&gt;ecommunity = new_ecom;</a>
<a name="ln1894"> </a>
<a name="ln1895">      bgp_info-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);</a>
<a name="ln1896">    }</a>
<a name="ln1897">  return RMAP_OKAY;</a>
<a name="ln1898">}</a>
<a name="ln1899"> </a>
<a name="ln1900">/* Compile function for set community. */</a>
<a name="ln1901">static void *</a>
<a name="ln1902">route_set_ecommunity_rt_compile (const char *arg)</a>
<a name="ln1903">{</a>
<a name="ln1904">  struct ecommunity *ecom;</a>
<a name="ln1905"> </a>
<a name="ln1906">  ecom = ecommunity_str2com (arg, ECOMMUNITY_ROUTE_TARGET, 0);</a>
<a name="ln1907">  if (! ecom)</a>
<a name="ln1908">    return NULL;</a>
<a name="ln1909">  return ecommunity_intern (ecom);</a>
<a name="ln1910">}</a>
<a name="ln1911"> </a>
<a name="ln1912">/* Free function for set community.  Used by _rt and _soo */</a>
<a name="ln1913">static void</a>
<a name="ln1914">route_set_ecommunity_free (void *rule)</a>
<a name="ln1915">{</a>
<a name="ln1916">  struct ecommunity *ecom = rule;</a>
<a name="ln1917">  ecommunity_unintern (&amp;ecom);</a>
<a name="ln1918">}</a>
<a name="ln1919"> </a>
<a name="ln1920">/* Set community rule structure. */</a>
<a name="ln1921">struct route_map_rule_cmd route_set_ecommunity_rt_cmd = </a>
<a name="ln1922">{</a>
<a name="ln1923">  &quot;extcommunity rt&quot;,</a>
<a name="ln1924">  route_set_ecommunity,</a>
<a name="ln1925">  route_set_ecommunity_rt_compile,</a>
<a name="ln1926">  route_set_ecommunity_free,</a>
<a name="ln1927">};</a>
<a name="ln1928"> </a>
<a name="ln1929">/* `set extcommunity soo COMMUNITY' */</a>
<a name="ln1930"> </a>
<a name="ln1931">/* Compile function for set community. */</a>
<a name="ln1932">static void *</a>
<a name="ln1933">route_set_ecommunity_soo_compile (const char *arg)</a>
<a name="ln1934">{</a>
<a name="ln1935">  struct ecommunity *ecom;</a>
<a name="ln1936"> </a>
<a name="ln1937">  ecom = ecommunity_str2com (arg, ECOMMUNITY_SITE_ORIGIN, 0);</a>
<a name="ln1938">  if (! ecom)</a>
<a name="ln1939">    return NULL;</a>
<a name="ln1940">  </a>
<a name="ln1941">  return ecommunity_intern (ecom);</a>
<a name="ln1942">}</a>
<a name="ln1943"> </a>
<a name="ln1944">/* Set community rule structure. */</a>
<a name="ln1945">struct route_map_rule_cmd route_set_ecommunity_soo_cmd = </a>
<a name="ln1946">{</a>
<a name="ln1947">  &quot;extcommunity soo&quot;,</a>
<a name="ln1948">  route_set_ecommunity,</a>
<a name="ln1949">  route_set_ecommunity_soo_compile,</a>
<a name="ln1950">  route_set_ecommunity_free,</a>
<a name="ln1951">};</a>
<a name="ln1952"> </a>
<a name="ln1953">/* `set origin ORIGIN' */</a>
<a name="ln1954"> </a>
<a name="ln1955">/* For origin set. */</a>
<a name="ln1956">static route_map_result_t</a>
<a name="ln1957">route_set_origin (void *rule, struct prefix *prefix, route_map_object_t type, void *object)</a>
<a name="ln1958">{</a>
<a name="ln1959">  u_char *origin;</a>
<a name="ln1960">  struct bgp_info *bgp_info;</a>
<a name="ln1961"> </a>
<a name="ln1962">  if (type == RMAP_BGP)</a>
<a name="ln1963">    {</a>
<a name="ln1964">      origin = rule;</a>
<a name="ln1965">      bgp_info = object;</a>
<a name="ln1966">    </a>
<a name="ln1967">      bgp_info-&gt;attr-&gt;origin = *origin;</a>
<a name="ln1968">    }</a>
<a name="ln1969"> </a>
<a name="ln1970">  return RMAP_OKAY;</a>
<a name="ln1971">}</a>
<a name="ln1972"> </a>
<a name="ln1973">/* Compile function for origin set. */</a>
<a name="ln1974">static void *</a>
<a name="ln1975">route_set_origin_compile (const char *arg)</a>
<a name="ln1976">{</a>
<a name="ln1977">  u_char *origin;</a>
<a name="ln1978"> </a>
<a name="ln1979">  origin = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (u_char));</a>
<a name="ln1980"> </a>
<a name="ln1981">  if (strcmp (arg, &quot;igp&quot;) == 0)</a>
<a name="ln1982">    *origin = 0;</a>
<a name="ln1983">  else if (strcmp (arg, &quot;egp&quot;) == 0)</a>
<a name="ln1984">    *origin = 1;</a>
<a name="ln1985">  else</a>
<a name="ln1986">    *origin = 2;</a>
<a name="ln1987"> </a>
<a name="ln1988">  return origin;</a>
<a name="ln1989">}</a>
<a name="ln1990"> </a>
<a name="ln1991">/* Compile function for origin set. */</a>
<a name="ln1992">static void</a>
<a name="ln1993">route_set_origin_free (void *rule)</a>
<a name="ln1994">{</a>
<a name="ln1995">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln1996">}</a>
<a name="ln1997"> </a>
<a name="ln1998">/* Set origin rule structure. */</a>
<a name="ln1999">struct route_map_rule_cmd route_set_origin_cmd = </a>
<a name="ln2000">{</a>
<a name="ln2001">  &quot;origin&quot;,</a>
<a name="ln2002">  route_set_origin,</a>
<a name="ln2003">  route_set_origin_compile,</a>
<a name="ln2004">  route_set_origin_free,</a>
<a name="ln2005">};</a>
<a name="ln2006"> </a>
<a name="ln2007">/* `set atomic-aggregate' */</a>
<a name="ln2008"> </a>
<a name="ln2009">/* For atomic aggregate set. */</a>
<a name="ln2010">static route_map_result_t</a>
<a name="ln2011">route_set_atomic_aggregate (void *rule, struct prefix *prefix,</a>
<a name="ln2012">			    route_map_object_t type, void *object)</a>
<a name="ln2013">{</a>
<a name="ln2014">  struct bgp_info *bgp_info;</a>
<a name="ln2015"> </a>
<a name="ln2016">  if (type == RMAP_BGP)</a>
<a name="ln2017">    {</a>
<a name="ln2018">      bgp_info = object;</a>
<a name="ln2019">      bgp_info-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_ATOMIC_AGGREGATE);</a>
<a name="ln2020">    }</a>
<a name="ln2021"> </a>
<a name="ln2022">  return RMAP_OKAY;</a>
<a name="ln2023">}</a>
<a name="ln2024"> </a>
<a name="ln2025">/* Compile function for atomic aggregate. */</a>
<a name="ln2026">static void *</a>
<a name="ln2027">route_set_atomic_aggregate_compile (const char *arg)</a>
<a name="ln2028">{</a>
<a name="ln2029">  return (void *)1;</a>
<a name="ln2030">}</a>
<a name="ln2031"> </a>
<a name="ln2032">/* Compile function for atomic aggregate. */</a>
<a name="ln2033">static void</a>
<a name="ln2034">route_set_atomic_aggregate_free (void *rule)</a>
<a name="ln2035">{</a>
<a name="ln2036">  return;</a>
<a name="ln2037">}</a>
<a name="ln2038"> </a>
<a name="ln2039">/* Set atomic aggregate rule structure. */</a>
<a name="ln2040">struct route_map_rule_cmd route_set_atomic_aggregate_cmd = </a>
<a name="ln2041">{</a>
<a name="ln2042">  &quot;atomic-aggregate&quot;,</a>
<a name="ln2043">  route_set_atomic_aggregate,</a>
<a name="ln2044">  route_set_atomic_aggregate_compile,</a>
<a name="ln2045">  route_set_atomic_aggregate_free,</a>
<a name="ln2046">};</a>
<a name="ln2047"> </a>
<a name="ln2048">/* `set aggregator as AS A.B.C.D' */</a>
<a name="ln2049">struct aggregator</a>
<a name="ln2050">{</a>
<a name="ln2051">  as_t as;</a>
<a name="ln2052">  struct in_addr address;</a>
<a name="ln2053">};</a>
<a name="ln2054"> </a>
<a name="ln2055">static route_map_result_t</a>
<a name="ln2056">route_set_aggregator_as (void *rule, struct prefix *prefix, </a>
<a name="ln2057">			 route_map_object_t type, void *object)</a>
<a name="ln2058">{</a>
<a name="ln2059">  struct bgp_info *bgp_info;</a>
<a name="ln2060">  struct aggregator *aggregator;</a>
<a name="ln2061">  struct attr_extra *ae;</a>
<a name="ln2062"> </a>
<a name="ln2063">  if (type == RMAP_BGP)</a>
<a name="ln2064">    {</a>
<a name="ln2065">      bgp_info = object;</a>
<a name="ln2066">      aggregator = rule;</a>
<a name="ln2067">      ae = bgp_attr_extra_get (bgp_info-&gt;attr);</a>
<a name="ln2068">      </a>
<a name="ln2069">      ae-&gt;aggregator_as = aggregator-&gt;as;</a>
<a name="ln2070">      ae-&gt;aggregator_addr = aggregator-&gt;address;</a>
<a name="ln2071">      bgp_info-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_AGGREGATOR);</a>
<a name="ln2072">    }</a>
<a name="ln2073"> </a>
<a name="ln2074">  return RMAP_OKAY;</a>
<a name="ln2075">}</a>
<a name="ln2076"> </a>
<a name="ln2077">static void *</a>
<a name="ln2078">route_set_aggregator_as_compile (const char *arg)</a>
<a name="ln2079">{</a>
<a name="ln2080">  struct aggregator *aggregator;</a>
<a name="ln2081">  char as[10];</a>
<a name="ln2082">  char address[20];</a>
<a name="ln2083"> </a>
<a name="ln2084">  aggregator = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct aggregator));</a>
<a name="ln2085">  sscanf (arg, &quot;%s %s&quot;, as, address);</a>
<a name="ln2086"> </a>
<a name="ln2087">  aggregator-&gt;as = strtoul (as, NULL, 10);</a>
<a name="ln2088">  inet_aton (address, &amp;aggregator-&gt;address);</a>
<a name="ln2089"> </a>
<a name="ln2090">  return aggregator;</a>
<a name="ln2091">}</a>
<a name="ln2092"> </a>
<a name="ln2093">static void</a>
<a name="ln2094">route_set_aggregator_as_free (void *rule)</a>
<a name="ln2095">{</a>
<a name="ln2096">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln2097">}</a>
<a name="ln2098"> </a>
<a name="ln2099">struct route_map_rule_cmd route_set_aggregator_as_cmd = </a>
<a name="ln2100">{</a>
<a name="ln2101">  &quot;aggregator as&quot;,</a>
<a name="ln2102">  route_set_aggregator_as,</a>
<a name="ln2103">  route_set_aggregator_as_compile,</a>
<a name="ln2104">  route_set_aggregator_as_free,</a>
<a name="ln2105">};</a>
<a name="ln2106"> </a>
<a name="ln2107">/* Set tag to object. object must be pointer to struct bgp_info */</a>
<a name="ln2108">static route_map_result_t</a>
<a name="ln2109">route_set_tag (void *rule, struct prefix *prefix,</a>
<a name="ln2110">               route_map_object_t type, void *object)</a>
<a name="ln2111">{</a>
<a name="ln2112">  route_tag_t *tag;</a>
<a name="ln2113">  struct bgp_info *bgp_info;</a>
<a name="ln2114">  struct attr_extra *ae;</a>
<a name="ln2115"> </a>
<a name="ln2116">  if (type == RMAP_BGP)</a>
<a name="ln2117">    {</a>
<a name="ln2118">      tag = rule;</a>
<a name="ln2119">      bgp_info = object;</a>
<a name="ln2120">      ae = bgp_attr_extra_get (bgp_info-&gt;attr);</a>
<a name="ln2121"> </a>
<a name="ln2122">      /* Set tag value */</a>
<a name="ln2123">      ae-&gt;tag=*tag;</a>
<a name="ln2124"> </a>
<a name="ln2125">    }</a>
<a name="ln2126"> </a>
<a name="ln2127">  return RMAP_OKAY;</a>
<a name="ln2128">}</a>
<a name="ln2129"> </a>
<a name="ln2130">/* Route map commands for tag set. */</a>
<a name="ln2131">static struct route_map_rule_cmd route_set_tag_cmd =</a>
<a name="ln2132">{</a>
<a name="ln2133">  &quot;tag&quot;,</a>
<a name="ln2134">  route_set_tag,</a>
<a name="ln2135">  route_map_rule_tag_compile,</a>
<a name="ln2136">  route_map_rule_tag_free,</a>
<a name="ln2137">};</a>
<a name="ln2138"> </a>
<a name="ln2139"> </a>
<a name="ln2140">/* `match ipv6 address IP_ACCESS_LIST' */</a>
<a name="ln2141"> </a>
<a name="ln2142">static route_map_result_t</a>
<a name="ln2143">route_match_ipv6_address (void *rule, struct prefix *prefix, </a>
<a name="ln2144">			  route_map_object_t type, void *object)</a>
<a name="ln2145">{</a>
<a name="ln2146">  struct access_list *alist;</a>
<a name="ln2147"> </a>
<a name="ln2148">  if (type == RMAP_BGP)</a>
<a name="ln2149">    {</a>
<a name="ln2150">      alist = access_list_lookup (AFI_IP6, (char *) rule);</a>
<a name="ln2151">      if (alist == NULL)</a>
<a name="ln2152">	return RMAP_NOMATCH;</a>
<a name="ln2153">    </a>
<a name="ln2154">      return (access_list_apply (alist, prefix) == FILTER_DENY ?</a>
<a name="ln2155">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln2156">    }</a>
<a name="ln2157">  return RMAP_NOMATCH;</a>
<a name="ln2158">}</a>
<a name="ln2159"> </a>
<a name="ln2160">static void *</a>
<a name="ln2161">route_match_ipv6_address_compile (const char *arg)</a>
<a name="ln2162">{</a>
<a name="ln2163">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln2164">}</a>
<a name="ln2165"> </a>
<a name="ln2166">static void</a>
<a name="ln2167">route_match_ipv6_address_free (void *rule)</a>
<a name="ln2168">{</a>
<a name="ln2169">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln2170">}</a>
<a name="ln2171"> </a>
<a name="ln2172">/* Route map commands for ip address matching. */</a>
<a name="ln2173">struct route_map_rule_cmd route_match_ipv6_address_cmd =</a>
<a name="ln2174">{</a>
<a name="ln2175">  &quot;ipv6 address&quot;,</a>
<a name="ln2176">  route_match_ipv6_address,</a>
<a name="ln2177">  route_match_ipv6_address_compile,</a>
<a name="ln2178">  route_match_ipv6_address_free</a>
<a name="ln2179">};</a>
<a name="ln2180"> </a>
<a name="ln2181">/* `match ipv6 next-hop IP_ADDRESS' */</a>
<a name="ln2182"> </a>
<a name="ln2183">static route_map_result_t</a>
<a name="ln2184">route_match_ipv6_next_hop (void *rule, struct prefix *prefix, </a>
<a name="ln2185">			   route_map_object_t type, void *object)</a>
<a name="ln2186">{</a>
<a name="ln2187">  struct in6_addr *addr = rule;</a>
<a name="ln2188">  struct bgp_info *bgp_info;</a>
<a name="ln2189"> </a>
<a name="ln2190">  if (type == RMAP_BGP)</a>
<a name="ln2191">    {</a>
<a name="ln2192">      bgp_info = object;</a>
<a name="ln2193">      </a>
<a name="ln2194">      if (!bgp_info-&gt;attr-&gt;extra)</a>
<a name="ln2195">        return RMAP_NOMATCH;</a>
<a name="ln2196">      </a>
<a name="ln2197">      if (IPV6_ADDR_SAME (&amp;bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_global, addr))</a>
<a name="ln2198">	return RMAP_MATCH;</a>
<a name="ln2199"> </a>
<a name="ln2200">      if (bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_len == 32 &amp;&amp;</a>
<a name="ln2201">	  IPV6_ADDR_SAME (&amp;bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_local, addr))</a>
<a name="ln2202">	return RMAP_MATCH;</a>
<a name="ln2203"> </a>
<a name="ln2204">      return RMAP_NOMATCH;</a>
<a name="ln2205">    }</a>
<a name="ln2206"> </a>
<a name="ln2207">  return RMAP_NOMATCH;</a>
<a name="ln2208">}</a>
<a name="ln2209"> </a>
<a name="ln2210">static void *</a>
<a name="ln2211">route_match_ipv6_next_hop_compile (const char *arg)</a>
<a name="ln2212">{</a>
<a name="ln2213">  struct in6_addr *address;</a>
<a name="ln2214">  int ret;</a>
<a name="ln2215"> </a>
<a name="ln2216">  address = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in6_addr));</a>
<a name="ln2217"> </a>
<a name="ln2218">  ret = inet_pton (AF_INET6, arg, address);</a>
<a name="ln2219">  if (!ret)</a>
<a name="ln2220">    {</a>
<a name="ln2221">      XFREE (MTYPE_ROUTE_MAP_COMPILED, address);</a>
<a name="ln2222">      return NULL;</a>
<a name="ln2223">    }</a>
<a name="ln2224"> </a>
<a name="ln2225">  return address;</a>
<a name="ln2226">}</a>
<a name="ln2227"> </a>
<a name="ln2228">static void</a>
<a name="ln2229">route_match_ipv6_next_hop_free (void *rule)</a>
<a name="ln2230">{</a>
<a name="ln2231">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln2232">}</a>
<a name="ln2233"> </a>
<a name="ln2234">struct route_map_rule_cmd route_match_ipv6_next_hop_cmd =</a>
<a name="ln2235">{</a>
<a name="ln2236">  &quot;ipv6 next-hop&quot;,</a>
<a name="ln2237">  route_match_ipv6_next_hop,</a>
<a name="ln2238">  route_match_ipv6_next_hop_compile,</a>
<a name="ln2239">  route_match_ipv6_next_hop_free</a>
<a name="ln2240">};</a>
<a name="ln2241"> </a>
<a name="ln2242">/* `match ipv6 address prefix-list PREFIX_LIST' */</a>
<a name="ln2243"> </a>
<a name="ln2244">static route_map_result_t</a>
<a name="ln2245">route_match_ipv6_address_prefix_list (void *rule, struct prefix *prefix, </a>
<a name="ln2246">			      route_map_object_t type, void *object)</a>
<a name="ln2247">{</a>
<a name="ln2248">  struct prefix_list *plist;</a>
<a name="ln2249"> </a>
<a name="ln2250">  if (type == RMAP_BGP)</a>
<a name="ln2251">    {</a>
<a name="ln2252">      plist = prefix_list_lookup (AFI_IP6, (char *) rule);</a>
<a name="ln2253">      if (plist == NULL)</a>
<a name="ln2254">	return RMAP_NOMATCH;</a>
<a name="ln2255">    </a>
<a name="ln2256">      return (prefix_list_apply (plist, prefix) == PREFIX_DENY ?</a>
<a name="ln2257">	      RMAP_NOMATCH : RMAP_MATCH);</a>
<a name="ln2258">    }</a>
<a name="ln2259">  return RMAP_NOMATCH;</a>
<a name="ln2260">}</a>
<a name="ln2261"> </a>
<a name="ln2262">static void *</a>
<a name="ln2263">route_match_ipv6_address_prefix_list_compile (const char *arg)</a>
<a name="ln2264">{</a>
<a name="ln2265">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln2266">}</a>
<a name="ln2267"> </a>
<a name="ln2268">static void</a>
<a name="ln2269">route_match_ipv6_address_prefix_list_free (void *rule)</a>
<a name="ln2270">{</a>
<a name="ln2271">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln2272">}</a>
<a name="ln2273"> </a>
<a name="ln2274">struct route_map_rule_cmd route_match_ipv6_address_prefix_list_cmd =</a>
<a name="ln2275">{</a>
<a name="ln2276">  &quot;ipv6 address prefix-list&quot;,</a>
<a name="ln2277">  route_match_ipv6_address_prefix_list,</a>
<a name="ln2278">  route_match_ipv6_address_prefix_list_compile,</a>
<a name="ln2279">  route_match_ipv6_address_prefix_list_free</a>
<a name="ln2280">};</a>
<a name="ln2281"> </a>
<a name="ln2282">/* `set ipv6 nexthop global IP_ADDRESS' */</a>
<a name="ln2283"> </a>
<a name="ln2284">/* Set nexthop to object.  ojbect must be pointer to struct attr. */</a>
<a name="ln2285">static route_map_result_t</a>
<a name="ln2286">route_set_ipv6_nexthop_global (void *rule, struct prefix *prefix, </a>
<a name="ln2287">			       route_map_object_t type, void *object)</a>
<a name="ln2288">{</a>
<a name="ln2289">  struct in6_addr *address;</a>
<a name="ln2290">  struct bgp_info *bgp_info;</a>
<a name="ln2291"> </a>
<a name="ln2292">  if (type == RMAP_BGP)</a>
<a name="ln2293">    {</a>
<a name="ln2294">      /* Fetch routemap's rule information. */</a>
<a name="ln2295">      address = rule;</a>
<a name="ln2296">      bgp_info = object;</a>
<a name="ln2297">    </a>
<a name="ln2298">      /* Set next hop value. */ </a>
<a name="ln2299">      (bgp_attr_extra_get (bgp_info-&gt;attr))-&gt;mp_nexthop_global = *address;</a>
<a name="ln2300">    </a>
<a name="ln2301">      /* Set nexthop length. */</a>
<a name="ln2302">      if (bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_len == 0)</a>
<a name="ln2303">	bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_len = 16;</a>
<a name="ln2304">    }</a>
<a name="ln2305"> </a>
<a name="ln2306">  return RMAP_OKAY;</a>
<a name="ln2307">}</a>
<a name="ln2308"> </a>
<a name="ln2309">/* Route map `ip next-hop' compile function.  Given string is converted</a>
<a name="ln2310">   to struct in_addr structure. */</a>
<a name="ln2311">static void *</a>
<a name="ln2312">route_set_ipv6_nexthop_global_compile (const char *arg)</a>
<a name="ln2313">{</a>
<a name="ln2314">  int ret;</a>
<a name="ln2315">  struct in6_addr *address;</a>
<a name="ln2316"> </a>
<a name="ln2317">  address = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in6_addr));</a>
<a name="ln2318"> </a>
<a name="ln2319">  ret = inet_pton (AF_INET6, arg, address);</a>
<a name="ln2320"> </a>
<a name="ln2321">  if (ret == 0)</a>
<a name="ln2322">    {</a>
<a name="ln2323">      XFREE (MTYPE_ROUTE_MAP_COMPILED, address);</a>
<a name="ln2324">      return NULL;</a>
<a name="ln2325">    }</a>
<a name="ln2326"> </a>
<a name="ln2327">  return address;</a>
<a name="ln2328">}</a>
<a name="ln2329"> </a>
<a name="ln2330">/* Free route map's compiled `ip next-hop' value. */</a>
<a name="ln2331">static void</a>
<a name="ln2332">route_set_ipv6_nexthop_global_free (void *rule)</a>
<a name="ln2333">{</a>
<a name="ln2334">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln2335">}</a>
<a name="ln2336"> </a>
<a name="ln2337">/* Route map commands for ip nexthop set. */</a>
<a name="ln2338">struct route_map_rule_cmd route_set_ipv6_nexthop_global_cmd =</a>
<a name="ln2339">{</a>
<a name="ln2340">  &quot;ipv6 next-hop global&quot;,</a>
<a name="ln2341">  route_set_ipv6_nexthop_global,</a>
<a name="ln2342">  route_set_ipv6_nexthop_global_compile,</a>
<a name="ln2343">  route_set_ipv6_nexthop_global_free</a>
<a name="ln2344">};</a>
<a name="ln2345"> </a>
<a name="ln2346">/* `set ipv6 nexthop local IP_ADDRESS' */</a>
<a name="ln2347"> </a>
<a name="ln2348">/* Set nexthop to object.  ojbect must be pointer to struct attr. */</a>
<a name="ln2349">static route_map_result_t</a>
<a name="ln2350">route_set_ipv6_nexthop_local (void *rule, struct prefix *prefix, </a>
<a name="ln2351">			      route_map_object_t type, void *object)</a>
<a name="ln2352">{</a>
<a name="ln2353">  struct in6_addr *address;</a>
<a name="ln2354">  struct bgp_info *bgp_info;</a>
<a name="ln2355"> </a>
<a name="ln2356">  if (type == RMAP_BGP)</a>
<a name="ln2357">    {</a>
<a name="ln2358">      /* Fetch routemap's rule information. */</a>
<a name="ln2359">      address = rule;</a>
<a name="ln2360">      bgp_info = object;</a>
<a name="ln2361">    </a>
<a name="ln2362">      /* Set next hop value. */ </a>
<a name="ln2363">      (bgp_attr_extra_get (bgp_info-&gt;attr))-&gt;mp_nexthop_local = *address;</a>
<a name="ln2364">    </a>
<a name="ln2365">      /* Set nexthop length. */</a>
<a name="ln2366">      if (bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_len != 32)</a>
<a name="ln2367">	bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_len = 32;</a>
<a name="ln2368">    }</a>
<a name="ln2369"> </a>
<a name="ln2370">  return RMAP_OKAY;</a>
<a name="ln2371">}</a>
<a name="ln2372"> </a>
<a name="ln2373">/* Route map `ip nexthop' compile function.  Given string is converted</a>
<a name="ln2374">   to struct in_addr structure. */</a>
<a name="ln2375">static void *</a>
<a name="ln2376">route_set_ipv6_nexthop_local_compile (const char *arg)</a>
<a name="ln2377">{</a>
<a name="ln2378">  int ret;</a>
<a name="ln2379">  struct in6_addr *address;</a>
<a name="ln2380"> </a>
<a name="ln2381">  address = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in6_addr));</a>
<a name="ln2382"> </a>
<a name="ln2383">  ret = inet_pton (AF_INET6, arg, address);</a>
<a name="ln2384"> </a>
<a name="ln2385">  if (ret == 0)</a>
<a name="ln2386">    {</a>
<a name="ln2387">      XFREE (MTYPE_ROUTE_MAP_COMPILED, address);</a>
<a name="ln2388">      return NULL;</a>
<a name="ln2389">    }</a>
<a name="ln2390"> </a>
<a name="ln2391">  return address;</a>
<a name="ln2392">}</a>
<a name="ln2393"> </a>
<a name="ln2394">/* Free route map's compiled `ip nexthop' value. */</a>
<a name="ln2395">static void</a>
<a name="ln2396">route_set_ipv6_nexthop_local_free (void *rule)</a>
<a name="ln2397">{</a>
<a name="ln2398">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln2399">}</a>
<a name="ln2400"> </a>
<a name="ln2401">/* Route map commands for ip nexthop set. */</a>
<a name="ln2402">struct route_map_rule_cmd route_set_ipv6_nexthop_local_cmd =</a>
<a name="ln2403">{</a>
<a name="ln2404">  &quot;ipv6 next-hop local&quot;,</a>
<a name="ln2405">  route_set_ipv6_nexthop_local,</a>
<a name="ln2406">  route_set_ipv6_nexthop_local_compile,</a>
<a name="ln2407">  route_set_ipv6_nexthop_local_free</a>
<a name="ln2408">};</a>
<a name="ln2409"> </a>
<a name="ln2410">/* `set ipv6 nexthop peer-address' */</a>
<a name="ln2411"> </a>
<a name="ln2412">/* Set nexthop to object.  ojbect must be pointer to struct attr. */</a>
<a name="ln2413">static route_map_result_t</a>
<a name="ln2414">route_set_ipv6_nexthop_peer (void *rule, struct prefix *prefix,</a>
<a name="ln2415">			     route_map_object_t type, void *object)</a>
<a name="ln2416">{</a>
<a name="ln2417">  struct in6_addr peer_address;</a>
<a name="ln2418">  struct bgp_info *bgp_info;</a>
<a name="ln2419">  struct peer *peer;</a>
<a name="ln2420"> </a>
<a name="ln2421">  if (type == RMAP_BGP)</a>
<a name="ln2422">    {</a>
<a name="ln2423">      /* Fetch routemap's rule information. */</a>
<a name="ln2424">      bgp_info = object;</a>
<a name="ln2425">      peer = bgp_info-&gt;peer;</a>
<a name="ln2426"> </a>
<a name="ln2427">      if ((CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_IN) ||</a>
<a name="ln2428">           CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_IMPORT))</a>
<a name="ln2429">	  &amp;&amp; peer-&gt;su_remote</a>
<a name="ln2430">	  &amp;&amp; sockunion_family (peer-&gt;su_remote) == AF_INET6)</a>
<a name="ln2431">	{</a>
<a name="ln2432">	  peer_address = peer-&gt;su_remote-&gt;sin6.sin6_addr;</a>
<a name="ln2433">	}</a>
<a name="ln2434">      else if (CHECK_FLAG (peer-&gt;rmap_type, PEER_RMAP_TYPE_OUT)</a>
<a name="ln2435">	       &amp;&amp; peer-&gt;su_local</a>
<a name="ln2436">	       &amp;&amp; sockunion_family (peer-&gt;su_local) == AF_INET6)</a>
<a name="ln2437">	{</a>
<a name="ln2438">	  peer_address = peer-&gt;su_local-&gt;sin6.sin6_addr;</a>
<a name="ln2439">	}</a>
<a name="ln2440"> </a>
<a name="ln2441">      if (IN6_IS_ADDR_LINKLOCAL(&amp;peer_address))</a>
<a name="ln2442">	{</a>
<a name="ln2443">	  /* Set next hop value. */</a>
<a name="ln2444">	  (bgp_attr_extra_get (bgp_info-&gt;attr))-&gt;mp_nexthop_local = peer_address;</a>
<a name="ln2445"> </a>
<a name="ln2446">	  /* Set nexthop length. */</a>
<a name="ln2447">	  if (bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_len != 32)</a>
<a name="ln2448">	    bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_len = 32;</a>
<a name="ln2449">	}</a>
<a name="ln2450">      else</a>
<a name="ln2451">	{</a>
<a name="ln2452">	  /* Set next hop value. */</a>
<a name="ln2453">	  (bgp_attr_extra_get (bgp_info-&gt;attr))-&gt;mp_nexthop_global = peer_address;</a>
<a name="ln2454"> </a>
<a name="ln2455">	  /* Set nexthop length. */</a>
<a name="ln2456">	  if (bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_len == 0)</a>
<a name="ln2457">	    bgp_info-&gt;attr-&gt;extra-&gt;mp_nexthop_len = 16;</a>
<a name="ln2458">	}</a>
<a name="ln2459">    }</a>
<a name="ln2460"> </a>
<a name="ln2461">  return RMAP_OKAY;</a>
<a name="ln2462">}</a>
<a name="ln2463"> </a>
<a name="ln2464">/* Route map `ip next-hop' compile function.  Given string is converted</a>
<a name="ln2465">   to struct in_addr structure. */</a>
<a name="ln2466">static void *</a>
<a name="ln2467">route_set_ipv6_nexthop_peer_compile (const char *arg)</a>
<a name="ln2468">{</a>
<a name="ln2469">  int *rins = NULL;</a>
<a name="ln2470"> </a>
<a name="ln2471">  rins = XCALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (int));</a>
<a name="ln2472">  *rins = 1;</a>
<a name="ln2473"> </a>
<a name="ln2474">  return rins;</a>
<a name="ln2475">}</a>
<a name="ln2476"> </a>
<a name="ln2477">/* Free route map's compiled `ip next-hop' value. */</a>
<a name="ln2478">static void</a>
<a name="ln2479">route_set_ipv6_nexthop_peer_free (void *rule)</a>
<a name="ln2480">{</a>
<a name="ln2481">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln2482">}</a>
<a name="ln2483"> </a>
<a name="ln2484">/* Route map commands for ip nexthop set. */</a>
<a name="ln2485">struct route_map_rule_cmd route_set_ipv6_nexthop_peer_cmd =</a>
<a name="ln2486">{</a>
<a name="ln2487">  &quot;ipv6 next-hop peer-address&quot;,</a>
<a name="ln2488">  route_set_ipv6_nexthop_peer,</a>
<a name="ln2489">  route_set_ipv6_nexthop_peer_compile,</a>
<a name="ln2490">  route_set_ipv6_nexthop_peer_free</a>
<a name="ln2491">};</a>
<a name="ln2492"> </a>
<a name="ln2493">/* `set vpnv4 nexthop A.B.C.D' */</a>
<a name="ln2494"> </a>
<a name="ln2495">static route_map_result_t</a>
<a name="ln2496">route_set_vpnv4_nexthop (void *rule, struct prefix *prefix, </a>
<a name="ln2497">			 route_map_object_t type, void *object)</a>
<a name="ln2498">{</a>
<a name="ln2499">  struct in_addr *address;</a>
<a name="ln2500">  struct bgp_info *bgp_info;</a>
<a name="ln2501"> </a>
<a name="ln2502">  if (type == RMAP_BGP)</a>
<a name="ln2503">    {</a>
<a name="ln2504">      /* Fetch routemap's rule information. */</a>
<a name="ln2505">      address = rule;</a>
<a name="ln2506">      bgp_info = object;</a>
<a name="ln2507">    </a>
<a name="ln2508">      /* Set next hop value. */ </a>
<a name="ln2509">      (bgp_attr_extra_get (bgp_info-&gt;attr))-&gt;mp_nexthop_global_in = *address;</a>
<a name="ln2510">      (bgp_attr_extra_get (bgp_info-&gt;attr))-&gt;mp_nexthop_len = 4;</a>
<a name="ln2511">    }</a>
<a name="ln2512"> </a>
<a name="ln2513">  return RMAP_OKAY;</a>
<a name="ln2514">}</a>
<a name="ln2515"> </a>
<a name="ln2516">static void *</a>
<a name="ln2517">route_set_vpnv4_nexthop_compile (const char *arg)</a>
<a name="ln2518">{</a>
<a name="ln2519">  int ret;</a>
<a name="ln2520">  struct in_addr *address;</a>
<a name="ln2521"> </a>
<a name="ln2522">  address = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in_addr));</a>
<a name="ln2523"> </a>
<a name="ln2524">  ret = inet_aton (arg, address);</a>
<a name="ln2525"> </a>
<a name="ln2526">  if (ret == 0)</a>
<a name="ln2527">    {</a>
<a name="ln2528">      XFREE (MTYPE_ROUTE_MAP_COMPILED, address);</a>
<a name="ln2529">      return NULL;</a>
<a name="ln2530">    }</a>
<a name="ln2531"> </a>
<a name="ln2532">  return address;</a>
<a name="ln2533">}</a>
<a name="ln2534"> </a>
<a name="ln2535">static void</a>
<a name="ln2536">route_set_vpnv4_nexthop_free (void *rule)</a>
<a name="ln2537">{</a>
<a name="ln2538">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln2539">}</a>
<a name="ln2540"> </a>
<a name="ln2541">/* Route map commands for ip nexthop set. */</a>
<a name="ln2542">struct route_map_rule_cmd route_set_vpnv4_nexthop_cmd =</a>
<a name="ln2543">{</a>
<a name="ln2544">  &quot;vpnv4 next-hop&quot;,</a>
<a name="ln2545">  route_set_vpnv4_nexthop,</a>
<a name="ln2546">  route_set_vpnv4_nexthop_compile,</a>
<a name="ln2547">  route_set_vpnv4_nexthop_free</a>
<a name="ln2548">};</a>
<a name="ln2549"> </a>
<a name="ln2550">/* `set originator-id' */</a>
<a name="ln2551"> </a>
<a name="ln2552">/* For origin set. */</a>
<a name="ln2553">static route_map_result_t</a>
<a name="ln2554">route_set_originator_id (void *rule, struct prefix *prefix, route_map_object_t type, void *object)</a>
<a name="ln2555">{</a>
<a name="ln2556">  struct in_addr *address;</a>
<a name="ln2557">  struct bgp_info *bgp_info;</a>
<a name="ln2558"> </a>
<a name="ln2559">  if (type == RMAP_BGP) </a>
<a name="ln2560">    {</a>
<a name="ln2561">      address = rule;</a>
<a name="ln2562">      bgp_info = object;</a>
<a name="ln2563">    </a>
<a name="ln2564">      bgp_info-&gt;attr-&gt;flag |= ATTR_FLAG_BIT (BGP_ATTR_ORIGINATOR_ID);</a>
<a name="ln2565">      (bgp_attr_extra_get (bgp_info-&gt;attr))-&gt;originator_id = *address;</a>
<a name="ln2566">    }</a>
<a name="ln2567"> </a>
<a name="ln2568">  return RMAP_OKAY;</a>
<a name="ln2569">}</a>
<a name="ln2570"> </a>
<a name="ln2571">/* Compile function for originator-id set. */</a>
<a name="ln2572">static void *</a>
<a name="ln2573">route_set_originator_id_compile (const char *arg)</a>
<a name="ln2574">{</a>
<a name="ln2575">  int ret;</a>
<a name="ln2576">  struct in_addr *address;</a>
<a name="ln2577"> </a>
<a name="ln2578">  address = XMALLOC (MTYPE_ROUTE_MAP_COMPILED, sizeof (struct in_addr));</a>
<a name="ln2579"> </a>
<a name="ln2580">  ret = inet_aton (arg, address);</a>
<a name="ln2581"> </a>
<a name="ln2582">  if (ret == 0)</a>
<a name="ln2583">    {</a>
<a name="ln2584">      XFREE (MTYPE_ROUTE_MAP_COMPILED, address);</a>
<a name="ln2585">      return NULL;</a>
<a name="ln2586">    }</a>
<a name="ln2587"> </a>
<a name="ln2588">  return address;</a>
<a name="ln2589">}</a>
<a name="ln2590"> </a>
<a name="ln2591">/* Compile function for originator_id set. */</a>
<a name="ln2592">static void</a>
<a name="ln2593">route_set_originator_id_free (void *rule)</a>
<a name="ln2594">{</a>
<a name="ln2595">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln2596">}</a>
<a name="ln2597"> </a>
<a name="ln2598">/* Set originator-id rule structure. */</a>
<a name="ln2599">struct route_map_rule_cmd route_set_originator_id_cmd = </a>
<a name="ln2600">{</a>
<a name="ln2601">  &quot;originator-id&quot;,</a>
<a name="ln2602">  route_set_originator_id,</a>
<a name="ln2603">  route_set_originator_id_compile,</a>
<a name="ln2604">  route_set_originator_id_free,</a>
<a name="ln2605">};</a>
<a name="ln2606"> </a>
<a name="ln2607">/* Add bgp route map rule. */</a>
<a name="ln2608">static int</a>
<a name="ln2609">bgp_route_match_add (struct vty *vty, struct route_map_index *index,</a>
<a name="ln2610">		     const char *command, const char *arg)</a>
<a name="ln2611">{</a>
<a name="ln2612">  int ret;</a>
<a name="ln2613"> </a>
<a name="ln2614">  ret = route_map_add_match (index, command, arg);</a>
<a name="ln2615">  if (ret)</a>
<a name="ln2616">    {</a>
<a name="ln2617">      switch (ret)</a>
<a name="ln2618">	{</a>
<a name="ln2619">	case RMAP_RULE_MISSING:</a>
<a name="ln2620">	  vty_out (vty, &quot;%% BGP Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2621">	  return CMD_WARNING;</a>
<a name="ln2622">	case RMAP_COMPILE_ERROR:</a>
<a name="ln2623">	  vty_out (vty, &quot;%% BGP Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2624">	  return CMD_WARNING;</a>
<a name="ln2625">	}</a>
<a name="ln2626">    }</a>
<a name="ln2627">  return CMD_SUCCESS;</a>
<a name="ln2628">}</a>
<a name="ln2629"> </a>
<a name="ln2630">/* Delete bgp route map rule. */</a>
<a name="ln2631">static int</a>
<a name="ln2632">bgp_route_match_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln2633">			const char *command, const char *arg)</a>
<a name="ln2634">{</a>
<a name="ln2635">  int ret;</a>
<a name="ln2636"> </a>
<a name="ln2637">  ret = route_map_delete_match (index, command, arg);</a>
<a name="ln2638">  if (ret)</a>
<a name="ln2639">    {</a>
<a name="ln2640">      switch (ret)</a>
<a name="ln2641">	{</a>
<a name="ln2642">	case RMAP_RULE_MISSING:</a>
<a name="ln2643">	  vty_out (vty, &quot;%% BGP Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2644">	  return CMD_WARNING;</a>
<a name="ln2645">	case RMAP_COMPILE_ERROR:</a>
<a name="ln2646">	  vty_out (vty, &quot;%% BGP Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2647">	  return CMD_WARNING;</a>
<a name="ln2648">	}</a>
<a name="ln2649">    }</a>
<a name="ln2650">  return CMD_SUCCESS;</a>
<a name="ln2651">}</a>
<a name="ln2652"> </a>
<a name="ln2653">/* Add bgp route map rule. */</a>
<a name="ln2654">static int</a>
<a name="ln2655">bgp_route_set_add (struct vty *vty, struct route_map_index *index,</a>
<a name="ln2656">		   const char *command, const char *arg)</a>
<a name="ln2657">{</a>
<a name="ln2658">  int ret;</a>
<a name="ln2659"> </a>
<a name="ln2660">  ret = route_map_add_set (index, command, arg);</a>
<a name="ln2661">  if (ret)</a>
<a name="ln2662">    {</a>
<a name="ln2663">      switch (ret)</a>
<a name="ln2664">	{</a>
<a name="ln2665">	case RMAP_RULE_MISSING:</a>
<a name="ln2666">	  vty_out (vty, &quot;%% BGP Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2667">	  return CMD_WARNING;</a>
<a name="ln2668">	case RMAP_COMPILE_ERROR:</a>
<a name="ln2669">	  vty_out (vty, &quot;%% BGP Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2670">	  return CMD_WARNING;</a>
<a name="ln2671">	}</a>
<a name="ln2672">    }</a>
<a name="ln2673">  return CMD_SUCCESS;</a>
<a name="ln2674">}</a>
<a name="ln2675"> </a>
<a name="ln2676">/* Delete bgp route map rule. */</a>
<a name="ln2677">static int</a>
<a name="ln2678">bgp_route_set_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln2679">		      const char *command, const char *arg)</a>
<a name="ln2680">{</a>
<a name="ln2681">  int ret;</a>
<a name="ln2682"> </a>
<a name="ln2683">  ret = route_map_delete_set (index, command, arg);</a>
<a name="ln2684">  if (ret)</a>
<a name="ln2685">    {</a>
<a name="ln2686">      switch (ret)</a>
<a name="ln2687">	{</a>
<a name="ln2688">	case RMAP_RULE_MISSING:</a>
<a name="ln2689">	  vty_out (vty, &quot;%% BGP Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2690">	  return CMD_WARNING;</a>
<a name="ln2691">	case RMAP_COMPILE_ERROR:</a>
<a name="ln2692">	  vty_out (vty, &quot;%% BGP Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln2693">	  return CMD_WARNING;</a>
<a name="ln2694">	}</a>
<a name="ln2695">    }</a>
<a name="ln2696">  return CMD_SUCCESS;</a>
<a name="ln2697">}</a>
<a name="ln2698"> </a>
<a name="ln2699">/* Hook function for updating route_map assignment. */</a>
<a name="ln2700">static void</a>
<a name="ln2701">bgp_route_map_update (const char *unused)</a>
<a name="ln2702">{</a>
<a name="ln2703">  int i;</a>
<a name="ln2704">  afi_t afi;</a>
<a name="ln2705">  safi_t safi;</a>
<a name="ln2706">  int direct;</a>
<a name="ln2707">  struct listnode *node, *nnode;</a>
<a name="ln2708">  struct listnode *mnode, *mnnode;</a>
<a name="ln2709">  struct bgp *bgp;</a>
<a name="ln2710">  struct peer *peer;</a>
<a name="ln2711">  struct peer_group *group;</a>
<a name="ln2712">  struct bgp_filter *filter;</a>
<a name="ln2713">  struct bgp_node *bn;</a>
<a name="ln2714">  struct bgp_static *bgp_static;</a>
<a name="ln2715"> </a>
<a name="ln2716">  if (bm-&gt;bgp == NULL)          /* may be called during cleanup */</a>
<a name="ln2717">    return;</a>
<a name="ln2718"> </a>
<a name="ln2719">  /* For neighbor route-map updates. */</a>
<a name="ln2720">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, mnode, mnnode, bgp))</a>
<a name="ln2721">    {</a>
<a name="ln2722">      for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln2723">	{</a>
<a name="ln2724">	  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln2725">	    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln2726">	      {</a>
<a name="ln2727">		filter = &amp;peer-&gt;filter[afi][safi];</a>
<a name="ln2728">	  </a>
<a name="ln2729">               for (direct = RMAP_IN; direct &lt; RMAP_MAX; direct++)</a>
<a name="ln2730">		  {</a>
<a name="ln2731">		    if (filter-&gt;map[direct].name)</a>
<a name="ln2732">		      filter-&gt;map[direct].map = </a>
<a name="ln2733">			route_map_lookup_by_name (filter-&gt;map[direct].name);</a>
<a name="ln2734">		    else</a>
<a name="ln2735">		      filter-&gt;map[direct].map = NULL;</a>
<a name="ln2736">		  }</a>
<a name="ln2737"> </a>
<a name="ln2738">		if (filter-&gt;usmap.name)</a>
<a name="ln2739">		  filter-&gt;usmap.map = route_map_lookup_by_name (filter-&gt;usmap.name);</a>
<a name="ln2740">		else</a>
<a name="ln2741">		  filter-&gt;usmap.map = NULL;</a>
<a name="ln2742">	      }</a>
<a name="ln2743">	}</a>
<a name="ln2744">      for (ALL_LIST_ELEMENTS (bgp-&gt;group, node, nnode, group))</a>
<a name="ln2745">	{</a>
<a name="ln2746">	  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln2747">	    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln2748">	      {</a>
<a name="ln2749">		filter = &amp;group-&gt;conf-&gt;filter[afi][safi];</a>
<a name="ln2750">	  </a>
<a name="ln2751">               for (direct = RMAP_IN; direct &lt; RMAP_MAX; direct++)</a>
<a name="ln2752">		  {</a>
<a name="ln2753">		    if (filter-&gt;map[direct].name)</a>
<a name="ln2754">		      filter-&gt;map[direct].map = </a>
<a name="ln2755">			route_map_lookup_by_name (filter-&gt;map[direct].name);</a>
<a name="ln2756">		    else</a>
<a name="ln2757">		      filter-&gt;map[direct].map = NULL;</a>
<a name="ln2758">		  }</a>
<a name="ln2759"> </a>
<a name="ln2760">		if (filter-&gt;usmap.name)</a>
<a name="ln2761">		  filter-&gt;usmap.map = route_map_lookup_by_name (filter-&gt;usmap.name);</a>
<a name="ln2762">		else</a>
<a name="ln2763">		  filter-&gt;usmap.map = NULL;</a>
<a name="ln2764">	      }</a>
<a name="ln2765">	}</a>
<a name="ln2766">    }</a>
<a name="ln2767"> </a>
<a name="ln2768">  /* For default-originate route-map updates. */</a>
<a name="ln2769">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, mnode, mnnode, bgp))</a>
<a name="ln2770">    {</a>
<a name="ln2771">      for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln2772">	{</a>
<a name="ln2773">	  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln2774">	    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln2775">	      {</a>
<a name="ln2776">		if (peer-&gt;default_rmap[afi][safi].name)</a>
<a name="ln2777">		  peer-&gt;default_rmap[afi][safi].map =</a>
<a name="ln2778">		    route_map_lookup_by_name (peer-&gt;default_rmap[afi][safi].name);</a>
<a name="ln2779">		else</a>
<a name="ln2780">		  peer-&gt;default_rmap[afi][safi].map = NULL;</a>
<a name="ln2781">	      }</a>
<a name="ln2782">	}</a>
<a name="ln2783">    }</a>
<a name="ln2784"> </a>
<a name="ln2785">  /* For network route-map updates. */</a>
<a name="ln2786">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, mnode, mnnode, bgp))</a>
<a name="ln2787">    {</a>
<a name="ln2788">      for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln2789">	for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln2790">	  for (bn = bgp_table_top (bgp-&gt;route[afi][safi]); bn;</a>
<a name="ln2791">	       bn = bgp_route_next (bn))</a>
<a name="ln2792">	    if ((bgp_static = bn-&gt;info) != NULL)</a>
<a name="ln2793">	      {</a>
<a name="ln2794">		if (bgp_static-&gt;rmap.name)</a>
<a name="ln2795">		  bgp_static-&gt;rmap.map =</a>
<a name="ln2796">			 route_map_lookup_by_name (bgp_static-&gt;rmap.name);</a>
<a name="ln2797">		else</a>
<a name="ln2798">		  bgp_static-&gt;rmap.map = NULL;</a>
<a name="ln2799">	      }</a>
<a name="ln2800">    }</a>
<a name="ln2801"> </a>
<a name="ln2802">  /* For redistribute route-map updates. */</a>
<a name="ln2803">  for (ALL_LIST_ELEMENTS (bm-&gt;bgp, mnode, mnnode, bgp))</a>
<a name="ln2804">    {</a>
<a name="ln2805">      for (i = 0; i &lt; ZEBRA_ROUTE_MAX; i++)</a>
<a name="ln2806">	{</a>
<a name="ln2807">	  if (bgp-&gt;rmap[AFI_IP][i].name)</a>
<a name="ln2808">	    bgp-&gt;rmap[AFI_IP][i].map =</a>
<a name="ln2809">	      route_map_lookup_by_name (bgp-&gt;rmap[AFI_IP][i].name);</a>
<a name="ln2810">	  if (bgp-&gt;rmap[AFI_IP6][i].name)</a>
<a name="ln2811">	    bgp-&gt;rmap[AFI_IP6][i].map =</a>
<a name="ln2812">	      route_map_lookup_by_name (bgp-&gt;rmap[AFI_IP6][i].name);</a>
<a name="ln2813">	}</a>
<a name="ln2814">    }</a>
<a name="ln2815">}</a>
<a name="ln2816"> </a>
<a name="ln2817">DEFUN (match_peer,</a>
<a name="ln2818">       match_peer_cmd,</a>
<a name="ln2819">       &quot;match peer (A.B.C.D|X:X::X:X)&quot;,</a>
<a name="ln2820">       MATCH_STR</a>
<a name="ln2821">       &quot;Match peer address\n&quot;</a>
<a name="ln2822">       &quot;IP address of peer\n&quot;</a>
<a name="ln2823">       &quot;IPv6 address of peer\n&quot;)</a>
<a name="ln2824">{</a>
<a name="ln2825">  return bgp_route_match_add (vty, vty-&gt;index, &quot;peer&quot;, argv[0]);</a>
<a name="ln2826">}</a>
<a name="ln2827"> </a>
<a name="ln2828">DEFUN (match_peer_local,</a>
<a name="ln2829">        match_peer_local_cmd,</a>
<a name="ln2830">        &quot;match peer local&quot;,</a>
<a name="ln2831">        MATCH_STR</a>
<a name="ln2832">        &quot;Match peer address\n&quot;</a>
<a name="ln2833">        &quot;Static or Redistributed routes\n&quot;)</a>
<a name="ln2834">{</a>
<a name="ln2835">  return bgp_route_match_add (vty, vty-&gt;index, &quot;peer&quot;, &quot;local&quot;);</a>
<a name="ln2836">}</a>
<a name="ln2837"> </a>
<a name="ln2838">DEFUN (no_match_peer,</a>
<a name="ln2839">       no_match_peer_cmd,</a>
<a name="ln2840">       &quot;no match peer&quot;,</a>
<a name="ln2841">       NO_STR</a>
<a name="ln2842">       MATCH_STR</a>
<a name="ln2843">       &quot;Match peer address\n&quot;)</a>
<a name="ln2844">{</a>
<a name="ln2845"> if (argc == 0)</a>
<a name="ln2846">   return bgp_route_match_delete (vty, vty-&gt;index, &quot;peer&quot;, NULL);</a>
<a name="ln2847"> </a>
<a name="ln2848">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;peer&quot;, argv[0]);</a>
<a name="ln2849">}</a>
<a name="ln2850"> </a>
<a name="ln2851">ALIAS (no_match_peer,</a>
<a name="ln2852">       no_match_peer_val_cmd,</a>
<a name="ln2853">       &quot;no match peer (A.B.C.D|X:X::X:X)&quot;,</a>
<a name="ln2854">       NO_STR</a>
<a name="ln2855">       MATCH_STR</a>
<a name="ln2856">       &quot;Match peer address\n&quot;</a>
<a name="ln2857">       &quot;IP address of peer\n&quot;</a>
<a name="ln2858">       &quot;IPv6 address of peer\n&quot;)</a>
<a name="ln2859"> </a>
<a name="ln2860">ALIAS (no_match_peer,</a>
<a name="ln2861">       no_match_peer_local_cmd,</a>
<a name="ln2862">       &quot;no match peer local&quot;,</a>
<a name="ln2863">       NO_STR</a>
<a name="ln2864">       MATCH_STR</a>
<a name="ln2865">       &quot;Match peer address\n&quot;</a>
<a name="ln2866">       &quot;Static or Redistributed routes\n&quot;)</a>
<a name="ln2867"> </a>
<a name="ln2868">DEFUN (match_ip_address, </a>
<a name="ln2869">       match_ip_address_cmd,</a>
<a name="ln2870">       &quot;match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln2871">       MATCH_STR</a>
<a name="ln2872">       IP_STR</a>
<a name="ln2873">       &quot;Match address of route\n&quot;</a>
<a name="ln2874">       &quot;IP access-list number\n&quot;</a>
<a name="ln2875">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln2876">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln2877">{</a>
<a name="ln2878">  return bgp_route_match_add (vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln2879">}</a>
<a name="ln2880"> </a>
<a name="ln2881">DEFUN (no_match_ip_address, </a>
<a name="ln2882">       no_match_ip_address_cmd,</a>
<a name="ln2883">       &quot;no match ip address&quot;,</a>
<a name="ln2884">       NO_STR</a>
<a name="ln2885">       MATCH_STR</a>
<a name="ln2886">       IP_STR</a>
<a name="ln2887">       &quot;Match address of route\n&quot;)</a>
<a name="ln2888">{</a>
<a name="ln2889">  if (argc == 0)</a>
<a name="ln2890">    return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip address&quot;, NULL);</a>
<a name="ln2891"> </a>
<a name="ln2892">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln2893">}</a>
<a name="ln2894"> </a>
<a name="ln2895">ALIAS (no_match_ip_address, </a>
<a name="ln2896">       no_match_ip_address_val_cmd,</a>
<a name="ln2897">       &quot;no match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln2898">       NO_STR</a>
<a name="ln2899">       MATCH_STR</a>
<a name="ln2900">       IP_STR</a>
<a name="ln2901">       &quot;Match address of route\n&quot;</a>
<a name="ln2902">       &quot;IP access-list number\n&quot;</a>
<a name="ln2903">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln2904">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln2905"> </a>
<a name="ln2906">DEFUN (match_ip_next_hop, </a>
<a name="ln2907">       match_ip_next_hop_cmd,</a>
<a name="ln2908">       &quot;match ip next-hop (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln2909">       MATCH_STR</a>
<a name="ln2910">       IP_STR</a>
<a name="ln2911">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln2912">       &quot;IP access-list number\n&quot;</a>
<a name="ln2913">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln2914">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln2915">{</a>
<a name="ln2916">  return bgp_route_match_add (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln2917">}</a>
<a name="ln2918"> </a>
<a name="ln2919">DEFUN (no_match_ip_next_hop,</a>
<a name="ln2920">       no_match_ip_next_hop_cmd,</a>
<a name="ln2921">       &quot;no match ip next-hop&quot;,</a>
<a name="ln2922">       NO_STR</a>
<a name="ln2923">       MATCH_STR</a>
<a name="ln2924">       IP_STR</a>
<a name="ln2925">       &quot;Match next-hop address of route\n&quot;)</a>
<a name="ln2926">{</a>
<a name="ln2927">  if (argc == 0)</a>
<a name="ln2928">    return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, NULL);</a>
<a name="ln2929"> </a>
<a name="ln2930">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln2931">}</a>
<a name="ln2932"> </a>
<a name="ln2933">ALIAS (no_match_ip_next_hop,</a>
<a name="ln2934">       no_match_ip_next_hop_val_cmd,</a>
<a name="ln2935">       &quot;no match ip next-hop (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln2936">       NO_STR</a>
<a name="ln2937">       MATCH_STR</a>
<a name="ln2938">       IP_STR</a>
<a name="ln2939">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln2940">       &quot;IP access-list number\n&quot;</a>
<a name="ln2941">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln2942">       &quot;IP Access-list name\n&quot;)</a>
<a name="ln2943"> </a>
<a name="ln2944">/* match probability { */</a>
<a name="ln2945"> </a>
<a name="ln2946">DEFUN (match_probability,</a>
<a name="ln2947">       match_probability_cmd,</a>
<a name="ln2948">       &quot;match probability &lt;0-100&gt;&quot;,</a>
<a name="ln2949">       MATCH_STR</a>
<a name="ln2950">       &quot;Match portion of routes defined by percentage value\n&quot;</a>
<a name="ln2951">       &quot;Percentage of routes\n&quot;)</a>
<a name="ln2952">{</a>
<a name="ln2953">  return bgp_route_match_add (vty, vty-&gt;index, &quot;probability&quot;, argv[0]);</a>
<a name="ln2954">}</a>
<a name="ln2955"> </a>
<a name="ln2956">DEFUN (no_match_probability,</a>
<a name="ln2957">       no_match_probability_cmd,</a>
<a name="ln2958">       &quot;no match probability&quot;,</a>
<a name="ln2959">       NO_STR</a>
<a name="ln2960">       MATCH_STR</a>
<a name="ln2961">       &quot;Match portion of routes defined by percentage value\n&quot;)</a>
<a name="ln2962">{</a>
<a name="ln2963">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;probability&quot;, argc ? argv[0] : NULL);</a>
<a name="ln2964">}</a>
<a name="ln2965"> </a>
<a name="ln2966">ALIAS (no_match_probability,</a>
<a name="ln2967">       no_match_probability_val_cmd,</a>
<a name="ln2968">       &quot;no match probability &lt;1-99&gt;&quot;,</a>
<a name="ln2969">       NO_STR</a>
<a name="ln2970">       MATCH_STR</a>
<a name="ln2971">       &quot;Match portion of routes defined by percentage value\n&quot;</a>
<a name="ln2972">       &quot;Percentage of routes\n&quot;)</a>
<a name="ln2973"> </a>
<a name="ln2974">/* } */</a>
<a name="ln2975"> </a>
<a name="ln2976">DEFUN (match_ip_route_source, </a>
<a name="ln2977">       match_ip_route_source_cmd,</a>
<a name="ln2978">       &quot;match ip route-source (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln2979">       MATCH_STR</a>
<a name="ln2980">       IP_STR</a>
<a name="ln2981">       &quot;Match advertising source address of route\n&quot;</a>
<a name="ln2982">       &quot;IP access-list number\n&quot;</a>
<a name="ln2983">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln2984">       &quot;IP standard access-list name\n&quot;)</a>
<a name="ln2985">{</a>
<a name="ln2986">  return bgp_route_match_add (vty, vty-&gt;index, &quot;ip route-source&quot;, argv[0]);</a>
<a name="ln2987">}</a>
<a name="ln2988"> </a>
<a name="ln2989">DEFUN (no_match_ip_route_source,</a>
<a name="ln2990">       no_match_ip_route_source_cmd,</a>
<a name="ln2991">       &quot;no match ip route-source&quot;,</a>
<a name="ln2992">       NO_STR</a>
<a name="ln2993">       MATCH_STR</a>
<a name="ln2994">       IP_STR</a>
<a name="ln2995">       &quot;Match advertising source address of route\n&quot;)</a>
<a name="ln2996">{</a>
<a name="ln2997">  if (argc == 0)</a>
<a name="ln2998">    return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip route-source&quot;, NULL);</a>
<a name="ln2999"> </a>
<a name="ln3000">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip route-source&quot;, argv[0]);</a>
<a name="ln3001">}</a>
<a name="ln3002"> </a>
<a name="ln3003">ALIAS (no_match_ip_route_source,</a>
<a name="ln3004">       no_match_ip_route_source_val_cmd,</a>
<a name="ln3005">       &quot;no match ip route-source (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln3006">       NO_STR</a>
<a name="ln3007">       MATCH_STR</a>
<a name="ln3008">       IP_STR</a>
<a name="ln3009">       &quot;Match advertising source address of route\n&quot;</a>
<a name="ln3010">       &quot;IP access-list number\n&quot;</a>
<a name="ln3011">       &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln3012">       &quot;IP standard access-list name\n&quot;)</a>
<a name="ln3013"> </a>
<a name="ln3014">DEFUN (match_ip_address_prefix_list, </a>
<a name="ln3015">       match_ip_address_prefix_list_cmd,</a>
<a name="ln3016">       &quot;match ip address prefix-list WORD&quot;,</a>
<a name="ln3017">       MATCH_STR</a>
<a name="ln3018">       IP_STR</a>
<a name="ln3019">       &quot;Match address of route\n&quot;</a>
<a name="ln3020">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln3021">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln3022">{</a>
<a name="ln3023">  return bgp_route_match_add (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, argv[0]);</a>
<a name="ln3024">}</a>
<a name="ln3025"> </a>
<a name="ln3026">DEFUN (no_match_ip_address_prefix_list,</a>
<a name="ln3027">       no_match_ip_address_prefix_list_cmd,</a>
<a name="ln3028">       &quot;no match ip address prefix-list&quot;,</a>
<a name="ln3029">       NO_STR</a>
<a name="ln3030">       MATCH_STR</a>
<a name="ln3031">       IP_STR</a>
<a name="ln3032">       &quot;Match address of route\n&quot;</a>
<a name="ln3033">       &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln3034">{</a>
<a name="ln3035">  if (argc == 0)</a>
<a name="ln3036">    return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, NULL);</a>
<a name="ln3037"> </a>
<a name="ln3038">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, argv[0]);</a>
<a name="ln3039">}</a>
<a name="ln3040"> </a>
<a name="ln3041">ALIAS (no_match_ip_address_prefix_list,</a>
<a name="ln3042">       no_match_ip_address_prefix_list_val_cmd,</a>
<a name="ln3043">       &quot;no match ip address prefix-list WORD&quot;,</a>
<a name="ln3044">       NO_STR</a>
<a name="ln3045">       MATCH_STR</a>
<a name="ln3046">       IP_STR</a>
<a name="ln3047">       &quot;Match address of route\n&quot;</a>
<a name="ln3048">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln3049">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln3050"> </a>
<a name="ln3051">DEFUN (match_ip_next_hop_prefix_list, </a>
<a name="ln3052">       match_ip_next_hop_prefix_list_cmd,</a>
<a name="ln3053">       &quot;match ip next-hop prefix-list WORD&quot;,</a>
<a name="ln3054">       MATCH_STR</a>
<a name="ln3055">       IP_STR</a>
<a name="ln3056">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln3057">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln3058">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln3059">{</a>
<a name="ln3060">  return bgp_route_match_add (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;, argv[0]);</a>
<a name="ln3061">}</a>
<a name="ln3062"> </a>
<a name="ln3063">DEFUN (no_match_ip_next_hop_prefix_list,</a>
<a name="ln3064">       no_match_ip_next_hop_prefix_list_cmd,</a>
<a name="ln3065">       &quot;no match ip next-hop prefix-list&quot;,</a>
<a name="ln3066">       NO_STR</a>
<a name="ln3067">       MATCH_STR</a>
<a name="ln3068">       IP_STR</a>
<a name="ln3069">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln3070">       &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln3071">{</a>
<a name="ln3072">  if (argc == 0)</a>
<a name="ln3073">    return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;, NULL);</a>
<a name="ln3074"> </a>
<a name="ln3075">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip next-hop prefix-list&quot;, argv[0]);</a>
<a name="ln3076">}</a>
<a name="ln3077"> </a>
<a name="ln3078">ALIAS (no_match_ip_next_hop_prefix_list,</a>
<a name="ln3079">       no_match_ip_next_hop_prefix_list_val_cmd,</a>
<a name="ln3080">       &quot;no match ip next-hop prefix-list WORD&quot;,</a>
<a name="ln3081">       NO_STR</a>
<a name="ln3082">       MATCH_STR</a>
<a name="ln3083">       IP_STR</a>
<a name="ln3084">       &quot;Match next-hop address of route\n&quot;</a>
<a name="ln3085">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln3086">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln3087"> </a>
<a name="ln3088">DEFUN (match_ip_route_source_prefix_list, </a>
<a name="ln3089">       match_ip_route_source_prefix_list_cmd,</a>
<a name="ln3090">       &quot;match ip route-source prefix-list WORD&quot;,</a>
<a name="ln3091">       MATCH_STR</a>
<a name="ln3092">       IP_STR</a>
<a name="ln3093">       &quot;Match advertising source address of route\n&quot;</a>
<a name="ln3094">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln3095">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln3096">{</a>
<a name="ln3097">  return bgp_route_match_add (vty, vty-&gt;index, &quot;ip route-source prefix-list&quot;, argv[0]);</a>
<a name="ln3098">}</a>
<a name="ln3099"> </a>
<a name="ln3100">DEFUN (no_match_ip_route_source_prefix_list,</a>
<a name="ln3101">       no_match_ip_route_source_prefix_list_cmd,</a>
<a name="ln3102">       &quot;no match ip route-source prefix-list&quot;,</a>
<a name="ln3103">       NO_STR</a>
<a name="ln3104">       MATCH_STR</a>
<a name="ln3105">       IP_STR</a>
<a name="ln3106">       &quot;Match advertising source address of route\n&quot;</a>
<a name="ln3107">       &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln3108">{</a>
<a name="ln3109">  if (argc == 0)</a>
<a name="ln3110">    return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip route-source prefix-list&quot;, NULL);</a>
<a name="ln3111"> </a>
<a name="ln3112">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;ip route-source prefix-list&quot;, argv[0]);</a>
<a name="ln3113">}</a>
<a name="ln3114"> </a>
<a name="ln3115">ALIAS (no_match_ip_route_source_prefix_list,</a>
<a name="ln3116">       no_match_ip_route_source_prefix_list_val_cmd,</a>
<a name="ln3117">       &quot;no match ip route-source prefix-list WORD&quot;,</a>
<a name="ln3118">       NO_STR</a>
<a name="ln3119">       MATCH_STR</a>
<a name="ln3120">       IP_STR</a>
<a name="ln3121">       &quot;Match advertising source address of route\n&quot;</a>
<a name="ln3122">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln3123">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln3124"> </a>
<a name="ln3125">DEFUN (match_metric, </a>
<a name="ln3126">       match_metric_cmd,</a>
<a name="ln3127">       &quot;match metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3128">       MATCH_STR</a>
<a name="ln3129">       &quot;Match metric of route\n&quot;</a>
<a name="ln3130">       &quot;Metric value\n&quot;)</a>
<a name="ln3131">{</a>
<a name="ln3132">  return bgp_route_match_add (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln3133">}</a>
<a name="ln3134"> </a>
<a name="ln3135">DEFUN (no_match_metric,</a>
<a name="ln3136">       no_match_metric_cmd,</a>
<a name="ln3137">       &quot;no match metric&quot;,</a>
<a name="ln3138">       NO_STR</a>
<a name="ln3139">       MATCH_STR</a>
<a name="ln3140">       &quot;Match metric of route\n&quot;)</a>
<a name="ln3141">{</a>
<a name="ln3142">  if (argc == 0)</a>
<a name="ln3143">    return bgp_route_match_delete (vty, vty-&gt;index, &quot;metric&quot;, NULL);</a>
<a name="ln3144"> </a>
<a name="ln3145">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln3146">}</a>
<a name="ln3147"> </a>
<a name="ln3148">ALIAS (no_match_metric,</a>
<a name="ln3149">       no_match_metric_val_cmd,</a>
<a name="ln3150">       &quot;no match metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3151">       NO_STR</a>
<a name="ln3152">       MATCH_STR</a>
<a name="ln3153">       &quot;Match metric of route\n&quot;</a>
<a name="ln3154">       &quot;Metric value\n&quot;)</a>
<a name="ln3155"> </a>
<a name="ln3156">DEFUN (match_local_pref,</a>
<a name="ln3157">       match_local_pref_cmd,</a>
<a name="ln3158">       &quot;match local-preference &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3159">       MATCH_STR</a>
<a name="ln3160">       &quot;Match local-preference of route\n&quot;</a>
<a name="ln3161">       &quot;Metric value\n&quot;)</a>
<a name="ln3162">{</a>
<a name="ln3163">  return bgp_route_match_add (vty, vty-&gt;index, &quot;local-preference&quot;, argv[0]);</a>
<a name="ln3164">}</a>
<a name="ln3165"> </a>
<a name="ln3166">DEFUN (no_match_local_pref,</a>
<a name="ln3167">       no_match_local_pref_cmd,</a>
<a name="ln3168">       &quot;no match local-preference&quot;,</a>
<a name="ln3169">       NO_STR</a>
<a name="ln3170">       MATCH_STR</a>
<a name="ln3171">       &quot;Match local preference of route\n&quot;)</a>
<a name="ln3172">{</a>
<a name="ln3173">  if (argc == 0)</a>
<a name="ln3174">    return bgp_route_match_delete (vty, vty-&gt;index, &quot;local-preference&quot;, NULL);</a>
<a name="ln3175"> </a>
<a name="ln3176">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;local-preference&quot;, argv[0]);</a>
<a name="ln3177">}</a>
<a name="ln3178"> </a>
<a name="ln3179">ALIAS (no_match_local_pref,</a>
<a name="ln3180">       no_match_local_pref_val_cmd,</a>
<a name="ln3181">       &quot;no match local-preference &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3182">       NO_STR</a>
<a name="ln3183">       MATCH_STR</a>
<a name="ln3184">       &quot;Match local preference of route\n&quot;</a>
<a name="ln3185">       &quot;Local preference value\n&quot;)</a>
<a name="ln3186"> </a>
<a name="ln3187">DEFUN (match_community, </a>
<a name="ln3188">       match_community_cmd,</a>
<a name="ln3189">       &quot;match community (&lt;1-99&gt;|&lt;100-500&gt;|WORD)&quot;,</a>
<a name="ln3190">       MATCH_STR</a>
<a name="ln3191">       &quot;Match BGP community list\n&quot;</a>
<a name="ln3192">       &quot;Community-list number (standard)\n&quot;</a>
<a name="ln3193">       &quot;Community-list number (expanded)\n&quot;</a>
<a name="ln3194">       &quot;Community-list name\n&quot;)</a>
<a name="ln3195">{</a>
<a name="ln3196">  return bgp_route_match_add (vty, vty-&gt;index, &quot;community&quot;, argv[0]);</a>
<a name="ln3197">}</a>
<a name="ln3198"> </a>
<a name="ln3199">DEFUN (match_community_exact, </a>
<a name="ln3200">       match_community_exact_cmd,</a>
<a name="ln3201">       &quot;match community (&lt;1-99&gt;|&lt;100-500&gt;|WORD) exact-match&quot;,</a>
<a name="ln3202">       MATCH_STR</a>
<a name="ln3203">       &quot;Match BGP community list\n&quot;</a>
<a name="ln3204">       &quot;Community-list number (standard)\n&quot;</a>
<a name="ln3205">       &quot;Community-list number (expanded)\n&quot;</a>
<a name="ln3206">       &quot;Community-list name\n&quot;</a>
<a name="ln3207">       &quot;Do exact matching of communities\n&quot;)</a>
<a name="ln3208">{</a>
<a name="ln3209">  int ret;</a>
<a name="ln3210">  char *argstr;</a>
<a name="ln3211"> </a>
<a name="ln3212">  argstr = XMALLOC (MTYPE_ROUTE_MAP_COMPILED,</a>
<a name="ln3213">		    strlen (argv[0]) + strlen (&quot;exact-match&quot;) + 2);</a>
<a name="ln3214"> </a>
<a name="ln3215">  sprintf (argstr, &quot;%s exact-match&quot;, argv[0]);</a>
<a name="ln3216"> </a>
<a name="ln3217">  ret = bgp_route_match_add (vty, vty-&gt;index, &quot;community&quot;, argstr);</a>
<a name="ln3218"> </a>
<a name="ln3219">  XFREE (MTYPE_ROUTE_MAP_COMPILED, argstr);</a>
<a name="ln3220"> </a>
<a name="ln3221">  return ret;</a>
<a name="ln3222">}</a>
<a name="ln3223"> </a>
<a name="ln3224">DEFUN (no_match_community,</a>
<a name="ln3225">       no_match_community_cmd,</a>
<a name="ln3226">       &quot;no match community&quot;,</a>
<a name="ln3227">       NO_STR</a>
<a name="ln3228">       MATCH_STR</a>
<a name="ln3229">       &quot;Match BGP community list\n&quot;)</a>
<a name="ln3230">{</a>
<a name="ln3231">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;community&quot;, NULL);</a>
<a name="ln3232">}</a>
<a name="ln3233"> </a>
<a name="ln3234">ALIAS (no_match_community,</a>
<a name="ln3235">       no_match_community_val_cmd,</a>
<a name="ln3236">       &quot;no match community (&lt;1-99&gt;|&lt;100-500&gt;|WORD)&quot;,</a>
<a name="ln3237">       NO_STR</a>
<a name="ln3238">       MATCH_STR</a>
<a name="ln3239">       &quot;Match BGP community list\n&quot;</a>
<a name="ln3240">       &quot;Community-list number (standard)\n&quot;</a>
<a name="ln3241">       &quot;Community-list number (expanded)\n&quot;</a>
<a name="ln3242">       &quot;Community-list name\n&quot;)</a>
<a name="ln3243"> </a>
<a name="ln3244">ALIAS (no_match_community,</a>
<a name="ln3245">       no_match_community_exact_cmd,</a>
<a name="ln3246">       &quot;no match community (&lt;1-99&gt;|&lt;100-500&gt;|WORD) exact-match&quot;,</a>
<a name="ln3247">       NO_STR</a>
<a name="ln3248">       MATCH_STR</a>
<a name="ln3249">       &quot;Match BGP community list\n&quot;</a>
<a name="ln3250">       &quot;Community-list number (standard)\n&quot;</a>
<a name="ln3251">       &quot;Community-list number (expanded)\n&quot;</a>
<a name="ln3252">       &quot;Community-list name\n&quot;</a>
<a name="ln3253">       &quot;Do exact matching of communities\n&quot;)</a>
<a name="ln3254"> </a>
<a name="ln3255">DEFUN (match_lcommunity,</a>
<a name="ln3256">       match_lcommunity_cmd,</a>
<a name="ln3257">       &quot;match large-community (&lt;1-99&gt;|&lt;100-500&gt;|WORD)&quot;,</a>
<a name="ln3258">       MATCH_STR</a>
<a name="ln3259">       &quot;Match BGP large community list\n&quot;</a>
<a name="ln3260">       &quot;Large Community-list number (standard)\n&quot;</a>
<a name="ln3261">       &quot;Large Community-list number (expanded)\n&quot;</a>
<a name="ln3262">       &quot;Large Community-list name\n&quot;)</a>
<a name="ln3263">{</a>
<a name="ln3264">  return bgp_route_match_add (vty, vty-&gt;index, &quot;large-community&quot;, argv[0]);</a>
<a name="ln3265">}</a>
<a name="ln3266"> </a>
<a name="ln3267">DEFUN (no_match_lcommunity,</a>
<a name="ln3268">       no_match_lcommunity_cmd,</a>
<a name="ln3269">       &quot;no match large-community (&lt;1-99&gt;|&lt;100-500&gt;|WORD)&quot;,</a>
<a name="ln3270">       NO_STR</a>
<a name="ln3271">       MATCH_STR</a>
<a name="ln3272">       &quot;Match BGP large community list\n&quot;</a>
<a name="ln3273">       &quot;Large Community-list number (standard)\n&quot;</a>
<a name="ln3274">       &quot;Large Community-list number (expanded)\n&quot;</a>
<a name="ln3275">       &quot;Large Community-list name\n&quot;)</a>
<a name="ln3276">{</a>
<a name="ln3277">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;large-community&quot;, NULL);</a>
<a name="ln3278">}</a>
<a name="ln3279"> </a>
<a name="ln3280"> </a>
<a name="ln3281">DEFUN (match_ecommunity, </a>
<a name="ln3282">       match_ecommunity_cmd,</a>
<a name="ln3283">       &quot;match extcommunity (&lt;1-99&gt;|&lt;100-500&gt;|WORD)&quot;,</a>
<a name="ln3284">       MATCH_STR</a>
<a name="ln3285">       &quot;Match BGP/VPN extended community list\n&quot;</a>
<a name="ln3286">       &quot;Extended community-list number (standard)\n&quot;</a>
<a name="ln3287">       &quot;Extended community-list number (expanded)\n&quot;</a>
<a name="ln3288">       &quot;Extended community-list name\n&quot;)</a>
<a name="ln3289">{</a>
<a name="ln3290">  return bgp_route_match_add (vty, vty-&gt;index, &quot;extcommunity&quot;, argv[0]);</a>
<a name="ln3291">}</a>
<a name="ln3292"> </a>
<a name="ln3293">DEFUN (no_match_ecommunity,</a>
<a name="ln3294">       no_match_ecommunity_cmd,</a>
<a name="ln3295">       &quot;no match extcommunity&quot;,</a>
<a name="ln3296">       NO_STR</a>
<a name="ln3297">       MATCH_STR</a>
<a name="ln3298">       &quot;Match BGP/VPN extended community list\n&quot;)</a>
<a name="ln3299">{</a>
<a name="ln3300">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;extcommunity&quot;, NULL);</a>
<a name="ln3301">}</a>
<a name="ln3302"> </a>
<a name="ln3303">ALIAS (no_match_ecommunity,</a>
<a name="ln3304">       no_match_ecommunity_val_cmd,</a>
<a name="ln3305">       &quot;no match extcommunity (&lt;1-99&gt;|&lt;100-500&gt;|WORD)&quot;,</a>
<a name="ln3306">       NO_STR</a>
<a name="ln3307">       MATCH_STR</a>
<a name="ln3308">       &quot;Match BGP/VPN extended community list\n&quot;</a>
<a name="ln3309">       &quot;Extended community-list number (standard)\n&quot;</a>
<a name="ln3310">       &quot;Extended community-list number (expanded)\n&quot;</a>
<a name="ln3311">       &quot;Extended community-list name\n&quot;)</a>
<a name="ln3312"> </a>
<a name="ln3313">DEFUN (match_aspath,</a>
<a name="ln3314">       match_aspath_cmd,</a>
<a name="ln3315">       &quot;match as-path WORD&quot;,</a>
<a name="ln3316">       MATCH_STR</a>
<a name="ln3317">       &quot;Match BGP AS path list\n&quot;</a>
<a name="ln3318">       &quot;AS path access-list name\n&quot;)</a>
<a name="ln3319">{</a>
<a name="ln3320">  return bgp_route_match_add (vty, vty-&gt;index, &quot;as-path&quot;, argv[0]);</a>
<a name="ln3321">}</a>
<a name="ln3322"> </a>
<a name="ln3323">DEFUN (no_match_aspath,</a>
<a name="ln3324">       no_match_aspath_cmd,</a>
<a name="ln3325">       &quot;no match as-path&quot;,</a>
<a name="ln3326">       NO_STR</a>
<a name="ln3327">       MATCH_STR</a>
<a name="ln3328">       &quot;Match BGP AS path list\n&quot;)</a>
<a name="ln3329">{</a>
<a name="ln3330">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;as-path&quot;, NULL);</a>
<a name="ln3331">}</a>
<a name="ln3332"> </a>
<a name="ln3333">ALIAS (no_match_aspath,</a>
<a name="ln3334">       no_match_aspath_val_cmd,</a>
<a name="ln3335">       &quot;no match as-path WORD&quot;,</a>
<a name="ln3336">       NO_STR</a>
<a name="ln3337">       MATCH_STR</a>
<a name="ln3338">       &quot;Match BGP AS path list\n&quot;</a>
<a name="ln3339">       &quot;AS path access-list name\n&quot;)</a>
<a name="ln3340"> </a>
<a name="ln3341">DEFUN (match_origin,</a>
<a name="ln3342">       match_origin_cmd,</a>
<a name="ln3343">       &quot;match origin (egp|igp|incomplete)&quot;,</a>
<a name="ln3344">       MATCH_STR</a>
<a name="ln3345">       &quot;BGP origin code\n&quot;</a>
<a name="ln3346">       &quot;remote EGP\n&quot;</a>
<a name="ln3347">       &quot;local IGP\n&quot;</a>
<a name="ln3348">       &quot;unknown heritage\n&quot;)</a>
<a name="ln3349">{</a>
<a name="ln3350">  if (strncmp (argv[0], &quot;igp&quot;, 2) == 0)</a>
<a name="ln3351">    return bgp_route_match_add (vty, vty-&gt;index, &quot;origin&quot;, &quot;igp&quot;);</a>
<a name="ln3352">  if (strncmp (argv[0], &quot;egp&quot;, 1) == 0)</a>
<a name="ln3353">    return bgp_route_match_add (vty, vty-&gt;index, &quot;origin&quot;, &quot;egp&quot;);</a>
<a name="ln3354">  if (strncmp (argv[0], &quot;incomplete&quot;, 2) == 0)</a>
<a name="ln3355">    return bgp_route_match_add (vty, vty-&gt;index, &quot;origin&quot;, &quot;incomplete&quot;);</a>
<a name="ln3356"> </a>
<a name="ln3357">  return CMD_WARNING;</a>
<a name="ln3358">}</a>
<a name="ln3359"> </a>
<a name="ln3360">DEFUN (no_match_origin,</a>
<a name="ln3361">       no_match_origin_cmd,</a>
<a name="ln3362">       &quot;no match origin&quot;,</a>
<a name="ln3363">       NO_STR</a>
<a name="ln3364">       MATCH_STR</a>
<a name="ln3365">       &quot;BGP origin code\n&quot;)</a>
<a name="ln3366">{</a>
<a name="ln3367">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;origin&quot;, NULL);</a>
<a name="ln3368">}</a>
<a name="ln3369"> </a>
<a name="ln3370">ALIAS (no_match_origin,</a>
<a name="ln3371">       no_match_origin_val_cmd,</a>
<a name="ln3372">       &quot;no match origin (egp|igp|incomplete)&quot;,</a>
<a name="ln3373">       NO_STR</a>
<a name="ln3374">       MATCH_STR</a>
<a name="ln3375">       &quot;BGP origin code\n&quot;</a>
<a name="ln3376">       &quot;remote EGP\n&quot;</a>
<a name="ln3377">       &quot;local IGP\n&quot;</a>
<a name="ln3378">       &quot;unknown heritage\n&quot;)</a>
<a name="ln3379"> </a>
<a name="ln3380">DEFUN (match_tag,</a>
<a name="ln3381">       match_tag_cmd,</a>
<a name="ln3382">       &quot;match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln3383">       MATCH_STR</a>
<a name="ln3384">       &quot;Match tag of route\n&quot;</a>
<a name="ln3385">       &quot;Tag value\n&quot;)</a>
<a name="ln3386">{</a>
<a name="ln3387">  return bgp_route_match_add (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln3388">}</a>
<a name="ln3389"> </a>
<a name="ln3390">DEFUN (no_match_tag,</a>
<a name="ln3391">       no_match_tag_cmd,</a>
<a name="ln3392">       &quot;no match tag&quot;,</a>
<a name="ln3393">       NO_STR</a>
<a name="ln3394">       MATCH_STR</a>
<a name="ln3395">       &quot;Match tag of route\n&quot;)</a>
<a name="ln3396">{</a>
<a name="ln3397">  if (argc == 0)</a>
<a name="ln3398">    return bgp_route_match_delete (vty, vty-&gt;index, &quot;tag&quot;, NULL);</a>
<a name="ln3399"> </a>
<a name="ln3400">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln3401">}</a>
<a name="ln3402"> </a>
<a name="ln3403">ALIAS (no_match_tag,</a>
<a name="ln3404">       no_match_tag_val_cmd,</a>
<a name="ln3405">       &quot;no match tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln3406">       NO_STR</a>
<a name="ln3407">       MATCH_STR</a>
<a name="ln3408">       &quot;Match tag of route\n&quot;</a>
<a name="ln3409">       &quot;Tag value\n&quot;)</a>
<a name="ln3410"> </a>
<a name="ln3411">DEFUN (set_ip_nexthop,</a>
<a name="ln3412">       set_ip_nexthop_cmd,</a>
<a name="ln3413">       &quot;set ip next-hop A.B.C.D&quot;,</a>
<a name="ln3414">       SET_STR</a>
<a name="ln3415">       IP_STR</a>
<a name="ln3416">       &quot;Next hop address\n&quot;</a>
<a name="ln3417">       &quot;IP address of next hop\n&quot;)</a>
<a name="ln3418">{</a>
<a name="ln3419">  union sockunion su;</a>
<a name="ln3420">  int ret;</a>
<a name="ln3421"> </a>
<a name="ln3422">  ret = str2sockunion (argv[0], &amp;su);</a>
<a name="ln3423">  if (ret &lt; 0)</a>
<a name="ln3424">    {</a>
<a name="ln3425">      vty_out (vty, &quot;%% Malformed Next-hop address%s&quot;, VTY_NEWLINE);</a>
<a name="ln3426">      return CMD_WARNING;</a>
<a name="ln3427">    }</a>
<a name="ln3428"> </a>
<a name="ln3429">  return bgp_route_set_add (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln3430">}</a>
<a name="ln3431"> </a>
<a name="ln3432">DEFUN (set_ip_nexthop_peer,</a>
<a name="ln3433">       set_ip_nexthop_peer_cmd,</a>
<a name="ln3434">       &quot;set ip next-hop peer-address&quot;,</a>
<a name="ln3435">       SET_STR</a>
<a name="ln3436">       IP_STR</a>
<a name="ln3437">       &quot;Next hop address\n&quot;</a>
<a name="ln3438">       &quot;Use peer address (for BGP only)\n&quot;)</a>
<a name="ln3439">{</a>
<a name="ln3440">  return bgp_route_set_add (vty, vty-&gt;index, &quot;ip next-hop&quot;, &quot;peer-address&quot;);</a>
<a name="ln3441">}</a>
<a name="ln3442"> </a>
<a name="ln3443">DEFUN_DEPRECATED (no_set_ip_nexthop_peer,</a>
<a name="ln3444">       no_set_ip_nexthop_peer_cmd,</a>
<a name="ln3445">       &quot;no set ip next-hop peer-address&quot;,</a>
<a name="ln3446">       NO_STR</a>
<a name="ln3447">       SET_STR</a>
<a name="ln3448">       IP_STR</a>
<a name="ln3449">       &quot;Next hop address\n&quot;</a>
<a name="ln3450">       &quot;Use peer address (for BGP only)\n&quot;)</a>
<a name="ln3451">{</a>
<a name="ln3452">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, NULL);</a>
<a name="ln3453">}</a>
<a name="ln3454"> </a>
<a name="ln3455"> </a>
<a name="ln3456">DEFUN (no_set_ip_nexthop,</a>
<a name="ln3457">       no_set_ip_nexthop_cmd,</a>
<a name="ln3458">       &quot;no set ip next-hop&quot;,</a>
<a name="ln3459">       NO_STR</a>
<a name="ln3460">       SET_STR</a>
<a name="ln3461">       &quot;Next hop address\n&quot;)</a>
<a name="ln3462">{</a>
<a name="ln3463">  if (argc == 0)</a>
<a name="ln3464">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, NULL);</a>
<a name="ln3465"> </a>
<a name="ln3466">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;ip next-hop&quot;, argv[0]);</a>
<a name="ln3467">}</a>
<a name="ln3468"> </a>
<a name="ln3469">ALIAS (no_set_ip_nexthop,</a>
<a name="ln3470">       no_set_ip_nexthop_val_cmd,</a>
<a name="ln3471">       &quot;no set ip next-hop A.B.C.D&quot;,</a>
<a name="ln3472">       NO_STR</a>
<a name="ln3473">       SET_STR</a>
<a name="ln3474">       IP_STR</a>
<a name="ln3475">       &quot;Next hop address\n&quot;</a>
<a name="ln3476">       &quot;IP address of next hop\n&quot;)</a>
<a name="ln3477"> </a>
<a name="ln3478">DEFUN (set_metric,</a>
<a name="ln3479">       set_metric_cmd,</a>
<a name="ln3480">       &quot;set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3481">       SET_STR</a>
<a name="ln3482">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln3483">       &quot;Metric value\n&quot;)</a>
<a name="ln3484">{</a>
<a name="ln3485">  return bgp_route_set_add (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln3486">}</a>
<a name="ln3487"> </a>
<a name="ln3488">ALIAS (set_metric,</a>
<a name="ln3489">       set_metric_addsub_cmd,</a>
<a name="ln3490">       &quot;set metric &lt;+/-metric&gt;&quot;,</a>
<a name="ln3491">       SET_STR</a>
<a name="ln3492">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln3493">       &quot;Add or subtract metric\n&quot;)</a>
<a name="ln3494"> </a>
<a name="ln3495">ALIAS (set_metric,</a>
<a name="ln3496">       set_metric_rtt_cmd,</a>
<a name="ln3497">       &quot;set metric (rtt|+rtt|-rtt)&quot;,</a>
<a name="ln3498">       SET_STR</a>
<a name="ln3499">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln3500">       &quot;Assign round trip time\n&quot;</a>
<a name="ln3501">       &quot;Add round trip time\n&quot;</a>
<a name="ln3502">       &quot;Subtract round trip time\n&quot;)</a>
<a name="ln3503"> </a>
<a name="ln3504">DEFUN (no_set_metric,</a>
<a name="ln3505">       no_set_metric_cmd,</a>
<a name="ln3506">       &quot;no set metric&quot;,</a>
<a name="ln3507">       NO_STR</a>
<a name="ln3508">       SET_STR</a>
<a name="ln3509">       &quot;Metric value for destination routing protocol\n&quot;)</a>
<a name="ln3510">{</a>
<a name="ln3511">  if (argc == 0)</a>
<a name="ln3512">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;metric&quot;, NULL);</a>
<a name="ln3513"> </a>
<a name="ln3514">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln3515">}</a>
<a name="ln3516"> </a>
<a name="ln3517">ALIAS (no_set_metric,</a>
<a name="ln3518">       no_set_metric_val_cmd,</a>
<a name="ln3519">       &quot;no set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3520">       NO_STR</a>
<a name="ln3521">       SET_STR</a>
<a name="ln3522">       &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln3523">       &quot;Metric value\n&quot;)</a>
<a name="ln3524"> </a>
<a name="ln3525">DEFUN (set_local_pref,</a>
<a name="ln3526">       set_local_pref_cmd,</a>
<a name="ln3527">       &quot;set local-preference &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3528">       SET_STR</a>
<a name="ln3529">       &quot;BGP local preference path attribute\n&quot;</a>
<a name="ln3530">       &quot;Preference value\n&quot;)</a>
<a name="ln3531">{</a>
<a name="ln3532">  return bgp_route_set_add (vty, vty-&gt;index, &quot;local-preference&quot;, argv[0]);</a>
<a name="ln3533">}</a>
<a name="ln3534"> </a>
<a name="ln3535">DEFUN (no_set_local_pref,</a>
<a name="ln3536">       no_set_local_pref_cmd,</a>
<a name="ln3537">       &quot;no set local-preference&quot;,</a>
<a name="ln3538">       NO_STR</a>
<a name="ln3539">       SET_STR</a>
<a name="ln3540">       &quot;BGP local preference path attribute\n&quot;)</a>
<a name="ln3541">{</a>
<a name="ln3542">  if (argc == 0)</a>
<a name="ln3543">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;local-preference&quot;, NULL);</a>
<a name="ln3544"> </a>
<a name="ln3545">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;local-preference&quot;, argv[0]);</a>
<a name="ln3546">}</a>
<a name="ln3547"> </a>
<a name="ln3548">ALIAS (no_set_local_pref,</a>
<a name="ln3549">       no_set_local_pref_val_cmd,</a>
<a name="ln3550">       &quot;no set local-preference &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3551">       NO_STR</a>
<a name="ln3552">       SET_STR</a>
<a name="ln3553">       &quot;BGP local preference path attribute\n&quot;</a>
<a name="ln3554">       &quot;Preference value\n&quot;)</a>
<a name="ln3555"> </a>
<a name="ln3556">DEFUN (set_weight,</a>
<a name="ln3557">       set_weight_cmd,</a>
<a name="ln3558">       &quot;set weight &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3559">       SET_STR</a>
<a name="ln3560">       &quot;BGP weight for routing table\n&quot;</a>
<a name="ln3561">       &quot;Weight value\n&quot;)</a>
<a name="ln3562">{</a>
<a name="ln3563">  return bgp_route_set_add (vty, vty-&gt;index, &quot;weight&quot;, argv[0]);</a>
<a name="ln3564">}</a>
<a name="ln3565"> </a>
<a name="ln3566">DEFUN (no_set_weight,</a>
<a name="ln3567">       no_set_weight_cmd,</a>
<a name="ln3568">       &quot;no set weight&quot;,</a>
<a name="ln3569">       NO_STR</a>
<a name="ln3570">       SET_STR</a>
<a name="ln3571">       &quot;BGP weight for routing table\n&quot;)</a>
<a name="ln3572">{</a>
<a name="ln3573">  if (argc == 0)</a>
<a name="ln3574">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;weight&quot;, NULL);</a>
<a name="ln3575">  </a>
<a name="ln3576">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;weight&quot;, argv[0]);</a>
<a name="ln3577">}</a>
<a name="ln3578"> </a>
<a name="ln3579">ALIAS (no_set_weight,</a>
<a name="ln3580">       no_set_weight_val_cmd,</a>
<a name="ln3581">       &quot;no set weight &lt;0-4294967295&gt;&quot;,</a>
<a name="ln3582">       NO_STR</a>
<a name="ln3583">       SET_STR</a>
<a name="ln3584">       &quot;BGP weight for routing table\n&quot;</a>
<a name="ln3585">       &quot;Weight value\n&quot;)</a>
<a name="ln3586"> </a>
<a name="ln3587">DEFUN (set_aspath_prepend,</a>
<a name="ln3588">       set_aspath_prepend_cmd,</a>
<a name="ln3589">       &quot;set as-path prepend .&quot; CMD_AS_RANGE,</a>
<a name="ln3590">       SET_STR</a>
<a name="ln3591">       &quot;Transform BGP AS_PATH attribute\n&quot;</a>
<a name="ln3592">       &quot;Prepend to the as-path\n&quot;</a>
<a name="ln3593">       &quot;AS number\n&quot;)</a>
<a name="ln3594">{</a>
<a name="ln3595">  int ret;</a>
<a name="ln3596">  char *str;</a>
<a name="ln3597"> </a>
<a name="ln3598">  str = argv_concat (argv, argc, 0);</a>
<a name="ln3599">  ret = bgp_route_set_add (vty, vty-&gt;index, &quot;as-path prepend&quot;, str);</a>
<a name="ln3600">  XFREE (MTYPE_TMP, str);</a>
<a name="ln3601"> </a>
<a name="ln3602">  return ret;</a>
<a name="ln3603">}</a>
<a name="ln3604"> </a>
<a name="ln3605">ALIAS (set_aspath_prepend,</a>
<a name="ln3606">       set_aspath_prepend_lastas_cmd,</a>
<a name="ln3607">       &quot;set as-path prepend (last-as) &lt;1-10&gt;&quot;,</a>
<a name="ln3608">       SET_STR</a>
<a name="ln3609">       &quot;Transform BGP AS_PATH attribute\n&quot;</a>
<a name="ln3610">       &quot;Prepend to the as-path\n&quot;</a>
<a name="ln3611">       &quot;Use the peer's AS-number\n&quot;</a>
<a name="ln3612">       &quot;Number of times to insert&quot;)</a>
<a name="ln3613"> </a>
<a name="ln3614">DEFUN (no_set_aspath_prepend,</a>
<a name="ln3615">       no_set_aspath_prepend_cmd,</a>
<a name="ln3616">       &quot;no set as-path prepend&quot;,</a>
<a name="ln3617">       NO_STR</a>
<a name="ln3618">       SET_STR</a>
<a name="ln3619">       &quot;Transform BGP AS_PATH attribute\n&quot;</a>
<a name="ln3620">       &quot;Prepend to the as-path\n&quot;)</a>
<a name="ln3621">{</a>
<a name="ln3622">  int ret;</a>
<a name="ln3623">  char *str;</a>
<a name="ln3624"> </a>
<a name="ln3625">  if (argc == 0)</a>
<a name="ln3626">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;as-path prepend&quot;, NULL);</a>
<a name="ln3627"> </a>
<a name="ln3628">  str = argv_concat (argv, argc, 0);</a>
<a name="ln3629">  ret = bgp_route_set_delete (vty, vty-&gt;index, &quot;as-path prepend&quot;, str);</a>
<a name="ln3630">  XFREE (MTYPE_TMP, str);</a>
<a name="ln3631">  return ret;</a>
<a name="ln3632">}</a>
<a name="ln3633"> </a>
<a name="ln3634">ALIAS (no_set_aspath_prepend,</a>
<a name="ln3635">       no_set_aspath_prepend_val_cmd,</a>
<a name="ln3636">       &quot;no set as-path prepend .&quot; CMD_AS_RANGE,</a>
<a name="ln3637">       NO_STR</a>
<a name="ln3638">       SET_STR</a>
<a name="ln3639">       &quot;Transform BGP AS_PATH attribute\n&quot;</a>
<a name="ln3640">       &quot;Prepend to the as-path\n&quot;</a>
<a name="ln3641">       &quot;AS number\n&quot;)</a>
<a name="ln3642"> </a>
<a name="ln3643">DEFUN (set_aspath_exclude,</a>
<a name="ln3644">       set_aspath_exclude_cmd,</a>
<a name="ln3645">       &quot;set as-path exclude .&quot; CMD_AS_RANGE,</a>
<a name="ln3646">       SET_STR</a>
<a name="ln3647">       &quot;Transform BGP AS-path attribute\n&quot;</a>
<a name="ln3648">       &quot;Exclude from the as-path\n&quot;</a>
<a name="ln3649">       &quot;AS number\n&quot;)</a>
<a name="ln3650">{</a>
<a name="ln3651">  int ret;</a>
<a name="ln3652">  char *str;</a>
<a name="ln3653"> </a>
<a name="ln3654">  str = argv_concat (argv, argc, 0);</a>
<a name="ln3655">  ret = bgp_route_set_add (vty, vty-&gt;index, &quot;as-path exclude&quot;, str);</a>
<a name="ln3656">  XFREE (MTYPE_TMP, str);</a>
<a name="ln3657">  return ret;</a>
<a name="ln3658">}</a>
<a name="ln3659"> </a>
<a name="ln3660">DEFUN (no_set_aspath_exclude,</a>
<a name="ln3661">       no_set_aspath_exclude_cmd,</a>
<a name="ln3662">       &quot;no set as-path exclude&quot;,</a>
<a name="ln3663">       NO_STR</a>
<a name="ln3664">       SET_STR</a>
<a name="ln3665">       &quot;Transform BGP AS_PATH attribute\n&quot;</a>
<a name="ln3666">       &quot;Exclude from the as-path\n&quot;)</a>
<a name="ln3667">{</a>
<a name="ln3668">  int ret;</a>
<a name="ln3669">  char *str;</a>
<a name="ln3670"> </a>
<a name="ln3671">  if (argc == 0)</a>
<a name="ln3672">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;as-path exclude&quot;, NULL);</a>
<a name="ln3673"> </a>
<a name="ln3674">  str = argv_concat (argv, argc, 0);</a>
<a name="ln3675">  ret = bgp_route_set_delete (vty, vty-&gt;index, &quot;as-path exclude&quot;, str);</a>
<a name="ln3676">  XFREE (MTYPE_TMP, str);</a>
<a name="ln3677">  return ret;</a>
<a name="ln3678">}</a>
<a name="ln3679"> </a>
<a name="ln3680">ALIAS (no_set_aspath_exclude,</a>
<a name="ln3681">       no_set_aspath_exclude_val_cmd,</a>
<a name="ln3682">       &quot;no set as-path exclude .&quot; CMD_AS_RANGE,</a>
<a name="ln3683">       NO_STR</a>
<a name="ln3684">       SET_STR</a>
<a name="ln3685">       &quot;Transform BGP AS_PATH attribute\n&quot;</a>
<a name="ln3686">       &quot;Exclude from the as-path\n&quot;</a>
<a name="ln3687">       &quot;AS number\n&quot;)</a>
<a name="ln3688"> </a>
<a name="ln3689">DEFUN (set_community,</a>
<a name="ln3690">       set_community_cmd,</a>
<a name="ln3691">       &quot;set community .AA:NN&quot;,</a>
<a name="ln3692">       SET_STR</a>
<a name="ln3693">       &quot;BGP community attribute\n&quot;</a>
<a name="ln3694">       &quot;Community number in aa:nn format or local-AS|no-advertise|no-export|internet or additive\n&quot;)</a>
<a name="ln3695">{</a>
<a name="ln3696">  int i;</a>
<a name="ln3697">  int first = 0;</a>
<a name="ln3698">  int additive = 0;</a>
<a name="ln3699">  struct buffer *b;</a>
<a name="ln3700">  struct community *com = NULL;</a>
<a name="ln3701">  char *str;</a>
<a name="ln3702">  char *argstr;</a>
<a name="ln3703">  int ret;</a>
<a name="ln3704"> </a>
<a name="ln3705">  b = buffer_new (1024);</a>
<a name="ln3706"> </a>
<a name="ln3707">  for (i = 0; i &lt; argc; i++)</a>
<a name="ln3708">    {</a>
<a name="ln3709">      if (strncmp (argv[i], &quot;additive&quot;, strlen (argv[i])) == 0)</a>
<a name="ln3710"> 	{</a>
<a name="ln3711"> 	  additive = 1;</a>
<a name="ln3712"> 	  continue;</a>
<a name="ln3713"> 	}</a>
<a name="ln3714"> </a>
<a name="ln3715">      if (first)</a>
<a name="ln3716">	buffer_putc (b, ' ');</a>
<a name="ln3717">      else</a>
<a name="ln3718">	first = 1;</a>
<a name="ln3719"> </a>
<a name="ln3720">      if (strncmp (argv[i], &quot;internet&quot;, strlen (argv[i])) == 0)</a>
<a name="ln3721"> 	{</a>
<a name="ln3722">	  buffer_putstr (b, &quot;internet&quot;);</a>
<a name="ln3723"> 	  continue;</a>
<a name="ln3724"> 	}</a>
<a name="ln3725">      if (strncmp (argv[i], &quot;local-AS&quot;, strlen (argv[i])) == 0)</a>
<a name="ln3726"> 	{</a>
<a name="ln3727">	  buffer_putstr (b, &quot;local-AS&quot;);</a>
<a name="ln3728"> 	  continue;</a>
<a name="ln3729"> 	}</a>
<a name="ln3730">      if (strncmp (argv[i], &quot;no-a&quot;, strlen (&quot;no-a&quot;)) == 0</a>
<a name="ln3731">	  &amp;&amp; strncmp (argv[i], &quot;no-advertise&quot;, strlen (argv[i])) == 0)</a>
<a name="ln3732"> 	{</a>
<a name="ln3733">	  buffer_putstr (b, &quot;no-advertise&quot;);</a>
<a name="ln3734"> 	  continue;</a>
<a name="ln3735"> 	}</a>
<a name="ln3736">      if (strncmp (argv[i], &quot;no-e&quot;, strlen (&quot;no-e&quot;))== 0</a>
<a name="ln3737">	  &amp;&amp; strncmp (argv[i], &quot;no-export&quot;, strlen (argv[i])) == 0)</a>
<a name="ln3738"> 	{</a>
<a name="ln3739">	  buffer_putstr (b, &quot;no-export&quot;);</a>
<a name="ln3740"> 	  continue;</a>
<a name="ln3741"> 	}</a>
<a name="ln3742">      buffer_putstr (b, argv[i]);</a>
<a name="ln3743">    }</a>
<a name="ln3744">  buffer_putc (b, '\0');</a>
<a name="ln3745"> </a>
<a name="ln3746">  /* Fetch result string then compile it to communities attribute.  */</a>
<a name="ln3747">  str = buffer_getstr (b);</a>
<a name="ln3748">  buffer_free (b);</a>
<a name="ln3749"> </a>
<a name="ln3750">  if (str)</a>
<a name="ln3751">    {</a>
<a name="ln3752">      com = community_str2com (str);</a>
<a name="ln3753">      XFREE (MTYPE_TMP, str);</a>
<a name="ln3754">    }</a>
<a name="ln3755"> </a>
<a name="ln3756">  /* Can't compile user input into communities attribute.  */</a>
<a name="ln3757">  if (! com)</a>
<a name="ln3758">    {</a>
<a name="ln3759">      vty_out (vty, &quot;%% Malformed communities attribute%s&quot;, VTY_NEWLINE);</a>
<a name="ln3760">      return CMD_WARNING;</a>
<a name="ln3761">    }</a>
<a name="ln3762"> </a>
<a name="ln3763">  /* Set communites attribute string.  */</a>
<a name="ln3764">  str = community_str (com);</a>
<a name="ln3765"> </a>
<a name="ln3766">  if (additive)</a>
<a name="ln3767">    {</a>
<a name="ln3768">      argstr = XCALLOC (MTYPE_TMP, strlen (str) + strlen (&quot; additive&quot;) + 1);</a>
<a name="ln3769">      strcpy (argstr, str);</a>
<a name="ln3770">      strcpy (argstr + strlen (str), &quot; additive&quot;);</a>
<a name="ln3771">      ret =  bgp_route_set_add (vty, vty-&gt;index, &quot;community&quot;, argstr);</a>
<a name="ln3772">      XFREE (MTYPE_TMP, argstr);</a>
<a name="ln3773">    }</a>
<a name="ln3774">  else</a>
<a name="ln3775">    ret =  bgp_route_set_add (vty, vty-&gt;index, &quot;community&quot;, str);</a>
<a name="ln3776"> </a>
<a name="ln3777">  community_free (com);</a>
<a name="ln3778"> </a>
<a name="ln3779">  return ret;</a>
<a name="ln3780">}</a>
<a name="ln3781"> </a>
<a name="ln3782">DEFUN (set_community_none,</a>
<a name="ln3783">       set_community_none_cmd,</a>
<a name="ln3784">       &quot;set community none&quot;,</a>
<a name="ln3785">       SET_STR</a>
<a name="ln3786">       &quot;BGP community attribute\n&quot;</a>
<a name="ln3787">       &quot;No community attribute\n&quot;)</a>
<a name="ln3788">{</a>
<a name="ln3789">  return bgp_route_set_add (vty, vty-&gt;index, &quot;community&quot;, &quot;none&quot;);</a>
<a name="ln3790">}</a>
<a name="ln3791"> </a>
<a name="ln3792">DEFUN (no_set_community,</a>
<a name="ln3793">       no_set_community_cmd,</a>
<a name="ln3794">       &quot;no set community&quot;,</a>
<a name="ln3795">       NO_STR</a>
<a name="ln3796">       SET_STR</a>
<a name="ln3797">       &quot;BGP community attribute\n&quot;)</a>
<a name="ln3798">{</a>
<a name="ln3799">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;community&quot;, NULL);</a>
<a name="ln3800">}</a>
<a name="ln3801"> </a>
<a name="ln3802">ALIAS (no_set_community,</a>
<a name="ln3803">       no_set_community_val_cmd,</a>
<a name="ln3804">       &quot;no set community .AA:NN&quot;,</a>
<a name="ln3805">       NO_STR</a>
<a name="ln3806">       SET_STR</a>
<a name="ln3807">       &quot;BGP community attribute\n&quot;</a>
<a name="ln3808">       &quot;Community number in aa:nn format or local-AS|no-advertise|no-export|internet or additive\n&quot;)</a>
<a name="ln3809"> </a>
<a name="ln3810">ALIAS (no_set_community,</a>
<a name="ln3811">       no_set_community_none_cmd,</a>
<a name="ln3812">       &quot;no set community none&quot;,</a>
<a name="ln3813">       NO_STR</a>
<a name="ln3814">       SET_STR</a>
<a name="ln3815">       &quot;BGP community attribute\n&quot;</a>
<a name="ln3816">       &quot;No community attribute\n&quot;)</a>
<a name="ln3817"> </a>
<a name="ln3818">DEFUN (set_community_delete,</a>
<a name="ln3819">       set_community_delete_cmd,</a>
<a name="ln3820">       &quot;set comm-list (&lt;1-99&gt;|&lt;100-500&gt;|WORD) delete&quot;,</a>
<a name="ln3821">       SET_STR</a>
<a name="ln3822">       &quot;set BGP community list (for deletion)\n&quot;</a>
<a name="ln3823">       &quot;Community-list number (standard)\n&quot;</a>
<a name="ln3824">       &quot;Community-list number (expanded)\n&quot;</a>
<a name="ln3825">       &quot;Community-list name\n&quot;</a>
<a name="ln3826">       &quot;Delete matching communities\n&quot;)</a>
<a name="ln3827">{</a>
<a name="ln3828">  char *str;</a>
<a name="ln3829"> </a>
<a name="ln3830">  str = XCALLOC (MTYPE_TMP, strlen (argv[0]) + strlen (&quot; delete&quot;) + 1);</a>
<a name="ln3831">  strcpy (str, argv[0]);</a>
<a name="ln3832">  strcpy (str + strlen (argv[0]), &quot; delete&quot;);</a>
<a name="ln3833"> </a>
<a name="ln3834">  bgp_route_set_add (vty, vty-&gt;index, &quot;comm-list&quot;, str);</a>
<a name="ln3835"> </a>
<a name="ln3836">  XFREE (MTYPE_TMP, str);</a>
<a name="ln3837">  return CMD_SUCCESS;</a>
<a name="ln3838">}</a>
<a name="ln3839"> </a>
<a name="ln3840">DEFUN (no_set_community_delete,</a>
<a name="ln3841">       no_set_community_delete_cmd,</a>
<a name="ln3842">       &quot;no set comm-list&quot;,</a>
<a name="ln3843">       NO_STR</a>
<a name="ln3844">       SET_STR</a>
<a name="ln3845">       &quot;set BGP community list (for deletion)\n&quot;)</a>
<a name="ln3846">{</a>
<a name="ln3847">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;comm-list&quot;, NULL);</a>
<a name="ln3848">}</a>
<a name="ln3849"> </a>
<a name="ln3850">ALIAS (no_set_community_delete,</a>
<a name="ln3851">       no_set_community_delete_val_cmd,</a>
<a name="ln3852">       &quot;no set comm-list (&lt;1-99&gt;|&lt;100-500&gt;|WORD) delete&quot;,</a>
<a name="ln3853">       NO_STR</a>
<a name="ln3854">       SET_STR</a>
<a name="ln3855">       &quot;set BGP community list (for deletion)\n&quot;</a>
<a name="ln3856">       &quot;Community-list number (standard)\n&quot;</a>
<a name="ln3857">       &quot;Community-list number (expanded)\n&quot;</a>
<a name="ln3858">       &quot;Community-list name\n&quot;</a>
<a name="ln3859">       &quot;Delete matching communities\n&quot;)</a>
<a name="ln3860"> </a>
<a name="ln3861"> </a>
<a name="ln3862">DEFUN (set_lcommunity,</a>
<a name="ln3863">       set_lcommunity_cmd,</a>
<a name="ln3864">       &quot;set large-community .AA:BB:CC&quot;,</a>
<a name="ln3865">       SET_STR</a>
<a name="ln3866">       &quot;BGP large community attribute\n&quot;</a>
<a name="ln3867">       &quot;Large Community number in aa:bb:cc format or additive\n&quot;)</a>
<a name="ln3868">{</a>
<a name="ln3869">  int ret;</a>
<a name="ln3870">  char *str;</a>
<a name="ln3871"> </a>
<a name="ln3872">  str = argv_concat (argv, argc, 0);</a>
<a name="ln3873">  ret = bgp_route_set_add (vty, vty-&gt;index, &quot;large-community&quot;, str);</a>
<a name="ln3874">  XFREE (MTYPE_TMP, str);</a>
<a name="ln3875"> </a>
<a name="ln3876">  return ret;</a>
<a name="ln3877">}</a>
<a name="ln3878"> </a>
<a name="ln3879">DEFUN (set_lcommunity_none,</a>
<a name="ln3880">       set_lcommunity_none_cmd,</a>
<a name="ln3881">       &quot;set large-community none&quot;,</a>
<a name="ln3882">       SET_STR</a>
<a name="ln3883">       &quot;BGP large community attribute\n&quot;</a>
<a name="ln3884">       &quot;No large community attribute\n&quot;)</a>
<a name="ln3885">{</a>
<a name="ln3886">  return bgp_route_set_add (vty, vty-&gt;index, &quot;large-community&quot;, &quot;none&quot;);</a>
<a name="ln3887">}</a>
<a name="ln3888"> </a>
<a name="ln3889">DEFUN (no_set_lcommunity,</a>
<a name="ln3890">       no_set_lcommunity_cmd,</a>
<a name="ln3891">       &quot;no set large-community&quot;,</a>
<a name="ln3892">       NO_STR</a>
<a name="ln3893">       SET_STR</a>
<a name="ln3894">       &quot;BGP large community attribute\n&quot;</a>
<a name="ln3895">       &quot;Large community\n&quot;)</a>
<a name="ln3896">{</a>
<a name="ln3897">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;large-community&quot;, NULL);</a>
<a name="ln3898">}</a>
<a name="ln3899"> </a>
<a name="ln3900">ALIAS (no_set_lcommunity,</a>
<a name="ln3901">       no_set_lcommunity_val_cmd,</a>
<a name="ln3902">       &quot;no set large-community .AA:BB:CC&quot;,</a>
<a name="ln3903">       NO_STR</a>
<a name="ln3904">       SET_STR</a>
<a name="ln3905">       &quot;BGP large community attribute\n&quot;</a>
<a name="ln3906">       &quot;Large community in .AA:BB:CC format or additive\n&quot;)</a>
<a name="ln3907"> </a>
<a name="ln3908">ALIAS (no_set_lcommunity,</a>
<a name="ln3909">       no_set_lcommunity_none_cmd,</a>
<a name="ln3910">       &quot;no set large-community none&quot;,</a>
<a name="ln3911">       NO_STR</a>
<a name="ln3912">       SET_STR</a>
<a name="ln3913">       &quot;BGP community attribute\n&quot;</a>
<a name="ln3914">       &quot;No community attribute\n&quot;)</a>
<a name="ln3915"> </a>
<a name="ln3916">DEFUN (set_lcommunity_delete,</a>
<a name="ln3917">       set_lcommunity_delete_cmd,</a>
<a name="ln3918">       &quot;set large-comm-list (&lt;1-99&gt;|&lt;100-500&gt;|WORD) delete&quot;,</a>
<a name="ln3919">       SET_STR</a>
<a name="ln3920">       &quot;set BGP large community list (for deletion)\n&quot;</a>
<a name="ln3921">       &quot;Large Community-list number (standard)\n&quot;</a>
<a name="ln3922">       &quot;Large Communitly-list number (expanded)\n&quot;</a>
<a name="ln3923">       &quot;Large Community-list name\n&quot;</a>
<a name="ln3924">       &quot;Delete matching large communities\n&quot;)</a>
<a name="ln3925">{</a>
<a name="ln3926">  char *str;</a>
<a name="ln3927"> </a>
<a name="ln3928">  str = XCALLOC (MTYPE_TMP, strlen (argv[0]) + strlen (&quot; delete&quot;) + 1);</a>
<a name="ln3929">  strcpy (str, argv[0]);</a>
<a name="ln3930">  strcpy (str + strlen (argv[0]), &quot; delete&quot;);</a>
<a name="ln3931"> </a>
<a name="ln3932">  bgp_route_set_add (vty, vty-&gt;index, &quot;large-comm-list&quot;, str);</a>
<a name="ln3933"> </a>
<a name="ln3934">  XFREE (MTYPE_TMP, str);</a>
<a name="ln3935">  return CMD_SUCCESS;</a>
<a name="ln3936">}</a>
<a name="ln3937"> </a>
<a name="ln3938">DEFUN (no_set_lcommunity_delete,</a>
<a name="ln3939">       no_set_lcommunity_delete_cmd,</a>
<a name="ln3940">       &quot;no set large-comm-list&quot;,</a>
<a name="ln3941">       NO_STR</a>
<a name="ln3942">       SET_STR</a>
<a name="ln3943">       &quot;set BGP large community list (for deletion)\n&quot;)</a>
<a name="ln3944">{</a>
<a name="ln3945">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;large-comm-list&quot;, NULL);</a>
<a name="ln3946">}</a>
<a name="ln3947"> </a>
<a name="ln3948">ALIAS (no_set_lcommunity_delete,</a>
<a name="ln3949">       no_set_lcommunity_delete_val_cmd,</a>
<a name="ln3950">       &quot;no set large-comm-list (&lt;1-99&gt;|&lt;100-500&gt;|WORD) delete&quot;,</a>
<a name="ln3951">       NO_STR</a>
<a name="ln3952">       SET_STR</a>
<a name="ln3953">       &quot;set BGP large community list (for deletion)\n&quot;</a>
<a name="ln3954">       &quot;Large Community-list number (standard)\n&quot;</a>
<a name="ln3955">       &quot;Large Communitly-list number (expanded)\n&quot;</a>
<a name="ln3956">       &quot;Large Community-list name\n&quot;</a>
<a name="ln3957">       &quot;Delete matching large communities\n&quot;)</a>
<a name="ln3958"> </a>
<a name="ln3959">DEFUN (set_ecommunity_rt,</a>
<a name="ln3960">       set_ecommunity_rt_cmd,</a>
<a name="ln3961">       &quot;set extcommunity rt .ASN:nn_or_IP-address:nn&quot;,</a>
<a name="ln3962">       SET_STR</a>
<a name="ln3963">       &quot;BGP extended community attribute\n&quot;</a>
<a name="ln3964">       &quot;Route Target extended community\n&quot;</a>
<a name="ln3965">       &quot;VPN extended community\n&quot;)</a>
<a name="ln3966">{</a>
<a name="ln3967">  int ret;</a>
<a name="ln3968">  char *str;</a>
<a name="ln3969"> </a>
<a name="ln3970">  str = argv_concat (argv, argc, 0);</a>
<a name="ln3971">  ret = bgp_route_set_add (vty, vty-&gt;index, &quot;extcommunity rt&quot;, str);</a>
<a name="ln3972">  XFREE (MTYPE_TMP, str);</a>
<a name="ln3973"> </a>
<a name="ln3974">  return ret;</a>
<a name="ln3975">}</a>
<a name="ln3976"> </a>
<a name="ln3977">DEFUN (no_set_ecommunity_rt,</a>
<a name="ln3978">       no_set_ecommunity_rt_cmd,</a>
<a name="ln3979">       &quot;no set extcommunity rt&quot;,</a>
<a name="ln3980">       NO_STR</a>
<a name="ln3981">       SET_STR</a>
<a name="ln3982">       &quot;BGP extended community attribute\n&quot;</a>
<a name="ln3983">       &quot;Route Target extended community\n&quot;)</a>
<a name="ln3984">{</a>
<a name="ln3985">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;extcommunity rt&quot;, NULL);</a>
<a name="ln3986">}</a>
<a name="ln3987"> </a>
<a name="ln3988">ALIAS (no_set_ecommunity_rt,</a>
<a name="ln3989">       no_set_ecommunity_rt_val_cmd,</a>
<a name="ln3990">       &quot;no set extcommunity rt .ASN:nn_or_IP-address:nn&quot;,</a>
<a name="ln3991">       NO_STR</a>
<a name="ln3992">       SET_STR</a>
<a name="ln3993">       &quot;BGP extended community attribute\n&quot;</a>
<a name="ln3994">       &quot;Route Target extended community\n&quot;</a>
<a name="ln3995">       &quot;VPN extended community\n&quot;)</a>
<a name="ln3996"> </a>
<a name="ln3997">DEFUN (set_ecommunity_soo,</a>
<a name="ln3998">       set_ecommunity_soo_cmd,</a>
<a name="ln3999">       &quot;set extcommunity soo .ASN:nn_or_IP-address:nn&quot;,</a>
<a name="ln4000">       SET_STR</a>
<a name="ln4001">       &quot;BGP extended community attribute\n&quot;</a>
<a name="ln4002">       &quot;Site-of-Origin extended community\n&quot;</a>
<a name="ln4003">       &quot;VPN extended community\n&quot;)</a>
<a name="ln4004">{</a>
<a name="ln4005">  int ret;</a>
<a name="ln4006">  char *str;</a>
<a name="ln4007"> </a>
<a name="ln4008">  str = argv_concat (argv, argc, 0);</a>
<a name="ln4009">  ret = bgp_route_set_add (vty, vty-&gt;index, &quot;extcommunity soo&quot;, str);</a>
<a name="ln4010">  XFREE (MTYPE_TMP, str);</a>
<a name="ln4011">  return ret;</a>
<a name="ln4012">}</a>
<a name="ln4013"> </a>
<a name="ln4014">DEFUN (no_set_ecommunity_soo,</a>
<a name="ln4015">       no_set_ecommunity_soo_cmd,</a>
<a name="ln4016">       &quot;no set extcommunity soo&quot;,</a>
<a name="ln4017">       NO_STR</a>
<a name="ln4018">       SET_STR</a>
<a name="ln4019">       &quot;BGP extended community attribute\n&quot;</a>
<a name="ln4020">       &quot;Site-of-Origin extended community\n&quot;)</a>
<a name="ln4021">{</a>
<a name="ln4022">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;extcommunity soo&quot;, NULL);</a>
<a name="ln4023">}</a>
<a name="ln4024"> </a>
<a name="ln4025">ALIAS (no_set_ecommunity_soo,</a>
<a name="ln4026">       no_set_ecommunity_soo_val_cmd,</a>
<a name="ln4027">       &quot;no set extcommunity soo .ASN:nn_or_IP-address:nn&quot;,</a>
<a name="ln4028">       NO_STR</a>
<a name="ln4029">       SET_STR</a>
<a name="ln4030">       &quot;BGP extended community attribute\n&quot;</a>
<a name="ln4031">       &quot;Site-of-Origin extended community\n&quot;</a>
<a name="ln4032">       &quot;VPN extended community\n&quot;)</a>
<a name="ln4033"> </a>
<a name="ln4034">DEFUN (set_origin,</a>
<a name="ln4035">       set_origin_cmd,</a>
<a name="ln4036">       &quot;set origin (egp|igp|incomplete)&quot;,</a>
<a name="ln4037">       SET_STR</a>
<a name="ln4038">       &quot;BGP origin code\n&quot;</a>
<a name="ln4039">       &quot;remote EGP\n&quot;</a>
<a name="ln4040">       &quot;local IGP\n&quot;</a>
<a name="ln4041">       &quot;unknown heritage\n&quot;)</a>
<a name="ln4042">{</a>
<a name="ln4043">  if (strncmp (argv[0], &quot;igp&quot;, 2) == 0)</a>
<a name="ln4044">    return bgp_route_set_add (vty, vty-&gt;index, &quot;origin&quot;, &quot;igp&quot;);</a>
<a name="ln4045">  if (strncmp (argv[0], &quot;egp&quot;, 1) == 0)</a>
<a name="ln4046">    return bgp_route_set_add (vty, vty-&gt;index, &quot;origin&quot;, &quot;egp&quot;);</a>
<a name="ln4047">  if (strncmp (argv[0], &quot;incomplete&quot;, 2) == 0)</a>
<a name="ln4048">    return bgp_route_set_add (vty, vty-&gt;index, &quot;origin&quot;, &quot;incomplete&quot;);</a>
<a name="ln4049"> </a>
<a name="ln4050">  return CMD_WARNING;</a>
<a name="ln4051">}</a>
<a name="ln4052"> </a>
<a name="ln4053">DEFUN (no_set_origin,</a>
<a name="ln4054">       no_set_origin_cmd,</a>
<a name="ln4055">       &quot;no set origin&quot;,</a>
<a name="ln4056">       NO_STR</a>
<a name="ln4057">       SET_STR</a>
<a name="ln4058">       &quot;BGP origin code\n&quot;)</a>
<a name="ln4059">{</a>
<a name="ln4060">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;origin&quot;, NULL);</a>
<a name="ln4061">}</a>
<a name="ln4062"> </a>
<a name="ln4063">ALIAS (no_set_origin,</a>
<a name="ln4064">       no_set_origin_val_cmd,</a>
<a name="ln4065">       &quot;no set origin (egp|igp|incomplete)&quot;,</a>
<a name="ln4066">       NO_STR</a>
<a name="ln4067">       SET_STR</a>
<a name="ln4068">       &quot;BGP origin code\n&quot;</a>
<a name="ln4069">       &quot;remote EGP\n&quot;</a>
<a name="ln4070">       &quot;local IGP\n&quot;</a>
<a name="ln4071">       &quot;unknown heritage\n&quot;)</a>
<a name="ln4072"> </a>
<a name="ln4073">DEFUN (set_atomic_aggregate,</a>
<a name="ln4074">       set_atomic_aggregate_cmd,</a>
<a name="ln4075">       &quot;set atomic-aggregate&quot;,</a>
<a name="ln4076">       SET_STR</a>
<a name="ln4077">       &quot;BGP atomic aggregate attribute\n&quot; )</a>
<a name="ln4078">{</a>
<a name="ln4079">  return bgp_route_set_add (vty, vty-&gt;index, &quot;atomic-aggregate&quot;, NULL);</a>
<a name="ln4080">}</a>
<a name="ln4081"> </a>
<a name="ln4082">DEFUN (no_set_atomic_aggregate,</a>
<a name="ln4083">       no_set_atomic_aggregate_cmd,</a>
<a name="ln4084">       &quot;no set atomic-aggregate&quot;,</a>
<a name="ln4085">       NO_STR</a>
<a name="ln4086">       SET_STR</a>
<a name="ln4087">       &quot;BGP atomic aggregate attribute\n&quot; )</a>
<a name="ln4088">{</a>
<a name="ln4089">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;atomic-aggregate&quot;, NULL);</a>
<a name="ln4090">}</a>
<a name="ln4091"> </a>
<a name="ln4092">DEFUN (set_aggregator_as,</a>
<a name="ln4093">       set_aggregator_as_cmd,</a>
<a name="ln4094">       &quot;set aggregator as &quot; CMD_AS_RANGE &quot; A.B.C.D&quot;,</a>
<a name="ln4095">       SET_STR</a>
<a name="ln4096">       &quot;BGP aggregator attribute\n&quot;</a>
<a name="ln4097">       &quot;AS number of aggregator\n&quot;</a>
<a name="ln4098">       &quot;AS number\n&quot;</a>
<a name="ln4099">       &quot;IP address of aggregator\n&quot;)</a>
<a name="ln4100">{</a>
<a name="ln4101">  int ret;</a>
<a name="ln4102">  as_t as __attribute__((unused)); /* dummy for VTY_GET_INTEGER_RANGE */</a>
<a name="ln4103">  struct in_addr address;</a>
<a name="ln4104">  char *argstr;</a>
<a name="ln4105"> </a>
<a name="ln4106">  VTY_GET_INTEGER_RANGE (&quot;AS&quot;, as, argv[0], 1, BGP_AS4_MAX);</a>
<a name="ln4107">  </a>
<a name="ln4108">  ret = inet_aton (argv[1], &amp;address);</a>
<a name="ln4109">  if (ret == 0)</a>
<a name="ln4110">    {</a>
<a name="ln4111">      vty_out (vty, &quot;Aggregator IP address is invalid%s&quot;, VTY_NEWLINE);</a>
<a name="ln4112">      return CMD_WARNING;</a>
<a name="ln4113">    }</a>
<a name="ln4114"> </a>
<a name="ln4115">  argstr = XMALLOC (MTYPE_ROUTE_MAP_COMPILED,</a>
<a name="ln4116">		    strlen (argv[0]) + strlen (argv[1]) + 2);</a>
<a name="ln4117"> </a>
<a name="ln4118">  sprintf (argstr, &quot;%s %s&quot;, argv[0], argv[1]);</a>
<a name="ln4119"> </a>
<a name="ln4120">  ret = bgp_route_set_add (vty, vty-&gt;index, &quot;aggregator as&quot;, argstr);</a>
<a name="ln4121"> </a>
<a name="ln4122">  XFREE (MTYPE_ROUTE_MAP_COMPILED, argstr);</a>
<a name="ln4123"> </a>
<a name="ln4124">  return ret;</a>
<a name="ln4125">}</a>
<a name="ln4126"> </a>
<a name="ln4127">DEFUN (no_set_aggregator_as,</a>
<a name="ln4128">       no_set_aggregator_as_cmd,</a>
<a name="ln4129">       &quot;no set aggregator as&quot;,</a>
<a name="ln4130">       NO_STR</a>
<a name="ln4131">       SET_STR</a>
<a name="ln4132">       &quot;BGP aggregator attribute\n&quot;</a>
<a name="ln4133">       &quot;AS number of aggregator\n&quot;)</a>
<a name="ln4134">{</a>
<a name="ln4135">  int ret;</a>
<a name="ln4136">  as_t as __attribute__((unused)); /* dummy for VTY_GET_INTEGER_RANGE */</a>
<a name="ln4137">  struct in_addr address;</a>
<a name="ln4138">  char *argstr;</a>
<a name="ln4139"> </a>
<a name="ln4140">  if (argv == 0)</a>
<a name="ln4141">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;aggregator as&quot;, NULL);</a>
<a name="ln4142">  </a>
<a name="ln4143">  VTY_GET_INTEGER_RANGE (&quot;AS&quot;, as, argv[0], 1, BGP_AS4_MAX);</a>
<a name="ln4144"> </a>
<a name="ln4145">  ret = inet_aton (argv[1], &amp;address);</a>
<a name="ln4146">  if (ret == 0)</a>
<a name="ln4147">    {</a>
<a name="ln4148">      vty_out (vty, &quot;Aggregator IP address is invalid%s&quot;, VTY_NEWLINE);</a>
<a name="ln4149">      return CMD_WARNING;</a>
<a name="ln4150">    }</a>
<a name="ln4151"> </a>
<a name="ln4152">  argstr = XMALLOC (MTYPE_ROUTE_MAP_COMPILED,</a>
<a name="ln4153">		    strlen (argv[0]) + strlen (argv[1]) + 2);</a>
<a name="ln4154"> </a>
<a name="ln4155">  sprintf (argstr, &quot;%s %s&quot;, argv[0], argv[1]);</a>
<a name="ln4156"> </a>
<a name="ln4157">  ret = bgp_route_set_delete (vty, vty-&gt;index, &quot;aggregator as&quot;, argstr);</a>
<a name="ln4158"> </a>
<a name="ln4159">  XFREE (MTYPE_ROUTE_MAP_COMPILED, argstr);</a>
<a name="ln4160"> </a>
<a name="ln4161">  return ret;</a>
<a name="ln4162">}</a>
<a name="ln4163"> </a>
<a name="ln4164">ALIAS (no_set_aggregator_as,</a>
<a name="ln4165">       no_set_aggregator_as_val_cmd,</a>
<a name="ln4166">       &quot;no set aggregator as &quot; CMD_AS_RANGE &quot; A.B.C.D&quot;,</a>
<a name="ln4167">       NO_STR</a>
<a name="ln4168">       SET_STR</a>
<a name="ln4169">       &quot;BGP aggregator attribute\n&quot;</a>
<a name="ln4170">       &quot;AS number of aggregator\n&quot;</a>
<a name="ln4171">       &quot;AS number\n&quot;</a>
<a name="ln4172">       &quot;IP address of aggregator\n&quot;)</a>
<a name="ln4173"> </a>
<a name="ln4174">DEFUN (set_tag,</a>
<a name="ln4175">       set_tag_cmd,</a>
<a name="ln4176">       &quot;set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln4177">       SET_STR</a>
<a name="ln4178">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln4179">       &quot;Tag value\n&quot;)</a>
<a name="ln4180">{</a>
<a name="ln4181">  return bgp_route_set_add (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln4182">}</a>
<a name="ln4183"> </a>
<a name="ln4184">DEFUN (no_set_tag,</a>
<a name="ln4185">       no_set_tag_cmd,</a>
<a name="ln4186">       &quot;no set tag&quot;,</a>
<a name="ln4187">       NO_STR</a>
<a name="ln4188">       SET_STR</a>
<a name="ln4189">       &quot;Tag value for routing protocol\n&quot;)</a>
<a name="ln4190">{</a>
<a name="ln4191">  if (argc == 0)</a>
<a name="ln4192">      bgp_route_set_delete(vty, vty-&gt;index, &quot;tag&quot;, NULL);</a>
<a name="ln4193"> </a>
<a name="ln4194">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;tag&quot;, argv[0]);</a>
<a name="ln4195">}</a>
<a name="ln4196"> </a>
<a name="ln4197">ALIAS (no_set_tag,</a>
<a name="ln4198">       no_set_tag_val_cmd,</a>
<a name="ln4199">       &quot;no set tag &lt;1-4294967295&gt;&quot;,</a>
<a name="ln4200">       NO_STR</a>
<a name="ln4201">       SET_STR</a>
<a name="ln4202">       &quot;Tag value for routing protocol\n&quot;</a>
<a name="ln4203">       &quot;Tag value\n&quot;)</a>
<a name="ln4204"> </a>
<a name="ln4205"> </a>
<a name="ln4206">DEFUN (match_ipv6_address, </a>
<a name="ln4207">       match_ipv6_address_cmd,</a>
<a name="ln4208">       &quot;match ipv6 address WORD&quot;,</a>
<a name="ln4209">       MATCH_STR</a>
<a name="ln4210">       IPV6_STR</a>
<a name="ln4211">       &quot;Match IPv6 address of route\n&quot;</a>
<a name="ln4212">       &quot;IPv6 access-list name\n&quot;)</a>
<a name="ln4213">{</a>
<a name="ln4214">  return bgp_route_match_add (vty, vty-&gt;index, &quot;ipv6 address&quot;, argv[0]);</a>
<a name="ln4215">}</a>
<a name="ln4216"> </a>
<a name="ln4217">DEFUN (no_match_ipv6_address, </a>
<a name="ln4218">       no_match_ipv6_address_cmd,</a>
<a name="ln4219">       &quot;no match ipv6 address WORD&quot;,</a>
<a name="ln4220">       NO_STR</a>
<a name="ln4221">       MATCH_STR</a>
<a name="ln4222">       IPV6_STR</a>
<a name="ln4223">       &quot;Match IPv6 address of route\n&quot;</a>
<a name="ln4224">       &quot;IPv6 access-list name\n&quot;)</a>
<a name="ln4225">{</a>
<a name="ln4226">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;ipv6 address&quot;, argv[0]);</a>
<a name="ln4227">}</a>
<a name="ln4228"> </a>
<a name="ln4229">DEFUN (match_ipv6_next_hop, </a>
<a name="ln4230">       match_ipv6_next_hop_cmd,</a>
<a name="ln4231">       &quot;match ipv6 next-hop X:X::X:X&quot;,</a>
<a name="ln4232">       MATCH_STR</a>
<a name="ln4233">       IPV6_STR</a>
<a name="ln4234">       &quot;Match IPv6 next-hop address of route\n&quot;</a>
<a name="ln4235">       &quot;IPv6 address of next hop\n&quot;)</a>
<a name="ln4236">{</a>
<a name="ln4237">  return bgp_route_match_add (vty, vty-&gt;index, &quot;ipv6 next-hop&quot;, argv[0]);</a>
<a name="ln4238">}</a>
<a name="ln4239"> </a>
<a name="ln4240">DEFUN (no_match_ipv6_next_hop,</a>
<a name="ln4241">       no_match_ipv6_next_hop_cmd,</a>
<a name="ln4242">       &quot;no match ipv6 next-hop X:X::X:X&quot;,</a>
<a name="ln4243">       NO_STR</a>
<a name="ln4244">       MATCH_STR</a>
<a name="ln4245">       IPV6_STR</a>
<a name="ln4246">       &quot;Match IPv6 next-hop address of route\n&quot;</a>
<a name="ln4247">       &quot;IPv6 address of next hop\n&quot;)</a>
<a name="ln4248">{</a>
<a name="ln4249">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;ipv6 next-hop&quot;, argv[0]);</a>
<a name="ln4250">}</a>
<a name="ln4251"> </a>
<a name="ln4252">DEFUN (match_ipv6_address_prefix_list, </a>
<a name="ln4253">       match_ipv6_address_prefix_list_cmd,</a>
<a name="ln4254">       &quot;match ipv6 address prefix-list WORD&quot;,</a>
<a name="ln4255">       MATCH_STR</a>
<a name="ln4256">       IPV6_STR</a>
<a name="ln4257">       &quot;Match address of route\n&quot;</a>
<a name="ln4258">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln4259">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln4260">{</a>
<a name="ln4261">  return bgp_route_match_add (vty, vty-&gt;index, &quot;ipv6 address prefix-list&quot;, argv[0]);</a>
<a name="ln4262">}</a>
<a name="ln4263"> </a>
<a name="ln4264">DEFUN (no_match_ipv6_address_prefix_list,</a>
<a name="ln4265">       no_match_ipv6_address_prefix_list_cmd,</a>
<a name="ln4266">       &quot;no match ipv6 address prefix-list WORD&quot;,</a>
<a name="ln4267">       NO_STR</a>
<a name="ln4268">       MATCH_STR</a>
<a name="ln4269">       IPV6_STR</a>
<a name="ln4270">       &quot;Match address of route\n&quot;</a>
<a name="ln4271">       &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln4272">       &quot;IP prefix-list name\n&quot;)</a>
<a name="ln4273">{</a>
<a name="ln4274">  return bgp_route_match_delete (vty, vty-&gt;index, &quot;ipv6 address prefix-list&quot;, argv[0]);</a>
<a name="ln4275">}</a>
<a name="ln4276"> </a>
<a name="ln4277">DEFUN (set_ipv6_nexthop_peer,</a>
<a name="ln4278">       set_ipv6_nexthop_peer_cmd,</a>
<a name="ln4279">       &quot;set ipv6 next-hop peer-address&quot;,</a>
<a name="ln4280">       SET_STR</a>
<a name="ln4281">       IPV6_STR</a>
<a name="ln4282">       &quot;Next hop address\n&quot;</a>
<a name="ln4283">       &quot;Use peer address (for BGP only)\n&quot;)</a>
<a name="ln4284">{</a>
<a name="ln4285">  return bgp_route_set_add (vty, vty-&gt;index, &quot;ipv6 next-hop peer-address&quot;, NULL);</a>
<a name="ln4286">}</a>
<a name="ln4287"> </a>
<a name="ln4288">DEFUN (no_set_ipv6_nexthop_peer,</a>
<a name="ln4289">       no_set_ipv6_nexthop_peer_cmd,</a>
<a name="ln4290">       &quot;no set ipv6 next-hop peer-address&quot;,</a>
<a name="ln4291">       NO_STR</a>
<a name="ln4292">       SET_STR</a>
<a name="ln4293">       IPV6_STR</a>
<a name="ln4294">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln4295">       )</a>
<a name="ln4296">{</a>
<a name="ln4297">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;ipv6 next-hop&quot;, argv[0]);</a>
<a name="ln4298">}</a>
<a name="ln4299"> </a>
<a name="ln4300">DEFUN (set_ipv6_nexthop_global,</a>
<a name="ln4301">       set_ipv6_nexthop_global_cmd,</a>
<a name="ln4302">       &quot;set ipv6 next-hop global X:X::X:X&quot;,</a>
<a name="ln4303">       SET_STR</a>
<a name="ln4304">       IPV6_STR</a>
<a name="ln4305">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln4306">       &quot;IPv6 global address\n&quot;</a>
<a name="ln4307">       &quot;IPv6 address of next hop\n&quot;)</a>
<a name="ln4308">{</a>
<a name="ln4309">  return bgp_route_set_add (vty, vty-&gt;index, &quot;ipv6 next-hop global&quot;, argv[0]);</a>
<a name="ln4310">}</a>
<a name="ln4311"> </a>
<a name="ln4312">DEFUN (no_set_ipv6_nexthop_global,</a>
<a name="ln4313">       no_set_ipv6_nexthop_global_cmd,</a>
<a name="ln4314">       &quot;no set ipv6 next-hop global&quot;,</a>
<a name="ln4315">       NO_STR</a>
<a name="ln4316">       SET_STR</a>
<a name="ln4317">       IPV6_STR</a>
<a name="ln4318">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln4319">       &quot;IPv6 global address\n&quot;)</a>
<a name="ln4320">{</a>
<a name="ln4321">  if (argc == 0)</a>
<a name="ln4322">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;ipv6 next-hop global&quot;, NULL);</a>
<a name="ln4323"> </a>
<a name="ln4324">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;ipv6 next-hop global&quot;, argv[0]);</a>
<a name="ln4325">}</a>
<a name="ln4326"> </a>
<a name="ln4327">ALIAS (no_set_ipv6_nexthop_global,</a>
<a name="ln4328">       no_set_ipv6_nexthop_global_val_cmd,</a>
<a name="ln4329">       &quot;no set ipv6 next-hop global X:X::X:X&quot;,</a>
<a name="ln4330">       NO_STR</a>
<a name="ln4331">       SET_STR</a>
<a name="ln4332">       IPV6_STR</a>
<a name="ln4333">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln4334">       &quot;IPv6 global address\n&quot;</a>
<a name="ln4335">       &quot;IPv6 address of next hop\n&quot;)</a>
<a name="ln4336"> </a>
<a name="ln4337">DEFUN (set_ipv6_nexthop_local,</a>
<a name="ln4338">       set_ipv6_nexthop_local_cmd,</a>
<a name="ln4339">       &quot;set ipv6 next-hop local X:X::X:X&quot;,</a>
<a name="ln4340">       SET_STR</a>
<a name="ln4341">       IPV6_STR</a>
<a name="ln4342">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln4343">       &quot;IPv6 local address\n&quot;</a>
<a name="ln4344">       &quot;IPv6 address of next hop\n&quot;)</a>
<a name="ln4345">{</a>
<a name="ln4346">  return bgp_route_set_add (vty, vty-&gt;index, &quot;ipv6 next-hop local&quot;, argv[0]);</a>
<a name="ln4347">}</a>
<a name="ln4348"> </a>
<a name="ln4349">DEFUN (no_set_ipv6_nexthop_local,</a>
<a name="ln4350">       no_set_ipv6_nexthop_local_cmd,</a>
<a name="ln4351">       &quot;no set ipv6 next-hop local&quot;,</a>
<a name="ln4352">       NO_STR</a>
<a name="ln4353">       SET_STR</a>
<a name="ln4354">       IPV6_STR</a>
<a name="ln4355">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln4356">       &quot;IPv6 local address\n&quot;)</a>
<a name="ln4357">{</a>
<a name="ln4358">  if (argc == 0)</a>
<a name="ln4359">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;ipv6 next-hop local&quot;, NULL);</a>
<a name="ln4360">  </a>
<a name="ln4361">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;ipv6 next-hop local&quot;, argv[0]);</a>
<a name="ln4362">}</a>
<a name="ln4363"> </a>
<a name="ln4364">ALIAS (no_set_ipv6_nexthop_local,</a>
<a name="ln4365">       no_set_ipv6_nexthop_local_val_cmd,</a>
<a name="ln4366">       &quot;no set ipv6 next-hop local X:X::X:X&quot;,</a>
<a name="ln4367">       NO_STR</a>
<a name="ln4368">       SET_STR</a>
<a name="ln4369">       IPV6_STR</a>
<a name="ln4370">       &quot;IPv6 next-hop address\n&quot;</a>
<a name="ln4371">       &quot;IPv6 local address\n&quot;</a>
<a name="ln4372">       &quot;IPv6 address of next hop\n&quot;)</a>
<a name="ln4373"> </a>
<a name="ln4374">DEFUN (set_vpnv4_nexthop,</a>
<a name="ln4375">       set_vpnv4_nexthop_cmd,</a>
<a name="ln4376">       &quot;set vpnv4 next-hop A.B.C.D&quot;,</a>
<a name="ln4377">       SET_STR</a>
<a name="ln4378">       &quot;VPNv4 information\n&quot;</a>
<a name="ln4379">       &quot;VPNv4 next-hop address\n&quot;</a>
<a name="ln4380">       &quot;IP address of next hop\n&quot;)</a>
<a name="ln4381">{</a>
<a name="ln4382">  return bgp_route_set_add (vty, vty-&gt;index, &quot;vpnv4 next-hop&quot;, argv[0]);</a>
<a name="ln4383">}</a>
<a name="ln4384"> </a>
<a name="ln4385">DEFUN (no_set_vpnv4_nexthop,</a>
<a name="ln4386">       no_set_vpnv4_nexthop_cmd,</a>
<a name="ln4387">       &quot;no set vpnv4 next-hop&quot;,</a>
<a name="ln4388">       NO_STR</a>
<a name="ln4389">       SET_STR</a>
<a name="ln4390">       &quot;VPNv4 information\n&quot;</a>
<a name="ln4391">       &quot;VPNv4 next-hop address\n&quot;)</a>
<a name="ln4392">{</a>
<a name="ln4393">  if (argc == 0)</a>
<a name="ln4394">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;vpnv4 next-hop&quot;, NULL);</a>
<a name="ln4395"> </a>
<a name="ln4396">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;vpnv4 next-hop&quot;, argv[0]);</a>
<a name="ln4397">}</a>
<a name="ln4398"> </a>
<a name="ln4399">ALIAS (no_set_vpnv4_nexthop,</a>
<a name="ln4400">       no_set_vpnv4_nexthop_val_cmd,</a>
<a name="ln4401">       &quot;no set vpnv4 next-hop A.B.C.D&quot;,</a>
<a name="ln4402">       NO_STR</a>
<a name="ln4403">       SET_STR</a>
<a name="ln4404">       &quot;VPNv4 information\n&quot;</a>
<a name="ln4405">       &quot;VPNv4 next-hop address\n&quot;</a>
<a name="ln4406">       &quot;IP address of next hop\n&quot;)</a>
<a name="ln4407"> </a>
<a name="ln4408">DEFUN (set_originator_id,</a>
<a name="ln4409">       set_originator_id_cmd,</a>
<a name="ln4410">       &quot;set originator-id A.B.C.D&quot;,</a>
<a name="ln4411">       SET_STR</a>
<a name="ln4412">       &quot;BGP originator ID attribute\n&quot;</a>
<a name="ln4413">       &quot;IP address of originator\n&quot;)</a>
<a name="ln4414">{</a>
<a name="ln4415">  return bgp_route_set_add (vty, vty-&gt;index, &quot;originator-id&quot;, argv[0]);</a>
<a name="ln4416">}</a>
<a name="ln4417"> </a>
<a name="ln4418">DEFUN (no_set_originator_id,</a>
<a name="ln4419">       no_set_originator_id_cmd,</a>
<a name="ln4420">       &quot;no set originator-id&quot;,</a>
<a name="ln4421">       NO_STR</a>
<a name="ln4422">       SET_STR</a>
<a name="ln4423">       &quot;BGP originator ID attribute\n&quot;)</a>
<a name="ln4424">{</a>
<a name="ln4425">  if (argc == 0)</a>
<a name="ln4426">    return bgp_route_set_delete (vty, vty-&gt;index, &quot;originator-id&quot;, NULL);</a>
<a name="ln4427">  </a>
<a name="ln4428">  return bgp_route_set_delete (vty, vty-&gt;index, &quot;originator-id&quot;, argv[0]);</a>
<a name="ln4429">}</a>
<a name="ln4430"> </a>
<a name="ln4431">ALIAS (no_set_originator_id,</a>
<a name="ln4432">       no_set_originator_id_val_cmd,</a>
<a name="ln4433">       &quot;no set originator-id A.B.C.D&quot;,</a>
<a name="ln4434">       NO_STR</a>
<a name="ln4435">       SET_STR</a>
<a name="ln4436">       &quot;BGP originator ID attribute\n&quot;</a>
<a name="ln4437">       &quot;IP address of originator\n&quot;)</a>
<a name="ln4438"> </a>
<a name="ln4439">DEFUN_DEPRECATED (set_pathlimit_ttl,</a>
<a name="ln4440">       set_pathlimit_ttl_cmd,</a>
<a name="ln4441">       &quot;set pathlimit ttl &lt;1-255&gt;&quot;,</a>
<a name="ln4442">       SET_STR</a>
<a name="ln4443">       &quot;BGP AS-Pathlimit attribute\n&quot;</a>
<a name="ln4444">       &quot;Set AS-Path Hop-count TTL\n&quot;)</a>
<a name="ln4445">{</a>
<a name="ln4446">  return CMD_SUCCESS;</a>
<a name="ln4447">}</a>
<a name="ln4448"> </a>
<a name="ln4449">DEFUN_DEPRECATED (no_set_pathlimit_ttl,</a>
<a name="ln4450">       no_set_pathlimit_ttl_cmd,</a>
<a name="ln4451">       &quot;no set pathlimit ttl&quot;,</a>
<a name="ln4452">       NO_STR</a>
<a name="ln4453">       SET_STR</a>
<a name="ln4454">       &quot;BGP AS-Pathlimit attribute\n&quot;</a>
<a name="ln4455">       &quot;Set AS-Path Hop-count TTL\n&quot;)</a>
<a name="ln4456">{</a>
<a name="ln4457">  return CMD_SUCCESS;</a>
<a name="ln4458">}</a>
<a name="ln4459"> </a>
<a name="ln4460">ALIAS (no_set_pathlimit_ttl,</a>
<a name="ln4461">       no_set_pathlimit_ttl_val_cmd,</a>
<a name="ln4462">       &quot;no set pathlimit ttl &lt;1-255&gt;&quot;,</a>
<a name="ln4463">       NO_STR</a>
<a name="ln4464">       MATCH_STR</a>
<a name="ln4465">       &quot;BGP AS-Pathlimit attribute\n&quot;</a>
<a name="ln4466">       &quot;Set AS-Path Hop-count TTL\n&quot;)</a>
<a name="ln4467"> </a>
<a name="ln4468">DEFUN_DEPRECATED (match_pathlimit_as,</a>
<a name="ln4469">       match_pathlimit_as_cmd,</a>
<a name="ln4470">       &quot;match pathlimit as &lt;1-65535&gt;&quot;,</a>
<a name="ln4471">       MATCH_STR</a>
<a name="ln4472">       &quot;BGP AS-Pathlimit attribute\n&quot;</a>
<a name="ln4473">       &quot;Match Pathlimit AS number\n&quot;)</a>
<a name="ln4474">{</a>
<a name="ln4475">  return CMD_SUCCESS;</a>
<a name="ln4476">}</a>
<a name="ln4477"> </a>
<a name="ln4478">DEFUN_DEPRECATED (no_match_pathlimit_as,</a>
<a name="ln4479">       no_match_pathlimit_as_cmd,</a>
<a name="ln4480">       &quot;no match pathlimit as&quot;,</a>
<a name="ln4481">       NO_STR</a>
<a name="ln4482">       MATCH_STR</a>
<a name="ln4483">       &quot;BGP AS-Pathlimit attribute\n&quot;</a>
<a name="ln4484">       &quot;Match Pathlimit AS number\n&quot;)</a>
<a name="ln4485">{</a>
<a name="ln4486">  return CMD_SUCCESS;</a>
<a name="ln4487">}</a>
<a name="ln4488"> </a>
<a name="ln4489">ALIAS (no_match_pathlimit_as,</a>
<a name="ln4490">       no_match_pathlimit_as_val_cmd,</a>
<a name="ln4491">       &quot;no match pathlimit as &lt;1-65535&gt;&quot;,</a>
<a name="ln4492">       NO_STR</a>
<a name="ln4493">       MATCH_STR</a>
<a name="ln4494">       &quot;BGP AS-Pathlimit attribute\n&quot;</a>
<a name="ln4495">       &quot;Match Pathlimit ASN\n&quot;)</a>
<a name="ln4496"> </a>
<a name="ln4497"> </a>
<a name="ln4498">/* Initialization of route map. */</a>
<a name="ln4499">void</a>
<a name="ln4500">bgp_route_map_init (void)</a>
<a name="ln4501">{</a>
<a name="ln4502">  route_map_init ();</a>
<a name="ln4503">  route_map_init_vty ();</a>
<a name="ln4504">  route_map_add_hook (bgp_route_map_update);</a>
<a name="ln4505">  route_map_delete_hook (bgp_route_map_update);</a>
<a name="ln4506"> </a>
<a name="ln4507">  route_map_install_match (&amp;route_match_peer_cmd);</a>
<a name="ln4508">  route_map_install_match (&amp;route_match_local_pref_cmd);</a>
<a name="ln4509">  route_map_install_match (&amp;route_match_ip_address_cmd);</a>
<a name="ln4510">  route_map_install_match (&amp;route_match_ip_next_hop_cmd);</a>
<a name="ln4511">  route_map_install_match (&amp;route_match_ip_route_source_cmd);</a>
<a name="ln4512">  route_map_install_match (&amp;route_match_ip_address_prefix_list_cmd);</a>
<a name="ln4513">  route_map_install_match (&amp;route_match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln4514">  route_map_install_match (&amp;route_match_ip_route_source_prefix_list_cmd);</a>
<a name="ln4515">  route_map_install_match (&amp;route_match_aspath_cmd);</a>
<a name="ln4516">  route_map_install_match (&amp;route_match_community_cmd);</a>
<a name="ln4517">  route_map_install_match (&amp;route_match_lcommunity_cmd);</a>
<a name="ln4518">  route_map_install_match (&amp;route_match_ecommunity_cmd);</a>
<a name="ln4519">  route_map_install_match (&amp;route_match_local_pref_cmd);</a>
<a name="ln4520">  route_map_install_match (&amp;route_match_metric_cmd);</a>
<a name="ln4521">  route_map_install_match (&amp;route_match_origin_cmd);</a>
<a name="ln4522">  route_map_install_match (&amp;route_match_probability_cmd);</a>
<a name="ln4523">  route_map_install_match (&amp;route_match_tag_cmd);</a>
<a name="ln4524"> </a>
<a name="ln4525">  route_map_install_set (&amp;route_set_ip_nexthop_cmd);</a>
<a name="ln4526">  route_map_install_set (&amp;route_set_local_pref_cmd);</a>
<a name="ln4527">  route_map_install_set (&amp;route_set_weight_cmd);</a>
<a name="ln4528">  route_map_install_set (&amp;route_set_metric_cmd);</a>
<a name="ln4529">  route_map_install_set (&amp;route_set_aspath_prepend_cmd);</a>
<a name="ln4530">  route_map_install_set (&amp;route_set_aspath_exclude_cmd);</a>
<a name="ln4531">  route_map_install_set (&amp;route_set_origin_cmd);</a>
<a name="ln4532">  route_map_install_set (&amp;route_set_atomic_aggregate_cmd);</a>
<a name="ln4533">  route_map_install_set (&amp;route_set_aggregator_as_cmd);</a>
<a name="ln4534">  route_map_install_set (&amp;route_set_community_cmd);</a>
<a name="ln4535">  route_map_install_set (&amp;route_set_community_delete_cmd);</a>
<a name="ln4536">  route_map_install_set (&amp;route_set_lcommunity_cmd);</a>
<a name="ln4537">  route_map_install_set (&amp;route_set_lcommunity_delete_cmd);</a>
<a name="ln4538">  route_map_install_set (&amp;route_set_vpnv4_nexthop_cmd);</a>
<a name="ln4539">  route_map_install_set (&amp;route_set_originator_id_cmd);</a>
<a name="ln4540">  route_map_install_set (&amp;route_set_ecommunity_rt_cmd);</a>
<a name="ln4541">  route_map_install_set (&amp;route_set_ecommunity_soo_cmd);</a>
<a name="ln4542">  route_map_install_set (&amp;route_set_tag_cmd);</a>
<a name="ln4543"> </a>
<a name="ln4544">  install_element (RMAP_NODE, &amp;match_peer_cmd);</a>
<a name="ln4545">  install_element (RMAP_NODE, &amp;match_peer_local_cmd);</a>
<a name="ln4546">  install_element (RMAP_NODE, &amp;no_match_peer_cmd);</a>
<a name="ln4547">  install_element (RMAP_NODE, &amp;no_match_peer_val_cmd);</a>
<a name="ln4548">  install_element (RMAP_NODE, &amp;no_match_peer_local_cmd);</a>
<a name="ln4549">  install_element (RMAP_NODE, &amp;match_ip_address_cmd);</a>
<a name="ln4550">  install_element (RMAP_NODE, &amp;no_match_ip_address_cmd);</a>
<a name="ln4551">  install_element (RMAP_NODE, &amp;no_match_ip_address_val_cmd);</a>
<a name="ln4552">  install_element (RMAP_NODE, &amp;match_ip_next_hop_cmd);</a>
<a name="ln4553">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_cmd);</a>
<a name="ln4554">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_val_cmd);</a>
<a name="ln4555">  install_element (RMAP_NODE, &amp;match_ip_route_source_cmd);</a>
<a name="ln4556">  install_element (RMAP_NODE, &amp;no_match_ip_route_source_cmd);</a>
<a name="ln4557">  install_element (RMAP_NODE, &amp;no_match_ip_route_source_val_cmd);</a>
<a name="ln4558">  install_element (RMAP_NODE, &amp;match_ip_address_prefix_list_cmd);</a>
<a name="ln4559">  install_element (RMAP_NODE, &amp;no_match_ip_address_prefix_list_cmd);</a>
<a name="ln4560">  install_element (RMAP_NODE, &amp;no_match_ip_address_prefix_list_val_cmd);</a>
<a name="ln4561">  install_element (RMAP_NODE, &amp;match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln4562">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_prefix_list_cmd);</a>
<a name="ln4563">  install_element (RMAP_NODE, &amp;no_match_ip_next_hop_prefix_list_val_cmd);</a>
<a name="ln4564">  install_element (RMAP_NODE, &amp;match_ip_route_source_prefix_list_cmd);</a>
<a name="ln4565">  install_element (RMAP_NODE, &amp;no_match_ip_route_source_prefix_list_cmd);</a>
<a name="ln4566">  install_element (RMAP_NODE, &amp;no_match_ip_route_source_prefix_list_val_cmd);</a>
<a name="ln4567"> </a>
<a name="ln4568">  install_element (RMAP_NODE, &amp;match_aspath_cmd);</a>
<a name="ln4569">  install_element (RMAP_NODE, &amp;no_match_aspath_cmd);</a>
<a name="ln4570">  install_element (RMAP_NODE, &amp;no_match_aspath_val_cmd);</a>
<a name="ln4571">  install_element (RMAP_NODE, &amp;match_metric_cmd);</a>
<a name="ln4572">  install_element (RMAP_NODE, &amp;no_match_metric_cmd);</a>
<a name="ln4573">  install_element (RMAP_NODE, &amp;no_match_metric_val_cmd);</a>
<a name="ln4574">  install_element (RMAP_NODE, &amp;match_local_pref_cmd);</a>
<a name="ln4575">  install_element (RMAP_NODE, &amp;no_match_local_pref_cmd);</a>
<a name="ln4576">  install_element (RMAP_NODE, &amp;no_match_local_pref_val_cmd);</a>
<a name="ln4577">  install_element (RMAP_NODE, &amp;match_community_cmd);</a>
<a name="ln4578">  install_element (RMAP_NODE, &amp;match_community_exact_cmd);</a>
<a name="ln4579">  install_element (RMAP_NODE, &amp;no_match_community_cmd);</a>
<a name="ln4580">  install_element (RMAP_NODE, &amp;no_match_community_val_cmd);</a>
<a name="ln4581">  install_element (RMAP_NODE, &amp;no_match_community_exact_cmd);</a>
<a name="ln4582">  install_element (RMAP_NODE, &amp;match_lcommunity_cmd);</a>
<a name="ln4583">  install_element (RMAP_NODE, &amp;no_match_lcommunity_cmd);</a>
<a name="ln4584">  install_element (RMAP_NODE, &amp;match_ecommunity_cmd);</a>
<a name="ln4585">  install_element (RMAP_NODE, &amp;no_match_ecommunity_cmd);</a>
<a name="ln4586">  install_element (RMAP_NODE, &amp;no_match_ecommunity_val_cmd);</a>
<a name="ln4587">  install_element (RMAP_NODE, &amp;match_origin_cmd);</a>
<a name="ln4588">  install_element (RMAP_NODE, &amp;no_match_origin_cmd);</a>
<a name="ln4589">  install_element (RMAP_NODE, &amp;no_match_origin_val_cmd);</a>
<a name="ln4590">  install_element (RMAP_NODE, &amp;match_probability_cmd);</a>
<a name="ln4591">  install_element (RMAP_NODE, &amp;no_match_probability_cmd);</a>
<a name="ln4592">  install_element (RMAP_NODE, &amp;no_match_probability_val_cmd);</a>
<a name="ln4593">  install_element (RMAP_NODE, &amp;match_tag_cmd);</a>
<a name="ln4594">  install_element (RMAP_NODE, &amp;no_match_tag_cmd);</a>
<a name="ln4595">  install_element (RMAP_NODE, &amp;no_match_tag_val_cmd);</a>
<a name="ln4596"> </a>
<a name="ln4597">  install_element (RMAP_NODE, &amp;set_ip_nexthop_cmd);</a>
<a name="ln4598">  install_element (RMAP_NODE, &amp;set_ip_nexthop_peer_cmd);</a>
<a name="ln4599">  install_element (RMAP_NODE, &amp;no_set_ip_nexthop_cmd);</a>
<a name="ln4600">  install_element (RMAP_NODE, &amp;no_set_ip_nexthop_val_cmd);</a>
<a name="ln4601">  install_element (RMAP_NODE, &amp;set_local_pref_cmd);</a>
<a name="ln4602">  install_element (RMAP_NODE, &amp;no_set_local_pref_cmd);</a>
<a name="ln4603">  install_element (RMAP_NODE, &amp;no_set_local_pref_val_cmd);</a>
<a name="ln4604">  install_element (RMAP_NODE, &amp;set_weight_cmd);</a>
<a name="ln4605">  install_element (RMAP_NODE, &amp;no_set_weight_cmd);</a>
<a name="ln4606">  install_element (RMAP_NODE, &amp;no_set_weight_val_cmd);</a>
<a name="ln4607">  install_element (RMAP_NODE, &amp;set_metric_cmd);</a>
<a name="ln4608">  install_element (RMAP_NODE, &amp;set_metric_addsub_cmd);</a>
<a name="ln4609">  install_element (RMAP_NODE, &amp;set_metric_rtt_cmd);</a>
<a name="ln4610">  install_element (RMAP_NODE, &amp;no_set_metric_cmd);</a>
<a name="ln4611">  install_element (RMAP_NODE, &amp;no_set_metric_val_cmd);</a>
<a name="ln4612">  install_element (RMAP_NODE, &amp;set_aspath_prepend_cmd);</a>
<a name="ln4613">  install_element (RMAP_NODE, &amp;set_aspath_prepend_lastas_cmd);</a>
<a name="ln4614">  install_element (RMAP_NODE, &amp;set_aspath_exclude_cmd);</a>
<a name="ln4615">  install_element (RMAP_NODE, &amp;no_set_aspath_prepend_cmd);</a>
<a name="ln4616">  install_element (RMAP_NODE, &amp;no_set_aspath_prepend_val_cmd);</a>
<a name="ln4617">  install_element (RMAP_NODE, &amp;no_set_aspath_exclude_cmd);</a>
<a name="ln4618">  install_element (RMAP_NODE, &amp;no_set_aspath_exclude_val_cmd);</a>
<a name="ln4619">  install_element (RMAP_NODE, &amp;set_origin_cmd);</a>
<a name="ln4620">  install_element (RMAP_NODE, &amp;no_set_origin_cmd);</a>
<a name="ln4621">  install_element (RMAP_NODE, &amp;no_set_origin_val_cmd);</a>
<a name="ln4622">  install_element (RMAP_NODE, &amp;set_atomic_aggregate_cmd);</a>
<a name="ln4623">  install_element (RMAP_NODE, &amp;no_set_atomic_aggregate_cmd);</a>
<a name="ln4624">  install_element (RMAP_NODE, &amp;set_aggregator_as_cmd);</a>
<a name="ln4625">  install_element (RMAP_NODE, &amp;no_set_aggregator_as_cmd);</a>
<a name="ln4626">  install_element (RMAP_NODE, &amp;no_set_aggregator_as_val_cmd);</a>
<a name="ln4627">  install_element (RMAP_NODE, &amp;set_community_cmd);</a>
<a name="ln4628">  install_element (RMAP_NODE, &amp;set_community_none_cmd);</a>
<a name="ln4629">  install_element (RMAP_NODE, &amp;no_set_community_cmd);</a>
<a name="ln4630">  install_element (RMAP_NODE, &amp;no_set_community_val_cmd);</a>
<a name="ln4631">  install_element (RMAP_NODE, &amp;no_set_community_none_cmd);</a>
<a name="ln4632">  install_element (RMAP_NODE, &amp;set_community_delete_cmd);</a>
<a name="ln4633">  install_element (RMAP_NODE, &amp;no_set_community_delete_cmd);</a>
<a name="ln4634">  install_element (RMAP_NODE, &amp;no_set_community_delete_val_cmd);</a>
<a name="ln4635">  install_element (RMAP_NODE, &amp;set_lcommunity_cmd);</a>
<a name="ln4636">  install_element (RMAP_NODE, &amp;set_lcommunity_none_cmd);</a>
<a name="ln4637">  install_element (RMAP_NODE, &amp;no_set_lcommunity_cmd);</a>
<a name="ln4638">  install_element (RMAP_NODE, &amp;no_set_lcommunity_val_cmd);</a>
<a name="ln4639">  install_element (RMAP_NODE, &amp;no_set_lcommunity_none_cmd);</a>
<a name="ln4640">  install_element (RMAP_NODE, &amp;set_lcommunity_delete_cmd);</a>
<a name="ln4641">  install_element (RMAP_NODE, &amp;no_set_lcommunity_delete_cmd);</a>
<a name="ln4642">  install_element (RMAP_NODE, &amp;no_set_lcommunity_delete_val_cmd);</a>
<a name="ln4643">  install_element (RMAP_NODE, &amp;set_ecommunity_rt_cmd);</a>
<a name="ln4644">  install_element (RMAP_NODE, &amp;no_set_ecommunity_rt_cmd);</a>
<a name="ln4645">  install_element (RMAP_NODE, &amp;no_set_ecommunity_rt_val_cmd);</a>
<a name="ln4646">  install_element (RMAP_NODE, &amp;set_ecommunity_soo_cmd);</a>
<a name="ln4647">  install_element (RMAP_NODE, &amp;no_set_ecommunity_soo_cmd);</a>
<a name="ln4648">  install_element (RMAP_NODE, &amp;no_set_ecommunity_soo_val_cmd);</a>
<a name="ln4649">  install_element (RMAP_NODE, &amp;set_vpnv4_nexthop_cmd);</a>
<a name="ln4650">  install_element (RMAP_NODE, &amp;no_set_vpnv4_nexthop_cmd);</a>
<a name="ln4651">  install_element (RMAP_NODE, &amp;no_set_vpnv4_nexthop_val_cmd);</a>
<a name="ln4652">  install_element (RMAP_NODE, &amp;set_originator_id_cmd);</a>
<a name="ln4653">  install_element (RMAP_NODE, &amp;no_set_originator_id_cmd);</a>
<a name="ln4654">  install_element (RMAP_NODE, &amp;no_set_originator_id_val_cmd);</a>
<a name="ln4655">  install_element (RMAP_NODE, &amp;set_tag_cmd);</a>
<a name="ln4656">  install_element (RMAP_NODE, &amp;no_set_tag_cmd);</a>
<a name="ln4657">  install_element (RMAP_NODE, &amp;no_set_tag_val_cmd);</a>
<a name="ln4658"> </a>
<a name="ln4659">  route_map_install_match (&amp;route_match_ipv6_address_cmd);</a>
<a name="ln4660">  route_map_install_match (&amp;route_match_ipv6_next_hop_cmd);</a>
<a name="ln4661">  route_map_install_match (&amp;route_match_ipv6_address_prefix_list_cmd);</a>
<a name="ln4662">  route_map_install_set (&amp;route_set_ipv6_nexthop_global_cmd);</a>
<a name="ln4663">  route_map_install_set (&amp;route_set_ipv6_nexthop_local_cmd);</a>
<a name="ln4664">  route_map_install_set (&amp;route_set_ipv6_nexthop_peer_cmd);</a>
<a name="ln4665"> </a>
<a name="ln4666">  install_element (RMAP_NODE, &amp;match_ipv6_address_cmd);</a>
<a name="ln4667">  install_element (RMAP_NODE, &amp;no_match_ipv6_address_cmd);</a>
<a name="ln4668">  install_element (RMAP_NODE, &amp;match_ipv6_next_hop_cmd);</a>
<a name="ln4669">  install_element (RMAP_NODE, &amp;no_match_ipv6_next_hop_cmd);</a>
<a name="ln4670">  install_element (RMAP_NODE, &amp;match_ipv6_address_prefix_list_cmd);</a>
<a name="ln4671">  install_element (RMAP_NODE, &amp;no_match_ipv6_address_prefix_list_cmd);</a>
<a name="ln4672">  install_element (RMAP_NODE, &amp;set_ipv6_nexthop_global_cmd);</a>
<a name="ln4673">  install_element (RMAP_NODE, &amp;no_set_ipv6_nexthop_global_cmd);</a>
<a name="ln4674">  install_element (RMAP_NODE, &amp;no_set_ipv6_nexthop_global_val_cmd);</a>
<a name="ln4675">  install_element (RMAP_NODE, &amp;set_ipv6_nexthop_local_cmd);</a>
<a name="ln4676">  install_element (RMAP_NODE, &amp;no_set_ipv6_nexthop_local_cmd);</a>
<a name="ln4677">  install_element (RMAP_NODE, &amp;no_set_ipv6_nexthop_local_val_cmd);</a>
<a name="ln4678">  install_element (RMAP_NODE, &amp;set_ipv6_nexthop_peer_cmd);</a>
<a name="ln4679">  install_element (RMAP_NODE, &amp;no_set_ipv6_nexthop_peer_cmd);</a>
<a name="ln4680"> </a>
<a name="ln4681">  /* AS-Pathlimit: functionality removed, commands kept for</a>
<a name="ln4682">   * compatibility.</a>
<a name="ln4683">   */</a>
<a name="ln4684">  install_element (RMAP_NODE, &amp;set_pathlimit_ttl_cmd);</a>
<a name="ln4685">  install_element (RMAP_NODE, &amp;no_set_pathlimit_ttl_cmd);</a>
<a name="ln4686">  install_element (RMAP_NODE, &amp;no_set_pathlimit_ttl_val_cmd);</a>
<a name="ln4687">  install_element (RMAP_NODE, &amp;match_pathlimit_as_cmd);</a>
<a name="ln4688">  install_element (RMAP_NODE, &amp;no_match_pathlimit_as_cmd);</a>
<a name="ln4689">  install_element (RMAP_NODE, &amp;no_match_pathlimit_as_val_cmd);</a>
<a name="ln4690">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="2085"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the third actual argument of the 'sscanf' function. It's dangerous to use string specifier without width specification. Buffer overflow is possible.</p></div>
<div class="balloon" rel="2085"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v576/" target="_blank">V576</a> Incorrect format. Consider checking the fourth actual argument of the 'sscanf' function. It's dangerous to use string specifier without width specification. Buffer overflow is possible.</p></div>
<div class="balloon" rel="2678"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1071/" target="_blank">V1071</a> Consider inspecting the 'bgp_route_set_delete' function. The return value is not always used. Total calls: 34, discarded results: 1.</p></div>
<div class="balloon" rel="2655"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1071/" target="_blank">V1071</a> Consider inspecting the 'bgp_route_set_add' function. The return value is not always used. Total calls: 27, discarded results: 2.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
