
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=windows-1256" />
  <title>irdp_packet.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> *</a>
<a name="ln3"> * Copyright (C) 2000  Robert Olsson.</a>
<a name="ln4"> * Swedish University of Agricultural Sciences</a>
<a name="ln5"> *</a>
<a name="ln6"> * This file is part of GNU Zebra.</a>
<a name="ln7"> *</a>
<a name="ln8"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln9"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln10"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln11"> * later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln14"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public License</a>
<a name="ln19"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln20"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln21"> * 02111-1307, USA.  </a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">/* </a>
<a name="ln25"> * This work includes work with the following copywrite:</a>
<a name="ln26"> *</a>
<a name="ln27"> * Copyright (C) 1997, 2000 Kunihiro Ishiguro</a>
<a name="ln28"> *</a>
<a name="ln29"> */</a>
<a name="ln30"> </a>
<a name="ln31">/* </a>
<a name="ln32"> * Thanks to Jens Låås at Swedish University of Agricultural Sciences</a>
<a name="ln33"> * for reviewing and tests.</a>
<a name="ln34"> */</a>
<a name="ln35"> </a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;zebra.h&gt;</a>
<a name="ln38"> </a>
<a name="ln39"> </a>
<a name="ln40">#ifdef HAVE_IRDP</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;if.h&quot;</a>
<a name="ln43">#include &quot;vty.h&quot;</a>
<a name="ln44">#include &quot;sockunion.h&quot;</a>
<a name="ln45">#include &quot;prefix.h&quot;</a>
<a name="ln46">#include &quot;command.h&quot;</a>
<a name="ln47">#include &quot;memory.h&quot;</a>
<a name="ln48">#include &quot;stream.h&quot;</a>
<a name="ln49">#include &quot;ioctl.h&quot;</a>
<a name="ln50">#include &quot;connected.h&quot;</a>
<a name="ln51">#include &quot;log.h&quot;</a>
<a name="ln52">#include &quot;zclient.h&quot;</a>
<a name="ln53">#include &quot;thread.h&quot;</a>
<a name="ln54">#include &quot;zebra/interface.h&quot;</a>
<a name="ln55">#include &quot;zebra/rtadv.h&quot;</a>
<a name="ln56">#include &quot;zebra/rib.h&quot;</a>
<a name="ln57">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln58">#include &quot;zebra/redistribute.h&quot;</a>
<a name="ln59">#include &quot;zebra/irdp.h&quot;</a>
<a name="ln60">#include &lt;netinet/ip_icmp.h&gt;</a>
<a name="ln61">#include &quot;if.h&quot;</a>
<a name="ln62">#include &quot;checksum.h&quot;</a>
<a name="ln63">#include &quot;sockunion.h&quot;</a>
<a name="ln64">#include &quot;log.h&quot;</a>
<a name="ln65">#include &quot;sockopt.h&quot;</a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68">/* GLOBAL VARS */</a>
<a name="ln69"> </a>
<a name="ln70">int irdp_sock = -1;</a>
<a name="ln71"> </a>
<a name="ln72">extern struct zebra_t zebrad;</a>
<a name="ln73">extern struct thread *t_irdp_raw;</a>
<a name="ln74"> </a>
<a name="ln75">static void</a>
<a name="ln76">parse_irdp_packet(char *p, </a>
<a name="ln77">		  int len, </a>
<a name="ln78">		  struct interface *ifp)</a>
<a name="ln79">{</a>
<a name="ln80">  struct ip *ip = (struct ip *)p ;</a>
<a name="ln81">  struct icmphdr *icmp;</a>
<a name="ln82">  struct in_addr src;</a>
<a name="ln83">  int ip_hlen, iplen, datalen;</a>
<a name="ln84">  struct zebra_if *zi;</a>
<a name="ln85">  struct irdp_interface *irdp;</a>
<a name="ln86"> </a>
<a name="ln87">  zi = ifp-&gt;info;</a>
<a name="ln88">  if (!zi) </a>
<a name="ln89">    return;</a>
<a name="ln90"> </a>
<a name="ln91">  irdp = &amp;zi-&gt;irdp;</a>
<a name="ln92">  if (!irdp) </a>
<a name="ln93">    return;</a>
<a name="ln94"> </a>
<a name="ln95">  ip_hlen = ip-&gt;ip_hl &lt;&lt; 2;</a>
<a name="ln96">  </a>
<a name="ln97">  sockopt_iphdrincl_swab_systoh (ip);</a>
<a name="ln98">  </a>
<a name="ln99">  iplen = ip-&gt;ip_len;</a>
<a name="ln100">  datalen = len - ip_hlen;</a>
<a name="ln101">  src = ip-&gt;ip_src;</a>
<a name="ln102"> </a>
<a name="ln103">  if (len != iplen)</a>
<a name="ln104">    {</a>
<a name="ln105">      zlog_err (&quot;IRDP: RX length doesn't match IP length&quot;);</a>
<a name="ln106">      return;</a>
<a name="ln107">    }</a>
<a name="ln108"> </a>
<a name="ln109">  if (iplen &lt; ICMP_MINLEN) </a>
<a name="ln110">    {</a>
<a name="ln111">      zlog_err (&quot;IRDP: RX ICMP packet too short from %s\n&quot;,</a>
<a name="ln112">  	      inet_ntoa (src));</a>
<a name="ln113">      return;</a>
<a name="ln114">    }</a>
<a name="ln115">    </a>
<a name="ln116">  /* XXX: RAW doesn't receive link-layer, surely? ??? */</a>
<a name="ln117">  /* Check so we don't checksum packets longer than oure RX_BUF - (ethlen +</a>
<a name="ln118">   len of IP-header) 14+20 */</a>
<a name="ln119">  if (iplen &gt; IRDP_RX_BUF-34) </a>
<a name="ln120">    {</a>
<a name="ln121">      zlog_err (&quot;IRDP: RX ICMP packet too long from %s\n&quot;,</a>
<a name="ln122">	        inet_ntoa (src));</a>
<a name="ln123">      return;</a>
<a name="ln124">    }</a>
<a name="ln125"> </a>
<a name="ln126">  icmp = (struct icmphdr *) (p+ip_hlen);</a>
<a name="ln127"> </a>
<a name="ln128">  /* check icmp checksum */    </a>
<a name="ln129">  if (in_cksum (icmp, datalen) != icmp-&gt;checksum) </a>
<a name="ln130">    {</a>
<a name="ln131">      zlog_warn (&quot;IRDP: RX ICMP packet from %s. Bad checksum, silently ignored&quot;,</a>
<a name="ln132">                 inet_ntoa (src));</a>
<a name="ln133">      return;</a>
<a name="ln134">    }</a>
<a name="ln135">  </a>
<a name="ln136">  /* Handle just only IRDP */</a>
<a name="ln137">  if (!(icmp-&gt;type == ICMP_ROUTERADVERT</a>
<a name="ln138">        || icmp-&gt;type == ICMP_ROUTERSOLICIT))</a>
<a name="ln139">    return;</a>
<a name="ln140">  </a>
<a name="ln141">  if (icmp-&gt;code != 0) </a>
<a name="ln142">    {</a>
<a name="ln143">      zlog_warn (&quot;IRDP: RX packet type %d from %s. Bad ICMP type code,&quot;</a>
<a name="ln144">                 &quot; silently ignored&quot;,</a>
<a name="ln145">                 icmp-&gt;type, inet_ntoa (src));</a>
<a name="ln146">      return;</a>
<a name="ln147">    }</a>
<a name="ln148"> </a>
<a name="ln149">  if (! ((ntohl (ip-&gt;ip_dst.s_addr) == INADDR_BROADCAST)</a>
<a name="ln150">         &amp;&amp; (irdp-&gt;flags &amp; IF_BROADCAST))</a>
<a name="ln151">        ||</a>
<a name="ln152">        (ntohl (ip-&gt;ip_dst.s_addr) == INADDR_ALLRTRS_GROUP</a>
<a name="ln153">         &amp;&amp; !(irdp-&gt;flags &amp; IF_BROADCAST)))</a>
<a name="ln154">    {</a>
<a name="ln155">      zlog_warn (&quot;IRDP: RX illegal from %s to %s while %s operates in %s\n&quot;,</a>
<a name="ln156">                 inet_ntoa (src),</a>
<a name="ln157">                 ntohl (ip-&gt;ip_dst.s_addr) == INADDR_ALLRTRS_GROUP ?</a>
<a name="ln158">                 &quot;multicast&quot; : inet_ntoa (ip-&gt;ip_dst),</a>
<a name="ln159">                 ifp-&gt;name,</a>
<a name="ln160">                 irdp-&gt;flags &amp; IF_BROADCAST ? &quot;broadcast&quot; : &quot;multicast&quot;);</a>
<a name="ln161"> </a>
<a name="ln162">      zlog_warn (&quot;IRDP: Please correct settings\n&quot;);</a>
<a name="ln163">      return;</a>
<a name="ln164">    }</a>
<a name="ln165"> </a>
<a name="ln166">  switch (icmp-&gt;type) </a>
<a name="ln167">    {</a>
<a name="ln168">    case ICMP_ROUTERADVERT:</a>
<a name="ln169">      break;</a>
<a name="ln170"> </a>
<a name="ln171">    case ICMP_ROUTERSOLICIT:</a>
<a name="ln172"> </a>
<a name="ln173">      if(irdp-&gt;flags &amp; IF_DEBUG_MESSAGES) </a>
<a name="ln174">	zlog_debug (&quot;IRDP: RX Solicit on %s from %s\n&quot;,</a>
<a name="ln175">		    ifp-&gt;name,</a>
<a name="ln176">		    inet_ntoa (src));</a>
<a name="ln177"> </a>
<a name="ln178">      process_solicit(ifp);</a>
<a name="ln179">      break;</a>
<a name="ln180"> </a>
<a name="ln181">    default:</a>
<a name="ln182">      zlog_warn (&quot;IRDP: RX type %d from %s. Bad ICMP type, silently ignored&quot;,</a>
<a name="ln183">		 icmp-&gt;type,</a>
<a name="ln184">		 inet_ntoa (src));</a>
<a name="ln185">    }</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">static int</a>
<a name="ln189">irdp_recvmsg (int sock, u_char *buf, int size, int *ifindex)</a>
<a name="ln190">{</a>
<a name="ln191">  struct msghdr msg;</a>
<a name="ln192">  struct iovec iov;</a>
<a name="ln193">  char adata[CMSG_SPACE( SOPT_SIZE_CMSG_PKTINFO_IPV4() )];</a>
<a name="ln194">  int ret;</a>
<a name="ln195"> </a>
<a name="ln196">  msg.msg_name = (void *)0;</a>
<a name="ln197">  msg.msg_namelen = 0;</a>
<a name="ln198">  msg.msg_iov = &amp;iov;</a>
<a name="ln199">  msg.msg_iovlen = 1;</a>
<a name="ln200">  msg.msg_control = (void *) adata;</a>
<a name="ln201">  msg.msg_controllen = sizeof adata;</a>
<a name="ln202"> </a>
<a name="ln203">  iov.iov_base = buf;</a>
<a name="ln204">  iov.iov_len = size;</a>
<a name="ln205"> </a>
<a name="ln206">  ret = recvmsg (sock, &amp;msg, 0);</a>
<a name="ln207">  if (ret &lt; 0) {</a>
<a name="ln208">    zlog_warn(&quot;IRDP: recvmsg: read error %s&quot;, safe_strerror(errno));</a>
<a name="ln209">    return ret;</a>
<a name="ln210">  }</a>
<a name="ln211"> </a>
<a name="ln212">  if (msg.msg_flags &amp; MSG_TRUNC) {</a>
<a name="ln213">    zlog_warn(&quot;IRDP: recvmsg: truncated message&quot;);</a>
<a name="ln214">    return ret;</a>
<a name="ln215">  }</a>
<a name="ln216">  if (msg.msg_flags &amp; MSG_CTRUNC) {</a>
<a name="ln217">    zlog_warn(&quot;IRDP: recvmsg: truncated control message&quot;);</a>
<a name="ln218">    return ret;</a>
<a name="ln219">  }</a>
<a name="ln220"> </a>
<a name="ln221">  *ifindex = getsockopt_ifindex (AF_INET, &amp;msg);</a>
<a name="ln222"> </a>
<a name="ln223">  return ret;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">int irdp_read_raw(struct thread *r)</a>
<a name="ln227">{</a>
<a name="ln228">  struct interface *ifp;</a>
<a name="ln229">  struct zebra_if *zi;</a>
<a name="ln230">  struct irdp_interface *irdp;</a>
<a name="ln231">  char buf[IRDP_RX_BUF];</a>
<a name="ln232">  int ret, ifindex = 0;</a>
<a name="ln233">  </a>
<a name="ln234">  int irdp_sock = THREAD_FD (r);</a>
<a name="ln235">  t_irdp_raw = thread_add_read (zebrad.master, irdp_read_raw, NULL, irdp_sock);</a>
<a name="ln236">  </a>
<a name="ln237">  ret = irdp_recvmsg (irdp_sock, (u_char *) buf, IRDP_RX_BUF,  &amp;ifindex);</a>
<a name="ln238"> </a>
<a name="ln239">  if (ret &lt; 0) zlog_warn (&quot;IRDP: RX Error length = %d&quot;, ret);</a>
<a name="ln240"> </a>
<a name="ln241">  ifp = if_lookup_by_index(ifindex);</a>
<a name="ln242">  if(! ifp ) return ret;</a>
<a name="ln243"> </a>
<a name="ln244">  zi= ifp-&gt;info;</a>
<a name="ln245">  if(! zi ) return ret;</a>
<a name="ln246"> </a>
<a name="ln247">  irdp = &amp;zi-&gt;irdp;</a>
<a name="ln248">  if(! irdp ) return ret;</a>
<a name="ln249"> </a>
<a name="ln250">  if(! (irdp-&gt;flags &amp; IF_ACTIVE)) {</a>
<a name="ln251"> </a>
<a name="ln252">    if(irdp-&gt;flags &amp; IF_DEBUG_MISC) </a>
<a name="ln253">      zlog_debug(&quot;IRDP: RX ICMP for disabled interface %s\n&quot;, ifp-&gt;name);</a>
<a name="ln254">    return 0;</a>
<a name="ln255">  }</a>
<a name="ln256"> </a>
<a name="ln257">  if(irdp-&gt;flags &amp; IF_DEBUG_PACKET) {</a>
<a name="ln258">    int i;</a>
<a name="ln259">    zlog_debug(&quot;IRDP: RX (idx %d) &quot;, ifindex);</a>
<a name="ln260">    for(i=0; i &lt; ret; i++) zlog_debug( &quot;IRDP: RX %x &quot;, buf[i]&amp;0xFF);</a>
<a name="ln261">  }</a>
<a name="ln262"> </a>
<a name="ln263">  parse_irdp_packet(buf, ret, ifp);</a>
<a name="ln264"> </a>
<a name="ln265">  return ret;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">void </a>
<a name="ln269">send_packet(struct interface *ifp, </a>
<a name="ln270">	    struct stream *s,</a>
<a name="ln271">	    u_int32_t dst,</a>
<a name="ln272">	    struct prefix *p,</a>
<a name="ln273">	    u_int32_t ttl)</a>
<a name="ln274">{</a>
<a name="ln275">  static struct sockaddr_in sockdst = {AF_INET};</a>
<a name="ln276">  struct ip *ip;</a>
<a name="ln277">  struct icmphdr *icmp;</a>
<a name="ln278">  struct msghdr *msg;</a>
<a name="ln279">  struct cmsghdr *cmsg;</a>
<a name="ln280">  struct iovec iovector;</a>
<a name="ln281">  char msgbuf[256];</a>
<a name="ln282">  char buf[256];</a>
<a name="ln283">  struct in_pktinfo *pktinfo;</a>
<a name="ln284">  u_long src;</a>
<a name="ln285">  int on;</a>
<a name="ln286"> </a>
<a name="ln287">  if (!(ifp-&gt;flags &amp; IFF_UP))</a>
<a name="ln288">    return;</a>
<a name="ln289"> </a>
<a name="ln290">  if (p)</a>
<a name="ln291">    src = ntohl(p-&gt;u.prefix4.s_addr);</a>
<a name="ln292">  else </a>
<a name="ln293">    src = 0; /* Is filled in */</a>
<a name="ln294">  </a>
<a name="ln295">  ip = (struct ip *) buf;</a>
<a name="ln296">  ip-&gt;ip_hl = sizeof(struct ip) &gt;&gt; 2;</a>
<a name="ln297">  ip-&gt;ip_v = IPVERSION;</a>
<a name="ln298">  ip-&gt;ip_tos = 0xC0;</a>
<a name="ln299">  ip-&gt;ip_off = 0L;</a>
<a name="ln300">  ip-&gt;ip_p = 1;       /* IP_ICMP */</a>
<a name="ln301">  ip-&gt;ip_ttl = ttl;</a>
<a name="ln302">  ip-&gt;ip_src.s_addr = src;</a>
<a name="ln303">  ip-&gt;ip_dst.s_addr = dst;</a>
<a name="ln304">  icmp = (struct icmphdr *) (buf + sizeof (struct ip));</a>
<a name="ln305"> </a>
<a name="ln306">  /* Merge IP header with icmp packet */</a>
<a name="ln307">  assert (stream_get_endp(s) &lt; (sizeof (buf) - sizeof (struct ip)));</a>
<a name="ln308">  stream_get(icmp, s, stream_get_endp(s));</a>
<a name="ln309"> </a>
<a name="ln310">  /* icmp-&gt;checksum is already calculated */</a>
<a name="ln311">  ip-&gt;ip_len  = sizeof(struct ip) + stream_get_endp(s);</a>
<a name="ln312"> </a>
<a name="ln313">  on = 1;</a>
<a name="ln314">  if (setsockopt(irdp_sock, IPPROTO_IP, IP_HDRINCL,</a>
<a name="ln315">		 (char *) &amp;on, sizeof(on)) &lt; 0)</a>
<a name="ln316">    zlog_warn(&quot;sendto %s&quot;, safe_strerror (errno));</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">  if(dst == INADDR_BROADCAST ) {</a>
<a name="ln320">    on = 1;</a>
<a name="ln321">    if (setsockopt(irdp_sock, SOL_SOCKET, SO_BROADCAST,</a>
<a name="ln322">		   (char *) &amp;on, sizeof(on)) &lt; 0)</a>
<a name="ln323">      zlog_warn(&quot;sendto %s&quot;, safe_strerror (errno));</a>
<a name="ln324">  }</a>
<a name="ln325"> </a>
<a name="ln326">  if(dst !=  INADDR_BROADCAST) {</a>
<a name="ln327">      on = 0; </a>
<a name="ln328">      if( setsockopt(irdp_sock,IPPROTO_IP, IP_MULTICAST_LOOP, </a>
<a name="ln329">		     (char *)&amp;on,sizeof(on)) &lt; 0)</a>
<a name="ln330">	zlog_warn(&quot;sendto %s&quot;, safe_strerror (errno));</a>
<a name="ln331">  }</a>
<a name="ln332"> </a>
<a name="ln333">  memset(&amp;sockdst,0,sizeof(sockdst));</a>
<a name="ln334">  sockdst.sin_family=AF_INET;</a>
<a name="ln335">  sockdst.sin_addr.s_addr = dst;</a>
<a name="ln336"> </a>
<a name="ln337">  cmsg = (struct cmsghdr *) (msgbuf + sizeof(struct msghdr));</a>
<a name="ln338">  cmsg-&gt;cmsg_len = sizeof(struct cmsghdr) + sizeof(struct in_pktinfo);</a>
<a name="ln339">  cmsg-&gt;cmsg_level = SOL_IP;</a>
<a name="ln340">  cmsg-&gt;cmsg_type = IP_PKTINFO;</a>
<a name="ln341">  pktinfo = (struct in_pktinfo *) CMSG_DATA(cmsg);</a>
<a name="ln342">  pktinfo-&gt;ipi_ifindex = ifp-&gt;ifindex;</a>
<a name="ln343">  pktinfo-&gt;ipi_spec_dst.s_addr = src;</a>
<a name="ln344">  pktinfo-&gt;ipi_addr.s_addr = src;</a>
<a name="ln345"> </a>
<a name="ln346">  iovector.iov_base = (void *) buf;</a>
<a name="ln347">  iovector.iov_len = ip-&gt;ip_len; </a>
<a name="ln348">  msg = (struct msghdr *) msgbuf;</a>
<a name="ln349">  msg-&gt;msg_name = &amp;sockdst;</a>
<a name="ln350">  msg-&gt;msg_namelen = sizeof(sockdst);</a>
<a name="ln351">  msg-&gt;msg_iov = &amp;iovector;</a>
<a name="ln352">  msg-&gt;msg_iovlen = 1;</a>
<a name="ln353">  msg-&gt;msg_control = cmsg;</a>
<a name="ln354">  msg-&gt;msg_controllen = cmsg-&gt;cmsg_len;</a>
<a name="ln355"> </a>
<a name="ln356">  sockopt_iphdrincl_swab_htosys (ip);</a>
<a name="ln357">  </a>
<a name="ln358">  if (sendmsg(irdp_sock, msg, 0) &lt; 0) {</a>
<a name="ln359">    zlog_warn(&quot;sendto %s&quot;, safe_strerror (errno));</a>
<a name="ln360">  }</a>
<a name="ln361">  /*   printf(&quot;TX on %s idx %d\n&quot;, ifp-&gt;name, ifp-&gt;ifindex); */</a>
<a name="ln362">}</a>
<a name="ln363"> </a>
<a name="ln364"> </a>
<a name="ln365">#endif /* HAVE_IRDP */</a>
<a name="ln366"> </a>
<a name="ln367"> </a>
<a name="ln368"> </a>

</code></pre>
<div class="balloon" rel="9"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="92"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!irdp' is always false.</p></div>
<div class="balloon" rel="248"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!irdp' is always false.</p></div>
<div class="balloon" rel="295"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'buf' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="348"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'msgbuf' is cast to a more strictly aligned pointer type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
