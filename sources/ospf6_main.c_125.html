
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf6_main.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (C) 1999 Yasuhiro Ohara</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the </a>
<a name="ln18"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330, </a>
<a name="ln19"> * Boston, MA 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23">#include &lt;lib/version.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;getopt.h&quot;</a>
<a name="ln26">#include &quot;thread.h&quot;</a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29">#include &quot;vty.h&quot;</a>
<a name="ln30">#include &quot;memory.h&quot;</a>
<a name="ln31">#include &quot;if.h&quot;</a>
<a name="ln32">#include &quot;filter.h&quot;</a>
<a name="ln33">#include &quot;prefix.h&quot;</a>
<a name="ln34">#include &quot;plist.h&quot;</a>
<a name="ln35">#include &quot;privs.h&quot;</a>
<a name="ln36">#include &quot;sigevent.h&quot;</a>
<a name="ln37">#include &quot;zclient.h&quot;</a>
<a name="ln38">#include &quot;vrf.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;ospf6d.h&quot;</a>
<a name="ln41">#include &quot;ospf6_top.h&quot;</a>
<a name="ln42">#include &quot;ospf6_message.h&quot;</a>
<a name="ln43">#include &quot;ospf6_asbr.h&quot;</a>
<a name="ln44">#include &quot;ospf6_lsa.h&quot;</a>
<a name="ln45">#include &quot;ospf6_interface.h&quot;</a>
<a name="ln46">#include &quot;ospf6_zebra.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">/* Default configuration file name for ospf6d. */</a>
<a name="ln49">#define OSPF6_DEFAULT_CONFIG       &quot;ospf6d.conf&quot;</a>
<a name="ln50"> </a>
<a name="ln51">/* Default port values. */</a>
<a name="ln52">#define OSPF6_VTY_PORT             2606</a>
<a name="ln53"> </a>
<a name="ln54">/* ospf6d privileges */</a>
<a name="ln55">zebra_capabilities_t _caps_p [] =</a>
<a name="ln56">{</a>
<a name="ln57">  ZCAP_NET_RAW,</a>
<a name="ln58">  ZCAP_BIND</a>
<a name="ln59">};</a>
<a name="ln60"> </a>
<a name="ln61">struct zebra_privs_t ospf6d_privs =</a>
<a name="ln62">{</a>
<a name="ln63">#if defined(QUAGGA_USER)</a>
<a name="ln64">  .user = QUAGGA_USER,</a>
<a name="ln65">#endif</a>
<a name="ln66">#if defined QUAGGA_GROUP</a>
<a name="ln67">  .group = QUAGGA_GROUP,</a>
<a name="ln68">#endif</a>
<a name="ln69">#ifdef VTY_GROUP</a>
<a name="ln70">  .vty_group = VTY_GROUP,</a>
<a name="ln71">#endif</a>
<a name="ln72">  .caps_p = _caps_p,</a>
<a name="ln73">  .cap_num_p = 2,</a>
<a name="ln74">  .cap_num_i = 0</a>
<a name="ln75">};</a>
<a name="ln76"> </a>
<a name="ln77">/* ospf6d options, we use GNU getopt library. */</a>
<a name="ln78">struct option longopts[] = </a>
<a name="ln79">{</a>
<a name="ln80">  { &quot;daemon&quot;,      no_argument,       NULL, 'd'},</a>
<a name="ln81">  { &quot;config_file&quot;, required_argument, NULL, 'f'},</a>
<a name="ln82">  { &quot;pid_file&quot;,    required_argument, NULL, 'i'},</a>
<a name="ln83">  { &quot;socket&quot;,      required_argument, NULL, 'z'},</a>
<a name="ln84">  { &quot;vty_addr&quot;,    required_argument, NULL, 'A'},</a>
<a name="ln85">  { &quot;vty_port&quot;,    required_argument, NULL, 'P'},</a>
<a name="ln86">  { &quot;user&quot;,        required_argument, NULL, 'u'},</a>
<a name="ln87">  { &quot;group&quot;,       required_argument, NULL, 'g'},</a>
<a name="ln88">  { &quot;version&quot;,     no_argument,       NULL, 'v'},</a>
<a name="ln89">  { &quot;dryrun&quot;,      no_argument,       NULL, 'C'},</a>
<a name="ln90">  { &quot;help&quot;,        no_argument,       NULL, 'h'},</a>
<a name="ln91">  { 0 }</a>
<a name="ln92">};</a>
<a name="ln93"> </a>
<a name="ln94">/* Configuration file and directory. */</a>
<a name="ln95">char config_default[] = SYSCONFDIR OSPF6_DEFAULT_CONFIG;</a>
<a name="ln96"> </a>
<a name="ln97">/* ospf6d program name. */</a>
<a name="ln98">char *progname;</a>
<a name="ln99"> </a>
<a name="ln100">/* is daemon? */</a>
<a name="ln101">int daemon_mode = 0;</a>
<a name="ln102"> </a>
<a name="ln103">/* Master of threads. */</a>
<a name="ln104">struct thread_master *master;</a>
<a name="ln105"> </a>
<a name="ln106">/* Process ID saved for use by init system */</a>
<a name="ln107">const char *pid_file = PATH_OSPF6D_PID;</a>
<a name="ln108"> </a>
<a name="ln109">/* Help information display. */</a>
<a name="ln110">static void</a>
<a name="ln111">usage (char *progname, int status)</a>
<a name="ln112">{</a>
<a name="ln113">  if (status != 0)</a>
<a name="ln114">    fprintf (stderr, &quot;Try `%s --help' for more information.\n&quot;, progname);</a>
<a name="ln115">  else</a>
<a name="ln116">    {    </a>
<a name="ln117">      printf (&quot;Usage : %s [OPTION...]\n\n\</a>
<a name="ln118">Daemon which manages OSPF version 3.\n\n\</a>
<a name="ln119">-d, --daemon       Runs in daemon mode\n\</a>
<a name="ln120">-f, --config_file  Set configuration file name\n\</a>
<a name="ln121">-i, --pid_file     Set process identifier file name\n\</a>
<a name="ln122">-z, --socket       Set path of zebra socket\n\</a>
<a name="ln123">-A, --vty_addr     Set vty's bind address\n\</a>
<a name="ln124">-P, --vty_port     Set vty's port number\n\</a>
<a name="ln125">-u, --user         User to run as\n\</a>
<a name="ln126">-g, --group        Group to run as\n\</a>
<a name="ln127">-v, --version      Print program version\n\</a>
<a name="ln128">-C, --dryrun       Check configuration for validity and exit\n\</a>
<a name="ln129">-h, --help         Display this help and exit\n\</a>
<a name="ln130">\n\</a>
<a name="ln131">Report bugs to %s\n&quot;, progname, ZEBRA_BUG_ADDRESS);</a>
<a name="ln132">    }</a>
<a name="ln133"> </a>
<a name="ln134">  exit (status);</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">static void __attribute__ ((noreturn))</a>
<a name="ln138">ospf6_exit (int status)</a>
<a name="ln139">{</a>
<a name="ln140">  struct listnode *node;</a>
<a name="ln141">  struct interface *ifp;</a>
<a name="ln142"> </a>
<a name="ln143">  if (ospf6)</a>
<a name="ln144">    ospf6_delete (ospf6);</a>
<a name="ln145"> </a>
<a name="ln146">  for (ALL_LIST_ELEMENTS_RO(iflist, node, ifp))</a>
<a name="ln147">    if (ifp-&gt;info != NULL)</a>
<a name="ln148">      ospf6_interface_delete(ifp-&gt;info);</a>
<a name="ln149"> </a>
<a name="ln150">  ospf6_message_terminate ();</a>
<a name="ln151">  ospf6_asbr_terminate ();</a>
<a name="ln152">  ospf6_lsa_terminate ();</a>
<a name="ln153"> </a>
<a name="ln154">  vrf_terminate ();</a>
<a name="ln155">  vty_terminate ();</a>
<a name="ln156">  cmd_terminate ();</a>
<a name="ln157"> </a>
<a name="ln158">  if (zclient)</a>
<a name="ln159">    zclient_free (zclient);</a>
<a name="ln160"> </a>
<a name="ln161">  if (master)</a>
<a name="ln162">    thread_master_free (master);</a>
<a name="ln163"> </a>
<a name="ln164">  if (zlog_default)</a>
<a name="ln165">    closezlog (zlog_default);</a>
<a name="ln166"> </a>
<a name="ln167">  exit (status);</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">/* SIGHUP handler. */</a>
<a name="ln171">static void </a>
<a name="ln172">sighup (void)</a>
<a name="ln173">{</a>
<a name="ln174">  zlog_info (&quot;SIGHUP received&quot;);</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">/* SIGINT handler. */</a>
<a name="ln178">static void</a>
<a name="ln179">sigint (void)</a>
<a name="ln180">{</a>
<a name="ln181">  zlog_notice (&quot;Terminating on signal SIGINT&quot;);</a>
<a name="ln182">  ospf6_exit (0);</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">/* SIGTERM handler. */</a>
<a name="ln186">static void</a>
<a name="ln187">sigterm (void)</a>
<a name="ln188">{</a>
<a name="ln189">  zlog_notice (&quot;Terminating on signal SIGTERM&quot;);</a>
<a name="ln190">  ospf6_clean();</a>
<a name="ln191">  ospf6_exit (0);</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">/* SIGUSR1 handler. */</a>
<a name="ln195">static void</a>
<a name="ln196">sigusr1 (void)</a>
<a name="ln197">{</a>
<a name="ln198">  zlog_info (&quot;SIGUSR1 received&quot;);</a>
<a name="ln199">  zlog_rotate (NULL);</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">struct quagga_signal_t ospf6_signals[] =</a>
<a name="ln203">{</a>
<a name="ln204">  {</a>
<a name="ln205">    .signal = SIGHUP,</a>
<a name="ln206">    .handler = &amp;sighup,</a>
<a name="ln207">  },</a>
<a name="ln208">  {</a>
<a name="ln209">    .signal = SIGINT,</a>
<a name="ln210">    .handler = &amp;sigint,</a>
<a name="ln211">  },</a>
<a name="ln212">  {</a>
<a name="ln213">    .signal = SIGTERM,</a>
<a name="ln214">    .handler = &amp;sigterm,</a>
<a name="ln215">  },</a>
<a name="ln216">  {</a>
<a name="ln217">    .signal = SIGUSR1,</a>
<a name="ln218">    .handler = &amp;sigusr1,</a>
<a name="ln219">  },</a>
<a name="ln220">};</a>
<a name="ln221"> </a>
<a name="ln222">/* Main routine of ospf6d. Treatment of argument and starting ospf finite</a>
<a name="ln223">   state machine is handled here. */</a>
<a name="ln224">int</a>
<a name="ln225">main (int argc, char *argv[], char *envp[])</a>
<a name="ln226">{</a>
<a name="ln227">  char *p;</a>
<a name="ln228">  int opt;</a>
<a name="ln229">  char *vty_addr = NULL;</a>
<a name="ln230">  int vty_port = 0;</a>
<a name="ln231">  char *config_file = NULL;</a>
<a name="ln232">  int dryrun = 0;</a>
<a name="ln233"> </a>
<a name="ln234">  /* Set umask before anything for security */</a>
<a name="ln235">  umask (0027);</a>
<a name="ln236"> </a>
<a name="ln237">  /* Preserve name of myself. */</a>
<a name="ln238">  progname = ((p = strrchr (argv[0], '/')) ? ++p : argv[0]);</a>
<a name="ln239"> </a>
<a name="ln240">  /* Command line argument treatment. */</a>
<a name="ln241">  while (1) </a>
<a name="ln242">    {</a>
<a name="ln243">      opt = getopt_long (argc, argv, &quot;df:i:z:hp:A:P:u:g:vC&quot;, longopts, 0);</a>
<a name="ln244">    </a>
<a name="ln245">      if (opt == EOF)</a>
<a name="ln246">        break;</a>
<a name="ln247"> </a>
<a name="ln248">      switch (opt) </a>
<a name="ln249">        {</a>
<a name="ln250">        case 0:</a>
<a name="ln251">          break;</a>
<a name="ln252">        case 'd':</a>
<a name="ln253">          daemon_mode = 1;</a>
<a name="ln254">          break;</a>
<a name="ln255">        case 'f':</a>
<a name="ln256">          config_file = optarg;</a>
<a name="ln257">          break;</a>
<a name="ln258">        case 'A':</a>
<a name="ln259">          vty_addr = optarg;</a>
<a name="ln260">          break;</a>
<a name="ln261">        case 'i':</a>
<a name="ln262">          pid_file = optarg;</a>
<a name="ln263">          break;</a>
<a name="ln264">        case 'z':</a>
<a name="ln265">          zclient_serv_path_set (optarg);</a>
<a name="ln266">          break;</a>
<a name="ln267">        case 'P':</a>
<a name="ln268">         /* Deal with atoi() returning 0 on failure, and ospf6d not</a>
<a name="ln269">             listening on ospf6d port... */</a>
<a name="ln270">          if (strcmp(optarg, &quot;0&quot;) == 0)</a>
<a name="ln271">            {</a>
<a name="ln272">              vty_port = 0;</a>
<a name="ln273">              break;</a>
<a name="ln274">            }</a>
<a name="ln275">          vty_port = atoi (optarg);</a>
<a name="ln276">          if (vty_port &lt;= 0 || vty_port &gt; 0xffff)</a>
<a name="ln277">            vty_port = OSPF6_VTY_PORT;</a>
<a name="ln278">          break;</a>
<a name="ln279">        case 'u':</a>
<a name="ln280">          ospf6d_privs.user = optarg;</a>
<a name="ln281">          break;</a>
<a name="ln282">	case 'g':</a>
<a name="ln283">	  ospf6d_privs.group = optarg;</a>
<a name="ln284">	  break;</a>
<a name="ln285">        case 'v':</a>
<a name="ln286">          print_version (progname);</a>
<a name="ln287">          exit (0);</a>
<a name="ln288">          break;</a>
<a name="ln289">	case 'C':</a>
<a name="ln290">	  dryrun = 1;</a>
<a name="ln291">	  break;</a>
<a name="ln292">        case 'h':</a>
<a name="ln293">          usage (progname, 0);</a>
<a name="ln294">          break;</a>
<a name="ln295">        default:</a>
<a name="ln296">          usage (progname, 1);</a>
<a name="ln297">          break;</a>
<a name="ln298">        }</a>
<a name="ln299">    }</a>
<a name="ln300"> </a>
<a name="ln301">  if (geteuid () != 0)</a>
<a name="ln302">    {</a>
<a name="ln303">      errno = EPERM;</a>
<a name="ln304">      perror (progname);</a>
<a name="ln305">      exit (1);</a>
<a name="ln306">    }</a>
<a name="ln307"> </a>
<a name="ln308">  /* thread master */</a>
<a name="ln309">  master = thread_master_create ();</a>
<a name="ln310"> </a>
<a name="ln311">  /* Initializations. */</a>
<a name="ln312">  zlog_default = openzlog (progname, ZLOG_OSPF6,</a>
<a name="ln313">                           LOG_CONS|LOG_NDELAY|LOG_PID,</a>
<a name="ln314">                           LOG_DAEMON);</a>
<a name="ln315">  zprivs_init (&amp;ospf6d_privs);</a>
<a name="ln316">  /* initialize zebra libraries */</a>
<a name="ln317">  signal_init (master, array_size(ospf6_signals), ospf6_signals);</a>
<a name="ln318">  cmd_init (1);</a>
<a name="ln319">  vty_init (master);</a>
<a name="ln320">  memory_init ();</a>
<a name="ln321">  vrf_init ();</a>
<a name="ln322">  access_list_init ();</a>
<a name="ln323">  prefix_list_init ();</a>
<a name="ln324"> </a>
<a name="ln325">  /* initialize ospf6 */</a>
<a name="ln326">  ospf6_init ();</a>
<a name="ln327"> </a>
<a name="ln328">  /* parse config file */</a>
<a name="ln329">  vty_read_config (config_file, config_default);</a>
<a name="ln330"> </a>
<a name="ln331">  /* Start execution only if not in dry-run mode */</a>
<a name="ln332">  if (dryrun)</a>
<a name="ln333">    return(0);</a>
<a name="ln334">  </a>
<a name="ln335">  if (daemon_mode &amp;&amp; daemon (0, 0) &lt; 0)</a>
<a name="ln336">    {</a>
<a name="ln337">      zlog_err(&quot;OSPF6d daemon failed: %s&quot;, strerror(errno));</a>
<a name="ln338">      exit (1);</a>
<a name="ln339">    }</a>
<a name="ln340"> </a>
<a name="ln341">  /* pid file create */</a>
<a name="ln342">  pid_output (pid_file);</a>
<a name="ln343"> </a>
<a name="ln344">  /* Make ospf6 vty socket. */</a>
<a name="ln345">  if (!vty_port)</a>
<a name="ln346">    vty_port = OSPF6_VTY_PORT;</a>
<a name="ln347">  vty_serv_sock (vty_addr, vty_port, OSPF6_VTYSH_PATH);</a>
<a name="ln348"> </a>
<a name="ln349">  /* Print start message */</a>
<a name="ln350">  zlog_notice (&quot;OSPF6d (Quagga-%s ospf6d-%s) starts: vty@%d&quot;,</a>
<a name="ln351">               QUAGGA_VERSION, OSPF6_DAEMON_VERSION,vty_port);</a>
<a name="ln352"> </a>
<a name="ln353">  /* Start finite state machine, here we go! */</a>
<a name="ln354">  thread_main (master);</a>
<a name="ln355">  </a>
<a name="ln356">  /* Log in case thread failed */</a>
<a name="ln357">  zlog_warn (&quot;Thread failed&quot;);</a>
<a name="ln358"> </a>
<a name="ln359">  /* Not reached. */</a>
<a name="ln360">  ospf6_exit (0);</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363"> </a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
