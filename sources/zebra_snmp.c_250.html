
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>zebra_snmp.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* FIB SNMP.</a>
<a name="ln2"> * Copyright (C) 1999 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">/*</a>
<a name="ln23"> * Currently SNMP is only running properly for MIBs in the default VRF.</a>
<a name="ln24"> */</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;zebra.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#ifdef HAVE_SNMP</a>
<a name="ln29">#include &lt;net-snmp/net-snmp-config.h&gt;</a>
<a name="ln30">#include &lt;net-snmp/net-snmp-includes.h&gt;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;if.h&quot;</a>
<a name="ln33">#include &quot;log.h&quot;</a>
<a name="ln34">#include &quot;prefix.h&quot;</a>
<a name="ln35">#include &quot;command.h&quot;</a>
<a name="ln36">#include &quot;smux.h&quot;</a>
<a name="ln37">#include &quot;table.h&quot;</a>
<a name="ln38">#include &quot;vrf.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">#include &quot;zebra/rib.h&quot;</a>
<a name="ln41">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">#define IPFWMIB 1,3,6,1,2,1,4,24</a>
<a name="ln44"> </a>
<a name="ln45">/* ipForwardTable */</a>
<a name="ln46">#define IPFORWARDDEST                         1</a>
<a name="ln47">#define IPFORWARDMASK                         2</a>
<a name="ln48">#define IPFORWARDPOLICY                       3</a>
<a name="ln49">#define IPFORWARDNEXTHOP                      4</a>
<a name="ln50">#define IPFORWARDIFINDEX                      5</a>
<a name="ln51">#define IPFORWARDTYPE                         6</a>
<a name="ln52">#define IPFORWARDPROTO                        7</a>
<a name="ln53">#define IPFORWARDAGE                          8</a>
<a name="ln54">#define IPFORWARDINFO                         9</a>
<a name="ln55">#define IPFORWARDNEXTHOPAS                   10</a>
<a name="ln56">#define IPFORWARDMETRIC1                     11</a>
<a name="ln57">#define IPFORWARDMETRIC2                     12</a>
<a name="ln58">#define IPFORWARDMETRIC3                     13</a>
<a name="ln59">#define IPFORWARDMETRIC4                     14</a>
<a name="ln60">#define IPFORWARDMETRIC5                     15</a>
<a name="ln61"> </a>
<a name="ln62">/* ipCidrRouteTable */</a>
<a name="ln63">#define IPCIDRROUTEDEST                       1</a>
<a name="ln64">#define IPCIDRROUTEMASK                       2</a>
<a name="ln65">#define IPCIDRROUTETOS                        3</a>
<a name="ln66">#define IPCIDRROUTENEXTHOP                    4</a>
<a name="ln67">#define IPCIDRROUTEIFINDEX                    5</a>
<a name="ln68">#define IPCIDRROUTETYPE                       6</a>
<a name="ln69">#define IPCIDRROUTEPROTO                      7</a>
<a name="ln70">#define IPCIDRROUTEAGE                        8</a>
<a name="ln71">#define IPCIDRROUTEINFO                       9</a>
<a name="ln72">#define IPCIDRROUTENEXTHOPAS                 10</a>
<a name="ln73">#define IPCIDRROUTEMETRIC1                   11</a>
<a name="ln74">#define IPCIDRROUTEMETRIC2                   12</a>
<a name="ln75">#define IPCIDRROUTEMETRIC3                   13</a>
<a name="ln76">#define IPCIDRROUTEMETRIC4                   14</a>
<a name="ln77">#define IPCIDRROUTEMETRIC5                   15</a>
<a name="ln78">#define IPCIDRROUTESTATUS                    16</a>
<a name="ln79"> </a>
<a name="ln80">#define INTEGER32 ASN_INTEGER</a>
<a name="ln81">#define GAUGE32 ASN_GAUGE</a>
<a name="ln82">#define ENUMERATION ASN_INTEGER</a>
<a name="ln83">#define ROWSTATUS ASN_INTEGER</a>
<a name="ln84">#define IPADDRESS ASN_IPADDRESS</a>
<a name="ln85">#define OBJECTIDENTIFIER ASN_OBJECT_ID</a>
<a name="ln86"> </a>
<a name="ln87">extern struct zebra_t zebrad;</a>
<a name="ln88"> </a>
<a name="ln89">oid ipfw_oid [] = { IPFWMIB };</a>
<a name="ln90"> </a>
<a name="ln91">/* Hook functions. */</a>
<a name="ln92">static u_char * ipFwNumber (struct variable *, oid [], size_t *,</a>
<a name="ln93">		     int, size_t *, WriteMethod **);</a>
<a name="ln94">static u_char * ipFwTable (struct variable *, oid [], size_t *,</a>
<a name="ln95">			   int, size_t *, WriteMethod **);</a>
<a name="ln96">static u_char * ipCidrNumber (struct variable *, oid [], size_t *,</a>
<a name="ln97">			      int, size_t *, WriteMethod **);</a>
<a name="ln98">static u_char * ipCidrTable (struct variable *, oid [], size_t *,</a>
<a name="ln99">			     int, size_t *, WriteMethod **);</a>
<a name="ln100"> </a>
<a name="ln101">struct variable zebra_variables[] = </a>
<a name="ln102">  {</a>
<a name="ln103">    {0, GAUGE32, RONLY, ipFwNumber, 1, {1}},</a>
<a name="ln104">    {IPFORWARDDEST, IPADDRESS, RONLY, ipFwTable, 3, {2, 1, 1}},</a>
<a name="ln105">    {IPFORWARDMASK, IPADDRESS, RONLY, ipFwTable, 3, {2, 1, 2}},</a>
<a name="ln106">    {IPFORWARDPOLICY, INTEGER32, RONLY, ipFwTable, 3, {2, 1, 3}},</a>
<a name="ln107">    {IPFORWARDNEXTHOP, IPADDRESS, RONLY, ipFwTable, 3, {2, 1, 4}},</a>
<a name="ln108">    {IPFORWARDIFINDEX, INTEGER32, RONLY, ipFwTable, 3, {2, 1, 5}},</a>
<a name="ln109">    {IPFORWARDTYPE, ENUMERATION, RONLY, ipFwTable, 3, {2, 1, 6}},</a>
<a name="ln110">    {IPFORWARDPROTO, ENUMERATION, RONLY, ipFwTable, 3, {2, 1, 7}},</a>
<a name="ln111">    {IPFORWARDAGE, INTEGER32, RONLY, ipFwTable, 3, {2, 1, 8}},</a>
<a name="ln112">    {IPFORWARDINFO, OBJECTIDENTIFIER, RONLY, ipFwTable, 3, {2, 1, 9}},</a>
<a name="ln113">    {IPFORWARDNEXTHOPAS, INTEGER32, RONLY, ipFwTable, 3, {2, 1, 10}},</a>
<a name="ln114">    {IPFORWARDMETRIC1, INTEGER32, RONLY, ipFwTable, 3, {2, 1, 11}},</a>
<a name="ln115">    {IPFORWARDMETRIC2, INTEGER32, RONLY, ipFwTable, 3, {2, 1, 12}},</a>
<a name="ln116">    {IPFORWARDMETRIC3, INTEGER32, RONLY, ipFwTable, 3, {2, 1, 13}},</a>
<a name="ln117">    {IPFORWARDMETRIC4, INTEGER32, RONLY, ipFwTable, 3, {2, 1, 14}},</a>
<a name="ln118">    {IPFORWARDMETRIC5, INTEGER32, RONLY, ipFwTable, 3, {2, 1, 15}},</a>
<a name="ln119">    {0, GAUGE32, RONLY, ipCidrNumber, 1, {3}},</a>
<a name="ln120">    {IPCIDRROUTEDEST, IPADDRESS, RONLY, ipCidrTable, 3, {4, 1, 1}},</a>
<a name="ln121">    {IPCIDRROUTEMASK, IPADDRESS, RONLY, ipCidrTable, 3, {4, 1, 2}},</a>
<a name="ln122">    {IPCIDRROUTETOS, INTEGER32, RONLY, ipCidrTable, 3, {4, 1, 3}},</a>
<a name="ln123">    {IPCIDRROUTENEXTHOP, IPADDRESS, RONLY, ipCidrTable, 3, {4, 1, 4}},</a>
<a name="ln124">    {IPCIDRROUTEIFINDEX, INTEGER32, RONLY, ipCidrTable, 3, {4, 1, 5}},</a>
<a name="ln125">    {IPCIDRROUTETYPE, ENUMERATION, RONLY, ipCidrTable, 3, {4, 1, 6}},</a>
<a name="ln126">    {IPCIDRROUTEPROTO, ENUMERATION, RONLY, ipCidrTable, 3, {4, 1, 7}},</a>
<a name="ln127">    {IPCIDRROUTEAGE, INTEGER32, RONLY, ipCidrTable, 3, {4, 1, 8}},</a>
<a name="ln128">    {IPCIDRROUTEINFO, OBJECTIDENTIFIER, RONLY, ipCidrTable, 3, {4, 1, 9}},</a>
<a name="ln129">    {IPCIDRROUTENEXTHOPAS, INTEGER32, RONLY, ipCidrTable, 3, {4, 1, 10}},</a>
<a name="ln130">    {IPCIDRROUTEMETRIC1, INTEGER32, RONLY, ipCidrTable, 3, {4, 1, 11}},</a>
<a name="ln131">    {IPCIDRROUTEMETRIC2, INTEGER32, RONLY, ipCidrTable, 3, {4, 1, 12}},</a>
<a name="ln132">    {IPCIDRROUTEMETRIC3, INTEGER32, RONLY, ipCidrTable, 3, {4, 1, 13}},</a>
<a name="ln133">    {IPCIDRROUTEMETRIC4, INTEGER32, RONLY, ipCidrTable, 3, {4, 1, 14}},</a>
<a name="ln134">    {IPCIDRROUTEMETRIC5, INTEGER32, RONLY, ipCidrTable, 3, {4, 1, 15}},</a>
<a name="ln135">    {IPCIDRROUTESTATUS, ROWSTATUS, RONLY, ipCidrTable, 3, {4, 1, 16}}</a>
<a name="ln136">  };</a>
<a name="ln137"> </a>
<a name="ln138"> </a>
<a name="ln139">static u_char *</a>
<a name="ln140">ipFwNumber (struct variable *v, oid objid[], size_t *objid_len,</a>
<a name="ln141">	    int exact, size_t *val_len, WriteMethod **write_method)</a>
<a name="ln142">{</a>
<a name="ln143">  static int result;</a>
<a name="ln144">  struct route_table *table;</a>
<a name="ln145">  struct route_node *rn;</a>
<a name="ln146">  struct rib *rib;</a>
<a name="ln147"> </a>
<a name="ln148">  if (smux_header_generic(v, objid, objid_len, exact, val_len, write_method) == MATCH_FAILED)</a>
<a name="ln149">    return NULL;</a>
<a name="ln150"> </a>
<a name="ln151">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, VRF_DEFAULT);</a>
<a name="ln152">  if (! table)</a>
<a name="ln153">    return NULL;</a>
<a name="ln154"> </a>
<a name="ln155">  /* Return number of routing entries. */</a>
<a name="ln156">  result = 0;</a>
<a name="ln157">  for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln158">    RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln159">      result++;</a>
<a name="ln160"> </a>
<a name="ln161">  return (u_char *)&amp;result;</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">static u_char *</a>
<a name="ln165">ipCidrNumber (struct variable *v, oid objid[], size_t *objid_len,</a>
<a name="ln166">	      int exact, size_t *val_len, WriteMethod **write_method)</a>
<a name="ln167">{</a>
<a name="ln168">  static int result;</a>
<a name="ln169">  struct route_table *table;</a>
<a name="ln170">  struct route_node *rn;</a>
<a name="ln171">  struct rib *rib;</a>
<a name="ln172"> </a>
<a name="ln173">  if (smux_header_generic(v, objid, objid_len, exact, val_len, write_method) == MATCH_FAILED)</a>
<a name="ln174">    return NULL;</a>
<a name="ln175"> </a>
<a name="ln176">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, VRF_DEFAULT);</a>
<a name="ln177">  if (! table)</a>
<a name="ln178">    return 0;</a>
<a name="ln179"> </a>
<a name="ln180">  /* Return number of routing entries. */</a>
<a name="ln181">  result = 0;</a>
<a name="ln182">  for (rn = route_top (table); rn; rn = route_next (rn))</a>
<a name="ln183">    RNODE_FOREACH_RIB (rn, rib)</a>
<a name="ln184">      result++;</a>
<a name="ln185"> </a>
<a name="ln186">  return (u_char *)&amp;result;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">static int</a>
<a name="ln190">in_addr_cmp(u_char *p1, u_char *p2)</a>
<a name="ln191">{</a>
<a name="ln192">  int i;</a>
<a name="ln193"> </a>
<a name="ln194">  for (i=0; i&lt;4; i++)</a>
<a name="ln195">    {</a>
<a name="ln196">      if (*p1 &lt; *p2)</a>
<a name="ln197">        return -1;</a>
<a name="ln198">      if (*p1 &gt; *p2)</a>
<a name="ln199">        return 1;</a>
<a name="ln200">      p1++; p2++;</a>
<a name="ln201">    }</a>
<a name="ln202">  return 0;</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">static int </a>
<a name="ln206">in_addr_add(u_char *p, int num)</a>
<a name="ln207">{</a>
<a name="ln208">  int i, ip0;</a>
<a name="ln209"> </a>
<a name="ln210">  ip0 = *p;</a>
<a name="ln211">  p += 4;</a>
<a name="ln212">  for (i = 3; 0 &lt;= i; i--) {</a>
<a name="ln213">    p--;</a>
<a name="ln214">    if (*p + num &gt; 255) {</a>
<a name="ln215">      *p += num;</a>
<a name="ln216">      num = 1;</a>
<a name="ln217">    } else {</a>
<a name="ln218">      *p += num;</a>
<a name="ln219">      return 1;</a>
<a name="ln220">    }</a>
<a name="ln221">  }</a>
<a name="ln222">  if (ip0 &gt; *p) {</a>
<a name="ln223">    /* ip + num &gt; 0xffffffff */</a>
<a name="ln224">    return 0;</a>
<a name="ln225">  }</a>
<a name="ln226">  </a>
<a name="ln227">  return 1;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">static int</a>
<a name="ln231">proto_trans(int type)</a>
<a name="ln232">{</a>
<a name="ln233">  switch (type)</a>
<a name="ln234">    {</a>
<a name="ln235">    case ZEBRA_ROUTE_SYSTEM:</a>
<a name="ln236">      return 1; /* other */</a>
<a name="ln237">    case ZEBRA_ROUTE_KERNEL:</a>
<a name="ln238">      return 1; /* other */</a>
<a name="ln239">    case ZEBRA_ROUTE_CONNECT:</a>
<a name="ln240">      return 2; /* local interface */</a>
<a name="ln241">    case ZEBRA_ROUTE_STATIC:</a>
<a name="ln242">      return 3; /* static route */</a>
<a name="ln243">    case ZEBRA_ROUTE_RIP:</a>
<a name="ln244">      return 8; /* rip */</a>
<a name="ln245">    case ZEBRA_ROUTE_RIPNG:</a>
<a name="ln246">      return 1; /* shouldn't happen */</a>
<a name="ln247">    case ZEBRA_ROUTE_OSPF:</a>
<a name="ln248">      return 13; /* ospf */</a>
<a name="ln249">    case ZEBRA_ROUTE_OSPF6:</a>
<a name="ln250">      return 1; /* shouldn't happen */</a>
<a name="ln251">    case ZEBRA_ROUTE_BGP:</a>
<a name="ln252">      return 14; /* bgp */</a>
<a name="ln253">    default:</a>
<a name="ln254">      return 1; /* other */</a>
<a name="ln255">    }</a>
<a name="ln256">}</a>
<a name="ln257"> </a>
<a name="ln258">static void</a>
<a name="ln259">check_replace(struct route_node *np2, struct rib *rib2, </a>
<a name="ln260">              struct route_node **np, struct rib **rib)</a>
<a name="ln261">{</a>
<a name="ln262">  int proto, proto2;</a>
<a name="ln263"> </a>
<a name="ln264">  if (!*np)</a>
<a name="ln265">    {</a>
<a name="ln266">      *np = np2;</a>
<a name="ln267">      *rib = rib2;</a>
<a name="ln268">      return;</a>
<a name="ln269">    }</a>
<a name="ln270"> </a>
<a name="ln271">  if (in_addr_cmp(&amp;(*np)-&gt;p.u.prefix, &amp;np2-&gt;p.u.prefix) &lt; 0)</a>
<a name="ln272">    return;</a>
<a name="ln273">  if (in_addr_cmp(&amp;(*np)-&gt;p.u.prefix, &amp;np2-&gt;p.u.prefix) &gt; 0)</a>
<a name="ln274">    {</a>
<a name="ln275">      *np = np2;</a>
<a name="ln276">      *rib = rib2;</a>
<a name="ln277">      return;</a>
<a name="ln278">    }</a>
<a name="ln279"> </a>
<a name="ln280">  proto = proto_trans((*rib)-&gt;type);</a>
<a name="ln281">  proto2 = proto_trans(rib2-&gt;type);</a>
<a name="ln282"> </a>
<a name="ln283">  if (proto2 &gt; proto)</a>
<a name="ln284">    return;</a>
<a name="ln285">  if (proto2 &lt; proto)</a>
<a name="ln286">    {</a>
<a name="ln287">      *np = np2;</a>
<a name="ln288">      *rib = rib2;</a>
<a name="ln289">      return;</a>
<a name="ln290">    }</a>
<a name="ln291"> </a>
<a name="ln292">  if (in_addr_cmp((u_char *)&amp;(*rib)-&gt;nexthop-&gt;gate.ipv4, </a>
<a name="ln293">                  (u_char *)&amp;rib2-&gt;nexthop-&gt;gate.ipv4) &lt;= 0)</a>
<a name="ln294">    return;</a>
<a name="ln295"> </a>
<a name="ln296">  *np = np2;</a>
<a name="ln297">  *rib = rib2;</a>
<a name="ln298">  return;</a>
<a name="ln299">}</a>
<a name="ln300"> </a>
<a name="ln301">static void</a>
<a name="ln302">get_fwtable_route_node(struct variable *v, oid objid[], size_t *objid_len, </a>
<a name="ln303">		       int exact, struct route_node **np, struct rib **rib)</a>
<a name="ln304">{</a>
<a name="ln305">  struct in_addr dest;</a>
<a name="ln306">  struct route_table *table;</a>
<a name="ln307">  struct route_node *np2;</a>
<a name="ln308">  struct rib *rib2;</a>
<a name="ln309">  int proto;</a>
<a name="ln310">  int policy;</a>
<a name="ln311">  struct in_addr nexthop;</a>
<a name="ln312">  u_char *pnt;</a>
<a name="ln313">  int i;</a>
<a name="ln314"> </a>
<a name="ln315">  /* Init index variables */</a>
<a name="ln316"> </a>
<a name="ln317">  pnt = (u_char *) &amp;dest;</a>
<a name="ln318">  for (i = 0; i &lt; 4; i++)</a>
<a name="ln319">    *pnt++ = 0;</a>
<a name="ln320"> </a>
<a name="ln321">  pnt = (u_char *) &amp;nexthop;</a>
<a name="ln322">  for (i = 0; i &lt; 4; i++)</a>
<a name="ln323">    *pnt++ = 0;</a>
<a name="ln324"> </a>
<a name="ln325">  proto = 0;</a>
<a name="ln326">  policy = 0;</a>
<a name="ln327"> </a>
<a name="ln328">  /* Init return variables */</a>
<a name="ln329"> </a>
<a name="ln330">  *np = NULL;</a>
<a name="ln331">  *rib = NULL;</a>
<a name="ln332"> </a>
<a name="ln333">  /* Short circuit exact matches of wrong length */</a>
<a name="ln334"> </a>
<a name="ln335">  if (exact &amp;&amp; (*objid_len != (unsigned) v-&gt;namelen + 10))</a>
<a name="ln336">    return;</a>
<a name="ln337"> </a>
<a name="ln338">  table = zebra_vrf_table (AFI_IP, SAFI_UNICAST, VRF_DEFAULT);</a>
<a name="ln339">  if (! table)</a>
<a name="ln340">    return;</a>
<a name="ln341"> </a>
<a name="ln342">  /* Get INDEX information out of OID.</a>
<a name="ln343">   * ipForwardDest, ipForwardProto, ipForwardPolicy, ipForwardNextHop</a>
<a name="ln344">   */</a>
<a name="ln345"> </a>
<a name="ln346">  if (*objid_len &gt; (unsigned) v-&gt;namelen)</a>
<a name="ln347">    oid2in_addr (objid + v-&gt;namelen, MIN(4, *objid_len - v-&gt;namelen), &amp;dest);</a>
<a name="ln348"> </a>
<a name="ln349">  if (*objid_len &gt; (unsigned) v-&gt;namelen + 4)</a>
<a name="ln350">    proto = objid[v-&gt;namelen + 4];</a>
<a name="ln351"> </a>
<a name="ln352">  if (*objid_len &gt; (unsigned) v-&gt;namelen + 5)</a>
<a name="ln353">    policy = objid[v-&gt;namelen + 5];</a>
<a name="ln354"> </a>
<a name="ln355">  if (*objid_len &gt; (unsigned) v-&gt;namelen + 6)</a>
<a name="ln356">    oid2in_addr (objid + v-&gt;namelen + 6, MIN(4, *objid_len - v-&gt;namelen - 6),</a>
<a name="ln357">		 &amp;nexthop);</a>
<a name="ln358"> </a>
<a name="ln359">  /* Apply GETNEXT on not exact search */</a>
<a name="ln360"> </a>
<a name="ln361">  if (!exact &amp;&amp; (*objid_len &gt;= (unsigned) v-&gt;namelen + 10))</a>
<a name="ln362">    {</a>
<a name="ln363">      if (! in_addr_add((u_char *) &amp;nexthop, 1)) </a>
<a name="ln364">        return;</a>
<a name="ln365">    }</a>
<a name="ln366"> </a>
<a name="ln367">  /* For exact: search matching entry in rib table. */</a>
<a name="ln368"> </a>
<a name="ln369">  if (exact)</a>
<a name="ln370">    {</a>
<a name="ln371">      if (policy) /* Not supported (yet?) */</a>
<a name="ln372">        return;</a>
<a name="ln373">      for (*np = route_top (table); *np; *np = route_next (*np))</a>
<a name="ln374">	{</a>
<a name="ln375">	  if (!in_addr_cmp(&amp;(*np)-&gt;p.u.prefix, (u_char *)&amp;dest))</a>
<a name="ln376">	    {</a>
<a name="ln377">	      RNODE_FOREACH_RIB (*np, *rib)</a>
<a name="ln378">	        {</a>
<a name="ln379">		  if (!in_addr_cmp((u_char *)&amp;(*rib)-&gt;nexthop-&gt;gate.ipv4,</a>
<a name="ln380">				   (u_char *)&amp;nexthop))</a>
<a name="ln381">		    if (proto == proto_trans((*rib)-&gt;type))</a>
<a name="ln382">		      return;</a>
<a name="ln383">		}</a>
<a name="ln384">	    }</a>
<a name="ln385">	}</a>
<a name="ln386">      return;</a>
<a name="ln387">    }</a>
<a name="ln388"> </a>
<a name="ln389">  /* Search next best entry */</a>
<a name="ln390"> </a>
<a name="ln391">  for (np2 = route_top (table); np2; np2 = route_next (np2))</a>
<a name="ln392">    {</a>
<a name="ln393"> </a>
<a name="ln394">      /* Check destination first */</a>
<a name="ln395">      if (in_addr_cmp(&amp;np2-&gt;p.u.prefix, (u_char *)&amp;dest) &gt; 0)</a>
<a name="ln396">	RNODE_FOREACH_RIB (np2, rib2)</a>
<a name="ln397">	  check_replace(np2, rib2, np, rib);</a>
<a name="ln398"> </a>
<a name="ln399">      if (in_addr_cmp(&amp;np2-&gt;p.u.prefix, (u_char *)&amp;dest) == 0)</a>
<a name="ln400">        { /* have to look at each rib individually */</a>
<a name="ln401">	  RNODE_FOREACH_RIB (np2, rib2)</a>
<a name="ln402">	    {</a>
<a name="ln403">	      int proto2, policy2;</a>
<a name="ln404"> </a>
<a name="ln405">	      proto2 = proto_trans(rib2-&gt;type);</a>
<a name="ln406">	      policy2 = 0;</a>
<a name="ln407"> </a>
<a name="ln408">	      if ((policy &lt; policy2)</a>
<a name="ln409">		  || ((policy == policy2) &amp;&amp; (proto &lt; proto2))</a>
<a name="ln410">		  || ((policy == policy2) &amp;&amp; (proto == proto2)</a>
<a name="ln411">		      &amp;&amp; (in_addr_cmp((u_char *)&amp;rib2-&gt;nexthop-&gt;gate.ipv4,</a>
<a name="ln412">				      (u_char *) &amp;nexthop) &gt;= 0)</a>
<a name="ln413">		      ))</a>
<a name="ln414">		check_replace(np2, rib2, np, rib);</a>
<a name="ln415">	    }</a>
<a name="ln416">	}</a>
<a name="ln417">    }</a>
<a name="ln418"> </a>
<a name="ln419">  if (!*rib)</a>
<a name="ln420">    return;</a>
<a name="ln421"> </a>
<a name="ln422">  policy = 0;</a>
<a name="ln423">  proto = proto_trans((*rib)-&gt;type);</a>
<a name="ln424"> </a>
<a name="ln425">  *objid_len = v-&gt;namelen + 10;</a>
<a name="ln426">  pnt = (u_char *) &amp;(*np)-&gt;p.u.prefix;</a>
<a name="ln427">  for (i = 0; i &lt; 4; i++)</a>
<a name="ln428">    objid[v-&gt;namelen + i] = *pnt++;</a>
<a name="ln429"> </a>
<a name="ln430">  objid[v-&gt;namelen + 4] = proto;</a>
<a name="ln431">  objid[v-&gt;namelen + 5] = policy;</a>
<a name="ln432"> </a>
<a name="ln433">  {</a>
<a name="ln434">    struct nexthop *nexthop;</a>
<a name="ln435"> </a>
<a name="ln436">    nexthop = (*rib)-&gt;nexthop;</a>
<a name="ln437">    if (nexthop)</a>
<a name="ln438">      {</a>
<a name="ln439">	pnt = (u_char *) &amp;nexthop-&gt;gate.ipv4;</a>
<a name="ln440">	for (i = 0; i &lt; 4; i++)</a>
<a name="ln441">	  objid[i + v-&gt;namelen + 6] = *pnt++;</a>
<a name="ln442">      }</a>
<a name="ln443">  }</a>
<a name="ln444"> </a>
<a name="ln445">  return;</a>
<a name="ln446">}</a>
<a name="ln447"> </a>
<a name="ln448">static u_char *</a>
<a name="ln449">ipFwTable (struct variable *v, oid objid[], size_t *objid_len,</a>
<a name="ln450">	   int exact, size_t *val_len, WriteMethod **write_method)</a>
<a name="ln451">{</a>
<a name="ln452">  struct route_node *np;</a>
<a name="ln453">  struct rib *rib;</a>
<a name="ln454">  static int result;</a>
<a name="ln455">  static int resarr[2];</a>
<a name="ln456">  static struct in_addr netmask;</a>
<a name="ln457">  struct nexthop *nexthop;</a>
<a name="ln458"> </a>
<a name="ln459">  if (smux_header_table(v, objid, objid_len, exact, val_len, write_method)</a>
<a name="ln460">      == MATCH_FAILED)</a>
<a name="ln461">    return NULL;</a>
<a name="ln462"> </a>
<a name="ln463">  get_fwtable_route_node(v, objid, objid_len, exact, &amp;np, &amp;rib);</a>
<a name="ln464">  if (!np)</a>
<a name="ln465">    return NULL;</a>
<a name="ln466"> </a>
<a name="ln467">  nexthop = rib-&gt;nexthop;</a>
<a name="ln468">  if (! nexthop)</a>
<a name="ln469">    return NULL;</a>
<a name="ln470"> </a>
<a name="ln471">  switch (v-&gt;magic)</a>
<a name="ln472">    {</a>
<a name="ln473">    case IPFORWARDDEST:</a>
<a name="ln474">      *val_len = 4;</a>
<a name="ln475">      return &amp;np-&gt;p.u.prefix;</a>
<a name="ln476">      break;</a>
<a name="ln477">    case IPFORWARDMASK:</a>
<a name="ln478">      masklen2ip(np-&gt;p.prefixlen, &amp;netmask);</a>
<a name="ln479">      *val_len = 4;</a>
<a name="ln480">      return (u_char *)&amp;netmask;</a>
<a name="ln481">      break;</a>
<a name="ln482">    case IPFORWARDPOLICY:</a>
<a name="ln483">      result = 0;</a>
<a name="ln484">      *val_len  = sizeof(int);</a>
<a name="ln485">      return (u_char *)&amp;result;</a>
<a name="ln486">      break;</a>
<a name="ln487">    case IPFORWARDNEXTHOP:</a>
<a name="ln488">      *val_len = 4;</a>
<a name="ln489">      return (u_char *)&amp;nexthop-&gt;gate.ipv4;</a>
<a name="ln490">      break;</a>
<a name="ln491">    case IPFORWARDIFINDEX:</a>
<a name="ln492">      *val_len = sizeof(int);</a>
<a name="ln493">      return (u_char *)&amp;nexthop-&gt;ifindex;</a>
<a name="ln494">      break;</a>
<a name="ln495">    case IPFORWARDTYPE:</a>
<a name="ln496">      if (nexthop-&gt;type == NEXTHOP_TYPE_IFINDEX</a>
<a name="ln497">	  || nexthop-&gt;type == NEXTHOP_TYPE_IFNAME)</a>
<a name="ln498">        result = 3;</a>
<a name="ln499">      else</a>
<a name="ln500">        result = 4;</a>
<a name="ln501">      *val_len  = sizeof(int);</a>
<a name="ln502">      return (u_char *)&amp;result;</a>
<a name="ln503">      break;</a>
<a name="ln504">    case IPFORWARDPROTO:</a>
<a name="ln505">      result = proto_trans(rib-&gt;type);</a>
<a name="ln506">      *val_len  = sizeof(int);</a>
<a name="ln507">      return (u_char *)&amp;result;</a>
<a name="ln508">      break;</a>
<a name="ln509">    case IPFORWARDAGE:</a>
<a name="ln510">      result = 0;</a>
<a name="ln511">      *val_len  = sizeof(int);</a>
<a name="ln512">      return (u_char *)&amp;result;</a>
<a name="ln513">      break;</a>
<a name="ln514">    case IPFORWARDINFO:</a>
<a name="ln515">      resarr[0] = 0;</a>
<a name="ln516">      resarr[1] = 0;</a>
<a name="ln517">      *val_len  = 2 * sizeof(int);</a>
<a name="ln518">      return (u_char *)resarr;</a>
<a name="ln519">      break;</a>
<a name="ln520">    case IPFORWARDNEXTHOPAS:</a>
<a name="ln521">      result = -1;</a>
<a name="ln522">      *val_len  = sizeof(int);</a>
<a name="ln523">      return (u_char *)&amp;result;</a>
<a name="ln524">      break;</a>
<a name="ln525">    case IPFORWARDMETRIC1:</a>
<a name="ln526">      result = 0;</a>
<a name="ln527">      *val_len  = sizeof(int);</a>
<a name="ln528">      return (u_char *)&amp;result;</a>
<a name="ln529">      break;</a>
<a name="ln530">    case IPFORWARDMETRIC2:</a>
<a name="ln531">      result = 0;</a>
<a name="ln532">      *val_len  = sizeof(int);</a>
<a name="ln533">      return (u_char *)&amp;result;</a>
<a name="ln534">      break;</a>
<a name="ln535">    case IPFORWARDMETRIC3:</a>
<a name="ln536">      result = 0;</a>
<a name="ln537">      *val_len  = sizeof(int);</a>
<a name="ln538">      return (u_char *)&amp;result;</a>
<a name="ln539">      break;</a>
<a name="ln540">    case IPFORWARDMETRIC4:</a>
<a name="ln541">      result = 0;</a>
<a name="ln542">      *val_len  = sizeof(int);</a>
<a name="ln543">      return (u_char *)&amp;result;</a>
<a name="ln544">      break;</a>
<a name="ln545">    case IPFORWARDMETRIC5:</a>
<a name="ln546">      result = 0;</a>
<a name="ln547">      *val_len  = sizeof(int);</a>
<a name="ln548">      return (u_char *)&amp;result;</a>
<a name="ln549">      break;</a>
<a name="ln550">    default:</a>
<a name="ln551">      return NULL;</a>
<a name="ln552">      break;</a>
<a name="ln553">    }  </a>
<a name="ln554">  return NULL;</a>
<a name="ln555">}</a>
<a name="ln556"> </a>
<a name="ln557">static u_char *</a>
<a name="ln558">ipCidrTable (struct variable *v, oid objid[], size_t *objid_len,</a>
<a name="ln559">	     int exact, size_t *val_len, WriteMethod **write_method)</a>
<a name="ln560">{</a>
<a name="ln561">  if (smux_header_table(v, objid, objid_len, exact, val_len, write_method)</a>
<a name="ln562">      == MATCH_FAILED)</a>
<a name="ln563">    return NULL;</a>
<a name="ln564"> </a>
<a name="ln565">  switch (v-&gt;magic)</a>
<a name="ln566">    {</a>
<a name="ln567">    case IPCIDRROUTEDEST:</a>
<a name="ln568">      break;</a>
<a name="ln569">    default:</a>
<a name="ln570">      return NULL;</a>
<a name="ln571">      break;</a>
<a name="ln572">    }  </a>
<a name="ln573">  return NULL;</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">void</a>
<a name="ln577">zebra_snmp_init ()</a>
<a name="ln578">{</a>
<a name="ln579">  smux_init (zebrad.master);</a>
<a name="ln580">  REGISTER_MIB(&quot;mibII/ipforward&quot;, zebra_variables, variable, ipfw_oid);</a>
<a name="ln581">}</a>
<a name="ln582">#endif /* HAVE_SNMP */</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
