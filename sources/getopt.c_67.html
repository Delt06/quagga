
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>getopt.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Getopt for GNU.</a>
<a name="ln2">   NOTE: getopt is now part of the C library, so if you don't know what</a>
<a name="ln3">   &quot;Keep this file name-space clean&quot; means, talk to drepper@gnu.org</a>
<a name="ln4">   before changing it!</a>
<a name="ln5"> </a>
<a name="ln6">   Copyright (C) 1987, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98</a>
<a name="ln7">   	Free Software Foundation, Inc.</a>
<a name="ln8"> </a>
<a name="ln9">   NOTE: The canonical source of this file is maintained with the GNU C Library.</a>
<a name="ln10">   Bugs can be reported to bug-glibc@gnu.org.</a>
<a name="ln11"> </a>
<a name="ln12">   This program is free software; you can redistribute it and/or modify it</a>
<a name="ln13">   under the terms of the GNU General Public License as published by the</a>
<a name="ln14">   Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln15">   later version.</a>
<a name="ln16"> </a>
<a name="ln17">   This program is distributed in the hope that it will be useful,</a>
<a name="ln18">   but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln19">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln20">   GNU General Public License for more details.</a>
<a name="ln21"> </a>
<a name="ln22">   You should have received a copy of the GNU General Public License</a>
<a name="ln23">   along with this program; if not, write to the Free Software</a>
<a name="ln24">   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,</a>
<a name="ln25">   USA.  */</a>
<a name="ln26"> </a>
<a name="ln27">/* This tells Alpha OSF/1 not to define a getopt prototype in &lt;stdio.h&gt;.</a>
<a name="ln28">   Ditto for AIX 3.2 and &lt;stdlib.h&gt;.  */</a>
<a name="ln29">#ifndef _NO_PROTO</a>
<a name="ln30"># define _NO_PROTO</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33">#include &lt;zebra.h&gt;</a>
<a name="ln34"> </a>
<a name="ln35">#if !defined __STDC__ || !__STDC__</a>
<a name="ln36">/* This is a separate conditional since some stdc systems</a>
<a name="ln37">   reject `defined (const)'.  */</a>
<a name="ln38"># ifndef const</a>
<a name="ln39">#  define const</a>
<a name="ln40"># endif</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;stdio.h&gt;</a>
<a name="ln44"> </a>
<a name="ln45">/* Comment out all this code if we are using the GNU C Library, and are not</a>
<a name="ln46">   actually compiling the library itself.  This code is part of the GNU C</a>
<a name="ln47">   Library, but also included in many other GNU distributions.  Compiling</a>
<a name="ln48">   and linking in this code is a waste when using the GNU C library</a>
<a name="ln49">   (especially if it is a shared library).  Rather than having every GNU</a>
<a name="ln50">   program understand `configure --with-gnu-libc' and omit the object files,</a>
<a name="ln51">   it is simpler to just do this in the source for each such file.  */</a>
<a name="ln52"> </a>
<a name="ln53">#define GETOPT_INTERFACE_VERSION 2</a>
<a name="ln54">#if !defined _LIBC &amp;&amp; defined __GLIBC__ &amp;&amp; __GLIBC__ &gt;= 2</a>
<a name="ln55"># include &lt;gnu-versions.h&gt;</a>
<a name="ln56"># if _GNU_GETOPT_INTERFACE_VERSION == GETOPT_INTERFACE_VERSION</a>
<a name="ln57">#  define ELIDE_CODE</a>
<a name="ln58"># endif</a>
<a name="ln59">#endif</a>
<a name="ln60"> </a>
<a name="ln61">#ifndef ELIDE_CODE</a>
<a name="ln62"> </a>
<a name="ln63"> </a>
<a name="ln64">/* This needs to come after some library #include</a>
<a name="ln65">   to get __GNU_LIBRARY__ defined.  */</a>
<a name="ln66">#ifdef	__GNU_LIBRARY__</a>
<a name="ln67">/* Don't include stdlib.h for non-GNU C libraries because some of them</a>
<a name="ln68">   contain conflicting prototypes for getopt.  */</a>
<a name="ln69"># include &lt;stdlib.h&gt;</a>
<a name="ln70"># include &lt;unistd.h&gt;</a>
<a name="ln71">#endif	/* GNU C library.  */</a>
<a name="ln72"> </a>
<a name="ln73">#ifdef VMS</a>
<a name="ln74"># include &lt;unixlib.h&gt;</a>
<a name="ln75"># if HAVE_STRING_H - 0</a>
<a name="ln76">#  include &lt;string.h&gt;</a>
<a name="ln77"># endif</a>
<a name="ln78">#endif</a>
<a name="ln79"> </a>
<a name="ln80">#ifndef _</a>
<a name="ln81">/* This is for other GNU distributions with internationalized messages.</a>
<a name="ln82">   When compiling libc, the _ macro is predefined.  */</a>
<a name="ln83"># ifdef HAVE_LIBINTL_H</a>
<a name="ln84">#  include &lt;libintl.h&gt;</a>
<a name="ln85">#  define _(msgid)	gettext (msgid)</a>
<a name="ln86"># else</a>
<a name="ln87">#  define _(msgid)	(msgid)</a>
<a name="ln88"># endif</a>
<a name="ln89">#endif</a>
<a name="ln90"> </a>
<a name="ln91">/* This version of `getopt' appears to the caller like standard Unix `getopt'</a>
<a name="ln92">   but it behaves differently for the user, since it allows the user</a>
<a name="ln93">   to intersperse the options with the other arguments.</a>
<a name="ln94"> </a>
<a name="ln95">   As `getopt' works, it permutes the elements of ARGV so that,</a>
<a name="ln96">   when it is done, all the options precede everything else.  Thus</a>
<a name="ln97">   all application programs are extended to handle flexible argument order.</a>
<a name="ln98"> </a>
<a name="ln99">   Setting the environment variable POSIXLY_CORRECT disables permutation.</a>
<a name="ln100">   Then the behavior is completely standard.</a>
<a name="ln101"> </a>
<a name="ln102">   GNU application programs can use a third alternative mode in which</a>
<a name="ln103">   they can distinguish the relative order of options and other arguments.  */</a>
<a name="ln104"> </a>
<a name="ln105">#include &quot;getopt.h&quot;</a>
<a name="ln106"> </a>
<a name="ln107">/* For communication from `getopt' to the caller.</a>
<a name="ln108">   When `getopt' finds an option that takes an argument,</a>
<a name="ln109">   the argument value is returned here.</a>
<a name="ln110">   Also, when `ordering' is RETURN_IN_ORDER,</a>
<a name="ln111">   each non-option ARGV-element is returned here.  */</a>
<a name="ln112"> </a>
<a name="ln113">char *optarg = NULL;</a>
<a name="ln114"> </a>
<a name="ln115">/* Index in ARGV of the next element to be scanned.</a>
<a name="ln116">   This is used for communication to and from the caller</a>
<a name="ln117">   and for communication between successive calls to `getopt'.</a>
<a name="ln118"> </a>
<a name="ln119">   On entry to `getopt', zero means this is the first call; initialize.</a>
<a name="ln120"> </a>
<a name="ln121">   When `getopt' returns -1, this is the index of the first of the</a>
<a name="ln122">   non-option elements that the caller should itself scan.</a>
<a name="ln123"> </a>
<a name="ln124">   Otherwise, `optind' communicates from one call to the next</a>
<a name="ln125">   how much of ARGV has been scanned so far.  */</a>
<a name="ln126"> </a>
<a name="ln127">/* 1003.2 says this must be 1 before any call.  */</a>
<a name="ln128">int optind = 1;</a>
<a name="ln129"> </a>
<a name="ln130">/* Formerly, initialization of getopt depended on optind==0, which</a>
<a name="ln131">   causes problems with re-calling getopt as programs generally don't</a>
<a name="ln132">   know that. */</a>
<a name="ln133"> </a>
<a name="ln134">int __getopt_initialized = 0;</a>
<a name="ln135"> </a>
<a name="ln136">/* The next char to be scanned in the option-element</a>
<a name="ln137">   in which the last option character we returned was found.</a>
<a name="ln138">   This allows us to pick up the scan where we left off.</a>
<a name="ln139"> </a>
<a name="ln140">   If this is zero, or a null string, it means resume the scan</a>
<a name="ln141">   by advancing to the next ARGV-element.  */</a>
<a name="ln142"> </a>
<a name="ln143">static char *nextchar;</a>
<a name="ln144"> </a>
<a name="ln145">/* Callers store zero here to inhibit the error message</a>
<a name="ln146">   for unrecognized options.  */</a>
<a name="ln147"> </a>
<a name="ln148">int opterr = 1;</a>
<a name="ln149"> </a>
<a name="ln150">/* Set to an option character which was unrecognized.</a>
<a name="ln151">   This must be initialized on some systems to avoid linking in the</a>
<a name="ln152">   system's own getopt implementation.  */</a>
<a name="ln153"> </a>
<a name="ln154">int optopt = '?';</a>
<a name="ln155"> </a>
<a name="ln156">/* Describe how to deal with options that follow non-option ARGV-elements.</a>
<a name="ln157"> </a>
<a name="ln158">   If the caller did not specify anything,</a>
<a name="ln159">   the default is REQUIRE_ORDER if the environment variable</a>
<a name="ln160">   POSIXLY_CORRECT is defined, PERMUTE otherwise.</a>
<a name="ln161"> </a>
<a name="ln162">   REQUIRE_ORDER means don't recognize them as options;</a>
<a name="ln163">   stop option processing when the first non-option is seen.</a>
<a name="ln164">   This is what Unix does.</a>
<a name="ln165">   This mode of operation is selected by either setting the environment</a>
<a name="ln166">   variable POSIXLY_CORRECT, or using `+' as the first character</a>
<a name="ln167">   of the list of option characters.</a>
<a name="ln168"> </a>
<a name="ln169">   PERMUTE is the default.  We permute the contents of ARGV as we scan,</a>
<a name="ln170">   so that eventually all the non-options are at the end.  This allows options</a>
<a name="ln171">   to be given in any order, even with programs that were not written to</a>
<a name="ln172">   expect this.</a>
<a name="ln173"> </a>
<a name="ln174">   RETURN_IN_ORDER is an option available to programs that were written</a>
<a name="ln175">   to expect options and other ARGV-elements in any order and that care about</a>
<a name="ln176">   the ordering of the two.  We describe each non-option ARGV-element</a>
<a name="ln177">   as if it were the argument of an option with character code 1.</a>
<a name="ln178">   Using `-' as the first character of the list of option characters</a>
<a name="ln179">   selects this mode of operation.</a>
<a name="ln180"> </a>
<a name="ln181">   The special argument `--' forces an end of option-scanning regardless</a>
<a name="ln182">   of the value of `ordering'.  In the case of RETURN_IN_ORDER, only</a>
<a name="ln183">   `--' can cause `getopt' to return -1 with `optind' != ARGC.  */</a>
<a name="ln184"> </a>
<a name="ln185">static enum</a>
<a name="ln186">{</a>
<a name="ln187">  REQUIRE_ORDER, PERMUTE, RETURN_IN_ORDER</a>
<a name="ln188">} ordering;</a>
<a name="ln189"> </a>
<a name="ln190">/* Value of POSIXLY_CORRECT environment variable.  */</a>
<a name="ln191">static char *posixly_correct;</a>
<a name="ln192"> </a>
<a name="ln193">#ifdef	__GNU_LIBRARY__</a>
<a name="ln194">/* We want to avoid inclusion of string.h with non-GNU libraries</a>
<a name="ln195">   because there are many ways it can cause trouble.</a>
<a name="ln196">   On some systems, it contains special magic macros that don't work</a>
<a name="ln197">   in GCC.  */</a>
<a name="ln198"># include &lt;string.h&gt;</a>
<a name="ln199"># define my_index	strchr</a>
<a name="ln200">#else</a>
<a name="ln201"> </a>
<a name="ln202"># if HAVE_STRING_H</a>
<a name="ln203">#  include &lt;string.h&gt;</a>
<a name="ln204"># else</a>
<a name="ln205">#  include &lt;strings.h&gt;</a>
<a name="ln206"># endif</a>
<a name="ln207"> </a>
<a name="ln208">/* Avoid depending on library functions or files</a>
<a name="ln209">   whose names are inconsistent.  */</a>
<a name="ln210"> </a>
<a name="ln211">#ifndef getenv</a>
<a name="ln212">extern char *getenv ();</a>
<a name="ln213">#endif</a>
<a name="ln214"> </a>
<a name="ln215">static char *</a>
<a name="ln216">my_index (str, chr)</a>
<a name="ln217">     const char *str;</a>
<a name="ln218">     int chr;</a>
<a name="ln219">{</a>
<a name="ln220">  while (*str)</a>
<a name="ln221">    {</a>
<a name="ln222">      if (*str == chr)</a>
<a name="ln223">	return (char *) str;</a>
<a name="ln224">      str++;</a>
<a name="ln225">    }</a>
<a name="ln226">  return 0;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">/* If using GCC, we can safely declare strlen this way.</a>
<a name="ln230">   If not using GCC, it is ok not to declare it.  */</a>
<a name="ln231">#ifdef __GNUC__</a>
<a name="ln232">/* Note that Motorola Delta 68k R3V7 comes with GCC but not stddef.h.</a>
<a name="ln233">   That was relevant to code that was here before.  */</a>
<a name="ln234"># if (!defined __STDC__ || !__STDC__) &amp;&amp; !defined strlen</a>
<a name="ln235">/* gcc with -traditional declares the built-in strlen to return int,</a>
<a name="ln236">   and has done so at least since version 2.4.5. -- rms.  */</a>
<a name="ln237">extern int strlen (const char *);</a>
<a name="ln238"># endif /* not __STDC__ */</a>
<a name="ln239">#endif /* __GNUC__ */</a>
<a name="ln240"> </a>
<a name="ln241">#endif /* not __GNU_LIBRARY__ */</a>
<a name="ln242"> </a>
<a name="ln243">/* Handle permutation of arguments.  */</a>
<a name="ln244"> </a>
<a name="ln245">/* Describe the part of ARGV that contains non-options that have</a>
<a name="ln246">   been skipped.  `first_nonopt' is the index in ARGV of the first of them;</a>
<a name="ln247">   `last_nonopt' is the index after the last of them.  */</a>
<a name="ln248"> </a>
<a name="ln249">static int first_nonopt;</a>
<a name="ln250">static int last_nonopt;</a>
<a name="ln251"> </a>
<a name="ln252">#ifdef _LIBC</a>
<a name="ln253">/* Bash 2.0 gives us an environment variable containing flags</a>
<a name="ln254">   indicating ARGV elements that should not be considered arguments.  */</a>
<a name="ln255"> </a>
<a name="ln256">/* Defined in getopt_init.c  */</a>
<a name="ln257">extern char *__getopt_nonoption_flags;</a>
<a name="ln258"> </a>
<a name="ln259">static int nonoption_flags_max_len;</a>
<a name="ln260">static int nonoption_flags_len;</a>
<a name="ln261"> </a>
<a name="ln262">static int original_argc;</a>
<a name="ln263">static char *const *original_argv;</a>
<a name="ln264"> </a>
<a name="ln265">/* Make sure the environment variable bash 2.0 puts in the environment</a>
<a name="ln266">   is valid for the getopt call we must make sure that the ARGV passed</a>
<a name="ln267">   to getopt is that one passed to the process.  */</a>
<a name="ln268">static void</a>
<a name="ln269">__attribute__ ((unused))</a>
<a name="ln270">store_args_and_env (int argc, char *const *argv)</a>
<a name="ln271">{</a>
<a name="ln272">  /* XXX This is no good solution.  We should rather copy the args so</a>
<a name="ln273">     that we can compare them later.  But we must not use malloc(3).  */</a>
<a name="ln274">  original_argc = argc;</a>
<a name="ln275">  original_argv = argv;</a>
<a name="ln276">}</a>
<a name="ln277"># ifdef text_set_element</a>
<a name="ln278">text_set_element (__libc_subinit, store_args_and_env);</a>
<a name="ln279"># endif /* text_set_element */</a>
<a name="ln280"> </a>
<a name="ln281"># define SWAP_FLAGS(ch1, ch2) \</a>
<a name="ln282">  if (nonoption_flags_len &gt; 0)						      \</a>
<a name="ln283">    {									      \</a>
<a name="ln284">      char __tmp = __getopt_nonoption_flags[ch1];			      \</a>
<a name="ln285">      __getopt_nonoption_flags[ch1] = __getopt_nonoption_flags[ch2];	      \</a>
<a name="ln286">      __getopt_nonoption_flags[ch2] = __tmp;				      \</a>
<a name="ln287">    }</a>
<a name="ln288">#else	/* !_LIBC */</a>
<a name="ln289"># define SWAP_FLAGS(ch1, ch2)</a>
<a name="ln290">#endif	/* _LIBC */</a>
<a name="ln291"> </a>
<a name="ln292">/* Exchange two adjacent subsequences of ARGV.</a>
<a name="ln293">   One subsequence is elements [first_nonopt,last_nonopt)</a>
<a name="ln294">   which contains all the non-options that have been skipped so far.</a>
<a name="ln295">   The other is elements [last_nonopt,optind), which contains all</a>
<a name="ln296">   the options processed since those non-options were skipped.</a>
<a name="ln297"> </a>
<a name="ln298">   `first_nonopt' and `last_nonopt' are relocated so that they describe</a>
<a name="ln299">   the new indices of the non-options in ARGV after they are moved.  */</a>
<a name="ln300"> </a>
<a name="ln301">#if defined __STDC__ &amp;&amp; __STDC__</a>
<a name="ln302">static void exchange (char **);</a>
<a name="ln303">#endif</a>
<a name="ln304"> </a>
<a name="ln305">static void</a>
<a name="ln306">exchange (argv)</a>
<a name="ln307">     char **argv;</a>
<a name="ln308">{</a>
<a name="ln309">  int bottom = first_nonopt;</a>
<a name="ln310">  int middle = last_nonopt;</a>
<a name="ln311">  int top = optind;</a>
<a name="ln312">  char *tem;</a>
<a name="ln313"> </a>
<a name="ln314">  /* Exchange the shorter segment with the far end of the longer segment.</a>
<a name="ln315">     That puts the shorter segment into the right place.</a>
<a name="ln316">     It leaves the longer segment in the right place overall,</a>
<a name="ln317">     but it consists of two parts that need to be swapped next.  */</a>
<a name="ln318"> </a>
<a name="ln319">#ifdef _LIBC</a>
<a name="ln320">  /* First make sure the handling of the `__getopt_nonoption_flags'</a>
<a name="ln321">     string can work normally.  Our top argument must be in the range</a>
<a name="ln322">     of the string.  */</a>
<a name="ln323">  if (nonoption_flags_len &gt; 0 &amp;&amp; top &gt;= nonoption_flags_max_len)</a>
<a name="ln324">    {</a>
<a name="ln325">      /* We must extend the array.  The user plays games with us and</a>
<a name="ln326">	 presents new arguments.  */</a>
<a name="ln327">      char *new_str = malloc (top + 1);</a>
<a name="ln328">      if (new_str == NULL)</a>
<a name="ln329">	nonoption_flags_len = nonoption_flags_max_len = 0;</a>
<a name="ln330">      else</a>
<a name="ln331">	{</a>
<a name="ln332">	  memset (__mempcpy (new_str, __getopt_nonoption_flags,</a>
<a name="ln333">			     nonoption_flags_max_len),</a>
<a name="ln334">		  '\0', top + 1 - nonoption_flags_max_len);</a>
<a name="ln335">	  nonoption_flags_max_len = top + 1;</a>
<a name="ln336">	  __getopt_nonoption_flags = new_str;</a>
<a name="ln337">	}</a>
<a name="ln338">    }</a>
<a name="ln339">#endif</a>
<a name="ln340"> </a>
<a name="ln341">  while (top &gt; middle &amp;&amp; middle &gt; bottom)</a>
<a name="ln342">    {</a>
<a name="ln343">      if (top - middle &gt; middle - bottom)</a>
<a name="ln344">	{</a>
<a name="ln345">	  /* Bottom segment is the short one.  */</a>
<a name="ln346">	  int len = middle - bottom;</a>
<a name="ln347">	  register int i;</a>
<a name="ln348"> </a>
<a name="ln349">	  /* Swap it with the top part of the top segment.  */</a>
<a name="ln350">	  for (i = 0; i &lt; len; i++)</a>
<a name="ln351">	    {</a>
<a name="ln352">	      tem = argv[bottom + i];</a>
<a name="ln353">	      argv[bottom + i] = argv[top - (middle - bottom) + i];</a>
<a name="ln354">	      argv[top - (middle - bottom) + i] = tem;</a>
<a name="ln355">	      SWAP_FLAGS (bottom + i, top - (middle - bottom) + i);</a>
<a name="ln356">	    }</a>
<a name="ln357">	  /* Exclude the moved bottom segment from further swapping.  */</a>
<a name="ln358">	  top -= len;</a>
<a name="ln359">	}</a>
<a name="ln360">      else</a>
<a name="ln361">	{</a>
<a name="ln362">	  /* Top segment is the short one.  */</a>
<a name="ln363">	  int len = top - middle;</a>
<a name="ln364">	  register int i;</a>
<a name="ln365"> </a>
<a name="ln366">	  /* Swap it with the bottom part of the bottom segment.  */</a>
<a name="ln367">	  for (i = 0; i &lt; len; i++)</a>
<a name="ln368">	    {</a>
<a name="ln369">	      tem = argv[bottom + i];</a>
<a name="ln370">	      argv[bottom + i] = argv[middle + i];</a>
<a name="ln371">	      argv[middle + i] = tem;</a>
<a name="ln372">	      SWAP_FLAGS (bottom + i, middle + i);</a>
<a name="ln373">	    }</a>
<a name="ln374">	  /* Exclude the moved top segment from further swapping.  */</a>
<a name="ln375">	  bottom += len;</a>
<a name="ln376">	}</a>
<a name="ln377">    }</a>
<a name="ln378"> </a>
<a name="ln379">  /* Update records for the slots the non-options now occupy.  */</a>
<a name="ln380"> </a>
<a name="ln381">  first_nonopt += (optind - last_nonopt);</a>
<a name="ln382">  last_nonopt = optind;</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">/* Initialize the internal data when the first call is made.  */</a>
<a name="ln386"> </a>
<a name="ln387">#if defined __STDC__ &amp;&amp; __STDC__</a>
<a name="ln388">static const char *_getopt_initialize (int, char *const *, const char *);</a>
<a name="ln389">#endif</a>
<a name="ln390">static const char *</a>
<a name="ln391">_getopt_initialize (argc, argv, optstring)</a>
<a name="ln392">     int argc;</a>
<a name="ln393">     char *const *argv;</a>
<a name="ln394">     const char *optstring;</a>
<a name="ln395">{</a>
<a name="ln396">  /* Start processing options with ARGV-element 1 (since ARGV-element 0</a>
<a name="ln397">     is the program name); the sequence of previously skipped</a>
<a name="ln398">     non-option ARGV-elements is empty.  */</a>
<a name="ln399"> </a>
<a name="ln400">  first_nonopt = last_nonopt = optind;</a>
<a name="ln401"> </a>
<a name="ln402">  nextchar = NULL;</a>
<a name="ln403"> </a>
<a name="ln404">  posixly_correct = getenv (&quot;POSIXLY_CORRECT&quot;);</a>
<a name="ln405"> </a>
<a name="ln406">  /* Determine how to handle the ordering of options and nonoptions.  */</a>
<a name="ln407"> </a>
<a name="ln408">  if (optstring[0] == '-')</a>
<a name="ln409">    {</a>
<a name="ln410">      ordering = RETURN_IN_ORDER;</a>
<a name="ln411">      ++optstring;</a>
<a name="ln412">    }</a>
<a name="ln413">  else if (optstring[0] == '+')</a>
<a name="ln414">    {</a>
<a name="ln415">      ordering = REQUIRE_ORDER;</a>
<a name="ln416">      ++optstring;</a>
<a name="ln417">    }</a>
<a name="ln418">  else if (posixly_correct != NULL)</a>
<a name="ln419">    ordering = REQUIRE_ORDER;</a>
<a name="ln420">  else</a>
<a name="ln421">    ordering = PERMUTE;</a>
<a name="ln422"> </a>
<a name="ln423">#ifdef _LIBC</a>
<a name="ln424">  if (posixly_correct == NULL</a>
<a name="ln425">      &amp;&amp; argc == original_argc &amp;&amp; argv == original_argv)</a>
<a name="ln426">    {</a>
<a name="ln427">      if (nonoption_flags_max_len == 0)</a>
<a name="ln428">	{</a>
<a name="ln429">	  if (__getopt_nonoption_flags == NULL</a>
<a name="ln430">	      || __getopt_nonoption_flags[0] == '\0')</a>
<a name="ln431">	    nonoption_flags_max_len = -1;</a>
<a name="ln432">	  else</a>
<a name="ln433">	    {</a>
<a name="ln434">	      const char *orig_str = __getopt_nonoption_flags;</a>
<a name="ln435">	      int len = nonoption_flags_max_len = strlen (orig_str);</a>
<a name="ln436">	      if (nonoption_flags_max_len &lt; argc)</a>
<a name="ln437">		nonoption_flags_max_len = argc;</a>
<a name="ln438">	      __getopt_nonoption_flags =</a>
<a name="ln439">		(char *) malloc (nonoption_flags_max_len);</a>
<a name="ln440">	      if (__getopt_nonoption_flags == NULL)</a>
<a name="ln441">		nonoption_flags_max_len = -1;</a>
<a name="ln442">	      else</a>
<a name="ln443">		memset (__mempcpy (__getopt_nonoption_flags, orig_str, len),</a>
<a name="ln444">			'\0', nonoption_flags_max_len - len);</a>
<a name="ln445">	    }</a>
<a name="ln446">	}</a>
<a name="ln447">      nonoption_flags_len = nonoption_flags_max_len;</a>
<a name="ln448">    }</a>
<a name="ln449">  else</a>
<a name="ln450">    nonoption_flags_len = 0;</a>
<a name="ln451">#endif</a>
<a name="ln452"> </a>
<a name="ln453">  return optstring;</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">/* Scan elements of ARGV (whose length is ARGC) for option characters</a>
<a name="ln457">   given in OPTSTRING.</a>
<a name="ln458"> </a>
<a name="ln459">   If an element of ARGV starts with '-', and is not exactly &quot;-&quot; or &quot;--&quot;,</a>
<a name="ln460">   then it is an option element.  The characters of this element</a>
<a name="ln461">   (aside from the initial '-') are option characters.  If `getopt'</a>
<a name="ln462">   is called repeatedly, it returns successively each of the option characters</a>
<a name="ln463">   from each of the option elements.</a>
<a name="ln464"> </a>
<a name="ln465">   If `getopt' finds another option character, it returns that character,</a>
<a name="ln466">   updating `optind' and `nextchar' so that the next call to `getopt' can</a>
<a name="ln467">   resume the scan with the following option character or ARGV-element.</a>
<a name="ln468"> </a>
<a name="ln469">   If there are no more option characters, `getopt' returns -1.</a>
<a name="ln470">   Then `optind' is the index in ARGV of the first ARGV-element</a>
<a name="ln471">   that is not an option.  (The ARGV-elements have been permuted</a>
<a name="ln472">   so that those that are not options now come last.)</a>
<a name="ln473"> </a>
<a name="ln474">   OPTSTRING is a string containing the legitimate option characters.</a>
<a name="ln475">   If an option character is seen that is not listed in OPTSTRING,</a>
<a name="ln476">   return '?' after printing an error message.  If you set `opterr' to</a>
<a name="ln477">   zero, the error message is suppressed but we still return '?'.</a>
<a name="ln478"> </a>
<a name="ln479">   If a char in OPTSTRING is followed by a colon, that means it wants an arg,</a>
<a name="ln480">   so the following text in the same ARGV-element, or the text of the following</a>
<a name="ln481">   ARGV-element, is returned in `optarg'.  Two colons mean an option that</a>
<a name="ln482">   wants an optional arg; if there is text in the current ARGV-element,</a>
<a name="ln483">   it is returned in `optarg', otherwise `optarg' is set to zero.</a>
<a name="ln484"> </a>
<a name="ln485">   If OPTSTRING starts with `-' or `+', it requests different methods of</a>
<a name="ln486">   handling the non-option ARGV-elements.</a>
<a name="ln487">   See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.</a>
<a name="ln488"> </a>
<a name="ln489">   Long-named options begin with `--' instead of `-'.</a>
<a name="ln490">   Their names may be abbreviated as long as the abbreviation is unique</a>
<a name="ln491">   or is an exact match for some defined option.  If they have an</a>
<a name="ln492">   argument, it follows the option name in the same ARGV-element, separated</a>
<a name="ln493">   from the option name by a `=', or else the in next ARGV-element.</a>
<a name="ln494">   When `getopt' finds a long-named option, it returns 0 if that option's</a>
<a name="ln495">   `flag' field is nonzero, the value of the option's `val' field</a>
<a name="ln496">   if the `flag' field is zero.</a>
<a name="ln497"> </a>
<a name="ln498">   The elements of ARGV aren't really const, because we permute them.</a>
<a name="ln499">   But we pretend they're const in the prototype to be compatible</a>
<a name="ln500">   with other systems.</a>
<a name="ln501"> </a>
<a name="ln502">   LONGOPTS is a vector of `struct option' terminated by an</a>
<a name="ln503">   element containing a name which is zero.</a>
<a name="ln504"> </a>
<a name="ln505">   LONGIND returns the index in LONGOPT of the long-named option found.</a>
<a name="ln506">   It is only valid when a long-named option has been found by the most</a>
<a name="ln507">   recent call.</a>
<a name="ln508"> </a>
<a name="ln509">   If LONG_ONLY is nonzero, '-' as well as '--' can introduce</a>
<a name="ln510">   long-named options.  */</a>
<a name="ln511"> </a>
<a name="ln512">int</a>
<a name="ln513">_getopt_internal (argc, argv, optstring, longopts, longind, long_only)</a>
<a name="ln514">     int argc;</a>
<a name="ln515">     char *const *argv;</a>
<a name="ln516">     const char *optstring;</a>
<a name="ln517">     const struct option *longopts;</a>
<a name="ln518">     int *longind;</a>
<a name="ln519">     int long_only;</a>
<a name="ln520">{</a>
<a name="ln521">  optarg = NULL;</a>
<a name="ln522"> </a>
<a name="ln523">  if (optind == 0 || !__getopt_initialized)</a>
<a name="ln524">    {</a>
<a name="ln525">      if (optind == 0)</a>
<a name="ln526">	optind = 1;	/* Don't scan ARGV[0], the program name.  */</a>
<a name="ln527">      optstring = _getopt_initialize (argc, argv, optstring);</a>
<a name="ln528">      __getopt_initialized = 1;</a>
<a name="ln529">    }</a>
<a name="ln530"> </a>
<a name="ln531">  /* Test whether ARGV[optind] points to a non-option argument.</a>
<a name="ln532">     Either it does not have option syntax, or there is an environment flag</a>
<a name="ln533">     from the shell indicating it is not an option.  The later information</a>
<a name="ln534">     is only used when the used in the GNU libc.  */</a>
<a name="ln535">#ifdef _LIBC</a>
<a name="ln536"># define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0'	      \</a>
<a name="ln537">		      || (optind &lt; nonoption_flags_len			      \</a>
<a name="ln538">			  &amp;&amp; __getopt_nonoption_flags[optind] == '1'))</a>
<a name="ln539">#else</a>
<a name="ln540"># define NONOPTION_P (argv[optind][0] != '-' || argv[optind][1] == '\0')</a>
<a name="ln541">#endif</a>
<a name="ln542"> </a>
<a name="ln543">  if (nextchar == NULL || *nextchar == '\0')</a>
<a name="ln544">    {</a>
<a name="ln545">      /* Advance to the next ARGV-element.  */</a>
<a name="ln546"> </a>
<a name="ln547">      /* Give FIRST_NONOPT &amp; LAST_NONOPT rational values if OPTIND has been</a>
<a name="ln548">	 moved back by the user (who may also have changed the arguments).  */</a>
<a name="ln549">      if (last_nonopt &gt; optind)</a>
<a name="ln550">	last_nonopt = optind;</a>
<a name="ln551">      if (first_nonopt &gt; optind)</a>
<a name="ln552">	first_nonopt = optind;</a>
<a name="ln553"> </a>
<a name="ln554">      if (ordering == PERMUTE)</a>
<a name="ln555">	{</a>
<a name="ln556">	  /* If we have just processed some options following some non-options,</a>
<a name="ln557">	     exchange them so that the options come first.  */</a>
<a name="ln558"> </a>
<a name="ln559">	  if (first_nonopt != last_nonopt &amp;&amp; last_nonopt != optind)</a>
<a name="ln560">	    exchange ((char **) argv);</a>
<a name="ln561">	  else if (last_nonopt != optind)</a>
<a name="ln562">	    first_nonopt = optind;</a>
<a name="ln563"> </a>
<a name="ln564">	  /* Skip any additional non-options</a>
<a name="ln565">	     and extend the range of non-options previously skipped.  */</a>
<a name="ln566"> </a>
<a name="ln567">	  while (optind &lt; argc &amp;&amp; NONOPTION_P)</a>
<a name="ln568">	    optind++;</a>
<a name="ln569">	  last_nonopt = optind;</a>
<a name="ln570">	}</a>
<a name="ln571"> </a>
<a name="ln572">      /* The special ARGV-element `--' means premature end of options.</a>
<a name="ln573">	 Skip it like a null option,</a>
<a name="ln574">	 then exchange with previous non-options as if it were an option,</a>
<a name="ln575">	 then skip everything else like a non-option.  */</a>
<a name="ln576"> </a>
<a name="ln577">      if (optind != argc &amp;&amp; !strcmp (argv[optind], &quot;--&quot;))</a>
<a name="ln578">	{</a>
<a name="ln579">	  optind++;</a>
<a name="ln580"> </a>
<a name="ln581">	  if (first_nonopt != last_nonopt &amp;&amp; last_nonopt != optind)</a>
<a name="ln582">	    exchange ((char **) argv);</a>
<a name="ln583">	  else if (first_nonopt == last_nonopt)</a>
<a name="ln584">	    first_nonopt = optind;</a>
<a name="ln585">	  last_nonopt = argc;</a>
<a name="ln586"> </a>
<a name="ln587">	  optind = argc;</a>
<a name="ln588">	}</a>
<a name="ln589"> </a>
<a name="ln590">      /* If we have done all the ARGV-elements, stop the scan</a>
<a name="ln591">	 and back over any non-options that we skipped and permuted.  */</a>
<a name="ln592"> </a>
<a name="ln593">      if (optind == argc)</a>
<a name="ln594">	{</a>
<a name="ln595">	  /* Set the next-arg-index to point at the non-options</a>
<a name="ln596">	     that we previously skipped, so the caller will digest them.  */</a>
<a name="ln597">	  if (first_nonopt != last_nonopt)</a>
<a name="ln598">	    optind = first_nonopt;</a>
<a name="ln599">	  return -1;</a>
<a name="ln600">	}</a>
<a name="ln601"> </a>
<a name="ln602">      /* If we have come to a non-option and did not permute it,</a>
<a name="ln603">	 either stop the scan or describe it to the caller and pass it by.  */</a>
<a name="ln604"> </a>
<a name="ln605">      if (NONOPTION_P)</a>
<a name="ln606">	{</a>
<a name="ln607">	  if (ordering == REQUIRE_ORDER)</a>
<a name="ln608">	    return -1;</a>
<a name="ln609">	  optarg = argv[optind++];</a>
<a name="ln610">	  return 1;</a>
<a name="ln611">	}</a>
<a name="ln612"> </a>
<a name="ln613">      /* We have found another option-ARGV-element.</a>
<a name="ln614">	 Skip the initial punctuation.  */</a>
<a name="ln615"> </a>
<a name="ln616">      nextchar = (argv[optind] + 1</a>
<a name="ln617">		  + (longopts != NULL &amp;&amp; argv[optind][1] == '-'));</a>
<a name="ln618">    }</a>
<a name="ln619"> </a>
<a name="ln620">  /* Decode the current option-ARGV-element.  */</a>
<a name="ln621"> </a>
<a name="ln622">  /* Check whether the ARGV-element is a long option.</a>
<a name="ln623"> </a>
<a name="ln624">     If long_only and the ARGV-element has the form &quot;-f&quot;, where f is</a>
<a name="ln625">     a valid short option, don't consider it an abbreviated form of</a>
<a name="ln626">     a long option that starts with f.  Otherwise there would be no</a>
<a name="ln627">     way to give the -f short option.</a>
<a name="ln628"> </a>
<a name="ln629">     On the other hand, if there's a long option &quot;fubar&quot; and</a>
<a name="ln630">     the ARGV-element is &quot;-fu&quot;, do consider that an abbreviation of</a>
<a name="ln631">     the long option, just like &quot;--fu&quot;, and not &quot;-f&quot; with arg &quot;u&quot;.</a>
<a name="ln632"> </a>
<a name="ln633">     This distinction seems to be the most useful approach.  */</a>
<a name="ln634"> </a>
<a name="ln635">  if (longopts != NULL</a>
<a name="ln636">      &amp;&amp; (argv[optind][1] == '-'</a>
<a name="ln637">	  || (long_only &amp;&amp; (argv[optind][2] || !my_index (optstring, argv[optind][1])))))</a>
<a name="ln638">    {</a>
<a name="ln639">      char *nameend;</a>
<a name="ln640">      const struct option *p;</a>
<a name="ln641">      const struct option *pfound = NULL;</a>
<a name="ln642">      int exact = 0;</a>
<a name="ln643">      int ambig = 0;</a>
<a name="ln644">      int indfound = -1;</a>
<a name="ln645">      int option_index;</a>
<a name="ln646"> </a>
<a name="ln647">      for (nameend = nextchar; *nameend &amp;&amp; *nameend != '='; nameend++)</a>
<a name="ln648">	/* Do nothing.  */ ;</a>
<a name="ln649"> </a>
<a name="ln650">      /* Test all long options for either exact match</a>
<a name="ln651">	 or abbreviated matches.  */</a>
<a name="ln652">      for (p = longopts, option_index = 0; p-&gt;name; p++, option_index++)</a>
<a name="ln653">	if (!strncmp (p-&gt;name, nextchar, nameend - nextchar))</a>
<a name="ln654">	  {</a>
<a name="ln655">	    if ((unsigned int) (nameend - nextchar)</a>
<a name="ln656">		== (unsigned int) strlen (p-&gt;name))</a>
<a name="ln657">	      {</a>
<a name="ln658">		/* Exact match found.  */</a>
<a name="ln659">		pfound = p;</a>
<a name="ln660">		indfound = option_index;</a>
<a name="ln661">		exact = 1;</a>
<a name="ln662">		break;</a>
<a name="ln663">	      }</a>
<a name="ln664">	    else if (pfound == NULL)</a>
<a name="ln665">	      {</a>
<a name="ln666">		/* First nonexact match found.  */</a>
<a name="ln667">		pfound = p;</a>
<a name="ln668">		indfound = option_index;</a>
<a name="ln669">	      }</a>
<a name="ln670">	    else</a>
<a name="ln671">	      /* Second or later nonexact match found.  */</a>
<a name="ln672">	      ambig = 1;</a>
<a name="ln673">	  }</a>
<a name="ln674"> </a>
<a name="ln675">      if (ambig &amp;&amp; !exact)</a>
<a name="ln676">	{</a>
<a name="ln677">	  if (opterr)</a>
<a name="ln678">	    fprintf (stderr, _(&quot;%s: option `%s' is ambiguous\n&quot;),</a>
<a name="ln679">		     argv[0], argv[optind]);</a>
<a name="ln680">	  nextchar += strlen (nextchar);</a>
<a name="ln681">	  optind++;</a>
<a name="ln682">	  optopt = 0;</a>
<a name="ln683">	  return '?';</a>
<a name="ln684">	}</a>
<a name="ln685"> </a>
<a name="ln686">      if (pfound != NULL)</a>
<a name="ln687">	{</a>
<a name="ln688">	  option_index = indfound;</a>
<a name="ln689">	  optind++;</a>
<a name="ln690">	  if (*nameend)</a>
<a name="ln691">	    {</a>
<a name="ln692">	      /* Don't test has_arg with &gt;, because some C compilers don't</a>
<a name="ln693">		 allow it to be used on enums.  */</a>
<a name="ln694">	      if (pfound-&gt;has_arg)</a>
<a name="ln695">		optarg = nameend + 1;</a>
<a name="ln696">	      else</a>
<a name="ln697">		{</a>
<a name="ln698">		  if (opterr)</a>
<a name="ln699">                    {</a>
<a name="ln700">		      if (argv[optind - 1][1] == '-')</a>
<a name="ln701">		        /* --option */</a>
<a name="ln702">		        fprintf (stderr,</a>
<a name="ln703">		         _(&quot;%s: option `--%s' doesn't allow an argument\n&quot;),</a>
<a name="ln704">		         argv[0], pfound-&gt;name);</a>
<a name="ln705">		      else</a>
<a name="ln706">		        /* +option or -option */</a>
<a name="ln707">		        fprintf (stderr,</a>
<a name="ln708">		         _(&quot;%s: option `%c%s' doesn't allow an argument\n&quot;),</a>
<a name="ln709">		         argv[0], argv[optind - 1][0], pfound-&gt;name);</a>
<a name="ln710">                    }</a>
<a name="ln711"> </a>
<a name="ln712">		  nextchar += strlen (nextchar);</a>
<a name="ln713"> </a>
<a name="ln714">		  optopt = pfound-&gt;val;</a>
<a name="ln715">		  return '?';</a>
<a name="ln716">		}</a>
<a name="ln717">	    }</a>
<a name="ln718">	  else if (pfound-&gt;has_arg == 1)</a>
<a name="ln719">	    {</a>
<a name="ln720">	      if (optind &lt; argc)</a>
<a name="ln721">		optarg = argv[optind++];</a>
<a name="ln722">	      else</a>
<a name="ln723">		{</a>
<a name="ln724">		  if (opterr)</a>
<a name="ln725">		    fprintf (stderr,</a>
<a name="ln726">			   _(&quot;%s: option `%s' requires an argument\n&quot;),</a>
<a name="ln727">			   argv[0], argv[optind - 1]);</a>
<a name="ln728">		  nextchar += strlen (nextchar);</a>
<a name="ln729">		  optopt = pfound-&gt;val;</a>
<a name="ln730">		  return optstring[0] == ':' ? ':' : '?';</a>
<a name="ln731">		}</a>
<a name="ln732">	    }</a>
<a name="ln733">	  nextchar += strlen (nextchar);</a>
<a name="ln734">	  if (longind != NULL)</a>
<a name="ln735">	    *longind = option_index;</a>
<a name="ln736">	  if (pfound-&gt;flag)</a>
<a name="ln737">	    {</a>
<a name="ln738">	      *(pfound-&gt;flag) = pfound-&gt;val;</a>
<a name="ln739">	      return 0;</a>
<a name="ln740">	    }</a>
<a name="ln741">	  return pfound-&gt;val;</a>
<a name="ln742">	}</a>
<a name="ln743"> </a>
<a name="ln744">      /* Can't find it as a long option.  If this is not getopt_long_only,</a>
<a name="ln745">	 or the option starts with '--' or is not a valid short</a>
<a name="ln746">	 option, then it's an error.</a>
<a name="ln747">	 Otherwise interpret it as a short option.  */</a>
<a name="ln748">      if (!long_only || argv[optind][1] == '-'</a>
<a name="ln749">	  || my_index (optstring, *nextchar) == NULL)</a>
<a name="ln750">	{</a>
<a name="ln751">	  if (opterr)</a>
<a name="ln752">	    {</a>
<a name="ln753">	      if (argv[optind][1] == '-')</a>
<a name="ln754">		/* --option */</a>
<a name="ln755">		fprintf (stderr, _(&quot;%s: unrecognized option `--%s'\n&quot;),</a>
<a name="ln756">			 argv[0], nextchar);</a>
<a name="ln757">	      else</a>
<a name="ln758">		/* +option or -option */</a>
<a name="ln759">		fprintf (stderr, _(&quot;%s: unrecognized option `%c%s'\n&quot;),</a>
<a name="ln760">			 argv[0], argv[optind][0], nextchar);</a>
<a name="ln761">	    }</a>
<a name="ln762">	  nextchar = (char *) &quot;&quot;;</a>
<a name="ln763">	  optind++;</a>
<a name="ln764">	  optopt = 0;</a>
<a name="ln765">	  return '?';</a>
<a name="ln766">	}</a>
<a name="ln767">    }</a>
<a name="ln768"> </a>
<a name="ln769">  /* Look at and handle the next short option-character.  */</a>
<a name="ln770"> </a>
<a name="ln771">  {</a>
<a name="ln772">    char c = *nextchar++;</a>
<a name="ln773">    char *temp = my_index (optstring, c);</a>
<a name="ln774"> </a>
<a name="ln775">    /* Increment `optind' when we start to process its last character.  */</a>
<a name="ln776">    if (*nextchar == '\0')</a>
<a name="ln777">      ++optind;</a>
<a name="ln778"> </a>
<a name="ln779">    if (temp == NULL || c == ':')</a>
<a name="ln780">      {</a>
<a name="ln781">	if (opterr)</a>
<a name="ln782">	  {</a>
<a name="ln783">	    if (posixly_correct)</a>
<a name="ln784">	      /* 1003.2 specifies the format of this message.  */</a>
<a name="ln785">	      fprintf (stderr, _(&quot;%s: illegal option -- %c\n&quot;),</a>
<a name="ln786">		       argv[0], c);</a>
<a name="ln787">	    else</a>
<a name="ln788">	      fprintf (stderr, _(&quot;%s: invalid option -- %c\n&quot;),</a>
<a name="ln789">		       argv[0], c);</a>
<a name="ln790">	  }</a>
<a name="ln791">	optopt = c;</a>
<a name="ln792">	return '?';</a>
<a name="ln793">      }</a>
<a name="ln794">    /* Convenience. Treat POSIX -W foo same as long option --foo */</a>
<a name="ln795">    if (temp[0] == 'W' &amp;&amp; temp[1] == ';')</a>
<a name="ln796">      {</a>
<a name="ln797">	char *nameend;</a>
<a name="ln798">	const struct option *p;</a>
<a name="ln799">	const struct option *pfound = NULL;</a>
<a name="ln800">	int exact = 0;</a>
<a name="ln801">	int ambig = 0;</a>
<a name="ln802">	int indfound = 0;</a>
<a name="ln803">	int option_index;</a>
<a name="ln804"> </a>
<a name="ln805">	/* This is an option that requires an argument.  */</a>
<a name="ln806">	if (*nextchar != '\0')</a>
<a name="ln807">	  {</a>
<a name="ln808">	    optarg = nextchar;</a>
<a name="ln809">	    /* If we end this ARGV-element by taking the rest as an arg,</a>
<a name="ln810">	       we must advance to the next element now.  */</a>
<a name="ln811">	    optind++;</a>
<a name="ln812">	  }</a>
<a name="ln813">	else if (optind == argc)</a>
<a name="ln814">	  {</a>
<a name="ln815">	    if (opterr)</a>
<a name="ln816">	      {</a>
<a name="ln817">		/* 1003.2 specifies the format of this message.  */</a>
<a name="ln818">		fprintf (stderr, _(&quot;%s: option requires an argument -- %c\n&quot;),</a>
<a name="ln819">			 argv[0], c);</a>
<a name="ln820">	      }</a>
<a name="ln821">	    optopt = c;</a>
<a name="ln822">	    if (optstring[0] == ':')</a>
<a name="ln823">	      c = ':';</a>
<a name="ln824">	    else</a>
<a name="ln825">	      c = '?';</a>
<a name="ln826">	    return c;</a>
<a name="ln827">	  }</a>
<a name="ln828">	else</a>
<a name="ln829">	  /* We already incremented `optind' once;</a>
<a name="ln830">	     increment it again when taking next ARGV-elt as argument.  */</a>
<a name="ln831">	  optarg = argv[optind++];</a>
<a name="ln832"> </a>
<a name="ln833">	/* optarg is now the argument, see if it's in the</a>
<a name="ln834">	   table of longopts.  */</a>
<a name="ln835"> </a>
<a name="ln836">	for (nextchar = nameend = optarg; *nameend &amp;&amp; *nameend != '='; nameend++)</a>
<a name="ln837">	  /* Do nothing.  */ ;</a>
<a name="ln838"> </a>
<a name="ln839">	/* Test all long options for either exact match</a>
<a name="ln840">	   or abbreviated matches.  */</a>
<a name="ln841">	for (p = longopts, option_index = 0; p-&gt;name; p++, option_index++)</a>
<a name="ln842">	  if (!strncmp (p-&gt;name, nextchar, nameend - nextchar))</a>
<a name="ln843">	    {</a>
<a name="ln844">	      if ((unsigned int) (nameend - nextchar) == strlen (p-&gt;name))</a>
<a name="ln845">		{</a>
<a name="ln846">		  /* Exact match found.  */</a>
<a name="ln847">		  pfound = p;</a>
<a name="ln848">		  indfound = option_index;</a>
<a name="ln849">		  exact = 1;</a>
<a name="ln850">		  break;</a>
<a name="ln851">		}</a>
<a name="ln852">	      else if (pfound == NULL)</a>
<a name="ln853">		{</a>
<a name="ln854">		  /* First nonexact match found.  */</a>
<a name="ln855">		  pfound = p;</a>
<a name="ln856">		  indfound = option_index;</a>
<a name="ln857">		}</a>
<a name="ln858">	      else</a>
<a name="ln859">		/* Second or later nonexact match found.  */</a>
<a name="ln860">		ambig = 1;</a>
<a name="ln861">	    }</a>
<a name="ln862">	if (ambig &amp;&amp; !exact)</a>
<a name="ln863">	  {</a>
<a name="ln864">	    if (opterr)</a>
<a name="ln865">	      fprintf (stderr, _(&quot;%s: option `-W %s' is ambiguous\n&quot;),</a>
<a name="ln866">		       argv[0], argv[optind]);</a>
<a name="ln867">	    nextchar += strlen (nextchar);</a>
<a name="ln868">	    optind++;</a>
<a name="ln869">	    return '?';</a>
<a name="ln870">	  }</a>
<a name="ln871">	if (pfound != NULL)</a>
<a name="ln872">	  {</a>
<a name="ln873">	    option_index = indfound;</a>
<a name="ln874">	    if (*nameend)</a>
<a name="ln875">	      {</a>
<a name="ln876">		/* Don't test has_arg with &gt;, because some C compilers don't</a>
<a name="ln877">		   allow it to be used on enums.  */</a>
<a name="ln878">		if (pfound-&gt;has_arg)</a>
<a name="ln879">		  optarg = nameend + 1;</a>
<a name="ln880">		else</a>
<a name="ln881">		  {</a>
<a name="ln882">		    if (opterr)</a>
<a name="ln883">		      fprintf (stderr, _(&quot;\</a>
<a name="ln884">%s: option `-W %s' doesn't allow an argument\n&quot;),</a>
<a name="ln885">			       argv[0], pfound-&gt;name);</a>
<a name="ln886"> </a>
<a name="ln887">		    nextchar += strlen (nextchar);</a>
<a name="ln888">		    return '?';</a>
<a name="ln889">		  }</a>
<a name="ln890">	      }</a>
<a name="ln891">	    else if (pfound-&gt;has_arg == 1)</a>
<a name="ln892">	      {</a>
<a name="ln893">		if (optind &lt; argc)</a>
<a name="ln894">		  optarg = argv[optind++];</a>
<a name="ln895">		else</a>
<a name="ln896">		  {</a>
<a name="ln897">		    if (opterr)</a>
<a name="ln898">		      fprintf (stderr,</a>
<a name="ln899">			       _(&quot;%s: option `%s' requires an argument\n&quot;),</a>
<a name="ln900">			       argv[0], argv[optind - 1]);</a>
<a name="ln901">		    nextchar += strlen (nextchar);</a>
<a name="ln902">		    return optstring[0] == ':' ? ':' : '?';</a>
<a name="ln903">		  }</a>
<a name="ln904">	      }</a>
<a name="ln905">	    nextchar += strlen (nextchar);</a>
<a name="ln906">	    if (longind != NULL)</a>
<a name="ln907">	      *longind = option_index;</a>
<a name="ln908">	    if (pfound-&gt;flag)</a>
<a name="ln909">	      {</a>
<a name="ln910">		*(pfound-&gt;flag) = pfound-&gt;val;</a>
<a name="ln911">		return 0;</a>
<a name="ln912">	      }</a>
<a name="ln913">	    return pfound-&gt;val;</a>
<a name="ln914">	  }</a>
<a name="ln915">	  nextchar = NULL;</a>
<a name="ln916">	  return 'W';	/* Let the application handle it.   */</a>
<a name="ln917">      }</a>
<a name="ln918">    if (temp[1] == ':')</a>
<a name="ln919">      {</a>
<a name="ln920">	if (temp[2] == ':')</a>
<a name="ln921">	  {</a>
<a name="ln922">	    /* This is an option that accepts an argument optionally.  */</a>
<a name="ln923">	    if (*nextchar != '\0')</a>
<a name="ln924">	      {</a>
<a name="ln925">		optarg = nextchar;</a>
<a name="ln926">		optind++;</a>
<a name="ln927">	      }</a>
<a name="ln928">	    else</a>
<a name="ln929">	      optarg = NULL;</a>
<a name="ln930">	    nextchar = NULL;</a>
<a name="ln931">	  }</a>
<a name="ln932">	else</a>
<a name="ln933">	  {</a>
<a name="ln934">	    /* This is an option that requires an argument.  */</a>
<a name="ln935">	    if (*nextchar != '\0')</a>
<a name="ln936">	      {</a>
<a name="ln937">		optarg = nextchar;</a>
<a name="ln938">		/* If we end this ARGV-element by taking the rest as an arg,</a>
<a name="ln939">		   we must advance to the next element now.  */</a>
<a name="ln940">		optind++;</a>
<a name="ln941">	      }</a>
<a name="ln942">	    else if (optind == argc)</a>
<a name="ln943">	      {</a>
<a name="ln944">		if (opterr)</a>
<a name="ln945">		  {</a>
<a name="ln946">		    /* 1003.2 specifies the format of this message.  */</a>
<a name="ln947">		    fprintf (stderr,</a>
<a name="ln948">			   _(&quot;%s: option requires an argument -- %c\n&quot;),</a>
<a name="ln949">			   argv[0], c);</a>
<a name="ln950">		  }</a>
<a name="ln951">		optopt = c;</a>
<a name="ln952">		if (optstring[0] == ':')</a>
<a name="ln953">		  c = ':';</a>
<a name="ln954">		else</a>
<a name="ln955">		  c = '?';</a>
<a name="ln956">	      }</a>
<a name="ln957">	    else</a>
<a name="ln958">	      /* We already incremented `optind' once;</a>
<a name="ln959">		 increment it again when taking next ARGV-elt as argument.  */</a>
<a name="ln960">	      optarg = argv[optind++];</a>
<a name="ln961">	    nextchar = NULL;</a>
<a name="ln962">	  }</a>
<a name="ln963">      }</a>
<a name="ln964">    return c;</a>
<a name="ln965">  }</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">#ifdef REALLY_NEED_PLAIN_GETOPT</a>
<a name="ln969"> </a>
<a name="ln970">int</a>
<a name="ln971">getopt (argc, argv, optstring)</a>
<a name="ln972">     int argc;</a>
<a name="ln973">     char *const *argv;</a>
<a name="ln974">     const char *optstring;</a>
<a name="ln975">{</a>
<a name="ln976">  return _getopt_internal (argc, argv, optstring,</a>
<a name="ln977">			   (const struct option *) 0,</a>
<a name="ln978">			   (int *) 0,</a>
<a name="ln979">			   0);</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">#endif /* REALLY_NEED_PLAIN_GETOPT */</a>
<a name="ln983"> </a>
<a name="ln984">#endif	/* Not ELIDE_CODE.  */</a>
<a name="ln985"> </a>
<a name="ln986">#ifdef TEST</a>
<a name="ln987"> </a>
<a name="ln988">/* Compile with -DTEST to make an executable for use in testing</a>
<a name="ln989">   the above definition of `getopt'.  */</a>
<a name="ln990"> </a>
<a name="ln991">int</a>
<a name="ln992">main (argc, argv)</a>
<a name="ln993">     int argc;</a>
<a name="ln994">     char **argv;</a>
<a name="ln995">{</a>
<a name="ln996">  int c;</a>
<a name="ln997">  int digit_optind = 0;</a>
<a name="ln998"> </a>
<a name="ln999">  while (1)</a>
<a name="ln1000">    {</a>
<a name="ln1001">      int this_option_optind = optind ? optind : 1;</a>
<a name="ln1002"> </a>
<a name="ln1003">      c = getopt (argc, argv, &quot;abc:d:0123456789&quot;);</a>
<a name="ln1004">      if (c == -1)</a>
<a name="ln1005">	break;</a>
<a name="ln1006"> </a>
<a name="ln1007">      switch (c)</a>
<a name="ln1008">	{</a>
<a name="ln1009">	case '0':</a>
<a name="ln1010">	case '1':</a>
<a name="ln1011">	case '2':</a>
<a name="ln1012">	case '3':</a>
<a name="ln1013">	case '4':</a>
<a name="ln1014">	case '5':</a>
<a name="ln1015">	case '6':</a>
<a name="ln1016">	case '7':</a>
<a name="ln1017">	case '8':</a>
<a name="ln1018">	case '9':</a>
<a name="ln1019">	  if (digit_optind != 0 &amp;&amp; digit_optind != this_option_optind)</a>
<a name="ln1020">	    printf (&quot;digits occur in two different argv-elements.\n&quot;);</a>
<a name="ln1021">	  digit_optind = this_option_optind;</a>
<a name="ln1022">	  printf (&quot;option %c\n&quot;, c);</a>
<a name="ln1023">	  break;</a>
<a name="ln1024"> </a>
<a name="ln1025">	case 'a':</a>
<a name="ln1026">	  printf (&quot;option a\n&quot;);</a>
<a name="ln1027">	  break;</a>
<a name="ln1028"> </a>
<a name="ln1029">	case 'b':</a>
<a name="ln1030">	  printf (&quot;option b\n&quot;);</a>
<a name="ln1031">	  break;</a>
<a name="ln1032"> </a>
<a name="ln1033">	case 'c':</a>
<a name="ln1034">	  printf (&quot;option c with value `%s'\n&quot;, optarg);</a>
<a name="ln1035">	  break;</a>
<a name="ln1036"> </a>
<a name="ln1037">	case '?':</a>
<a name="ln1038">	  break;</a>
<a name="ln1039"> </a>
<a name="ln1040">	default:</a>
<a name="ln1041">	  printf (&quot;?? getopt returned character code 0%o ??\n&quot;, c);</a>
<a name="ln1042">	}</a>
<a name="ln1043">    }</a>
<a name="ln1044"> </a>
<a name="ln1045">  if (optind &lt; argc)</a>
<a name="ln1046">    {</a>
<a name="ln1047">      printf (&quot;non-option ARGV-elements: &quot;);</a>
<a name="ln1048">      while (optind &lt; argc)</a>
<a name="ln1049">	printf (&quot;%s &quot;, argv[optind++]);</a>
<a name="ln1050">      printf (&quot;\n&quot;);</a>
<a name="ln1051">    }</a>
<a name="ln1052"> </a>
<a name="ln1053">  exit (0);</a>
<a name="ln1054">}</a>
<a name="ln1055"> </a>
<a name="ln1056">#endif /* TEST */</a>

</code></pre>
<div class="balloon" rel="13"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
