
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_advertise.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP advertisement and adjacency</a>
<a name="ln2">   Copyright (C) 1996, 97, 98, 99, 2000 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;command.h&quot;</a>
<a name="ln24">#include &quot;memory.h&quot;</a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;hash.h&quot;</a>
<a name="ln27">#include &quot;thread.h&quot;</a>
<a name="ln28">#include &quot;filter.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln31">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln32">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln33">#include &quot;bgpd/bgp_advertise.h&quot;</a>
<a name="ln34">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln35">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_packet.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_fsm.h&quot;</a>
<a name="ln38">#include &quot;bgpd/bgp_mplsvpn.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">/* BGP advertise attribute is used for pack same attribute update into</a>
<a name="ln41">   one packet.  To do that we maintain attribute hash in struct</a>
<a name="ln42">   peer.  */</a>
<a name="ln43">static struct bgp_advertise_attr *</a>
<a name="ln44">baa_new (void)</a>
<a name="ln45">{</a>
<a name="ln46">  return (struct bgp_advertise_attr *)</a>
<a name="ln47">    XCALLOC (MTYPE_BGP_ADVERTISE_ATTR, sizeof (struct bgp_advertise_attr));</a>
<a name="ln48">}</a>
<a name="ln49"> </a>
<a name="ln50">static void</a>
<a name="ln51">baa_free (struct bgp_advertise_attr *baa)</a>
<a name="ln52">{</a>
<a name="ln53">  XFREE (MTYPE_BGP_ADVERTISE_ATTR, baa);</a>
<a name="ln54">}</a>
<a name="ln55"> </a>
<a name="ln56">static void *</a>
<a name="ln57">baa_hash_alloc (void *p)</a>
<a name="ln58">{</a>
<a name="ln59">  struct bgp_advertise_attr * ref = (struct bgp_advertise_attr *) p;</a>
<a name="ln60">  struct bgp_advertise_attr *baa;</a>
<a name="ln61"> </a>
<a name="ln62">  baa = baa_new ();</a>
<a name="ln63">  baa-&gt;attr = ref-&gt;attr;</a>
<a name="ln64">  return baa;</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">static unsigned int</a>
<a name="ln68">baa_hash_key (void *p)</a>
<a name="ln69">{</a>
<a name="ln70">  struct bgp_advertise_attr * baa = (struct bgp_advertise_attr *) p;</a>
<a name="ln71"> </a>
<a name="ln72">  return attrhash_key_make (baa-&gt;attr);</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">static int</a>
<a name="ln76">baa_hash_cmp (const void *p1, const void *p2)</a>
<a name="ln77">{</a>
<a name="ln78">  const struct bgp_advertise_attr * baa1 = p1;</a>
<a name="ln79">  const struct bgp_advertise_attr * baa2 = p2;</a>
<a name="ln80"> </a>
<a name="ln81">  return attrhash_cmp (baa1-&gt;attr, baa2-&gt;attr);</a>
<a name="ln82">}</a>
<a name="ln83"> </a>
<a name="ln84">/* BGP update and withdraw information is stored in BGP advertise</a>
<a name="ln85">   structure.  This structure is referred from BGP adjacency</a>
<a name="ln86">   information.  */</a>
<a name="ln87">static struct bgp_advertise *</a>
<a name="ln88">bgp_advertise_new (void)</a>
<a name="ln89">{</a>
<a name="ln90">  return (struct bgp_advertise *) </a>
<a name="ln91">    XCALLOC (MTYPE_BGP_ADVERTISE, sizeof (struct bgp_advertise));</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">static void</a>
<a name="ln95">bgp_advertise_free (struct bgp_advertise *adv)</a>
<a name="ln96">{</a>
<a name="ln97">  if (adv-&gt;binfo)</a>
<a name="ln98">    bgp_info_unlock (adv-&gt;binfo); /* bgp_advertise bgp_info reference */</a>
<a name="ln99">  XFREE (MTYPE_BGP_ADVERTISE, adv);</a>
<a name="ln100">}</a>
<a name="ln101"> </a>
<a name="ln102">static void</a>
<a name="ln103">bgp_advertise_add (struct bgp_advertise_attr *baa,</a>
<a name="ln104">		   struct bgp_advertise *adv)</a>
<a name="ln105">{</a>
<a name="ln106">  adv-&gt;next = baa-&gt;adv;</a>
<a name="ln107">  if (baa-&gt;adv)</a>
<a name="ln108">    baa-&gt;adv-&gt;prev = adv;</a>
<a name="ln109">  baa-&gt;adv = adv;</a>
<a name="ln110">}</a>
<a name="ln111"> </a>
<a name="ln112">static void</a>
<a name="ln113">bgp_advertise_delete (struct bgp_advertise_attr *baa,</a>
<a name="ln114">		      struct bgp_advertise *adv)</a>
<a name="ln115">{</a>
<a name="ln116">  if (adv-&gt;next)</a>
<a name="ln117">    adv-&gt;next-&gt;prev = adv-&gt;prev;</a>
<a name="ln118">  if (adv-&gt;prev)</a>
<a name="ln119">    adv-&gt;prev-&gt;next = adv-&gt;next;</a>
<a name="ln120">  else</a>
<a name="ln121">    baa-&gt;adv = adv-&gt;next;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">static struct bgp_advertise_attr *</a>
<a name="ln125">bgp_advertise_intern (struct hash *hash, struct attr *attr)</a>
<a name="ln126">{</a>
<a name="ln127">  struct bgp_advertise_attr ref;</a>
<a name="ln128">  struct bgp_advertise_attr *baa;</a>
<a name="ln129"> </a>
<a name="ln130">  ref.attr = bgp_attr_intern (attr);</a>
<a name="ln131">  baa = (struct bgp_advertise_attr *) hash_get (hash, &amp;ref, baa_hash_alloc);</a>
<a name="ln132">  baa-&gt;refcnt++;</a>
<a name="ln133"> </a>
<a name="ln134">  return baa;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">static void</a>
<a name="ln138">bgp_advertise_unintern (struct hash *hash, struct bgp_advertise_attr *baa)</a>
<a name="ln139">{</a>
<a name="ln140">  if (baa-&gt;refcnt)</a>
<a name="ln141">    baa-&gt;refcnt--;</a>
<a name="ln142"> </a>
<a name="ln143">  if (baa-&gt;refcnt &amp;&amp; baa-&gt;attr)</a>
<a name="ln144">    bgp_attr_unintern (&amp;baa-&gt;attr);</a>
<a name="ln145">  else</a>
<a name="ln146">    {</a>
<a name="ln147">      if (baa-&gt;attr)</a>
<a name="ln148">	{</a>
<a name="ln149">	  hash_release (hash, baa);</a>
<a name="ln150">	  bgp_attr_unintern (&amp;baa-&gt;attr);</a>
<a name="ln151">	}</a>
<a name="ln152">      baa_free (baa);</a>
<a name="ln153">    }</a>
<a name="ln154">}</a>
<a name="ln155"> </a>
<a name="ln156">/* BGP adjacency keeps minimal advertisement information.  */</a>
<a name="ln157">static void</a>
<a name="ln158">bgp_adj_out_free (struct bgp_adj_out *adj)</a>
<a name="ln159">{</a>
<a name="ln160">  peer_unlock (adj-&gt;peer); /* adj_out peer reference */</a>
<a name="ln161">  XFREE (MTYPE_BGP_ADJ_OUT, adj);</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">int</a>
<a name="ln165">bgp_adj_out_lookup (struct peer *peer, struct prefix *p,</a>
<a name="ln166">		    afi_t afi, safi_t safi, struct bgp_node *rn)</a>
<a name="ln167">{</a>
<a name="ln168">  struct bgp_adj_out *adj;</a>
<a name="ln169"> </a>
<a name="ln170">  for (adj = rn-&gt;adj_out; adj; adj = adj-&gt;next)</a>
<a name="ln171">    if (adj-&gt;peer == peer)</a>
<a name="ln172">      break;</a>
<a name="ln173"> </a>
<a name="ln174">  if (! adj)</a>
<a name="ln175">    return 0;</a>
<a name="ln176"> </a>
<a name="ln177">  return (adj-&gt;adv </a>
<a name="ln178">	  ? (adj-&gt;adv-&gt;baa ? 1 : 0)</a>
<a name="ln179">	  : (adj-&gt;attr ? 1 : 0));</a>
<a name="ln180">}</a>
<a name="ln181"> </a>
<a name="ln182">struct bgp_advertise *</a>
<a name="ln183">bgp_advertise_clean (struct peer *peer, struct bgp_adj_out *adj,</a>
<a name="ln184">		     afi_t afi, safi_t safi)</a>
<a name="ln185">{</a>
<a name="ln186">  struct bgp_advertise *adv;</a>
<a name="ln187">  struct bgp_advertise_attr *baa;</a>
<a name="ln188">  struct bgp_advertise *next;</a>
<a name="ln189">  struct bgp_advertise_fifo *fhead;</a>
<a name="ln190"> </a>
<a name="ln191">  adv = adj-&gt;adv;</a>
<a name="ln192">  baa = adv-&gt;baa;</a>
<a name="ln193">  next = NULL;</a>
<a name="ln194">  fhead = (struct bgp_advertise_fifo *)&amp;peer-&gt;sync[afi][safi]-&gt;withdraw;</a>
<a name="ln195"> </a>
<a name="ln196">  if (baa)</a>
<a name="ln197">    {</a>
<a name="ln198">      /* Unlink myself from advertise attribute FIFO.  */</a>
<a name="ln199">      bgp_advertise_delete (baa, adv);</a>
<a name="ln200"> </a>
<a name="ln201">      /* Fetch next advertise candidate. */</a>
<a name="ln202">      next = baa-&gt;adv;</a>
<a name="ln203"> </a>
<a name="ln204">      /* Unintern BGP advertise attribute.  */</a>
<a name="ln205">      bgp_advertise_unintern (peer-&gt;hash[afi][safi], baa);</a>
<a name="ln206"> </a>
<a name="ln207">      fhead = (struct bgp_advertise_fifo *)&amp;peer-&gt;sync[afi][safi]-&gt;update;</a>
<a name="ln208">    }</a>
<a name="ln209"> </a>
<a name="ln210">  /* Unlink myself from advertisement FIFO.  */</a>
<a name="ln211">  BGP_ADV_FIFO_DEL (fhead, adv);</a>
<a name="ln212"> </a>
<a name="ln213">  /* Free memory.  */</a>
<a name="ln214">  bgp_advertise_free (adj-&gt;adv);</a>
<a name="ln215">  adj-&gt;adv = NULL;</a>
<a name="ln216"> </a>
<a name="ln217">  return next;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">void</a>
<a name="ln221">bgp_adj_out_set (struct bgp_node *rn, struct peer *peer, struct prefix *p,</a>
<a name="ln222">		 struct attr *attr, afi_t afi, safi_t safi,</a>
<a name="ln223">		 struct bgp_info *binfo)</a>
<a name="ln224">{</a>
<a name="ln225">  struct bgp_adj_out *adj = NULL;</a>
<a name="ln226">  struct bgp_advertise *adv;</a>
<a name="ln227"> </a>
<a name="ln228">  if (DISABLE_BGP_ANNOUNCE)</a>
<a name="ln229">    return;</a>
<a name="ln230"> </a>
<a name="ln231">  /* Look for adjacency information. */</a>
<a name="ln232">  if (rn)</a>
<a name="ln233">    {</a>
<a name="ln234">      for (adj = rn-&gt;adj_out; adj; adj = adj-&gt;next)</a>
<a name="ln235">	if (adj-&gt;peer == peer)</a>
<a name="ln236">	  break;</a>
<a name="ln237">    }</a>
<a name="ln238"> </a>
<a name="ln239">  if (! adj)</a>
<a name="ln240">    {</a>
<a name="ln241">      adj = XCALLOC (MTYPE_BGP_ADJ_OUT, sizeof (struct bgp_adj_out));</a>
<a name="ln242">      adj-&gt;peer = peer_lock (peer); /* adj_out peer reference */</a>
<a name="ln243">      </a>
<a name="ln244">      if (rn)</a>
<a name="ln245">        {</a>
<a name="ln246">          BGP_ADJ_OUT_ADD (rn, adj);</a>
<a name="ln247">          bgp_lock_node (rn);</a>
<a name="ln248">        }</a>
<a name="ln249">    }</a>
<a name="ln250"> </a>
<a name="ln251">  if (adj-&gt;adv)</a>
<a name="ln252">    bgp_advertise_clean (peer, adj, afi, safi);</a>
<a name="ln253">  </a>
<a name="ln254">  adj-&gt;adv = bgp_advertise_new ();</a>
<a name="ln255"> </a>
<a name="ln256">  adv = adj-&gt;adv;</a>
<a name="ln257">  adv-&gt;rn = rn;</a>
<a name="ln258">  </a>
<a name="ln259">  assert (adv-&gt;binfo == NULL);</a>
<a name="ln260">  adv-&gt;binfo = bgp_info_lock (binfo); /* bgp_info adj_out reference */</a>
<a name="ln261">  </a>
<a name="ln262">  if (attr)</a>
<a name="ln263">    adv-&gt;baa = bgp_advertise_intern (peer-&gt;hash[afi][safi], attr);</a>
<a name="ln264">  else</a>
<a name="ln265">    adv-&gt;baa = baa_new ();</a>
<a name="ln266">  adv-&gt;adj = adj;</a>
<a name="ln267"> </a>
<a name="ln268">  /* Add new advertisement to advertisement attribute list. */</a>
<a name="ln269">  bgp_advertise_add (adv-&gt;baa, adv);</a>
<a name="ln270"> </a>
<a name="ln271">  BGP_ADV_FIFO_ADD (&amp;peer-&gt;sync[afi][safi]-&gt;update, &amp;adv-&gt;fifo);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">void</a>
<a name="ln275">bgp_adj_out_unset (struct bgp_node *rn, struct peer *peer, struct prefix *p, </a>
<a name="ln276">		   afi_t afi, safi_t safi)</a>
<a name="ln277">{</a>
<a name="ln278">  struct bgp_adj_out *adj;</a>
<a name="ln279">  struct bgp_advertise *adv;</a>
<a name="ln280"> </a>
<a name="ln281">  if (DISABLE_BGP_ANNOUNCE)</a>
<a name="ln282">    return;</a>
<a name="ln283"> </a>
<a name="ln284">  /* Lookup existing adjacency, if it is not there return immediately.  */</a>
<a name="ln285">  for (adj = rn-&gt;adj_out; adj; adj = adj-&gt;next)</a>
<a name="ln286">    if (adj-&gt;peer == peer)</a>
<a name="ln287">      break;</a>
<a name="ln288"> </a>
<a name="ln289">  if (! adj)</a>
<a name="ln290">    return;</a>
<a name="ln291"> </a>
<a name="ln292">  /* Clearn up previous advertisement.  */</a>
<a name="ln293">  if (adj-&gt;adv)</a>
<a name="ln294">    bgp_advertise_clean (peer, adj, afi, safi);</a>
<a name="ln295"> </a>
<a name="ln296">  if (adj-&gt;attr)</a>
<a name="ln297">    {</a>
<a name="ln298">      /* We need advertisement structure.  */</a>
<a name="ln299">      adj-&gt;adv = bgp_advertise_new ();</a>
<a name="ln300">      adv = adj-&gt;adv;</a>
<a name="ln301">      adv-&gt;rn = rn;</a>
<a name="ln302">      adv-&gt;adj = adj;</a>
<a name="ln303"> </a>
<a name="ln304">      /* Add to synchronization entry for withdraw announcement.  */</a>
<a name="ln305">      BGP_ADV_FIFO_ADD (&amp;peer-&gt;sync[afi][safi]-&gt;withdraw, &amp;adv-&gt;fifo);</a>
<a name="ln306"> </a>
<a name="ln307">      /* Schedule packet write. */</a>
<a name="ln308">      BGP_WRITE_ON (peer-&gt;t_write, bgp_write, peer-&gt;fd);</a>
<a name="ln309">    }</a>
<a name="ln310">  else</a>
<a name="ln311">    {</a>
<a name="ln312">      /* Remove myself from adjacency. */</a>
<a name="ln313">      BGP_ADJ_OUT_DEL (rn, adj);</a>
<a name="ln314">      </a>
<a name="ln315">      /* Free allocated information.  */</a>
<a name="ln316">      bgp_adj_out_free (adj);</a>
<a name="ln317"> </a>
<a name="ln318">      bgp_unlock_node (rn);</a>
<a name="ln319">    }</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">void</a>
<a name="ln323">bgp_adj_out_remove (struct bgp_node *rn, struct bgp_adj_out *adj, </a>
<a name="ln324">		    struct peer *peer, afi_t afi, safi_t safi)</a>
<a name="ln325">{</a>
<a name="ln326">  if (adj-&gt;attr)</a>
<a name="ln327">    bgp_attr_unintern (&amp;adj-&gt;attr);</a>
<a name="ln328"> </a>
<a name="ln329">  if (adj-&gt;adv)</a>
<a name="ln330">    bgp_advertise_clean (peer, adj, afi, safi);</a>
<a name="ln331"> </a>
<a name="ln332">  BGP_ADJ_OUT_DEL (rn, adj);</a>
<a name="ln333">  bgp_adj_out_free (adj);</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">void</a>
<a name="ln337">bgp_adj_in_set (struct bgp_node *rn, struct peer *peer, struct attr *attr)</a>
<a name="ln338">{</a>
<a name="ln339">  struct bgp_adj_in *adj;</a>
<a name="ln340"> </a>
<a name="ln341">  for (adj = rn-&gt;adj_in; adj; adj = adj-&gt;next)</a>
<a name="ln342">    {</a>
<a name="ln343">      if (adj-&gt;peer == peer)</a>
<a name="ln344">	{</a>
<a name="ln345">	  if (adj-&gt;attr != attr)</a>
<a name="ln346">	    {</a>
<a name="ln347">	      bgp_attr_unintern (&amp;adj-&gt;attr);</a>
<a name="ln348">	      adj-&gt;attr = bgp_attr_intern (attr);</a>
<a name="ln349">	    }</a>
<a name="ln350">	  return;</a>
<a name="ln351">	}</a>
<a name="ln352">    }</a>
<a name="ln353">  adj = XCALLOC (MTYPE_BGP_ADJ_IN, sizeof (struct bgp_adj_in));</a>
<a name="ln354">  adj-&gt;peer = peer_lock (peer); /* adj_in peer reference */</a>
<a name="ln355">  adj-&gt;attr = bgp_attr_intern (attr);</a>
<a name="ln356">  BGP_ADJ_IN_ADD (rn, adj);</a>
<a name="ln357">  bgp_lock_node (rn);</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">void</a>
<a name="ln361">bgp_adj_in_remove (struct bgp_node *rn, struct bgp_adj_in *bai)</a>
<a name="ln362">{</a>
<a name="ln363">  bgp_attr_unintern (&amp;bai-&gt;attr);</a>
<a name="ln364">  BGP_ADJ_IN_DEL (rn, bai);</a>
<a name="ln365">  peer_unlock (bai-&gt;peer); /* adj_in peer reference */</a>
<a name="ln366">  XFREE (MTYPE_BGP_ADJ_IN, bai);</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">int</a>
<a name="ln370">bgp_adj_in_unset (struct bgp_node *rn, struct peer *peer)</a>
<a name="ln371">{</a>
<a name="ln372">  struct bgp_adj_in *adj;</a>
<a name="ln373"> </a>
<a name="ln374">  for (adj = rn-&gt;adj_in; adj; adj = adj-&gt;next)</a>
<a name="ln375">    if (adj-&gt;peer == peer)</a>
<a name="ln376">      break;</a>
<a name="ln377"> </a>
<a name="ln378">  if (! adj)</a>
<a name="ln379">    return 0;</a>
<a name="ln380"> </a>
<a name="ln381">  bgp_adj_in_remove (rn, adj);</a>
<a name="ln382">  bgp_unlock_node (rn);</a>
<a name="ln383">  return 1;</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">void</a>
<a name="ln387">bgp_sync_init (struct peer *peer)</a>
<a name="ln388">{</a>
<a name="ln389">  afi_t afi;</a>
<a name="ln390">  safi_t safi;</a>
<a name="ln391">  struct bgp_synchronize *sync;</a>
<a name="ln392"> </a>
<a name="ln393">  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln394">    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln395">      {</a>
<a name="ln396">	sync = XCALLOC (MTYPE_BGP_SYNCHRONISE, </a>
<a name="ln397">	                sizeof (struct bgp_synchronize));</a>
<a name="ln398">	BGP_ADV_FIFO_INIT (&amp;sync-&gt;update);</a>
<a name="ln399">	BGP_ADV_FIFO_INIT (&amp;sync-&gt;withdraw);</a>
<a name="ln400">	BGP_ADV_FIFO_INIT (&amp;sync-&gt;withdraw_low);</a>
<a name="ln401">	peer-&gt;sync[afi][safi] = sync;</a>
<a name="ln402">	peer-&gt;hash[afi][safi] = hash_create (baa_hash_key, baa_hash_cmp);</a>
<a name="ln403">      }</a>
<a name="ln404">}</a>
<a name="ln405"> </a>
<a name="ln406">void</a>
<a name="ln407">bgp_sync_delete (struct peer *peer)</a>
<a name="ln408">{</a>
<a name="ln409">  afi_t afi;</a>
<a name="ln410">  safi_t safi;</a>
<a name="ln411"> </a>
<a name="ln412">  for (afi = AFI_IP; afi &lt; AFI_MAX; afi++)</a>
<a name="ln413">    for (safi = SAFI_UNICAST; safi &lt; SAFI_MAX; safi++)</a>
<a name="ln414">      {</a>
<a name="ln415">	if (peer-&gt;sync[afi][safi])</a>
<a name="ln416">	  XFREE (MTYPE_BGP_SYNCHRONISE, peer-&gt;sync[afi][safi]);</a>
<a name="ln417">	peer-&gt;sync[afi][safi] = NULL;</a>
<a name="ln418">	</a>
<a name="ln419">	if (peer-&gt;hash[afi][safi])</a>
<a name="ln420">	  hash_free (peer-&gt;hash[afi][safi]);</a>
<a name="ln421">	peer-&gt;hash[afi][safi] = NULL;</a>
<a name="ln422">      }</a>
<a name="ln423">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
