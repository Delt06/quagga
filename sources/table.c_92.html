
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>table.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Routing Table functions.</a>
<a name="ln3"> * Copyright (C) 1998 Kunihiro Ishiguro</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.  </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;prefix.h&quot;</a>
<a name="ln26">#include &quot;table.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;sockunion.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">static void route_node_delete (struct route_node *);</a>
<a name="ln31">static void route_table_free (struct route_table *);</a>
<a name="ln32"> </a>
<a name="ln33"> </a>
<a name="ln34">/*</a>
<a name="ln35"> * route_table_init_with_delegate</a>
<a name="ln36"> */</a>
<a name="ln37">struct route_table *</a>
<a name="ln38">route_table_init_with_delegate (route_table_delegate_t *delegate)</a>
<a name="ln39">{</a>
<a name="ln40">  struct route_table *rt;</a>
<a name="ln41"> </a>
<a name="ln42">  rt = XCALLOC (MTYPE_ROUTE_TABLE, sizeof (struct route_table));</a>
<a name="ln43">  rt-&gt;delegate = delegate;</a>
<a name="ln44">  return rt;</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">void</a>
<a name="ln48">route_table_finish (struct route_table *rt)</a>
<a name="ln49">{</a>
<a name="ln50">  route_table_free (rt);</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">/* Allocate new route node. */</a>
<a name="ln54">static struct route_node *</a>
<a name="ln55">route_node_new (struct route_table *table)</a>
<a name="ln56">{</a>
<a name="ln57">  return table-&gt;delegate-&gt;create_node (table-&gt;delegate, table);</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">/* Allocate new route node with prefix set. */</a>
<a name="ln61">static struct route_node *</a>
<a name="ln62">route_node_set (struct route_table *table, const struct prefix *prefix)</a>
<a name="ln63">{</a>
<a name="ln64">  struct route_node *node;</a>
<a name="ln65">  </a>
<a name="ln66">  node = route_node_new (table);</a>
<a name="ln67"> </a>
<a name="ln68">  prefix_copy (&amp;node-&gt;p, prefix);</a>
<a name="ln69">  node-&gt;table = table;</a>
<a name="ln70"> </a>
<a name="ln71">  return node;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">/* Free route node. */</a>
<a name="ln75">static void</a>
<a name="ln76">route_node_free (struct route_table *table, struct route_node *node)</a>
<a name="ln77">{</a>
<a name="ln78">  table-&gt;delegate-&gt;destroy_node (table-&gt;delegate, table, node);</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">/* Free route table. */</a>
<a name="ln82">static void</a>
<a name="ln83">route_table_free (struct route_table *rt)</a>
<a name="ln84">{</a>
<a name="ln85">  struct route_node *tmp_node;</a>
<a name="ln86">  struct route_node *node;</a>
<a name="ln87"> </a>
<a name="ln88">  if (rt == NULL)</a>
<a name="ln89">    return;</a>
<a name="ln90"> </a>
<a name="ln91">  node = rt-&gt;top;</a>
<a name="ln92"> </a>
<a name="ln93">  /* Bulk deletion of nodes remaining in this table.  This function is not</a>
<a name="ln94">     called until workers have completed their dependency on this table.</a>
<a name="ln95">     A final route_unlock_node() will not be called for these nodes. */</a>
<a name="ln96">  while (node)</a>
<a name="ln97">    {</a>
<a name="ln98">      if (node-&gt;l_left)</a>
<a name="ln99">	{</a>
<a name="ln100">	  node = node-&gt;l_left;</a>
<a name="ln101">	  continue;</a>
<a name="ln102">	}</a>
<a name="ln103"> </a>
<a name="ln104">      if (node-&gt;l_right)</a>
<a name="ln105">	{</a>
<a name="ln106">	  node = node-&gt;l_right;</a>
<a name="ln107">	  continue;</a>
<a name="ln108">	}</a>
<a name="ln109"> </a>
<a name="ln110">      tmp_node = node;</a>
<a name="ln111">      node = node-&gt;parent;</a>
<a name="ln112"> </a>
<a name="ln113">      tmp_node-&gt;table-&gt;count--;</a>
<a name="ln114">      tmp_node-&gt;lock = 0;  /* to cause assert if unlocked after this */</a>
<a name="ln115">      route_node_free (rt, tmp_node);</a>
<a name="ln116"> </a>
<a name="ln117">      if (node != NULL)</a>
<a name="ln118">	{</a>
<a name="ln119">	  if (node-&gt;l_left == tmp_node)</a>
<a name="ln120">	    node-&gt;l_left = NULL;</a>
<a name="ln121">	  else</a>
<a name="ln122">	    node-&gt;l_right = NULL;</a>
<a name="ln123">	}</a>
<a name="ln124">      else</a>
<a name="ln125">	{</a>
<a name="ln126">	  break;</a>
<a name="ln127">	}</a>
<a name="ln128">    }</a>
<a name="ln129"> </a>
<a name="ln130">  assert (rt-&gt;count == 0);</a>
<a name="ln131"> </a>
<a name="ln132">  XFREE (MTYPE_ROUTE_TABLE, rt);</a>
<a name="ln133">  return;</a>
<a name="ln134">}</a>
<a name="ln135"> </a>
<a name="ln136">/* Utility mask array. */</a>
<a name="ln137">static const u_char maskbit[] =</a>
<a name="ln138">{</a>
<a name="ln139">  0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff</a>
<a name="ln140">};</a>
<a name="ln141"> </a>
<a name="ln142">/* Common prefix route genaration. */</a>
<a name="ln143">static void</a>
<a name="ln144">route_common (const struct prefix *n, const struct prefix *p, struct prefix *new)</a>
<a name="ln145">{</a>
<a name="ln146">  int i;</a>
<a name="ln147">  u_char diff;</a>
<a name="ln148">  u_char mask;</a>
<a name="ln149"> </a>
<a name="ln150">  const u_char *np = (const u_char *)&amp;n-&gt;u.prefix;</a>
<a name="ln151">  const u_char *pp = (const u_char *)&amp;p-&gt;u.prefix;</a>
<a name="ln152">  u_char *newp = (u_char *)&amp;new-&gt;u.prefix;</a>
<a name="ln153"> </a>
<a name="ln154">  for (i = 0; i &lt; p-&gt;prefixlen / 8; i++)</a>
<a name="ln155">    {</a>
<a name="ln156">      if (np[i] == pp[i])</a>
<a name="ln157">	newp[i] = np[i];</a>
<a name="ln158">      else</a>
<a name="ln159">	break;</a>
<a name="ln160">    }</a>
<a name="ln161"> </a>
<a name="ln162">  new-&gt;prefixlen = i * 8;</a>
<a name="ln163"> </a>
<a name="ln164">  if (new-&gt;prefixlen != p-&gt;prefixlen)</a>
<a name="ln165">    {</a>
<a name="ln166">      diff = np[i] ^ pp[i];</a>
<a name="ln167">      mask = 0x80;</a>
<a name="ln168">      while (new-&gt;prefixlen &lt; p-&gt;prefixlen &amp;&amp; !(mask &amp; diff))</a>
<a name="ln169">	{</a>
<a name="ln170">	  mask &gt;&gt;= 1;</a>
<a name="ln171">	  new-&gt;prefixlen++;</a>
<a name="ln172">	}</a>
<a name="ln173">      newp[i] = np[i] &amp; maskbit[new-&gt;prefixlen % 8];</a>
<a name="ln174">    }</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">static void</a>
<a name="ln178">set_link (struct route_node *node, struct route_node *new)</a>
<a name="ln179">{</a>
<a name="ln180">  unsigned int bit = prefix_bit (&amp;new-&gt;p.u.prefix, node-&gt;p.prefixlen);</a>
<a name="ln181"> </a>
<a name="ln182">  node-&gt;link[bit] = new;</a>
<a name="ln183">  new-&gt;parent = node;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">/* Lock node. */</a>
<a name="ln187">struct route_node *</a>
<a name="ln188">route_lock_node (struct route_node *node)</a>
<a name="ln189">{</a>
<a name="ln190">  node-&gt;lock++;</a>
<a name="ln191">  return node;</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">/* Unlock node. */</a>
<a name="ln195">void</a>
<a name="ln196">route_unlock_node (struct route_node *node)</a>
<a name="ln197">{</a>
<a name="ln198">  assert (node-&gt;lock &gt; 0);</a>
<a name="ln199">  node-&gt;lock--;</a>
<a name="ln200"> </a>
<a name="ln201">  if (node-&gt;lock == 0)</a>
<a name="ln202">    route_node_delete (node);</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">/* Find matched prefix. */</a>
<a name="ln206">struct route_node *</a>
<a name="ln207">route_node_match (const struct route_table *table, const struct prefix *p)</a>
<a name="ln208">{</a>
<a name="ln209">  struct route_node *node;</a>
<a name="ln210">  struct route_node *matched;</a>
<a name="ln211"> </a>
<a name="ln212">  matched = NULL;</a>
<a name="ln213">  node = table-&gt;top;</a>
<a name="ln214"> </a>
<a name="ln215">  /* Walk down tree.  If there is matched route then store it to</a>
<a name="ln216">     matched. */</a>
<a name="ln217">  while (node &amp;&amp; node-&gt;p.prefixlen &lt;= p-&gt;prefixlen &amp;&amp; </a>
<a name="ln218">	 prefix_match (&amp;node-&gt;p, p))</a>
<a name="ln219">    {</a>
<a name="ln220">      if (node-&gt;info)</a>
<a name="ln221">	matched = node;</a>
<a name="ln222">      </a>
<a name="ln223">      if (node-&gt;p.prefixlen == p-&gt;prefixlen)</a>
<a name="ln224">        break;</a>
<a name="ln225">      </a>
<a name="ln226">      node = node-&gt;link[prefix_bit(&amp;p-&gt;u.prefix, node-&gt;p.prefixlen)];</a>
<a name="ln227">    }</a>
<a name="ln228"> </a>
<a name="ln229">  /* If matched route found, return it. */</a>
<a name="ln230">  if (matched)</a>
<a name="ln231">    return route_lock_node (matched);</a>
<a name="ln232"> </a>
<a name="ln233">  return NULL;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">struct route_node *</a>
<a name="ln237">route_node_match_ipv4 (const struct route_table *table,</a>
<a name="ln238">		       const struct in_addr *addr)</a>
<a name="ln239">{</a>
<a name="ln240">  struct prefix_ipv4 p;</a>
<a name="ln241"> </a>
<a name="ln242">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln243">  p.family = AF_INET;</a>
<a name="ln244">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln245">  p.prefix = *addr;</a>
<a name="ln246"> </a>
<a name="ln247">  return route_node_match (table, (struct prefix *) &amp;p);</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">#ifdef HAVE_IPV6</a>
<a name="ln251">struct route_node *</a>
<a name="ln252">route_node_match_ipv6 (const struct route_table *table,</a>
<a name="ln253">		       const struct in6_addr *addr)</a>
<a name="ln254">{</a>
<a name="ln255">  struct prefix_ipv6 p;</a>
<a name="ln256"> </a>
<a name="ln257">  memset (&amp;p, 0, sizeof (struct prefix_ipv6));</a>
<a name="ln258">  p.family = AF_INET6;</a>
<a name="ln259">  p.prefixlen = IPV6_MAX_PREFIXLEN;</a>
<a name="ln260">  p.prefix = *addr;</a>
<a name="ln261"> </a>
<a name="ln262">  return route_node_match (table, (struct prefix *) &amp;p);</a>
<a name="ln263">}</a>
<a name="ln264">#endif /* HAVE_IPV6 */</a>
<a name="ln265"> </a>
<a name="ln266">/* Lookup same prefix node.  Return NULL when we can't find route. */</a>
<a name="ln267">struct route_node *</a>
<a name="ln268">route_node_lookup (const struct route_table *table, const struct prefix *p)</a>
<a name="ln269">{</a>
<a name="ln270">  struct route_node *node;</a>
<a name="ln271">  u_char prefixlen = p-&gt;prefixlen;</a>
<a name="ln272">  const u_char *prefix = &amp;p-&gt;u.prefix;</a>
<a name="ln273"> </a>
<a name="ln274">  node = table-&gt;top;</a>
<a name="ln275"> </a>
<a name="ln276">  while (node &amp;&amp; node-&gt;p.prefixlen &lt;= prefixlen &amp;&amp;</a>
<a name="ln277">	 prefix_match (&amp;node-&gt;p, p))</a>
<a name="ln278">    {</a>
<a name="ln279">      if (node-&gt;p.prefixlen == prefixlen)</a>
<a name="ln280">        return node-&gt;info ? route_lock_node (node) : NULL;</a>
<a name="ln281"> </a>
<a name="ln282">      node = node-&gt;link[prefix_bit(prefix, node-&gt;p.prefixlen)];</a>
<a name="ln283">    }</a>
<a name="ln284"> </a>
<a name="ln285">  return NULL;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">/* Add node to routing table. */</a>
<a name="ln289">struct route_node *</a>
<a name="ln290">route_node_get (struct route_table *const table, const struct prefix *p)</a>
<a name="ln291">{</a>
<a name="ln292">  struct route_node *new;</a>
<a name="ln293">  struct route_node *node;</a>
<a name="ln294">  struct route_node *match;</a>
<a name="ln295">  u_char prefixlen = p-&gt;prefixlen;</a>
<a name="ln296">  const u_char *prefix = &amp;p-&gt;u.prefix;</a>
<a name="ln297"> </a>
<a name="ln298">  match = NULL;</a>
<a name="ln299">  node = table-&gt;top;</a>
<a name="ln300">  while (node &amp;&amp; node-&gt;p.prefixlen &lt;= prefixlen &amp;&amp;</a>
<a name="ln301">	 prefix_match (&amp;node-&gt;p, p))</a>
<a name="ln302">    {</a>
<a name="ln303">      if (node-&gt;p.prefixlen == prefixlen)</a>
<a name="ln304">        return route_lock_node (node);</a>
<a name="ln305"> </a>
<a name="ln306">      match = node;</a>
<a name="ln307">      node = node-&gt;link[prefix_bit(prefix, node-&gt;p.prefixlen)];</a>
<a name="ln308">    }</a>
<a name="ln309"> </a>
<a name="ln310">  if (node == NULL)</a>
<a name="ln311">    {</a>
<a name="ln312">      new = route_node_set (table, p);</a>
<a name="ln313">      if (match)</a>
<a name="ln314">	set_link (match, new);</a>
<a name="ln315">      else</a>
<a name="ln316">	table-&gt;top = new;</a>
<a name="ln317">    }</a>
<a name="ln318">  else</a>
<a name="ln319">    {</a>
<a name="ln320">      new = route_node_new (table);</a>
<a name="ln321">      route_common (&amp;node-&gt;p, p, &amp;new-&gt;p);</a>
<a name="ln322">      new-&gt;p.family = p-&gt;family;</a>
<a name="ln323">      new-&gt;table = table;</a>
<a name="ln324">      set_link (new, node);</a>
<a name="ln325"> </a>
<a name="ln326">      if (match)</a>
<a name="ln327">	set_link (match, new);</a>
<a name="ln328">      else</a>
<a name="ln329">	table-&gt;top = new;</a>
<a name="ln330"> </a>
<a name="ln331">      if (new-&gt;p.prefixlen != p-&gt;prefixlen)</a>
<a name="ln332">	{</a>
<a name="ln333">	  match = new;</a>
<a name="ln334">	  new = route_node_set (table, p);</a>
<a name="ln335">	  set_link (match, new);</a>
<a name="ln336">	  table-&gt;count++;</a>
<a name="ln337">	}</a>
<a name="ln338">    }</a>
<a name="ln339">  table-&gt;count++;</a>
<a name="ln340">  route_lock_node (new);</a>
<a name="ln341">  </a>
<a name="ln342">  return new;</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">/* Delete node from the routing table. */</a>
<a name="ln346">static void</a>
<a name="ln347">route_node_delete (struct route_node *node)</a>
<a name="ln348">{</a>
<a name="ln349">  struct route_node *child;</a>
<a name="ln350">  struct route_node *parent;</a>
<a name="ln351"> </a>
<a name="ln352">  assert (node-&gt;lock == 0);</a>
<a name="ln353">  assert (node-&gt;info == NULL);</a>
<a name="ln354"> </a>
<a name="ln355">  if (node-&gt;l_left &amp;&amp; node-&gt;l_right)</a>
<a name="ln356">    return;</a>
<a name="ln357"> </a>
<a name="ln358">  if (node-&gt;l_left)</a>
<a name="ln359">    child = node-&gt;l_left;</a>
<a name="ln360">  else</a>
<a name="ln361">    child = node-&gt;l_right;</a>
<a name="ln362"> </a>
<a name="ln363">  parent = node-&gt;parent;</a>
<a name="ln364"> </a>
<a name="ln365">  if (child)</a>
<a name="ln366">    child-&gt;parent = parent;</a>
<a name="ln367"> </a>
<a name="ln368">  if (parent)</a>
<a name="ln369">    {</a>
<a name="ln370">      if (parent-&gt;l_left == node)</a>
<a name="ln371">	parent-&gt;l_left = child;</a>
<a name="ln372">      else</a>
<a name="ln373">	parent-&gt;l_right = child;</a>
<a name="ln374">    }</a>
<a name="ln375">  else</a>
<a name="ln376">    node-&gt;table-&gt;top = child;</a>
<a name="ln377"> </a>
<a name="ln378">  node-&gt;table-&gt;count--;</a>
<a name="ln379"> </a>
<a name="ln380">  route_node_free (node-&gt;table, node);</a>
<a name="ln381"> </a>
<a name="ln382">  /* If parent node is stub then delete it also. */</a>
<a name="ln383">  if (parent &amp;&amp; parent-&gt;lock == 0)</a>
<a name="ln384">    route_node_delete (parent);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">/* Get fist node and lock it.  This function is useful when one want</a>
<a name="ln388">   to lookup all the node exist in the routing table. */</a>
<a name="ln389">struct route_node *</a>
<a name="ln390">route_top (struct route_table *table)</a>
<a name="ln391">{</a>
<a name="ln392">  /* If there is no node in the routing table return NULL. */</a>
<a name="ln393">  if (table-&gt;top == NULL)</a>
<a name="ln394">    return NULL;</a>
<a name="ln395"> </a>
<a name="ln396">  /* Lock the top node and return it. */</a>
<a name="ln397">  route_lock_node (table-&gt;top);</a>
<a name="ln398">  return table-&gt;top;</a>
<a name="ln399">}</a>
<a name="ln400"> </a>
<a name="ln401">/* Unlock current node and lock next node then return it. */</a>
<a name="ln402">struct route_node *</a>
<a name="ln403">route_next (struct route_node *node)</a>
<a name="ln404">{</a>
<a name="ln405">  struct route_node *next;</a>
<a name="ln406">  struct route_node *start;</a>
<a name="ln407"> </a>
<a name="ln408">  /* Node may be deleted from route_unlock_node so we have to preserve</a>
<a name="ln409">     next node's pointer. */</a>
<a name="ln410"> </a>
<a name="ln411">  if (node-&gt;l_left)</a>
<a name="ln412">    {</a>
<a name="ln413">      next = node-&gt;l_left;</a>
<a name="ln414">      route_lock_node (next);</a>
<a name="ln415">      route_unlock_node (node);</a>
<a name="ln416">      return next;</a>
<a name="ln417">    }</a>
<a name="ln418">  if (node-&gt;l_right)</a>
<a name="ln419">    {</a>
<a name="ln420">      next = node-&gt;l_right;</a>
<a name="ln421">      route_lock_node (next);</a>
<a name="ln422">      route_unlock_node (node);</a>
<a name="ln423">      return next;</a>
<a name="ln424">    }</a>
<a name="ln425"> </a>
<a name="ln426">  start = node;</a>
<a name="ln427">  while (node-&gt;parent)</a>
<a name="ln428">    {</a>
<a name="ln429">      if (node-&gt;parent-&gt;l_left == node &amp;&amp; node-&gt;parent-&gt;l_right)</a>
<a name="ln430">	{</a>
<a name="ln431">	  next = node-&gt;parent-&gt;l_right;</a>
<a name="ln432">	  route_lock_node (next);</a>
<a name="ln433">	  route_unlock_node (start);</a>
<a name="ln434">	  return next;</a>
<a name="ln435">	}</a>
<a name="ln436">      node = node-&gt;parent;</a>
<a name="ln437">    }</a>
<a name="ln438">  route_unlock_node (start);</a>
<a name="ln439">  return NULL;</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">/* Unlock current node and lock next node until limit. */</a>
<a name="ln443">struct route_node *</a>
<a name="ln444">route_next_until (struct route_node *node, struct route_node *limit)</a>
<a name="ln445">{</a>
<a name="ln446">  struct route_node *next;</a>
<a name="ln447">  struct route_node *start;</a>
<a name="ln448"> </a>
<a name="ln449">  /* Node may be deleted from route_unlock_node so we have to preserve</a>
<a name="ln450">     next node's pointer. */</a>
<a name="ln451"> </a>
<a name="ln452">  if (node-&gt;l_left)</a>
<a name="ln453">    {</a>
<a name="ln454">      next = node-&gt;l_left;</a>
<a name="ln455">      route_lock_node (next);</a>
<a name="ln456">      route_unlock_node (node);</a>
<a name="ln457">      return next;</a>
<a name="ln458">    }</a>
<a name="ln459">  if (node-&gt;l_right)</a>
<a name="ln460">    {</a>
<a name="ln461">      next = node-&gt;l_right;</a>
<a name="ln462">      route_lock_node (next);</a>
<a name="ln463">      route_unlock_node (node);</a>
<a name="ln464">      return next;</a>
<a name="ln465">    }</a>
<a name="ln466"> </a>
<a name="ln467">  start = node;</a>
<a name="ln468">  while (node-&gt;parent &amp;&amp; node != limit)</a>
<a name="ln469">    {</a>
<a name="ln470">      if (node-&gt;parent-&gt;l_left == node &amp;&amp; node-&gt;parent-&gt;l_right)</a>
<a name="ln471">	{</a>
<a name="ln472">	  next = node-&gt;parent-&gt;l_right;</a>
<a name="ln473">	  route_lock_node (next);</a>
<a name="ln474">	  route_unlock_node (start);</a>
<a name="ln475">	  return next;</a>
<a name="ln476">	}</a>
<a name="ln477">      node = node-&gt;parent;</a>
<a name="ln478">    }</a>
<a name="ln479">  route_unlock_node (start);</a>
<a name="ln480">  return NULL;</a>
<a name="ln481">}</a>
<a name="ln482"> </a>
<a name="ln483">unsigned long</a>
<a name="ln484">route_table_count (const struct route_table *table)</a>
<a name="ln485">{</a>
<a name="ln486">  return table-&gt;count;</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">/**</a>
<a name="ln490"> * route_node_create</a>
<a name="ln491"> *</a>
<a name="ln492"> * Default function for creating a route node.</a>
<a name="ln493"> */</a>
<a name="ln494">static struct route_node *</a>
<a name="ln495">route_node_create (route_table_delegate_t *delegate,</a>
<a name="ln496">		   struct route_table *table)</a>
<a name="ln497">{</a>
<a name="ln498">  struct route_node *node;</a>
<a name="ln499">  node = XCALLOC (MTYPE_ROUTE_NODE, sizeof (struct route_node));</a>
<a name="ln500">  return node;</a>
<a name="ln501">}</a>
<a name="ln502"> </a>
<a name="ln503">/**</a>
<a name="ln504"> * route_node_destroy</a>
<a name="ln505"> *</a>
<a name="ln506"> * Default function for destroying a route node.</a>
<a name="ln507"> */</a>
<a name="ln508">static void</a>
<a name="ln509">route_node_destroy (route_table_delegate_t *delegate,</a>
<a name="ln510">		    struct route_table *table, struct route_node *node)</a>
<a name="ln511">{</a>
<a name="ln512">  XFREE (MTYPE_ROUTE_NODE, node);</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">/*</a>
<a name="ln516"> * Default delegate.</a>
<a name="ln517"> */</a>
<a name="ln518">static route_table_delegate_t default_delegate = {</a>
<a name="ln519">  .create_node = route_node_create,</a>
<a name="ln520">  .destroy_node = route_node_destroy</a>
<a name="ln521">};</a>
<a name="ln522"> </a>
<a name="ln523">/*</a>
<a name="ln524"> * route_table_init</a>
<a name="ln525"> */</a>
<a name="ln526">struct route_table *</a>
<a name="ln527">route_table_init (void)</a>
<a name="ln528">{</a>
<a name="ln529">  return route_table_init_with_delegate (&amp;default_delegate);</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">/**</a>
<a name="ln533"> * route_table_prefix_iter_cmp</a>
<a name="ln534"> *</a>
<a name="ln535"> * Compare two prefixes according to the order in which they appear in</a>
<a name="ln536"> * an iteration over a tree.</a>
<a name="ln537"> * </a>
<a name="ln538"> * @return -1 if p1 occurs before p2 (p1 &lt; p2)</a>
<a name="ln539"> *          0 if the prefixes are identical (p1 == p2)</a>
<a name="ln540"> *         +1 if p1 occurs after p2 (p1 &gt; p2)</a>
<a name="ln541"> */</a>
<a name="ln542">int</a>
<a name="ln543">route_table_prefix_iter_cmp (struct prefix *p1, struct prefix *p2)</a>
<a name="ln544">{</a>
<a name="ln545">  struct prefix common_space;</a>
<a name="ln546">  struct prefix *common = &amp;common_space;</a>
<a name="ln547"> </a>
<a name="ln548">  if (p1-&gt;prefixlen &lt;= p2-&gt;prefixlen)</a>
<a name="ln549">    {</a>
<a name="ln550">      if (prefix_match (p1, p2))</a>
<a name="ln551">	{</a>
<a name="ln552"> </a>
<a name="ln553">	  /*</a>
<a name="ln554">	   * p1 contains p2, or is equal to it.</a>
<a name="ln555">	   */</a>
<a name="ln556">	  return (p1-&gt;prefixlen == p2-&gt;prefixlen) ? 0 : -1;</a>
<a name="ln557">	}</a>
<a name="ln558">    }</a>
<a name="ln559">  else</a>
<a name="ln560">    {</a>
<a name="ln561"> </a>
<a name="ln562">      /*</a>
<a name="ln563">       * Check if p2 contains p1.</a>
<a name="ln564">       */</a>
<a name="ln565">      if (prefix_match (p2, p1))</a>
<a name="ln566">	  return 1;</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">  route_common (p1, p2, common);</a>
<a name="ln570">  assert (common-&gt;prefixlen &lt; p1-&gt;prefixlen);</a>
<a name="ln571">  assert (common-&gt;prefixlen &lt; p2-&gt;prefixlen);</a>
<a name="ln572"> </a>
<a name="ln573">  /*</a>
<a name="ln574">   * Both prefixes are longer than the common prefix.</a>
<a name="ln575">   *</a>
<a name="ln576">   * We need to check the bit after the common prefixlen to determine</a>
<a name="ln577">   * which one comes later.</a>
<a name="ln578">   */</a>
<a name="ln579">  if (prefix_bit (&amp;p1-&gt;u.prefix, common-&gt;prefixlen))</a>
<a name="ln580">    {</a>
<a name="ln581"> </a>
<a name="ln582">      /*</a>
<a name="ln583">       * We branch to the right to get to p1 from the common prefix.</a>
<a name="ln584">       */</a>
<a name="ln585">      assert (!prefix_bit (&amp;p2-&gt;u.prefix, common-&gt;prefixlen));</a>
<a name="ln586">      return 1;</a>
<a name="ln587">    }</a>
<a name="ln588"> </a>
<a name="ln589">  /*</a>
<a name="ln590">   * We branch to the right to get to p2 from the common prefix.</a>
<a name="ln591">   */</a>
<a name="ln592">  assert (prefix_bit (&amp;p2-&gt;u.prefix, common-&gt;prefixlen));</a>
<a name="ln593">  return -1;</a>
<a name="ln594">}</a>
<a name="ln595"> </a>
<a name="ln596">/*</a>
<a name="ln597"> * route_get_subtree_next</a>
<a name="ln598"> *</a>
<a name="ln599"> * Helper function that returns the first node that follows the nodes</a>
<a name="ln600"> * in the sub-tree under 'node' in iteration order.</a>
<a name="ln601"> */</a>
<a name="ln602">static struct route_node *</a>
<a name="ln603">route_get_subtree_next (struct route_node *node)</a>
<a name="ln604">{</a>
<a name="ln605">  while (node-&gt;parent)</a>
<a name="ln606">    {</a>
<a name="ln607">      if (node-&gt;parent-&gt;l_left == node &amp;&amp; node-&gt;parent-&gt;l_right)</a>
<a name="ln608">	return node-&gt;parent-&gt;l_right;</a>
<a name="ln609"> </a>
<a name="ln610">      node = node-&gt;parent;</a>
<a name="ln611">    }</a>
<a name="ln612"> </a>
<a name="ln613">  return NULL;</a>
<a name="ln614">}</a>
<a name="ln615"> </a>
<a name="ln616">/**</a>
<a name="ln617"> * route_table_get_next_internal</a>
<a name="ln618"> *</a>
<a name="ln619"> * Helper function to find the node that occurs after the given prefix in</a>
<a name="ln620"> * order of iteration.</a>
<a name="ln621"> *</a>
<a name="ln622"> * @see route_table_get_next</a>
<a name="ln623"> */</a>
<a name="ln624">static struct route_node *</a>
<a name="ln625">route_table_get_next_internal (const struct route_table *table,</a>
<a name="ln626">			       struct prefix *p)</a>
<a name="ln627">{</a>
<a name="ln628">  struct route_node *node, *tmp_node;</a>
<a name="ln629">  int cmp;</a>
<a name="ln630"> </a>
<a name="ln631">  node = table-&gt;top;</a>
<a name="ln632"> </a>
<a name="ln633">  while (node)</a>
<a name="ln634">    {</a>
<a name="ln635">      int match;</a>
<a name="ln636"> </a>
<a name="ln637">      if (node-&gt;p.prefixlen &lt; p-&gt;prefixlen)</a>
<a name="ln638">	match = prefix_match (&amp;node-&gt;p, p);</a>
<a name="ln639">      else</a>
<a name="ln640">	match = prefix_match (p, &amp;node-&gt;p);</a>
<a name="ln641"> </a>
<a name="ln642">      if (match)</a>
<a name="ln643">	{</a>
<a name="ln644">	  if (node-&gt;p.prefixlen == p-&gt;prefixlen)</a>
<a name="ln645">	    {</a>
<a name="ln646"> </a>
<a name="ln647">	      /*</a>
<a name="ln648">	       * The prefix p exists in the tree, just return the next</a>
<a name="ln649">	       * node.</a>
<a name="ln650">	       */</a>
<a name="ln651">	      route_lock_node (node);</a>
<a name="ln652">	      node = route_next (node);</a>
<a name="ln653">	      if (node)</a>
<a name="ln654">		route_unlock_node (node);</a>
<a name="ln655"> </a>
<a name="ln656">	      return (node);</a>
<a name="ln657">	    }</a>
<a name="ln658"> </a>
<a name="ln659">	  if (node-&gt;p.prefixlen &gt; p-&gt;prefixlen)</a>
<a name="ln660">	    {</a>
<a name="ln661"> </a>
<a name="ln662">	      /*</a>
<a name="ln663">	       * Node is in the subtree of p, and hence greater than p.</a>
<a name="ln664">	       */</a>
<a name="ln665">	      return node;</a>
<a name="ln666">	    }</a>
<a name="ln667"> </a>
<a name="ln668">	  /*</a>
<a name="ln669">	   * p is in the sub-tree under node.</a>
<a name="ln670">	   */</a>
<a name="ln671">	  tmp_node = node-&gt;link[prefix_bit (&amp;p-&gt;u.prefix, node-&gt;p.prefixlen)];</a>
<a name="ln672"> </a>
<a name="ln673">	  if (tmp_node)</a>
<a name="ln674">	    {</a>
<a name="ln675">	      node = tmp_node;</a>
<a name="ln676">	      continue;</a>
<a name="ln677">	    }</a>
<a name="ln678"> </a>
<a name="ln679">	  /*</a>
<a name="ln680">	   * There are no nodes in the direction where p should be. If</a>
<a name="ln681">	   * node has a right child, then it must be greater than p.</a>
<a name="ln682">	   */</a>
<a name="ln683">	  if (node-&gt;l_right)</a>
<a name="ln684">	    return node-&gt;l_right;</a>
<a name="ln685"> </a>
<a name="ln686">	  /*</a>
<a name="ln687">	   * No more children to follow, go upwards looking for the next</a>
<a name="ln688">	   * node.</a>
<a name="ln689">	   */</a>
<a name="ln690">	  return route_get_subtree_next (node);</a>
<a name="ln691">	}</a>
<a name="ln692"> </a>
<a name="ln693">      /*</a>
<a name="ln694">       * Neither node prefix nor 'p' contains the other.</a>
<a name="ln695">       */</a>
<a name="ln696">      cmp = route_table_prefix_iter_cmp (&amp;node-&gt;p, p);</a>
<a name="ln697">      if (cmp &gt; 0)</a>
<a name="ln698">	{</a>
<a name="ln699"> </a>
<a name="ln700">	  /*</a>
<a name="ln701">	   * Node follows p in iteration order. Return it.</a>
<a name="ln702">	   */</a>
<a name="ln703">	  return node;</a>
<a name="ln704">	}</a>
<a name="ln705"> </a>
<a name="ln706">      assert (cmp &lt; 0);</a>
<a name="ln707"> </a>
<a name="ln708">      /*</a>
<a name="ln709">       * Node and the subtree under it come before prefix p in</a>
<a name="ln710">       * iteration order. Prefix p and its sub-tree are not present in</a>
<a name="ln711">       * the tree. Go upwards and find the first node that follows the</a>
<a name="ln712">       * subtree. That node will also succeed p.</a>
<a name="ln713">       */</a>
<a name="ln714">      return route_get_subtree_next (node);</a>
<a name="ln715">    }</a>
<a name="ln716"> </a>
<a name="ln717">  return NULL;</a>
<a name="ln718">}</a>
<a name="ln719"> </a>
<a name="ln720">/**</a>
<a name="ln721"> * route_table_get_next</a>
<a name="ln722"> *</a>
<a name="ln723"> * Find the node that occurs after the given prefix in order of</a>
<a name="ln724"> * iteration.</a>
<a name="ln725"> */</a>
<a name="ln726">struct route_node *</a>
<a name="ln727">route_table_get_next (const struct route_table *table, struct prefix *p)</a>
<a name="ln728">{</a>
<a name="ln729">  struct route_node *node;</a>
<a name="ln730"> </a>
<a name="ln731">  node = route_table_get_next_internal (table, p);</a>
<a name="ln732">  if (node)</a>
<a name="ln733">    {</a>
<a name="ln734">      assert (route_table_prefix_iter_cmp (&amp;node-&gt;p, p) &gt; 0);</a>
<a name="ln735">      route_lock_node (node);</a>
<a name="ln736">    }</a>
<a name="ln737">  return node;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">/*</a>
<a name="ln741"> * route_table_iter_init</a>
<a name="ln742"> */</a>
<a name="ln743">void</a>
<a name="ln744">route_table_iter_init (route_table_iter_t * iter, struct route_table *table)</a>
<a name="ln745">{</a>
<a name="ln746">  memset (iter, 0, sizeof (*iter));</a>
<a name="ln747">  iter-&gt;state = RT_ITER_STATE_INIT;</a>
<a name="ln748">  iter-&gt;table = table;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">/*</a>
<a name="ln752"> * route_table_iter_pause</a>
<a name="ln753"> *</a>
<a name="ln754"> * Pause an iteration over the table. This allows the iteration to be</a>
<a name="ln755"> * resumed point after arbitrary additions/deletions from the table.</a>
<a name="ln756"> * An iteration can be resumed by just calling route_table_iter_next()</a>
<a name="ln757"> * on the iterator.</a>
<a name="ln758"> */</a>
<a name="ln759">void</a>
<a name="ln760">route_table_iter_pause (route_table_iter_t * iter)</a>
<a name="ln761">{</a>
<a name="ln762">  switch (iter-&gt;state)</a>
<a name="ln763">    {</a>
<a name="ln764"> </a>
<a name="ln765">    case RT_ITER_STATE_INIT:</a>
<a name="ln766">    case RT_ITER_STATE_PAUSED:</a>
<a name="ln767">    case RT_ITER_STATE_DONE:</a>
<a name="ln768">      return;</a>
<a name="ln769"> </a>
<a name="ln770">    case RT_ITER_STATE_ITERATING:</a>
<a name="ln771"> </a>
<a name="ln772">      /*</a>
<a name="ln773">       * Save the prefix that we are currently at. The next call to</a>
<a name="ln774">       * route_table_iter_next() will return the node after this prefix</a>
<a name="ln775">       * in the tree.</a>
<a name="ln776">       */</a>
<a name="ln777">      prefix_copy (&amp;iter-&gt;pause_prefix, &amp;iter-&gt;current-&gt;p);</a>
<a name="ln778">      route_unlock_node (iter-&gt;current);</a>
<a name="ln779">      iter-&gt;current = NULL;</a>
<a name="ln780">      iter-&gt;state = RT_ITER_STATE_PAUSED;</a>
<a name="ln781">      return;</a>
<a name="ln782"> </a>
<a name="ln783">    default:</a>
<a name="ln784">      assert (0);</a>
<a name="ln785">    }</a>
<a name="ln786"> </a>
<a name="ln787">}</a>
<a name="ln788"> </a>
<a name="ln789">/*</a>
<a name="ln790"> * route_table_iter_cleanup</a>
<a name="ln791"> *</a>
<a name="ln792"> * Release any resources held by the iterator.</a>
<a name="ln793"> */</a>
<a name="ln794">void</a>
<a name="ln795">route_table_iter_cleanup (route_table_iter_t * iter)</a>
<a name="ln796">{</a>
<a name="ln797">  if (iter-&gt;state == RT_ITER_STATE_ITERATING)</a>
<a name="ln798">    {</a>
<a name="ln799">      route_unlock_node (iter-&gt;current);</a>
<a name="ln800">      iter-&gt;current = NULL;</a>
<a name="ln801">    }</a>
<a name="ln802">  assert (!iter-&gt;current);</a>
<a name="ln803"> </a>
<a name="ln804">  /*</a>
<a name="ln805">   * Set the state to RT_ITER_STATE_DONE to make any</a>
<a name="ln806">   * route_table_iter_next() calls on this iterator return NULL.</a>
<a name="ln807">   */</a>
<a name="ln808">  iter-&gt;state = RT_ITER_STATE_DONE;</a>
<a name="ln809">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="656"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1020/" target="_blank">V1020</a> The function exited without calling the 'route_unlock_node' function. Check lines: 656, 651.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
