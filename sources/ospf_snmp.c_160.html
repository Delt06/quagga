
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_snmp.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* OSPFv2 SNMP support</a>
<a name="ln2"> * Copyright (C) 2005 6WIND &lt;alain.ritoux@6wind.com&gt;</a>
<a name="ln3"> * Copyright (C) 2000 IP Infusion Inc.</a>
<a name="ln4"> *</a>
<a name="ln5"> * Written by Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln6"> *</a>
<a name="ln7"> * This file is part of GNU Zebra.</a>
<a name="ln8"> *</a>
<a name="ln9"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln10"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln11"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln12"> * later version.</a>
<a name="ln13"> *</a>
<a name="ln14"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln15"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln16"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln17"> * General Public License for more details.</a>
<a name="ln18"> *</a>
<a name="ln19"> * You should have received a copy of the GNU General Public License</a>
<a name="ln20"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln21"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln22"> * 02111-1307, USA.  </a>
<a name="ln23"> */</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;zebra.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#ifdef HAVE_SNMP</a>
<a name="ln28">#include &lt;net-snmp/net-snmp-config.h&gt;</a>
<a name="ln29">#include &lt;net-snmp/net-snmp-includes.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31">#include &quot;if.h&quot;</a>
<a name="ln32">#include &quot;log.h&quot;</a>
<a name="ln33">#include &quot;prefix.h&quot;</a>
<a name="ln34">#include &quot;table.h&quot;</a>
<a name="ln35">#include &quot;command.h&quot;</a>
<a name="ln36">#include &quot;memory.h&quot;</a>
<a name="ln37">#include &quot;smux.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_abr.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln48">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln49">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln50">#include &quot;ospfd/ospf_snmp.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">/* OSPF2-MIB. */</a>
<a name="ln53">#define OSPF2MIB 1,3,6,1,2,1,14</a>
<a name="ln54"> </a>
<a name="ln55">/* OSPF MIB General Group values. */</a>
<a name="ln56">#define OSPFROUTERID                     1</a>
<a name="ln57">#define OSPFADMINSTAT                    2</a>
<a name="ln58">#define OSPFVERSIONNUMBER                3</a>
<a name="ln59">#define OSPFAREABDRRTRSTATUS             4</a>
<a name="ln60">#define OSPFASBDRRTRSTATUS               5</a>
<a name="ln61">#define OSPFEXTERNLSACOUNT               6</a>
<a name="ln62">#define OSPFEXTERNLSACKSUMSUM            7</a>
<a name="ln63">#define OSPFTOSSUPPORT                   8</a>
<a name="ln64">#define OSPFORIGINATENEWLSAS             9</a>
<a name="ln65">#define OSPFRXNEWLSAS                    10</a>
<a name="ln66">#define OSPFEXTLSDBLIMIT                 11</a>
<a name="ln67">#define OSPFMULTICASTEXTENSIONS          12</a>
<a name="ln68">#define OSPFEXITOVERFLOWINTERVAL         13</a>
<a name="ln69">#define OSPFDEMANDEXTENSIONS             14</a>
<a name="ln70"> </a>
<a name="ln71">/* OSPF MIB ospfAreaTable. */</a>
<a name="ln72">#define OSPFAREAID                       1</a>
<a name="ln73">#define OSPFAUTHTYPE                     2</a>
<a name="ln74">#define OSPFIMPORTASEXTERN               3</a>
<a name="ln75">#define OSPFSPFRUNS                      4</a>
<a name="ln76">#define OSPFAREABDRRTRCOUNT              5</a>
<a name="ln77">#define OSPFASBDRRTRCOUNT                6</a>
<a name="ln78">#define OSPFAREALSACOUNT                 7</a>
<a name="ln79">#define OSPFAREALSACKSUMSUM              8</a>
<a name="ln80">#define OSPFAREASUMMARY                  9</a>
<a name="ln81">#define OSPFAREASTATUS                   10</a>
<a name="ln82"> </a>
<a name="ln83">/* OSPF MIB ospfStubAreaTable. */</a>
<a name="ln84">#define OSPFSTUBAREAID                   1</a>
<a name="ln85">#define OSPFSTUBTOS                      2</a>
<a name="ln86">#define OSPFSTUBMETRIC                   3</a>
<a name="ln87">#define OSPFSTUBSTATUS                   4</a>
<a name="ln88">#define OSPFSTUBMETRICTYPE               5</a>
<a name="ln89"> </a>
<a name="ln90">/* OSPF MIB ospfLsdbTable. */</a>
<a name="ln91">#define OSPFLSDBAREAID                   1</a>
<a name="ln92">#define OSPFLSDBTYPE                     2</a>
<a name="ln93">#define OSPFLSDBLSID                     3</a>
<a name="ln94">#define OSPFLSDBROUTERID                 4</a>
<a name="ln95">#define OSPFLSDBSEQUENCE                 5</a>
<a name="ln96">#define OSPFLSDBAGE                      6</a>
<a name="ln97">#define OSPFLSDBCHECKSUM                 7</a>
<a name="ln98">#define OSPFLSDBADVERTISEMENT            8</a>
<a name="ln99"> </a>
<a name="ln100">/* OSPF MIB ospfAreaRangeTable. */</a>
<a name="ln101">#define OSPFAREARANGEAREAID              1</a>
<a name="ln102">#define OSPFAREARANGENET                 2</a>
<a name="ln103">#define OSPFAREARANGEMASK                3</a>
<a name="ln104">#define OSPFAREARANGESTATUS              4</a>
<a name="ln105">#define OSPFAREARANGEEFFECT              5</a>
<a name="ln106"> </a>
<a name="ln107">/* OSPF MIB ospfHostTable. */</a>
<a name="ln108">#define OSPFHOSTIPADDRESS                1</a>
<a name="ln109">#define OSPFHOSTTOS                      2</a>
<a name="ln110">#define OSPFHOSTMETRIC                   3</a>
<a name="ln111">#define OSPFHOSTSTATUS                   4</a>
<a name="ln112">#define OSPFHOSTAREAID                   5</a>
<a name="ln113"> </a>
<a name="ln114">/* OSPF MIB ospfIfTable. */</a>
<a name="ln115">#define OSPFIFIPADDRESS                  1</a>
<a name="ln116">#define OSPFADDRESSLESSIF                2</a>
<a name="ln117">#define OSPFIFAREAID                     3</a>
<a name="ln118">#define OSPFIFTYPE                       4</a>
<a name="ln119">#define OSPFIFADMINSTAT                  5</a>
<a name="ln120">#define OSPFIFRTRPRIORITY                6</a>
<a name="ln121">#define OSPFIFTRANSITDELAY               7</a>
<a name="ln122">#define OSPFIFRETRANSINTERVAL            8</a>
<a name="ln123">#define OSPFIFHELLOINTERVAL              9</a>
<a name="ln124">#define OSPFIFRTRDEADINTERVAL            10</a>
<a name="ln125">#define OSPFIFPOLLINTERVAL               11</a>
<a name="ln126">#define OSPFIFSTATE                      12</a>
<a name="ln127">#define OSPFIFDESIGNATEDROUTER           13</a>
<a name="ln128">#define OSPFIFBACKUPDESIGNATEDROUTER     14</a>
<a name="ln129">#define OSPFIFEVENTS                     15</a>
<a name="ln130">#define OSPFIFAUTHKEY                    16</a>
<a name="ln131">#define OSPFIFSTATUS                     17</a>
<a name="ln132">#define OSPFIFMULTICASTFORWARDING        18</a>
<a name="ln133">#define OSPFIFDEMAND                     19</a>
<a name="ln134">#define OSPFIFAUTHTYPE                   20</a>
<a name="ln135"> </a>
<a name="ln136">/* OSPF MIB ospfIfMetricTable. */</a>
<a name="ln137">#define OSPFIFMETRICIPADDRESS            1</a>
<a name="ln138">#define OSPFIFMETRICADDRESSLESSIF        2</a>
<a name="ln139">#define OSPFIFMETRICTOS                  3</a>
<a name="ln140">#define OSPFIFMETRICVALUE                4</a>
<a name="ln141">#define OSPFIFMETRICSTATUS               5</a>
<a name="ln142"> </a>
<a name="ln143">/* OSPF MIB ospfVirtIfTable. */</a>
<a name="ln144">#define OSPFVIRTIFAREAID                 1</a>
<a name="ln145">#define OSPFVIRTIFNEIGHBOR               2</a>
<a name="ln146">#define OSPFVIRTIFTRANSITDELAY           3</a>
<a name="ln147">#define OSPFVIRTIFRETRANSINTERVAL        4</a>
<a name="ln148">#define OSPFVIRTIFHELLOINTERVAL          5</a>
<a name="ln149">#define OSPFVIRTIFRTRDEADINTERVAL        6</a>
<a name="ln150">#define OSPFVIRTIFSTATE                  7</a>
<a name="ln151">#define OSPFVIRTIFEVENTS                 8</a>
<a name="ln152">#define OSPFVIRTIFAUTHKEY                9</a>
<a name="ln153">#define OSPFVIRTIFSTATUS                 10</a>
<a name="ln154">#define OSPFVIRTIFAUTHTYPE               11</a>
<a name="ln155"> </a>
<a name="ln156">/* OSPF MIB ospfNbrTable. */</a>
<a name="ln157">#define OSPFNBRIPADDR                    1</a>
<a name="ln158">#define OSPFNBRADDRESSLESSINDEX          2</a>
<a name="ln159">#define OSPFNBRRTRID                     3</a>
<a name="ln160">#define OSPFNBROPTIONS                   4</a>
<a name="ln161">#define OSPFNBRPRIORITY                  5</a>
<a name="ln162">#define OSPFNBRSTATE                     6</a>
<a name="ln163">#define OSPFNBREVENTS                    7</a>
<a name="ln164">#define OSPFNBRLSRETRANSQLEN             8</a>
<a name="ln165">#define OSPFNBMANBRSTATUS                9</a>
<a name="ln166">#define OSPFNBMANBRPERMANENCE            10</a>
<a name="ln167">#define OSPFNBRHELLOSUPPRESSED           11</a>
<a name="ln168"> </a>
<a name="ln169">/* OSPF MIB ospfVirtNbrTable. */</a>
<a name="ln170">#define OSPFVIRTNBRAREA                  1</a>
<a name="ln171">#define OSPFVIRTNBRRTRID                 2</a>
<a name="ln172">#define OSPFVIRTNBRIPADDR                3</a>
<a name="ln173">#define OSPFVIRTNBROPTIONS               4</a>
<a name="ln174">#define OSPFVIRTNBRSTATE                 5</a>
<a name="ln175">#define OSPFVIRTNBREVENTS                6</a>
<a name="ln176">#define OSPFVIRTNBRLSRETRANSQLEN         7</a>
<a name="ln177">#define OSPFVIRTNBRHELLOSUPPRESSED       8</a>
<a name="ln178"> </a>
<a name="ln179">/* OSPF MIB ospfExtLsdbTable. */</a>
<a name="ln180">#define OSPFEXTLSDBTYPE                  1</a>
<a name="ln181">#define OSPFEXTLSDBLSID                  2</a>
<a name="ln182">#define OSPFEXTLSDBROUTERID              3</a>
<a name="ln183">#define OSPFEXTLSDBSEQUENCE              4</a>
<a name="ln184">#define OSPFEXTLSDBAGE                   5</a>
<a name="ln185">#define OSPFEXTLSDBCHECKSUM              6</a>
<a name="ln186">#define OSPFEXTLSDBADVERTISEMENT         7</a>
<a name="ln187"> </a>
<a name="ln188">/* OSPF MIB ospfAreaAggregateTable. */</a>
<a name="ln189">#define OSPFAREAAGGREGATEAREAID          1</a>
<a name="ln190">#define OSPFAREAAGGREGATELSDBTYPE        2</a>
<a name="ln191">#define OSPFAREAAGGREGATENET             3</a>
<a name="ln192">#define OSPFAREAAGGREGATEMASK            4</a>
<a name="ln193">#define OSPFAREAAGGREGATESTATUS          5</a>
<a name="ln194">#define OSPFAREAAGGREGATEEFFECT          6</a>
<a name="ln195"> </a>
<a name="ln196">/* SYNTAX Status from OSPF-MIB. */</a>
<a name="ln197">#define OSPF_STATUS_ENABLED  1</a>
<a name="ln198">#define OSPF_STATUS_DISABLED 2</a>
<a name="ln199"> </a>
<a name="ln200">/* SNMP value hack. */</a>
<a name="ln201">#define COUNTER     ASN_COUNTER</a>
<a name="ln202">#define INTEGER     ASN_INTEGER</a>
<a name="ln203">#define GAUGE       ASN_GAUGE</a>
<a name="ln204">#define TIMETICKS   ASN_TIMETICKS</a>
<a name="ln205">#define IPADDRESS   ASN_IPADDRESS</a>
<a name="ln206">#define STRING      ASN_OCTET_STR</a>
<a name="ln207"> </a>
<a name="ln208">/* Declare static local variables for convenience. */</a>
<a name="ln209">SNMP_LOCAL_VARIABLES</a>
<a name="ln210"> </a>
<a name="ln211">/* OSPF-MIB instances. */</a>
<a name="ln212">oid ospf_oid [] = { OSPF2MIB };</a>
<a name="ln213">oid ospf_trap_oid [] = { OSPF2MIB, 16, 2 }; /* Not reverse mappable! */</a>
<a name="ln214"> </a>
<a name="ln215">/* IP address 0.0.0.0. */</a>
<a name="ln216">static struct in_addr ospf_empty_addr = { .s_addr = 0 };</a>
<a name="ln217"> </a>
<a name="ln218">/* Hook functions. */</a>
<a name="ln219">static u_char *ospfGeneralGroup (struct variable *, oid *, size_t *,</a>
<a name="ln220">				 int, size_t *, WriteMethod **);</a>
<a name="ln221">static u_char *ospfAreaEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln222">			      size_t *, WriteMethod **);</a>
<a name="ln223">static u_char *ospfStubAreaEntry (struct variable *, oid *, size_t *,</a>
<a name="ln224">				  int, size_t *, WriteMethod **);</a>
<a name="ln225">static u_char *ospfLsdbEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln226">			      size_t *, WriteMethod **);</a>
<a name="ln227">static u_char *ospfAreaRangeEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln228">				   size_t *, WriteMethod **);</a>
<a name="ln229">static u_char *ospfHostEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln230">			      size_t *, WriteMethod **);</a>
<a name="ln231">static u_char *ospfIfEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln232">			    size_t *, WriteMethod **);</a>
<a name="ln233">static u_char *ospfIfMetricEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln234">				  size_t *, WriteMethod **);</a>
<a name="ln235">static u_char *ospfVirtIfEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln236">				size_t *, WriteMethod **);</a>
<a name="ln237">static u_char *ospfNbrEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln238">			     size_t *, WriteMethod **);</a>
<a name="ln239">static u_char *ospfVirtNbrEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln240">				 size_t *, WriteMethod **);</a>
<a name="ln241">static u_char *ospfExtLsdbEntry (struct variable *, oid *, size_t *, int,</a>
<a name="ln242">				 size_t *, WriteMethod **);</a>
<a name="ln243">static u_char *ospfAreaAggregateEntry (struct variable *, oid *, size_t *,</a>
<a name="ln244">				       int, size_t *, WriteMethod **);</a>
<a name="ln245"> </a>
<a name="ln246">struct variable ospf_variables[] = </a>
<a name="ln247">{</a>
<a name="ln248">  /* OSPF general variables */</a>
<a name="ln249">  {OSPFROUTERID,              IPADDRESS, RWRITE, ospfGeneralGroup,</a>
<a name="ln250">   2, {1, 1}},</a>
<a name="ln251">  {OSPFADMINSTAT,             INTEGER, RWRITE, ospfGeneralGroup,</a>
<a name="ln252">   2, {1, 2}},</a>
<a name="ln253">  {OSPFVERSIONNUMBER,         INTEGER, RONLY, ospfGeneralGroup,</a>
<a name="ln254">   2, {1, 3}},</a>
<a name="ln255">  {OSPFAREABDRRTRSTATUS,      INTEGER, RONLY, ospfGeneralGroup,</a>
<a name="ln256">   2, {1, 4}},</a>
<a name="ln257">  {OSPFASBDRRTRSTATUS,        INTEGER, RWRITE, ospfGeneralGroup,</a>
<a name="ln258">   2, {1, 5}},</a>
<a name="ln259">  {OSPFEXTERNLSACOUNT,        GAUGE, RONLY, ospfGeneralGroup,</a>
<a name="ln260">   2, {1, 6}},</a>
<a name="ln261">  {OSPFEXTERNLSACKSUMSUM,     INTEGER, RONLY, ospfGeneralGroup,</a>
<a name="ln262">   2, {1, 7}},</a>
<a name="ln263">  {OSPFTOSSUPPORT,            INTEGER, RWRITE, ospfGeneralGroup,</a>
<a name="ln264">   2, {1, 8}},</a>
<a name="ln265">  {OSPFORIGINATENEWLSAS,      COUNTER, RONLY, ospfGeneralGroup,</a>
<a name="ln266">   2, {1, 9}},</a>
<a name="ln267">  {OSPFRXNEWLSAS,             COUNTER, RONLY, ospfGeneralGroup,</a>
<a name="ln268">   2, {1, 10}},</a>
<a name="ln269">  {OSPFEXTLSDBLIMIT,          INTEGER, RWRITE, ospfGeneralGroup,</a>
<a name="ln270">   2, {1, 11}},</a>
<a name="ln271">  {OSPFMULTICASTEXTENSIONS,   INTEGER, RWRITE, ospfGeneralGroup,</a>
<a name="ln272">   2, {1, 12}},</a>
<a name="ln273">  {OSPFEXITOVERFLOWINTERVAL,  INTEGER, RWRITE, ospfGeneralGroup,</a>
<a name="ln274">   2, {1, 13}},</a>
<a name="ln275">  {OSPFDEMANDEXTENSIONS,      INTEGER, RWRITE, ospfGeneralGroup,</a>
<a name="ln276">   2, {1, 14}},</a>
<a name="ln277"> </a>
<a name="ln278">  /* OSPF area data structure. */</a>
<a name="ln279">  {OSPFAREAID,                IPADDRESS, RONLY, ospfAreaEntry,</a>
<a name="ln280">   3, {2, 1, 1}},</a>
<a name="ln281">  {OSPFAUTHTYPE,              INTEGER, RWRITE, ospfAreaEntry,</a>
<a name="ln282">   3, {2, 1, 2}},</a>
<a name="ln283">  {OSPFIMPORTASEXTERN,        INTEGER, RWRITE, ospfAreaEntry,</a>
<a name="ln284">   3, {2, 1, 3}},</a>
<a name="ln285">  {OSPFSPFRUNS,               COUNTER, RONLY, ospfAreaEntry,</a>
<a name="ln286">   3, {2, 1, 4}},</a>
<a name="ln287">  {OSPFAREABDRRTRCOUNT,       GAUGE, RONLY, ospfAreaEntry,</a>
<a name="ln288">   3, {2, 1, 5}},</a>
<a name="ln289">  {OSPFASBDRRTRCOUNT,         GAUGE, RONLY, ospfAreaEntry,</a>
<a name="ln290">   3, {2, 1, 6}},</a>
<a name="ln291">  {OSPFAREALSACOUNT,          GAUGE, RONLY, ospfAreaEntry,</a>
<a name="ln292">   3, {2, 1, 7}},</a>
<a name="ln293">  {OSPFAREALSACKSUMSUM,       INTEGER, RONLY, ospfAreaEntry,</a>
<a name="ln294">   3, {2, 1, 8}},</a>
<a name="ln295">  {OSPFAREASUMMARY,           INTEGER, RWRITE, ospfAreaEntry,</a>
<a name="ln296">   3, {2, 1, 9}},</a>
<a name="ln297">  {OSPFAREASTATUS,            INTEGER, RWRITE, ospfAreaEntry,</a>
<a name="ln298">   3, {2, 1, 10}},</a>
<a name="ln299"> </a>
<a name="ln300">  /* OSPF stub area information. */</a>
<a name="ln301">  {OSPFSTUBAREAID,            IPADDRESS, RONLY, ospfStubAreaEntry,</a>
<a name="ln302">   3, {3, 1, 1}},</a>
<a name="ln303">  {OSPFSTUBTOS,               INTEGER, RONLY, ospfStubAreaEntry,</a>
<a name="ln304">   3, {3, 1, 2}},</a>
<a name="ln305">  {OSPFSTUBMETRIC,            INTEGER, RWRITE, ospfStubAreaEntry,</a>
<a name="ln306">   3, {3, 1, 3}},</a>
<a name="ln307">  {OSPFSTUBSTATUS,            INTEGER, RWRITE, ospfStubAreaEntry,</a>
<a name="ln308">   3, {3, 1, 4}},</a>
<a name="ln309">  {OSPFSTUBMETRICTYPE,        INTEGER, RWRITE, ospfStubAreaEntry,</a>
<a name="ln310">   3, {3, 1, 5}},</a>
<a name="ln311"> </a>
<a name="ln312">  /* OSPF link state database. */</a>
<a name="ln313">  {OSPFLSDBAREAID,            IPADDRESS, RONLY, ospfLsdbEntry,</a>
<a name="ln314">   3, {4, 1, 1}},</a>
<a name="ln315">  {OSPFLSDBTYPE,              INTEGER, RONLY, ospfLsdbEntry,</a>
<a name="ln316">   3, {4, 1, 2}},</a>
<a name="ln317">  {OSPFLSDBLSID,              IPADDRESS, RONLY, ospfLsdbEntry,</a>
<a name="ln318">   3, {4, 1, 3}},</a>
<a name="ln319">  {OSPFLSDBROUTERID,          IPADDRESS, RONLY, ospfLsdbEntry,</a>
<a name="ln320">   3, {4, 1, 4}},</a>
<a name="ln321">  {OSPFLSDBSEQUENCE,          INTEGER, RONLY, ospfLsdbEntry,</a>
<a name="ln322">   3, {4, 1, 5}},</a>
<a name="ln323">  {OSPFLSDBAGE,               INTEGER, RONLY, ospfLsdbEntry,</a>
<a name="ln324">   3, {4, 1, 6}},</a>
<a name="ln325">  {OSPFLSDBCHECKSUM,          INTEGER, RONLY, ospfLsdbEntry,</a>
<a name="ln326">   3, {4, 1, 7}},</a>
<a name="ln327">  {OSPFLSDBADVERTISEMENT,     STRING, RONLY, ospfLsdbEntry,</a>
<a name="ln328">   3, {4, 1, 8}},</a>
<a name="ln329"> </a>
<a name="ln330">  /* Area range table. */</a>
<a name="ln331">  {OSPFAREARANGEAREAID,       IPADDRESS, RONLY, ospfAreaRangeEntry,</a>
<a name="ln332">   3, {5, 1, 1}},</a>
<a name="ln333">  {OSPFAREARANGENET,          IPADDRESS, RONLY, ospfAreaRangeEntry,</a>
<a name="ln334">   3, {5, 1, 2}},</a>
<a name="ln335">  {OSPFAREARANGEMASK,         IPADDRESS, RWRITE, ospfAreaRangeEntry,</a>
<a name="ln336">   3, {5, 1, 3}},</a>
<a name="ln337">  {OSPFAREARANGESTATUS,       INTEGER, RWRITE, ospfAreaRangeEntry,</a>
<a name="ln338">   3, {5, 1, 4}},</a>
<a name="ln339">  {OSPFAREARANGEEFFECT,       INTEGER, RWRITE, ospfAreaRangeEntry,</a>
<a name="ln340">   3, {5, 1, 5}},</a>
<a name="ln341"> </a>
<a name="ln342">  /* OSPF host table. */</a>
<a name="ln343">  {OSPFHOSTIPADDRESS,         IPADDRESS, RONLY, ospfHostEntry,</a>
<a name="ln344">   3, {6, 1, 1}},</a>
<a name="ln345">  {OSPFHOSTTOS,               INTEGER, RONLY, ospfHostEntry,</a>
<a name="ln346">   3, {6, 1, 2}},</a>
<a name="ln347">  {OSPFHOSTMETRIC,            INTEGER, RWRITE, ospfHostEntry,</a>
<a name="ln348">   3, {6, 1, 3}},</a>
<a name="ln349">  {OSPFHOSTSTATUS,            INTEGER, RWRITE, ospfHostEntry,</a>
<a name="ln350">   3, {6, 1, 4}},</a>
<a name="ln351">  {OSPFHOSTAREAID,            IPADDRESS, RONLY, ospfHostEntry,</a>
<a name="ln352">   3, {6, 1, 5}},</a>
<a name="ln353"> </a>
<a name="ln354">  /* OSPF interface table. */</a>
<a name="ln355">  {OSPFIFIPADDRESS,           IPADDRESS, RONLY, ospfIfEntry,</a>
<a name="ln356">   3, {7, 1, 1}},</a>
<a name="ln357">  {OSPFADDRESSLESSIF,         INTEGER, RONLY, ospfIfEntry,</a>
<a name="ln358">   3, {7, 1, 2}},</a>
<a name="ln359">  {OSPFIFAREAID,              IPADDRESS, RWRITE, ospfIfEntry,</a>
<a name="ln360">   3, {7, 1, 3}},</a>
<a name="ln361">  {OSPFIFTYPE,                INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln362">   3, {7, 1, 4}},</a>
<a name="ln363">  {OSPFIFADMINSTAT,           INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln364">   3, {7, 1, 5}},</a>
<a name="ln365">  {OSPFIFRTRPRIORITY,         INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln366">   3, {7, 1, 6}},</a>
<a name="ln367">  {OSPFIFTRANSITDELAY,        INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln368">   3, {7, 1, 7}},</a>
<a name="ln369">  {OSPFIFRETRANSINTERVAL,     INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln370">   3, {7, 1, 8}},</a>
<a name="ln371">  {OSPFIFHELLOINTERVAL,       INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln372">   3, {7, 1, 9}},</a>
<a name="ln373">  {OSPFIFRTRDEADINTERVAL,     INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln374">   3, {7, 1, 10}},</a>
<a name="ln375">  {OSPFIFPOLLINTERVAL,        INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln376">   3, {7, 1, 11}},</a>
<a name="ln377">  {OSPFIFSTATE,               INTEGER, RONLY, ospfIfEntry,</a>
<a name="ln378">   3, {7, 1, 12}},</a>
<a name="ln379">  {OSPFIFDESIGNATEDROUTER,    IPADDRESS, RONLY, ospfIfEntry,</a>
<a name="ln380">   3, {7, 1, 13}},</a>
<a name="ln381">  {OSPFIFBACKUPDESIGNATEDROUTER, IPADDRESS, RONLY, ospfIfEntry,</a>
<a name="ln382">   3, {7, 1, 14}},</a>
<a name="ln383">  {OSPFIFEVENTS,              COUNTER, RONLY, ospfIfEntry,</a>
<a name="ln384">   3, {7, 1, 15}},</a>
<a name="ln385">  {OSPFIFAUTHKEY,             STRING,  RWRITE, ospfIfEntry,</a>
<a name="ln386">   3, {7, 1, 16}},</a>
<a name="ln387">  {OSPFIFSTATUS,              INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln388">   3, {7, 1, 17}},</a>
<a name="ln389">  {OSPFIFMULTICASTFORWARDING, INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln390">   3, {7, 1, 18}},</a>
<a name="ln391">  {OSPFIFDEMAND,              INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln392">   3, {7, 1, 19}},</a>
<a name="ln393">  {OSPFIFAUTHTYPE,            INTEGER, RWRITE, ospfIfEntry,</a>
<a name="ln394">   3, {7, 1, 20}},</a>
<a name="ln395"> </a>
<a name="ln396">  /* OSPF interface metric table. */</a>
<a name="ln397">  {OSPFIFMETRICIPADDRESS,     IPADDRESS, RONLY, ospfIfMetricEntry,</a>
<a name="ln398">   3, {8, 1, 1}},</a>
<a name="ln399">  {OSPFIFMETRICADDRESSLESSIF, INTEGER, RONLY, ospfIfMetricEntry,</a>
<a name="ln400">   3, {8, 1, 2}},</a>
<a name="ln401">  {OSPFIFMETRICTOS,           INTEGER, RONLY, ospfIfMetricEntry,</a>
<a name="ln402">   3, {8, 1, 3}},</a>
<a name="ln403">  {OSPFIFMETRICVALUE,         INTEGER, RWRITE, ospfIfMetricEntry,</a>
<a name="ln404">   3, {8, 1, 4}},</a>
<a name="ln405">  {OSPFIFMETRICSTATUS,        INTEGER, RWRITE, ospfIfMetricEntry,</a>
<a name="ln406">   3, {8, 1, 5}},</a>
<a name="ln407"> </a>
<a name="ln408">  /* OSPF virtual interface table. */</a>
<a name="ln409">  {OSPFVIRTIFAREAID,          IPADDRESS, RONLY, ospfVirtIfEntry,</a>
<a name="ln410">   3, {9, 1, 1}},</a>
<a name="ln411">  {OSPFVIRTIFNEIGHBOR,        IPADDRESS, RONLY, ospfVirtIfEntry,</a>
<a name="ln412">   3, {9, 1, 2}},</a>
<a name="ln413">  {OSPFVIRTIFTRANSITDELAY,    INTEGER, RWRITE, ospfVirtIfEntry,</a>
<a name="ln414">   3, {9, 1, 3}},</a>
<a name="ln415">  {OSPFVIRTIFRETRANSINTERVAL, INTEGER, RWRITE, ospfVirtIfEntry,</a>
<a name="ln416">   3, {9, 1, 4}},</a>
<a name="ln417">  {OSPFVIRTIFHELLOINTERVAL,   INTEGER, RWRITE, ospfVirtIfEntry,</a>
<a name="ln418">   3, {9, 1, 5}},</a>
<a name="ln419">  {OSPFVIRTIFRTRDEADINTERVAL, INTEGER, RWRITE, ospfVirtIfEntry,</a>
<a name="ln420">   3, {9, 1, 6}},</a>
<a name="ln421">  {OSPFVIRTIFSTATE,           INTEGER, RONLY, ospfVirtIfEntry,</a>
<a name="ln422">   3, {9, 1, 7}},</a>
<a name="ln423">  {OSPFVIRTIFEVENTS,          COUNTER, RONLY, ospfVirtIfEntry,</a>
<a name="ln424">   3, {9, 1, 8}},</a>
<a name="ln425">  {OSPFVIRTIFAUTHKEY,         STRING,  RWRITE, ospfVirtIfEntry,</a>
<a name="ln426">   3, {9, 1, 9}},</a>
<a name="ln427">  {OSPFVIRTIFSTATUS,          INTEGER, RWRITE, ospfVirtIfEntry,</a>
<a name="ln428">   3, {9, 1, 10}},</a>
<a name="ln429">  {OSPFVIRTIFAUTHTYPE,        INTEGER, RWRITE, ospfVirtIfEntry,</a>
<a name="ln430">   3, {9, 1, 11}},</a>
<a name="ln431"> </a>
<a name="ln432">  /* OSPF neighbor table. */</a>
<a name="ln433">  {OSPFNBRIPADDR,             IPADDRESS, RONLY, ospfNbrEntry,</a>
<a name="ln434">   3, {10, 1, 1}},</a>
<a name="ln435">  {OSPFNBRADDRESSLESSINDEX,   INTEGER, RONLY, ospfNbrEntry,</a>
<a name="ln436">   3, {10, 1, 2}},</a>
<a name="ln437">  {OSPFNBRRTRID,              IPADDRESS, RONLY, ospfNbrEntry,</a>
<a name="ln438">   3, {10, 1, 3}},</a>
<a name="ln439">  {OSPFNBROPTIONS,            INTEGER, RONLY, ospfNbrEntry,</a>
<a name="ln440">   3, {10, 1, 4}},</a>
<a name="ln441">  {OSPFNBRPRIORITY,           INTEGER, RWRITE, ospfNbrEntry,</a>
<a name="ln442">   3, {10, 1, 5}},</a>
<a name="ln443">  {OSPFNBRSTATE,              INTEGER, RONLY, ospfNbrEntry,</a>
<a name="ln444">   3, {10, 1, 6}},</a>
<a name="ln445">  {OSPFNBREVENTS,             COUNTER, RONLY, ospfNbrEntry,</a>
<a name="ln446">   3, {10, 1, 7}},</a>
<a name="ln447">  {OSPFNBRLSRETRANSQLEN,      GAUGE, RONLY, ospfNbrEntry,</a>
<a name="ln448">   3, {10, 1, 8}},</a>
<a name="ln449">  {OSPFNBMANBRSTATUS,         INTEGER, RWRITE, ospfNbrEntry,</a>
<a name="ln450">   3, {10, 1, 9}},</a>
<a name="ln451">  {OSPFNBMANBRPERMANENCE,     INTEGER, RONLY, ospfNbrEntry,</a>
<a name="ln452">   3, {10, 1, 10}},</a>
<a name="ln453">  {OSPFNBRHELLOSUPPRESSED,    INTEGER, RONLY, ospfNbrEntry,</a>
<a name="ln454">   3, {10, 1, 11}},</a>
<a name="ln455"> </a>
<a name="ln456">  /* OSPF virtual neighbor table. */</a>
<a name="ln457">  {OSPFVIRTNBRAREA,           IPADDRESS, RONLY, ospfVirtNbrEntry,</a>
<a name="ln458">   3, {11, 1, 1}},</a>
<a name="ln459">  {OSPFVIRTNBRRTRID,          IPADDRESS, RONLY, ospfVirtNbrEntry,</a>
<a name="ln460">   3, {11, 1, 2}},</a>
<a name="ln461">  {OSPFVIRTNBRIPADDR,         IPADDRESS, RONLY, ospfVirtNbrEntry,</a>
<a name="ln462">   3, {11, 1, 3}},</a>
<a name="ln463">  {OSPFVIRTNBROPTIONS,        INTEGER, RONLY, ospfVirtNbrEntry,</a>
<a name="ln464">   3, {11, 1, 4}},</a>
<a name="ln465">  {OSPFVIRTNBRSTATE,          INTEGER, RONLY, ospfVirtNbrEntry,</a>
<a name="ln466">   3, {11, 1, 5}},</a>
<a name="ln467">  {OSPFVIRTNBREVENTS,         COUNTER, RONLY, ospfVirtNbrEntry,</a>
<a name="ln468">   3, {11, 1, 6}},</a>
<a name="ln469">  {OSPFVIRTNBRLSRETRANSQLEN,  INTEGER, RONLY, ospfVirtNbrEntry,</a>
<a name="ln470">   3, {11, 1, 7}},</a>
<a name="ln471">  {OSPFVIRTNBRHELLOSUPPRESSED, INTEGER, RONLY, ospfVirtNbrEntry,</a>
<a name="ln472">   3, {11, 1, 8}},</a>
<a name="ln473"> </a>
<a name="ln474">  /* OSPF link state database, external. */</a>
<a name="ln475">  {OSPFEXTLSDBTYPE,           INTEGER, RONLY, ospfExtLsdbEntry,</a>
<a name="ln476">   3, {12, 1, 1}},</a>
<a name="ln477">  {OSPFEXTLSDBLSID,           IPADDRESS, RONLY, ospfExtLsdbEntry,</a>
<a name="ln478">   3, {12, 1, 2}},</a>
<a name="ln479">  {OSPFEXTLSDBROUTERID,       IPADDRESS, RONLY, ospfExtLsdbEntry,</a>
<a name="ln480">   3, {12, 1, 3}},</a>
<a name="ln481">  {OSPFEXTLSDBSEQUENCE,       INTEGER, RONLY, ospfExtLsdbEntry,</a>
<a name="ln482">   3, {12, 1, 4}},</a>
<a name="ln483">  {OSPFEXTLSDBAGE,            INTEGER, RONLY, ospfExtLsdbEntry,</a>
<a name="ln484">   3, {12, 1, 5}},</a>
<a name="ln485">  {OSPFEXTLSDBCHECKSUM,       INTEGER, RONLY, ospfExtLsdbEntry,</a>
<a name="ln486">   3, {12, 1, 6}},</a>
<a name="ln487">  {OSPFEXTLSDBADVERTISEMENT,  STRING,  RONLY, ospfExtLsdbEntry,</a>
<a name="ln488">   3, {12, 1, 7}},</a>
<a name="ln489"> </a>
<a name="ln490">  /* OSPF area aggregate table. */</a>
<a name="ln491">  {OSPFAREAAGGREGATEAREAID,   IPADDRESS, RONLY, ospfAreaAggregateEntry, </a>
<a name="ln492">   3, {14, 1, 1}},</a>
<a name="ln493">  {OSPFAREAAGGREGATELSDBTYPE, INTEGER, RONLY, ospfAreaAggregateEntry, </a>
<a name="ln494">   3, {14, 1, 2}},</a>
<a name="ln495">  {OSPFAREAAGGREGATENET,      IPADDRESS, RONLY, ospfAreaAggregateEntry, </a>
<a name="ln496">   3, {14, 1, 3}},</a>
<a name="ln497">  {OSPFAREAAGGREGATEMASK,     IPADDRESS, RONLY, ospfAreaAggregateEntry, </a>
<a name="ln498">   3, {14, 1, 4}},</a>
<a name="ln499">  {OSPFAREAAGGREGATESTATUS,   INTEGER, RWRITE, ospfAreaAggregateEntry,</a>
<a name="ln500">   3, {14, 1, 5}},</a>
<a name="ln501">  {OSPFAREAAGGREGATEEFFECT,   INTEGER, RWRITE, ospfAreaAggregateEntry,</a>
<a name="ln502">   3, {14, 1, 6}}</a>
<a name="ln503">};</a>
<a name="ln504"> </a>
<a name="ln505">/* The administrative status of OSPF.  When OSPF is enbled on at least</a>
<a name="ln506">   one interface return 1. */</a>
<a name="ln507">static int</a>
<a name="ln508">ospf_admin_stat (struct ospf *ospf)</a>
<a name="ln509">{</a>
<a name="ln510">  struct listnode *node;</a>
<a name="ln511">  struct ospf_interface *oi;</a>
<a name="ln512"> </a>
<a name="ln513">  if (ospf == NULL)</a>
<a name="ln514">    return 0;</a>
<a name="ln515"> </a>
<a name="ln516">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, node, oi))</a>
<a name="ln517">    if (oi &amp;&amp; oi-&gt;address)</a>
<a name="ln518">      return 1;</a>
<a name="ln519"> </a>
<a name="ln520">  return 0;</a>
<a name="ln521">}</a>
<a name="ln522"> </a>
<a name="ln523">static u_char *</a>
<a name="ln524">ospfGeneralGroup (struct variable *v, oid *name, size_t *length,</a>
<a name="ln525">		  int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln526">{</a>
<a name="ln527">  struct ospf *ospf;</a>
<a name="ln528"> </a>
<a name="ln529">  ospf = ospf_lookup ();</a>
<a name="ln530"> </a>
<a name="ln531">  /* Check whether the instance identifier is valid */</a>
<a name="ln532">  if (smux_header_generic (v, name, length, exact, var_len, write_method)</a>
<a name="ln533">      == MATCH_FAILED)</a>
<a name="ln534">    return NULL;</a>
<a name="ln535"> </a>
<a name="ln536">  /* Return the current value of the variable */</a>
<a name="ln537">  switch (v-&gt;magic) </a>
<a name="ln538">    {</a>
<a name="ln539">    case OSPFROUTERID:		/* 1 */</a>
<a name="ln540">      /* Router-ID of this OSPF instance. */</a>
<a name="ln541">      if (ospf)</a>
<a name="ln542">	return SNMP_IPADDRESS (ospf-&gt;router_id);</a>
<a name="ln543">      else</a>
<a name="ln544">	return SNMP_IPADDRESS (ospf_empty_addr);</a>
<a name="ln545">      break;</a>
<a name="ln546">    case OSPFADMINSTAT:		/* 2 */</a>
<a name="ln547">      /* The administrative status of OSPF in the router. */</a>
<a name="ln548">      if (ospf_admin_stat (ospf))</a>
<a name="ln549">	return SNMP_INTEGER (OSPF_STATUS_ENABLED);</a>
<a name="ln550">      else</a>
<a name="ln551">	return SNMP_INTEGER (OSPF_STATUS_DISABLED);</a>
<a name="ln552">      break;</a>
<a name="ln553">    case OSPFVERSIONNUMBER:	/* 3 */</a>
<a name="ln554">      /* OSPF version 2. */</a>
<a name="ln555">      return SNMP_INTEGER (OSPF_VERSION);</a>
<a name="ln556">      break;</a>
<a name="ln557">    case OSPFAREABDRRTRSTATUS:	/* 4 */</a>
<a name="ln558">      /* Area Border router status. */</a>
<a name="ln559">      if (ospf &amp;&amp; CHECK_FLAG (ospf-&gt;flags, OSPF_FLAG_ABR))</a>
<a name="ln560">	return SNMP_INTEGER (SNMP_TRUE);</a>
<a name="ln561">      else</a>
<a name="ln562">	return SNMP_INTEGER (SNMP_FALSE);</a>
<a name="ln563">      break;</a>
<a name="ln564">    case OSPFASBDRRTRSTATUS:	/* 5 */</a>
<a name="ln565">      /* AS Border router status. */</a>
<a name="ln566">      if (ospf &amp;&amp; CHECK_FLAG (ospf-&gt;flags, OSPF_FLAG_ASBR))</a>
<a name="ln567">	return SNMP_INTEGER (SNMP_TRUE);</a>
<a name="ln568">      else</a>
<a name="ln569">	return SNMP_INTEGER (SNMP_FALSE);</a>
<a name="ln570">      break;</a>
<a name="ln571">    case OSPFEXTERNLSACOUNT:	/* 6 */</a>
<a name="ln572">      /* External LSA counts. */</a>
<a name="ln573">      if (ospf)</a>
<a name="ln574">	return SNMP_INTEGER (ospf_lsdb_count_all (ospf-&gt;lsdb));</a>
<a name="ln575">      else</a>
<a name="ln576">	return SNMP_INTEGER (0);</a>
<a name="ln577">      break;</a>
<a name="ln578">    case OSPFEXTERNLSACKSUMSUM:	/* 7 */</a>
<a name="ln579">      /* External LSA checksum. */</a>
<a name="ln580">      return SNMP_INTEGER (0);</a>
<a name="ln581">      break;</a>
<a name="ln582">    case OSPFTOSSUPPORT:	/* 8 */</a>
<a name="ln583">      /* TOS is not supported. */</a>
<a name="ln584">      return SNMP_INTEGER (SNMP_FALSE);</a>
<a name="ln585">      break;</a>
<a name="ln586">    case OSPFORIGINATENEWLSAS:	/* 9 */</a>
<a name="ln587">      /* The number of new link-state advertisements. */</a>
<a name="ln588">      if (ospf)</a>
<a name="ln589">	return SNMP_INTEGER (ospf-&gt;lsa_originate_count);</a>
<a name="ln590">      else</a>
<a name="ln591">	return SNMP_INTEGER (0);</a>
<a name="ln592">      break;</a>
<a name="ln593">    case OSPFRXNEWLSAS:		/* 10 */</a>
<a name="ln594">      /* The number of link-state advertisements received determined</a>
<a name="ln595">         to be new instantiations. */</a>
<a name="ln596">      if (ospf)</a>
<a name="ln597">	return SNMP_INTEGER (ospf-&gt;rx_lsa_count);</a>
<a name="ln598">      else</a>
<a name="ln599">	return SNMP_INTEGER (0);</a>
<a name="ln600">      break;</a>
<a name="ln601">    case OSPFEXTLSDBLIMIT:	/* 11 */</a>
<a name="ln602">      /* There is no limit for the number of non-default</a>
<a name="ln603">         AS-external-LSAs. */</a>
<a name="ln604">      return SNMP_INTEGER (-1);</a>
<a name="ln605">      break;</a>
<a name="ln606">    case OSPFMULTICASTEXTENSIONS: /* 12 */</a>
<a name="ln607">      /* Multicast Extensions to OSPF is not supported. */</a>
<a name="ln608">      return SNMP_INTEGER (0);</a>
<a name="ln609">      break;</a>
<a name="ln610">    case OSPFEXITOVERFLOWINTERVAL: /* 13 */</a>
<a name="ln611">      /* Overflow is not supported. */</a>
<a name="ln612">      return SNMP_INTEGER (0);</a>
<a name="ln613">      break;</a>
<a name="ln614">    case OSPFDEMANDEXTENSIONS:	/* 14 */</a>
<a name="ln615">      /* Demand routing is not supported. */</a>
<a name="ln616">      return SNMP_INTEGER (SNMP_FALSE);</a>
<a name="ln617">      break;</a>
<a name="ln618">    default:</a>
<a name="ln619">      return NULL;</a>
<a name="ln620">    }</a>
<a name="ln621">  return NULL;</a>
<a name="ln622">}</a>
<a name="ln623"> </a>
<a name="ln624">static struct ospf_area *</a>
<a name="ln625">ospf_area_lookup_next (struct ospf *ospf, struct in_addr *area_id, int first)</a>
<a name="ln626">{</a>
<a name="ln627">  struct ospf_area *area;</a>
<a name="ln628">  struct listnode *node;</a>
<a name="ln629"> </a>
<a name="ln630">  if (ospf == NULL)</a>
<a name="ln631">    return NULL;</a>
<a name="ln632"> </a>
<a name="ln633">  if (first)</a>
<a name="ln634">    {</a>
<a name="ln635">      node = listhead (ospf-&gt;areas);</a>
<a name="ln636">      if (node)</a>
<a name="ln637">	{</a>
<a name="ln638">	  area = listgetdata (node);</a>
<a name="ln639">	  *area_id = area-&gt;area_id;</a>
<a name="ln640">	  return area;</a>
<a name="ln641">	}</a>
<a name="ln642">      return NULL;</a>
<a name="ln643">    }</a>
<a name="ln644">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln645">    {</a>
<a name="ln646">      if (ntohl (area-&gt;area_id.s_addr) &gt; ntohl (area_id-&gt;s_addr))</a>
<a name="ln647">	{</a>
<a name="ln648">	  *area_id = area-&gt;area_id;</a>
<a name="ln649">	  return area;</a>
<a name="ln650">	}</a>
<a name="ln651">    }</a>
<a name="ln652">  return NULL;</a>
<a name="ln653">}</a>
<a name="ln654"> </a>
<a name="ln655">static struct ospf_area *</a>
<a name="ln656">ospfAreaLookup (struct variable *v, oid name[], size_t *length,</a>
<a name="ln657">		struct in_addr *addr, int exact)</a>
<a name="ln658">{</a>
<a name="ln659">  struct ospf *ospf;</a>
<a name="ln660">  struct ospf_area *area;</a>
<a name="ln661">  int len;</a>
<a name="ln662"> </a>
<a name="ln663">  ospf = ospf_lookup ();</a>
<a name="ln664">  if (ospf == NULL)</a>
<a name="ln665">    return NULL;</a>
<a name="ln666"> </a>
<a name="ln667">  if (exact)</a>
<a name="ln668">    {</a>
<a name="ln669">      /* Length is insufficient to lookup OSPF area. */</a>
<a name="ln670">      if (*length - v-&gt;namelen != sizeof (struct in_addr))</a>
<a name="ln671">	return NULL;</a>
<a name="ln672"> </a>
<a name="ln673">      oid2in_addr (name + v-&gt;namelen, sizeof (struct in_addr), addr);</a>
<a name="ln674"> </a>
<a name="ln675">      area = ospf_area_lookup_by_area_id (ospf, *addr);</a>
<a name="ln676"> </a>
<a name="ln677">      return area;</a>
<a name="ln678">    }</a>
<a name="ln679">  else</a>
<a name="ln680">    {</a>
<a name="ln681">      len = *length - v-&gt;namelen;</a>
<a name="ln682">      if (len &gt; 4)</a>
<a name="ln683">	len = 4;</a>
<a name="ln684">      </a>
<a name="ln685">      oid2in_addr (name + v-&gt;namelen, len, addr);</a>
<a name="ln686"> </a>
<a name="ln687">      area = ospf_area_lookup_next (ospf, addr, len == 0 ? 1 : 0);</a>
<a name="ln688"> </a>
<a name="ln689">      if (area == NULL)</a>
<a name="ln690">	return NULL;</a>
<a name="ln691"> </a>
<a name="ln692">      oid_copy_addr (name + v-&gt;namelen, addr, sizeof (struct in_addr));</a>
<a name="ln693">      *length = sizeof (struct in_addr) + v-&gt;namelen;</a>
<a name="ln694"> </a>
<a name="ln695">      return area;</a>
<a name="ln696">    }</a>
<a name="ln697">  return NULL;</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">static u_char *</a>
<a name="ln701">ospfAreaEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln702">	       size_t *var_len, WriteMethod **write_method)</a>
<a name="ln703">{</a>
<a name="ln704">  struct ospf_area *area;</a>
<a name="ln705">  struct in_addr addr;</a>
<a name="ln706"> </a>
<a name="ln707">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln708">      == MATCH_FAILED)</a>
<a name="ln709">    return NULL;</a>
<a name="ln710"> </a>
<a name="ln711">  memset (&amp;addr, 0, sizeof (struct in_addr));</a>
<a name="ln712"> </a>
<a name="ln713">  area = ospfAreaLookup (v, name, length, &amp;addr, exact);</a>
<a name="ln714">  if (! area)</a>
<a name="ln715">    return NULL;</a>
<a name="ln716">  </a>
<a name="ln717">  /* Return the current value of the variable */</a>
<a name="ln718">  switch (v-&gt;magic) </a>
<a name="ln719">    {</a>
<a name="ln720">    case OSPFAREAID:		/* 1 */</a>
<a name="ln721">      return SNMP_IPADDRESS (area-&gt;area_id);</a>
<a name="ln722">      break;</a>
<a name="ln723">    case OSPFAUTHTYPE:		/* 2 */</a>
<a name="ln724">      return SNMP_INTEGER (area-&gt;auth_type);</a>
<a name="ln725">      break;</a>
<a name="ln726">    case OSPFIMPORTASEXTERN:	/* 3 */</a>
<a name="ln727">      return SNMP_INTEGER (area-&gt;external_routing + 1);</a>
<a name="ln728">      break;</a>
<a name="ln729">    case OSPFSPFRUNS:		/* 4 */</a>
<a name="ln730">      return SNMP_INTEGER (area-&gt;spf_calculation);</a>
<a name="ln731">      break;</a>
<a name="ln732">    case OSPFAREABDRRTRCOUNT:	/* 5 */</a>
<a name="ln733">      return SNMP_INTEGER (area-&gt;abr_count);</a>
<a name="ln734">      break;</a>
<a name="ln735">    case OSPFASBDRRTRCOUNT:	/* 6 */</a>
<a name="ln736">      return SNMP_INTEGER (area-&gt;asbr_count);</a>
<a name="ln737">      break;</a>
<a name="ln738">    case OSPFAREALSACOUNT:	/* 7 */</a>
<a name="ln739">      return SNMP_INTEGER (area-&gt;lsdb-&gt;total);</a>
<a name="ln740">      break;</a>
<a name="ln741">    case OSPFAREALSACKSUMSUM:	/* 8 */</a>
<a name="ln742">      return SNMP_INTEGER (0);</a>
<a name="ln743">      break;</a>
<a name="ln744">    case OSPFAREASUMMARY:	/* 9 */</a>
<a name="ln745">#define OSPF_noAreaSummary   1</a>
<a name="ln746">#define OSPF_sendAreaSummary 2</a>
<a name="ln747">      if (area-&gt;no_summary)</a>
<a name="ln748">	return SNMP_INTEGER (OSPF_noAreaSummary);</a>
<a name="ln749">      else</a>
<a name="ln750">	return SNMP_INTEGER (OSPF_sendAreaSummary);</a>
<a name="ln751">      break;</a>
<a name="ln752">    case OSPFAREASTATUS:	/* 10 */</a>
<a name="ln753">      return SNMP_INTEGER (SNMP_VALID);</a>
<a name="ln754">      break;</a>
<a name="ln755">    default:</a>
<a name="ln756">      return NULL;</a>
<a name="ln757">      break;</a>
<a name="ln758">    }</a>
<a name="ln759">  return NULL;</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">static struct ospf_area *</a>
<a name="ln763">ospf_stub_area_lookup_next (struct in_addr *area_id, int first)</a>
<a name="ln764">{</a>
<a name="ln765">  struct ospf_area *area;</a>
<a name="ln766">  struct listnode *node;</a>
<a name="ln767">  struct ospf *ospf;</a>
<a name="ln768"> </a>
<a name="ln769">  ospf = ospf_lookup ();</a>
<a name="ln770">  if (ospf == NULL)</a>
<a name="ln771">    return NULL;</a>
<a name="ln772"> </a>
<a name="ln773">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln774">    {</a>
<a name="ln775">      if (area-&gt;external_routing == OSPF_AREA_STUB)</a>
<a name="ln776">	{</a>
<a name="ln777">	  if (first)</a>
<a name="ln778">	    {</a>
<a name="ln779">	      *area_id = area-&gt;area_id;</a>
<a name="ln780">	      return area;</a>
<a name="ln781">	    }</a>
<a name="ln782">	  else if (ntohl (area-&gt;area_id.s_addr) &gt; ntohl (area_id-&gt;s_addr))</a>
<a name="ln783">	    {</a>
<a name="ln784">	      *area_id = area-&gt;area_id;</a>
<a name="ln785">	      return area;</a>
<a name="ln786">	    }</a>
<a name="ln787">	}</a>
<a name="ln788">    }</a>
<a name="ln789">  return NULL;</a>
<a name="ln790">}</a>
<a name="ln791"> </a>
<a name="ln792">static struct ospf_area *</a>
<a name="ln793">ospfStubAreaLookup (struct variable *v, oid name[], size_t *length,</a>
<a name="ln794">		    struct in_addr *addr, int exact)</a>
<a name="ln795">{</a>
<a name="ln796">  struct ospf *ospf;</a>
<a name="ln797">  struct ospf_area *area;</a>
<a name="ln798">  int len;</a>
<a name="ln799"> </a>
<a name="ln800">  ospf = ospf_lookup ();</a>
<a name="ln801">  if (ospf == NULL)</a>
<a name="ln802">    return NULL;</a>
<a name="ln803"> </a>
<a name="ln804">  /* Exact lookup. */</a>
<a name="ln805">  if (exact)</a>
<a name="ln806">    {</a>
<a name="ln807">      /* ospfStubAreaID + ospfStubTOS. */</a>
<a name="ln808">      if (*length != v-&gt;namelen + sizeof (struct in_addr) + 1)</a>
<a name="ln809">	return NULL;</a>
<a name="ln810"> </a>
<a name="ln811">      /* Check ospfStubTOS is zero. */</a>
<a name="ln812">      if (name[*length - 1] != 0)</a>
<a name="ln813">	return NULL;</a>
<a name="ln814"> </a>
<a name="ln815">      oid2in_addr (name + v-&gt;namelen, sizeof (struct in_addr), addr);</a>
<a name="ln816"> </a>
<a name="ln817">      area = ospf_area_lookup_by_area_id (ospf, *addr);</a>
<a name="ln818"> </a>
<a name="ln819">      if (area-&gt;external_routing == OSPF_AREA_STUB)</a>
<a name="ln820">	return area;</a>
<a name="ln821">      else</a>
<a name="ln822">	return NULL;</a>
<a name="ln823">    }</a>
<a name="ln824">  else</a>
<a name="ln825">    {</a>
<a name="ln826">      len = *length - v-&gt;namelen;</a>
<a name="ln827">      if (len &gt; 4)</a>
<a name="ln828">	len = 4;</a>
<a name="ln829">      </a>
<a name="ln830">      oid2in_addr (name + v-&gt;namelen, len, addr);</a>
<a name="ln831"> </a>
<a name="ln832">      area = ospf_stub_area_lookup_next (addr, len == 0 ? 1 : 0);</a>
<a name="ln833"> </a>
<a name="ln834">      if (area == NULL)</a>
<a name="ln835">	return NULL;</a>
<a name="ln836"> </a>
<a name="ln837">      oid_copy_addr (name + v-&gt;namelen, addr, sizeof (struct in_addr));</a>
<a name="ln838">      /* Set TOS 0. */</a>
<a name="ln839">      name[v-&gt;namelen + sizeof (struct in_addr)] = 0;</a>
<a name="ln840">      *length = v-&gt;namelen + sizeof (struct in_addr) + 1;</a>
<a name="ln841"> </a>
<a name="ln842">      return area;</a>
<a name="ln843">    }</a>
<a name="ln844">  return NULL;</a>
<a name="ln845">}</a>
<a name="ln846"> </a>
<a name="ln847">static u_char *</a>
<a name="ln848">ospfStubAreaEntry (struct variable *v, oid *name, size_t *length,</a>
<a name="ln849">		   int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln850">{</a>
<a name="ln851">  struct ospf_area *area;</a>
<a name="ln852">  struct in_addr addr;</a>
<a name="ln853"> </a>
<a name="ln854">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln855">      == MATCH_FAILED)</a>
<a name="ln856">    return NULL;</a>
<a name="ln857"> </a>
<a name="ln858">  memset (&amp;addr, 0, sizeof (struct in_addr));</a>
<a name="ln859"> </a>
<a name="ln860">  area = ospfStubAreaLookup (v, name, length, &amp;addr, exact);</a>
<a name="ln861">  if (! area)</a>
<a name="ln862">    return NULL;</a>
<a name="ln863"> </a>
<a name="ln864">  /* Return the current value of the variable */</a>
<a name="ln865">  switch (v-&gt;magic) </a>
<a name="ln866">    {</a>
<a name="ln867">    case OSPFSTUBAREAID:	/* 1 */</a>
<a name="ln868">      /* OSPF stub area id. */</a>
<a name="ln869">      return SNMP_IPADDRESS (area-&gt;area_id);</a>
<a name="ln870">      break;</a>
<a name="ln871">    case OSPFSTUBTOS:		/* 2 */</a>
<a name="ln872">      /* TOS value is not supported. */</a>
<a name="ln873">      return SNMP_INTEGER (0);</a>
<a name="ln874">      break;</a>
<a name="ln875">    case OSPFSTUBMETRIC:	/* 3 */</a>
<a name="ln876">      /* Default cost to stub area. */</a>
<a name="ln877">      return SNMP_INTEGER (area-&gt;default_cost);</a>
<a name="ln878">      break;</a>
<a name="ln879">    case OSPFSTUBSTATUS:	/* 4 */</a>
<a name="ln880">      /* Status of the stub area. */</a>
<a name="ln881">      return SNMP_INTEGER (SNMP_VALID);</a>
<a name="ln882">      break;</a>
<a name="ln883">    case OSPFSTUBMETRICTYPE:	/* 5 */</a>
<a name="ln884">      /* OSPF Metric type. */</a>
<a name="ln885">#define OSPF_ospfMetric     1</a>
<a name="ln886">#define OSPF_comparableCost 2</a>
<a name="ln887">#define OSPF_nonComparable  3</a>
<a name="ln888">      return SNMP_INTEGER (OSPF_ospfMetric);</a>
<a name="ln889">      break;</a>
<a name="ln890">    default:</a>
<a name="ln891">      return NULL;</a>
<a name="ln892">      break;</a>
<a name="ln893">    }</a>
<a name="ln894">  return NULL;</a>
<a name="ln895">}</a>
<a name="ln896"> </a>
<a name="ln897">static struct ospf_lsa *</a>
<a name="ln898">lsdb_lookup_next (struct ospf_area *area, u_char *type, int type_next,</a>
<a name="ln899">		  struct in_addr *ls_id, int ls_id_next,</a>
<a name="ln900">		  struct in_addr *router_id, int router_id_next)</a>
<a name="ln901">{</a>
<a name="ln902">  struct ospf_lsa *lsa;</a>
<a name="ln903">  int i;</a>
<a name="ln904"> </a>
<a name="ln905">  if (type_next)</a>
<a name="ln906">    i = OSPF_MIN_LSA;</a>
<a name="ln907">  else</a>
<a name="ln908">    i = *type;</a>
<a name="ln909"> </a>
<a name="ln910">  /* Sanity check, if LSA type unknwon</a>
<a name="ln911">     merley skip any LSA */</a>
<a name="ln912">  if ((i &lt; OSPF_MIN_LSA) || (i &gt;= OSPF_MAX_LSA))</a>
<a name="ln913">    {</a>
<a name="ln914">      zlog_debug(&quot;Strange request with LSA type %d\n&quot;, i);</a>
<a name="ln915">      return NULL;</a>
<a name="ln916">    }</a>
<a name="ln917"> </a>
<a name="ln918">  for (; i &lt; OSPF_MAX_LSA; i++)</a>
<a name="ln919">    {</a>
<a name="ln920">      *type = i;</a>
<a name="ln921"> </a>
<a name="ln922">      lsa = ospf_lsdb_lookup_by_id_next (area-&gt;lsdb, *type, *ls_id, *router_id,</a>
<a name="ln923">					ls_id_next);</a>
<a name="ln924">      if (lsa)</a>
<a name="ln925">	return lsa;</a>
<a name="ln926"> </a>
<a name="ln927">      ls_id_next = 1;</a>
<a name="ln928">    }</a>
<a name="ln929">  return NULL;</a>
<a name="ln930">}</a>
<a name="ln931"> </a>
<a name="ln932">static struct ospf_lsa *</a>
<a name="ln933">ospfLsdbLookup (struct variable *v, oid *name, size_t *length,</a>
<a name="ln934">		struct in_addr *area_id, u_char *type,</a>
<a name="ln935">		struct in_addr *ls_id, struct in_addr *router_id, int exact)</a>
<a name="ln936">{</a>
<a name="ln937">  struct ospf *ospf;</a>
<a name="ln938">  struct ospf_area *area;</a>
<a name="ln939">  struct ospf_lsa *lsa;</a>
<a name="ln940">  int len;</a>
<a name="ln941">  int type_next;</a>
<a name="ln942">  int ls_id_next;</a>
<a name="ln943">  int router_id_next;</a>
<a name="ln944">  oid *offset;</a>
<a name="ln945">  int offsetlen;</a>
<a name="ln946"> </a>
<a name="ln947">  ospf = ospf_lookup ();</a>
<a name="ln948"> </a>
<a name="ln949">#define OSPF_LSDB_ENTRY_OFFSET \</a>
<a name="ln950">          (IN_ADDR_SIZE + 1 + IN_ADDR_SIZE + IN_ADDR_SIZE)</a>
<a name="ln951"> </a>
<a name="ln952">  if (exact)</a>
<a name="ln953">    {</a>
<a name="ln954">      /* Area ID + Type + LS ID + Router ID. */</a>
<a name="ln955">      if (*length - v-&gt;namelen != OSPF_LSDB_ENTRY_OFFSET)</a>
<a name="ln956">	return NULL;</a>
<a name="ln957">      </a>
<a name="ln958">      /* Set OID offset for Area ID. */</a>
<a name="ln959">      offset = name + v-&gt;namelen;</a>
<a name="ln960"> </a>
<a name="ln961">      /* Lookup area first. */</a>
<a name="ln962">      oid2in_addr (offset, IN_ADDR_SIZE, area_id);</a>
<a name="ln963">      area = ospf_area_lookup_by_area_id (ospf, *area_id);</a>
<a name="ln964">      if (! area)</a>
<a name="ln965">	return NULL;</a>
<a name="ln966">      offset += IN_ADDR_SIZE;</a>
<a name="ln967"> </a>
<a name="ln968">      /* Type. */</a>
<a name="ln969">      *type = *offset;</a>
<a name="ln970">      offset++;</a>
<a name="ln971"> </a>
<a name="ln972">      /* LS ID. */</a>
<a name="ln973">      oid2in_addr (offset, IN_ADDR_SIZE, ls_id);</a>
<a name="ln974">      offset += IN_ADDR_SIZE;</a>
<a name="ln975"> </a>
<a name="ln976">      /* Router ID. */</a>
<a name="ln977">      oid2in_addr (offset, IN_ADDR_SIZE, router_id);</a>
<a name="ln978"> </a>
<a name="ln979">      /* Lookup LSDB. */</a>
<a name="ln980">      return ospf_lsdb_lookup_by_id (area-&gt;lsdb, *type, *ls_id, *router_id);</a>
<a name="ln981">    }</a>
<a name="ln982">  else</a>
<a name="ln983">    {</a>
<a name="ln984">      /* Get variable length. */</a>
<a name="ln985">      offset = name + v-&gt;namelen;</a>
<a name="ln986">      offsetlen = *length - v-&gt;namelen;</a>
<a name="ln987">      len = offsetlen;</a>
<a name="ln988"> </a>
<a name="ln989">      if (len &gt; (int)IN_ADDR_SIZE)</a>
<a name="ln990">	len = IN_ADDR_SIZE;</a>
<a name="ln991"> </a>
<a name="ln992">      oid2in_addr (offset, len, area_id);</a>
<a name="ln993"> </a>
<a name="ln994">      /* First we search area. */</a>
<a name="ln995">      if (len == IN_ADDR_SIZE)</a>
<a name="ln996">	area = ospf_area_lookup_by_area_id (ospf, *area_id);</a>
<a name="ln997">      else</a>
<a name="ln998">	area = ospf_area_lookup_next (ospf, area_id, 1);</a>
<a name="ln999"> </a>
<a name="ln1000">      if (area == NULL)</a>
<a name="ln1001">	return NULL;</a>
<a name="ln1002"> </a>
<a name="ln1003">      do </a>
<a name="ln1004">	{</a>
<a name="ln1005">	  /* Next we lookup type. */</a>
<a name="ln1006">	  offset += len;</a>
<a name="ln1007">	  offsetlen -= len;</a>
<a name="ln1008">	  len = offsetlen;</a>
<a name="ln1009"> </a>
<a name="ln1010">	  if (len &lt;= 0)</a>
<a name="ln1011">	    type_next = 1;</a>
<a name="ln1012">	  else</a>
<a name="ln1013">	    {</a>
<a name="ln1014">	      len = 1;</a>
<a name="ln1015">	      type_next = 0;</a>
<a name="ln1016">	      *type = *offset;</a>
<a name="ln1017">	    }</a>
<a name="ln1018">	</a>
<a name="ln1019">	  /* LS ID. */</a>
<a name="ln1020">	  offset++;</a>
<a name="ln1021">	  offsetlen--;</a>
<a name="ln1022">	  len = offsetlen;</a>
<a name="ln1023"> </a>
<a name="ln1024">	  if (len &lt;= 0)</a>
<a name="ln1025">	    ls_id_next = 1;</a>
<a name="ln1026">	  else</a>
<a name="ln1027">	    {</a>
<a name="ln1028">	      ls_id_next = 0;</a>
<a name="ln1029">	      if (len &gt; (int)IN_ADDR_SIZE)</a>
<a name="ln1030">		len = IN_ADDR_SIZE;</a>
<a name="ln1031"> </a>
<a name="ln1032">	      oid2in_addr (offset, len, ls_id);</a>
<a name="ln1033">	    }</a>
<a name="ln1034"> </a>
<a name="ln1035">	  /* Router ID. */</a>
<a name="ln1036">	  offset += IN_ADDR_SIZE;</a>
<a name="ln1037">	  offsetlen -= IN_ADDR_SIZE;</a>
<a name="ln1038">	  len = offsetlen;</a>
<a name="ln1039"> </a>
<a name="ln1040">	  if (len &lt;= 0)</a>
<a name="ln1041">	    router_id_next = 1;</a>
<a name="ln1042">	  else</a>
<a name="ln1043">	    {</a>
<a name="ln1044">	      router_id_next = 0;</a>
<a name="ln1045">	      if (len &gt; (int)IN_ADDR_SIZE)</a>
<a name="ln1046">		len = IN_ADDR_SIZE;</a>
<a name="ln1047"> </a>
<a name="ln1048">	      oid2in_addr (offset, len, router_id);</a>
<a name="ln1049">	    }</a>
<a name="ln1050"> </a>
<a name="ln1051">	  lsa = lsdb_lookup_next (area, type, type_next, ls_id, ls_id_next,</a>
<a name="ln1052">				  router_id, router_id_next);</a>
<a name="ln1053"> </a>
<a name="ln1054">	  if (lsa)</a>
<a name="ln1055">	    {</a>
<a name="ln1056">	      /* Fill in length. */</a>
<a name="ln1057">	      *length = v-&gt;namelen + OSPF_LSDB_ENTRY_OFFSET;</a>
<a name="ln1058"> </a>
<a name="ln1059">	      /* Fill in value. */</a>
<a name="ln1060">	      offset = name + v-&gt;namelen;</a>
<a name="ln1061">	      oid_copy_addr (offset, area_id, IN_ADDR_SIZE);</a>
<a name="ln1062">	      offset += IN_ADDR_SIZE;</a>
<a name="ln1063">	      *offset = lsa-&gt;data-&gt;type;</a>
<a name="ln1064">	      offset++;</a>
<a name="ln1065">	      oid_copy_addr (offset, &amp;lsa-&gt;data-&gt;id, IN_ADDR_SIZE);</a>
<a name="ln1066">	      offset += IN_ADDR_SIZE;</a>
<a name="ln1067">	      oid_copy_addr (offset, &amp;lsa-&gt;data-&gt;adv_router, IN_ADDR_SIZE);</a>
<a name="ln1068">	    </a>
<a name="ln1069">	      return lsa;</a>
<a name="ln1070">	    }</a>
<a name="ln1071">	}</a>
<a name="ln1072">      while ((area = ospf_area_lookup_next (ospf, area_id, 0)) != NULL);</a>
<a name="ln1073">    }</a>
<a name="ln1074">  return NULL;</a>
<a name="ln1075">}</a>
<a name="ln1076"> </a>
<a name="ln1077">static u_char *</a>
<a name="ln1078">ospfLsdbEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln1079">	       size_t *var_len, WriteMethod **write_method)</a>
<a name="ln1080">{</a>
<a name="ln1081">  struct ospf_lsa *lsa;</a>
<a name="ln1082">  struct lsa_header *lsah;</a>
<a name="ln1083">  struct in_addr area_id;</a>
<a name="ln1084">  u_char type;</a>
<a name="ln1085">  struct in_addr ls_id;</a>
<a name="ln1086">  struct in_addr router_id;</a>
<a name="ln1087">  struct ospf *ospf;</a>
<a name="ln1088"> </a>
<a name="ln1089">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln1090">      == MATCH_FAILED)</a>
<a name="ln1091">    return NULL;</a>
<a name="ln1092"> </a>
<a name="ln1093">  /* INDEX { ospfLsdbAreaId, ospfLsdbType,</a>
<a name="ln1094">     ospfLsdbLsid, ospfLsdbRouterId } */</a>
<a name="ln1095"> </a>
<a name="ln1096">  memset (&amp;area_id, 0, sizeof (struct in_addr));</a>
<a name="ln1097">  type = 0;</a>
<a name="ln1098">  memset (&amp;ls_id, 0, sizeof (struct in_addr));</a>
<a name="ln1099">  memset (&amp;router_id, 0, sizeof (struct in_addr));</a>
<a name="ln1100"> </a>
<a name="ln1101">  /* Check OSPF instance. */</a>
<a name="ln1102">  ospf = ospf_lookup ();</a>
<a name="ln1103">  if (ospf == NULL)</a>
<a name="ln1104">    return NULL;</a>
<a name="ln1105"> </a>
<a name="ln1106">  lsa = ospfLsdbLookup (v, name, length, &amp;area_id, &amp;type, &amp;ls_id, &amp;router_id,</a>
<a name="ln1107">			exact);</a>
<a name="ln1108">  if (! lsa)</a>
<a name="ln1109">    return NULL;</a>
<a name="ln1110"> </a>
<a name="ln1111">  lsah = lsa-&gt;data;</a>
<a name="ln1112"> </a>
<a name="ln1113">  /* Return the current value of the variable */</a>
<a name="ln1114">  switch (v-&gt;magic) </a>
<a name="ln1115">    {</a>
<a name="ln1116">    case OSPFLSDBAREAID:	/* 1 */</a>
<a name="ln1117">      return SNMP_IPADDRESS (lsa-&gt;area-&gt;area_id);</a>
<a name="ln1118">      break;</a>
<a name="ln1119">    case OSPFLSDBTYPE:		/* 2 */</a>
<a name="ln1120">      return SNMP_INTEGER (lsah-&gt;type);</a>
<a name="ln1121">      break;</a>
<a name="ln1122">    case OSPFLSDBLSID:		/* 3 */</a>
<a name="ln1123">      return SNMP_IPADDRESS (lsah-&gt;id);</a>
<a name="ln1124">      break;</a>
<a name="ln1125">    case OSPFLSDBROUTERID:	/* 4 */</a>
<a name="ln1126">      return SNMP_IPADDRESS (lsah-&gt;adv_router);</a>
<a name="ln1127">      break;</a>
<a name="ln1128">    case OSPFLSDBSEQUENCE:	/* 5 */</a>
<a name="ln1129">      return SNMP_INTEGER (lsah-&gt;ls_seqnum);</a>
<a name="ln1130">      break;</a>
<a name="ln1131">    case OSPFLSDBAGE:		/* 6 */</a>
<a name="ln1132">      return SNMP_INTEGER (lsah-&gt;ls_age);</a>
<a name="ln1133">      break;</a>
<a name="ln1134">    case OSPFLSDBCHECKSUM:	/* 7 */</a>
<a name="ln1135">      return SNMP_INTEGER (lsah-&gt;checksum);</a>
<a name="ln1136">      break;</a>
<a name="ln1137">    case OSPFLSDBADVERTISEMENT:	/* 8 */</a>
<a name="ln1138">      *var_len = ntohs (lsah-&gt;length);</a>
<a name="ln1139">      return (u_char *) lsah;</a>
<a name="ln1140">      break;</a>
<a name="ln1141">    default:</a>
<a name="ln1142">      return NULL;</a>
<a name="ln1143">      break;</a>
<a name="ln1144">    }</a>
<a name="ln1145">  return NULL;</a>
<a name="ln1146">}</a>
<a name="ln1147"> </a>
<a name="ln1148">static struct ospf_area_range *</a>
<a name="ln1149">ospfAreaRangeLookup (struct variable *v, oid *name, size_t *length,</a>
<a name="ln1150">		     struct in_addr *area_id, struct in_addr *range_net,</a>
<a name="ln1151">		     int exact)</a>
<a name="ln1152">{</a>
<a name="ln1153">  oid *offset;</a>
<a name="ln1154">  int offsetlen;</a>
<a name="ln1155">  int len;</a>
<a name="ln1156">  struct ospf *ospf;</a>
<a name="ln1157">  struct ospf_area *area;</a>
<a name="ln1158">  struct ospf_area_range *range;</a>
<a name="ln1159">  struct prefix_ipv4 p;</a>
<a name="ln1160">  p.family = AF_INET;</a>
<a name="ln1161">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln1162"> </a>
<a name="ln1163">  ospf = ospf_lookup ();</a>
<a name="ln1164"> </a>
<a name="ln1165">  if (exact) </a>
<a name="ln1166">    {</a>
<a name="ln1167">      /* Area ID + Range Network. */</a>
<a name="ln1168">      if (v-&gt;namelen + IN_ADDR_SIZE + IN_ADDR_SIZE != *length)</a>
<a name="ln1169">	return NULL;</a>
<a name="ln1170"> </a>
<a name="ln1171">      /* Set OID offset for Area ID. */</a>
<a name="ln1172">      offset = name + v-&gt;namelen;</a>
<a name="ln1173"> </a>
<a name="ln1174">      /* Lookup area first. */</a>
<a name="ln1175">      oid2in_addr (offset, IN_ADDR_SIZE, area_id);</a>
<a name="ln1176"> </a>
<a name="ln1177">      area = ospf_area_lookup_by_area_id (ospf, *area_id);</a>
<a name="ln1178">      if (! area)</a>
<a name="ln1179">	return NULL;</a>
<a name="ln1180"> </a>
<a name="ln1181">      offset += IN_ADDR_SIZE;</a>
<a name="ln1182"> </a>
<a name="ln1183">      /* Lookup area range. */</a>
<a name="ln1184">      oid2in_addr (offset, IN_ADDR_SIZE, range_net);</a>
<a name="ln1185">      p.prefix = *range_net;</a>
<a name="ln1186"> </a>
<a name="ln1187">      return ospf_area_range_lookup (area, &amp;p);</a>
<a name="ln1188">    }</a>
<a name="ln1189">  else</a>
<a name="ln1190">    {</a>
<a name="ln1191">      /* Set OID offset for Area ID. */</a>
<a name="ln1192">      offset = name + v-&gt;namelen;</a>
<a name="ln1193">      offsetlen = *length - v-&gt;namelen;</a>
<a name="ln1194"> </a>
<a name="ln1195">      len = offsetlen;</a>
<a name="ln1196">      if (len &gt; (int)IN_ADDR_SIZE)</a>
<a name="ln1197">	len = IN_ADDR_SIZE;</a>
<a name="ln1198"> </a>
<a name="ln1199">      oid2in_addr (offset, len, area_id);</a>
<a name="ln1200"> </a>
<a name="ln1201">      /* First we search area. */</a>
<a name="ln1202">      if (len == IN_ADDR_SIZE)</a>
<a name="ln1203">	area = ospf_area_lookup_by_area_id (ospf,*area_id);</a>
<a name="ln1204">      else</a>
<a name="ln1205">	area = ospf_area_lookup_next (ospf, area_id, len == 0 ? 1 : 0);</a>
<a name="ln1206"> </a>
<a name="ln1207">      if (area == NULL)</a>
<a name="ln1208">	return NULL;</a>
<a name="ln1209"> </a>
<a name="ln1210">      do </a>
<a name="ln1211">	{</a>
<a name="ln1212">	  offset += IN_ADDR_SIZE;</a>
<a name="ln1213">	  offsetlen -= IN_ADDR_SIZE;</a>
<a name="ln1214">	  len = offsetlen;</a>
<a name="ln1215"> </a>
<a name="ln1216">	  if (len &lt; 0)</a>
<a name="ln1217">	    len = 0;</a>
<a name="ln1218">	  if (len &gt; (int)IN_ADDR_SIZE)</a>
<a name="ln1219">	    len = IN_ADDR_SIZE;</a>
<a name="ln1220"> </a>
<a name="ln1221">	  oid2in_addr (offset, len, range_net);</a>
<a name="ln1222"> </a>
<a name="ln1223">	  range = ospf_area_range_lookup_next (area, range_net,</a>
<a name="ln1224">					       len == 0 ? 1 : 0);</a>
<a name="ln1225"> </a>
<a name="ln1226">	  if (range)</a>
<a name="ln1227">	    {</a>
<a name="ln1228">	      /* Fill in length. */</a>
<a name="ln1229">	      *length = v-&gt;namelen + IN_ADDR_SIZE + IN_ADDR_SIZE;</a>
<a name="ln1230"> </a>
<a name="ln1231">	      /* Fill in value. */</a>
<a name="ln1232">	      offset = name + v-&gt;namelen;</a>
<a name="ln1233">	      oid_copy_addr (offset, area_id, IN_ADDR_SIZE);</a>
<a name="ln1234">	      offset += IN_ADDR_SIZE;</a>
<a name="ln1235">	      oid_copy_addr (offset, range_net, IN_ADDR_SIZE);</a>
<a name="ln1236"> </a>
<a name="ln1237">	      return range;</a>
<a name="ln1238">	    }</a>
<a name="ln1239">	}</a>
<a name="ln1240">      while ((area = ospf_area_lookup_next (ospf, area_id, 0)) != NULL);</a>
<a name="ln1241">    }</a>
<a name="ln1242">  return NULL;</a>
<a name="ln1243">}</a>
<a name="ln1244"> </a>
<a name="ln1245">static u_char *</a>
<a name="ln1246">ospfAreaRangeEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln1247">		    size_t *var_len, WriteMethod **write_method)</a>
<a name="ln1248">{</a>
<a name="ln1249">  struct ospf_area_range *range;</a>
<a name="ln1250">  struct in_addr area_id;</a>
<a name="ln1251">  struct in_addr range_net;</a>
<a name="ln1252">  struct in_addr mask;</a>
<a name="ln1253">  struct ospf *ospf;</a>
<a name="ln1254">  </a>
<a name="ln1255">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln1256">      == MATCH_FAILED)</a>
<a name="ln1257">    return NULL;</a>
<a name="ln1258"> </a>
<a name="ln1259">  /* Check OSPF instance. */</a>
<a name="ln1260">  ospf = ospf_lookup ();</a>
<a name="ln1261">  if (ospf == NULL)</a>
<a name="ln1262">    return NULL;</a>
<a name="ln1263"> </a>
<a name="ln1264">  memset (&amp;area_id, 0, IN_ADDR_SIZE);</a>
<a name="ln1265">  memset (&amp;range_net, 0, IN_ADDR_SIZE);</a>
<a name="ln1266"> </a>
<a name="ln1267">  range = ospfAreaRangeLookup (v, name, length, &amp;area_id, &amp;range_net, exact);</a>
<a name="ln1268">  if (! range)</a>
<a name="ln1269">    return NULL;</a>
<a name="ln1270"> </a>
<a name="ln1271">  /* Convert prefixlen to network mask format. */</a>
<a name="ln1272">  masklen2ip (range-&gt;subst_masklen, &amp;mask);</a>
<a name="ln1273"> </a>
<a name="ln1274">  /* Return the current value of the variable */</a>
<a name="ln1275">  switch (v-&gt;magic) </a>
<a name="ln1276">    {</a>
<a name="ln1277">    case OSPFAREARANGEAREAID:	/* 1 */</a>
<a name="ln1278">      return SNMP_IPADDRESS (area_id);</a>
<a name="ln1279">      break;</a>
<a name="ln1280">    case OSPFAREARANGENET:	/* 2 */</a>
<a name="ln1281">      return SNMP_IPADDRESS (range_net);</a>
<a name="ln1282">      break;</a>
<a name="ln1283">    case OSPFAREARANGEMASK:	/* 3 */</a>
<a name="ln1284">      return SNMP_IPADDRESS (mask);</a>
<a name="ln1285">      break;</a>
<a name="ln1286">    case OSPFAREARANGESTATUS:	/* 4 */</a>
<a name="ln1287">      return SNMP_INTEGER (SNMP_VALID);</a>
<a name="ln1288">      break;</a>
<a name="ln1289">    case OSPFAREARANGEEFFECT:	/* 5 */</a>
<a name="ln1290">#define OSPF_advertiseMatching      1</a>
<a name="ln1291">#define OSPF_doNotAdvertiseMatching 2</a>
<a name="ln1292">      return SNMP_INTEGER (OSPF_advertiseMatching);</a>
<a name="ln1293">      break;</a>
<a name="ln1294">    default:</a>
<a name="ln1295">      return NULL;</a>
<a name="ln1296">      break;</a>
<a name="ln1297">    }</a>
<a name="ln1298">  return NULL;</a>
<a name="ln1299">}</a>
<a name="ln1300"> </a>
<a name="ln1301">static struct ospf_nbr_nbma *</a>
<a name="ln1302">ospfHostLookup (struct variable *v, oid *name, size_t *length,</a>
<a name="ln1303">		struct in_addr *addr, int exact)</a>
<a name="ln1304">{</a>
<a name="ln1305">  int len;</a>
<a name="ln1306">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1307">  struct ospf *ospf;</a>
<a name="ln1308"> </a>
<a name="ln1309">  ospf = ospf_lookup ();</a>
<a name="ln1310">  if (ospf == NULL)</a>
<a name="ln1311">    return NULL;</a>
<a name="ln1312"> </a>
<a name="ln1313">  if (exact)</a>
<a name="ln1314">    {</a>
<a name="ln1315">      /* INDEX { ospfHostIpAddress, ospfHostTOS } */</a>
<a name="ln1316">      if (*length != v-&gt;namelen + IN_ADDR_SIZE + 1)</a>
<a name="ln1317">	return NULL;</a>
<a name="ln1318"> </a>
<a name="ln1319">      /* Check ospfHostTOS. */</a>
<a name="ln1320">      if (name[*length - 1] != 0)</a>
<a name="ln1321">	return NULL;</a>
<a name="ln1322"> </a>
<a name="ln1323">      oid2in_addr (name + v-&gt;namelen, IN_ADDR_SIZE, addr);</a>
<a name="ln1324"> </a>
<a name="ln1325">      nbr_nbma = ospf_nbr_nbma_lookup (ospf, *addr);</a>
<a name="ln1326"> </a>
<a name="ln1327">      return nbr_nbma;</a>
<a name="ln1328">    }</a>
<a name="ln1329">  else</a>
<a name="ln1330">    {</a>
<a name="ln1331">      len = *length - v-&gt;namelen;</a>
<a name="ln1332">      if (len &gt; 4)</a>
<a name="ln1333">	len = 4;</a>
<a name="ln1334">      </a>
<a name="ln1335">      oid2in_addr (name + v-&gt;namelen, len, addr);</a>
<a name="ln1336"> </a>
<a name="ln1337">      nbr_nbma = ospf_nbr_nbma_lookup_next (ospf, addr, len == 0 ? 1 : 0);</a>
<a name="ln1338"> </a>
<a name="ln1339">      if (nbr_nbma == NULL)</a>
<a name="ln1340">	return NULL;</a>
<a name="ln1341"> </a>
<a name="ln1342">      oid_copy_addr (name + v-&gt;namelen, addr, IN_ADDR_SIZE);</a>
<a name="ln1343"> </a>
<a name="ln1344">      /* Set TOS 0. */</a>
<a name="ln1345">      name[v-&gt;namelen + IN_ADDR_SIZE] = 0;</a>
<a name="ln1346"> </a>
<a name="ln1347">      *length = v-&gt;namelen + IN_ADDR_SIZE + 1;</a>
<a name="ln1348"> </a>
<a name="ln1349">      return nbr_nbma;</a>
<a name="ln1350">    }</a>
<a name="ln1351">  return NULL;</a>
<a name="ln1352">}</a>
<a name="ln1353"> </a>
<a name="ln1354">static u_char *</a>
<a name="ln1355">ospfHostEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln1356">	       size_t *var_len, WriteMethod **write_method)</a>
<a name="ln1357">{</a>
<a name="ln1358">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln1359">  struct ospf_interface *oi;</a>
<a name="ln1360">  struct in_addr addr;</a>
<a name="ln1361">  struct ospf *ospf;</a>
<a name="ln1362"> </a>
<a name="ln1363">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln1364">      == MATCH_FAILED)</a>
<a name="ln1365">    return NULL;</a>
<a name="ln1366"> </a>
<a name="ln1367">  /* Check OSPF instance. */</a>
<a name="ln1368">  ospf = ospf_lookup ();</a>
<a name="ln1369">  if (ospf == NULL)</a>
<a name="ln1370">    return NULL;</a>
<a name="ln1371"> </a>
<a name="ln1372">  memset (&amp;addr, 0, sizeof (struct in_addr));</a>
<a name="ln1373"> </a>
<a name="ln1374">  nbr_nbma = ospfHostLookup (v, name, length, &amp;addr, exact);</a>
<a name="ln1375">  if (nbr_nbma == NULL)</a>
<a name="ln1376">    return NULL;</a>
<a name="ln1377"> </a>
<a name="ln1378">  oi = nbr_nbma-&gt;oi;</a>
<a name="ln1379"> </a>
<a name="ln1380">  /* Return the current value of the variable */</a>
<a name="ln1381">  switch (v-&gt;magic) </a>
<a name="ln1382">    {</a>
<a name="ln1383">    case OSPFHOSTIPADDRESS:	/* 1 */</a>
<a name="ln1384">      return SNMP_IPADDRESS (nbr_nbma-&gt;addr);</a>
<a name="ln1385">      break;</a>
<a name="ln1386">    case OSPFHOSTTOS:		/* 2 */</a>
<a name="ln1387">      return SNMP_INTEGER (0);</a>
<a name="ln1388">      break;</a>
<a name="ln1389">    case OSPFHOSTMETRIC:	/* 3 */</a>
<a name="ln1390">      if (oi)</a>
<a name="ln1391">	return SNMP_INTEGER (oi-&gt;output_cost);</a>
<a name="ln1392">      else</a>
<a name="ln1393">	return SNMP_INTEGER (1);</a>
<a name="ln1394">      break;</a>
<a name="ln1395">    case OSPFHOSTSTATUS:	/* 4 */</a>
<a name="ln1396">      return SNMP_INTEGER (SNMP_VALID);</a>
<a name="ln1397">      break;</a>
<a name="ln1398">    case OSPFHOSTAREAID:	/* 5 */</a>
<a name="ln1399">      if (oi &amp;&amp; oi-&gt;area)</a>
<a name="ln1400">	return SNMP_IPADDRESS (oi-&gt;area-&gt;area_id);</a>
<a name="ln1401">      else</a>
<a name="ln1402">	return SNMP_IPADDRESS (ospf_empty_addr);</a>
<a name="ln1403">      break;</a>
<a name="ln1404">    default:</a>
<a name="ln1405">      return NULL;</a>
<a name="ln1406">      break;</a>
<a name="ln1407">    }</a>
<a name="ln1408">  return NULL;</a>
<a name="ln1409">}</a>
<a name="ln1410"> </a>
<a name="ln1411">struct list *ospf_snmp_iflist;</a>
<a name="ln1412"> </a>
<a name="ln1413">struct ospf_snmp_if</a>
<a name="ln1414">{</a>
<a name="ln1415">  struct in_addr addr;</a>
<a name="ln1416">  ifindex_t ifindex;</a>
<a name="ln1417">  struct interface *ifp;</a>
<a name="ln1418">};</a>
<a name="ln1419"> </a>
<a name="ln1420">static struct ospf_snmp_if *</a>
<a name="ln1421">ospf_snmp_if_new (void)</a>
<a name="ln1422">{</a>
<a name="ln1423">  return XCALLOC (MTYPE_TMP, sizeof (struct ospf_snmp_if));</a>
<a name="ln1424">}</a>
<a name="ln1425"> </a>
<a name="ln1426">static void</a>
<a name="ln1427">ospf_snmp_if_free (struct ospf_snmp_if *osif)</a>
<a name="ln1428">{</a>
<a name="ln1429">  XFREE (MTYPE_TMP, osif);</a>
<a name="ln1430">}</a>
<a name="ln1431"> </a>
<a name="ln1432">void</a>
<a name="ln1433">ospf_snmp_if_delete (struct interface *ifp)</a>
<a name="ln1434">{</a>
<a name="ln1435">  struct listnode *node, *nnode;</a>
<a name="ln1436">  struct ospf_snmp_if *osif;</a>
<a name="ln1437"> </a>
<a name="ln1438">  for (ALL_LIST_ELEMENTS (ospf_snmp_iflist, node, nnode, osif))</a>
<a name="ln1439">    {</a>
<a name="ln1440">      if (osif-&gt;ifp == ifp)</a>
<a name="ln1441">	{</a>
<a name="ln1442">	  list_delete_node (ospf_snmp_iflist, node);</a>
<a name="ln1443">	  ospf_snmp_if_free (osif);</a>
<a name="ln1444">	  return;</a>
<a name="ln1445">	}</a>
<a name="ln1446">    }</a>
<a name="ln1447">}</a>
<a name="ln1448"> </a>
<a name="ln1449">void</a>
<a name="ln1450">ospf_snmp_if_update (struct interface *ifp)</a>
<a name="ln1451">{</a>
<a name="ln1452">  struct listnode *node;</a>
<a name="ln1453">  struct listnode *pn;</a>
<a name="ln1454">  struct connected *ifc;</a>
<a name="ln1455">  struct prefix *p;</a>
<a name="ln1456">  struct ospf_snmp_if *osif;</a>
<a name="ln1457">  struct in_addr *addr;</a>
<a name="ln1458">  ifindex_t ifindex;</a>
<a name="ln1459"> </a>
<a name="ln1460">  ospf_snmp_if_delete (ifp);</a>
<a name="ln1461"> </a>
<a name="ln1462">  p = NULL;</a>
<a name="ln1463">  addr = NULL;</a>
<a name="ln1464">  ifindex = 0;</a>
<a name="ln1465"> </a>
<a name="ln1466">  /* Lookup first IPv4 address entry. */</a>
<a name="ln1467">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, node, ifc))</a>
<a name="ln1468">    {</a>
<a name="ln1469">      p = CONNECTED_ID(ifc);</a>
<a name="ln1470"> </a>
<a name="ln1471">      if (p-&gt;family == AF_INET)</a>
<a name="ln1472">	{</a>
<a name="ln1473">	  addr = &amp;p-&gt;u.prefix4;</a>
<a name="ln1474">	  break;</a>
<a name="ln1475">	}</a>
<a name="ln1476">    }</a>
<a name="ln1477">  if (! addr)</a>
<a name="ln1478">    ifindex = ifp-&gt;ifindex;</a>
<a name="ln1479"> </a>
<a name="ln1480">  /* Add interface to the list. */</a>
<a name="ln1481">  pn = NULL;</a>
<a name="ln1482">  for (ALL_LIST_ELEMENTS_RO (ospf_snmp_iflist, node, osif))</a>
<a name="ln1483">    {</a>
<a name="ln1484">      if (addr)</a>
<a name="ln1485">	{</a>
<a name="ln1486">	  /* Usual interfaces --&gt; Sort them based on interface IPv4 addresses */</a>
<a name="ln1487">	  if (ntohl (osif-&gt;addr.s_addr) &gt; ntohl (addr-&gt;s_addr))</a>
<a name="ln1488">	    break;</a>
<a name="ln1489">	}</a>
<a name="ln1490">      else</a>
<a name="ln1491">	{</a>
<a name="ln1492">	  /* Unnumbered interfaces --&gt; Sort them based on interface indexes */</a>
<a name="ln1493">	  if (osif-&gt;addr.s_addr != 0 || osif-&gt;ifindex &gt; ifindex)</a>
<a name="ln1494">	    break;</a>
<a name="ln1495">	}</a>
<a name="ln1496">      pn = node;</a>
<a name="ln1497">    }</a>
<a name="ln1498"> </a>
<a name="ln1499">  osif = ospf_snmp_if_new ();</a>
<a name="ln1500">  if (addr) /* Usual interface */</a>
<a name="ln1501">  {</a>
<a name="ln1502">    osif-&gt;addr = *addr;</a>
<a name="ln1503">    </a>
<a name="ln1504">    /* This field is used for storing ospfAddressLessIf OID value,</a>
<a name="ln1505">     * conform to RFC1850 OSPF-MIB specification, it must be 0 for</a>
<a name="ln1506">     * usual interface */</a>
<a name="ln1507">    osif-&gt;ifindex = 0;</a>
<a name="ln1508">  }</a>
<a name="ln1509">  else  /* Unnumbered interface */</a>
<a name="ln1510">    osif-&gt;ifindex = ifindex;</a>
<a name="ln1511">  osif-&gt;ifp = ifp;</a>
<a name="ln1512"> </a>
<a name="ln1513">  listnode_add_after (ospf_snmp_iflist, pn, osif);</a>
<a name="ln1514">}</a>
<a name="ln1515"> </a>
<a name="ln1516">static int</a>
<a name="ln1517">ospf_snmp_is_if_have_addr (struct interface *ifp)</a>
<a name="ln1518">{</a>
<a name="ln1519">  struct listnode *nn;</a>
<a name="ln1520">  struct connected *ifc;</a>
<a name="ln1521"> </a>
<a name="ln1522">  /* Is this interface having any connected IPv4 address ? */</a>
<a name="ln1523">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, nn, ifc))</a>
<a name="ln1524">  {</a>
<a name="ln1525">    if (CONNECTED_PREFIX(ifc)-&gt;family == AF_INET)</a>
<a name="ln1526">      return 1;</a>
<a name="ln1527">  }</a>
<a name="ln1528">  </a>
<a name="ln1529">  return 0;</a>
<a name="ln1530">}</a>
<a name="ln1531"> </a>
<a name="ln1532">static struct ospf_interface *</a>
<a name="ln1533">ospf_snmp_if_lookup (struct in_addr *ifaddr, ifindex_t *ifindex)</a>
<a name="ln1534">{</a>
<a name="ln1535">  struct listnode *node;</a>
<a name="ln1536">  struct ospf_snmp_if *osif;</a>
<a name="ln1537">  struct ospf_interface *oi = NULL;</a>
<a name="ln1538">  struct ospf *ospf = ospf_lookup ();</a>
<a name="ln1539"> </a>
<a name="ln1540">  for (ALL_LIST_ELEMENTS_RO (ospf_snmp_iflist, node, osif))</a>
<a name="ln1541">    {  </a>
<a name="ln1542">      if (ifaddr-&gt;s_addr)</a>
<a name="ln1543">        {</a>
<a name="ln1544">	      if (IPV4_ADDR_SAME (&amp;osif-&gt;addr, ifaddr))</a>
<a name="ln1545">            oi = ospf_if_lookup_by_local_addr (ospf, osif-&gt;ifp, *ifaddr);</a>
<a name="ln1546">        }</a>
<a name="ln1547">      else</a>
<a name="ln1548">        {</a>
<a name="ln1549">	      if (osif-&gt;ifindex == *ifindex)</a>
<a name="ln1550">            oi = ospf_if_lookup_by_local_addr (ospf, osif-&gt;ifp, *ifaddr);</a>
<a name="ln1551">        }</a>
<a name="ln1552">    }</a>
<a name="ln1553">  return oi;</a>
<a name="ln1554">}</a>
<a name="ln1555"> </a>
<a name="ln1556">static struct ospf_interface *</a>
<a name="ln1557">ospf_snmp_if_lookup_next (struct in_addr *ifaddr, ifindex_t *ifindex,</a>
<a name="ln1558">			  int ifaddr_next, ifindex_t ifindex_next)</a>
<a name="ln1559">{</a>
<a name="ln1560">  struct ospf_snmp_if *osif;</a>
<a name="ln1561">  struct listnode *nn;</a>
<a name="ln1562">  struct ospf *ospf = ospf_lookup ();</a>
<a name="ln1563">  struct ospf_interface *oi = NULL;</a>
<a name="ln1564"> </a>
<a name="ln1565">  if (ospf == NULL)</a>
<a name="ln1566">    return NULL;</a>
<a name="ln1567"> </a>
<a name="ln1568">  /* No instance is specified --&gt; Return the first OSPF interface */</a>
<a name="ln1569">  if (ifaddr_next)</a>
<a name="ln1570">    {</a>
<a name="ln1571">      for (ALL_LIST_ELEMENTS_RO (ospf_snmp_iflist, nn, osif))</a>
<a name="ln1572">	{</a>
<a name="ln1573">	  osif = listgetdata (nn);</a>
<a name="ln1574">	  *ifaddr = osif-&gt;addr;</a>
<a name="ln1575">	  *ifindex = osif-&gt;ifindex;</a>
<a name="ln1576">          /* Because no instance is specified, we don't care about the kind of </a>
<a name="ln1577">           * interface (usual or unnumbered), just returning the first valid </a>
<a name="ln1578">           * OSPF interface */</a>
<a name="ln1579">          oi = ospf_if_lookup_by_local_addr (ospf, osif-&gt;ifp, *ifaddr);</a>
<a name="ln1580">          if (oi)</a>
<a name="ln1581">            return (oi);</a>
<a name="ln1582">	}</a>
<a name="ln1583">      return NULL;</a>
<a name="ln1584">    }</a>
<a name="ln1585"> </a>
<a name="ln1586">  /* An instance is specified --&gt; Return the next OSPF interface */</a>
<a name="ln1587">  for (ALL_LIST_ELEMENTS_RO (ospf_snmp_iflist, nn, osif))</a>
<a name="ln1588">    {</a>
<a name="ln1589">      /* Usual interface */</a>
<a name="ln1590">      if (ifaddr-&gt;s_addr) </a>
<a name="ln1591">	{</a>
<a name="ln1592">	  /* The interface must have valid AF_INET connected address */</a>
<a name="ln1593">	  /* it must have lager IPv4 address value than the lookup entry */</a>
<a name="ln1594">	  if ((ospf_snmp_is_if_have_addr(osif-&gt;ifp)) &amp;&amp;</a>
<a name="ln1595">	      (ntohl (osif-&gt;addr.s_addr) &gt; ntohl (ifaddr-&gt;s_addr)))</a>
<a name="ln1596">	    {</a>
<a name="ln1597">	      *ifaddr = osif-&gt;addr;</a>
<a name="ln1598">	      *ifindex = osif-&gt;ifindex;</a>
<a name="ln1599">        </a>
<a name="ln1600">	      /* and it must be an OSPF interface */</a>
<a name="ln1601">	      oi = ospf_if_lookup_by_local_addr (ospf, osif-&gt;ifp, *ifaddr);</a>
<a name="ln1602">	      if (oi)</a>
<a name="ln1603">		return oi;</a>
<a name="ln1604">	    }</a>
<a name="ln1605">	}</a>
<a name="ln1606">      /* Unnumbered interface */</a>
<a name="ln1607">      else  </a>
<a name="ln1608">        /* The interface must NOT have valid AF_INET connected address */</a>
<a name="ln1609">        /* it must have lager interface index than the lookup entry */</a>
<a name="ln1610">        if ((!ospf_snmp_is_if_have_addr(osif-&gt;ifp)) &amp;&amp;</a>
<a name="ln1611">            (osif-&gt;ifindex &gt; *ifindex))</a>
<a name="ln1612">          {</a>
<a name="ln1613">            *ifaddr = osif-&gt;addr;</a>
<a name="ln1614">            *ifindex = osif-&gt;ifindex;</a>
<a name="ln1615">        </a>
<a name="ln1616">            /* and it must be an OSPF interface */</a>
<a name="ln1617">            oi = ospf_if_lookup_by_local_addr (ospf, osif-&gt;ifp, *ifaddr);</a>
<a name="ln1618">            if (oi)</a>
<a name="ln1619">              return oi;</a>
<a name="ln1620">          }</a>
<a name="ln1621">    }</a>
<a name="ln1622">  return NULL;</a>
<a name="ln1623">}</a>
<a name="ln1624"> </a>
<a name="ln1625">static int</a>
<a name="ln1626">ospf_snmp_iftype (struct interface *ifp)</a>
<a name="ln1627">{</a>
<a name="ln1628">#define ospf_snmp_iftype_broadcast         1</a>
<a name="ln1629">#define ospf_snmp_iftype_nbma              2</a>
<a name="ln1630">#define ospf_snmp_iftype_pointToPoint      3</a>
<a name="ln1631">#define ospf_snmp_iftype_pointToMultipoint 5</a>
<a name="ln1632">  if (if_is_broadcast (ifp))</a>
<a name="ln1633">    return ospf_snmp_iftype_broadcast;</a>
<a name="ln1634">  if (if_is_pointopoint (ifp))</a>
<a name="ln1635">    return ospf_snmp_iftype_pointToPoint;</a>
<a name="ln1636">  return ospf_snmp_iftype_broadcast;</a>
<a name="ln1637">}</a>
<a name="ln1638"> </a>
<a name="ln1639">static struct ospf_interface *</a>
<a name="ln1640">ospfIfLookup (struct variable *v, oid *name, size_t *length,</a>
<a name="ln1641">	      struct in_addr *ifaddr, ifindex_t *ifindex, int exact)</a>
<a name="ln1642">{</a>
<a name="ln1643">  unsigned int len;</a>
<a name="ln1644">  int ifaddr_next = 0;</a>
<a name="ln1645">  ifindex_t ifindex_next = 0;</a>
<a name="ln1646">  struct ospf_interface *oi;</a>
<a name="ln1647">  oid *offset;</a>
<a name="ln1648"> </a>
<a name="ln1649">  if (exact)</a>
<a name="ln1650">    {</a>
<a name="ln1651">      if (*length != v-&gt;namelen + IN_ADDR_SIZE + 1)</a>
<a name="ln1652">	return NULL;</a>
<a name="ln1653"> </a>
<a name="ln1654">      oid2in_addr (name + v-&gt;namelen, IN_ADDR_SIZE, ifaddr);</a>
<a name="ln1655">      *ifindex = name[v-&gt;namelen + IN_ADDR_SIZE];</a>
<a name="ln1656"> </a>
<a name="ln1657">      return ospf_snmp_if_lookup (ifaddr, ifindex);</a>
<a name="ln1658">    }</a>
<a name="ln1659">  else</a>
<a name="ln1660">    {</a>
<a name="ln1661">      len = *length - v-&gt;namelen;</a>
<a name="ln1662">      if (len &gt;= IN_ADDR_SIZE)</a>
<a name="ln1663">	len = IN_ADDR_SIZE;</a>
<a name="ln1664">      if (len &lt;= 0)</a>
<a name="ln1665">	ifaddr_next = 1;</a>
<a name="ln1666"> </a>
<a name="ln1667">      oid2in_addr (name + v-&gt;namelen, len, ifaddr);</a>
<a name="ln1668"> </a>
<a name="ln1669">      len = *length - v-&gt;namelen - IN_ADDR_SIZE;</a>
<a name="ln1670">      if (len &gt;= 1)</a>
<a name="ln1671">	len = 1;</a>
<a name="ln1672">      else</a>
<a name="ln1673">	ifindex_next = 1;</a>
<a name="ln1674"> </a>
<a name="ln1675">      if (len == 1)</a>
<a name="ln1676">	*ifindex = name[v-&gt;namelen + IN_ADDR_SIZE];</a>
<a name="ln1677"> </a>
<a name="ln1678">      oi = ospf_snmp_if_lookup_next (ifaddr, ifindex, ifaddr_next,</a>
<a name="ln1679">				      ifindex_next);</a>
<a name="ln1680">      if (oi)</a>
<a name="ln1681">	{</a>
<a name="ln1682">	  *length = v-&gt;namelen + IN_ADDR_SIZE + 1;</a>
<a name="ln1683">	  offset = name + v-&gt;namelen;</a>
<a name="ln1684">	  oid_copy_addr (offset, ifaddr, IN_ADDR_SIZE);</a>
<a name="ln1685">	  offset += IN_ADDR_SIZE;</a>
<a name="ln1686">	  *offset = *ifindex;</a>
<a name="ln1687">	  return oi;</a>
<a name="ln1688">	}</a>
<a name="ln1689">    }</a>
<a name="ln1690">  return NULL;</a>
<a name="ln1691">}</a>
<a name="ln1692"> </a>
<a name="ln1693">static u_char *</a>
<a name="ln1694">ospfIfEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln1695">	     size_t *var_len, WriteMethod **write_method)</a>
<a name="ln1696">{</a>
<a name="ln1697">  ifindex_t ifindex;</a>
<a name="ln1698">  struct in_addr ifaddr;</a>
<a name="ln1699">  struct ospf_interface *oi;</a>
<a name="ln1700">  struct ospf *ospf;</a>
<a name="ln1701"> </a>
<a name="ln1702">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln1703">      == MATCH_FAILED)</a>
<a name="ln1704">    return NULL;</a>
<a name="ln1705"> </a>
<a name="ln1706">  ifindex = 0;</a>
<a name="ln1707">  memset (&amp;ifaddr, 0, sizeof (struct in_addr));</a>
<a name="ln1708"> </a>
<a name="ln1709">  /* Check OSPF instance. */</a>
<a name="ln1710">  ospf = ospf_lookup ();</a>
<a name="ln1711">  if (ospf == NULL)</a>
<a name="ln1712">    return NULL;</a>
<a name="ln1713"> </a>
<a name="ln1714">  oi = ospfIfLookup (v, name, length, &amp;ifaddr, &amp;ifindex, exact);</a>
<a name="ln1715">  if (oi == NULL)</a>
<a name="ln1716">    return NULL;</a>
<a name="ln1717"> </a>
<a name="ln1718">  /* Return the current value of the variable */</a>
<a name="ln1719">  switch (v-&gt;magic) </a>
<a name="ln1720">    {</a>
<a name="ln1721">    case OSPFIFIPADDRESS:	/* 1 */</a>
<a name="ln1722">      return SNMP_IPADDRESS (ifaddr);</a>
<a name="ln1723">      break;</a>
<a name="ln1724">    case OSPFADDRESSLESSIF:	/* 2 */</a>
<a name="ln1725">      return SNMP_INTEGER (ifindex);</a>
<a name="ln1726">      break;</a>
<a name="ln1727">    case OSPFIFAREAID:		/* 3 */</a>
<a name="ln1728">      if (oi-&gt;area)</a>
<a name="ln1729">	return SNMP_IPADDRESS (oi-&gt;area-&gt;area_id);</a>
<a name="ln1730">      else</a>
<a name="ln1731">	return SNMP_IPADDRESS (ospf_empty_addr);</a>
<a name="ln1732">      break;</a>
<a name="ln1733">    case OSPFIFTYPE:		/* 4 */</a>
<a name="ln1734">      return SNMP_INTEGER (ospf_snmp_iftype (oi-&gt;ifp));</a>
<a name="ln1735">      break;</a>
<a name="ln1736">    case OSPFIFADMINSTAT:	/* 5 */</a>
<a name="ln1737">      if (oi)</a>
<a name="ln1738">	return SNMP_INTEGER (OSPF_STATUS_ENABLED);</a>
<a name="ln1739">      else</a>
<a name="ln1740">	return SNMP_INTEGER (OSPF_STATUS_DISABLED);</a>
<a name="ln1741">      break;</a>
<a name="ln1742">    case OSPFIFRTRPRIORITY:	/* 6 */</a>
<a name="ln1743">      return SNMP_INTEGER (PRIORITY (oi));</a>
<a name="ln1744">      break;</a>
<a name="ln1745">    case OSPFIFTRANSITDELAY:	/* 7 */</a>
<a name="ln1746">      return SNMP_INTEGER (OSPF_IF_PARAM (oi, transmit_delay));</a>
<a name="ln1747">      break;</a>
<a name="ln1748">    case OSPFIFRETRANSINTERVAL:	/* 8 */</a>
<a name="ln1749">      return SNMP_INTEGER (OSPF_IF_PARAM (oi, retransmit_interval));</a>
<a name="ln1750">      break;</a>
<a name="ln1751">    case OSPFIFHELLOINTERVAL:	/* 9 */</a>
<a name="ln1752">      return SNMP_INTEGER (OSPF_IF_PARAM (oi, v_hello));</a>
<a name="ln1753">      break;</a>
<a name="ln1754">    case OSPFIFRTRDEADINTERVAL:	/* 10 */</a>
<a name="ln1755">      return SNMP_INTEGER (OSPF_IF_PARAM (oi, v_wait));</a>
<a name="ln1756">      break;</a>
<a name="ln1757">    case OSPFIFPOLLINTERVAL:	/* 11 */</a>
<a name="ln1758">      return SNMP_INTEGER (OSPF_POLL_INTERVAL_DEFAULT);</a>
<a name="ln1759">      break;</a>
<a name="ln1760">    case OSPFIFSTATE:		/* 12 */</a>
<a name="ln1761">      return SNMP_INTEGER (ISM_SNMP(oi-&gt;state));</a>
<a name="ln1762">      break;</a>
<a name="ln1763">    case OSPFIFDESIGNATEDROUTER: /* 13 */</a>
<a name="ln1764">      return SNMP_IPADDRESS (DR (oi));</a>
<a name="ln1765">      break;</a>
<a name="ln1766">    case OSPFIFBACKUPDESIGNATEDROUTER: /* 14 */</a>
<a name="ln1767">      return SNMP_IPADDRESS (BDR (oi));</a>
<a name="ln1768">      break;</a>
<a name="ln1769">    case OSPFIFEVENTS:		/* 15 */</a>
<a name="ln1770">      return SNMP_INTEGER (oi-&gt;state_change);</a>
<a name="ln1771">      break;</a>
<a name="ln1772">    case OSPFIFAUTHKEY:		/* 16 */</a>
<a name="ln1773">      *var_len = 0;</a>
<a name="ln1774">      return (u_char *) OSPF_IF_PARAM (oi, auth_simple);</a>
<a name="ln1775">      break;</a>
<a name="ln1776">    case OSPFIFSTATUS:		/* 17 */</a>
<a name="ln1777">      return SNMP_INTEGER (SNMP_VALID);</a>
<a name="ln1778">      break;</a>
<a name="ln1779">    case OSPFIFMULTICASTFORWARDING: /* 18 */</a>
<a name="ln1780">#define ospf_snmp_multiforward_blocked    1</a>
<a name="ln1781">#define ospf_snmp_multiforward_multicast  2</a>
<a name="ln1782">#define ospf_snmp_multiforward_unicast    3</a>
<a name="ln1783">      return SNMP_INTEGER (ospf_snmp_multiforward_blocked);</a>
<a name="ln1784">      break;</a>
<a name="ln1785">    case OSPFIFDEMAND:		/* 19 */</a>
<a name="ln1786">      return SNMP_INTEGER (SNMP_FALSE);</a>
<a name="ln1787">      break;</a>
<a name="ln1788">    case OSPFIFAUTHTYPE:	/* 20 */</a>
<a name="ln1789">      if (oi-&gt;area)</a>
<a name="ln1790">	return SNMP_INTEGER (oi-&gt;area-&gt;auth_type);</a>
<a name="ln1791">      else</a>
<a name="ln1792">	return SNMP_INTEGER (0);</a>
<a name="ln1793">      break;</a>
<a name="ln1794">    default:</a>
<a name="ln1795">      return NULL;</a>
<a name="ln1796">      break;</a>
<a name="ln1797">    }</a>
<a name="ln1798">  return NULL;</a>
<a name="ln1799">}</a>
<a name="ln1800"> </a>
<a name="ln1801">#define OSPF_SNMP_METRIC_VALUE 1</a>
<a name="ln1802"> </a>
<a name="ln1803">static struct ospf_interface *</a>
<a name="ln1804">ospfIfMetricLookup (struct variable *v, oid *name, size_t *length,</a>
<a name="ln1805">		    struct in_addr *ifaddr, ifindex_t *ifindex, int exact)</a>
<a name="ln1806">{</a>
<a name="ln1807">  unsigned int len;</a>
<a name="ln1808">  int ifaddr_next = 0;</a>
<a name="ln1809">  ifindex_t ifindex_next = 0;</a>
<a name="ln1810">  struct ospf_interface *oi;</a>
<a name="ln1811">  oid *offset;</a>
<a name="ln1812">  int metric;</a>
<a name="ln1813"> </a>
<a name="ln1814">  if (exact)</a>
<a name="ln1815">    {</a>
<a name="ln1816">      if (*length != v-&gt;namelen + IN_ADDR_SIZE + 1 + 1)</a>
<a name="ln1817">	return NULL;</a>
<a name="ln1818"> </a>
<a name="ln1819">      oid2in_addr (name + v-&gt;namelen, IN_ADDR_SIZE, ifaddr);</a>
<a name="ln1820">      *ifindex = name[v-&gt;namelen + IN_ADDR_SIZE];</a>
<a name="ln1821">      metric = name[v-&gt;namelen + IN_ADDR_SIZE + 1];</a>
<a name="ln1822"> </a>
<a name="ln1823">      if (metric != OSPF_SNMP_METRIC_VALUE)</a>
<a name="ln1824">	return NULL;</a>
<a name="ln1825"> </a>
<a name="ln1826">      return ospf_snmp_if_lookup (ifaddr, ifindex);</a>
<a name="ln1827">    }</a>
<a name="ln1828">  else</a>
<a name="ln1829">    {</a>
<a name="ln1830">      len = *length - v-&gt;namelen;</a>
<a name="ln1831">      if (len &gt;= IN_ADDR_SIZE)</a>
<a name="ln1832">	len = IN_ADDR_SIZE;</a>
<a name="ln1833">      else</a>
<a name="ln1834">	ifaddr_next = 1;</a>
<a name="ln1835"> </a>
<a name="ln1836">      oid2in_addr (name + v-&gt;namelen, len, ifaddr);</a>
<a name="ln1837"> </a>
<a name="ln1838">      len = *length - v-&gt;namelen - IN_ADDR_SIZE;</a>
<a name="ln1839">      if (len &gt;= 1)</a>
<a name="ln1840">	len = 1;</a>
<a name="ln1841">      else</a>
<a name="ln1842">	ifindex_next = 1;</a>
<a name="ln1843"> </a>
<a name="ln1844">      if (len == 1)</a>
<a name="ln1845">	*ifindex = name[v-&gt;namelen + IN_ADDR_SIZE];</a>
<a name="ln1846"> </a>
<a name="ln1847">      oi = ospf_snmp_if_lookup_next (ifaddr, ifindex, ifaddr_next,</a>
<a name="ln1848">				      ifindex_next);</a>
<a name="ln1849">      if (oi)</a>
<a name="ln1850">	{</a>
<a name="ln1851">	  *length = v-&gt;namelen + IN_ADDR_SIZE + 1 + 1;</a>
<a name="ln1852">	  offset = name + v-&gt;namelen;</a>
<a name="ln1853">	  oid_copy_addr (offset, ifaddr, IN_ADDR_SIZE);</a>
<a name="ln1854">	  offset += IN_ADDR_SIZE;</a>
<a name="ln1855">	  *offset = *ifindex;</a>
<a name="ln1856">	  offset++;</a>
<a name="ln1857">	  *offset = OSPF_SNMP_METRIC_VALUE;</a>
<a name="ln1858">	  return oi;</a>
<a name="ln1859">	}</a>
<a name="ln1860">    }</a>
<a name="ln1861">  return NULL;</a>
<a name="ln1862">}</a>
<a name="ln1863"> </a>
<a name="ln1864">static u_char *</a>
<a name="ln1865">ospfIfMetricEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln1866">		   size_t *var_len, WriteMethod **write_method)</a>
<a name="ln1867">{</a>
<a name="ln1868">  /* Currently we support metric 1 only. */</a>
<a name="ln1869">  ifindex_t ifindex;</a>
<a name="ln1870">  struct in_addr ifaddr;</a>
<a name="ln1871">  struct ospf_interface *oi;</a>
<a name="ln1872">  struct ospf *ospf;</a>
<a name="ln1873"> </a>
<a name="ln1874">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln1875">      == MATCH_FAILED)</a>
<a name="ln1876">    return NULL;</a>
<a name="ln1877"> </a>
<a name="ln1878">  ifindex = 0;</a>
<a name="ln1879">  memset (&amp;ifaddr, 0, sizeof (struct in_addr));</a>
<a name="ln1880"> </a>
<a name="ln1881">  /* Check OSPF instance. */</a>
<a name="ln1882">  ospf = ospf_lookup ();</a>
<a name="ln1883">  if (ospf == NULL)</a>
<a name="ln1884">    return NULL;</a>
<a name="ln1885"> </a>
<a name="ln1886">  oi = ospfIfMetricLookup (v, name, length, &amp;ifaddr, &amp;ifindex, exact);</a>
<a name="ln1887">  if (oi == NULL)</a>
<a name="ln1888">    return NULL;</a>
<a name="ln1889"> </a>
<a name="ln1890">  /* Return the current value of the variable */</a>
<a name="ln1891">  switch (v-&gt;magic) </a>
<a name="ln1892">    {</a>
<a name="ln1893">    case OSPFIFMETRICIPADDRESS:</a>
<a name="ln1894">      return SNMP_IPADDRESS (ifaddr);</a>
<a name="ln1895">      break;</a>
<a name="ln1896">    case OSPFIFMETRICADDRESSLESSIF:</a>
<a name="ln1897">      return SNMP_INTEGER (ifindex);</a>
<a name="ln1898">      break;</a>
<a name="ln1899">    case OSPFIFMETRICTOS:</a>
<a name="ln1900">      return SNMP_INTEGER (0);</a>
<a name="ln1901">      break;</a>
<a name="ln1902">    case OSPFIFMETRICVALUE:</a>
<a name="ln1903">      return SNMP_INTEGER (OSPF_SNMP_METRIC_VALUE);</a>
<a name="ln1904">      break;</a>
<a name="ln1905">    case OSPFIFMETRICSTATUS:</a>
<a name="ln1906">      return SNMP_INTEGER (1);</a>
<a name="ln1907">      break;</a>
<a name="ln1908">    default:</a>
<a name="ln1909">      return NULL;</a>
<a name="ln1910">      break;</a>
<a name="ln1911">    }</a>
<a name="ln1912">  return NULL;</a>
<a name="ln1913">}</a>
<a name="ln1914"> </a>
<a name="ln1915">struct route_table *ospf_snmp_vl_table;</a>
<a name="ln1916"> </a>
<a name="ln1917">void</a>
<a name="ln1918">ospf_snmp_vl_add (struct ospf_vl_data *vl_data)</a>
<a name="ln1919">{</a>
<a name="ln1920">  struct prefix_ls lp;</a>
<a name="ln1921">  struct route_node *rn;</a>
<a name="ln1922"> </a>
<a name="ln1923">  memset (&amp;lp, 0, sizeof (struct prefix_ls));</a>
<a name="ln1924">  lp.family = 0;</a>
<a name="ln1925">  lp.prefixlen = 64;</a>
<a name="ln1926">  lp.id = vl_data-&gt;vl_area_id;</a>
<a name="ln1927">  lp.adv_router = vl_data-&gt;vl_peer;</a>
<a name="ln1928"> </a>
<a name="ln1929">  rn = route_node_get (ospf_snmp_vl_table, (struct prefix *) &amp;lp);</a>
<a name="ln1930">  if (rn-&gt;info)</a>
<a name="ln1931">    route_unlock_node (rn);</a>
<a name="ln1932"> </a>
<a name="ln1933">  rn-&gt;info = vl_data;</a>
<a name="ln1934">}</a>
<a name="ln1935"> </a>
<a name="ln1936">void</a>
<a name="ln1937">ospf_snmp_vl_delete (struct ospf_vl_data *vl_data)</a>
<a name="ln1938">{</a>
<a name="ln1939">  struct prefix_ls lp;</a>
<a name="ln1940">  struct route_node *rn;</a>
<a name="ln1941"> </a>
<a name="ln1942">  memset (&amp;lp, 0, sizeof (struct prefix_ls));</a>
<a name="ln1943">  lp.family = 0;</a>
<a name="ln1944">  lp.prefixlen = 64;</a>
<a name="ln1945">  lp.id = vl_data-&gt;vl_area_id;</a>
<a name="ln1946">  lp.adv_router = vl_data-&gt;vl_peer;</a>
<a name="ln1947"> </a>
<a name="ln1948">  rn = route_node_lookup (ospf_snmp_vl_table, (struct prefix *) &amp;lp);</a>
<a name="ln1949">  if (! rn)</a>
<a name="ln1950">    return;</a>
<a name="ln1951">  rn-&gt;info = NULL;</a>
<a name="ln1952">  route_unlock_node (rn);</a>
<a name="ln1953">  route_unlock_node (rn);</a>
<a name="ln1954">}</a>
<a name="ln1955"> </a>
<a name="ln1956">static struct ospf_vl_data *</a>
<a name="ln1957">ospf_snmp_vl_lookup (struct in_addr *area_id, struct in_addr *neighbor)</a>
<a name="ln1958">{</a>
<a name="ln1959">  struct prefix_ls lp;</a>
<a name="ln1960">  struct route_node *rn;</a>
<a name="ln1961">  struct ospf_vl_data *vl_data;</a>
<a name="ln1962"> </a>
<a name="ln1963">  memset (&amp;lp, 0, sizeof (struct prefix_ls));</a>
<a name="ln1964">  lp.family = 0;</a>
<a name="ln1965">  lp.prefixlen = 64;</a>
<a name="ln1966">  lp.id = *area_id;</a>
<a name="ln1967">  lp.adv_router = *neighbor;</a>
<a name="ln1968"> </a>
<a name="ln1969">  rn = route_node_lookup (ospf_snmp_vl_table, (struct prefix *) &amp;lp);</a>
<a name="ln1970">  if (rn)</a>
<a name="ln1971">    {</a>
<a name="ln1972">      vl_data = rn-&gt;info;</a>
<a name="ln1973">      route_unlock_node (rn);</a>
<a name="ln1974">      return vl_data;</a>
<a name="ln1975">    }</a>
<a name="ln1976">  return NULL;</a>
<a name="ln1977">}</a>
<a name="ln1978"> </a>
<a name="ln1979">static struct ospf_vl_data *</a>
<a name="ln1980">ospf_snmp_vl_lookup_next (struct in_addr *area_id, struct in_addr *neighbor,</a>
<a name="ln1981">			  int first)</a>
<a name="ln1982">{</a>
<a name="ln1983">  struct prefix_ls lp;</a>
<a name="ln1984">  struct route_node *rn;</a>
<a name="ln1985">  struct ospf_vl_data *vl_data;</a>
<a name="ln1986"> </a>
<a name="ln1987">  memset (&amp;lp, 0, sizeof (struct prefix_ls));</a>
<a name="ln1988">  lp.family = 0;</a>
<a name="ln1989">  lp.prefixlen = 64;</a>
<a name="ln1990">  lp.id = *area_id;</a>
<a name="ln1991">  lp.adv_router = *neighbor;</a>
<a name="ln1992"> </a>
<a name="ln1993">  if (first)</a>
<a name="ln1994">    rn = route_top (ospf_snmp_vl_table);</a>
<a name="ln1995">  else</a>
<a name="ln1996">    {</a>
<a name="ln1997">      rn = route_node_get (ospf_snmp_vl_table, (struct prefix *) &amp;lp);</a>
<a name="ln1998">      rn = route_next (rn);</a>
<a name="ln1999">    }</a>
<a name="ln2000"> </a>
<a name="ln2001">  for (; rn; rn = route_next (rn))</a>
<a name="ln2002">    if (rn-&gt;info)</a>
<a name="ln2003">      break;</a>
<a name="ln2004"> </a>
<a name="ln2005">  if (rn &amp;&amp; rn-&gt;info)</a>
<a name="ln2006">    {</a>
<a name="ln2007">      vl_data = rn-&gt;info;</a>
<a name="ln2008">      *area_id = vl_data-&gt;vl_area_id;</a>
<a name="ln2009">      *neighbor = vl_data-&gt;vl_peer;</a>
<a name="ln2010">      route_unlock_node (rn);</a>
<a name="ln2011">      return vl_data;</a>
<a name="ln2012">    }</a>
<a name="ln2013">  return NULL;</a>
<a name="ln2014">}</a>
<a name="ln2015"> </a>
<a name="ln2016">static struct ospf_vl_data *</a>
<a name="ln2017">ospfVirtIfLookup (struct variable *v, oid *name, size_t *length,</a>
<a name="ln2018">		  struct in_addr *area_id, struct in_addr *neighbor, int exact)</a>
<a name="ln2019">{</a>
<a name="ln2020">  int first;</a>
<a name="ln2021">  unsigned int len;</a>
<a name="ln2022">  struct ospf_vl_data *vl_data;</a>
<a name="ln2023"> </a>
<a name="ln2024">  if (exact)</a>
<a name="ln2025">    {</a>
<a name="ln2026">      if (*length != v-&gt;namelen + IN_ADDR_SIZE + IN_ADDR_SIZE)</a>
<a name="ln2027">	return NULL;</a>
<a name="ln2028"> </a>
<a name="ln2029">      oid2in_addr (name + v-&gt;namelen, IN_ADDR_SIZE, area_id);</a>
<a name="ln2030">      oid2in_addr (name + v-&gt;namelen + IN_ADDR_SIZE, IN_ADDR_SIZE, neighbor);</a>
<a name="ln2031"> </a>
<a name="ln2032">      return ospf_snmp_vl_lookup (area_id, neighbor);</a>
<a name="ln2033">    }</a>
<a name="ln2034">  else</a>
<a name="ln2035">    {</a>
<a name="ln2036">      first = 0;</a>
<a name="ln2037"> </a>
<a name="ln2038">      len = *length - v-&gt;namelen;</a>
<a name="ln2039">      if (len &lt;= 0)</a>
<a name="ln2040">	first = 1;</a>
<a name="ln2041">      if (len &gt; IN_ADDR_SIZE)</a>
<a name="ln2042">	len = IN_ADDR_SIZE;</a>
<a name="ln2043">      oid2in_addr (name + v-&gt;namelen, len, area_id);</a>
<a name="ln2044"> </a>
<a name="ln2045">      len = *length - v-&gt;namelen - IN_ADDR_SIZE;</a>
<a name="ln2046">      if (len &gt; IN_ADDR_SIZE)</a>
<a name="ln2047">	len = IN_ADDR_SIZE;</a>
<a name="ln2048">      oid2in_addr (name + v-&gt;namelen + IN_ADDR_SIZE, len, neighbor);</a>
<a name="ln2049"> </a>
<a name="ln2050">      vl_data = ospf_snmp_vl_lookup_next (area_id, neighbor, first);</a>
<a name="ln2051"> </a>
<a name="ln2052">      if (vl_data)</a>
<a name="ln2053">	{</a>
<a name="ln2054">	  *length = v-&gt;namelen + IN_ADDR_SIZE + IN_ADDR_SIZE;</a>
<a name="ln2055">	  oid_copy_addr (name + v-&gt;namelen, area_id, IN_ADDR_SIZE);</a>
<a name="ln2056">	  oid_copy_addr (name + v-&gt;namelen + IN_ADDR_SIZE, neighbor,</a>
<a name="ln2057">			 IN_ADDR_SIZE);</a>
<a name="ln2058">	  return vl_data;</a>
<a name="ln2059">	}</a>
<a name="ln2060">    }</a>
<a name="ln2061">  return NULL;</a>
<a name="ln2062">}</a>
<a name="ln2063"> </a>
<a name="ln2064">static u_char *</a>
<a name="ln2065">ospfVirtIfEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln2066">		 size_t *var_len, WriteMethod **write_method)</a>
<a name="ln2067">{</a>
<a name="ln2068">  struct ospf_vl_data *vl_data;</a>
<a name="ln2069">  struct ospf_interface *oi;</a>
<a name="ln2070">  struct in_addr area_id;</a>
<a name="ln2071">  struct in_addr neighbor;</a>
<a name="ln2072"> </a>
<a name="ln2073">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln2074">      == MATCH_FAILED)</a>
<a name="ln2075">    return NULL;</a>
<a name="ln2076"> </a>
<a name="ln2077">  memset (&amp;area_id, 0, sizeof (struct in_addr));</a>
<a name="ln2078">  memset (&amp;neighbor, 0, sizeof (struct in_addr));</a>
<a name="ln2079"> </a>
<a name="ln2080">  vl_data = ospfVirtIfLookup (v, name, length, &amp;area_id, &amp;neighbor, exact);</a>
<a name="ln2081">  if (! vl_data)</a>
<a name="ln2082">    return NULL;</a>
<a name="ln2083">  oi = vl_data-&gt;vl_oi;</a>
<a name="ln2084">  if (! oi)</a>
<a name="ln2085">    return NULL;</a>
<a name="ln2086">  </a>
<a name="ln2087">  /* Return the current value of the variable */</a>
<a name="ln2088">  switch (v-&gt;magic) </a>
<a name="ln2089">    {</a>
<a name="ln2090">    case OSPFVIRTIFAREAID:</a>
<a name="ln2091">      return SNMP_IPADDRESS (area_id);</a>
<a name="ln2092">      break;</a>
<a name="ln2093">    case OSPFVIRTIFNEIGHBOR:</a>
<a name="ln2094">      return SNMP_IPADDRESS (neighbor);</a>
<a name="ln2095">      break;</a>
<a name="ln2096">    case OSPFVIRTIFTRANSITDELAY:</a>
<a name="ln2097">      return SNMP_INTEGER (OSPF_IF_PARAM (oi, transmit_delay));</a>
<a name="ln2098">      break;</a>
<a name="ln2099">    case OSPFVIRTIFRETRANSINTERVAL:</a>
<a name="ln2100">      return SNMP_INTEGER (OSPF_IF_PARAM (oi, retransmit_interval));</a>
<a name="ln2101">      break;</a>
<a name="ln2102">    case OSPFVIRTIFHELLOINTERVAL:</a>
<a name="ln2103">      return SNMP_INTEGER (OSPF_IF_PARAM (oi, v_hello));</a>
<a name="ln2104">      break;</a>
<a name="ln2105">    case OSPFVIRTIFRTRDEADINTERVAL:</a>
<a name="ln2106">      return SNMP_INTEGER (OSPF_IF_PARAM (oi, v_wait));</a>
<a name="ln2107">      break;</a>
<a name="ln2108">    case OSPFVIRTIFSTATE:</a>
<a name="ln2109">      return SNMP_INTEGER (oi-&gt;state);</a>
<a name="ln2110">      break;</a>
<a name="ln2111">    case OSPFVIRTIFEVENTS:</a>
<a name="ln2112">      return SNMP_INTEGER (oi-&gt;state_change);</a>
<a name="ln2113">      break;</a>
<a name="ln2114">    case OSPFVIRTIFAUTHKEY:</a>
<a name="ln2115">      *var_len = 0;</a>
<a name="ln2116">      return (u_char *) OSPF_IF_PARAM (oi, auth_simple);</a>
<a name="ln2117">      break;</a>
<a name="ln2118">    case OSPFVIRTIFSTATUS:</a>
<a name="ln2119">      return SNMP_INTEGER (SNMP_VALID);</a>
<a name="ln2120">      break;</a>
<a name="ln2121">    case OSPFVIRTIFAUTHTYPE:</a>
<a name="ln2122">      if (oi-&gt;area)</a>
<a name="ln2123">	return SNMP_INTEGER (oi-&gt;area-&gt;auth_type);</a>
<a name="ln2124">      else</a>
<a name="ln2125">	return SNMP_INTEGER (0);</a>
<a name="ln2126">      break;</a>
<a name="ln2127">    default:</a>
<a name="ln2128">      return NULL;</a>
<a name="ln2129">      break;</a>
<a name="ln2130">    }</a>
<a name="ln2131">  return NULL;</a>
<a name="ln2132">}</a>
<a name="ln2133"> </a>
<a name="ln2134">static struct ospf_neighbor *</a>
<a name="ln2135">ospf_snmp_nbr_lookup (struct ospf *ospf, struct in_addr *nbr_addr,</a>
<a name="ln2136">		      ifindex_t *ifindex)</a>
<a name="ln2137">{</a>
<a name="ln2138">  struct listnode *node, *nnode;</a>
<a name="ln2139">  struct ospf_interface *oi;</a>
<a name="ln2140">  struct ospf_neighbor *nbr;</a>
<a name="ln2141">  struct route_node *rn;</a>
<a name="ln2142"> </a>
<a name="ln2143">  for (ALL_LIST_ELEMENTS (ospf-&gt;oiflist, node, nnode, oi))</a>
<a name="ln2144">    {</a>
<a name="ln2145">      for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln2146">	if ((nbr = rn-&gt;info) != NULL</a>
<a name="ln2147">	    &amp;&amp; nbr != oi-&gt;nbr_self</a>
<a name="ln2148">/* If EXACT match is needed, provide ALL entry found</a>
<a name="ln2149">	    &amp;&amp; nbr-&gt;state != NSM_Down</a>
<a name="ln2150"> */</a>
<a name="ln2151">	    &amp;&amp; nbr-&gt;src.s_addr != 0)</a>
<a name="ln2152">	  {</a>
<a name="ln2153">	    if (IPV4_ADDR_SAME (&amp;nbr-&gt;src, nbr_addr))</a>
<a name="ln2154">	      {</a>
<a name="ln2155">		route_unlock_node (rn);</a>
<a name="ln2156">		return nbr;</a>
<a name="ln2157">	      }</a>
<a name="ln2158">	  }</a>
<a name="ln2159">    }</a>
<a name="ln2160">  return NULL;</a>
<a name="ln2161">}</a>
<a name="ln2162"> </a>
<a name="ln2163">static struct ospf_neighbor *</a>
<a name="ln2164">ospf_snmp_nbr_lookup_next (struct in_addr *nbr_addr, ifindex_t *ifindex,</a>
<a name="ln2165">			   int first)</a>
<a name="ln2166">{</a>
<a name="ln2167">  struct listnode *nn;</a>
<a name="ln2168">  struct ospf_interface *oi;</a>
<a name="ln2169">  struct ospf_neighbor *nbr;</a>
<a name="ln2170">  struct route_node *rn;</a>
<a name="ln2171">  struct ospf_neighbor *min = NULL;</a>
<a name="ln2172">  struct ospf *ospf = ospf;</a>
<a name="ln2173"> </a>
<a name="ln2174">  ospf = ospf_lookup ();</a>
<a name="ln2175"> </a>
<a name="ln2176">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, nn, oi))</a>
<a name="ln2177">    {</a>
<a name="ln2178">      for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln2179">	if ((nbr = rn-&gt;info) != NULL</a>
<a name="ln2180">	    &amp;&amp; nbr != oi-&gt;nbr_self</a>
<a name="ln2181">	    &amp;&amp; nbr-&gt;state != NSM_Down</a>
<a name="ln2182">	    &amp;&amp; nbr-&gt;src.s_addr != 0)</a>
<a name="ln2183">	  {</a>
<a name="ln2184">	    if (first)</a>
<a name="ln2185">	      {</a>
<a name="ln2186">		if (! min)</a>
<a name="ln2187">		  min = nbr;</a>
<a name="ln2188">		else if (ntohl (nbr-&gt;src.s_addr) &lt; ntohl (min-&gt;src.s_addr))</a>
<a name="ln2189">		  min = nbr;</a>
<a name="ln2190">	      }</a>
<a name="ln2191">	    else if (ntohl (nbr-&gt;src.s_addr) &gt; ntohl (nbr_addr-&gt;s_addr))</a>
<a name="ln2192">	      {</a>
<a name="ln2193">		if (! min)</a>
<a name="ln2194">		  min = nbr;</a>
<a name="ln2195">		else if (ntohl (nbr-&gt;src.s_addr) &lt; ntohl (min-&gt;src.s_addr))</a>
<a name="ln2196">		  min = nbr;</a>
<a name="ln2197">	      }</a>
<a name="ln2198">	  }</a>
<a name="ln2199">    }</a>
<a name="ln2200">  if (min)</a>
<a name="ln2201">    {</a>
<a name="ln2202">      *nbr_addr = min-&gt;src;</a>
<a name="ln2203">      *ifindex = 0;</a>
<a name="ln2204">      return min;</a>
<a name="ln2205">    }</a>
<a name="ln2206">  return NULL;</a>
<a name="ln2207">}</a>
<a name="ln2208"> </a>
<a name="ln2209">static struct ospf_neighbor *</a>
<a name="ln2210">ospfNbrLookup (struct variable *v, oid *name, size_t *length,</a>
<a name="ln2211">	       struct in_addr *nbr_addr, ifindex_t *ifindex, int exact)</a>
<a name="ln2212">{</a>
<a name="ln2213">  unsigned int len;</a>
<a name="ln2214">  int first;</a>
<a name="ln2215">  struct ospf_neighbor *nbr;</a>
<a name="ln2216">  struct ospf *ospf;</a>
<a name="ln2217"> </a>
<a name="ln2218">  ospf = ospf_lookup ();</a>
<a name="ln2219"> </a>
<a name="ln2220">  if (! ospf)</a>
<a name="ln2221">    return NULL;</a>
<a name="ln2222"> </a>
<a name="ln2223">  if (exact)</a>
<a name="ln2224">    {</a>
<a name="ln2225">      if (*length != v-&gt;namelen + IN_ADDR_SIZE + 1)</a>
<a name="ln2226">	return NULL;</a>
<a name="ln2227"> </a>
<a name="ln2228">      oid2in_addr (name + v-&gt;namelen, IN_ADDR_SIZE, nbr_addr);</a>
<a name="ln2229">      *ifindex = name[v-&gt;namelen + IN_ADDR_SIZE];</a>
<a name="ln2230"> </a>
<a name="ln2231">      return ospf_snmp_nbr_lookup (ospf, nbr_addr, ifindex);</a>
<a name="ln2232">    }</a>
<a name="ln2233">  else</a>
<a name="ln2234">    {</a>
<a name="ln2235">      first = 0;</a>
<a name="ln2236">      len = *length - v-&gt;namelen;</a>
<a name="ln2237"> </a>
<a name="ln2238">      if (len &lt;= 0)</a>
<a name="ln2239">	first = 1;</a>
<a name="ln2240"> </a>
<a name="ln2241">      if (len &gt; IN_ADDR_SIZE)</a>
<a name="ln2242">	len = IN_ADDR_SIZE;</a>
<a name="ln2243"> </a>
<a name="ln2244">      oid2in_addr (name + v-&gt;namelen, len, nbr_addr);</a>
<a name="ln2245"> </a>
<a name="ln2246">      len = *length - v-&gt;namelen - IN_ADDR_SIZE;</a>
<a name="ln2247">      if (len &gt;= 1)</a>
<a name="ln2248">	*ifindex = name[v-&gt;namelen + IN_ADDR_SIZE];</a>
<a name="ln2249">      </a>
<a name="ln2250">      nbr = ospf_snmp_nbr_lookup_next (nbr_addr, ifindex, first);</a>
<a name="ln2251"> </a>
<a name="ln2252">      if (nbr)</a>
<a name="ln2253">	{</a>
<a name="ln2254">	  *length = v-&gt;namelen + IN_ADDR_SIZE + 1;</a>
<a name="ln2255">	  oid_copy_addr (name + v-&gt;namelen, nbr_addr, IN_ADDR_SIZE);</a>
<a name="ln2256">	  name[v-&gt;namelen + IN_ADDR_SIZE] = *ifindex;</a>
<a name="ln2257">	  return nbr;</a>
<a name="ln2258">	}</a>
<a name="ln2259">    }</a>
<a name="ln2260">  return NULL;</a>
<a name="ln2261">}</a>
<a name="ln2262"> </a>
<a name="ln2263">/* map internal quagga neighbor states to official MIB values:</a>
<a name="ln2264"> </a>
<a name="ln2265">ospfNbrState OBJECT-TYPE</a>
<a name="ln2266">        SYNTAX   INTEGER    {</a>
<a name="ln2267">                    down (1),</a>
<a name="ln2268">                    attempt (2),</a>
<a name="ln2269">                    init (3),</a>
<a name="ln2270">                    twoWay (4),</a>
<a name="ln2271">                    exchangeStart (5),</a>
<a name="ln2272">                    exchange (6),</a>
<a name="ln2273">                    loading (7),</a>
<a name="ln2274">                    full (8)</a>
<a name="ln2275">                  }</a>
<a name="ln2276">*/</a>
<a name="ln2277">static int32_t</a>
<a name="ln2278">ospf_snmp_neighbor_state(u_char nst)</a>
<a name="ln2279">{</a>
<a name="ln2280">  switch (nst)</a>
<a name="ln2281">    {</a>
<a name="ln2282">    case NSM_Attempt:</a>
<a name="ln2283">      return 2;</a>
<a name="ln2284">    case NSM_Init:</a>
<a name="ln2285">      return 3;</a>
<a name="ln2286">    case NSM_TwoWay:</a>
<a name="ln2287">      return 4;</a>
<a name="ln2288">    case NSM_ExStart:</a>
<a name="ln2289">      return 5;</a>
<a name="ln2290">    case NSM_Exchange:</a>
<a name="ln2291">      return 6;</a>
<a name="ln2292">    case NSM_Loading:</a>
<a name="ln2293">      return 7;</a>
<a name="ln2294">    case NSM_Full:</a>
<a name="ln2295">      return 8;</a>
<a name="ln2296">    default:</a>
<a name="ln2297">      return 1; /* down */</a>
<a name="ln2298">    }</a>
<a name="ln2299">}</a>
<a name="ln2300"> </a>
<a name="ln2301">static u_char *</a>
<a name="ln2302">ospfNbrEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln2303">	      size_t *var_len, WriteMethod **write_method)</a>
<a name="ln2304">{</a>
<a name="ln2305">  struct in_addr nbr_addr;</a>
<a name="ln2306">  ifindex_t ifindex;</a>
<a name="ln2307">  struct ospf_neighbor *nbr;</a>
<a name="ln2308">  struct ospf_interface *oi;</a>
<a name="ln2309"> </a>
<a name="ln2310">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln2311">      == MATCH_FAILED)</a>
<a name="ln2312">    return NULL;</a>
<a name="ln2313"> </a>
<a name="ln2314">  memset (&amp;nbr_addr, 0, sizeof (struct in_addr));</a>
<a name="ln2315">  ifindex = 0;</a>
<a name="ln2316">  </a>
<a name="ln2317">  nbr = ospfNbrLookup (v, name, length, &amp;nbr_addr, &amp;ifindex, exact);</a>
<a name="ln2318">  if (! nbr)</a>
<a name="ln2319">    return NULL;</a>
<a name="ln2320">  oi = nbr-&gt;oi;</a>
<a name="ln2321">  if (! oi)</a>
<a name="ln2322">    return NULL;</a>
<a name="ln2323"> </a>
<a name="ln2324">  /* Return the current value of the variable */</a>
<a name="ln2325">  switch (v-&gt;magic) </a>
<a name="ln2326">    {</a>
<a name="ln2327">    case OSPFNBRIPADDR:</a>
<a name="ln2328">      return SNMP_IPADDRESS (nbr_addr);</a>
<a name="ln2329">      break;</a>
<a name="ln2330">    case OSPFNBRADDRESSLESSINDEX:</a>
<a name="ln2331">      return SNMP_INTEGER (ifindex);</a>
<a name="ln2332">      break;</a>
<a name="ln2333">    case OSPFNBRRTRID:</a>
<a name="ln2334">      return SNMP_IPADDRESS (nbr-&gt;router_id);</a>
<a name="ln2335">      break;</a>
<a name="ln2336">    case OSPFNBROPTIONS:</a>
<a name="ln2337">      return SNMP_INTEGER (oi-&gt;nbr_self-&gt;options);</a>
<a name="ln2338">      break;</a>
<a name="ln2339">    case OSPFNBRPRIORITY:</a>
<a name="ln2340">      return SNMP_INTEGER (nbr-&gt;priority);</a>
<a name="ln2341">      break;</a>
<a name="ln2342">    case OSPFNBRSTATE:</a>
<a name="ln2343">      return SNMP_INTEGER (ospf_snmp_neighbor_state(nbr-&gt;state));</a>
<a name="ln2344">      break;</a>
<a name="ln2345">    case OSPFNBREVENTS:</a>
<a name="ln2346">      return SNMP_INTEGER (nbr-&gt;state_change);</a>
<a name="ln2347">      break;</a>
<a name="ln2348">    case OSPFNBRLSRETRANSQLEN:</a>
<a name="ln2349">      return SNMP_INTEGER (ospf_ls_retransmit_count (nbr));</a>
<a name="ln2350">      break;</a>
<a name="ln2351">    case OSPFNBMANBRSTATUS:</a>
<a name="ln2352">      return SNMP_INTEGER (SNMP_VALID);</a>
<a name="ln2353">      break;</a>
<a name="ln2354">    case OSPFNBMANBRPERMANENCE:</a>
<a name="ln2355">      return SNMP_INTEGER (2);</a>
<a name="ln2356">      break;</a>
<a name="ln2357">    case OSPFNBRHELLOSUPPRESSED:</a>
<a name="ln2358">      return SNMP_INTEGER (SNMP_FALSE);</a>
<a name="ln2359">      break;</a>
<a name="ln2360">    default:</a>
<a name="ln2361">      return NULL;</a>
<a name="ln2362">      break;</a>
<a name="ln2363">    }</a>
<a name="ln2364">  return NULL;</a>
<a name="ln2365">}</a>
<a name="ln2366"> </a>
<a name="ln2367">static u_char *</a>
<a name="ln2368">ospfVirtNbrEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln2369">		  size_t *var_len, WriteMethod **write_method)</a>
<a name="ln2370">{</a>
<a name="ln2371">  struct ospf_vl_data *vl_data;</a>
<a name="ln2372">  struct in_addr area_id;</a>
<a name="ln2373">  struct in_addr neighbor;</a>
<a name="ln2374">  struct ospf *ospf;</a>
<a name="ln2375"> </a>
<a name="ln2376">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln2377">      == MATCH_FAILED)</a>
<a name="ln2378">    return NULL;</a>
<a name="ln2379"> </a>
<a name="ln2380">  memset (&amp;area_id, 0, sizeof (struct in_addr));</a>
<a name="ln2381">  memset (&amp;neighbor, 0, sizeof (struct in_addr));</a>
<a name="ln2382"> </a>
<a name="ln2383">  /* Check OSPF instance. */</a>
<a name="ln2384">  ospf = ospf_lookup ();</a>
<a name="ln2385">  if (ospf == NULL)</a>
<a name="ln2386">    return NULL;</a>
<a name="ln2387"> </a>
<a name="ln2388">  vl_data = ospfVirtIfLookup (v, name, length, &amp;area_id, &amp;neighbor, exact);</a>
<a name="ln2389">  if (! vl_data)</a>
<a name="ln2390">    return NULL;</a>
<a name="ln2391"> </a>
<a name="ln2392">  /* Return the current value of the variable */</a>
<a name="ln2393">  switch (v-&gt;magic) </a>
<a name="ln2394">    {</a>
<a name="ln2395">    case OSPFVIRTNBRAREA:</a>
<a name="ln2396">      return (u_char *) NULL;</a>
<a name="ln2397">      break;</a>
<a name="ln2398">    case OSPFVIRTNBRRTRID:</a>
<a name="ln2399">      return (u_char *) NULL;</a>
<a name="ln2400">      break;</a>
<a name="ln2401">    case OSPFVIRTNBRIPADDR:</a>
<a name="ln2402">      return (u_char *) NULL;</a>
<a name="ln2403">      break;</a>
<a name="ln2404">    case OSPFVIRTNBROPTIONS:</a>
<a name="ln2405">      return (u_char *) NULL;</a>
<a name="ln2406">      break;</a>
<a name="ln2407">    case OSPFVIRTNBRSTATE:</a>
<a name="ln2408">      return (u_char *) NULL;</a>
<a name="ln2409">      break;</a>
<a name="ln2410">    case OSPFVIRTNBREVENTS:</a>
<a name="ln2411">      return (u_char *) NULL;</a>
<a name="ln2412">      break;</a>
<a name="ln2413">    case OSPFVIRTNBRLSRETRANSQLEN:</a>
<a name="ln2414">      return (u_char *) NULL;</a>
<a name="ln2415">      break;</a>
<a name="ln2416">    case OSPFVIRTNBRHELLOSUPPRESSED:</a>
<a name="ln2417">      return (u_char *) NULL;</a>
<a name="ln2418">      break;</a>
<a name="ln2419">    default:</a>
<a name="ln2420">      return NULL;</a>
<a name="ln2421">      break;</a>
<a name="ln2422">    }</a>
<a name="ln2423">  return NULL;</a>
<a name="ln2424">}</a>
<a name="ln2425"> </a>
<a name="ln2426">static struct ospf_lsa *</a>
<a name="ln2427">ospfExtLsdbLookup (struct variable *v, oid *name, size_t *length, u_char *type,</a>
<a name="ln2428">		   struct in_addr *ls_id, struct in_addr *router_id, int exact)</a>
<a name="ln2429">{</a>
<a name="ln2430">  int first;</a>
<a name="ln2431">  oid *offset;</a>
<a name="ln2432">  int offsetlen;</a>
<a name="ln2433">  u_char lsa_type;</a>
<a name="ln2434">  unsigned int len;</a>
<a name="ln2435">  struct ospf_lsa *lsa;</a>
<a name="ln2436">  struct ospf *ospf;</a>
<a name="ln2437"> </a>
<a name="ln2438">  ospf = ospf_lookup ();</a>
<a name="ln2439">  if (exact)</a>
<a name="ln2440">    {</a>
<a name="ln2441">      if (*length != v-&gt;namelen + 1 + IN_ADDR_SIZE + IN_ADDR_SIZE)</a>
<a name="ln2442">	return NULL;</a>
<a name="ln2443">      </a>
<a name="ln2444">      offset = name + v-&gt;namelen;</a>
<a name="ln2445"> </a>
<a name="ln2446">      /* Make it sure given value match to type. */</a>
<a name="ln2447">      lsa_type = *offset;</a>
<a name="ln2448">      offset++;</a>
<a name="ln2449"> </a>
<a name="ln2450">      if (lsa_type != *type)</a>
<a name="ln2451">	return NULL;</a>
<a name="ln2452">      </a>
<a name="ln2453">      /* LS ID. */</a>
<a name="ln2454">      oid2in_addr (offset, IN_ADDR_SIZE, ls_id);</a>
<a name="ln2455">      offset += IN_ADDR_SIZE;</a>
<a name="ln2456"> </a>
<a name="ln2457">      /* Router ID. */</a>
<a name="ln2458">      oid2in_addr (offset, IN_ADDR_SIZE, router_id);</a>
<a name="ln2459"> </a>
<a name="ln2460">      return ospf_lsdb_lookup_by_id (ospf-&gt;lsdb, *type, *ls_id, *router_id);</a>
<a name="ln2461">    }</a>
<a name="ln2462">  else</a>
<a name="ln2463">    {</a>
<a name="ln2464">      /* Get variable length. */</a>
<a name="ln2465">      first = 0;</a>
<a name="ln2466">      offset = name + v-&gt;namelen;</a>
<a name="ln2467">      offsetlen = *length - v-&gt;namelen;</a>
<a name="ln2468"> </a>
<a name="ln2469">      /* LSA type value. */</a>
<a name="ln2470">      lsa_type = *offset;</a>
<a name="ln2471">      offset++;</a>
<a name="ln2472">      offsetlen--;</a>
<a name="ln2473"> </a>
<a name="ln2474">      if (offsetlen &lt;= 0 || lsa_type &lt; OSPF_AS_EXTERNAL_LSA)</a>
<a name="ln2475">	first = 1;</a>
<a name="ln2476"> </a>
<a name="ln2477">      /* LS ID. */</a>
<a name="ln2478">      len = offsetlen;</a>
<a name="ln2479">      if (len &gt; IN_ADDR_SIZE)</a>
<a name="ln2480">	len = IN_ADDR_SIZE;</a>
<a name="ln2481"> </a>
<a name="ln2482">      oid2in_addr (offset, len, ls_id);</a>
<a name="ln2483"> </a>
<a name="ln2484">      offset += IN_ADDR_SIZE;</a>
<a name="ln2485">      offsetlen -= IN_ADDR_SIZE;</a>
<a name="ln2486"> </a>
<a name="ln2487">      /* Router ID. */</a>
<a name="ln2488">      len = offsetlen;</a>
<a name="ln2489">      if (len &gt; IN_ADDR_SIZE)</a>
<a name="ln2490">	len = IN_ADDR_SIZE;</a>
<a name="ln2491"> </a>
<a name="ln2492">      oid2in_addr (offset, len, router_id);</a>
<a name="ln2493"> </a>
<a name="ln2494">      lsa = ospf_lsdb_lookup_by_id_next (ospf-&gt;lsdb, *type, *ls_id,</a>
<a name="ln2495">					*router_id, first);</a>
<a name="ln2496"> </a>
<a name="ln2497">      if (lsa)</a>
<a name="ln2498">	{</a>
<a name="ln2499">	  /* Fill in length. */</a>
<a name="ln2500">	  *length = v-&gt;namelen + 1 + IN_ADDR_SIZE + IN_ADDR_SIZE;</a>
<a name="ln2501"> </a>
<a name="ln2502">	  /* Fill in value. */</a>
<a name="ln2503">	  offset = name + v-&gt;namelen;</a>
<a name="ln2504"> </a>
<a name="ln2505">	  *offset = OSPF_AS_EXTERNAL_LSA;</a>
<a name="ln2506">	  offset++;</a>
<a name="ln2507">	  oid_copy_addr (offset, &amp;lsa-&gt;data-&gt;id, IN_ADDR_SIZE);</a>
<a name="ln2508">	  offset += IN_ADDR_SIZE;</a>
<a name="ln2509">	  oid_copy_addr (offset, &amp;lsa-&gt;data-&gt;adv_router, IN_ADDR_SIZE);</a>
<a name="ln2510">	    </a>
<a name="ln2511">	  return lsa;</a>
<a name="ln2512">	}</a>
<a name="ln2513">    }</a>
<a name="ln2514">  return NULL;</a>
<a name="ln2515">}</a>
<a name="ln2516"> </a>
<a name="ln2517">static u_char *</a>
<a name="ln2518">ospfExtLsdbEntry (struct variable *v, oid *name, size_t *length, int exact,</a>
<a name="ln2519">		  size_t *var_len, WriteMethod **write_method)</a>
<a name="ln2520">{</a>
<a name="ln2521">  struct ospf_lsa *lsa;</a>
<a name="ln2522">  struct lsa_header *lsah;</a>
<a name="ln2523">  u_char type;</a>
<a name="ln2524">  struct in_addr ls_id;</a>
<a name="ln2525">  struct in_addr router_id;</a>
<a name="ln2526">  struct ospf *ospf;</a>
<a name="ln2527"> </a>
<a name="ln2528">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln2529">      == MATCH_FAILED)</a>
<a name="ln2530">    return NULL;</a>
<a name="ln2531"> </a>
<a name="ln2532">  type = OSPF_AS_EXTERNAL_LSA;</a>
<a name="ln2533">  memset (&amp;ls_id, 0, sizeof (struct in_addr));</a>
<a name="ln2534">  memset (&amp;router_id, 0, sizeof (struct in_addr));</a>
<a name="ln2535"> </a>
<a name="ln2536">  /* Check OSPF instance. */</a>
<a name="ln2537">  ospf = ospf_lookup ();</a>
<a name="ln2538">  if (ospf == NULL)</a>
<a name="ln2539">    return NULL;</a>
<a name="ln2540"> </a>
<a name="ln2541">  lsa = ospfExtLsdbLookup (v, name, length, &amp;type, &amp;ls_id, &amp;router_id, exact);</a>
<a name="ln2542">  if (! lsa)</a>
<a name="ln2543">    return NULL;</a>
<a name="ln2544"> </a>
<a name="ln2545">  lsah = lsa-&gt;data;</a>
<a name="ln2546"> </a>
<a name="ln2547">  /* Return the current value of the variable */</a>
<a name="ln2548">  switch (v-&gt;magic) </a>
<a name="ln2549">    {</a>
<a name="ln2550">    case OSPFEXTLSDBTYPE:</a>
<a name="ln2551">      return SNMP_INTEGER (OSPF_AS_EXTERNAL_LSA);</a>
<a name="ln2552">      break;</a>
<a name="ln2553">    case OSPFEXTLSDBLSID:</a>
<a name="ln2554">      return SNMP_IPADDRESS (lsah-&gt;id);</a>
<a name="ln2555">      break;</a>
<a name="ln2556">    case OSPFEXTLSDBROUTERID:</a>
<a name="ln2557">      return SNMP_IPADDRESS (lsah-&gt;adv_router);</a>
<a name="ln2558">      break;</a>
<a name="ln2559">    case OSPFEXTLSDBSEQUENCE:</a>
<a name="ln2560">      return SNMP_INTEGER (lsah-&gt;ls_seqnum);</a>
<a name="ln2561">      break;</a>
<a name="ln2562">    case OSPFEXTLSDBAGE:</a>
<a name="ln2563">      return SNMP_INTEGER (lsah-&gt;ls_age);</a>
<a name="ln2564">      break;</a>
<a name="ln2565">    case OSPFEXTLSDBCHECKSUM:</a>
<a name="ln2566">      return SNMP_INTEGER (lsah-&gt;checksum);</a>
<a name="ln2567">      break;</a>
<a name="ln2568">    case OSPFEXTLSDBADVERTISEMENT:</a>
<a name="ln2569">      *var_len = ntohs (lsah-&gt;length);</a>
<a name="ln2570">      return (u_char *) lsah;</a>
<a name="ln2571">      break;</a>
<a name="ln2572">    default:</a>
<a name="ln2573">      return NULL;</a>
<a name="ln2574">      break;</a>
<a name="ln2575">    }</a>
<a name="ln2576">  return NULL;</a>
<a name="ln2577">}</a>
<a name="ln2578"> </a>
<a name="ln2579">static u_char *</a>
<a name="ln2580">ospfAreaAggregateEntry (struct variable *v, oid *name, size_t *length,</a>
<a name="ln2581">			int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln2582">{</a>
<a name="ln2583">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln2584">      == MATCH_FAILED)</a>
<a name="ln2585">    return NULL;</a>
<a name="ln2586"> </a>
<a name="ln2587">  /* Return the current value of the variable */</a>
<a name="ln2588">  switch (v-&gt;magic) </a>
<a name="ln2589">    {</a>
<a name="ln2590">    case OSPFAREAAGGREGATEAREAID:</a>
<a name="ln2591">      return (u_char *) NULL;</a>
<a name="ln2592">      break;</a>
<a name="ln2593">    case OSPFAREAAGGREGATELSDBTYPE:</a>
<a name="ln2594">      return (u_char *) NULL;</a>
<a name="ln2595">      break;</a>
<a name="ln2596">    case OSPFAREAAGGREGATENET:</a>
<a name="ln2597">      return (u_char *) NULL;</a>
<a name="ln2598">      break;</a>
<a name="ln2599">    case OSPFAREAAGGREGATEMASK:</a>
<a name="ln2600">      return (u_char *) NULL;</a>
<a name="ln2601">      break;</a>
<a name="ln2602">    case OSPFAREAAGGREGATESTATUS:</a>
<a name="ln2603">      return (u_char *) NULL;</a>
<a name="ln2604">      break;</a>
<a name="ln2605">    case OSPFAREAAGGREGATEEFFECT:</a>
<a name="ln2606">      return (u_char *) NULL;</a>
<a name="ln2607">      break;</a>
<a name="ln2608">    default:</a>
<a name="ln2609">      return NULL;</a>
<a name="ln2610">      break;</a>
<a name="ln2611">    }</a>
<a name="ln2612">  return NULL;</a>
<a name="ln2613">}</a>
<a name="ln2614"> </a>
<a name="ln2615">/* OSPF Traps. */</a>
<a name="ln2616">#define IFSTATECHANGE      16</a>
<a name="ln2617">#define VIRTIFSTATECHANGE   1</a>
<a name="ln2618">#define NBRSTATECHANGE      2</a>
<a name="ln2619">#define VIRTNBRSTATECHANGE  3</a>
<a name="ln2620"> </a>
<a name="ln2621">struct trap_object ospfNbrTrapList[] =</a>
<a name="ln2622">{</a>
<a name="ln2623">  {-2, {1, OSPFROUTERID}},</a>
<a name="ln2624">  {3, {10, 1, OSPFNBRIPADDR}},</a>
<a name="ln2625">  {3, {10, 1, OSPFNBRRTRID}},</a>
<a name="ln2626">  {3, {10, 1, OSPFNBRSTATE}}</a>
<a name="ln2627">};</a>
<a name="ln2628"> </a>
<a name="ln2629"> </a>
<a name="ln2630">struct trap_object ospfVirtNbrTrapList[] =</a>
<a name="ln2631">{</a>
<a name="ln2632">  {-2, {1, 1}},</a>
<a name="ln2633">  {3, {11, 1, OSPFVIRTNBRAREA}},</a>
<a name="ln2634">  {3, {11, 1, OSPFVIRTNBRRTRID}},</a>
<a name="ln2635">  {3, {11, 1, OSPFVIRTNBRSTATE}}</a>
<a name="ln2636">};</a>
<a name="ln2637"> </a>
<a name="ln2638">struct trap_object ospfIfTrapList[] =</a>
<a name="ln2639">{</a>
<a name="ln2640">  {-2, {1, OSPFROUTERID}},</a>
<a name="ln2641">  {3, {7, 1, OSPFIFIPADDRESS}},</a>
<a name="ln2642">  {3, {7, 1, OSPFADDRESSLESSIF}},</a>
<a name="ln2643">  {3, {7, 1, OSPFIFSTATE}}</a>
<a name="ln2644">};</a>
<a name="ln2645"> </a>
<a name="ln2646">struct trap_object ospfVirtIfTrapList[] =</a>
<a name="ln2647">{</a>
<a name="ln2648">  {-2, {1, OSPFROUTERID}},</a>
<a name="ln2649">  {3, {9, 1, OSPFVIRTIFAREAID}},</a>
<a name="ln2650">  {3, {9, 1, OSPFVIRTIFNEIGHBOR}},</a>
<a name="ln2651">  {3, {9, 1, OSPFVIRTIFSTATE}}</a>
<a name="ln2652">};</a>
<a name="ln2653"> </a>
<a name="ln2654">void</a>
<a name="ln2655">ospfTrapNbrStateChange (struct ospf_neighbor *on)</a>
<a name="ln2656">{</a>
<a name="ln2657">  oid index[sizeof (oid) * (IN_ADDR_SIZE + 1)];</a>
<a name="ln2658">  char msgbuf[16];</a>
<a name="ln2659">  </a>
<a name="ln2660">  ospf_nbr_state_message(on, msgbuf, sizeof(msgbuf));</a>
<a name="ln2661">  zlog (NULL, LOG_INFO, &quot;ospfTrapNbrStateChange trap sent: %s now %s&quot;,</a>
<a name="ln2662">	inet_ntoa(on-&gt;address.u.prefix4), msgbuf);</a>
<a name="ln2663"> </a>
<a name="ln2664">  oid_copy_addr (index, &amp;(on-&gt;address.u.prefix4), IN_ADDR_SIZE);</a>
<a name="ln2665">  index[IN_ADDR_SIZE] = 0;</a>
<a name="ln2666"> </a>
<a name="ln2667">  smux_trap (ospf_variables, sizeof ospf_variables / sizeof (struct variable),</a>
<a name="ln2668">	     ospf_trap_oid, sizeof ospf_trap_oid / sizeof (oid),</a>
<a name="ln2669">	     ospf_oid, sizeof ospf_oid / sizeof (oid),</a>
<a name="ln2670">             index,  IN_ADDR_SIZE + 1,</a>
<a name="ln2671">             ospfNbrTrapList, </a>
<a name="ln2672">             sizeof ospfNbrTrapList / sizeof (struct trap_object),</a>
<a name="ln2673">             NBRSTATECHANGE);</a>
<a name="ln2674">}</a>
<a name="ln2675"> </a>
<a name="ln2676">void</a>
<a name="ln2677">ospfTrapVirtNbrStateChange (struct ospf_neighbor *on)</a>
<a name="ln2678">{</a>
<a name="ln2679">  oid index[sizeof (oid) * (IN_ADDR_SIZE + 1)];</a>
<a name="ln2680">  </a>
<a name="ln2681">  zlog (NULL, LOG_INFO, &quot;ospfTrapVirtNbrStateChange trap sent&quot;);</a>
<a name="ln2682"> </a>
<a name="ln2683">  oid_copy_addr (index, &amp;(on-&gt;address.u.prefix4), IN_ADDR_SIZE);</a>
<a name="ln2684">  index[IN_ADDR_SIZE] = 0;</a>
<a name="ln2685"> </a>
<a name="ln2686">  smux_trap (ospf_variables, sizeof ospf_variables / sizeof (struct variable),</a>
<a name="ln2687">	     ospf_trap_oid, sizeof ospf_trap_oid / sizeof (oid),</a>
<a name="ln2688">	     ospf_oid, sizeof ospf_oid / sizeof (oid),</a>
<a name="ln2689">             index,  IN_ADDR_SIZE + 1,</a>
<a name="ln2690">             ospfVirtNbrTrapList, </a>
<a name="ln2691">             sizeof ospfVirtNbrTrapList / sizeof (struct trap_object),</a>
<a name="ln2692">             VIRTNBRSTATECHANGE);</a>
<a name="ln2693">}</a>
<a name="ln2694"> </a>
<a name="ln2695">void</a>
<a name="ln2696">ospfTrapIfStateChange (struct ospf_interface *oi)</a>
<a name="ln2697">{</a>
<a name="ln2698">  oid index[sizeof (oid) * (IN_ADDR_SIZE + 1)];</a>
<a name="ln2699"> </a>
<a name="ln2700">  zlog (NULL, LOG_INFO, &quot;ospfTrapIfStateChange trap sent: %s now %s&quot;,</a>
<a name="ln2701">  	inet_ntoa(oi-&gt;address-&gt;u.prefix4),</a>
<a name="ln2702">	LOOKUP(ospf_ism_state_msg, oi-&gt;state));</a>
<a name="ln2703">  </a>
<a name="ln2704">  oid_copy_addr (index, &amp;(oi-&gt;address-&gt;u.prefix4), IN_ADDR_SIZE);</a>
<a name="ln2705">  index[IN_ADDR_SIZE] = 0;</a>
<a name="ln2706"> </a>
<a name="ln2707">  smux_trap (ospf_variables, sizeof ospf_variables / sizeof (struct variable),</a>
<a name="ln2708">	     ospf_trap_oid, sizeof ospf_trap_oid / sizeof (oid),</a>
<a name="ln2709">	     ospf_oid, sizeof ospf_oid / sizeof (oid),</a>
<a name="ln2710">             index, IN_ADDR_SIZE + 1,</a>
<a name="ln2711">             ospfIfTrapList, </a>
<a name="ln2712">             sizeof ospfIfTrapList / sizeof (struct trap_object),</a>
<a name="ln2713">             IFSTATECHANGE);</a>
<a name="ln2714">}</a>
<a name="ln2715"> </a>
<a name="ln2716">void</a>
<a name="ln2717">ospfTrapVirtIfStateChange (struct ospf_interface *oi)</a>
<a name="ln2718">{</a>
<a name="ln2719">  oid index[sizeof (oid) * (IN_ADDR_SIZE + 1)];</a>
<a name="ln2720"> </a>
<a name="ln2721">  zlog (NULL, LOG_INFO, &quot;ospfTrapVirtIfStateChange trap sent&quot;);</a>
<a name="ln2722">  </a>
<a name="ln2723">  oid_copy_addr (index, &amp;(oi-&gt;address-&gt;u.prefix4), IN_ADDR_SIZE);</a>
<a name="ln2724">  index[IN_ADDR_SIZE] = 0;</a>
<a name="ln2725"> </a>
<a name="ln2726">  smux_trap (ospf_variables, sizeof ospf_variables / sizeof (struct variable),</a>
<a name="ln2727">	     ospf_trap_oid, sizeof ospf_trap_oid / sizeof (oid),</a>
<a name="ln2728">	     ospf_oid, sizeof ospf_oid / sizeof (oid),</a>
<a name="ln2729">             index, IN_ADDR_SIZE + 1,</a>
<a name="ln2730">             ospfVirtIfTrapList,</a>
<a name="ln2731">             sizeof ospfVirtIfTrapList / sizeof (struct trap_object),</a>
<a name="ln2732">             VIRTIFSTATECHANGE);</a>
<a name="ln2733">}</a>
<a name="ln2734">/* Register OSPF2-MIB. */</a>
<a name="ln2735">void</a>
<a name="ln2736">ospf_snmp_init ()</a>
<a name="ln2737">{</a>
<a name="ln2738">  ospf_snmp_iflist = list_new ();</a>
<a name="ln2739">  ospf_snmp_vl_table = route_table_init ();</a>
<a name="ln2740">  smux_init (om-&gt;master);</a>
<a name="ln2741">  REGISTER_MIB(&quot;mibII/ospf&quot;, ospf_variables, variable, ospf_oid);</a>
<a name="ln2742">}</a>
<a name="ln2743">#endif /* HAVE_SNMP */</a>

</code></pre>
<div class="balloon" rel="10"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
