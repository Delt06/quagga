
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_network.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF network related functions</a>
<a name="ln3"> *   Copyright (C) 1999 Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;linklist.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;if.h&quot;</a>
<a name="ln29">#include &quot;sockunion.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31">#include &quot;sockopt.h&quot;</a>
<a name="ln32">#include &quot;privs.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">extern struct zebra_privs_t ospfd_privs;</a>
<a name="ln35"> </a>
<a name="ln36">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_network.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">/* Join to the OSPF ALL SPF ROUTERS multicast group. */</a>
<a name="ln49">int</a>
<a name="ln50">ospf_if_add_allspfrouters (struct ospf *top, struct prefix *p,</a>
<a name="ln51">			   ifindex_t ifindex)</a>
<a name="ln52">{</a>
<a name="ln53">  int ret;</a>
<a name="ln54">  </a>
<a name="ln55">  ret = setsockopt_ipv4_multicast (top-&gt;fd, IP_ADD_MEMBERSHIP,</a>
<a name="ln56">                                   htonl (OSPF_ALLSPFROUTERS),</a>
<a name="ln57">                                   ifindex);</a>
<a name="ln58">  if (ret &lt; 0)</a>
<a name="ln59">    zlog_warn (&quot;can't setsockopt IP_ADD_MEMBERSHIP (fd %d, addr %s, &quot;</a>
<a name="ln60">	       &quot;ifindex %u, AllSPFRouters): %s; perhaps a kernel limit &quot;</a>
<a name="ln61">	       &quot;on # of multicast group memberships has been exceeded?&quot;,</a>
<a name="ln62">               top-&gt;fd, inet_ntoa(p-&gt;u.prefix4), ifindex, safe_strerror(errno));</a>
<a name="ln63">  else</a>
<a name="ln64">    zlog_debug (&quot;interface %s [%u] join AllSPFRouters Multicast group.&quot;,</a>
<a name="ln65">	       inet_ntoa (p-&gt;u.prefix4), ifindex);</a>
<a name="ln66"> </a>
<a name="ln67">  return ret;</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70">int</a>
<a name="ln71">ospf_if_drop_allspfrouters (struct ospf *top, struct prefix *p,</a>
<a name="ln72">			    ifindex_t ifindex)</a>
<a name="ln73">{</a>
<a name="ln74">  int ret;</a>
<a name="ln75"> </a>
<a name="ln76">  ret = setsockopt_ipv4_multicast (top-&gt;fd, IP_DROP_MEMBERSHIP,</a>
<a name="ln77">                                   htonl (OSPF_ALLSPFROUTERS),</a>
<a name="ln78">                                   ifindex);</a>
<a name="ln79">  if (ret &lt; 0)</a>
<a name="ln80">    zlog_warn (&quot;can't setsockopt IP_DROP_MEMBERSHIP (fd %d, addr %s, &quot;</a>
<a name="ln81">	       &quot;ifindex %u, AllSPFRouters): %s&quot;,</a>
<a name="ln82">               top-&gt;fd, inet_ntoa(p-&gt;u.prefix4), ifindex, safe_strerror(errno));</a>
<a name="ln83">  else</a>
<a name="ln84">    zlog_debug (&quot;interface %s [%u] leave AllSPFRouters Multicast group.&quot;,</a>
<a name="ln85">	        inet_ntoa (p-&gt;u.prefix4), ifindex);</a>
<a name="ln86"> </a>
<a name="ln87">  return ret;</a>
<a name="ln88">}</a>
<a name="ln89"> </a>
<a name="ln90">/* Join to the OSPF ALL Designated ROUTERS multicast group. */</a>
<a name="ln91">int</a>
<a name="ln92">ospf_if_add_alldrouters (struct ospf *top, struct prefix *p, ifindex_t ifindex)</a>
<a name="ln93">{</a>
<a name="ln94">  int ret;</a>
<a name="ln95"> </a>
<a name="ln96">  ret = setsockopt_ipv4_multicast (top-&gt;fd, IP_ADD_MEMBERSHIP,</a>
<a name="ln97">                                   htonl (OSPF_ALLDROUTERS),</a>
<a name="ln98">                                   ifindex);</a>
<a name="ln99">  if (ret &lt; 0)</a>
<a name="ln100">    zlog_warn (&quot;can't setsockopt IP_ADD_MEMBERSHIP (fd %d, addr %s, &quot;</a>
<a name="ln101">	       &quot;ifindex %u, AllDRouters): %s; perhaps a kernel limit &quot;</a>
<a name="ln102">	       &quot;on # of multicast group memberships has been exceeded?&quot;,</a>
<a name="ln103">               top-&gt;fd, inet_ntoa(p-&gt;u.prefix4), ifindex, safe_strerror(errno));</a>
<a name="ln104">  else</a>
<a name="ln105">    zlog_debug (&quot;interface %s [%u] join AllDRouters Multicast group.&quot;,</a>
<a name="ln106">	        inet_ntoa (p-&gt;u.prefix4), ifindex);</a>
<a name="ln107"> </a>
<a name="ln108">  return ret;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">int</a>
<a name="ln112">ospf_if_drop_alldrouters (struct ospf *top, struct prefix *p, ifindex_t ifindex)</a>
<a name="ln113">{</a>
<a name="ln114">  int ret;</a>
<a name="ln115"> </a>
<a name="ln116">  ret = setsockopt_ipv4_multicast (top-&gt;fd, IP_DROP_MEMBERSHIP,</a>
<a name="ln117">                                   htonl (OSPF_ALLDROUTERS),</a>
<a name="ln118">                                   ifindex);</a>
<a name="ln119">  if (ret &lt; 0)</a>
<a name="ln120">    zlog_warn (&quot;can't setsockopt IP_DROP_MEMBERSHIP (fd %d, addr %s, &quot;</a>
<a name="ln121">	       &quot;ifindex %u, AllDRouters): %s&quot;,</a>
<a name="ln122">               top-&gt;fd, inet_ntoa(p-&gt;u.prefix4), ifindex, safe_strerror(errno));</a>
<a name="ln123">  else</a>
<a name="ln124">    zlog_debug (&quot;interface %s [%u] leave AllDRouters Multicast group.&quot;,</a>
<a name="ln125">	        inet_ntoa (p-&gt;u.prefix4), ifindex);</a>
<a name="ln126"> </a>
<a name="ln127">  return ret;</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">int</a>
<a name="ln131">ospf_if_ipmulticast (struct ospf *top, struct prefix *p, ifindex_t ifindex)</a>
<a name="ln132">{</a>
<a name="ln133">  u_char val;</a>
<a name="ln134">  int ret, len;</a>
<a name="ln135">  </a>
<a name="ln136">  val = 0;</a>
<a name="ln137">  len = sizeof (val);</a>
<a name="ln138">  </a>
<a name="ln139">  /* Prevent receiving self-origined multicast packets. */</a>
<a name="ln140">  ret = setsockopt (top-&gt;fd, IPPROTO_IP, IP_MULTICAST_LOOP, (void *)&amp;val, len);</a>
<a name="ln141">  if (ret &lt; 0)</a>
<a name="ln142">    zlog_warn (&quot;can't setsockopt IP_MULTICAST_LOOP(0) for fd %d: %s&quot;,</a>
<a name="ln143">	       top-&gt;fd, safe_strerror(errno));</a>
<a name="ln144">  </a>
<a name="ln145">  /* Explicitly set multicast ttl to 1 -- endo. */</a>
<a name="ln146">  val = 1;</a>
<a name="ln147">  ret = setsockopt (top-&gt;fd, IPPROTO_IP, IP_MULTICAST_TTL, (void *)&amp;val, len);</a>
<a name="ln148">  if (ret &lt; 0)</a>
<a name="ln149">    zlog_warn (&quot;can't setsockopt IP_MULTICAST_TTL(1) for fd %d: %s&quot;,</a>
<a name="ln150">	       top-&gt;fd, safe_strerror (errno));</a>
<a name="ln151"> </a>
<a name="ln152">  ret = setsockopt_ipv4_multicast_if (top-&gt;fd, ifindex);</a>
<a name="ln153">  if (ret &lt; 0)</a>
<a name="ln154">    zlog_warn(&quot;can't setsockopt IP_MULTICAST_IF(fd %d, addr %s, &quot;</a>
<a name="ln155">	      &quot;ifindex %u): %s&quot;,</a>
<a name="ln156">	      top-&gt;fd, inet_ntoa(p-&gt;u.prefix4), ifindex, safe_strerror(errno));</a>
<a name="ln157"> </a>
<a name="ln158">  return ret;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">int</a>
<a name="ln162">ospf_sock_init (void)</a>
<a name="ln163">{</a>
<a name="ln164">  int ospf_sock;</a>
<a name="ln165">  int ret, hincl = 1;</a>
<a name="ln166"> </a>
<a name="ln167">  if ( ospfd_privs.change (ZPRIVS_RAISE) )</a>
<a name="ln168">    zlog_err (&quot;ospf_sock_init: could not raise privs, %s&quot;,</a>
<a name="ln169">               safe_strerror (errno) );</a>
<a name="ln170">    </a>
<a name="ln171">  ospf_sock = socket (AF_INET, SOCK_RAW, IPPROTO_OSPFIGP);</a>
<a name="ln172">  if (ospf_sock &lt; 0)</a>
<a name="ln173">    {</a>
<a name="ln174">      int save_errno = errno;</a>
<a name="ln175">      if ( ospfd_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln176">        zlog_err (&quot;ospf_sock_init: could not lower privs, %s&quot;,</a>
<a name="ln177">                   safe_strerror (errno) );</a>
<a name="ln178">      zlog_err (&quot;ospf_read_sock_init: socket: %s&quot;, safe_strerror (save_errno));</a>
<a name="ln179">      exit(1);</a>
<a name="ln180">    }</a>
<a name="ln181">    </a>
<a name="ln182">#ifdef IP_HDRINCL</a>
<a name="ln183">  /* we will include IP header with packet */</a>
<a name="ln184">  ret = setsockopt (ospf_sock, IPPROTO_IP, IP_HDRINCL, &amp;hincl, sizeof (hincl));</a>
<a name="ln185">  if (ret &lt; 0)</a>
<a name="ln186">    {</a>
<a name="ln187">      int save_errno = errno;</a>
<a name="ln188">      if ( ospfd_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln189">        zlog_err (&quot;ospf_sock_init: could not lower privs, %s&quot;,</a>
<a name="ln190">                   safe_strerror (errno) );</a>
<a name="ln191">      zlog_warn (&quot;Can't set IP_HDRINCL option for fd %d: %s&quot;,</a>
<a name="ln192">      		 ospf_sock, safe_strerror(save_errno));</a>
<a name="ln193">    }</a>
<a name="ln194">#elif defined (IPTOS_PREC_INTERNETCONTROL)</a>
<a name="ln195">#warning &quot;IP_HDRINCL not available on this system&quot;</a>
<a name="ln196">#warning &quot;using IPTOS_PREC_INTERNETCONTROL&quot;</a>
<a name="ln197">  ret = setsockopt_ipv4_tos(ospf_sock, IPTOS_PREC_INTERNETCONTROL);</a>
<a name="ln198">  if (ret &lt; 0)</a>
<a name="ln199">    {</a>
<a name="ln200">      int save_errno = errno;</a>
<a name="ln201">      if ( ospfd_privs.change (ZPRIVS_LOWER) )</a>
<a name="ln202">        zlog_err (&quot;ospf_sock_init: could not lower privs, %s&quot;,</a>
<a name="ln203">                   safe_strerror (errno) );</a>
<a name="ln204">      zlog_warn (&quot;can't set sockopt IP_TOS %d to socket %d: %s&quot;,</a>
<a name="ln205">      		 tos, ospf_sock, safe_strerror(save_errno));</a>
<a name="ln206">      close (ospf_sock);	/* Prevent sd leak. */</a>
<a name="ln207">      return ret;</a>
<a name="ln208">    }</a>
<a name="ln209">#else /* !IPTOS_PREC_INTERNETCONTROL */</a>
<a name="ln210">#warning &quot;IP_HDRINCL not available, nor is IPTOS_PREC_INTERNETCONTROL&quot;</a>
<a name="ln211">  zlog_warn (&quot;IP_HDRINCL option not available&quot;);</a>
<a name="ln212">#endif /* IP_HDRINCL */</a>
<a name="ln213"> </a>
<a name="ln214">  ret = setsockopt_ifindex (AF_INET, ospf_sock, 1);</a>
<a name="ln215"> </a>
<a name="ln216">  if (ret &lt; 0)</a>
<a name="ln217">     zlog_warn (&quot;Can't set pktinfo option for fd %d&quot;, ospf_sock);</a>
<a name="ln218"> </a>
<a name="ln219">  if (ospfd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln220">    {</a>
<a name="ln221">      zlog_err (&quot;ospf_sock_init: could not lower privs, %s&quot;,</a>
<a name="ln222">               safe_strerror (errno) );</a>
<a name="ln223">    }</a>
<a name="ln224"> </a>
<a name="ln225">  return ospf_sock;</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">void</a>
<a name="ln229">ospf_adjust_sndbuflen (struct ospf * ospf, unsigned int buflen)</a>
<a name="ln230">{</a>
<a name="ln231">  int ret, newbuflen;</a>
<a name="ln232">  /* Check if any work has to be done at all. */</a>
<a name="ln233">  if (ospf-&gt;maxsndbuflen &gt;= buflen)</a>
<a name="ln234">    return;</a>
<a name="ln235">  if (IS_DEBUG_OSPF (zebra, ZEBRA_INTERFACE))</a>
<a name="ln236">    zlog_debug (&quot;%s: adjusting OSPF send buffer size to %d&quot;,</a>
<a name="ln237">      __func__, buflen);</a>
<a name="ln238">  if (ospfd_privs.change (ZPRIVS_RAISE))</a>
<a name="ln239">    zlog_err (&quot;%s: could not raise privs, %s&quot;, __func__,</a>
<a name="ln240">      safe_strerror (errno));</a>
<a name="ln241">  /* Now we try to set SO_SNDBUF to what our caller has requested</a>
<a name="ln242">   * (the MTU of a newly added interface). However, if the OS has</a>
<a name="ln243">   * truncated the actual buffer size to somewhat less size, try</a>
<a name="ln244">   * to detect it and update our records appropriately. The OS</a>
<a name="ln245">   * may allocate more buffer space, than requested, this isn't</a>
<a name="ln246">   * a error.</a>
<a name="ln247">   */</a>
<a name="ln248">  ret = setsockopt_so_sendbuf (ospf-&gt;fd, buflen);</a>
<a name="ln249">  newbuflen = getsockopt_so_sendbuf (ospf-&gt;fd);</a>
<a name="ln250">  if (ret &lt; 0 || newbuflen &lt; 0 || newbuflen &lt; (int) buflen)</a>
<a name="ln251">    zlog_warn (&quot;%s: tried to set SO_SNDBUF to %u, but got %d&quot;,</a>
<a name="ln252">      __func__, buflen, newbuflen);</a>
<a name="ln253">  if (newbuflen &gt;= 0)</a>
<a name="ln254">    ospf-&gt;maxsndbuflen = (unsigned int)newbuflen;</a>
<a name="ln255">  else</a>
<a name="ln256">    zlog_warn (&quot;%s: failed to get SO_SNDBUF&quot;, __func__);</a>
<a name="ln257">  if (ospfd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln258">    zlog_err (&quot;%s: could not lower privs, %s&quot;, __func__,</a>
<a name="ln259">      safe_strerror (errno));</a>
<a name="ln260">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
