
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf6_lsa.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (C) 2003 Yasuhiro Ohara</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the </a>
<a name="ln18"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330, </a>
<a name="ln19"> * Boston, MA 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">/* Include other stuffs */</a>
<a name="ln25">#include &quot;log.h&quot;</a>
<a name="ln26">#include &quot;linklist.h&quot;</a>
<a name="ln27">#include &quot;vector.h&quot;</a>
<a name="ln28">#include &quot;vty.h&quot;</a>
<a name="ln29">#include &quot;command.h&quot;</a>
<a name="ln30">#include &quot;memory.h&quot;</a>
<a name="ln31">#include &quot;thread.h&quot;</a>
<a name="ln32">#include &quot;checksum.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;ospf6_proto.h&quot;</a>
<a name="ln35">#include &quot;ospf6_lsa.h&quot;</a>
<a name="ln36">#include &quot;ospf6_lsdb.h&quot;</a>
<a name="ln37">#include &quot;ospf6_message.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">#include &quot;ospf6_top.h&quot;</a>
<a name="ln40">#include &quot;ospf6_area.h&quot;</a>
<a name="ln41">#include &quot;ospf6_interface.h&quot;</a>
<a name="ln42">#include &quot;ospf6_neighbor.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;ospf6_flood.h&quot;</a>
<a name="ln45">#include &quot;ospf6d.h&quot;</a>
<a name="ln46"> </a>
<a name="ln47">vector ospf6_lsa_handler_vector;</a>
<a name="ln48"> </a>
<a name="ln49">static int</a>
<a name="ln50">ospf6_unknown_lsa_show (struct vty *vty, struct ospf6_lsa *lsa)</a>
<a name="ln51">{</a>
<a name="ln52">  u_char *start, *end, *current;</a>
<a name="ln53">  char byte[4];</a>
<a name="ln54"> </a>
<a name="ln55">  start = (u_char *) lsa-&gt;header + sizeof (struct ospf6_lsa_header);</a>
<a name="ln56">  end = (u_char *) lsa-&gt;header + ntohs (lsa-&gt;header-&gt;length);</a>
<a name="ln57"> </a>
<a name="ln58">  vty_out (vty, &quot;        Unknown contents:%s&quot;, VNL);</a>
<a name="ln59">  for (current = start; current &lt; end; current ++)</a>
<a name="ln60">    {</a>
<a name="ln61">      if ((current - start) % 16 == 0)</a>
<a name="ln62">        vty_out (vty, &quot;%s        &quot;, VNL);</a>
<a name="ln63">      else if ((current - start) % 4 == 0)</a>
<a name="ln64">        vty_out (vty, &quot; &quot;);</a>
<a name="ln65"> </a>
<a name="ln66">      snprintf (byte, sizeof (byte), &quot;%02x&quot;, *current);</a>
<a name="ln67">      vty_out (vty, &quot;%s&quot;, byte);</a>
<a name="ln68">    }</a>
<a name="ln69"> </a>
<a name="ln70">  vty_out (vty, &quot;%s%s&quot;, VNL, VNL);</a>
<a name="ln71">  return 0;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">struct ospf6_lsa_handler unknown_handler =</a>
<a name="ln75">{</a>
<a name="ln76">  OSPF6_LSTYPE_UNKNOWN,</a>
<a name="ln77">  &quot;Unknown&quot;,</a>
<a name="ln78">  &quot;Unk&quot;,</a>
<a name="ln79">  ospf6_unknown_lsa_show,</a>
<a name="ln80">  NULL,</a>
<a name="ln81">  OSPF6_LSA_DEBUG,</a>
<a name="ln82">};</a>
<a name="ln83"> </a>
<a name="ln84">void</a>
<a name="ln85">ospf6_install_lsa_handler (struct ospf6_lsa_handler *handler)</a>
<a name="ln86">{</a>
<a name="ln87">  /* type in handler is host byte order */</a>
<a name="ln88">  int index = handler-&gt;type &amp; OSPF6_LSTYPE_FCODE_MASK;</a>
<a name="ln89">  vector_set_index (ospf6_lsa_handler_vector, index, handler);</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">struct ospf6_lsa_handler *</a>
<a name="ln93">ospf6_get_lsa_handler (u_int16_t type)</a>
<a name="ln94">{</a>
<a name="ln95">  struct ospf6_lsa_handler *handler = NULL;</a>
<a name="ln96">  unsigned int index = ntohs (type) &amp; OSPF6_LSTYPE_FCODE_MASK;</a>
<a name="ln97"> </a>
<a name="ln98">  if (index &gt;= vector_active (ospf6_lsa_handler_vector))</a>
<a name="ln99">    handler = &amp;unknown_handler;</a>
<a name="ln100">  else</a>
<a name="ln101">    handler = vector_slot (ospf6_lsa_handler_vector, index);</a>
<a name="ln102"> </a>
<a name="ln103">  if (handler == NULL)</a>
<a name="ln104">    handler = &amp;unknown_handler;</a>
<a name="ln105"> </a>
<a name="ln106">  return handler;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">const char *</a>
<a name="ln110">ospf6_lstype_name (u_int16_t type)</a>
<a name="ln111">{</a>
<a name="ln112">  static char buf[8];</a>
<a name="ln113">  struct ospf6_lsa_handler *handler;</a>
<a name="ln114"> </a>
<a name="ln115">  handler = ospf6_get_lsa_handler (type);</a>
<a name="ln116">  if (handler &amp;&amp; handler != &amp;unknown_handler)</a>
<a name="ln117">    return handler-&gt;name;</a>
<a name="ln118"> </a>
<a name="ln119">  snprintf (buf, sizeof (buf), &quot;0x%04hx&quot;, ntohs (type));</a>
<a name="ln120">  return buf;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">const char *</a>
<a name="ln124">ospf6_lstype_short_name (u_int16_t type)</a>
<a name="ln125">{</a>
<a name="ln126">  static char buf[8];</a>
<a name="ln127">  struct ospf6_lsa_handler *handler;</a>
<a name="ln128"> </a>
<a name="ln129">  handler = ospf6_get_lsa_handler (type);</a>
<a name="ln130">  if (handler &amp;&amp; handler != &amp;unknown_handler)</a>
<a name="ln131">    return handler-&gt;short_name;</a>
<a name="ln132"> </a>
<a name="ln133">  snprintf (buf, sizeof (buf), &quot;0x%04hx&quot;, ntohs (type));</a>
<a name="ln134">  return buf;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">u_char</a>
<a name="ln138">ospf6_lstype_debug (u_int16_t type)</a>
<a name="ln139">{</a>
<a name="ln140">  struct ospf6_lsa_handler *handler;</a>
<a name="ln141">  handler = ospf6_get_lsa_handler (type);</a>
<a name="ln142">  return handler-&gt;debug;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">/* RFC2328: Section 13.2 */</a>
<a name="ln146">int</a>
<a name="ln147">ospf6_lsa_is_differ (struct ospf6_lsa *lsa1,</a>
<a name="ln148">                     struct ospf6_lsa *lsa2)</a>
<a name="ln149">{</a>
<a name="ln150">  int len;</a>
<a name="ln151"> </a>
<a name="ln152">  assert (OSPF6_LSA_IS_SAME (lsa1, lsa2));</a>
<a name="ln153"> </a>
<a name="ln154">  /* XXX, Options ??? */</a>
<a name="ln155"> </a>
<a name="ln156">  ospf6_lsa_age_current (lsa1);</a>
<a name="ln157">  ospf6_lsa_age_current (lsa2);</a>
<a name="ln158">  if (ntohs (lsa1-&gt;header-&gt;age) == OSPF_LSA_MAXAGE &amp;&amp;</a>
<a name="ln159">      ntohs (lsa2-&gt;header-&gt;age) != OSPF_LSA_MAXAGE)</a>
<a name="ln160">    return 1;</a>
<a name="ln161">  if (ntohs (lsa1-&gt;header-&gt;age) != OSPF_LSA_MAXAGE &amp;&amp;</a>
<a name="ln162">      ntohs (lsa2-&gt;header-&gt;age) == OSPF_LSA_MAXAGE)</a>
<a name="ln163">    return 1;</a>
<a name="ln164"> </a>
<a name="ln165">  /* compare body */</a>
<a name="ln166">  if (ntohs (lsa1-&gt;header-&gt;length) != ntohs (lsa2-&gt;header-&gt;length))</a>
<a name="ln167">    return 1;</a>
<a name="ln168"> </a>
<a name="ln169">  len = ntohs (lsa1-&gt;header-&gt;length) - sizeof (struct ospf6_lsa_header);</a>
<a name="ln170">  return memcmp (lsa1-&gt;header + 1, lsa2-&gt;header + 1, len);</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">int</a>
<a name="ln174">ospf6_lsa_is_changed (struct ospf6_lsa *lsa1,</a>
<a name="ln175">                      struct ospf6_lsa *lsa2)</a>
<a name="ln176">{</a>
<a name="ln177">  int length;</a>
<a name="ln178"> </a>
<a name="ln179">  if (OSPF6_LSA_IS_MAXAGE (lsa1) ^ OSPF6_LSA_IS_MAXAGE (lsa2))</a>
<a name="ln180">    return 1;</a>
<a name="ln181">  if (ntohs (lsa1-&gt;header-&gt;length) != ntohs (lsa2-&gt;header-&gt;length))</a>
<a name="ln182">    return 1;</a>
<a name="ln183">  /* Going beyond LSA headers to compare the payload only makes sense, when both LSAs aren't header-only. */</a>
<a name="ln184">  if (CHECK_FLAG (lsa1-&gt;flag, OSPF6_LSA_HEADERONLY) != CHECK_FLAG (lsa2-&gt;flag, OSPF6_LSA_HEADERONLY))</a>
<a name="ln185">  {</a>
<a name="ln186">    zlog_warn (&quot;%s: only one of two (%s, %s) LSAs compared is header-only&quot;, __func__, lsa1-&gt;name, lsa2-&gt;name);</a>
<a name="ln187">    return 1;</a>
<a name="ln188">  }</a>
<a name="ln189">  if (CHECK_FLAG (lsa1-&gt;flag, OSPF6_LSA_HEADERONLY))</a>
<a name="ln190">    return 0;</a>
<a name="ln191"> </a>
<a name="ln192">  length = OSPF6_LSA_SIZE (lsa1-&gt;header) - sizeof (struct ospf6_lsa_header);</a>
<a name="ln193">  /* Once upper layer verifies LSAs received, length underrun should become a warning. */</a>
<a name="ln194">  if (length &lt;= 0)</a>
<a name="ln195">    return 0;</a>
<a name="ln196"> </a>
<a name="ln197">  return memcmp (OSPF6_LSA_HEADER_END (lsa1-&gt;header),</a>
<a name="ln198">                 OSPF6_LSA_HEADER_END (lsa2-&gt;header), length);</a>
<a name="ln199">}</a>
<a name="ln200"> </a>
<a name="ln201">/* ospf6 age functions */</a>
<a name="ln202">/* calculate birth */</a>
<a name="ln203">static void</a>
<a name="ln204">ospf6_lsa_age_set (struct ospf6_lsa *lsa)</a>
<a name="ln205">{</a>
<a name="ln206">  struct timeval now;</a>
<a name="ln207"> </a>
<a name="ln208">  assert (lsa &amp;&amp; lsa-&gt;header);</a>
<a name="ln209"> </a>
<a name="ln210">  if (quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now) &lt; 0)</a>
<a name="ln211">    zlog_warn (&quot;LSA: quagga_gettime failed, may fail LSA AGEs: %s&quot;,</a>
<a name="ln212">               safe_strerror (errno));</a>
<a name="ln213"> </a>
<a name="ln214">  lsa-&gt;birth.tv_sec = now.tv_sec - ntohs (lsa-&gt;header-&gt;age);</a>
<a name="ln215">  lsa-&gt;birth.tv_usec = now.tv_usec;</a>
<a name="ln216"> </a>
<a name="ln217">  return;</a>
<a name="ln218">}</a>
<a name="ln219"> </a>
<a name="ln220">/* this function calculates current age from its birth,</a>
<a name="ln221">   then update age field of LSA header. return value is current age */</a>
<a name="ln222">u_int16_t</a>
<a name="ln223">ospf6_lsa_age_current (struct ospf6_lsa *lsa)</a>
<a name="ln224">{</a>
<a name="ln225">  struct timeval now;</a>
<a name="ln226">  u_int32_t ulage;</a>
<a name="ln227">  u_int16_t age;</a>
<a name="ln228"> </a>
<a name="ln229">  assert (lsa);</a>
<a name="ln230">  assert (lsa-&gt;header);</a>
<a name="ln231"> </a>
<a name="ln232">  /* current time */</a>
<a name="ln233">  if (quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now) &lt; 0)</a>
<a name="ln234">    zlog_warn (&quot;LSA: quagga_gettime failed, may fail LSA AGEs: %s&quot;,</a>
<a name="ln235">               safe_strerror (errno));</a>
<a name="ln236"> </a>
<a name="ln237">  if (ntohs (lsa-&gt;header-&gt;age) &gt;= OSPF_LSA_MAXAGE)</a>
<a name="ln238">    {</a>
<a name="ln239">      /* ospf6_lsa_premature_aging () sets age to MAXAGE; when using</a>
<a name="ln240">         relative time, we cannot compare against lsa birth time, so</a>
<a name="ln241">         we catch this special case here. */</a>
<a name="ln242">      lsa-&gt;header-&gt;age = htons (OSPF_LSA_MAXAGE);</a>
<a name="ln243">      return OSPF_LSA_MAXAGE;</a>
<a name="ln244">    }</a>
<a name="ln245">  /* calculate age */</a>
<a name="ln246">  ulage = now.tv_sec - lsa-&gt;birth.tv_sec;</a>
<a name="ln247"> </a>
<a name="ln248">  /* if over MAXAGE, set to it */</a>
<a name="ln249">  age = (ulage &gt; OSPF_LSA_MAXAGE ? OSPF_LSA_MAXAGE : ulage);</a>
<a name="ln250"> </a>
<a name="ln251">  lsa-&gt;header-&gt;age = htons (age);</a>
<a name="ln252">  return age;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">/* update age field of LSA header with adding InfTransDelay */</a>
<a name="ln256">void</a>
<a name="ln257">ospf6_lsa_age_update_to_send (struct ospf6_lsa *lsa, u_int32_t transdelay)</a>
<a name="ln258">{</a>
<a name="ln259">  unsigned short age;</a>
<a name="ln260"> </a>
<a name="ln261">  age = ospf6_lsa_age_current (lsa) + transdelay;</a>
<a name="ln262">  if (age &gt; OSPF_LSA_MAXAGE)</a>
<a name="ln263">    age = OSPF_LSA_MAXAGE;</a>
<a name="ln264">  lsa-&gt;header-&gt;age = htons (age);</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">void</a>
<a name="ln268">ospf6_lsa_premature_aging (struct ospf6_lsa *lsa)</a>
<a name="ln269">{</a>
<a name="ln270">  /* log */</a>
<a name="ln271">  if (IS_OSPF6_DEBUG_LSA_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln272">    zlog_debug (&quot;LSA: Premature aging: %s&quot;, lsa-&gt;name);</a>
<a name="ln273"> </a>
<a name="ln274">  THREAD_OFF (lsa-&gt;expire);</a>
<a name="ln275">  THREAD_OFF (lsa-&gt;refresh);</a>
<a name="ln276"> </a>
<a name="ln277">  /*</a>
<a name="ln278">   * We clear the LSA from the neighbor retx lists now because it</a>
<a name="ln279">   * will not get deleted later. Essentially, changing the age to</a>
<a name="ln280">   * MaxAge will prevent this LSA from being matched with its</a>
<a name="ln281">   * existing entries in the retx list thereby causing those entries</a>
<a name="ln282">   * to be silently replaced with its MaxAged version, but with ever</a>
<a name="ln283">   * increasing retx count causing this LSA to remain forever and</a>
<a name="ln284">   * for the MaxAge remover thread to be called forever too.</a>
<a name="ln285">   *</a>
<a name="ln286">   * The reason the previous entry silently disappears is that when</a>
<a name="ln287">   * entry is added to a neighbor's retx list, it replaces the existing</a>
<a name="ln288">   * entry. But since the ospf6_lsdb_add() routine is generic and not aware</a>
<a name="ln289">   * of the special semantics of retx count, the retx count is not</a>
<a name="ln290">   * decremented when its replaced. Attempting to add the incr and decr</a>
<a name="ln291">   * retx count routines as the hook_add and hook_remove for the retx lists</a>
<a name="ln292">   * have a problem because the hook_remove routine is called for MaxAge</a>
<a name="ln293">   * entries (as will be the case in a traditional LSDB, unlike in this case</a>
<a name="ln294">   * where an LSDB is used as an efficient tree structure to store all kinds</a>
<a name="ln295">   * of data) that are added instead of calling the hook_add routine.</a>
<a name="ln296">   */</a>
<a name="ln297"> </a>
<a name="ln298">  ospf6_flood_clear (lsa);</a>
<a name="ln299"> </a>
<a name="ln300">  lsa-&gt;header-&gt;age = htons (OSPF_LSA_MAXAGE);</a>
<a name="ln301">  thread_execute (master, ospf6_lsa_expire, lsa, 0);</a>
<a name="ln302">}</a>
<a name="ln303"> </a>
<a name="ln304">/* check which is more recent. if a is more recent, return -1;</a>
<a name="ln305">   if the same, return 0; otherwise(b is more recent), return 1 */</a>
<a name="ln306">int</a>
<a name="ln307">ospf6_lsa_compare (struct ospf6_lsa *a, struct ospf6_lsa *b)</a>
<a name="ln308">{</a>
<a name="ln309">  int32_t seqnuma, seqnumb;</a>
<a name="ln310">  u_int16_t cksuma, cksumb;</a>
<a name="ln311">  u_int16_t agea, ageb;</a>
<a name="ln312"> </a>
<a name="ln313">  assert (a &amp;&amp; a-&gt;header);</a>
<a name="ln314">  assert (b &amp;&amp; b-&gt;header);</a>
<a name="ln315">  assert (OSPF6_LSA_IS_SAME (a, b));</a>
<a name="ln316"> </a>
<a name="ln317">  seqnuma = (int32_t) ntohl (a-&gt;header-&gt;seqnum);</a>
<a name="ln318">  seqnumb = (int32_t) ntohl (b-&gt;header-&gt;seqnum);</a>
<a name="ln319"> </a>
<a name="ln320">  /* compare by sequence number */</a>
<a name="ln321">  if (seqnuma &gt; seqnumb)</a>
<a name="ln322">    return -1;</a>
<a name="ln323">  if (seqnuma &lt; seqnumb)</a>
<a name="ln324">    return 1;</a>
<a name="ln325"> </a>
<a name="ln326">  /* Checksum */</a>
<a name="ln327">  cksuma = ntohs (a-&gt;header-&gt;checksum);</a>
<a name="ln328">  cksumb = ntohs (b-&gt;header-&gt;checksum);</a>
<a name="ln329">  if (cksuma &gt; cksumb)</a>
<a name="ln330">    return -1;</a>
<a name="ln331">  if (cksuma &lt; cksumb)</a>
<a name="ln332">    return 0;</a>
<a name="ln333"> </a>
<a name="ln334">  /* Update Age */</a>
<a name="ln335">  agea = ospf6_lsa_age_current (a);</a>
<a name="ln336">  ageb = ospf6_lsa_age_current (b);</a>
<a name="ln337"> </a>
<a name="ln338">  /* MaxAge check */</a>
<a name="ln339">  if (agea == OSPF_LSA_MAXAGE &amp;&amp; ageb != OSPF_LSA_MAXAGE)</a>
<a name="ln340">    return -1;</a>
<a name="ln341">  else if (agea != OSPF_LSA_MAXAGE &amp;&amp; ageb == OSPF_LSA_MAXAGE)</a>
<a name="ln342">    return 1;</a>
<a name="ln343"> </a>
<a name="ln344">  /* Age check */</a>
<a name="ln345">  if (agea &gt; ageb &amp;&amp; agea - ageb &gt;= OSPF_LSA_MAXAGE_DIFF)</a>
<a name="ln346">    return 1;</a>
<a name="ln347">  else if (agea &lt; ageb &amp;&amp; ageb - agea &gt;= OSPF_LSA_MAXAGE_DIFF)</a>
<a name="ln348">    return -1;</a>
<a name="ln349"> </a>
<a name="ln350">  /* neither recent */</a>
<a name="ln351">  return 0;</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">char *</a>
<a name="ln355">ospf6_lsa_printbuf (struct ospf6_lsa *lsa, char *buf, int size)</a>
<a name="ln356">{</a>
<a name="ln357">  char id[16], adv_router[16];</a>
<a name="ln358">  inet_ntop (AF_INET, &amp;lsa-&gt;header-&gt;id, id, sizeof (id));</a>
<a name="ln359">  inet_ntop (AF_INET, &amp;lsa-&gt;header-&gt;adv_router, adv_router,</a>
<a name="ln360">             sizeof (adv_router));</a>
<a name="ln361">  snprintf (buf, size, &quot;[%s Id:%s Adv:%s]&quot;,</a>
<a name="ln362">            ospf6_lstype_name (lsa-&gt;header-&gt;type), id, adv_router);</a>
<a name="ln363">  return buf;</a>
<a name="ln364">}</a>
<a name="ln365"> </a>
<a name="ln366">void</a>
<a name="ln367">ospf6_lsa_header_print_raw (struct ospf6_lsa_header *header)</a>
<a name="ln368">{</a>
<a name="ln369">  char id[16], adv_router[16];</a>
<a name="ln370">  inet_ntop (AF_INET, &amp;header-&gt;id, id, sizeof (id));</a>
<a name="ln371">  inet_ntop (AF_INET, &amp;header-&gt;adv_router, adv_router,</a>
<a name="ln372">             sizeof (adv_router));</a>
<a name="ln373">  zlog_debug (&quot;    [%s Id:%s Adv:%s]&quot;,</a>
<a name="ln374">	      ospf6_lstype_name (header-&gt;type), id, adv_router);</a>
<a name="ln375">  zlog_debug (&quot;    Age: %4hu SeqNum: %#08lx Cksum: %04hx Len: %d&quot;,</a>
<a name="ln376">	      ntohs (header-&gt;age), (u_long) ntohl (header-&gt;seqnum),</a>
<a name="ln377">	      ntohs (header-&gt;checksum), ntohs (header-&gt;length));</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">void</a>
<a name="ln381">ospf6_lsa_header_print (struct ospf6_lsa *lsa)</a>
<a name="ln382">{</a>
<a name="ln383">  ospf6_lsa_age_current (lsa);</a>
<a name="ln384">  ospf6_lsa_header_print_raw (lsa-&gt;header);</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">void</a>
<a name="ln388">ospf6_lsa_show_summary_header (struct vty *vty)</a>
<a name="ln389">{</a>
<a name="ln390">  vty_out (vty, &quot;%-4s %-15s%-15s%4s %8s %30s%s&quot;,</a>
<a name="ln391">           &quot;Type&quot;, &quot;LSId&quot;, &quot;AdvRouter&quot;, &quot;Age&quot;, &quot;SeqNum&quot;,</a>
<a name="ln392">           &quot;Payload&quot;, VNL);</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">void</a>
<a name="ln396">ospf6_lsa_show_summary (struct vty *vty, struct ospf6_lsa *lsa)</a>
<a name="ln397">{</a>
<a name="ln398">  char adv_router[16], id[16];</a>
<a name="ln399">  int type;</a>
<a name="ln400">  struct ospf6_lsa_handler *handler;</a>
<a name="ln401">  char buf[64], tmpbuf[80];</a>
<a name="ln402">  int cnt = 0;</a>
<a name="ln403"> </a>
<a name="ln404">  assert (lsa);</a>
<a name="ln405">  assert (lsa-&gt;header);</a>
<a name="ln406"> </a>
<a name="ln407">  inet_ntop (AF_INET, &amp;lsa-&gt;header-&gt;id, id, sizeof (id));</a>
<a name="ln408">  inet_ntop (AF_INET, &amp;lsa-&gt;header-&gt;adv_router, adv_router,</a>
<a name="ln409">             sizeof (adv_router));</a>
<a name="ln410"> </a>
<a name="ln411">  type = ntohs(lsa-&gt;header-&gt;type);</a>
<a name="ln412">  handler = ospf6_get_lsa_handler (lsa-&gt;header-&gt;type);</a>
<a name="ln413">  if ((type == OSPF6_LSTYPE_INTER_PREFIX) ||</a>
<a name="ln414">      (type == OSPF6_LSTYPE_INTER_ROUTER) ||</a>
<a name="ln415">      (type == OSPF6_LSTYPE_AS_EXTERNAL))</a>
<a name="ln416">    {</a>
<a name="ln417">      vty_out (vty, &quot;%-4s %-15s%-15s%4hu %8lx %30s%s&quot;,</a>
<a name="ln418">	       ospf6_lstype_short_name (lsa-&gt;header-&gt;type),</a>
<a name="ln419">	       id, adv_router, ospf6_lsa_age_current (lsa),</a>
<a name="ln420">	       (u_long) ntohl (lsa-&gt;header-&gt;seqnum),</a>
<a name="ln421">	       handler-&gt;get_prefix_str(lsa, buf, sizeof(buf), 0), VNL);</a>
<a name="ln422">    }</a>
<a name="ln423">  else if (type != OSPF6_LSTYPE_UNKNOWN)</a>
<a name="ln424">    {</a>
<a name="ln425">      sprintf (tmpbuf, &quot;%-4s %-15s%-15s%4hu %8lx&quot;,</a>
<a name="ln426">	       ospf6_lstype_short_name (lsa-&gt;header-&gt;type),</a>
<a name="ln427">	       id, adv_router, ospf6_lsa_age_current (lsa),</a>
<a name="ln428">	       (u_long) ntohl (lsa-&gt;header-&gt;seqnum));</a>
<a name="ln429"> </a>
<a name="ln430">      while (handler-&gt;get_prefix_str(lsa, buf, sizeof(buf), cnt) != NULL)</a>
<a name="ln431">	{</a>
<a name="ln432">	  vty_out (vty, &quot;%s %30s%s&quot;, tmpbuf, buf, VNL);</a>
<a name="ln433">	  cnt++;</a>
<a name="ln434">	}</a>
<a name="ln435">    }</a>
<a name="ln436">  else</a>
<a name="ln437">    {</a>
<a name="ln438">      vty_out (vty, &quot;%-4s %-15s%-15s%4hu %8lx%s&quot;,</a>
<a name="ln439">	       ospf6_lstype_short_name (lsa-&gt;header-&gt;type),</a>
<a name="ln440">	       id, adv_router, ospf6_lsa_age_current (lsa),</a>
<a name="ln441">	       (u_long) ntohl (lsa-&gt;header-&gt;seqnum), VNL);</a>
<a name="ln442">    }</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">void</a>
<a name="ln446">ospf6_lsa_show_dump (struct vty *vty, struct ospf6_lsa *lsa)</a>
<a name="ln447">{</a>
<a name="ln448">  u_char *start, *end, *current;</a>
<a name="ln449">  char byte[4];</a>
<a name="ln450"> </a>
<a name="ln451">  start = (u_char *) lsa-&gt;header;</a>
<a name="ln452">  end = (u_char *) lsa-&gt;header + ntohs (lsa-&gt;header-&gt;length);</a>
<a name="ln453"> </a>
<a name="ln454">  vty_out (vty, &quot;%s&quot;, VNL);</a>
<a name="ln455">  vty_out (vty, &quot;%s:%s&quot;, lsa-&gt;name, VNL);</a>
<a name="ln456"> </a>
<a name="ln457">  for (current = start; current &lt; end; current ++)</a>
<a name="ln458">    {</a>
<a name="ln459">      if ((current - start) % 16 == 0)</a>
<a name="ln460">        vty_out (vty, &quot;%s        &quot;, VNL);</a>
<a name="ln461">      else if ((current - start) % 4 == 0)</a>
<a name="ln462">        vty_out (vty, &quot; &quot;);</a>
<a name="ln463"> </a>
<a name="ln464">      snprintf (byte, sizeof (byte), &quot;%02x&quot;, *current);</a>
<a name="ln465">      vty_out (vty, &quot;%s&quot;, byte);</a>
<a name="ln466">    }</a>
<a name="ln467"> </a>
<a name="ln468">  vty_out (vty, &quot;%s%s&quot;, VNL, VNL);</a>
<a name="ln469">  return;</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">void</a>
<a name="ln473">ospf6_lsa_show_internal (struct vty *vty, struct ospf6_lsa *lsa)</a>
<a name="ln474">{</a>
<a name="ln475">  char adv_router[64], id[64];</a>
<a name="ln476"> </a>
<a name="ln477">  assert (lsa &amp;&amp; lsa-&gt;header);</a>
<a name="ln478"> </a>
<a name="ln479">  inet_ntop (AF_INET, &amp;lsa-&gt;header-&gt;id, id, sizeof (id));</a>
<a name="ln480">  inet_ntop (AF_INET, &amp;lsa-&gt;header-&gt;adv_router,</a>
<a name="ln481">             adv_router, sizeof (adv_router));</a>
<a name="ln482"> </a>
<a name="ln483">  vty_out (vty, &quot;%s&quot;, VNL);</a>
<a name="ln484">  vty_out (vty, &quot;Age: %4hu Type: %s%s&quot;, ospf6_lsa_age_current (lsa),</a>
<a name="ln485">           ospf6_lstype_name (lsa-&gt;header-&gt;type), VNL);</a>
<a name="ln486">  vty_out (vty, &quot;Link State ID: %s%s&quot;, id, VNL);</a>
<a name="ln487">  vty_out (vty, &quot;Advertising Router: %s%s&quot;, adv_router, VNL);</a>
<a name="ln488">  vty_out (vty, &quot;LS Sequence Number: %#010lx%s&quot;,</a>
<a name="ln489">           (u_long) ntohl (lsa-&gt;header-&gt;seqnum), VNL);</a>
<a name="ln490">  vty_out (vty, &quot;CheckSum: %#06hx Length: %hu%s&quot;,</a>
<a name="ln491">           ntohs (lsa-&gt;header-&gt;checksum),</a>
<a name="ln492">           ntohs (lsa-&gt;header-&gt;length), VNL);</a>
<a name="ln493">  vty_out (vty, &quot;Flag: %x %s&quot;, lsa-&gt;flag, VNL);</a>
<a name="ln494">  vty_out (vty, &quot;Lock: %d %s&quot;, lsa-&gt;lock, VNL);</a>
<a name="ln495">  vty_out (vty, &quot;ReTx Count: %d%s&quot;, lsa-&gt;retrans_count, VNL);</a>
<a name="ln496">  vty_out (vty, &quot;Threads: Expire: 0x%p, Refresh: 0x%p %s&quot;,</a>
<a name="ln497">           (void *)lsa-&gt;expire, (void *)lsa-&gt;refresh, VNL);</a>
<a name="ln498">  vty_out (vty, &quot;%s&quot;, VNL);</a>
<a name="ln499">  return;</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">void</a>
<a name="ln503">ospf6_lsa_show (struct vty *vty, struct ospf6_lsa *lsa)</a>
<a name="ln504">{</a>
<a name="ln505">  char adv_router[64], id[64];</a>
<a name="ln506">  struct ospf6_lsa_handler *handler;</a>
<a name="ln507">  struct timeval now, res;</a>
<a name="ln508">  char duration[16];</a>
<a name="ln509"> </a>
<a name="ln510">  assert (lsa &amp;&amp; lsa-&gt;header);</a>
<a name="ln511"> </a>
<a name="ln512">  inet_ntop (AF_INET, &amp;lsa-&gt;header-&gt;id, id, sizeof (id));</a>
<a name="ln513">  inet_ntop (AF_INET, &amp;lsa-&gt;header-&gt;adv_router,</a>
<a name="ln514">             adv_router, sizeof (adv_router));</a>
<a name="ln515"> </a>
<a name="ln516">  quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now);</a>
<a name="ln517">  timersub (&amp;now, &amp;lsa-&gt;installed, &amp;res);</a>
<a name="ln518">  timerstring (&amp;res, duration, sizeof (duration));</a>
<a name="ln519"> </a>
<a name="ln520">  vty_out (vty, &quot;Age: %4hu Type: %s%s&quot;, ospf6_lsa_age_current (lsa),</a>
<a name="ln521">           ospf6_lstype_name (lsa-&gt;header-&gt;type), VNL);</a>
<a name="ln522">  vty_out (vty, &quot;Link State ID: %s%s&quot;, id, VNL);</a>
<a name="ln523">  vty_out (vty, &quot;Advertising Router: %s%s&quot;, adv_router, VNL);</a>
<a name="ln524">  vty_out (vty, &quot;LS Sequence Number: %#010lx%s&quot;,</a>
<a name="ln525">           (u_long) ntohl (lsa-&gt;header-&gt;seqnum), VNL);</a>
<a name="ln526">  vty_out (vty, &quot;CheckSum: %#06hx Length: %hu%s&quot;,</a>
<a name="ln527">           ntohs (lsa-&gt;header-&gt;checksum),</a>
<a name="ln528">           ntohs (lsa-&gt;header-&gt;length), VNL);</a>
<a name="ln529">  vty_out (vty, &quot;Duration: %s%s&quot;, duration, VNL);</a>
<a name="ln530"> </a>
<a name="ln531">  handler = ospf6_get_lsa_handler (lsa-&gt;header-&gt;type);</a>
<a name="ln532">  if (handler-&gt;show == NULL)</a>
<a name="ln533">    handler = &amp;unknown_handler;</a>
<a name="ln534">  (*handler-&gt;show) (vty, lsa);</a>
<a name="ln535"> </a>
<a name="ln536">  vty_out (vty, &quot;%s&quot;, VNL);</a>
<a name="ln537">}</a>
<a name="ln538"> </a>
<a name="ln539">/* OSPFv3 LSA creation/deletion function */</a>
<a name="ln540">struct ospf6_lsa *</a>
<a name="ln541">ospf6_lsa_create (struct ospf6_lsa_header *header)</a>
<a name="ln542">{</a>
<a name="ln543">  struct ospf6_lsa *lsa = NULL;</a>
<a name="ln544">  struct ospf6_lsa_header *new_header = NULL;</a>
<a name="ln545">  u_int16_t lsa_size = 0;</a>
<a name="ln546"> </a>
<a name="ln547">  /* size of the entire LSA */</a>
<a name="ln548">  lsa_size = ntohs (header-&gt;length);   /* XXX vulnerable */</a>
<a name="ln549"> </a>
<a name="ln550">  /* allocate memory for this LSA */</a>
<a name="ln551">  new_header = (struct ospf6_lsa_header *)</a>
<a name="ln552">    XMALLOC (MTYPE_OSPF6_LSA, lsa_size);</a>
<a name="ln553"> </a>
<a name="ln554">  /* copy LSA from original header */</a>
<a name="ln555">  memcpy (new_header, header, lsa_size);</a>
<a name="ln556"> </a>
<a name="ln557">  /* LSA information structure */</a>
<a name="ln558">  /* allocate memory */</a>
<a name="ln559">  lsa = (struct ospf6_lsa *)</a>
<a name="ln560">    XCALLOC (MTYPE_OSPF6_LSA, sizeof (struct ospf6_lsa));</a>
<a name="ln561"> </a>
<a name="ln562">  lsa-&gt;header = (struct ospf6_lsa_header *) new_header;</a>
<a name="ln563"> </a>
<a name="ln564">  /* dump string */</a>
<a name="ln565">  ospf6_lsa_printbuf (lsa, lsa-&gt;name, sizeof (lsa-&gt;name));</a>
<a name="ln566"> </a>
<a name="ln567">  /* calculate birth of this lsa */</a>
<a name="ln568">  ospf6_lsa_age_set (lsa);</a>
<a name="ln569"> </a>
<a name="ln570">  return lsa;</a>
<a name="ln571">}</a>
<a name="ln572"> </a>
<a name="ln573">struct ospf6_lsa *</a>
<a name="ln574">ospf6_lsa_create_headeronly (struct ospf6_lsa_header *header)</a>
<a name="ln575">{</a>
<a name="ln576">  struct ospf6_lsa *lsa = NULL;</a>
<a name="ln577">  struct ospf6_lsa_header *new_header = NULL;</a>
<a name="ln578"> </a>
<a name="ln579">  /* allocate memory for this LSA */</a>
<a name="ln580">  new_header = (struct ospf6_lsa_header *)</a>
<a name="ln581">    XMALLOC (MTYPE_OSPF6_LSA, sizeof (struct ospf6_lsa_header));</a>
<a name="ln582"> </a>
<a name="ln583">  /* copy LSA from original header */</a>
<a name="ln584">  memcpy (new_header, header, sizeof (struct ospf6_lsa_header));</a>
<a name="ln585"> </a>
<a name="ln586">  /* LSA information structure */</a>
<a name="ln587">  /* allocate memory */</a>
<a name="ln588">  lsa = (struct ospf6_lsa *)</a>
<a name="ln589">    XCALLOC (MTYPE_OSPF6_LSA, sizeof (struct ospf6_lsa));</a>
<a name="ln590"> </a>
<a name="ln591">  lsa-&gt;header = (struct ospf6_lsa_header *) new_header;</a>
<a name="ln592">  SET_FLAG (lsa-&gt;flag, OSPF6_LSA_HEADERONLY);</a>
<a name="ln593"> </a>
<a name="ln594">  /* dump string */</a>
<a name="ln595">  ospf6_lsa_printbuf (lsa, lsa-&gt;name, sizeof (lsa-&gt;name));</a>
<a name="ln596"> </a>
<a name="ln597">  /* calculate birth of this lsa */</a>
<a name="ln598">  ospf6_lsa_age_set (lsa);</a>
<a name="ln599"> </a>
<a name="ln600">  return lsa;</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">void</a>
<a name="ln604">ospf6_lsa_delete (struct ospf6_lsa *lsa)</a>
<a name="ln605">{</a>
<a name="ln606">  assert (lsa-&gt;lock == 0);</a>
<a name="ln607"> </a>
<a name="ln608">  /* cancel threads */</a>
<a name="ln609">  THREAD_OFF (lsa-&gt;expire);</a>
<a name="ln610">  THREAD_OFF (lsa-&gt;refresh);</a>
<a name="ln611"> </a>
<a name="ln612">  /* do free */</a>
<a name="ln613">  XFREE (MTYPE_OSPF6_LSA, lsa-&gt;header);</a>
<a name="ln614">  XFREE (MTYPE_OSPF6_LSA, lsa);</a>
<a name="ln615">}</a>
<a name="ln616"> </a>
<a name="ln617">struct ospf6_lsa *</a>
<a name="ln618">ospf6_lsa_copy (struct ospf6_lsa *lsa)</a>
<a name="ln619">{</a>
<a name="ln620">  struct ospf6_lsa *copy = NULL;</a>
<a name="ln621"> </a>
<a name="ln622">  ospf6_lsa_age_current (lsa);</a>
<a name="ln623">  if (CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_HEADERONLY))</a>
<a name="ln624">    copy = ospf6_lsa_create_headeronly (lsa-&gt;header);</a>
<a name="ln625">  else</a>
<a name="ln626">    copy = ospf6_lsa_create (lsa-&gt;header);</a>
<a name="ln627">  assert (copy-&gt;lock == 0);</a>
<a name="ln628"> </a>
<a name="ln629">  copy-&gt;birth = lsa-&gt;birth;</a>
<a name="ln630">  copy-&gt;originated = lsa-&gt;originated;</a>
<a name="ln631">  copy-&gt;received = lsa-&gt;received;</a>
<a name="ln632">  copy-&gt;installed = lsa-&gt;installed;</a>
<a name="ln633">  copy-&gt;lsdb = lsa-&gt;lsdb;</a>
<a name="ln634">  copy-&gt;rn = NULL;</a>
<a name="ln635"> </a>
<a name="ln636">  return copy;</a>
<a name="ln637">}</a>
<a name="ln638"> </a>
<a name="ln639">/* increment reference counter of struct ospf6_lsa */</a>
<a name="ln640">void</a>
<a name="ln641">ospf6_lsa_lock (struct ospf6_lsa *lsa)</a>
<a name="ln642">{</a>
<a name="ln643">  lsa-&gt;lock++;</a>
<a name="ln644">  return;</a>
<a name="ln645">}</a>
<a name="ln646"> </a>
<a name="ln647">/* decrement reference counter of struct ospf6_lsa */</a>
<a name="ln648">void</a>
<a name="ln649">ospf6_lsa_unlock (struct ospf6_lsa *lsa)</a>
<a name="ln650">{</a>
<a name="ln651">  /* decrement reference counter */</a>
<a name="ln652">  assert (lsa-&gt;lock &gt; 0);</a>
<a name="ln653">  lsa-&gt;lock--;</a>
<a name="ln654"> </a>
<a name="ln655">  if (lsa-&gt;lock != 0)</a>
<a name="ln656">    return;</a>
<a name="ln657"> </a>
<a name="ln658">  ospf6_lsa_delete (lsa);</a>
<a name="ln659">}</a>
<a name="ln660"> </a>
<a name="ln661"> </a>
<a name="ln662">/* ospf6 lsa expiry */</a>
<a name="ln663">int</a>
<a name="ln664">ospf6_lsa_expire (struct thread *thread)</a>
<a name="ln665">{</a>
<a name="ln666">  struct ospf6_lsa *lsa;</a>
<a name="ln667"> </a>
<a name="ln668">  lsa = (struct ospf6_lsa *) THREAD_ARG (thread);</a>
<a name="ln669"> </a>
<a name="ln670">  assert (lsa &amp;&amp; lsa-&gt;header);</a>
<a name="ln671">  assert (OSPF6_LSA_IS_MAXAGE (lsa));</a>
<a name="ln672">  assert (! lsa-&gt;refresh);</a>
<a name="ln673"> </a>
<a name="ln674">  lsa-&gt;expire = (struct thread *) NULL;</a>
<a name="ln675"> </a>
<a name="ln676">  if (IS_OSPF6_DEBUG_LSA_TYPE (lsa-&gt;header-&gt;type))</a>
<a name="ln677">    {</a>
<a name="ln678">      zlog_debug (&quot;LSA Expire:&quot;);</a>
<a name="ln679">      ospf6_lsa_header_print (lsa);</a>
<a name="ln680">    }</a>
<a name="ln681"> </a>
<a name="ln682">  if (CHECK_FLAG (lsa-&gt;flag, OSPF6_LSA_HEADERONLY))</a>
<a name="ln683">    return 0;    /* dbexchange will do something ... */</a>
<a name="ln684"> </a>
<a name="ln685">  /* reinstall lsa */</a>
<a name="ln686">  ospf6_install_lsa (lsa);</a>
<a name="ln687"> </a>
<a name="ln688">  /* reflood lsa */</a>
<a name="ln689">  ospf6_flood (NULL, lsa);</a>
<a name="ln690"> </a>
<a name="ln691">  /* schedule maxage remover */</a>
<a name="ln692">  ospf6_maxage_remove (ospf6);</a>
<a name="ln693"> </a>
<a name="ln694">  return 0;</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">int</a>
<a name="ln698">ospf6_lsa_refresh (struct thread *thread)</a>
<a name="ln699">{</a>
<a name="ln700">  struct ospf6_lsa *old, *self, *new;</a>
<a name="ln701">  struct ospf6_lsdb *lsdb_self;</a>
<a name="ln702"> </a>
<a name="ln703">  assert (thread);</a>
<a name="ln704">  old = (struct ospf6_lsa *) THREAD_ARG (thread);</a>
<a name="ln705">  assert (old &amp;&amp; old-&gt;header);</a>
<a name="ln706"> </a>
<a name="ln707">  old-&gt;refresh = (struct thread *) NULL;</a>
<a name="ln708"> </a>
<a name="ln709">  lsdb_self = ospf6_get_scoped_lsdb_self (old);</a>
<a name="ln710">  self = ospf6_lsdb_lookup (old-&gt;header-&gt;type, old-&gt;header-&gt;id,</a>
<a name="ln711">                            old-&gt;header-&gt;adv_router, lsdb_self);</a>
<a name="ln712">  if (self == NULL)</a>
<a name="ln713">    {</a>
<a name="ln714">      if (IS_OSPF6_DEBUG_LSA_TYPE (old-&gt;header-&gt;type))</a>
<a name="ln715">        zlog_debug (&quot;Refresh: could not find self LSA, flush %s&quot;, old-&gt;name);</a>
<a name="ln716">      ospf6_lsa_premature_aging (old);</a>
<a name="ln717">      return 0;</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">  /* Reset age, increment LS sequence number. */</a>
<a name="ln721">  self-&gt;header-&gt;age = htons (0);</a>
<a name="ln722">  self-&gt;header-&gt;seqnum =</a>
<a name="ln723">    ospf6_new_ls_seqnum (self-&gt;header-&gt;type, self-&gt;header-&gt;id,</a>
<a name="ln724">                         self-&gt;header-&gt;adv_router, old-&gt;lsdb);</a>
<a name="ln725">  ospf6_lsa_checksum (self-&gt;header);</a>
<a name="ln726"> </a>
<a name="ln727">  new = ospf6_lsa_create (self-&gt;header);</a>
<a name="ln728">  new-&gt;lsdb = old-&gt;lsdb;</a>
<a name="ln729">  new-&gt;refresh = thread_add_timer (master, ospf6_lsa_refresh, new,</a>
<a name="ln730">                                   OSPF_LS_REFRESH_TIME);</a>
<a name="ln731"> </a>
<a name="ln732">  /* store it in the LSDB for self-originated LSAs */</a>
<a name="ln733">  ospf6_lsdb_add (ospf6_lsa_copy (new), lsdb_self);</a>
<a name="ln734"> </a>
<a name="ln735">  if (IS_OSPF6_DEBUG_LSA_TYPE (new-&gt;header-&gt;type))</a>
<a name="ln736">    {</a>
<a name="ln737">      zlog_debug (&quot;LSA Refresh:&quot;);</a>
<a name="ln738">      ospf6_lsa_header_print (new);</a>
<a name="ln739">    }</a>
<a name="ln740"> </a>
<a name="ln741">  ospf6_install_lsa (new);</a>
<a name="ln742">  ospf6_flood (NULL, new);</a>
<a name="ln743"> </a>
<a name="ln744">  return 0;</a>
<a name="ln745">}</a>
<a name="ln746"> </a>
<a name="ln747"> </a>
<a name="ln748"> </a>
<a name="ln749">/* Fletcher Checksum -- Refer to RFC1008. */</a>
<a name="ln750"> </a>
<a name="ln751">/* All the offsets are zero-based. The offsets in the RFC1008 are</a>
<a name="ln752">   one-based. */</a>
<a name="ln753">unsigned short</a>
<a name="ln754">ospf6_lsa_checksum (struct ospf6_lsa_header *lsa_header)</a>
<a name="ln755">{</a>
<a name="ln756">  u_char *buffer = (u_char *) &amp;lsa_header-&gt;type;</a>
<a name="ln757">  int type_offset = buffer - (u_char *) &amp;lsa_header-&gt;age; /* should be 2 */</a>
<a name="ln758"> </a>
<a name="ln759">  /* Skip the AGE field */</a>
<a name="ln760">  u_int16_t len = ntohs(lsa_header-&gt;length) - type_offset;</a>
<a name="ln761"> </a>
<a name="ln762">  /* Checksum offset starts from &quot;type&quot; field, not the beginning of the</a>
<a name="ln763">     lsa_header struct. The offset is 14, rather than 16. */</a>
<a name="ln764">  int checksum_offset = (u_char *) &amp;lsa_header-&gt;checksum - buffer;</a>
<a name="ln765"> </a>
<a name="ln766">  return (unsigned short)fletcher_checksum(buffer, len, checksum_offset);</a>
<a name="ln767">}</a>
<a name="ln768"> </a>
<a name="ln769">int</a>
<a name="ln770">ospf6_lsa_checksum_valid (struct ospf6_lsa_header *lsa_header)</a>
<a name="ln771">{</a>
<a name="ln772">  u_char *buffer = (u_char *) &amp;lsa_header-&gt;type;</a>
<a name="ln773">  int type_offset = buffer - (u_char *) &amp;lsa_header-&gt;age; /* should be 2 */</a>
<a name="ln774"> </a>
<a name="ln775">  /* Skip the AGE field */</a>
<a name="ln776">  u_int16_t len = ntohs(lsa_header-&gt;length) - type_offset;</a>
<a name="ln777"> </a>
<a name="ln778">  return (fletcher_checksum(buffer, len, FLETCHER_CHECKSUM_VALIDATE) == 0);</a>
<a name="ln779">}</a>
<a name="ln780"> </a>
<a name="ln781">void</a>
<a name="ln782">ospf6_lsa_init (void)</a>
<a name="ln783">{</a>
<a name="ln784">  ospf6_lsa_handler_vector = vector_init (0);</a>
<a name="ln785">  ospf6_install_lsa_handler (&amp;unknown_handler);</a>
<a name="ln786">}</a>
<a name="ln787"> </a>
<a name="ln788">void</a>
<a name="ln789">ospf6_lsa_terminate (void)</a>
<a name="ln790">{</a>
<a name="ln791">  vector_free (ospf6_lsa_handler_vector);</a>
<a name="ln792">}</a>
<a name="ln793"> </a>
<a name="ln794">static char *</a>
<a name="ln795">ospf6_lsa_handler_name (struct ospf6_lsa_handler *h)</a>
<a name="ln796">{</a>
<a name="ln797">  static char buf[64];</a>
<a name="ln798">  unsigned int i; </a>
<a name="ln799">  unsigned int size = strlen (h-&gt;name);</a>
<a name="ln800"> </a>
<a name="ln801">  if (!strcmp(h-&gt;name, &quot;unknown&quot;) &amp;&amp;</a>
<a name="ln802">      h-&gt;type != OSPF6_LSTYPE_UNKNOWN)</a>
<a name="ln803">    {</a>
<a name="ln804">      snprintf (buf, sizeof (buf), &quot;%#04hx&quot;, h-&gt;type);</a>
<a name="ln805">      return buf;</a>
<a name="ln806">    }</a>
<a name="ln807"> </a>
<a name="ln808">  for (i = 0; i &lt; MIN (size, sizeof (buf)); i++)</a>
<a name="ln809">    {</a>
<a name="ln810">      if (! islower ((unsigned char)h-&gt;name[i]))</a>
<a name="ln811">        buf[i] = tolower ((unsigned char)h-&gt;name[i]);</a>
<a name="ln812">      else</a>
<a name="ln813">        buf[i] = h-&gt;name[i];</a>
<a name="ln814">    }</a>
<a name="ln815">  buf[size] = '\0';</a>
<a name="ln816">  return buf;</a>
<a name="ln817">}</a>
<a name="ln818"> </a>
<a name="ln819">DEFUN (debug_ospf6_lsa_type,</a>
<a name="ln820">       debug_ospf6_lsa_hex_cmd,</a>
<a name="ln821">       &quot;debug ospf6 lsa (router|network|inter-prefix|inter-router|as-ext|grp-mbr|type7|link|intra-prefix|unknown)&quot;,</a>
<a name="ln822">       DEBUG_STR</a>
<a name="ln823">       OSPF6_STR</a>
<a name="ln824">       &quot;Debug Link State Advertisements (LSAs)\n&quot;</a>
<a name="ln825">       &quot;Specify LS type as Hexadecimal\n&quot;</a>
<a name="ln826">      )</a>
<a name="ln827">{</a>
<a name="ln828">  unsigned int i;</a>
<a name="ln829">  struct ospf6_lsa_handler *handler = NULL;</a>
<a name="ln830"> </a>
<a name="ln831">  assert (argc);</a>
<a name="ln832"> </a>
<a name="ln833">  for (i = 0; i &lt; vector_active (ospf6_lsa_handler_vector); i++)</a>
<a name="ln834">    {</a>
<a name="ln835">      handler = vector_slot (ospf6_lsa_handler_vector, i);</a>
<a name="ln836">      if (handler == NULL)</a>
<a name="ln837">        continue;</a>
<a name="ln838">      if (strncmp (argv[0], ospf6_lsa_handler_name(handler), strlen(argv[0])) == 0)</a>
<a name="ln839">        break;</a>
<a name="ln840">      if (! strcasecmp (argv[0], handler-&gt;name))</a>
<a name="ln841">        break;</a>
<a name="ln842">      handler = NULL;</a>
<a name="ln843">    }</a>
<a name="ln844"> </a>
<a name="ln845">  if (handler == NULL)</a>
<a name="ln846">    handler = &amp;unknown_handler;</a>
<a name="ln847"> </a>
<a name="ln848">  if (argc &gt;= 2)</a>
<a name="ln849">    {</a>
<a name="ln850">      if (! strcmp (argv[1], &quot;originate&quot;))</a>
<a name="ln851">        SET_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG_ORIGINATE);</a>
<a name="ln852">      if (! strcmp (argv[1], &quot;examine&quot;))</a>
<a name="ln853">        SET_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG_EXAMIN);</a>
<a name="ln854">      if (! strcmp (argv[1], &quot;flooding&quot;))</a>
<a name="ln855">        SET_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG_FLOOD);</a>
<a name="ln856">    }</a>
<a name="ln857">  else</a>
<a name="ln858">    SET_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG);</a>
<a name="ln859"> </a>
<a name="ln860">  return CMD_SUCCESS;</a>
<a name="ln861">}</a>
<a name="ln862"> </a>
<a name="ln863">ALIAS (debug_ospf6_lsa_type,</a>
<a name="ln864">       debug_ospf6_lsa_hex_detail_cmd,</a>
<a name="ln865">       &quot;debug ospf6 lsa (router|network|inter-prefix|inter-router|as-ext|grp-mbr|type7|link|intra-prefix|unknown) (originate|examine|flooding)&quot;,</a>
<a name="ln866">       DEBUG_STR</a>
<a name="ln867">       OSPF6_STR</a>
<a name="ln868">       &quot;Debug Link State Advertisements (LSAs)\n&quot;</a>
<a name="ln869">       &quot;Specify LS type as Hexadecimal\n&quot;</a>
<a name="ln870">      )</a>
<a name="ln871"> </a>
<a name="ln872">DEFUN (no_debug_ospf6_lsa_type,</a>
<a name="ln873">       no_debug_ospf6_lsa_hex_cmd,</a>
<a name="ln874">       &quot;no debug ospf6 lsa (router|network|inter-prefix|inter-router|as-ext|grp-mbr|type7|link|intra-prefix|unknown)&quot;,</a>
<a name="ln875">       NO_STR</a>
<a name="ln876">       DEBUG_STR</a>
<a name="ln877">       OSPF6_STR</a>
<a name="ln878">       &quot;Debug Link State Advertisements (LSAs)\n&quot;</a>
<a name="ln879">       &quot;Specify LS type as Hexadecimal\n&quot;</a>
<a name="ln880">      )</a>
<a name="ln881">{</a>
<a name="ln882">  u_int i;</a>
<a name="ln883">  struct ospf6_lsa_handler *handler = NULL;</a>
<a name="ln884"> </a>
<a name="ln885">  assert (argc);</a>
<a name="ln886"> </a>
<a name="ln887">  for (i = 0; i &lt; vector_active (ospf6_lsa_handler_vector); i++)</a>
<a name="ln888">    {</a>
<a name="ln889">      handler = vector_slot (ospf6_lsa_handler_vector, i);</a>
<a name="ln890">      if (handler == NULL)</a>
<a name="ln891">        continue;</a>
<a name="ln892">      if (strncmp (argv[0], ospf6_lsa_handler_name(handler), strlen(argv[0])) == 0)</a>
<a name="ln893">        break;</a>
<a name="ln894">      if (! strcasecmp (argv[0], handler-&gt;name))</a>
<a name="ln895">        break;</a>
<a name="ln896">    }</a>
<a name="ln897"> </a>
<a name="ln898">  if (handler == NULL)</a>
<a name="ln899">    return CMD_SUCCESS;</a>
<a name="ln900"> </a>
<a name="ln901">  if (argc &gt;= 2)</a>
<a name="ln902">    {</a>
<a name="ln903">      if (! strcmp (argv[1], &quot;originate&quot;))</a>
<a name="ln904">        UNSET_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG_ORIGINATE);</a>
<a name="ln905">      if (! strcmp (argv[1], &quot;examine&quot;))</a>
<a name="ln906">        UNSET_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG_EXAMIN);</a>
<a name="ln907">      if (! strcmp (argv[1], &quot;flooding&quot;))</a>
<a name="ln908">        UNSET_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG_FLOOD);</a>
<a name="ln909">    }</a>
<a name="ln910">  else</a>
<a name="ln911">    UNSET_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG);</a>
<a name="ln912"> </a>
<a name="ln913">  return CMD_SUCCESS;</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">ALIAS (no_debug_ospf6_lsa_type,</a>
<a name="ln917">       no_debug_ospf6_lsa_hex_detail_cmd,</a>
<a name="ln918">       &quot;no debug ospf6 lsa (router|network|inter-prefix|inter-router|as-ext|grp-mbr|type7|link|intra-prefix) (originate|examine|flooding)&quot;,</a>
<a name="ln919">       NO_STR</a>
<a name="ln920">       DEBUG_STR</a>
<a name="ln921">       OSPF6_STR</a>
<a name="ln922">       &quot;Debug Link State Advertisements (LSAs)\n&quot;</a>
<a name="ln923">       &quot;Specify LS type as Hexadecimal\n&quot;</a>
<a name="ln924">      )</a>
<a name="ln925"> </a>
<a name="ln926">void</a>
<a name="ln927">install_element_ospf6_debug_lsa (void)</a>
<a name="ln928">{</a>
<a name="ln929">  install_element (ENABLE_NODE, &amp;debug_ospf6_lsa_hex_cmd);</a>
<a name="ln930">  install_element (ENABLE_NODE, &amp;debug_ospf6_lsa_hex_detail_cmd);</a>
<a name="ln931">  install_element (ENABLE_NODE, &amp;no_debug_ospf6_lsa_hex_cmd);</a>
<a name="ln932">  install_element (ENABLE_NODE, &amp;no_debug_ospf6_lsa_hex_detail_cmd);</a>
<a name="ln933">  install_element (CONFIG_NODE, &amp;debug_ospf6_lsa_hex_cmd);</a>
<a name="ln934">  install_element (CONFIG_NODE, &amp;debug_ospf6_lsa_hex_detail_cmd);</a>
<a name="ln935">  install_element (CONFIG_NODE, &amp;no_debug_ospf6_lsa_hex_cmd);</a>
<a name="ln936">  install_element (CONFIG_NODE, &amp;no_debug_ospf6_lsa_hex_detail_cmd);</a>
<a name="ln937">}</a>
<a name="ln938"> </a>
<a name="ln939">int</a>
<a name="ln940">config_write_ospf6_debug_lsa (struct vty *vty)</a>
<a name="ln941">{</a>
<a name="ln942">  u_int i;</a>
<a name="ln943">  struct ospf6_lsa_handler *handler;</a>
<a name="ln944"> </a>
<a name="ln945">  for (i = 0; i &lt; vector_active (ospf6_lsa_handler_vector); i++)</a>
<a name="ln946">    {</a>
<a name="ln947">      handler = vector_slot (ospf6_lsa_handler_vector, i);</a>
<a name="ln948">      if (handler == NULL)</a>
<a name="ln949">        continue;</a>
<a name="ln950">      if (CHECK_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG))</a>
<a name="ln951">        vty_out (vty, &quot;debug ospf6 lsa %s%s&quot;,</a>
<a name="ln952">                 ospf6_lsa_handler_name (handler), VNL);</a>
<a name="ln953">      if (CHECK_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG_ORIGINATE))</a>
<a name="ln954">        vty_out (vty, &quot;debug ospf6 lsa %s originate%s&quot;,</a>
<a name="ln955">                 ospf6_lsa_handler_name (handler), VNL);</a>
<a name="ln956">      if (CHECK_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG_EXAMIN))</a>
<a name="ln957">        vty_out (vty, &quot;debug ospf6 lsa %s examine%s&quot;,</a>
<a name="ln958">                 ospf6_lsa_handler_name (handler), VNL);</a>
<a name="ln959">      if (CHECK_FLAG (handler-&gt;debug, OSPF6_LSA_DEBUG_FLOOD))</a>
<a name="ln960">        vty_out (vty, &quot;debug ospf6 lsa %s flooding%s&quot;,</a>
<a name="ln961">                 ospf6_lsa_handler_name (handler), VNL);</a>
<a name="ln962">    }</a>
<a name="ln963"> </a>
<a name="ln964">  return 0;</a>
<a name="ln965">}</a>
<a name="ln966"> </a>
<a name="ln967"> </a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="116"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: handler.</p></div>
<div class="balloon" rel="130"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: handler.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
