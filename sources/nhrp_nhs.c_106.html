
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_nhs.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP NHC nexthop server functions (registration)</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;zebra.h&quot;</a>
<a name="ln11">#include &quot;zbuf.h&quot;</a>
<a name="ln12">#include &quot;memory.h&quot;</a>
<a name="ln13">#include &quot;thread.h&quot;</a>
<a name="ln14">#include &quot;nhrpd.h&quot;</a>
<a name="ln15">#include &quot;nhrp_protocol.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17">static int nhrp_nhs_resolve(struct thread *t);</a>
<a name="ln18">static int nhrp_reg_send_req(struct thread *t);</a>
<a name="ln19"> </a>
<a name="ln20">static void nhrp_reg_reply(struct nhrp_reqid *reqid, void *arg)</a>
<a name="ln21">{</a>
<a name="ln22">	struct nhrp_packet_parser *p = arg;</a>
<a name="ln23">	struct nhrp_registration *r = container_of(reqid, struct nhrp_registration, reqid);</a>
<a name="ln24">	struct nhrp_nhs *nhs = r-&gt;nhs;</a>
<a name="ln25">	struct interface *ifp = nhs-&gt;ifp;</a>
<a name="ln26">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln27">	struct nhrp_extension_header *ext;</a>
<a name="ln28">	struct nhrp_cie_header *cie;</a>
<a name="ln29">	struct nhrp_cache *c;</a>
<a name="ln30">	struct zbuf extpl;</a>
<a name="ln31">	union sockunion cie_nbma, cie_proto, *proto;</a>
<a name="ln32">	char buf[64];</a>
<a name="ln33">	int ok = 0, holdtime;</a>
<a name="ln34"> </a>
<a name="ln35">	nhrp_reqid_free(&amp;nhrp_packet_reqid, &amp;r-&gt;reqid);</a>
<a name="ln36"> </a>
<a name="ln37">	if (p-&gt;hdr-&gt;type != NHRP_PACKET_REGISTRATION_REPLY) {</a>
<a name="ln38">		debugf(NHRP_DEBUG_COMMON, &quot;NHS: Registration failed&quot;);</a>
<a name="ln39">		return;</a>
<a name="ln40">	}</a>
<a name="ln41"> </a>
<a name="ln42">	debugf(NHRP_DEBUG_COMMON, &quot;NHS: Reg.reply received&quot;);</a>
<a name="ln43"> </a>
<a name="ln44">	ok = 1;</a>
<a name="ln45">	while ((cie = nhrp_cie_pull(&amp;p-&gt;payload, p-&gt;hdr, &amp;cie_nbma, &amp;cie_proto)) != NULL) {</a>
<a name="ln46">		proto = sockunion_family(&amp;cie_proto) != AF_UNSPEC ? &amp;cie_proto : &amp;p-&gt;src_proto;</a>
<a name="ln47">		debugf(NHRP_DEBUG_COMMON, &quot;NHS: CIE registration: %s: %d&quot;,</a>
<a name="ln48">			sockunion2str(proto, buf, sizeof(buf)),</a>
<a name="ln49">			cie-&gt;code);</a>
<a name="ln50">		if (!((cie-&gt;code == NHRP_CODE_SUCCESS) ||</a>
<a name="ln51">                      (cie-&gt;code == NHRP_CODE_ADMINISTRATIVELY_PROHIBITED &amp;&amp; nhs-&gt;hub)))</a>
<a name="ln52">			ok = 0;</a>
<a name="ln53">	}</a>
<a name="ln54"> </a>
<a name="ln55">	if (!ok)</a>
<a name="ln56">		return;</a>
<a name="ln57"> </a>
<a name="ln58">	/* Parse extensions */</a>
<a name="ln59">	sockunion_family(&amp;nifp-&gt;nat_nbma) = AF_UNSPEC;</a>
<a name="ln60">	while ((ext = nhrp_ext_pull(&amp;p-&gt;extensions, &amp;extpl)) != NULL) {</a>
<a name="ln61">		switch (htons(ext-&gt;type) &amp; ~NHRP_EXTENSION_FLAG_COMPULSORY) {</a>
<a name="ln62">		case NHRP_EXTENSION_NAT_ADDRESS:</a>
<a name="ln63">			/* NHS adds second CIE if NAT is detected */</a>
<a name="ln64">			if (nhrp_cie_pull(&amp;extpl, p-&gt;hdr, &amp;cie_nbma, &amp;cie_proto) &amp;&amp;</a>
<a name="ln65">			    nhrp_cie_pull(&amp;extpl, p-&gt;hdr, &amp;cie_nbma, &amp;cie_proto)) {</a>
<a name="ln66">				nifp-&gt;nat_nbma = cie_nbma;</a>
<a name="ln67">				debugf(NHRP_DEBUG_IF, &quot;%s: NAT detected, real NBMA address: %s&quot;,</a>
<a name="ln68">					ifp-&gt;name, sockunion2str(&amp;nifp-&gt;nbma, buf, sizeof(buf)));</a>
<a name="ln69">			}</a>
<a name="ln70">			break;</a>
<a name="ln71">		}</a>
<a name="ln72">	}</a>
<a name="ln73"> </a>
<a name="ln74">	/* Success - schedule next registration, and route NHS */</a>
<a name="ln75">	r-&gt;timeout = 2;</a>
<a name="ln76">	holdtime = nifp-&gt;afi[nhs-&gt;afi].holdtime;</a>
<a name="ln77">	THREAD_OFF(r-&gt;t_register);</a>
<a name="ln78"> </a>
<a name="ln79">	/* RFC 2332 5.2.3 - Registration is recommend to be renewed</a>
<a name="ln80">	 * every one third of holdtime */</a>
<a name="ln81">	THREAD_TIMER_ON(master, r-&gt;t_register, nhrp_reg_send_req, r, holdtime / 3);</a>
<a name="ln82"> </a>
<a name="ln83">	r-&gt;proto_addr = p-&gt;dst_proto;</a>
<a name="ln84">	c = nhrp_cache_get(ifp, &amp;p-&gt;dst_proto, 1);</a>
<a name="ln85">	if (c) nhrp_cache_update_binding(c, NHRP_CACHE_NHS, holdtime, nhrp_peer_ref(r-&gt;peer), 0, NULL);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">static int nhrp_reg_timeout(struct thread *t)</a>
<a name="ln89">{</a>
<a name="ln90">	struct nhrp_registration *r = THREAD_ARG(t);</a>
<a name="ln91">	struct nhrp_cache *c;</a>
<a name="ln92"> </a>
<a name="ln93">	r-&gt;t_register = NULL;</a>
<a name="ln94"> </a>
<a name="ln95">	if (r-&gt;timeout &gt;= 16 &amp;&amp; sockunion_family(&amp;r-&gt;proto_addr) != AF_UNSPEC) {</a>
<a name="ln96">		nhrp_reqid_free(&amp;nhrp_packet_reqid, &amp;r-&gt;reqid);</a>
<a name="ln97">		c = nhrp_cache_get(r-&gt;nhs-&gt;ifp, &amp;r-&gt;proto_addr, 0);</a>
<a name="ln98">		if (c) nhrp_cache_update_binding(c, NHRP_CACHE_NHS, -1, NULL, 0, NULL);</a>
<a name="ln99">		sockunion_family(&amp;r-&gt;proto_addr) = AF_UNSPEC;</a>
<a name="ln100">	}</a>
<a name="ln101"> </a>
<a name="ln102">	r-&gt;timeout &lt;&lt;= 1;</a>
<a name="ln103">	if (r-&gt;timeout &gt; 64) r-&gt;timeout = 2;</a>
<a name="ln104">	THREAD_TIMER_MSEC_ON(master, r-&gt;t_register, nhrp_reg_send_req, r, 10);</a>
<a name="ln105"> </a>
<a name="ln106">	return 0;</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">static void nhrp_reg_peer_notify(struct notifier_block *n, unsigned long cmd)</a>
<a name="ln110">{</a>
<a name="ln111">	struct nhrp_registration *r = container_of(n, struct nhrp_registration, peer_notifier);</a>
<a name="ln112">	char buf[SU_ADDRSTRLEN];</a>
<a name="ln113"> </a>
<a name="ln114">	switch (cmd) {</a>
<a name="ln115">	case NOTIFY_PEER_UP:</a>
<a name="ln116">	case NOTIFY_PEER_DOWN:</a>
<a name="ln117">	case NOTIFY_PEER_IFCONFIG_CHANGED:</a>
<a name="ln118">	case NOTIFY_PEER_MTU_CHANGED:</a>
<a name="ln119">		debugf(NHRP_DEBUG_COMMON, &quot;NHS: Flush timer for %s&quot;,</a>
<a name="ln120">			sockunion2str(&amp;r-&gt;peer-&gt;vc-&gt;remote.nbma, buf, sizeof buf));</a>
<a name="ln121">		THREAD_TIMER_OFF(r-&gt;t_register);</a>
<a name="ln122">		THREAD_TIMER_MSEC_ON(master, r-&gt;t_register, nhrp_reg_send_req, r, 10);</a>
<a name="ln123">		break;</a>
<a name="ln124">	}</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">static int nhrp_reg_send_req(struct thread *t)</a>
<a name="ln128">{</a>
<a name="ln129">	struct nhrp_registration *r = THREAD_ARG(t);</a>
<a name="ln130">	struct nhrp_nhs *nhs = r-&gt;nhs;</a>
<a name="ln131">	char buf1[SU_ADDRSTRLEN], buf2[SU_ADDRSTRLEN];</a>
<a name="ln132">	struct interface *ifp = nhs-&gt;ifp;</a>
<a name="ln133">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln134">	struct nhrp_afi_data *if_ad = &amp;nifp-&gt;afi[nhs-&gt;afi];</a>
<a name="ln135">	union sockunion *dst_proto;</a>
<a name="ln136">	struct zbuf *zb;</a>
<a name="ln137">	struct nhrp_packet_header *hdr;</a>
<a name="ln138">	struct nhrp_extension_header *ext;</a>
<a name="ln139">	struct nhrp_cie_header *cie;</a>
<a name="ln140"> </a>
<a name="ln141">	r-&gt;t_register = NULL;</a>
<a name="ln142">	if (!nhrp_peer_check(r-&gt;peer, 2)) {</a>
<a name="ln143">		debugf(NHRP_DEBUG_COMMON, &quot;NHS: Waiting link for %s&quot;,</a>
<a name="ln144">			sockunion2str(&amp;r-&gt;peer-&gt;vc-&gt;remote.nbma, buf1, sizeof buf1));</a>
<a name="ln145">		THREAD_TIMER_ON(master, r-&gt;t_register, nhrp_reg_send_req, r, 120);</a>
<a name="ln146">		return 0;</a>
<a name="ln147">	}</a>
<a name="ln148"> </a>
<a name="ln149">	THREAD_TIMER_ON(master, r-&gt;t_register, nhrp_reg_timeout, r, r-&gt;timeout);</a>
<a name="ln150"> </a>
<a name="ln151">	/* RFC2332 5.2.3 NHC uses it's own address as dst if NHS is unknown */</a>
<a name="ln152">	dst_proto = &amp;nhs-&gt;proto_addr;</a>
<a name="ln153">	if (sockunion_family(dst_proto) == AF_UNSPEC)</a>
<a name="ln154">		dst_proto = &amp;if_ad-&gt;addr;</a>
<a name="ln155"> </a>
<a name="ln156">	sockunion2str(&amp;if_ad-&gt;addr, buf1, sizeof(buf1));</a>
<a name="ln157">	sockunion2str(dst_proto, buf2, sizeof(buf2));</a>
<a name="ln158">	debugf(NHRP_DEBUG_COMMON, &quot;NHS: Register %s -&gt; %s (timeout %d)&quot;, buf1, buf2, r-&gt;timeout);</a>
<a name="ln159"> </a>
<a name="ln160">	/* No protocol address configured for tunnel interface */</a>
<a name="ln161">	if (sockunion_family(&amp;if_ad-&gt;addr) == AF_UNSPEC)</a>
<a name="ln162">		return 0;</a>
<a name="ln163"> </a>
<a name="ln164">	zb = zbuf_alloc(1400);</a>
<a name="ln165">	hdr = nhrp_packet_push(zb, NHRP_PACKET_REGISTRATION_REQUEST, &amp;nifp-&gt;nbma, &amp;if_ad-&gt;addr, dst_proto);</a>
<a name="ln166">	hdr-&gt;hop_count = 1;</a>
<a name="ln167">	if (!(if_ad-&gt;flags &amp; NHRP_IFF_REG_NO_UNIQUE))</a>
<a name="ln168">		hdr-&gt;flags |= htons(NHRP_FLAG_REGISTRATION_UNIQUE);</a>
<a name="ln169"> </a>
<a name="ln170">	hdr-&gt;u.request_id = htonl(nhrp_reqid_alloc(&amp;nhrp_packet_reqid, &amp;r-&gt;reqid, nhrp_reg_reply));</a>
<a name="ln171"> </a>
<a name="ln172">	/* FIXME: push CIE for each local protocol address */</a>
<a name="ln173">	cie = nhrp_cie_push(zb, NHRP_CODE_SUCCESS, NULL, NULL);</a>
<a name="ln174">	cie-&gt;prefix_length = 0xff;</a>
<a name="ln175">	cie-&gt;holding_time = htons(if_ad-&gt;holdtime);</a>
<a name="ln176">	cie-&gt;mtu = htons(if_ad-&gt;mtu);</a>
<a name="ln177"> </a>
<a name="ln178">	nhrp_ext_request(zb, hdr, ifp);</a>
<a name="ln179"> </a>
<a name="ln180">	/* Cisco NAT detection extension */</a>
<a name="ln181">	hdr-&gt;flags |= htons(NHRP_FLAG_REGISTRATION_NAT);</a>
<a name="ln182">	ext = nhrp_ext_push(zb, hdr, NHRP_EXTENSION_NAT_ADDRESS);</a>
<a name="ln183">	cie = nhrp_cie_push(zb, NHRP_CODE_SUCCESS, &amp;nifp-&gt;nbma, &amp;if_ad-&gt;addr);</a>
<a name="ln184">	cie-&gt;prefix_length = 8 * sockunion_get_addrlen(&amp;if_ad-&gt;addr);</a>
<a name="ln185">	nhrp_ext_complete(zb, ext);</a>
<a name="ln186"> </a>
<a name="ln187">	nhrp_packet_complete(zb, hdr);</a>
<a name="ln188">	nhrp_peer_send(r-&gt;peer, zb);</a>
<a name="ln189">	zbuf_free(zb);</a>
<a name="ln190"> </a>
<a name="ln191">	return 0;</a>
<a name="ln192">}</a>
<a name="ln193"> </a>
<a name="ln194">static void nhrp_reg_delete(struct nhrp_registration *r)</a>
<a name="ln195">{</a>
<a name="ln196">	nhrp_peer_notify_del(r-&gt;peer, &amp;r-&gt;peer_notifier);</a>
<a name="ln197">	nhrp_peer_unref(r-&gt;peer);</a>
<a name="ln198">	list_del(&amp;r-&gt;reglist_entry);</a>
<a name="ln199">	THREAD_OFF(r-&gt;t_register);</a>
<a name="ln200">	XFREE(MTYPE_NHRP_REGISTRATION, r);</a>
<a name="ln201">}</a>
<a name="ln202"> </a>
<a name="ln203">static struct nhrp_registration *nhrp_reg_by_nbma(struct nhrp_nhs *nhs, const union sockunion *nbma_addr)</a>
<a name="ln204">{</a>
<a name="ln205">	struct nhrp_registration *r;</a>
<a name="ln206"> </a>
<a name="ln207">	list_for_each_entry(r, &amp;nhs-&gt;reglist_head, reglist_entry)</a>
<a name="ln208">		if (sockunion_same(&amp;r-&gt;peer-&gt;vc-&gt;remote.nbma, nbma_addr))</a>
<a name="ln209">			return r;</a>
<a name="ln210">	return NULL;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">static void nhrp_nhs_resolve_cb(struct resolver_query *q, int n, union sockunion *addrs)</a>
<a name="ln214">{</a>
<a name="ln215">	struct nhrp_nhs *nhs = container_of(q, struct nhrp_nhs, dns_resolve);</a>
<a name="ln216">	struct nhrp_interface *nifp = nhs-&gt;ifp-&gt;info;</a>
<a name="ln217">	struct nhrp_registration *reg, *regn;</a>
<a name="ln218">	int i;</a>
<a name="ln219"> </a>
<a name="ln220">	nhs-&gt;t_resolve = NULL;</a>
<a name="ln221">	if (n &lt; 0) {</a>
<a name="ln222">		/* Failed, retry in a moment */</a>
<a name="ln223">		THREAD_TIMER_ON(master, nhs-&gt;t_resolve, nhrp_nhs_resolve, nhs, 5);</a>
<a name="ln224">		return;</a>
<a name="ln225">	}</a>
<a name="ln226"> </a>
<a name="ln227">	THREAD_TIMER_ON(master, nhs-&gt;t_resolve, nhrp_nhs_resolve, nhs, 2*60*60);</a>
<a name="ln228"> </a>
<a name="ln229">	list_for_each_entry(reg, &amp;nhs-&gt;reglist_head, reglist_entry)</a>
<a name="ln230">		reg-&gt;mark = 1;</a>
<a name="ln231"> </a>
<a name="ln232">	nhs-&gt;hub = 0;</a>
<a name="ln233">	for (i = 0; i &lt; n; i++) {</a>
<a name="ln234">		if (sockunion_same(&amp;addrs[i], &amp;nifp-&gt;nbma)) {</a>
<a name="ln235">			nhs-&gt;hub = 1;</a>
<a name="ln236">			continue;</a>
<a name="ln237">		}</a>
<a name="ln238"> </a>
<a name="ln239">		reg = nhrp_reg_by_nbma(nhs, &amp;addrs[i]);</a>
<a name="ln240">		if (reg) {</a>
<a name="ln241">			reg-&gt;mark = 0;</a>
<a name="ln242">			continue;</a>
<a name="ln243">		}</a>
<a name="ln244"> </a>
<a name="ln245">		reg = XCALLOC(MTYPE_NHRP_REGISTRATION, sizeof(*reg));</a>
<a name="ln246">		reg-&gt;peer = nhrp_peer_get(nhs-&gt;ifp, &amp;addrs[i]);</a>
<a name="ln247">		reg-&gt;nhs = nhs;</a>
<a name="ln248">		reg-&gt;timeout = 1;</a>
<a name="ln249">		list_init(&amp;reg-&gt;reglist_entry);</a>
<a name="ln250">		list_add_tail(&amp;reg-&gt;reglist_entry, &amp;nhs-&gt;reglist_head);</a>
<a name="ln251">		nhrp_peer_notify_add(reg-&gt;peer, &amp;reg-&gt;peer_notifier, nhrp_reg_peer_notify);</a>
<a name="ln252">		THREAD_TIMER_MSEC_ON(master, reg-&gt;t_register, nhrp_reg_send_req, reg, 50);</a>
<a name="ln253">	}</a>
<a name="ln254"> </a>
<a name="ln255">	list_for_each_entry_safe(reg, regn, &amp;nhs-&gt;reglist_head, reglist_entry) {</a>
<a name="ln256">		if (reg-&gt;mark)</a>
<a name="ln257">			nhrp_reg_delete(reg);</a>
<a name="ln258">	}</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261">static int nhrp_nhs_resolve(struct thread *t)</a>
<a name="ln262">{</a>
<a name="ln263">	struct nhrp_nhs *nhs = THREAD_ARG(t);</a>
<a name="ln264"> </a>
<a name="ln265">	resolver_resolve(&amp;nhs-&gt;dns_resolve, AF_INET, nhs-&gt;nbma_fqdn, nhrp_nhs_resolve_cb);</a>
<a name="ln266"> </a>
<a name="ln267">	return 0;</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">int nhrp_nhs_add(struct interface *ifp, afi_t afi, union sockunion *proto_addr, const char *nbma_fqdn)</a>
<a name="ln271">{</a>
<a name="ln272">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln273">	struct nhrp_nhs *nhs;</a>
<a name="ln274"> </a>
<a name="ln275">	if (sockunion_family(proto_addr) != AF_UNSPEC &amp;&amp;</a>
<a name="ln276">	    sockunion_family(proto_addr) != afi2family(afi))</a>
<a name="ln277">		return NHRP_ERR_PROTOCOL_ADDRESS_MISMATCH;</a>
<a name="ln278"> </a>
<a name="ln279">	list_for_each_entry(nhs, &amp;nifp-&gt;afi[afi].nhslist_head, nhslist_entry) {</a>
<a name="ln280">		if (sockunion_family(&amp;nhs-&gt;proto_addr) != AF_UNSPEC &amp;&amp;</a>
<a name="ln281">		    sockunion_family(proto_addr) != AF_UNSPEC &amp;&amp;</a>
<a name="ln282">		    sockunion_same(&amp;nhs-&gt;proto_addr, proto_addr))</a>
<a name="ln283">			return NHRP_ERR_ENTRY_EXISTS;</a>
<a name="ln284"> </a>
<a name="ln285">		if (strcmp(nhs-&gt;nbma_fqdn, nbma_fqdn) == 0)</a>
<a name="ln286">			return NHRP_ERR_ENTRY_EXISTS;</a>
<a name="ln287">	}</a>
<a name="ln288"> </a>
<a name="ln289">	nhs = XMALLOC(MTYPE_NHRP_NHS, sizeof(struct nhrp_nhs));</a>
<a name="ln290">	if (!nhs) return NHRP_ERR_NO_MEMORY;</a>
<a name="ln291"> </a>
<a name="ln292">	*nhs = (struct nhrp_nhs) {</a>
<a name="ln293">		.afi = afi,</a>
<a name="ln294">		.ifp = ifp,</a>
<a name="ln295">		.proto_addr = *proto_addr,</a>
<a name="ln296">		.nbma_fqdn = strdup(nbma_fqdn),</a>
<a name="ln297">		.reglist_head = LIST_INITIALIZER(nhs-&gt;reglist_head),</a>
<a name="ln298">	};</a>
<a name="ln299">	list_add_tail(&amp;nhs-&gt;nhslist_entry, &amp;nifp-&gt;afi[afi].nhslist_head);</a>
<a name="ln300">	THREAD_TIMER_MSEC_ON(master, nhs-&gt;t_resolve, nhrp_nhs_resolve, nhs, 1000);</a>
<a name="ln301"> </a>
<a name="ln302">	return NHRP_OK;</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">int nhrp_nhs_del(struct interface *ifp, afi_t afi, union sockunion *proto_addr, const char *nbma_fqdn)</a>
<a name="ln306">{</a>
<a name="ln307">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln308">	struct nhrp_nhs *nhs, *nnhs;</a>
<a name="ln309">	int ret = NHRP_ERR_ENTRY_NOT_FOUND;</a>
<a name="ln310"> </a>
<a name="ln311">	if (sockunion_family(proto_addr) != AF_UNSPEC &amp;&amp;</a>
<a name="ln312">	    sockunion_family(proto_addr) != afi2family(afi))</a>
<a name="ln313">		return NHRP_ERR_PROTOCOL_ADDRESS_MISMATCH;</a>
<a name="ln314"> </a>
<a name="ln315">	list_for_each_entry_safe(nhs, nnhs, &amp;nifp-&gt;afi[afi].nhslist_head, nhslist_entry) {</a>
<a name="ln316">		if (!sockunion_same(&amp;nhs-&gt;proto_addr, proto_addr))</a>
<a name="ln317">			continue;</a>
<a name="ln318">		if (strcmp(nhs-&gt;nbma_fqdn, nbma_fqdn) != 0)</a>
<a name="ln319">			continue;</a>
<a name="ln320"> </a>
<a name="ln321">		nhrp_nhs_free(nhs);</a>
<a name="ln322">		ret = NHRP_OK;</a>
<a name="ln323">	}</a>
<a name="ln324"> </a>
<a name="ln325">	return ret;</a>
<a name="ln326">}</a>
<a name="ln327"> </a>
<a name="ln328">int nhrp_nhs_free(struct nhrp_nhs *nhs)</a>
<a name="ln329">{</a>
<a name="ln330">	struct nhrp_registration *r, *rn;</a>
<a name="ln331"> </a>
<a name="ln332">	list_for_each_entry_safe(r, rn, &amp;nhs-&gt;reglist_head, reglist_entry)</a>
<a name="ln333">		nhrp_reg_delete(r);</a>
<a name="ln334">	THREAD_OFF(nhs-&gt;t_resolve);</a>
<a name="ln335">	list_del(&amp;nhs-&gt;nhslist_entry);</a>
<a name="ln336">	free((void*) nhs-&gt;nbma_fqdn);</a>
<a name="ln337">	XFREE(MTYPE_NHRP_NHS, nhs);</a>
<a name="ln338">	return 0;</a>
<a name="ln339">}</a>
<a name="ln340"> </a>
<a name="ln341">void nhrp_nhs_terminate(void)</a>
<a name="ln342">{</a>
<a name="ln343">	struct interface *ifp;</a>
<a name="ln344">	struct nhrp_interface *nifp;</a>
<a name="ln345">	struct nhrp_nhs *nhs, *tmp;</a>
<a name="ln346">	struct listnode *node;</a>
<a name="ln347">	afi_t afi;</a>
<a name="ln348"> </a>
<a name="ln349">	for (ALL_LIST_ELEMENTS_RO(iflist, node, ifp)) {</a>
<a name="ln350">		nifp = ifp-&gt;info;</a>
<a name="ln351">		for (afi = 0; afi &lt; AFI_MAX; afi++) {</a>
<a name="ln352">			list_for_each_entry_safe(nhs, tmp, &amp;nifp-&gt;afi[afi].nhslist_head, nhslist_entry)</a>
<a name="ln353">				nhrp_nhs_free(nhs);</a>
<a name="ln354">		}</a>
<a name="ln355">	}</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">void nhrp_nhs_foreach(struct interface *ifp, afi_t afi, void (*cb)(struct nhrp_nhs *, struct nhrp_registration *, void *), void *ctx)</a>
<a name="ln359">{</a>
<a name="ln360">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln361">	struct nhrp_nhs *nhs;</a>
<a name="ln362">	struct nhrp_registration *reg;</a>
<a name="ln363"> </a>
<a name="ln364">	list_for_each_entry(nhs, &amp;nifp-&gt;afi[afi].nhslist_head, nhslist_entry) {</a>
<a name="ln365">		if (!list_empty(&amp;nhs-&gt;reglist_head)) {</a>
<a name="ln366">			list_for_each_entry(reg, &amp;nhs-&gt;reglist_head, reglist_entry)</a>
<a name="ln367">				cb(nhs, reg, ctx);</a>
<a name="ln368">		} else</a>
<a name="ln369">			cb(nhs, 0, ctx);</a>
<a name="ln370">	}</a>
<a name="ln371">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="64"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v501/" target="_blank">V501</a> There are identical sub-expressions 'nhrp_cie_pull(& extpl, p->hdr, & cie_nbma, & cie_proto)' to the left and to the right of the '&&' operator.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
