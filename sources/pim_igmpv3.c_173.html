
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_igmpv3.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24">#include &quot;log.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;pimd.h&quot;</a>
<a name="ln28">#include &quot;pim_iface.h&quot;</a>
<a name="ln29">#include &quot;pim_igmp.h&quot;</a>
<a name="ln30">#include &quot;pim_igmpv3.h&quot;</a>
<a name="ln31">#include &quot;pim_str.h&quot;</a>
<a name="ln32">#include &quot;pim_util.h&quot;</a>
<a name="ln33">#include &quot;pim_time.h&quot;</a>
<a name="ln34">#include &quot;pim_zebra.h&quot;</a>
<a name="ln35">#include &quot;pim_oil.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">static void group_retransmit_timer_on(struct igmp_group *group);</a>
<a name="ln38">static long igmp_group_timer_remain_msec(struct igmp_group *group);</a>
<a name="ln39">static long igmp_source_timer_remain_msec(struct igmp_source *source);</a>
<a name="ln40">static void group_query_send(struct igmp_group *group);</a>
<a name="ln41">static void source_query_send_by_flag(struct igmp_group *group,</a>
<a name="ln42">				      int num_sources_tosend);</a>
<a name="ln43"> </a>
<a name="ln44">static void on_trace(const char *label,</a>
<a name="ln45">		     struct interface *ifp, struct in_addr from,</a>
<a name="ln46">		     struct in_addr group_addr,</a>
<a name="ln47">		     int num_sources, struct in_addr *sources)</a>
<a name="ln48">{</a>
<a name="ln49">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln50">    char from_str[100];</a>
<a name="ln51">    char group_str[100];</a>
<a name="ln52"> </a>
<a name="ln53">    pim_inet4_dump(&quot;&lt;from?&gt;&quot;, from, from_str, sizeof(from_str));</a>
<a name="ln54">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln55"> </a>
<a name="ln56">    zlog_debug(&quot;%s: from %s on %s: group=%s sources=%d&quot;,</a>
<a name="ln57">	       label, from_str, ifp-&gt;name, group_str, num_sources);</a>
<a name="ln58">  }</a>
<a name="ln59">}</a>
<a name="ln60"> </a>
<a name="ln61">int igmp_group_compat_mode(const struct igmp_sock *igmp,</a>
<a name="ln62">			   const struct igmp_group *group)</a>
<a name="ln63">{</a>
<a name="ln64">  struct pim_interface *pim_ifp;</a>
<a name="ln65">  int64_t               now_dsec;</a>
<a name="ln66">  long                  older_host_present_interval_dsec;</a>
<a name="ln67"> </a>
<a name="ln68">  zassert(igmp);</a>
<a name="ln69">  zassert(igmp-&gt;interface);</a>
<a name="ln70">  zassert(igmp-&gt;interface-&gt;info);</a>
<a name="ln71"> </a>
<a name="ln72">  pim_ifp = igmp-&gt;interface-&gt;info;</a>
<a name="ln73"> </a>
<a name="ln74">  /*</a>
<a name="ln75">    RFC 3376: 8.13. Older Host Present Interval</a>
<a name="ln76"> </a>
<a name="ln77">    This value MUST be ((the Robustness Variable) times (the Query</a>
<a name="ln78">    Interval)) plus (one Query Response Interval).</a>
<a name="ln79"> </a>
<a name="ln80">    older_host_present_interval_dsec = \</a>
<a name="ln81">      igmp-&gt;querier_robustness_variable * \</a>
<a name="ln82">      10 * igmp-&gt;querier_query_interval + \</a>
<a name="ln83">      pim_ifp-&gt;query_max_response_time_dsec;</a>
<a name="ln84">  */</a>
<a name="ln85">  older_host_present_interval_dsec =</a>
<a name="ln86">    PIM_IGMP_OHPI_DSEC(igmp-&gt;querier_robustness_variable,</a>
<a name="ln87">		       igmp-&gt;querier_query_interval,</a>
<a name="ln88">		       pim_ifp-&gt;igmp_query_max_response_time_dsec);</a>
<a name="ln89"> </a>
<a name="ln90">  now_dsec = pim_time_monotonic_dsec();</a>
<a name="ln91">  if (now_dsec &lt; 1) {</a>
<a name="ln92">    /* broken timer logged by pim_time_monotonic_dsec() */</a>
<a name="ln93">    return 3;</a>
<a name="ln94">  }</a>
<a name="ln95"> </a>
<a name="ln96">  if ((now_dsec - group-&gt;last_igmp_v1_report_dsec) &lt; older_host_present_interval_dsec)</a>
<a name="ln97">    return 1; /* IGMPv1 */</a>
<a name="ln98"> </a>
<a name="ln99">  if ((now_dsec - group-&gt;last_igmp_v2_report_dsec) &lt; older_host_present_interval_dsec)</a>
<a name="ln100">    return 2; /* IGMPv2 */</a>
<a name="ln101"> </a>
<a name="ln102">  return 3; /* IGMPv3 */</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">void igmp_group_reset_gmi(struct igmp_group *group)</a>
<a name="ln106">{</a>
<a name="ln107">  long group_membership_interval_msec;</a>
<a name="ln108">  struct pim_interface *pim_ifp;</a>
<a name="ln109">  struct igmp_sock *igmp;</a>
<a name="ln110">  struct interface *ifp;</a>
<a name="ln111"> </a>
<a name="ln112">  igmp = group-&gt;group_igmp_sock;</a>
<a name="ln113">  ifp = igmp-&gt;interface;</a>
<a name="ln114">  pim_ifp = ifp-&gt;info;</a>
<a name="ln115"> </a>
<a name="ln116">  /*</a>
<a name="ln117">    RFC 3376: 8.4. Group Membership Interval</a>
<a name="ln118"> </a>
<a name="ln119">    The Group Membership Interval is the amount of time that must pass</a>
<a name="ln120">    before a multicast router decides there are no more members of a</a>
<a name="ln121">    group or a particular source on a network.</a>
<a name="ln122"> </a>
<a name="ln123">    This value MUST be ((the Robustness Variable) times (the Query</a>
<a name="ln124">    Interval)) plus (one Query Response Interval).</a>
<a name="ln125"> </a>
<a name="ln126">    group_membership_interval_msec = querier_robustness_variable *</a>
<a name="ln127">                                     (1000 * querier_query_interval) +</a>
<a name="ln128">                                     100 * query_response_interval_dsec;</a>
<a name="ln129">  */</a>
<a name="ln130">  group_membership_interval_msec =</a>
<a name="ln131">    PIM_IGMP_GMI_MSEC(igmp-&gt;querier_robustness_variable,</a>
<a name="ln132">		      igmp-&gt;querier_query_interval,</a>
<a name="ln133">		      pim_ifp-&gt;igmp_query_max_response_time_dsec);</a>
<a name="ln134"> </a>
<a name="ln135">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln136">    char group_str[100];</a>
<a name="ln137">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln138">    zlog_debug(&quot;Resetting group %s timer to GMI=%ld.%03ld sec on %s&quot;,</a>
<a name="ln139">	       group_str,</a>
<a name="ln140">	       group_membership_interval_msec / 1000,</a>
<a name="ln141">	       group_membership_interval_msec % 1000,</a>
<a name="ln142">	       ifp-&gt;name);</a>
<a name="ln143">  }</a>
<a name="ln144"> </a>
<a name="ln145">  /*</a>
<a name="ln146">    RFC 3376: 6.2.2. Definition of Group Timers</a>
<a name="ln147"> </a>
<a name="ln148">    The group timer is only used when a group is in EXCLUDE mode and</a>
<a name="ln149">    it represents the time for the *filter-mode* of the group to</a>
<a name="ln150">    expire and switch to INCLUDE mode.</a>
<a name="ln151">  */</a>
<a name="ln152">  zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln153"> </a>
<a name="ln154">  igmp_group_timer_on(group, group_membership_interval_msec, ifp-&gt;name);</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">static int igmp_source_timer(struct thread *t)</a>
<a name="ln158">{</a>
<a name="ln159">  struct igmp_source *source;</a>
<a name="ln160">  struct igmp_group *group;</a>
<a name="ln161"> </a>
<a name="ln162">  zassert(t);</a>
<a name="ln163">  source = THREAD_ARG(t);</a>
<a name="ln164">  zassert(source);</a>
<a name="ln165"> </a>
<a name="ln166">  group = source-&gt;source_group;</a>
<a name="ln167"> </a>
<a name="ln168">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln169">    char group_str[100];</a>
<a name="ln170">    char source_str[100];</a>
<a name="ln171">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln172">    pim_inet4_dump(&quot;&lt;source?&gt;&quot;, source-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln173">    zlog_debug(&quot;%s: Source timer expired for group %s source %s on %s&quot;,</a>
<a name="ln174">	       __PRETTY_FUNCTION__,</a>
<a name="ln175">	       group_str, source_str,</a>
<a name="ln176">	       group-&gt;group_igmp_sock-&gt;interface-&gt;name);</a>
<a name="ln177">  }</a>
<a name="ln178"> </a>
<a name="ln179">  zassert(source-&gt;t_source_timer);</a>
<a name="ln180">  source-&gt;t_source_timer = 0;</a>
<a name="ln181"> </a>
<a name="ln182">  /*</a>
<a name="ln183">    RFC 3376: 6.3. IGMPv3 Source-Specific Forwarding Rules</a>
<a name="ln184"> </a>
<a name="ln185">    Group</a>
<a name="ln186">    Filter-Mode    Source Timer Value    Action</a>
<a name="ln187">    -----------    ------------------    ------</a>
<a name="ln188">    INCLUDE        TIMER == 0            Suggest to stop forwarding</a>
<a name="ln189">                                         traffic from source and</a>
<a name="ln190">                                         remove source record.  If</a>
<a name="ln191">                                         there are no more source</a>
<a name="ln192">                                         records for the group, delete</a>
<a name="ln193">                                         group record.</a>
<a name="ln194"> </a>
<a name="ln195">    EXCLUDE        TIMER == 0            Suggest to not forward</a>
<a name="ln196">                                         traffic from source</a>
<a name="ln197">                                         (DO NOT remove record)</a>
<a name="ln198"> </a>
<a name="ln199">    Source timer switched from (T &gt; 0) to (T == 0): disable forwarding.</a>
<a name="ln200">   */</a>
<a name="ln201"> </a>
<a name="ln202">  zassert(!source-&gt;t_source_timer);</a>
<a name="ln203"> </a>
<a name="ln204">  if (group-&gt;group_filtermode_isexcl) {</a>
<a name="ln205">    /* EXCLUDE mode */</a>
<a name="ln206"> </a>
<a name="ln207">    igmp_source_forward_stop(source);</a>
<a name="ln208">  }</a>
<a name="ln209">  else {</a>
<a name="ln210">    /* INCLUDE mode */</a>
<a name="ln211"> </a>
<a name="ln212">    /* igmp_source_delete() will stop forwarding source */</a>
<a name="ln213">    igmp_source_delete(source);</a>
<a name="ln214"> </a>
<a name="ln215">    /*</a>
<a name="ln216">      If there are no more source records for the group, delete group</a>
<a name="ln217">      record.</a>
<a name="ln218">    */</a>
<a name="ln219">    if (!listcount(group-&gt;group_source_list)) {</a>
<a name="ln220">      igmp_group_delete_empty_include(group);</a>
<a name="ln221">    }</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224">  return 0;</a>
<a name="ln225">}</a>
<a name="ln226"> </a>
<a name="ln227">static void source_timer_off(struct igmp_group *group,</a>
<a name="ln228">			     struct igmp_source *source)</a>
<a name="ln229">{</a>
<a name="ln230">  if (!source-&gt;t_source_timer)</a>
<a name="ln231">    return;</a>
<a name="ln232">  </a>
<a name="ln233">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln234">    char group_str[100];</a>
<a name="ln235">    char source_str[100];</a>
<a name="ln236">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln237">    pim_inet4_dump(&quot;&lt;source?&gt;&quot;, source-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln238">    zlog_debug(&quot;Cancelling TIMER event for group %s source %s on %s&quot;,</a>
<a name="ln239">	       group_str, source_str,</a>
<a name="ln240">	       group-&gt;group_igmp_sock-&gt;interface-&gt;name);</a>
<a name="ln241">  }</a>
<a name="ln242"> </a>
<a name="ln243">  THREAD_OFF(source-&gt;t_source_timer);</a>
<a name="ln244">  zassert(!source-&gt;t_source_timer);</a>
<a name="ln245">}</a>
<a name="ln246"> </a>
<a name="ln247">static void igmp_source_timer_on(struct igmp_group *group,</a>
<a name="ln248">				 struct igmp_source *source,</a>
<a name="ln249">				 long interval_msec)</a>
<a name="ln250">{</a>
<a name="ln251">  source_timer_off(group, source);</a>
<a name="ln252"> </a>
<a name="ln253">  if (PIM_DEBUG_IGMP_EVENTS) {</a>
<a name="ln254">    char group_str[100];</a>
<a name="ln255">    char source_str[100];</a>
<a name="ln256">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln257">    pim_inet4_dump(&quot;&lt;source?&gt;&quot;, source-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln258">    zlog_debug(&quot;Scheduling %ld.%03ld sec TIMER event for group %s source %s on %s&quot;,</a>
<a name="ln259">	       interval_msec / 1000,</a>
<a name="ln260">	       interval_msec % 1000,</a>
<a name="ln261">	       group_str, source_str,</a>
<a name="ln262">	       group-&gt;group_igmp_sock-&gt;interface-&gt;name);</a>
<a name="ln263">  }</a>
<a name="ln264"> </a>
<a name="ln265">  THREAD_TIMER_MSEC_ON(master, source-&gt;t_source_timer,</a>
<a name="ln266">		       igmp_source_timer,</a>
<a name="ln267">		       source, interval_msec);</a>
<a name="ln268">  zassert(source-&gt;t_source_timer);</a>
<a name="ln269"> </a>
<a name="ln270">  /*</a>
<a name="ln271">    RFC 3376: 6.3. IGMPv3 Source-Specific Forwarding Rules</a>
<a name="ln272">    </a>
<a name="ln273">    Source timer switched from (T == 0) to (T &gt; 0): enable forwarding.</a>
<a name="ln274">  */</a>
<a name="ln275">  igmp_source_forward_start(source);</a>
<a name="ln276">}</a>
<a name="ln277"> </a>
<a name="ln278">void igmp_source_reset_gmi(struct igmp_sock *igmp,</a>
<a name="ln279">			   struct igmp_group *group,</a>
<a name="ln280">			   struct igmp_source *source)</a>
<a name="ln281">{</a>
<a name="ln282">  long group_membership_interval_msec;</a>
<a name="ln283">  struct pim_interface *pim_ifp;</a>
<a name="ln284">  struct interface *ifp;</a>
<a name="ln285"> </a>
<a name="ln286">  ifp = igmp-&gt;interface;</a>
<a name="ln287">  pim_ifp = ifp-&gt;info;</a>
<a name="ln288"> </a>
<a name="ln289">  group_membership_interval_msec =</a>
<a name="ln290">    PIM_IGMP_GMI_MSEC(igmp-&gt;querier_robustness_variable,</a>
<a name="ln291">		      igmp-&gt;querier_query_interval,</a>
<a name="ln292">		      pim_ifp-&gt;igmp_query_max_response_time_dsec);</a>
<a name="ln293"> </a>
<a name="ln294">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln295">    char group_str[100];</a>
<a name="ln296">    char source_str[100];</a>
<a name="ln297"> </a>
<a name="ln298">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln299">    pim_inet4_dump(&quot;&lt;source?&gt;&quot;, source-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln300"> </a>
<a name="ln301">    zlog_debug(&quot;Resetting source %s timer to GMI=%ld.%03ld sec for group %s on %s&quot;,</a>
<a name="ln302">	       source_str,</a>
<a name="ln303">	       group_membership_interval_msec / 1000,</a>
<a name="ln304">	       group_membership_interval_msec % 1000,</a>
<a name="ln305">	       group_str,</a>
<a name="ln306">	       ifp-&gt;name);</a>
<a name="ln307">  }</a>
<a name="ln308"> </a>
<a name="ln309">  igmp_source_timer_on(group, source,</a>
<a name="ln310">		       group_membership_interval_msec);</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">static void source_mark_delete_flag(struct list *source_list)</a>
<a name="ln314">{</a>
<a name="ln315">  struct listnode    *src_node;</a>
<a name="ln316">  struct igmp_source *src;</a>
<a name="ln317"> </a>
<a name="ln318">  for (ALL_LIST_ELEMENTS_RO(source_list, src_node, src)) {</a>
<a name="ln319">    IGMP_SOURCE_DO_DELETE(src-&gt;source_flags);</a>
<a name="ln320">  }</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">static void source_mark_send_flag(struct list *source_list)</a>
<a name="ln324">{</a>
<a name="ln325">  struct listnode    *src_node;</a>
<a name="ln326">  struct igmp_source *src;</a>
<a name="ln327"> </a>
<a name="ln328">  for (ALL_LIST_ELEMENTS_RO(source_list, src_node, src)) {</a>
<a name="ln329">    IGMP_SOURCE_DO_SEND(src-&gt;source_flags);</a>
<a name="ln330">  }</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">static int source_mark_send_flag_by_timer(struct list *source_list)</a>
<a name="ln334">{</a>
<a name="ln335">  struct listnode    *src_node;</a>
<a name="ln336">  struct igmp_source *src;</a>
<a name="ln337">  int                 num_marked_sources = 0;</a>
<a name="ln338"> </a>
<a name="ln339">  for (ALL_LIST_ELEMENTS_RO(source_list, src_node, src)) {</a>
<a name="ln340">    /* Is source timer running? */</a>
<a name="ln341">    if (src-&gt;t_source_timer) {</a>
<a name="ln342">      IGMP_SOURCE_DO_SEND(src-&gt;source_flags);</a>
<a name="ln343">      ++num_marked_sources;</a>
<a name="ln344">    }</a>
<a name="ln345">    else {</a>
<a name="ln346">      IGMP_SOURCE_DONT_SEND(src-&gt;source_flags);</a>
<a name="ln347">    }</a>
<a name="ln348">  }</a>
<a name="ln349"> </a>
<a name="ln350">  return num_marked_sources;</a>
<a name="ln351">}</a>
<a name="ln352"> </a>
<a name="ln353">static void source_clear_send_flag(struct list *source_list)</a>
<a name="ln354">{</a>
<a name="ln355">  struct listnode    *src_node;</a>
<a name="ln356">  struct igmp_source *src;</a>
<a name="ln357"> </a>
<a name="ln358">  for (ALL_LIST_ELEMENTS_RO(source_list, src_node, src)) {</a>
<a name="ln359">    IGMP_SOURCE_DONT_SEND(src-&gt;source_flags);</a>
<a name="ln360">  }</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">/*</a>
<a name="ln364">  Any source (*,G) is forwarded only if mode is EXCLUDE {empty}</a>
<a name="ln365">*/</a>
<a name="ln366">static void group_exclude_fwd_anysrc_ifempty(struct igmp_group *group)</a>
<a name="ln367">{</a>
<a name="ln368">  zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln369"> </a>
<a name="ln370">  if (listcount(group-&gt;group_source_list) &lt; 1) {</a>
<a name="ln371">    igmp_anysource_forward_start(group);</a>
<a name="ln372">  }</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">void igmp_source_free(struct igmp_source *source)</a>
<a name="ln376">{</a>
<a name="ln377">  /* make sure there is no source timer running */</a>
<a name="ln378">  zassert(!source-&gt;t_source_timer);</a>
<a name="ln379"> </a>
<a name="ln380">  XFREE(MTYPE_PIM_IGMP_GROUP_SOURCE, source);</a>
<a name="ln381">}</a>
<a name="ln382"> </a>
<a name="ln383">static void source_channel_oil_detach(struct igmp_source *source)</a>
<a name="ln384">{</a>
<a name="ln385">  if (source-&gt;source_channel_oil) {</a>
<a name="ln386">    pim_channel_oil_del(source-&gt;source_channel_oil);</a>
<a name="ln387">    source-&gt;source_channel_oil = 0;</a>
<a name="ln388">  }</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">/*</a>
<a name="ln392">  igmp_source_delete:       stop fowarding, and delete the source</a>
<a name="ln393">  igmp_source_forward_stop: stop fowarding, but keep the source</a>
<a name="ln394">*/</a>
<a name="ln395">void igmp_source_delete(struct igmp_source *source)</a>
<a name="ln396">{</a>
<a name="ln397">  struct igmp_group *group;</a>
<a name="ln398"> </a>
<a name="ln399">  group = source-&gt;source_group;</a>
<a name="ln400"> </a>
<a name="ln401">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln402">    char group_str[100];</a>
<a name="ln403">    char source_str[100];</a>
<a name="ln404">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln405">    pim_inet4_dump(&quot;&lt;source?&gt;&quot;, source-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln406">    zlog_debug(&quot;Deleting IGMP source %s for group %s from socket %d interface %s&quot;,</a>
<a name="ln407">	       source_str, group_str,</a>
<a name="ln408">	       group-&gt;group_igmp_sock-&gt;fd,</a>
<a name="ln409">	       group-&gt;group_igmp_sock-&gt;interface-&gt;name);</a>
<a name="ln410">  }</a>
<a name="ln411"> </a>
<a name="ln412">  source_timer_off(group, source);</a>
<a name="ln413">  igmp_source_forward_stop(source);</a>
<a name="ln414"> </a>
<a name="ln415">  /* sanity check that forwarding has been disabled */</a>
<a name="ln416">  if (IGMP_SOURCE_TEST_FORWARDING(source-&gt;source_flags)) {</a>
<a name="ln417">    char group_str[100];</a>
<a name="ln418">    char source_str[100];</a>
<a name="ln419">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln420">    pim_inet4_dump(&quot;&lt;source?&gt;&quot;, source-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln421">    zlog_warn(&quot;%s: forwarding=ON(!) IGMP source %s for group %s from socket %d interface %s&quot;,</a>
<a name="ln422">	      __PRETTY_FUNCTION__,</a>
<a name="ln423">	      source_str, group_str,</a>
<a name="ln424">	      group-&gt;group_igmp_sock-&gt;fd,</a>
<a name="ln425">	      group-&gt;group_igmp_sock-&gt;interface-&gt;name);</a>
<a name="ln426">    /* warning only */</a>
<a name="ln427">  }</a>
<a name="ln428"> </a>
<a name="ln429">  source_channel_oil_detach(source);</a>
<a name="ln430"> </a>
<a name="ln431">  /*</a>
<a name="ln432">    notice that listnode_delete() can't be moved</a>
<a name="ln433">    into igmp_source_free() because the later is</a>
<a name="ln434">    called by list_delete_all_node()</a>
<a name="ln435">  */</a>
<a name="ln436">  listnode_delete(group-&gt;group_source_list, source);</a>
<a name="ln437"> </a>
<a name="ln438">  igmp_source_free(source);</a>
<a name="ln439"> </a>
<a name="ln440">  if (group-&gt;group_filtermode_isexcl) {</a>
<a name="ln441">    group_exclude_fwd_anysrc_ifempty(group);</a>
<a name="ln442">  }</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">static void source_delete_by_flag(struct list *source_list)</a>
<a name="ln446">{</a>
<a name="ln447">  struct listnode    *src_node;</a>
<a name="ln448">  struct listnode    *src_nextnode;</a>
<a name="ln449">  struct igmp_source *src;</a>
<a name="ln450">  </a>
<a name="ln451">  for (ALL_LIST_ELEMENTS(source_list, src_node, src_nextnode, src))</a>
<a name="ln452">    if (IGMP_SOURCE_TEST_DELETE(src-&gt;source_flags))</a>
<a name="ln453">      igmp_source_delete(src);</a>
<a name="ln454">}</a>
<a name="ln455"> </a>
<a name="ln456">void igmp_source_delete_expired(struct list *source_list)</a>
<a name="ln457">{</a>
<a name="ln458">  struct listnode    *src_node;</a>
<a name="ln459">  struct listnode    *src_nextnode;</a>
<a name="ln460">  struct igmp_source *src;</a>
<a name="ln461">  </a>
<a name="ln462">  for (ALL_LIST_ELEMENTS(source_list, src_node, src_nextnode, src))</a>
<a name="ln463">    if (!src-&gt;t_source_timer)</a>
<a name="ln464">      igmp_source_delete(src);</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">struct igmp_source *igmp_find_source_by_addr(struct igmp_group *group,</a>
<a name="ln468">					     struct in_addr src_addr)</a>
<a name="ln469">{</a>
<a name="ln470">  struct listnode    *src_node;</a>
<a name="ln471">  struct igmp_source *src;</a>
<a name="ln472"> </a>
<a name="ln473">  for (ALL_LIST_ELEMENTS_RO(group-&gt;group_source_list, src_node, src))</a>
<a name="ln474">    if (src_addr.s_addr == src-&gt;source_addr.s_addr)</a>
<a name="ln475">      return src;</a>
<a name="ln476"> </a>
<a name="ln477">  return 0;</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">struct igmp_source *</a>
<a name="ln481">source_new (struct igmp_group *group,</a>
<a name="ln482">	    struct in_addr src_addr)</a>
<a name="ln483">{</a>
<a name="ln484">  struct igmp_source *src;</a>
<a name="ln485"> </a>
<a name="ln486">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln487">    char group_str[100];</a>
<a name="ln488">    char source_str[100];</a>
<a name="ln489">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln490">    pim_inet4_dump(&quot;&lt;source?&gt;&quot;, src_addr, source_str, sizeof(source_str));</a>
<a name="ln491">    zlog_debug(&quot;Creating new IGMP source %s for group %s on socket %d interface %s&quot;,</a>
<a name="ln492">	       source_str, group_str,</a>
<a name="ln493">	       group-&gt;group_igmp_sock-&gt;fd,</a>
<a name="ln494">	       group-&gt;group_igmp_sock-&gt;interface-&gt;name);</a>
<a name="ln495">  }</a>
<a name="ln496"> </a>
<a name="ln497">  src = XMALLOC(MTYPE_PIM_IGMP_GROUP_SOURCE, sizeof(*src));</a>
<a name="ln498">  if (!src) {</a>
<a name="ln499">    zlog_warn(&quot;%s %s: XMALLOC() failure&quot;,</a>
<a name="ln500">	      __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln501">    return 0; /* error, not found, could not create */</a>
<a name="ln502">  }</a>
<a name="ln503">  </a>
<a name="ln504">  src-&gt;t_source_timer                = NULL;</a>
<a name="ln505">  src-&gt;source_group                  = group; /* back pointer */</a>
<a name="ln506">  src-&gt;source_addr                   = src_addr;</a>
<a name="ln507">  src-&gt;source_creation               = pim_time_monotonic_sec();</a>
<a name="ln508">  src-&gt;source_flags                  = 0;</a>
<a name="ln509">  src-&gt;source_query_retransmit_count = 0;</a>
<a name="ln510">  src-&gt;source_channel_oil            = NULL;</a>
<a name="ln511"> </a>
<a name="ln512">  listnode_add(group-&gt;group_source_list, src);</a>
<a name="ln513"> </a>
<a name="ln514">  zassert(!src-&gt;t_source_timer); /* source timer == 0 */</a>
<a name="ln515"> </a>
<a name="ln516">  /* Any source (*,G) is forwarded only if mode is EXCLUDE {empty} */</a>
<a name="ln517">  igmp_anysource_forward_stop(group);</a>
<a name="ln518"> </a>
<a name="ln519">  return src;</a>
<a name="ln520">}</a>
<a name="ln521"> </a>
<a name="ln522">static struct igmp_source *add_source_by_addr(struct igmp_sock *igmp,</a>
<a name="ln523">					      struct igmp_group *group,</a>
<a name="ln524">					      struct in_addr src_addr)</a>
<a name="ln525">{</a>
<a name="ln526">  struct igmp_source *src;</a>
<a name="ln527"> </a>
<a name="ln528">  src = igmp_find_source_by_addr(group, src_addr);</a>
<a name="ln529">  if (src) {</a>
<a name="ln530">    return src;</a>
<a name="ln531">  }</a>
<a name="ln532"> </a>
<a name="ln533">  src = source_new(group, src_addr);</a>
<a name="ln534">  if (!src) {</a>
<a name="ln535">    return 0;</a>
<a name="ln536">  }</a>
<a name="ln537"> </a>
<a name="ln538">  return src;</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">static void allow(struct igmp_sock *igmp, struct in_addr from,</a>
<a name="ln542">		  struct in_addr group_addr,</a>
<a name="ln543">		  int num_sources, struct in_addr *sources)</a>
<a name="ln544">{</a>
<a name="ln545">  struct igmp_group *group;</a>
<a name="ln546">  int    i;</a>
<a name="ln547"> </a>
<a name="ln548">  /* non-existant group is created as INCLUDE {empty} */</a>
<a name="ln549">  group = igmp_add_group_by_addr(igmp, group_addr);</a>
<a name="ln550">  if (!group) {</a>
<a name="ln551">    return;</a>
<a name="ln552">  }</a>
<a name="ln553"> </a>
<a name="ln554">  /* scan received sources */</a>
<a name="ln555">  for (i = 0; i &lt; num_sources; ++i) {</a>
<a name="ln556">    struct igmp_source *source;</a>
<a name="ln557">    struct in_addr     *src_addr;</a>
<a name="ln558"> </a>
<a name="ln559">    src_addr = sources + i;</a>
<a name="ln560"> </a>
<a name="ln561">    source = add_source_by_addr(igmp, group, *src_addr);</a>
<a name="ln562">    if (!source) {</a>
<a name="ln563">      continue;</a>
<a name="ln564">    }</a>
<a name="ln565"> </a>
<a name="ln566">    /*</a>
<a name="ln567">      RFC 3376: 6.4.1. Reception of Current-State Records</a>
<a name="ln568"> </a>
<a name="ln569">      When receiving IS_IN reports for groups in EXCLUDE mode is</a>
<a name="ln570">      sources should be moved from set with (timers = 0) to set with</a>
<a name="ln571">      (timers &gt; 0).</a>
<a name="ln572"> </a>
<a name="ln573">      igmp_source_reset_gmi() below, resetting the source timers to</a>
<a name="ln574">      GMI, accomplishes this.</a>
<a name="ln575">    */</a>
<a name="ln576">    igmp_source_reset_gmi(igmp, group, source);</a>
<a name="ln577"> </a>
<a name="ln578">  } /* scan received sources */</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">void igmpv3_report_isin(struct igmp_sock *igmp, struct in_addr from,</a>
<a name="ln582">			struct in_addr group_addr,</a>
<a name="ln583">			int num_sources, struct in_addr *sources)</a>
<a name="ln584">{</a>
<a name="ln585">  on_trace(__PRETTY_FUNCTION__,</a>
<a name="ln586">	   igmp-&gt;interface, from, group_addr, num_sources, sources);</a>
<a name="ln587"> </a>
<a name="ln588">  allow(igmp, from, group_addr, num_sources, sources);</a>
<a name="ln589">}</a>
<a name="ln590"> </a>
<a name="ln591">static void isex_excl(struct igmp_group *group,</a>
<a name="ln592">		      int num_sources, struct in_addr *sources)</a>
<a name="ln593">{</a>
<a name="ln594">  int     i;</a>
<a name="ln595"> </a>
<a name="ln596">  /* EXCLUDE mode */</a>
<a name="ln597">  zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln598">  </a>
<a name="ln599">  /* E.1: set deletion flag for known sources (X,Y) */</a>
<a name="ln600">  source_mark_delete_flag(group-&gt;group_source_list);</a>
<a name="ln601"> </a>
<a name="ln602">  /* scan received sources (A) */</a>
<a name="ln603">  for (i = 0; i &lt; num_sources; ++i) {</a>
<a name="ln604">    struct igmp_source *source;</a>
<a name="ln605">    struct in_addr     *src_addr;</a>
<a name="ln606"> </a>
<a name="ln607">    src_addr = sources + i;</a>
<a name="ln608"> </a>
<a name="ln609">    /* E.2: lookup reported source from (A) in (X,Y) */</a>
<a name="ln610">    source = igmp_find_source_by_addr(group, *src_addr);</a>
<a name="ln611">    if (source) {</a>
<a name="ln612">      /* E.3: if found, clear deletion flag: (X*A) or (Y*A) */</a>
<a name="ln613">      IGMP_SOURCE_DONT_DELETE(source-&gt;source_flags);</a>
<a name="ln614">    }</a>
<a name="ln615">    else {</a>
<a name="ln616">      /* E.4: if not found, create source with timer=GMI: (A-X-Y) */</a>
<a name="ln617">      source = source_new(group, *src_addr);</a>
<a name="ln618">      if (!source) {</a>
<a name="ln619">	/* ugh, internal malloc failure, skip source */</a>
<a name="ln620">	continue;</a>
<a name="ln621">      }</a>
<a name="ln622">      zassert(!source-&gt;t_source_timer); /* timer == 0 */</a>
<a name="ln623">      igmp_source_reset_gmi(group-&gt;group_igmp_sock, group, source);</a>
<a name="ln624">      zassert(source-&gt;t_source_timer); /* (A-X-Y) timer &gt; 0 */</a>
<a name="ln625">    }</a>
<a name="ln626"> </a>
<a name="ln627">  } /* scan received sources */</a>
<a name="ln628"> </a>
<a name="ln629">  /* E.5: delete all sources marked with deletion flag: (X-A) and (Y-A) */</a>
<a name="ln630">  source_delete_by_flag(group-&gt;group_source_list);</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">static void isex_incl(struct igmp_group *group,</a>
<a name="ln634">		      int num_sources, struct in_addr *sources)</a>
<a name="ln635">{</a>
<a name="ln636">  int i;</a>
<a name="ln637"> </a>
<a name="ln638">  /* INCLUDE mode */</a>
<a name="ln639">  zassert(!group-&gt;group_filtermode_isexcl);</a>
<a name="ln640">  </a>
<a name="ln641">  /* I.1: set deletion flag for known sources (A) */</a>
<a name="ln642">  source_mark_delete_flag(group-&gt;group_source_list);</a>
<a name="ln643"> </a>
<a name="ln644">  /* scan received sources (B) */</a>
<a name="ln645">  for (i = 0; i &lt; num_sources; ++i) {</a>
<a name="ln646">    struct igmp_source *source;</a>
<a name="ln647">    struct in_addr     *src_addr;</a>
<a name="ln648"> </a>
<a name="ln649">    src_addr = sources + i;</a>
<a name="ln650"> </a>
<a name="ln651">    /* I.2: lookup reported source (B) */</a>
<a name="ln652">    source = igmp_find_source_by_addr(group, *src_addr);</a>
<a name="ln653">    if (source) {</a>
<a name="ln654">      /* I.3: if found, clear deletion flag (A*B) */</a>
<a name="ln655">      IGMP_SOURCE_DONT_DELETE(source-&gt;source_flags);</a>
<a name="ln656">    }</a>
<a name="ln657">    else {</a>
<a name="ln658">      /* I.4: if not found, create source with timer=0 (B-A) */</a>
<a name="ln659">      source = source_new(group, *src_addr);</a>
<a name="ln660">      if (!source) {</a>
<a name="ln661">	/* ugh, internal malloc failure, skip source */</a>
<a name="ln662">	continue;</a>
<a name="ln663">      }</a>
<a name="ln664">      zassert(!source-&gt;t_source_timer); /* (B-A) timer=0 */</a>
<a name="ln665">    }</a>
<a name="ln666"> </a>
<a name="ln667">  } /* scan received sources */</a>
<a name="ln668"> </a>
<a name="ln669">  /* I.5: delete all sources marked with deletion flag (A-B) */</a>
<a name="ln670">  source_delete_by_flag(group-&gt;group_source_list);</a>
<a name="ln671"> </a>
<a name="ln672">  group-&gt;group_filtermode_isexcl = 1; /* boolean=true */</a>
<a name="ln673"> </a>
<a name="ln674">  zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln675"> </a>
<a name="ln676">  group_exclude_fwd_anysrc_ifempty(group);</a>
<a name="ln677">}</a>
<a name="ln678"> </a>
<a name="ln679">void igmpv3_report_isex(struct igmp_sock *igmp, struct in_addr from,</a>
<a name="ln680">			struct in_addr group_addr,</a>
<a name="ln681">			int num_sources, struct in_addr *sources)</a>
<a name="ln682">{</a>
<a name="ln683">  struct interface *ifp = igmp-&gt;interface;</a>
<a name="ln684">  struct igmp_group *group;</a>
<a name="ln685"> </a>
<a name="ln686">  on_trace(__PRETTY_FUNCTION__,</a>
<a name="ln687">	   ifp, from, group_addr, num_sources, sources);</a>
<a name="ln688"> </a>
<a name="ln689">  /* non-existant group is created as INCLUDE {empty} */</a>
<a name="ln690">  group = igmp_add_group_by_addr(igmp, group_addr);</a>
<a name="ln691">  if (!group) {</a>
<a name="ln692">    return;</a>
<a name="ln693">  }</a>
<a name="ln694"> </a>
<a name="ln695">  if (group-&gt;group_filtermode_isexcl) {</a>
<a name="ln696">    /* EXCLUDE mode */</a>
<a name="ln697">    isex_excl(group, num_sources, sources);</a>
<a name="ln698">  }</a>
<a name="ln699">  else {</a>
<a name="ln700">    /* INCLUDE mode */</a>
<a name="ln701">    isex_incl(group, num_sources, sources);</a>
<a name="ln702">    zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln703">  }</a>
<a name="ln704"> </a>
<a name="ln705">  zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln706"> </a>
<a name="ln707">  igmp_group_reset_gmi(group);</a>
<a name="ln708">}</a>
<a name="ln709"> </a>
<a name="ln710">static void toin_incl(struct igmp_group *group,</a>
<a name="ln711">		      int num_sources, struct in_addr *sources)</a>
<a name="ln712">{</a>
<a name="ln713">  struct igmp_sock *igmp = group-&gt;group_igmp_sock;</a>
<a name="ln714">  int num_sources_tosend = listcount(group-&gt;group_source_list);</a>
<a name="ln715">  int i;</a>
<a name="ln716"> </a>
<a name="ln717">  /* Set SEND flag for all known sources (A) */</a>
<a name="ln718">  source_mark_send_flag(group-&gt;group_source_list);</a>
<a name="ln719"> </a>
<a name="ln720">  /* Scan received sources (B) */</a>
<a name="ln721">  for (i = 0; i &lt; num_sources; ++i) {</a>
<a name="ln722">    struct igmp_source *source;</a>
<a name="ln723">    struct in_addr     *src_addr;</a>
<a name="ln724"> </a>
<a name="ln725">    src_addr = sources + i;</a>
<a name="ln726"> </a>
<a name="ln727">    /* Lookup reported source (B) */</a>
<a name="ln728">    source = igmp_find_source_by_addr(group, *src_addr);</a>
<a name="ln729">    if (source) {</a>
<a name="ln730">      /* If found, clear SEND flag (A*B) */</a>
<a name="ln731">      IGMP_SOURCE_DONT_SEND(source-&gt;source_flags);</a>
<a name="ln732">      --num_sources_tosend;</a>
<a name="ln733">    }</a>
<a name="ln734">    else {</a>
<a name="ln735">      /* If not found, create new source */</a>
<a name="ln736">      source = source_new(group, *src_addr);</a>
<a name="ln737">      if (!source) {</a>
<a name="ln738">	/* ugh, internal malloc failure, skip source */</a>
<a name="ln739">	continue;</a>
<a name="ln740">      }</a>
<a name="ln741">    }</a>
<a name="ln742"> </a>
<a name="ln743">    /* (B)=GMI */</a>
<a name="ln744">    igmp_source_reset_gmi(igmp, group, source);</a>
<a name="ln745">  }</a>
<a name="ln746"> </a>
<a name="ln747">  /* Send sources marked with SEND flag: Q(G,A-B) */</a>
<a name="ln748">  if (num_sources_tosend &gt; 0) {</a>
<a name="ln749">    source_query_send_by_flag(group, num_sources_tosend);</a>
<a name="ln750">  }</a>
<a name="ln751">}</a>
<a name="ln752"> </a>
<a name="ln753">static void toin_excl(struct igmp_group *group,</a>
<a name="ln754">		      int num_sources, struct in_addr *sources)</a>
<a name="ln755">{</a>
<a name="ln756">  struct igmp_sock *igmp = group-&gt;group_igmp_sock;</a>
<a name="ln757">  int num_sources_tosend;</a>
<a name="ln758">  int i;</a>
<a name="ln759"> </a>
<a name="ln760">  /* Set SEND flag for X (sources with timer &gt; 0) */</a>
<a name="ln761">  num_sources_tosend = source_mark_send_flag_by_timer(group-&gt;group_source_list);</a>
<a name="ln762"> </a>
<a name="ln763">  /* Scan received sources (A) */</a>
<a name="ln764">  for (i = 0; i &lt; num_sources; ++i) {</a>
<a name="ln765">    struct igmp_source *source;</a>
<a name="ln766">    struct in_addr     *src_addr;</a>
<a name="ln767"> </a>
<a name="ln768">    src_addr = sources + i;</a>
<a name="ln769"> </a>
<a name="ln770">    /* Lookup reported source (A) */</a>
<a name="ln771">    source = igmp_find_source_by_addr(group, *src_addr);</a>
<a name="ln772">    if (source) {</a>
<a name="ln773">      if (source-&gt;t_source_timer) {</a>
<a name="ln774">	/* If found and timer running, clear SEND flag (X*A) */</a>
<a name="ln775">	IGMP_SOURCE_DONT_SEND(source-&gt;source_flags);</a>
<a name="ln776">	--num_sources_tosend;</a>
<a name="ln777">      }</a>
<a name="ln778">    }</a>
<a name="ln779">    else {</a>
<a name="ln780">      /* If not found, create new source */</a>
<a name="ln781">      source = source_new(group, *src_addr);</a>
<a name="ln782">      if (!source) {</a>
<a name="ln783">	/* ugh, internal malloc failure, skip source */</a>
<a name="ln784">	continue;</a>
<a name="ln785">      }</a>
<a name="ln786">    }</a>
<a name="ln787"> </a>
<a name="ln788">    /* (A)=GMI */</a>
<a name="ln789">    igmp_source_reset_gmi(igmp, group, source);</a>
<a name="ln790">  }</a>
<a name="ln791"> </a>
<a name="ln792">  /* Send sources marked with SEND flag: Q(G,X-A) */</a>
<a name="ln793">  if (num_sources_tosend &gt; 0) {</a>
<a name="ln794">    source_query_send_by_flag(group, num_sources_tosend);</a>
<a name="ln795">  }</a>
<a name="ln796"> </a>
<a name="ln797">  /* Send Q(G) */</a>
<a name="ln798">  group_query_send(group);</a>
<a name="ln799">}</a>
<a name="ln800"> </a>
<a name="ln801">void igmpv3_report_toin(struct igmp_sock *igmp, struct in_addr from,</a>
<a name="ln802">			struct in_addr group_addr,</a>
<a name="ln803">			int num_sources, struct in_addr *sources)</a>
<a name="ln804">{</a>
<a name="ln805">  struct interface *ifp = igmp-&gt;interface;</a>
<a name="ln806">  struct igmp_group *group;</a>
<a name="ln807"> </a>
<a name="ln808">  on_trace(__PRETTY_FUNCTION__,</a>
<a name="ln809">	   ifp, from, group_addr, num_sources, sources);</a>
<a name="ln810"> </a>
<a name="ln811">  /* non-existant group is created as INCLUDE {empty} */</a>
<a name="ln812">  group = igmp_add_group_by_addr(igmp, group_addr);</a>
<a name="ln813">  if (!group) {</a>
<a name="ln814">    return;</a>
<a name="ln815">  }</a>
<a name="ln816"> </a>
<a name="ln817">  if (group-&gt;group_filtermode_isexcl) {</a>
<a name="ln818">    /* EXCLUDE mode */</a>
<a name="ln819">    toin_excl(group, num_sources, sources);</a>
<a name="ln820">  }</a>
<a name="ln821">  else {</a>
<a name="ln822">    /* INCLUDE mode */</a>
<a name="ln823">    toin_incl(group, num_sources, sources);</a>
<a name="ln824">  }</a>
<a name="ln825">}</a>
<a name="ln826"> </a>
<a name="ln827">static void toex_incl(struct igmp_group *group,</a>
<a name="ln828">		      int num_sources, struct in_addr *sources)</a>
<a name="ln829">{</a>
<a name="ln830">  int num_sources_tosend = 0;</a>
<a name="ln831">  int i;</a>
<a name="ln832"> </a>
<a name="ln833">  zassert(!group-&gt;group_filtermode_isexcl);</a>
<a name="ln834"> </a>
<a name="ln835">  /* Set DELETE flag for all known sources (A) */</a>
<a name="ln836">  source_mark_delete_flag(group-&gt;group_source_list);</a>
<a name="ln837"> </a>
<a name="ln838">  /* Clear off SEND flag from all known sources (A) */</a>
<a name="ln839">  source_clear_send_flag(group-&gt;group_source_list);</a>
<a name="ln840"> </a>
<a name="ln841">  /* Scan received sources (B) */</a>
<a name="ln842">  for (i = 0; i &lt; num_sources; ++i) {</a>
<a name="ln843">    struct igmp_source *source;</a>
<a name="ln844">    struct in_addr     *src_addr;</a>
<a name="ln845"> </a>
<a name="ln846">    src_addr = sources + i;</a>
<a name="ln847"> </a>
<a name="ln848">    /* Lookup reported source (B) */</a>
<a name="ln849">    source = igmp_find_source_by_addr(group, *src_addr);</a>
<a name="ln850">    if (source) {</a>
<a name="ln851">      /* If found, clear deletion flag: (A*B) */</a>
<a name="ln852">      IGMP_SOURCE_DONT_DELETE(source-&gt;source_flags);</a>
<a name="ln853">      /* and set SEND flag (A*B) */</a>
<a name="ln854">      IGMP_SOURCE_DO_SEND(source-&gt;source_flags);</a>
<a name="ln855">      ++num_sources_tosend;</a>
<a name="ln856">    }</a>
<a name="ln857">    else {</a>
<a name="ln858">      /* If source not found, create source with timer=0: (B-A)=0 */</a>
<a name="ln859">      source = source_new(group, *src_addr);</a>
<a name="ln860">      if (!source) {</a>
<a name="ln861">	/* ugh, internal malloc failure, skip source */</a>
<a name="ln862">	continue;</a>
<a name="ln863">      }</a>
<a name="ln864">      zassert(!source-&gt;t_source_timer); /* (B-A) timer=0 */</a>
<a name="ln865">    }</a>
<a name="ln866"> </a>
<a name="ln867">  } /* Scan received sources (B) */</a>
<a name="ln868"> </a>
<a name="ln869">  group-&gt;group_filtermode_isexcl = 1; /* boolean=true */</a>
<a name="ln870"> </a>
<a name="ln871">  /* Delete all sources marked with DELETE flag (A-B) */</a>
<a name="ln872">  source_delete_by_flag(group-&gt;group_source_list);</a>
<a name="ln873"> </a>
<a name="ln874">  /* Send sources marked with SEND flag: Q(G,A*B) */</a>
<a name="ln875">  if (num_sources_tosend &gt; 0) {</a>
<a name="ln876">    source_query_send_by_flag(group, num_sources_tosend);</a>
<a name="ln877">  }</a>
<a name="ln878"> </a>
<a name="ln879">  zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln880"> </a>
<a name="ln881">  group_exclude_fwd_anysrc_ifempty(group);</a>
<a name="ln882">}</a>
<a name="ln883"> </a>
<a name="ln884">static void toex_excl(struct igmp_group *group,</a>
<a name="ln885">		      int num_sources, struct in_addr *sources)</a>
<a name="ln886">{</a>
<a name="ln887">  int num_sources_tosend = 0;</a>
<a name="ln888">  int i;</a>
<a name="ln889"> </a>
<a name="ln890">  /* set DELETE flag for all known sources (X,Y) */</a>
<a name="ln891">  source_mark_delete_flag(group-&gt;group_source_list);</a>
<a name="ln892"> </a>
<a name="ln893">  /* clear off SEND flag from all known sources (X,Y) */</a>
<a name="ln894">  source_clear_send_flag(group-&gt;group_source_list);</a>
<a name="ln895"> </a>
<a name="ln896">  /* scan received sources (A) */</a>
<a name="ln897">  for (i = 0; i &lt; num_sources; ++i) {</a>
<a name="ln898">    struct igmp_source *source;</a>
<a name="ln899">    struct in_addr     *src_addr;</a>
<a name="ln900">    </a>
<a name="ln901">    src_addr = sources + i;</a>
<a name="ln902">    </a>
<a name="ln903">    /* lookup reported source (A) in known sources (X,Y) */</a>
<a name="ln904">    source = igmp_find_source_by_addr(group, *src_addr);</a>
<a name="ln905">    if (source) {</a>
<a name="ln906">      /* if found, clear off DELETE flag from reported source (A) */</a>
<a name="ln907">      IGMP_SOURCE_DONT_DELETE(source-&gt;source_flags);</a>
<a name="ln908">    }</a>
<a name="ln909">    else {</a>
<a name="ln910">      /* if not found, create source with Group Timer: (A-X-Y)=Group Timer */</a>
<a name="ln911">      long group_timer_msec;</a>
<a name="ln912">      source = source_new(group, *src_addr);</a>
<a name="ln913">      if (!source) {</a>
<a name="ln914">	/* ugh, internal malloc failure, skip source */</a>
<a name="ln915">	continue;</a>
<a name="ln916">      }</a>
<a name="ln917"> </a>
<a name="ln918">      zassert(!source-&gt;t_source_timer); /* timer == 0 */</a>
<a name="ln919">      group_timer_msec = igmp_group_timer_remain_msec(group);</a>
<a name="ln920">      igmp_source_timer_on(group, source, group_timer_msec);</a>
<a name="ln921">      zassert(source-&gt;t_source_timer); /* (A-X-Y) timer &gt; 0 */</a>
<a name="ln922"> </a>
<a name="ln923">      /* make sure source is created with DELETE flag unset */</a>
<a name="ln924">      zassert(!IGMP_SOURCE_TEST_DELETE(source-&gt;source_flags));</a>
<a name="ln925">    }</a>
<a name="ln926"> </a>
<a name="ln927">    /* make sure reported source has DELETE flag unset */</a>
<a name="ln928">    zassert(!IGMP_SOURCE_TEST_DELETE(source-&gt;source_flags));</a>
<a name="ln929"> </a>
<a name="ln930">    if (source-&gt;t_source_timer) {</a>
<a name="ln931">      /* if source timer&gt;0 mark SEND flag: Q(G,A-Y) */</a>
<a name="ln932">      IGMP_SOURCE_DO_SEND(source-&gt;source_flags);</a>
<a name="ln933">      ++num_sources_tosend;</a>
<a name="ln934">    }</a>
<a name="ln935"> </a>
<a name="ln936">  } /* scan received sources (A) */</a>
<a name="ln937"> </a>
<a name="ln938">  /*</a>
<a name="ln939">    delete all sources marked with DELETE flag:</a>
<a name="ln940">    Delete (X-A)</a>
<a name="ln941">    Delete (Y-A)</a>
<a name="ln942">  */</a>
<a name="ln943">  source_delete_by_flag(group-&gt;group_source_list);</a>
<a name="ln944"> </a>
<a name="ln945">  /* send sources marked with SEND flag: Q(G,A-Y) */</a>
<a name="ln946">  if (num_sources_tosend &gt; 0) {</a>
<a name="ln947">    source_query_send_by_flag(group, num_sources_tosend);</a>
<a name="ln948">  }</a>
<a name="ln949">}</a>
<a name="ln950"> </a>
<a name="ln951">void igmpv3_report_toex(struct igmp_sock *igmp, struct in_addr from,</a>
<a name="ln952">			struct in_addr group_addr,</a>
<a name="ln953">			int num_sources, struct in_addr *sources)</a>
<a name="ln954">{</a>
<a name="ln955">  struct interface *ifp = igmp-&gt;interface;</a>
<a name="ln956">  struct igmp_group *group;</a>
<a name="ln957"> </a>
<a name="ln958">  on_trace(__PRETTY_FUNCTION__,</a>
<a name="ln959">	   ifp, from, group_addr, num_sources, sources);</a>
<a name="ln960"> </a>
<a name="ln961">  /* non-existant group is created as INCLUDE {empty} */</a>
<a name="ln962">  group = igmp_add_group_by_addr(igmp, group_addr);</a>
<a name="ln963">  if (!group) {</a>
<a name="ln964">    return;</a>
<a name="ln965">  }</a>
<a name="ln966"> </a>
<a name="ln967">  if (group-&gt;group_filtermode_isexcl) {</a>
<a name="ln968">    /* EXCLUDE mode */</a>
<a name="ln969">    toex_excl(group, num_sources, sources);</a>
<a name="ln970">  }</a>
<a name="ln971">  else {</a>
<a name="ln972">    /* INCLUDE mode */</a>
<a name="ln973">    toex_incl(group, num_sources, sources);</a>
<a name="ln974">    zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln975">  }</a>
<a name="ln976">  zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln977"> </a>
<a name="ln978">  /* Group Timer=GMI */</a>
<a name="ln979">  igmp_group_reset_gmi(group);</a>
<a name="ln980">}</a>
<a name="ln981"> </a>
<a name="ln982">void igmpv3_report_allow(struct igmp_sock *igmp, struct in_addr from,</a>
<a name="ln983">			 struct in_addr group_addr,</a>
<a name="ln984">			 int num_sources, struct in_addr *sources)</a>
<a name="ln985">{</a>
<a name="ln986">  on_trace(__PRETTY_FUNCTION__,</a>
<a name="ln987">	   igmp-&gt;interface, from, group_addr, num_sources, sources);</a>
<a name="ln988"> </a>
<a name="ln989">  allow(igmp, from, group_addr, num_sources, sources);</a>
<a name="ln990">}</a>
<a name="ln991"> </a>
<a name="ln992">/*</a>
<a name="ln993">  RFC3376: 6.6.3.1. Building and Sending Group Specific Queries</a>
<a name="ln994"> </a>
<a name="ln995">  When transmitting a group specific query, if the group timer is</a>
<a name="ln996">  larger than LMQT, the &quot;Suppress Router-Side Processing&quot; bit is set</a>
<a name="ln997">  in the query message.</a>
<a name="ln998">*/</a>
<a name="ln999">static void group_retransmit_group(struct igmp_group *group)</a>
<a name="ln1000">{</a>
<a name="ln1001">  char                  query_buf[PIM_IGMP_BUFSIZE_WRITE];</a>
<a name="ln1002">  struct igmp_sock     *igmp;</a>
<a name="ln1003">  struct pim_interface *pim_ifp;</a>
<a name="ln1004">  long                  lmqc;      /* Last Member Query Count */</a>
<a name="ln1005">  long                  lmqi_msec; /* Last Member Query Interval */</a>
<a name="ln1006">  long                  lmqt_msec; /* Last Member Query Time */</a>
<a name="ln1007">  int                   s_flag;</a>
<a name="ln1008"> </a>
<a name="ln1009">  igmp = group-&gt;group_igmp_sock;</a>
<a name="ln1010">  pim_ifp = igmp-&gt;interface-&gt;info;</a>
<a name="ln1011"> </a>
<a name="ln1012">  lmqc      = igmp-&gt;querier_robustness_variable;</a>
<a name="ln1013">  lmqi_msec = 100 * pim_ifp-&gt;igmp_specific_query_max_response_time_dsec;</a>
<a name="ln1014">  lmqt_msec = lmqc * lmqi_msec;</a>
<a name="ln1015"> </a>
<a name="ln1016">  /*</a>
<a name="ln1017">    RFC3376: 6.6.3.1. Building and Sending Group Specific Queries</a>
<a name="ln1018">    </a>
<a name="ln1019">    When transmitting a group specific query, if the group timer is</a>
<a name="ln1020">    larger than LMQT, the &quot;Suppress Router-Side Processing&quot; bit is set</a>
<a name="ln1021">    in the query message.</a>
<a name="ln1022">  */</a>
<a name="ln1023">  s_flag = igmp_group_timer_remain_msec(group) &gt; lmqt_msec;</a>
<a name="ln1024"> </a>
<a name="ln1025">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln1026">    char group_str[100];</a>
<a name="ln1027">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln1028">    zlog_debug(&quot;retransmit_group_specific_query: group %s on %s: s_flag=%d count=%d&quot;,</a>
<a name="ln1029">	       group_str, igmp-&gt;interface-&gt;name, s_flag,</a>
<a name="ln1030">	       group-&gt;group_specific_query_retransmit_count);</a>
<a name="ln1031">  }</a>
<a name="ln1032"> </a>
<a name="ln1033">  /*</a>
<a name="ln1034">    RFC3376: 4.1.12. IP Destination Addresses for Queries</a>
<a name="ln1035"> </a>
<a name="ln1036">    Group-Specific and Group-and-Source-Specific Queries are sent with</a>
<a name="ln1037">    an IP destination address equal to the multicast address of</a>
<a name="ln1038">    interest.</a>
<a name="ln1039">  */</a>
<a name="ln1040"> </a>
<a name="ln1041">  pim_igmp_send_membership_query(group,</a>
<a name="ln1042">				 igmp-&gt;fd,</a>
<a name="ln1043">				 igmp-&gt;interface-&gt;name,</a>
<a name="ln1044">				 query_buf,</a>
<a name="ln1045">				 sizeof(query_buf),</a>
<a name="ln1046">				 0 /* num_sources_tosend */,</a>
<a name="ln1047">				 group-&gt;group_addr /* dst_addr */,</a>
<a name="ln1048">				 group-&gt;group_addr /* group_addr */,</a>
<a name="ln1049">				 pim_ifp-&gt;igmp_specific_query_max_response_time_dsec,</a>
<a name="ln1050">				 s_flag,</a>
<a name="ln1051">				 igmp-&gt;querier_robustness_variable,</a>
<a name="ln1052">				 igmp-&gt;querier_query_interval);</a>
<a name="ln1053">}</a>
<a name="ln1054"> </a>
<a name="ln1055">/*</a>
<a name="ln1056">  RFC3376: 6.6.3.2. Building and Sending Group and Source Specific Queries</a>
<a name="ln1057"> </a>
<a name="ln1058">  When building a group and source specific query for a group G, two</a>
<a name="ln1059">  separate query messages are sent for the group.  The first one has</a>
<a name="ln1060">  the &quot;Suppress Router-Side Processing&quot; bit set and contains all the</a>
<a name="ln1061">  sources with retransmission state and timers greater than LMQT.  The</a>
<a name="ln1062">  second has the &quot;Suppress Router-Side Processing&quot; bit clear and</a>
<a name="ln1063">  contains all the sources with retransmission state and timers lower</a>
<a name="ln1064">  or equal to LMQT.  If either of the two calculated messages does not</a>
<a name="ln1065">  contain any sources, then its transmission is suppressed.</a>
<a name="ln1066"> */</a>
<a name="ln1067">static int group_retransmit_sources(struct igmp_group *group,</a>
<a name="ln1068">				    int send_with_sflag_set)</a>
<a name="ln1069">{</a>
<a name="ln1070">  struct igmp_sock     *igmp;</a>
<a name="ln1071">  struct pim_interface *pim_ifp;</a>
<a name="ln1072">  long                  lmqc;      /* Last Member Query Count */</a>
<a name="ln1073">  long                  lmqi_msec; /* Last Member Query Interval */</a>
<a name="ln1074">  long                  lmqt_msec; /* Last Member Query Time */</a>
<a name="ln1075">  char                  query_buf1[PIM_IGMP_BUFSIZE_WRITE]; /* 1 = with s_flag set */</a>
<a name="ln1076">  char                  query_buf2[PIM_IGMP_BUFSIZE_WRITE]; /* 2 = with s_flag clear */</a>
<a name="ln1077">  int                   query_buf1_max_sources;</a>
<a name="ln1078">  int                   query_buf2_max_sources;</a>
<a name="ln1079">  struct in_addr       *source_addr1;</a>
<a name="ln1080">  struct in_addr       *source_addr2;</a>
<a name="ln1081">  int                   num_sources_tosend1;</a>
<a name="ln1082">  int                   num_sources_tosend2;</a>
<a name="ln1083">  struct listnode      *src_node;</a>
<a name="ln1084">  struct igmp_source   *src;</a>
<a name="ln1085">  int                   num_retransmit_sources_left = 0;</a>
<a name="ln1086">  </a>
<a name="ln1087">  query_buf1_max_sources = (sizeof(query_buf1) - IGMP_V3_SOURCES_OFFSET) &gt;&gt; 2;</a>
<a name="ln1088">  query_buf2_max_sources = (sizeof(query_buf2) - IGMP_V3_SOURCES_OFFSET) &gt;&gt; 2;</a>
<a name="ln1089">  </a>
<a name="ln1090">  source_addr1 = (struct in_addr *)(query_buf1 + IGMP_V3_SOURCES_OFFSET);</a>
<a name="ln1091">  source_addr2 = (struct in_addr *)(query_buf2 + IGMP_V3_SOURCES_OFFSET);</a>
<a name="ln1092"> </a>
<a name="ln1093">  igmp = group-&gt;group_igmp_sock;</a>
<a name="ln1094">  pim_ifp = igmp-&gt;interface-&gt;info;</a>
<a name="ln1095"> </a>
<a name="ln1096">  lmqc      = igmp-&gt;querier_robustness_variable;</a>
<a name="ln1097">  lmqi_msec = 100 * pim_ifp-&gt;igmp_specific_query_max_response_time_dsec;</a>
<a name="ln1098">  lmqt_msec = lmqc * lmqi_msec;</a>
<a name="ln1099"> </a>
<a name="ln1100">  /* Scan all group sources */</a>
<a name="ln1101">  for (ALL_LIST_ELEMENTS_RO(group-&gt;group_source_list, src_node, src)) {</a>
<a name="ln1102"> </a>
<a name="ln1103">    /* Source has retransmission state? */</a>
<a name="ln1104">    if (src-&gt;source_query_retransmit_count &lt; 1)</a>
<a name="ln1105">      continue;</a>
<a name="ln1106"> </a>
<a name="ln1107">    if (--src-&gt;source_query_retransmit_count &gt; 0) {</a>
<a name="ln1108">      ++num_retransmit_sources_left;</a>
<a name="ln1109">    }</a>
<a name="ln1110"> </a>
<a name="ln1111">    /* Copy source address into appropriate query buffer */</a>
<a name="ln1112">    if (igmp_source_timer_remain_msec(src) &gt; lmqt_msec) {</a>
<a name="ln1113">      *source_addr1 = src-&gt;source_addr;</a>
<a name="ln1114">      ++source_addr1;</a>
<a name="ln1115">    }</a>
<a name="ln1116">    else {</a>
<a name="ln1117">      *source_addr2 = src-&gt;source_addr;</a>
<a name="ln1118">      ++source_addr2;</a>
<a name="ln1119">    }</a>
<a name="ln1120"> </a>
<a name="ln1121">  }</a>
<a name="ln1122">  </a>
<a name="ln1123">  num_sources_tosend1 = source_addr1 - (struct in_addr *)(query_buf1 + IGMP_V3_SOURCES_OFFSET);</a>
<a name="ln1124">  num_sources_tosend2 = source_addr2 - (struct in_addr *)(query_buf2 + IGMP_V3_SOURCES_OFFSET);</a>
<a name="ln1125"> </a>
<a name="ln1126">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln1127">    char group_str[100];</a>
<a name="ln1128">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln1129">    zlog_debug(&quot;retransmit_grp&amp;src_specific_query: group %s on %s: srcs_with_sflag=%d srcs_wo_sflag=%d will_send_sflag=%d retransmit_src_left=%d&quot;,</a>
<a name="ln1130">	       group_str, igmp-&gt;interface-&gt;name,</a>
<a name="ln1131">	       num_sources_tosend1,</a>
<a name="ln1132">	       num_sources_tosend2,</a>
<a name="ln1133">	       send_with_sflag_set,</a>
<a name="ln1134">	       num_retransmit_sources_left);</a>
<a name="ln1135">  }</a>
<a name="ln1136"> </a>
<a name="ln1137">  if (num_sources_tosend1 &gt; 0) {</a>
<a name="ln1138">    /*</a>
<a name="ln1139">      Send group-and-source-specific query with s_flag set and all</a>
<a name="ln1140">      sources with timers greater than LMQT.</a>
<a name="ln1141">    */</a>
<a name="ln1142"> </a>
<a name="ln1143">    if (send_with_sflag_set) {</a>
<a name="ln1144"> </a>
<a name="ln1145">      query_buf1_max_sources = (sizeof(query_buf1) - IGMP_V3_SOURCES_OFFSET) &gt;&gt; 2;</a>
<a name="ln1146">      if (num_sources_tosend1 &gt; query_buf1_max_sources) {</a>
<a name="ln1147">	char group_str[100];</a>
<a name="ln1148">	pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln1149">	zlog_warn(&quot;%s: group %s on %s: s_flag=1 unable to fit %d sources into buf_size=%zu (max_sources=%d)&quot;,</a>
<a name="ln1150">		  __PRETTY_FUNCTION__, group_str, igmp-&gt;interface-&gt;name,</a>
<a name="ln1151">		  num_sources_tosend1, sizeof(query_buf1), query_buf1_max_sources);</a>
<a name="ln1152">      }</a>
<a name="ln1153">      else {</a>
<a name="ln1154">	/*</a>
<a name="ln1155">	  RFC3376: 4.1.12. IP Destination Addresses for Queries</a>
<a name="ln1156">      </a>
<a name="ln1157">	  Group-Specific and Group-and-Source-Specific Queries are sent with</a>
<a name="ln1158">	  an IP destination address equal to the multicast address of</a>
<a name="ln1159">	  interest.</a>
<a name="ln1160">	*/</a>
<a name="ln1161">    </a>
<a name="ln1162">	pim_igmp_send_membership_query(group,</a>
<a name="ln1163">				       igmp-&gt;fd,</a>
<a name="ln1164">				       igmp-&gt;interface-&gt;name,</a>
<a name="ln1165">				       query_buf1,</a>
<a name="ln1166">				       sizeof(query_buf1),</a>
<a name="ln1167">				       num_sources_tosend1,</a>
<a name="ln1168">				       group-&gt;group_addr,</a>
<a name="ln1169">				       group-&gt;group_addr,</a>
<a name="ln1170">				       pim_ifp-&gt;igmp_specific_query_max_response_time_dsec,</a>
<a name="ln1171">				       1 /* s_flag */,</a>
<a name="ln1172">				       igmp-&gt;querier_robustness_variable,</a>
<a name="ln1173">				       igmp-&gt;querier_query_interval);</a>
<a name="ln1174">    </a>
<a name="ln1175">      }</a>
<a name="ln1176"> </a>
<a name="ln1177">    } /* send_with_sflag_set */</a>
<a name="ln1178"> </a>
<a name="ln1179">  }</a>
<a name="ln1180"> </a>
<a name="ln1181">  if (num_sources_tosend2 &gt; 0) {</a>
<a name="ln1182">    /*</a>
<a name="ln1183">      Send group-and-source-specific query with s_flag clear and all</a>
<a name="ln1184">      sources with timers lower or equal to LMQT.</a>
<a name="ln1185">    */</a>
<a name="ln1186">  </a>
<a name="ln1187">    query_buf2_max_sources = (sizeof(query_buf2) - IGMP_V3_SOURCES_OFFSET) &gt;&gt; 2;</a>
<a name="ln1188">    if (num_sources_tosend2 &gt; query_buf2_max_sources) {</a>
<a name="ln1189">      char group_str[100];</a>
<a name="ln1190">      pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln1191">      zlog_warn(&quot;%s: group %s on %s: s_flag=0 unable to fit %d sources into buf_size=%zu (max_sources=%d)&quot;,</a>
<a name="ln1192">		__PRETTY_FUNCTION__, group_str, igmp-&gt;interface-&gt;name,</a>
<a name="ln1193">		num_sources_tosend2, sizeof(query_buf2), query_buf2_max_sources);</a>
<a name="ln1194">    }</a>
<a name="ln1195">    else {</a>
<a name="ln1196">      /*</a>
<a name="ln1197">	RFC3376: 4.1.12. IP Destination Addresses for Queries</a>
<a name="ln1198"> </a>
<a name="ln1199">	Group-Specific and Group-and-Source-Specific Queries are sent with</a>
<a name="ln1200">	an IP destination address equal to the multicast address of</a>
<a name="ln1201">	interest.</a>
<a name="ln1202">      */</a>
<a name="ln1203"> </a>
<a name="ln1204">      pim_igmp_send_membership_query(group,</a>
<a name="ln1205">				     igmp-&gt;fd,</a>
<a name="ln1206">				     igmp-&gt;interface-&gt;name,</a>
<a name="ln1207">				     query_buf2,</a>
<a name="ln1208">				     sizeof(query_buf2),</a>
<a name="ln1209">				     num_sources_tosend2,</a>
<a name="ln1210">				     group-&gt;group_addr,</a>
<a name="ln1211">				     group-&gt;group_addr,</a>
<a name="ln1212">				     pim_ifp-&gt;igmp_specific_query_max_response_time_dsec,</a>
<a name="ln1213">				     0 /* s_flag */,</a>
<a name="ln1214">				     igmp-&gt;querier_robustness_variable,</a>
<a name="ln1215">				     igmp-&gt;querier_query_interval);</a>
<a name="ln1216"> </a>
<a name="ln1217">    }</a>
<a name="ln1218">  }</a>
<a name="ln1219"> </a>
<a name="ln1220">  return num_retransmit_sources_left;</a>
<a name="ln1221">}</a>
<a name="ln1222"> </a>
<a name="ln1223">static int igmp_group_retransmit(struct thread *t)</a>
<a name="ln1224">{</a>
<a name="ln1225">  struct igmp_group *group;</a>
<a name="ln1226">  int num_retransmit_sources_left;</a>
<a name="ln1227">  int send_with_sflag_set; /* boolean */</a>
<a name="ln1228"> </a>
<a name="ln1229">  zassert(t);</a>
<a name="ln1230">  group = THREAD_ARG(t);</a>
<a name="ln1231">  zassert(group);</a>
<a name="ln1232"> </a>
<a name="ln1233">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln1234">    char group_str[100];</a>
<a name="ln1235">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln1236">    zlog_debug(&quot;group_retransmit_timer: group %s on %s&quot;,</a>
<a name="ln1237">	       group_str, group-&gt;group_igmp_sock-&gt;interface-&gt;name);</a>
<a name="ln1238">  }</a>
<a name="ln1239"> </a>
<a name="ln1240">  /* Retransmit group-specific queries? (RFC3376: 6.6.3.1) */</a>
<a name="ln1241">  if (group-&gt;group_specific_query_retransmit_count &gt; 0) {</a>
<a name="ln1242"> </a>
<a name="ln1243">    /* Retransmit group-specific queries (RFC3376: 6.6.3.1) */</a>
<a name="ln1244">    group_retransmit_group(group);</a>
<a name="ln1245">    --group-&gt;group_specific_query_retransmit_count;</a>
<a name="ln1246"> </a>
<a name="ln1247">    /*</a>
<a name="ln1248">      RFC3376: 6.6.3.2</a>
<a name="ln1249">      If a group specific query is scheduled to be transmitted at the</a>
<a name="ln1250">      same time as a group and source specific query for the same group,</a>
<a name="ln1251">      then transmission of the group and source specific message with the</a>
<a name="ln1252">      &quot;Suppress Router-Side Processing&quot; bit set may be suppressed.</a>
<a name="ln1253">    */</a>
<a name="ln1254">    send_with_sflag_set = 0; /* boolean=false */</a>
<a name="ln1255">  }</a>
<a name="ln1256">  else {</a>
<a name="ln1257">    send_with_sflag_set = 1; /* boolean=true */</a>
<a name="ln1258">  }</a>
<a name="ln1259"> </a>
<a name="ln1260">  /* Retransmit group-and-source-specific queries (RFC3376: 6.6.3.2) */</a>
<a name="ln1261">  num_retransmit_sources_left = group_retransmit_sources(group,</a>
<a name="ln1262">							 send_with_sflag_set);</a>
<a name="ln1263"> </a>
<a name="ln1264">  group-&gt;t_group_query_retransmit_timer = 0;</a>
<a name="ln1265"> </a>
<a name="ln1266">  /*</a>
<a name="ln1267">    Keep group retransmit timer running if there is any retransmit</a>
<a name="ln1268">    counter pending</a>
<a name="ln1269">  */</a>
<a name="ln1270">  if ((num_retransmit_sources_left &gt; 0) ||</a>
<a name="ln1271">      (group-&gt;group_specific_query_retransmit_count &gt; 0)) {</a>
<a name="ln1272">    group_retransmit_timer_on(group);</a>
<a name="ln1273">  }</a>
<a name="ln1274"> </a>
<a name="ln1275">  return 0;</a>
<a name="ln1276">}</a>
<a name="ln1277"> </a>
<a name="ln1278">/*</a>
<a name="ln1279">  group_retransmit_timer_on:</a>
<a name="ln1280">  if group retransmit timer isn't running, starts it;</a>
<a name="ln1281">  otherwise, do nothing</a>
<a name="ln1282">*/</a>
<a name="ln1283">static void group_retransmit_timer_on(struct igmp_group *group)</a>
<a name="ln1284">{</a>
<a name="ln1285">  struct igmp_sock     *igmp;</a>
<a name="ln1286">  struct pim_interface *pim_ifp;</a>
<a name="ln1287">  long                  lmqi_msec; /* Last Member Query Interval */</a>
<a name="ln1288"> </a>
<a name="ln1289">  /* if group retransmit timer is running, do nothing */</a>
<a name="ln1290">  if (group-&gt;t_group_query_retransmit_timer) {</a>
<a name="ln1291">    return;</a>
<a name="ln1292">  }</a>
<a name="ln1293"> </a>
<a name="ln1294">  igmp = group-&gt;group_igmp_sock;</a>
<a name="ln1295">  pim_ifp = igmp-&gt;interface-&gt;info;</a>
<a name="ln1296"> </a>
<a name="ln1297">  lmqi_msec = 100 * pim_ifp-&gt;igmp_specific_query_max_response_time_dsec;</a>
<a name="ln1298"> </a>
<a name="ln1299">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln1300">    char group_str[100];</a>
<a name="ln1301">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln1302">    zlog_debug(&quot;Scheduling %ld.%03ld sec retransmit timer for group %s on %s&quot;,</a>
<a name="ln1303">	       lmqi_msec / 1000,</a>
<a name="ln1304">	       lmqi_msec % 1000,</a>
<a name="ln1305">	       group_str,</a>
<a name="ln1306">	       igmp-&gt;interface-&gt;name);</a>
<a name="ln1307">  }</a>
<a name="ln1308"> </a>
<a name="ln1309">  THREAD_TIMER_MSEC_ON(master, group-&gt;t_group_query_retransmit_timer,</a>
<a name="ln1310">		       igmp_group_retransmit,</a>
<a name="ln1311">		       group, lmqi_msec);</a>
<a name="ln1312">}</a>
<a name="ln1313"> </a>
<a name="ln1314">static long igmp_group_timer_remain_msec(struct igmp_group *group)</a>
<a name="ln1315">{</a>
<a name="ln1316">  return pim_time_timer_remain_msec(group-&gt;t_group_timer);</a>
<a name="ln1317">}</a>
<a name="ln1318"> </a>
<a name="ln1319">static long igmp_source_timer_remain_msec(struct igmp_source *source)</a>
<a name="ln1320">{</a>
<a name="ln1321">  return pim_time_timer_remain_msec(source-&gt;t_source_timer);</a>
<a name="ln1322">}</a>
<a name="ln1323"> </a>
<a name="ln1324">/*</a>
<a name="ln1325">  RFC3376: 6.6.3.1. Building and Sending Group Specific Queries</a>
<a name="ln1326">*/</a>
<a name="ln1327">static void group_query_send(struct igmp_group *group)</a>
<a name="ln1328">{</a>
<a name="ln1329">  long              lmqc;    /* Last Member Query Count */</a>
<a name="ln1330"> </a>
<a name="ln1331">  lmqc = group-&gt;group_igmp_sock-&gt;querier_robustness_variable;</a>
<a name="ln1332"> </a>
<a name="ln1333">  /* lower group timer to lmqt */</a>
<a name="ln1334">  igmp_group_timer_lower_to_lmqt(group);</a>
<a name="ln1335"> </a>
<a name="ln1336">  /* reset retransmission counter */</a>
<a name="ln1337">  group-&gt;group_specific_query_retransmit_count = lmqc;</a>
<a name="ln1338"> </a>
<a name="ln1339">  /* immediately send group specific query (decrease retransmit counter by 1)*/</a>
<a name="ln1340">  group_retransmit_group(group);</a>
<a name="ln1341"> </a>
<a name="ln1342">  /* make sure group retransmit timer is running */</a>
<a name="ln1343">  group_retransmit_timer_on(group);</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">/*</a>
<a name="ln1347">  RFC3376: 6.6.3.2. Building and Sending Group and Source Specific Queries</a>
<a name="ln1348">*/</a>
<a name="ln1349">static void source_query_send_by_flag(struct igmp_group *group,</a>
<a name="ln1350">				      int num_sources_tosend)</a>
<a name="ln1351">{</a>
<a name="ln1352">  struct igmp_sock     *igmp;</a>
<a name="ln1353">  struct pim_interface *pim_ifp;</a>
<a name="ln1354">  struct listnode      *src_node;</a>
<a name="ln1355">  struct igmp_source   *src;</a>
<a name="ln1356">  long                  lmqc;      /* Last Member Query Count */</a>
<a name="ln1357">  long                  lmqi_msec; /* Last Member Query Interval */</a>
<a name="ln1358">  long                  lmqt_msec; /* Last Member Query Time */</a>
<a name="ln1359"> </a>
<a name="ln1360">  zassert(num_sources_tosend &gt; 0);</a>
<a name="ln1361"> </a>
<a name="ln1362">  igmp = group-&gt;group_igmp_sock;</a>
<a name="ln1363">  pim_ifp = igmp-&gt;interface-&gt;info;</a>
<a name="ln1364"> </a>
<a name="ln1365">  lmqc      = igmp-&gt;querier_robustness_variable;</a>
<a name="ln1366">  lmqi_msec = 100 * pim_ifp-&gt;igmp_specific_query_max_response_time_dsec;</a>
<a name="ln1367">  lmqt_msec = lmqc * lmqi_msec;</a>
<a name="ln1368"> </a>
<a name="ln1369">  /*</a>
<a name="ln1370">    RFC3376: 6.6.3.2. Building and Sending Group and Source Specific Queries</a>
<a name="ln1371"> </a>
<a name="ln1372">    (...) for each of the sources in X of group G, with source timer larger</a>
<a name="ln1373">    than LMQT:</a>
<a name="ln1374">    o Set number of retransmissions for each source to [Last Member</a>
<a name="ln1375">    Query Count].</a>
<a name="ln1376">    o Lower source timer to LMQT.</a>
<a name="ln1377">  */</a>
<a name="ln1378">  for (ALL_LIST_ELEMENTS_RO(group-&gt;group_source_list, src_node, src)) {</a>
<a name="ln1379">    if (IGMP_SOURCE_TEST_SEND(src-&gt;source_flags)) {</a>
<a name="ln1380">      /* source &quot;src&quot; in X of group G */</a>
<a name="ln1381">      if (igmp_source_timer_remain_msec(src) &gt; lmqt_msec) {</a>
<a name="ln1382">	src-&gt;source_query_retransmit_count = lmqc;</a>
<a name="ln1383">	igmp_source_timer_lower_to_lmqt(src);</a>
<a name="ln1384">      }</a>
<a name="ln1385">    }</a>
<a name="ln1386">  }</a>
<a name="ln1387"> </a>
<a name="ln1388">  /* send group-and-source specific queries */</a>
<a name="ln1389">  group_retransmit_sources(group, 1 /* send_with_sflag_set=true */);</a>
<a name="ln1390"> </a>
<a name="ln1391">  /* make sure group retransmit timer is running */</a>
<a name="ln1392">  group_retransmit_timer_on(group);</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">static void block_excl(struct igmp_group *group,</a>
<a name="ln1396">		       int num_sources, struct in_addr *sources)</a>
<a name="ln1397">{</a>
<a name="ln1398">  int num_sources_tosend = 0;</a>
<a name="ln1399">  int i;</a>
<a name="ln1400"> </a>
<a name="ln1401">  /* 1. clear off SEND flag from all known sources (X,Y) */</a>
<a name="ln1402">  source_clear_send_flag(group-&gt;group_source_list);</a>
<a name="ln1403"> </a>
<a name="ln1404">  /* 2. scan received sources (A) */</a>
<a name="ln1405">  for (i = 0; i &lt; num_sources; ++i) {</a>
<a name="ln1406">    struct igmp_source *source;</a>
<a name="ln1407">    struct in_addr     *src_addr;</a>
<a name="ln1408">    </a>
<a name="ln1409">    src_addr = sources + i;</a>
<a name="ln1410">    </a>
<a name="ln1411">    /* lookup reported source (A) in known sources (X,Y) */</a>
<a name="ln1412">    source = igmp_find_source_by_addr(group, *src_addr);</a>
<a name="ln1413">    if (!source) {</a>
<a name="ln1414">      /* 3: if not found, create source with Group Timer: (A-X-Y)=Group Timer */</a>
<a name="ln1415">      long group_timer_msec;</a>
<a name="ln1416">      source = source_new(group, *src_addr);</a>
<a name="ln1417">      if (!source) {</a>
<a name="ln1418">	/* ugh, internal malloc failure, skip source */</a>
<a name="ln1419">	continue;</a>
<a name="ln1420">      }</a>
<a name="ln1421"> </a>
<a name="ln1422">      zassert(!source-&gt;t_source_timer); /* timer == 0 */</a>
<a name="ln1423">      group_timer_msec = igmp_group_timer_remain_msec(group);</a>
<a name="ln1424">      igmp_source_timer_on(group, source, group_timer_msec);</a>
<a name="ln1425">      zassert(source-&gt;t_source_timer); /* (A-X-Y) timer &gt; 0 */</a>
<a name="ln1426">    }</a>
<a name="ln1427"> </a>
<a name="ln1428">    if (source-&gt;t_source_timer) {</a>
<a name="ln1429">      /* 4. if source timer&gt;0 mark SEND flag: Q(G,A-Y) */</a>
<a name="ln1430">      IGMP_SOURCE_DO_SEND(source-&gt;source_flags);</a>
<a name="ln1431">      ++num_sources_tosend;</a>
<a name="ln1432">    }</a>
<a name="ln1433">  }</a>
<a name="ln1434"> </a>
<a name="ln1435">  /* 5. send sources marked with SEND flag: Q(G,A-Y) */</a>
<a name="ln1436">  if (num_sources_tosend &gt; 0) {</a>
<a name="ln1437">    source_query_send_by_flag(group, num_sources_tosend);</a>
<a name="ln1438">  }</a>
<a name="ln1439">}</a>
<a name="ln1440"> </a>
<a name="ln1441">static void block_incl(struct igmp_group *group,</a>
<a name="ln1442">		       int num_sources, struct in_addr *sources)</a>
<a name="ln1443">{</a>
<a name="ln1444">  int num_sources_tosend = 0;</a>
<a name="ln1445">  int i;</a>
<a name="ln1446"> </a>
<a name="ln1447">  /* 1. clear off SEND flag from all known sources (B) */</a>
<a name="ln1448">  source_clear_send_flag(group-&gt;group_source_list);</a>
<a name="ln1449"> </a>
<a name="ln1450">  /* 2. scan received sources (A) */</a>
<a name="ln1451">  for (i = 0; i &lt; num_sources; ++i) {</a>
<a name="ln1452">    struct igmp_source *source;</a>
<a name="ln1453">    struct in_addr     *src_addr;</a>
<a name="ln1454">    </a>
<a name="ln1455">    src_addr = sources + i;</a>
<a name="ln1456">    </a>
<a name="ln1457">    /* lookup reported source (A) in known sources (B) */</a>
<a name="ln1458">    source = igmp_find_source_by_addr(group, *src_addr);</a>
<a name="ln1459">    if (source) {</a>
<a name="ln1460">      /* 3. if found (A*B), mark SEND flag: Q(G,A*B) */</a>
<a name="ln1461">      IGMP_SOURCE_DO_SEND(source-&gt;source_flags);</a>
<a name="ln1462">      ++num_sources_tosend;</a>
<a name="ln1463">    }</a>
<a name="ln1464">  } </a>
<a name="ln1465"> </a>
<a name="ln1466">  /* 4. send sources marked with SEND flag: Q(G,A*B) */</a>
<a name="ln1467">  if (num_sources_tosend &gt; 0) {</a>
<a name="ln1468">    source_query_send_by_flag(group, num_sources_tosend);</a>
<a name="ln1469">  }</a>
<a name="ln1470">}</a>
<a name="ln1471"> </a>
<a name="ln1472">void igmpv3_report_block(struct igmp_sock *igmp, struct in_addr from,</a>
<a name="ln1473">			 struct in_addr group_addr,</a>
<a name="ln1474">			 int num_sources, struct in_addr *sources)</a>
<a name="ln1475">{</a>
<a name="ln1476">  struct interface *ifp = igmp-&gt;interface;</a>
<a name="ln1477">  struct igmp_group *group;</a>
<a name="ln1478"> </a>
<a name="ln1479">  on_trace(__PRETTY_FUNCTION__,</a>
<a name="ln1480">	   ifp, from, group_addr, num_sources, sources);</a>
<a name="ln1481"> </a>
<a name="ln1482">  /* non-existant group is created as INCLUDE {empty} */</a>
<a name="ln1483">  group = igmp_add_group_by_addr(igmp, group_addr);</a>
<a name="ln1484">  if (!group) {</a>
<a name="ln1485">    return;</a>
<a name="ln1486">  }</a>
<a name="ln1487"> </a>
<a name="ln1488">  if (group-&gt;group_filtermode_isexcl) {</a>
<a name="ln1489">    /* EXCLUDE mode */</a>
<a name="ln1490">    block_excl(group, num_sources, sources);</a>
<a name="ln1491">  }</a>
<a name="ln1492">  else {</a>
<a name="ln1493">    /* INCLUDE mode */</a>
<a name="ln1494">    block_incl(group, num_sources, sources);</a>
<a name="ln1495">  }</a>
<a name="ln1496">}</a>
<a name="ln1497"> </a>
<a name="ln1498">void igmp_group_timer_lower_to_lmqt(struct igmp_group *group)</a>
<a name="ln1499">{</a>
<a name="ln1500">  struct igmp_sock     *igmp;</a>
<a name="ln1501">  struct interface     *ifp;</a>
<a name="ln1502">  struct pim_interface *pim_ifp;</a>
<a name="ln1503">  char                 *ifname;</a>
<a name="ln1504">  int   lmqi_dsec; /* Last Member Query Interval */</a>
<a name="ln1505">  int   lmqc;      /* Last Member Query Count */</a>
<a name="ln1506">  int   lmqt_msec; /* Last Member Query Time */</a>
<a name="ln1507"> </a>
<a name="ln1508">  /*</a>
<a name="ln1509">    RFC 3376: 6.2.2. Definition of Group Timers</a>
<a name="ln1510">    </a>
<a name="ln1511">    The group timer is only used when a group is in EXCLUDE mode and</a>
<a name="ln1512">    it represents the time for the *filter-mode* of the group to</a>
<a name="ln1513">    expire and switch to INCLUDE mode.</a>
<a name="ln1514">  */</a>
<a name="ln1515">  if (!group-&gt;group_filtermode_isexcl) {</a>
<a name="ln1516">    return;</a>
<a name="ln1517">  }</a>
<a name="ln1518"> </a>
<a name="ln1519">  igmp    = group-&gt;group_igmp_sock;</a>
<a name="ln1520">  ifp     = igmp-&gt;interface;</a>
<a name="ln1521">  pim_ifp = ifp-&gt;info;</a>
<a name="ln1522">  ifname  = ifp-&gt;name;</a>
<a name="ln1523"> </a>
<a name="ln1524">  lmqi_dsec = pim_ifp-&gt;igmp_specific_query_max_response_time_dsec;</a>
<a name="ln1525">  lmqc      = igmp-&gt;querier_robustness_variable;</a>
<a name="ln1526">  lmqt_msec = PIM_IGMP_LMQT_MSEC(lmqi_dsec, lmqc); /* lmqt_msec = (100 * lmqi_dsec) * lmqc */</a>
<a name="ln1527"> </a>
<a name="ln1528">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln1529">    char group_str[100];</a>
<a name="ln1530">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln1531">    zlog_debug(&quot;%s: group %s on %s: LMQC=%d LMQI=%d dsec LMQT=%d msec&quot;,</a>
<a name="ln1532">	       __PRETTY_FUNCTION__,</a>
<a name="ln1533">	       group_str, ifname,</a>
<a name="ln1534">	       lmqc, lmqi_dsec, lmqt_msec);</a>
<a name="ln1535">  }</a>
<a name="ln1536"> </a>
<a name="ln1537">  zassert(group-&gt;group_filtermode_isexcl);</a>
<a name="ln1538"> </a>
<a name="ln1539">  igmp_group_timer_on(group, lmqt_msec, ifname);</a>
<a name="ln1540">}</a>
<a name="ln1541"> </a>
<a name="ln1542">void igmp_source_timer_lower_to_lmqt(struct igmp_source *source)</a>
<a name="ln1543">{</a>
<a name="ln1544">  struct igmp_group    *group;</a>
<a name="ln1545">  struct igmp_sock     *igmp;</a>
<a name="ln1546">  struct interface     *ifp;</a>
<a name="ln1547">  struct pim_interface *pim_ifp;</a>
<a name="ln1548">  char                 *ifname;</a>
<a name="ln1549">  int   lmqi_dsec; /* Last Member Query Interval */</a>
<a name="ln1550">  int   lmqc;      /* Last Member Query Count */</a>
<a name="ln1551">  int   lmqt_msec; /* Last Member Query Time */</a>
<a name="ln1552"> </a>
<a name="ln1553">  group   = source-&gt;source_group;</a>
<a name="ln1554">  igmp    = group-&gt;group_igmp_sock;</a>
<a name="ln1555">  ifp     = igmp-&gt;interface;</a>
<a name="ln1556">  pim_ifp = ifp-&gt;info;</a>
<a name="ln1557">  ifname  = ifp-&gt;name;</a>
<a name="ln1558"> </a>
<a name="ln1559">  lmqi_dsec = pim_ifp-&gt;igmp_specific_query_max_response_time_dsec;</a>
<a name="ln1560">  lmqc      = igmp-&gt;querier_robustness_variable;</a>
<a name="ln1561">  lmqt_msec = PIM_IGMP_LMQT_MSEC(lmqi_dsec, lmqc); /* lmqt_msec = (100 * lmqi_dsec) * lmqc */</a>
<a name="ln1562"> </a>
<a name="ln1563">  if (PIM_DEBUG_IGMP_TRACE) {</a>
<a name="ln1564">    char group_str[100];</a>
<a name="ln1565">    char source_str[100];</a>
<a name="ln1566">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group-&gt;group_addr, group_str, sizeof(group_str));</a>
<a name="ln1567">    pim_inet4_dump(&quot;&lt;source?&gt;&quot;, source-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln1568">    zlog_debug(&quot;%s: group %s source %s on %s: LMQC=%d LMQI=%d dsec LMQT=%d msec&quot;,</a>
<a name="ln1569">	       __PRETTY_FUNCTION__,</a>
<a name="ln1570">	       group_str, source_str, ifname,</a>
<a name="ln1571">	       lmqc, lmqi_dsec, lmqt_msec);</a>
<a name="ln1572">  }</a>
<a name="ln1573"> </a>
<a name="ln1574">  igmp_source_timer_on(group, source, lmqt_msec);</a>
<a name="ln1575">}</a>
<a name="ln1576"> </a>
<a name="ln1577">/*</a>
<a name="ln1578">  Copy sources to message:</a>
<a name="ln1579">    </a>
<a name="ln1580">  struct in_addr *sources = (struct in_addr *)(query_buf + IGMP_V3_SOURCES_OFFSET);</a>
<a name="ln1581">  if (num_sources &gt; 0) {</a>
<a name="ln1582">  struct listnode    *node;</a>
<a name="ln1583">  struct igmp_source *src;</a>
<a name="ln1584">  int                 i = 0;</a>
<a name="ln1585"> </a>
<a name="ln1586">  for (ALL_LIST_ELEMENTS_RO(source_list, node, src)) {</a>
<a name="ln1587">  sources[i++] = src-&gt;source_addr;</a>
<a name="ln1588">  }</a>
<a name="ln1589">  }</a>
<a name="ln1590">*/</a>
<a name="ln1591">void pim_igmp_send_membership_query(struct igmp_group *group,</a>
<a name="ln1592">				    int fd,</a>
<a name="ln1593">				    const char *ifname,</a>
<a name="ln1594">				    char *query_buf,</a>
<a name="ln1595">				    int query_buf_size,</a>
<a name="ln1596">				    int num_sources,</a>
<a name="ln1597">				    struct in_addr dst_addr,</a>
<a name="ln1598">				    struct in_addr group_addr,</a>
<a name="ln1599">				    int query_max_response_time_dsec,</a>
<a name="ln1600">				    uint8_t s_flag,</a>
<a name="ln1601">				    uint8_t querier_robustness_variable,</a>
<a name="ln1602">				    uint16_t querier_query_interval)</a>
<a name="ln1603">{</a>
<a name="ln1604">  ssize_t             msg_size;</a>
<a name="ln1605">  uint8_t             max_resp_code;</a>
<a name="ln1606">  uint8_t             qqic;</a>
<a name="ln1607">  ssize_t             sent;</a>
<a name="ln1608">  struct sockaddr_in  to;</a>
<a name="ln1609">  socklen_t           tolen;</a>
<a name="ln1610">  uint16_t            checksum;</a>
<a name="ln1611"> </a>
<a name="ln1612">  zassert(num_sources &gt;= 0);</a>
<a name="ln1613"> </a>
<a name="ln1614">  msg_size = IGMP_V3_SOURCES_OFFSET + (num_sources &lt;&lt; 2);</a>
<a name="ln1615">  if (msg_size &gt; query_buf_size) {</a>
<a name="ln1616">    zlog_err(&quot;%s %s: unable to send: msg_size=%zd larger than query_buf_size=%d&quot;,</a>
<a name="ln1617">	     __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln1618">	     msg_size, query_buf_size);</a>
<a name="ln1619">    return;</a>
<a name="ln1620">  }</a>
<a name="ln1621"> </a>
<a name="ln1622">  s_flag = PIM_FORCE_BOOLEAN(s_flag);</a>
<a name="ln1623">  zassert((s_flag == 0) || (s_flag == 1));</a>
<a name="ln1624"> </a>
<a name="ln1625">  max_resp_code = igmp_msg_encode16to8(query_max_response_time_dsec);</a>
<a name="ln1626">  qqic          = igmp_msg_encode16to8(querier_query_interval);</a>
<a name="ln1627"> </a>
<a name="ln1628">  /*</a>
<a name="ln1629">    RFC 3376: 4.1.6. QRV (Querier's Robustness Variable)</a>
<a name="ln1630"> </a>
<a name="ln1631">    If non-zero, the QRV field contains the [Robustness Variable]</a>
<a name="ln1632">    value used by the querier, i.e., the sender of the Query.  If the</a>
<a name="ln1633">    querier's [Robustness Variable] exceeds 7, the maximum value of</a>
<a name="ln1634">    the QRV field, the QRV is set to zero.</a>
<a name="ln1635">  */</a>
<a name="ln1636">  if (querier_robustness_variable &gt; 7) {</a>
<a name="ln1637">    querier_robustness_variable = 0;</a>
<a name="ln1638">  }</a>
<a name="ln1639"> </a>
<a name="ln1640">  query_buf[0]                                         = PIM_IGMP_MEMBERSHIP_QUERY;</a>
<a name="ln1641">  query_buf[1]                                         = max_resp_code;</a>
<a name="ln1642">  *(uint16_t *)(query_buf + IGMP_V3_CHECKSUM_OFFSET)   = 0; /* for computing checksum */</a>
<a name="ln1643">  memcpy(query_buf+4, &amp;group_addr, sizeof(struct in_addr));</a>
<a name="ln1644"> </a>
<a name="ln1645">  query_buf[8]                                         = (s_flag &lt;&lt; 3) | querier_robustness_variable;</a>
<a name="ln1646">  query_buf[9]                                         = qqic;</a>
<a name="ln1647">  *(uint16_t *)(query_buf + IGMP_V3_NUMSOURCES_OFFSET) = htons(num_sources);</a>
<a name="ln1648"> </a>
<a name="ln1649">  checksum = in_cksum(query_buf, msg_size);</a>
<a name="ln1650">  *(uint16_t *)(query_buf + IGMP_V3_CHECKSUM_OFFSET) = checksum;</a>
<a name="ln1651"> </a>
<a name="ln1652">  if (PIM_DEBUG_IGMP_PACKETS) {</a>
<a name="ln1653">    char dst_str[100];</a>
<a name="ln1654">    char group_str[100];</a>
<a name="ln1655">    pim_inet4_dump(&quot;&lt;dst?&gt;&quot;, dst_addr, dst_str, sizeof(dst_str));</a>
<a name="ln1656">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln1657">    zlog_debug(&quot;%s: to %s on %s: group=%s sources=%d msg_size=%zd s_flag=%x QRV=%u QQI=%u QQIC=%02x checksum=%x&quot;,</a>
<a name="ln1658">	       __PRETTY_FUNCTION__,</a>
<a name="ln1659">	       dst_str, ifname, group_str, num_sources,</a>
<a name="ln1660">	       msg_size, s_flag, querier_robustness_variable,</a>
<a name="ln1661">	       querier_query_interval, qqic, checksum);</a>
<a name="ln1662">  }</a>
<a name="ln1663"> </a>
<a name="ln1664">  memset(&amp;to, 0, sizeof(to));</a>
<a name="ln1665">  to.sin_family = AF_INET;</a>
<a name="ln1666">  to.sin_addr = dst_addr;</a>
<a name="ln1667">  tolen = sizeof(to);</a>
<a name="ln1668"> </a>
<a name="ln1669">  sent = sendto(fd, query_buf, msg_size, MSG_DONTWAIT,</a>
<a name="ln1670">                (struct sockaddr *)&amp;to, tolen);</a>
<a name="ln1671">  if (sent != (ssize_t) msg_size) {</a>
<a name="ln1672">    int e = errno;</a>
<a name="ln1673">    char dst_str[100];</a>
<a name="ln1674">    char group_str[100];</a>
<a name="ln1675">    pim_inet4_dump(&quot;&lt;dst?&gt;&quot;, dst_addr, dst_str, sizeof(dst_str));</a>
<a name="ln1676">    pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln1677">    if (sent &lt; 0) {</a>
<a name="ln1678">      zlog_warn(&quot;%s: sendto() failure to %s on %s: group=%s msg_size=%zd: errno=%d: %s&quot;,</a>
<a name="ln1679">		__PRETTY_FUNCTION__,</a>
<a name="ln1680">		dst_str, ifname, group_str, msg_size,</a>
<a name="ln1681">		e, safe_strerror(e));</a>
<a name="ln1682">    }</a>
<a name="ln1683">    else {</a>
<a name="ln1684">      zlog_warn(&quot;%s: sendto() partial to %s on %s: group=%s msg_size=%zd: sent=%zd&quot;,</a>
<a name="ln1685">		__PRETTY_FUNCTION__,</a>
<a name="ln1686">		dst_str, ifname, group_str,</a>
<a name="ln1687">		msg_size, sent);</a>
<a name="ln1688">    }</a>
<a name="ln1689">    return;</a>
<a name="ln1690">  }</a>
<a name="ln1691"> </a>
<a name="ln1692">  /*</a>
<a name="ln1693">    s_flag sanity test: s_flag must be set for general queries</a>
<a name="ln1694"> </a>
<a name="ln1695">    RFC 3376: 6.6.1. Timer Updates</a>
<a name="ln1696"> </a>
<a name="ln1697">    When a router sends or receives a query with a clear Suppress</a>
<a name="ln1698">    Router-Side Processing flag, it must update its timers to reflect</a>
<a name="ln1699">    the correct timeout values for the group or sources being queried.</a>
<a name="ln1700"> </a>
<a name="ln1701">    General queries don't trigger timer update.</a>
<a name="ln1702">  */</a>
<a name="ln1703">  if (!s_flag) {</a>
<a name="ln1704">    /* general query? */</a>
<a name="ln1705">    if (PIM_INADDR_IS_ANY(group_addr)) {</a>
<a name="ln1706">      char dst_str[100];</a>
<a name="ln1707">      char group_str[100];</a>
<a name="ln1708">      pim_inet4_dump(&quot;&lt;dst?&gt;&quot;, dst_addr, dst_str, sizeof(dst_str));</a>
<a name="ln1709">      pim_inet4_dump(&quot;&lt;group?&gt;&quot;, group_addr, group_str, sizeof(group_str));</a>
<a name="ln1710">      zlog_warn(&quot;%s: to %s on %s: group=%s sources=%d: s_flag is clear for general query!&quot;,</a>
<a name="ln1711">		__PRETTY_FUNCTION__,</a>
<a name="ln1712">		dst_str, ifname, group_str, num_sources);</a>
<a name="ln1713">    }</a>
<a name="ln1714">  }</a>
<a name="ln1715"> </a>
<a name="ln1716">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="1090"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'query_buf1' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="1091"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'query_buf2' is cast to a more strictly aligned pointer type.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
