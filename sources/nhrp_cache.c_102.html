
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_cache.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP cache</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;zebra.h&quot;</a>
<a name="ln11">#include &quot;memory.h&quot;</a>
<a name="ln12">#include &quot;thread.h&quot;</a>
<a name="ln13">#include &quot;hash.h&quot;</a>
<a name="ln14">#include &quot;nhrpd.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;netlink.h&quot;</a>
<a name="ln17"> </a>
<a name="ln18">unsigned long nhrp_cache_counts[NHRP_CACHE_NUM_TYPES];</a>
<a name="ln19"> </a>
<a name="ln20">const char * const nhrp_cache_type_str[] = {</a>
<a name="ln21">	[NHRP_CACHE_INVALID]	= &quot;invalid&quot;,</a>
<a name="ln22">	[NHRP_CACHE_INCOMPLETE]	= &quot;incomplete&quot;,</a>
<a name="ln23">	[NHRP_CACHE_NEGATIVE]	= &quot;negative&quot;,</a>
<a name="ln24">	[NHRP_CACHE_CACHED]	= &quot;cached&quot;,</a>
<a name="ln25">	[NHRP_CACHE_DYNAMIC]	= &quot;dynamic&quot;,</a>
<a name="ln26">	[NHRP_CACHE_NHS]	= &quot;nhs&quot;,</a>
<a name="ln27">	[NHRP_CACHE_STATIC]	= &quot;static&quot;,</a>
<a name="ln28">	[NHRP_CACHE_LOCAL]	= &quot;local&quot;,</a>
<a name="ln29">};</a>
<a name="ln30"> </a>
<a name="ln31">static unsigned int nhrp_cache_protocol_key(void *peer_data)</a>
<a name="ln32">{</a>
<a name="ln33">	struct nhrp_cache *p = peer_data;</a>
<a name="ln34">	return sockunion_hash(&amp;p-&gt;remote_addr);</a>
<a name="ln35">}</a>
<a name="ln36"> </a>
<a name="ln37">static int nhrp_cache_protocol_cmp(const void *cache_data, const void *key_data)</a>
<a name="ln38">{</a>
<a name="ln39">	const struct nhrp_cache *a = cache_data;</a>
<a name="ln40">	const struct nhrp_cache *b = key_data;</a>
<a name="ln41">	return sockunion_same(&amp;a-&gt;remote_addr, &amp;b-&gt;remote_addr);</a>
<a name="ln42">}</a>
<a name="ln43"> </a>
<a name="ln44">static void *nhrp_cache_alloc(void *data)</a>
<a name="ln45">{</a>
<a name="ln46">	struct nhrp_cache *p, *key = data;</a>
<a name="ln47"> </a>
<a name="ln48">	p = XMALLOC(MTYPE_NHRP_CACHE, sizeof(struct nhrp_cache));</a>
<a name="ln49">	if (p) {</a>
<a name="ln50">		*p = (struct nhrp_cache) {</a>
<a name="ln51">			.cur.type = NHRP_CACHE_INVALID,</a>
<a name="ln52">			.new.type = NHRP_CACHE_INVALID,</a>
<a name="ln53">			.remote_addr = key-&gt;remote_addr,</a>
<a name="ln54">			.ifp = key-&gt;ifp,</a>
<a name="ln55">			.notifier_list = NOTIFIER_LIST_INITIALIZER(&amp;p-&gt;notifier_list),</a>
<a name="ln56">		};</a>
<a name="ln57">		nhrp_cache_counts[p-&gt;cur.type]++;</a>
<a name="ln58">	}</a>
<a name="ln59"> </a>
<a name="ln60">	return p;</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">static void nhrp_cache_free(struct nhrp_cache *c)</a>
<a name="ln64">{</a>
<a name="ln65">	struct nhrp_interface *nifp = c-&gt;ifp-&gt;info;</a>
<a name="ln66"> </a>
<a name="ln67">	zassert(c-&gt;cur.type == NHRP_CACHE_INVALID &amp;&amp; c-&gt;cur.peer == NULL);</a>
<a name="ln68">	zassert(c-&gt;new.type == NHRP_CACHE_INVALID &amp;&amp; c-&gt;new.peer == NULL);</a>
<a name="ln69">	nhrp_cache_counts[c-&gt;cur.type]--;</a>
<a name="ln70">	notifier_call(&amp;c-&gt;notifier_list, NOTIFY_CACHE_DELETE);</a>
<a name="ln71">	zassert(!notifier_active(&amp;c-&gt;notifier_list));</a>
<a name="ln72">	hash_release(nifp-&gt;cache_hash, c);</a>
<a name="ln73">	XFREE(MTYPE_NHRP_CACHE, c);</a>
<a name="ln74">}</a>
<a name="ln75"> </a>
<a name="ln76">struct nhrp_cache *nhrp_cache_get(struct interface *ifp, union sockunion *remote_addr, int create)</a>
<a name="ln77">{</a>
<a name="ln78">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln79">	struct nhrp_cache key;</a>
<a name="ln80"> </a>
<a name="ln81">	if (!nifp-&gt;cache_hash) {</a>
<a name="ln82">		nifp-&gt;cache_hash = hash_create(nhrp_cache_protocol_key, nhrp_cache_protocol_cmp);</a>
<a name="ln83">		if (!nifp-&gt;cache_hash)</a>
<a name="ln84">			return NULL;</a>
<a name="ln85">	}</a>
<a name="ln86"> </a>
<a name="ln87">	key.remote_addr = *remote_addr;</a>
<a name="ln88">	key.ifp = ifp;</a>
<a name="ln89"> </a>
<a name="ln90">	return hash_get(nifp-&gt;cache_hash, &amp;key, create ? nhrp_cache_alloc : NULL);</a>
<a name="ln91">}</a>
<a name="ln92"> </a>
<a name="ln93">static int nhrp_cache_do_free(struct thread *t)</a>
<a name="ln94">{</a>
<a name="ln95">	struct nhrp_cache *c = THREAD_ARG(t);</a>
<a name="ln96">	c-&gt;t_timeout = NULL;</a>
<a name="ln97">	nhrp_cache_free(c);</a>
<a name="ln98">	return 0;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">static int nhrp_cache_do_timeout(struct thread *t)</a>
<a name="ln102">{</a>
<a name="ln103">	struct nhrp_cache *c = THREAD_ARG(t);</a>
<a name="ln104">	c-&gt;t_timeout = NULL;</a>
<a name="ln105">	if (c-&gt;cur.type != NHRP_CACHE_INVALID)</a>
<a name="ln106">		nhrp_cache_update_binding(c, c-&gt;cur.type, -1, NULL, 0, NULL);</a>
<a name="ln107">	return 0;</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">static void nhrp_cache_update_route(struct nhrp_cache *c)</a>
<a name="ln111">{</a>
<a name="ln112">	struct prefix pfx;</a>
<a name="ln113">	struct nhrp_peer *p = c-&gt;cur.peer;</a>
<a name="ln114"> </a>
<a name="ln115">	sockunion2hostprefix(&amp;c-&gt;remote_addr, &amp;pfx);</a>
<a name="ln116"> </a>
<a name="ln117">	if (p &amp;&amp; nhrp_peer_check(p, 1)) {</a>
<a name="ln118">		netlink_update_binding(p-&gt;ifp, &amp;c-&gt;remote_addr, &amp;p-&gt;vc-&gt;remote.nbma);</a>
<a name="ln119">		nhrp_route_announce(1, c-&gt;cur.type, &amp;pfx, c-&gt;ifp, NULL, c-&gt;cur.mtu);</a>
<a name="ln120">		if (c-&gt;cur.type &gt;= NHRP_CACHE_DYNAMIC) {</a>
<a name="ln121">			nhrp_route_update_nhrp(&amp;pfx, c-&gt;ifp);</a>
<a name="ln122">			c-&gt;nhrp_route_installed = 1;</a>
<a name="ln123">		} else if (c-&gt;nhrp_route_installed) {</a>
<a name="ln124">			nhrp_route_update_nhrp(&amp;pfx, NULL);</a>
<a name="ln125">			c-&gt;nhrp_route_installed = 0;</a>
<a name="ln126">		}</a>
<a name="ln127">		if (!c-&gt;route_installed) {</a>
<a name="ln128">			notifier_call(&amp;c-&gt;notifier_list, NOTIFY_CACHE_UP);</a>
<a name="ln129">			c-&gt;route_installed = 1;</a>
<a name="ln130">		}</a>
<a name="ln131">	} else {</a>
<a name="ln132">		if (c-&gt;nhrp_route_installed) {</a>
<a name="ln133">			nhrp_route_update_nhrp(&amp;pfx, NULL);</a>
<a name="ln134">			c-&gt;nhrp_route_installed = 0;</a>
<a name="ln135">		}</a>
<a name="ln136">		if (c-&gt;route_installed) {</a>
<a name="ln137">			sockunion2hostprefix(&amp;c-&gt;remote_addr, &amp;pfx);</a>
<a name="ln138">			notifier_call(&amp;c-&gt;notifier_list, NOTIFY_CACHE_DOWN);</a>
<a name="ln139">			nhrp_route_announce(0, c-&gt;cur.type, &amp;pfx, NULL, NULL, 0);</a>
<a name="ln140">			c-&gt;route_installed = 0;</a>
<a name="ln141">		}</a>
<a name="ln142">	}</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">static void nhrp_cache_peer_notifier(struct notifier_block *n, unsigned long cmd)</a>
<a name="ln146">{</a>
<a name="ln147">	struct nhrp_cache *c = container_of(n, struct nhrp_cache, peer_notifier);</a>
<a name="ln148"> </a>
<a name="ln149">	switch (cmd) {</a>
<a name="ln150">	case NOTIFY_PEER_UP:</a>
<a name="ln151">		nhrp_cache_update_route(c);</a>
<a name="ln152">		break;</a>
<a name="ln153">	case NOTIFY_PEER_DOWN:</a>
<a name="ln154">	case NOTIFY_PEER_IFCONFIG_CHANGED:</a>
<a name="ln155">		notifier_call(&amp;c-&gt;notifier_list, NOTIFY_CACHE_DOWN);</a>
<a name="ln156">		nhrp_cache_update_binding(c, c-&gt;cur.type, -1, NULL, 0, NULL);</a>
<a name="ln157">		break;</a>
<a name="ln158">	case NOTIFY_PEER_NBMA_CHANGING:</a>
<a name="ln159">		if (c-&gt;cur.type == NHRP_CACHE_DYNAMIC)</a>
<a name="ln160">			c-&gt;cur.peer-&gt;vc-&gt;abort_migration = 1;</a>
<a name="ln161">		break;</a>
<a name="ln162">	}</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">static void nhrp_cache_reset_new(struct nhrp_cache *c)</a>
<a name="ln166">{</a>
<a name="ln167">	THREAD_OFF(c-&gt;t_auth);</a>
<a name="ln168">	if (list_hashed(&amp;c-&gt;newpeer_notifier.notifier_entry))</a>
<a name="ln169">		nhrp_peer_notify_del(c-&gt;new.peer, &amp;c-&gt;newpeer_notifier);</a>
<a name="ln170">	nhrp_peer_unref(c-&gt;new.peer);</a>
<a name="ln171">	memset(&amp;c-&gt;new, 0, sizeof(c-&gt;new));</a>
<a name="ln172">	c-&gt;new.type = NHRP_CACHE_INVALID;</a>
<a name="ln173">}</a>
<a name="ln174"> </a>
<a name="ln175">static void nhrp_cache_update_timers(struct nhrp_cache *c)</a>
<a name="ln176">{</a>
<a name="ln177">	THREAD_OFF(c-&gt;t_timeout);</a>
<a name="ln178"> </a>
<a name="ln179">	switch (c-&gt;cur.type) {</a>
<a name="ln180">	case NHRP_CACHE_INVALID:</a>
<a name="ln181">		if (!c-&gt;t_auth)</a>
<a name="ln182">			THREAD_TIMER_MSEC_ON(master, c-&gt;t_timeout, nhrp_cache_do_free, c, 10);</a>
<a name="ln183">		break;</a>
<a name="ln184">	default:</a>
<a name="ln185">		if (c-&gt;cur.expires)</a>
<a name="ln186">			THREAD_TIMER_ON(master, c-&gt;t_timeout, nhrp_cache_do_timeout, c, c-&gt;cur.expires - recent_relative_time().tv_sec);</a>
<a name="ln187">		break;</a>
<a name="ln188">	}</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">static void nhrp_cache_authorize_binding(struct nhrp_reqid *r, void *arg)</a>
<a name="ln192">{</a>
<a name="ln193">	struct nhrp_cache *c = container_of(r, struct nhrp_cache, eventid);</a>
<a name="ln194">	char buf[SU_ADDRSTRLEN];</a>
<a name="ln195"> </a>
<a name="ln196">	debugf(NHRP_DEBUG_COMMON, &quot;cache: %s %s: %s&quot;,</a>
<a name="ln197">		c-&gt;ifp-&gt;name, sockunion2str(&amp;c-&gt;remote_addr, buf, sizeof buf),</a>
<a name="ln198">		(const char *) arg);</a>
<a name="ln199"> </a>
<a name="ln200">	nhrp_reqid_free(&amp;nhrp_event_reqid, r);</a>
<a name="ln201"> </a>
<a name="ln202">	if (arg &amp;&amp; strcmp(arg, &quot;accept&quot;) == 0) {</a>
<a name="ln203">		if (c-&gt;cur.peer) {</a>
<a name="ln204">			netlink_update_binding(c-&gt;cur.peer-&gt;ifp, &amp;c-&gt;remote_addr, NULL);</a>
<a name="ln205">			nhrp_peer_notify_del(c-&gt;cur.peer, &amp;c-&gt;peer_notifier);</a>
<a name="ln206">			nhrp_peer_unref(c-&gt;cur.peer);</a>
<a name="ln207">		}</a>
<a name="ln208">		nhrp_cache_counts[c-&gt;cur.type]--;</a>
<a name="ln209">		nhrp_cache_counts[c-&gt;new.type]++;</a>
<a name="ln210">		c-&gt;cur = c-&gt;new;</a>
<a name="ln211">		c-&gt;cur.peer = nhrp_peer_ref(c-&gt;cur.peer);</a>
<a name="ln212">		nhrp_cache_reset_new(c);</a>
<a name="ln213">		if (c-&gt;cur.peer)</a>
<a name="ln214">			nhrp_peer_notify_add(c-&gt;cur.peer, &amp;c-&gt;peer_notifier, nhrp_cache_peer_notifier);</a>
<a name="ln215">		nhrp_cache_update_route(c);</a>
<a name="ln216">		notifier_call(&amp;c-&gt;notifier_list, NOTIFY_CACHE_BINDING_CHANGE);</a>
<a name="ln217">	} else {</a>
<a name="ln218">		nhrp_cache_reset_new(c);</a>
<a name="ln219">	}</a>
<a name="ln220"> </a>
<a name="ln221">	nhrp_cache_update_timers(c);</a>
<a name="ln222">}</a>
<a name="ln223"> </a>
<a name="ln224">static int nhrp_cache_do_auth_timeout(struct thread *t)</a>
<a name="ln225">{</a>
<a name="ln226">	struct nhrp_cache *c = THREAD_ARG(t);</a>
<a name="ln227">	c-&gt;t_auth = NULL;</a>
<a name="ln228">	nhrp_cache_authorize_binding(&amp;c-&gt;eventid, (void *) &quot;timeout&quot;);</a>
<a name="ln229">	return 0;</a>
<a name="ln230">}</a>
<a name="ln231"> </a>
<a name="ln232">static void nhrp_cache_newpeer_notifier(struct notifier_block *n, unsigned long cmd)</a>
<a name="ln233">{</a>
<a name="ln234">	struct nhrp_cache *c = container_of(n, struct nhrp_cache, newpeer_notifier);</a>
<a name="ln235"> </a>
<a name="ln236">	switch (cmd) {</a>
<a name="ln237">	case NOTIFY_PEER_UP:</a>
<a name="ln238">		if (nhrp_peer_check(c-&gt;new.peer, 1)) {</a>
<a name="ln239">			evmgr_notify(&quot;authorize-binding&quot;, c, nhrp_cache_authorize_binding);</a>
<a name="ln240">			THREAD_TIMER_ON(master, c-&gt;t_auth, nhrp_cache_do_auth_timeout, c, 10);</a>
<a name="ln241">		}</a>
<a name="ln242">		break;</a>
<a name="ln243">	case NOTIFY_PEER_DOWN:</a>
<a name="ln244">	case NOTIFY_PEER_IFCONFIG_CHANGED:</a>
<a name="ln245">		nhrp_cache_reset_new(c);</a>
<a name="ln246">		break;</a>
<a name="ln247">	}</a>
<a name="ln248">}</a>
<a name="ln249"> </a>
<a name="ln250">int nhrp_cache_update_binding(struct nhrp_cache *c, enum nhrp_cache_type type, int holding_time, struct nhrp_peer *p, uint32_t mtu, union sockunion *nbma_oa)</a>
<a name="ln251">{</a>
<a name="ln252">	if (c-&gt;cur.type &gt; type || c-&gt;new.type &gt; type) {</a>
<a name="ln253">		nhrp_peer_unref(p);</a>
<a name="ln254">		return 0;</a>
<a name="ln255">	}</a>
<a name="ln256"> </a>
<a name="ln257">	/* Sanitize MTU */</a>
<a name="ln258">	switch (sockunion_family(&amp;c-&gt;remote_addr)) {</a>
<a name="ln259">	case AF_INET:</a>
<a name="ln260">		if (mtu &lt; 576 || mtu &gt;= 1500)</a>
<a name="ln261">			mtu = 0;</a>
<a name="ln262">		/* Opennhrp announces nbma mtu, but we use protocol mtu.</a>
<a name="ln263">		 * This heuristic tries to fix up it. */</a>
<a name="ln264">		if (mtu &gt; 1420) mtu = (mtu &amp; -16) - 80;</a>
<a name="ln265">		break;</a>
<a name="ln266">	default:</a>
<a name="ln267">		mtu = 0;</a>
<a name="ln268">		break;</a>
<a name="ln269">	}</a>
<a name="ln270"> </a>
<a name="ln271">	nhrp_cache_reset_new(c);</a>
<a name="ln272">	if (c-&gt;cur.type == type &amp;&amp; c-&gt;cur.peer == p &amp;&amp; c-&gt;cur.mtu == mtu) {</a>
<a name="ln273">		if (holding_time &gt; 0) c-&gt;cur.expires = recent_relative_time().tv_sec + holding_time;</a>
<a name="ln274">		if (nbma_oa) c-&gt;cur.remote_nbma_natoa = *nbma_oa;</a>
<a name="ln275">		else memset(&amp;c-&gt;cur.remote_nbma_natoa, 0, sizeof c-&gt;cur.remote_nbma_natoa);</a>
<a name="ln276">		nhrp_peer_unref(p);</a>
<a name="ln277">	} else {</a>
<a name="ln278">		c-&gt;new.type = type;</a>
<a name="ln279">		c-&gt;new.peer = p;</a>
<a name="ln280">		c-&gt;new.mtu = mtu;</a>
<a name="ln281">		if (nbma_oa) c-&gt;new.remote_nbma_natoa = *nbma_oa;</a>
<a name="ln282"> </a>
<a name="ln283">		if (holding_time &gt; 0)</a>
<a name="ln284">			c-&gt;new.expires = recent_relative_time().tv_sec + holding_time;</a>
<a name="ln285">		else if (holding_time &lt; 0)</a>
<a name="ln286">			c-&gt;new.type = NHRP_CACHE_INVALID;</a>
<a name="ln287"> </a>
<a name="ln288">		if (c-&gt;new.type == NHRP_CACHE_INVALID ||</a>
<a name="ln289">		    c-&gt;new.type &gt;= NHRP_CACHE_STATIC ||</a>
<a name="ln290">		    c-&gt;map) {</a>
<a name="ln291">			nhrp_cache_authorize_binding(&amp;c-&gt;eventid, (void *) &quot;accept&quot;);</a>
<a name="ln292">		} else {</a>
<a name="ln293">			nhrp_peer_notify_add(c-&gt;new.peer, &amp;c-&gt;newpeer_notifier, nhrp_cache_newpeer_notifier);</a>
<a name="ln294">			nhrp_cache_newpeer_notifier(&amp;c-&gt;newpeer_notifier, NOTIFY_PEER_UP);</a>
<a name="ln295">			THREAD_TIMER_ON(master, c-&gt;t_auth, nhrp_cache_do_auth_timeout, c, 60);</a>
<a name="ln296">		}</a>
<a name="ln297">	}</a>
<a name="ln298">	nhrp_cache_update_timers(c);</a>
<a name="ln299"> </a>
<a name="ln300">	return 1;</a>
<a name="ln301">}</a>
<a name="ln302"> </a>
<a name="ln303">void nhrp_cache_set_used(struct nhrp_cache *c, int used)</a>
<a name="ln304">{</a>
<a name="ln305">	c-&gt;used = used;</a>
<a name="ln306">	if (c-&gt;used)</a>
<a name="ln307">		notifier_call(&amp;c-&gt;notifier_list, NOTIFY_CACHE_USED);</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">struct nhrp_cache_iterator_ctx {</a>
<a name="ln311">	void (*cb)(struct nhrp_cache *, void *);</a>
<a name="ln312">	void *ctx;</a>
<a name="ln313">};</a>
<a name="ln314"> </a>
<a name="ln315">static void nhrp_cache_iterator(struct hash_backet *b, void *ctx)</a>
<a name="ln316">{</a>
<a name="ln317">	struct nhrp_cache_iterator_ctx *ic = ctx;</a>
<a name="ln318">	ic-&gt;cb(b-&gt;data, ic-&gt;ctx);</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">void nhrp_cache_foreach(struct interface *ifp, void (*cb)(struct nhrp_cache *, void *), void *ctx)</a>
<a name="ln322">{</a>
<a name="ln323">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln324">	struct nhrp_cache_iterator_ctx ic = {</a>
<a name="ln325">		.cb = cb,</a>
<a name="ln326">		.ctx = ctx,</a>
<a name="ln327">	};</a>
<a name="ln328"> </a>
<a name="ln329">	if (nifp-&gt;cache_hash)</a>
<a name="ln330">		hash_iterate(nifp-&gt;cache_hash, nhrp_cache_iterator, &amp;ic);</a>
<a name="ln331">}</a>
<a name="ln332"> </a>
<a name="ln333">void nhrp_cache_notify_add(struct nhrp_cache *c, struct notifier_block *n, notifier_fn_t fn)</a>
<a name="ln334">{</a>
<a name="ln335">	notifier_add(n, &amp;c-&gt;notifier_list, fn);</a>
<a name="ln336">}</a>
<a name="ln337"> </a>
<a name="ln338">void nhrp_cache_notify_del(struct nhrp_cache *c, struct notifier_block *n)</a>
<a name="ln339">{</a>
<a name="ln340">	notifier_del(n);</a>
<a name="ln341">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
