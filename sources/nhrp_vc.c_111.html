
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_vc.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP virtual connection</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &quot;zebra.h&quot;</a>
<a name="ln11">#include &quot;memory.h&quot;</a>
<a name="ln12">#include &quot;stream.h&quot;</a>
<a name="ln13">#include &quot;hash.h&quot;</a>
<a name="ln14">#include &quot;thread.h&quot;</a>
<a name="ln15">#include &quot;jhash.h&quot;</a>
<a name="ln16"> </a>
<a name="ln17">#include &quot;nhrpd.h&quot;</a>
<a name="ln18">#include &quot;os.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">struct child_sa {</a>
<a name="ln21">	uint32_t id;</a>
<a name="ln22">	struct nhrp_vc *vc;</a>
<a name="ln23">	struct list_head childlist_entry;</a>
<a name="ln24">};</a>
<a name="ln25"> </a>
<a name="ln26">static struct hash *nhrp_vc_hash;</a>
<a name="ln27">static struct list_head childlist_head[512];</a>
<a name="ln28"> </a>
<a name="ln29">static unsigned int nhrp_vc_key(void *peer_data)</a>
<a name="ln30">{</a>
<a name="ln31">	struct nhrp_vc *vc = peer_data;</a>
<a name="ln32">	return jhash_2words(</a>
<a name="ln33">		sockunion_hash(&amp;vc-&gt;local.nbma),</a>
<a name="ln34">		sockunion_hash(&amp;vc-&gt;remote.nbma),</a>
<a name="ln35">		0);</a>
<a name="ln36">}</a>
<a name="ln37"> </a>
<a name="ln38">static int nhrp_vc_cmp(const void *cache_data, const void *key_data)</a>
<a name="ln39">{</a>
<a name="ln40">	const struct nhrp_vc *a = cache_data;</a>
<a name="ln41">	const struct nhrp_vc *b = key_data;</a>
<a name="ln42">	return	sockunion_same(&amp;a-&gt;local.nbma, &amp;b-&gt;local.nbma) &amp;&amp;</a>
<a name="ln43">		sockunion_same(&amp;a-&gt;remote.nbma, &amp;b-&gt;remote.nbma);</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">static void *nhrp_vc_alloc(void *data)</a>
<a name="ln47">{</a>
<a name="ln48">	struct nhrp_vc *vc, *key = data;</a>
<a name="ln49"> </a>
<a name="ln50">	vc = XMALLOC(MTYPE_NHRP_VC, sizeof(struct nhrp_vc));</a>
<a name="ln51">	if (vc) {</a>
<a name="ln52">		*vc = (struct nhrp_vc) {</a>
<a name="ln53">			.local.nbma = key-&gt;local.nbma,</a>
<a name="ln54">			.remote.nbma = key-&gt;remote.nbma,</a>
<a name="ln55">			.notifier_list = NOTIFIER_LIST_INITIALIZER(&amp;vc-&gt;notifier_list),</a>
<a name="ln56">		};</a>
<a name="ln57">	}</a>
<a name="ln58"> </a>
<a name="ln59">	return vc;</a>
<a name="ln60">}</a>
<a name="ln61"> </a>
<a name="ln62">static void nhrp_vc_free(void *data)</a>
<a name="ln63">{</a>
<a name="ln64">	XFREE(MTYPE_NHRP_VC, data);</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">struct nhrp_vc *nhrp_vc_get(const union sockunion *src, const union sockunion *dst, int create)</a>
<a name="ln68">{</a>
<a name="ln69">	struct nhrp_vc key;</a>
<a name="ln70">	key.local.nbma = *src;</a>
<a name="ln71">	key.remote.nbma = *dst;</a>
<a name="ln72">	return hash_get(nhrp_vc_hash, &amp;key, create ? nhrp_vc_alloc : 0);</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">static void nhrp_vc_check_delete(struct nhrp_vc *vc)</a>
<a name="ln76">{</a>
<a name="ln77">	if (vc-&gt;updating || vc-&gt;ipsec || notifier_active(&amp;vc-&gt;notifier_list))</a>
<a name="ln78">		return;</a>
<a name="ln79">	hash_release(nhrp_vc_hash, vc);</a>
<a name="ln80">	nhrp_vc_free(vc);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">static void nhrp_vc_update(struct nhrp_vc *vc, long cmd)</a>
<a name="ln84">{</a>
<a name="ln85">	vc-&gt;updating = 1;</a>
<a name="ln86">	notifier_call(&amp;vc-&gt;notifier_list, cmd);</a>
<a name="ln87">	vc-&gt;updating = 0;</a>
<a name="ln88">	nhrp_vc_check_delete(vc);</a>
<a name="ln89">}</a>
<a name="ln90"> </a>
<a name="ln91">static void nhrp_vc_ipsec_reset(struct nhrp_vc *vc)</a>
<a name="ln92">{</a>
<a name="ln93">	vc-&gt;local.id[0] = 0;</a>
<a name="ln94">	vc-&gt;local.certlen = 0;</a>
<a name="ln95">	vc-&gt;remote.id[0] = 0;</a>
<a name="ln96">	vc-&gt;remote.certlen = 0;</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">int nhrp_vc_ipsec_updown(uint32_t child_id, struct nhrp_vc *vc)</a>
<a name="ln100">{</a>
<a name="ln101">	char buf[2][SU_ADDRSTRLEN];</a>
<a name="ln102">	struct child_sa *sa = NULL, *lsa;</a>
<a name="ln103">	uint32_t child_hash = child_id % ZEBRA_NUM_OF(childlist_head);</a>
<a name="ln104">	int abort_migration = 0;</a>
<a name="ln105"> </a>
<a name="ln106">	list_for_each_entry(lsa, &amp;childlist_head[child_hash], childlist_entry) {</a>
<a name="ln107">		if (lsa-&gt;id == child_id) {</a>
<a name="ln108">			sa = lsa;</a>
<a name="ln109">			break;</a>
<a name="ln110">		}</a>
<a name="ln111">	}</a>
<a name="ln112"> </a>
<a name="ln113">	if (!sa) {</a>
<a name="ln114">		if (!vc) return 0;</a>
<a name="ln115"> </a>
<a name="ln116">		sa = XMALLOC(MTYPE_NHRP_VC, sizeof(struct child_sa));</a>
<a name="ln117">		if (!sa) return 0;</a>
<a name="ln118"> </a>
<a name="ln119">		*sa = (struct child_sa) {</a>
<a name="ln120">			.id = child_id,</a>
<a name="ln121">			.childlist_entry = LIST_INITIALIZER(sa-&gt;childlist_entry),</a>
<a name="ln122">			.vc = NULL,</a>
<a name="ln123">		};</a>
<a name="ln124">		list_add_tail(&amp;sa-&gt;childlist_entry, &amp;childlist_head[child_hash]);</a>
<a name="ln125">	}</a>
<a name="ln126"> </a>
<a name="ln127">	if (sa-&gt;vc == vc)</a>
<a name="ln128">		return 0;</a>
<a name="ln129"> </a>
<a name="ln130">	if (vc) {</a>
<a name="ln131">		/* Attach first to new VC */</a>
<a name="ln132">		vc-&gt;ipsec++;</a>
<a name="ln133">		nhrp_vc_update(vc, NOTIFY_VC_IPSEC_CHANGED);</a>
<a name="ln134">	}</a>
<a name="ln135">	if (sa-&gt;vc &amp;&amp; vc) {</a>
<a name="ln136">		/* Notify old VC of migration */</a>
<a name="ln137">		sa-&gt;vc-&gt;abort_migration = 0;</a>
<a name="ln138">		debugf(NHRP_DEBUG_COMMON, &quot;IPsec NBMA change of %s to %s&quot;,</a>
<a name="ln139">			sockunion2str(&amp;sa-&gt;vc-&gt;remote.nbma, buf[0], sizeof buf[0]),</a>
<a name="ln140">			sockunion2str(&amp;vc-&gt;remote.nbma, buf[1], sizeof buf[1]));</a>
<a name="ln141">		nhrp_vc_update(sa-&gt;vc, NOTIFY_VC_IPSEC_UPDATE_NBMA);</a>
<a name="ln142">		abort_migration = sa-&gt;vc-&gt;abort_migration;</a>
<a name="ln143">	}</a>
<a name="ln144">	if (sa-&gt;vc) {</a>
<a name="ln145">		/* Deattach old VC */</a>
<a name="ln146">		sa-&gt;vc-&gt;ipsec--;</a>
<a name="ln147">		if (!sa-&gt;vc-&gt;ipsec) nhrp_vc_ipsec_reset(sa-&gt;vc);</a>
<a name="ln148">		nhrp_vc_update(sa-&gt;vc, NOTIFY_VC_IPSEC_CHANGED);</a>
<a name="ln149">	}</a>
<a name="ln150"> </a>
<a name="ln151">	/* Update */</a>
<a name="ln152">	sa-&gt;vc = vc;</a>
<a name="ln153">	if (!vc) {</a>
<a name="ln154">		list_del(&amp;sa-&gt;childlist_entry);</a>
<a name="ln155">		XFREE(MTYPE_NHRP_VC, sa);</a>
<a name="ln156">	}</a>
<a name="ln157"> </a>
<a name="ln158">	return abort_migration;</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">void nhrp_vc_notify_add(struct nhrp_vc *vc, struct notifier_block *n, notifier_fn_t action)</a>
<a name="ln162">{</a>
<a name="ln163">	notifier_add(n, &amp;vc-&gt;notifier_list, action);</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">void nhrp_vc_notify_del(struct nhrp_vc *vc, struct notifier_block *n)</a>
<a name="ln167">{</a>
<a name="ln168">	notifier_del(n);</a>
<a name="ln169">	nhrp_vc_check_delete(vc);</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173">struct nhrp_vc_iterator_ctx {</a>
<a name="ln174">	void (*cb)(struct nhrp_vc *, void *);</a>
<a name="ln175">	void *ctx;</a>
<a name="ln176">};</a>
<a name="ln177"> </a>
<a name="ln178">static void nhrp_vc_iterator(struct hash_backet *b, void *ctx)</a>
<a name="ln179">{</a>
<a name="ln180">	struct nhrp_vc_iterator_ctx *ic = ctx;</a>
<a name="ln181">	ic-&gt;cb(b-&gt;data, ic-&gt;ctx);</a>
<a name="ln182">}</a>
<a name="ln183"> </a>
<a name="ln184">void nhrp_vc_foreach(void (*cb)(struct nhrp_vc *, void *), void *ctx)</a>
<a name="ln185">{</a>
<a name="ln186">	struct nhrp_vc_iterator_ctx ic = {</a>
<a name="ln187">		.cb = cb,</a>
<a name="ln188">		.ctx = ctx,</a>
<a name="ln189">	};</a>
<a name="ln190">	hash_iterate(nhrp_vc_hash, nhrp_vc_iterator, &amp;ic);</a>
<a name="ln191">}</a>
<a name="ln192"> </a>
<a name="ln193">void nhrp_vc_init(void)</a>
<a name="ln194">{</a>
<a name="ln195">	size_t i;</a>
<a name="ln196"> </a>
<a name="ln197">	nhrp_vc_hash = hash_create(nhrp_vc_key, nhrp_vc_cmp);</a>
<a name="ln198">	for (i = 0; i &lt; ZEBRA_NUM_OF(childlist_head); i++)</a>
<a name="ln199">		list_init(&amp;childlist_head[i]);</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">void nhrp_vc_reset(void)</a>
<a name="ln203">{</a>
<a name="ln204">	struct child_sa *sa, *n;</a>
<a name="ln205">	size_t i;</a>
<a name="ln206"> </a>
<a name="ln207">	for (i = 0; i &lt; ZEBRA_NUM_OF(childlist_head); i++) {</a>
<a name="ln208">		list_for_each_entry_safe(sa, n, &amp;childlist_head[i], childlist_entry)</a>
<a name="ln209">			nhrp_vc_ipsec_updown(sa-&gt;id, 0);</a>
<a name="ln210">	}</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">void nhrp_vc_terminate(void)</a>
<a name="ln214">{</a>
<a name="ln215">	nhrp_vc_reset();</a>
<a name="ln216">	hash_clean(nhrp_vc_hash, nhrp_vc_free);</a>
<a name="ln217">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
