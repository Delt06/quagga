
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_pim.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;log.h&quot;</a>
<a name="ln26">#include &quot;thread.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;pimd.h&quot;</a>
<a name="ln30">#include &quot;pim_pim.h&quot;</a>
<a name="ln31">#include &quot;pim_time.h&quot;</a>
<a name="ln32">#include &quot;pim_iface.h&quot;</a>
<a name="ln33">#include &quot;pim_sock.h&quot;</a>
<a name="ln34">#include &quot;pim_str.h&quot;</a>
<a name="ln35">#include &quot;pim_util.h&quot;</a>
<a name="ln36">#include &quot;pim_tlv.h&quot;</a>
<a name="ln37">#include &quot;pim_neighbor.h&quot;</a>
<a name="ln38">#include &quot;pim_hello.h&quot;</a>
<a name="ln39">#include &quot;pim_join.h&quot;</a>
<a name="ln40">#include &quot;pim_assert.h&quot;</a>
<a name="ln41">#include &quot;pim_msg.h&quot;</a>
<a name="ln42"> </a>
<a name="ln43">static int on_pim_hello_send(struct thread *t);</a>
<a name="ln44">static int pim_hello_send(struct interface *ifp,</a>
<a name="ln45">			  uint16_t holdtime);</a>
<a name="ln46"> </a>
<a name="ln47">static void sock_close(struct interface *ifp)</a>
<a name="ln48">{</a>
<a name="ln49">  struct pim_interface *pim_ifp = ifp-&gt;info;</a>
<a name="ln50"> </a>
<a name="ln51">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln52">    if (pim_ifp-&gt;t_pim_sock_read) {</a>
<a name="ln53">      zlog_debug(&quot;Cancelling READ event for PIM socket fd=%d on interface %s&quot;,</a>
<a name="ln54">		 pim_ifp-&gt;pim_sock_fd,</a>
<a name="ln55">		 ifp-&gt;name);</a>
<a name="ln56">    }</a>
<a name="ln57">  }</a>
<a name="ln58">  THREAD_OFF(pim_ifp-&gt;t_pim_sock_read);</a>
<a name="ln59"> </a>
<a name="ln60">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln61">    if (pim_ifp-&gt;t_pim_hello_timer) {</a>
<a name="ln62">      zlog_debug(&quot;Cancelling PIM hello timer for interface %s&quot;,</a>
<a name="ln63">		 ifp-&gt;name);</a>
<a name="ln64">    }</a>
<a name="ln65">  }</a>
<a name="ln66">  THREAD_OFF(pim_ifp-&gt;t_pim_hello_timer);</a>
<a name="ln67"> </a>
<a name="ln68">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln69">    zlog_debug(&quot;Deleting PIM socket fd=%d on interface %s&quot;,</a>
<a name="ln70">	       pim_ifp-&gt;pim_sock_fd, ifp-&gt;name);</a>
<a name="ln71">  }</a>
<a name="ln72"> </a>
<a name="ln73">  if (close(pim_ifp-&gt;pim_sock_fd)) {</a>
<a name="ln74">    zlog_warn(&quot;Failure closing PIM socket fd=%d on interface %s: errno=%d: %s&quot;,</a>
<a name="ln75">	      pim_ifp-&gt;pim_sock_fd, ifp-&gt;name,</a>
<a name="ln76">	      errno, safe_strerror(errno));</a>
<a name="ln77">  }</a>
<a name="ln78">  </a>
<a name="ln79">  pim_ifp-&gt;pim_sock_fd = -1;</a>
<a name="ln80">  pim_ifp-&gt;pim_sock_creation = 0;</a>
<a name="ln81"> </a>
<a name="ln82">  zassert(pim_ifp-&gt;pim_sock_fd &lt; 0);</a>
<a name="ln83">  zassert(!pim_ifp-&gt;t_pim_sock_read);</a>
<a name="ln84">  zassert(!pim_ifp-&gt;t_pim_hello_timer);</a>
<a name="ln85">  zassert(!pim_ifp-&gt;pim_sock_creation);</a>
<a name="ln86">}</a>
<a name="ln87"> </a>
<a name="ln88">void pim_sock_delete(struct interface *ifp, const char *delete_message)</a>
<a name="ln89">{</a>
<a name="ln90">  zlog_info(&quot;PIM INTERFACE DOWN: on interface %s: %s&quot;,</a>
<a name="ln91">	    ifp-&gt;name, delete_message);</a>
<a name="ln92"> </a>
<a name="ln93">  if (!ifp-&gt;info) {</a>
<a name="ln94">    zlog_err(&quot;%s: %s: but PIM not enabled on interface %s (!)&quot;,</a>
<a name="ln95">	     __PRETTY_FUNCTION__, delete_message, ifp-&gt;name);</a>
<a name="ln96">    return;</a>
<a name="ln97">  }</a>
<a name="ln98"> </a>
<a name="ln99">  /*</a>
<a name="ln100">    RFC 4601: 4.3.1.  Sending Hello Messages</a>
<a name="ln101">    </a>
<a name="ln102">    Before an interface goes down or changes primary IP address, a Hello</a>
<a name="ln103">    message with a zero HoldTime should be sent immediately (with the</a>
<a name="ln104">    old IP address if the IP address changed).</a>
<a name="ln105">  */</a>
<a name="ln106">  pim_hello_send(ifp, 0 /* zero-sec holdtime */);</a>
<a name="ln107"> </a>
<a name="ln108">  pim_neighbor_delete_all(ifp, delete_message);</a>
<a name="ln109"> </a>
<a name="ln110">  sock_close(ifp);</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">int pim_pim_packet(struct interface *ifp, uint8_t *buf, size_t len)</a>
<a name="ln114">{</a>
<a name="ln115">  struct ip *ip_hdr;</a>
<a name="ln116">  size_t ip_hlen; /* ip header length in bytes */</a>
<a name="ln117">  char src_str[100];</a>
<a name="ln118">  char dst_str[100];</a>
<a name="ln119">  uint8_t *pim_msg;</a>
<a name="ln120">  int pim_msg_len;</a>
<a name="ln121">  uint8_t pim_version;</a>
<a name="ln122">  uint8_t pim_type;</a>
<a name="ln123">  uint16_t pim_checksum; /* received checksum */</a>
<a name="ln124">  uint16_t checksum;     /* computed checksum */</a>
<a name="ln125">  struct pim_neighbor *neigh;</a>
<a name="ln126"> </a>
<a name="ln127">  if (!ifp-&gt;info) {</a>
<a name="ln128">    zlog_warn(&quot;%s: PIM not enabled on interface %s&quot;,</a>
<a name="ln129">	      __PRETTY_FUNCTION__, ifp-&gt;name);</a>
<a name="ln130">    return -1;</a>
<a name="ln131">  }</a>
<a name="ln132">    </a>
<a name="ln133">  if (len &lt; sizeof(*ip_hdr)) {</a>
<a name="ln134">    zlog_warn(&quot;PIM packet size=%zu shorter than minimum=%zu&quot;,</a>
<a name="ln135">	      len, sizeof(*ip_hdr));</a>
<a name="ln136">    return -1;</a>
<a name="ln137">  }</a>
<a name="ln138"> </a>
<a name="ln139">  ip_hdr = (struct ip *) buf;</a>
<a name="ln140"> </a>
<a name="ln141">  pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ip_hdr-&gt;ip_src, src_str, sizeof(src_str));</a>
<a name="ln142">  pim_inet4_dump(&quot;&lt;dst?&gt;&quot;, ip_hdr-&gt;ip_dst, dst_str, sizeof(dst_str));</a>
<a name="ln143"> </a>
<a name="ln144">  ip_hlen = ip_hdr-&gt;ip_hl &lt;&lt; 2; /* ip_hl gives length in 4-byte words */</a>
<a name="ln145"> </a>
<a name="ln146">  if (PIM_DEBUG_PIM_PACKETS) {</a>
<a name="ln147">    zlog_debug(&quot;Recv IP packet from %s to %s on %s: size=%zu ip_header_size=%zu ip_proto=%d&quot;,</a>
<a name="ln148">	       src_str, dst_str, ifp-&gt;name, len, ip_hlen, ip_hdr-&gt;ip_p);</a>
<a name="ln149">  }</a>
<a name="ln150"> </a>
<a name="ln151">  if (ip_hdr-&gt;ip_p != PIM_IP_PROTO_PIM) {</a>
<a name="ln152">    zlog_warn(&quot;IP packet protocol=%d is not PIM=%d&quot;,</a>
<a name="ln153">	      ip_hdr-&gt;ip_p, PIM_IP_PROTO_PIM);</a>
<a name="ln154">    return -1;</a>
<a name="ln155">  }</a>
<a name="ln156"> </a>
<a name="ln157">  if (ip_hlen &lt; PIM_IP_HEADER_MIN_LEN) {</a>
<a name="ln158">    zlog_warn(&quot;IP packet header size=%zu shorter than minimum=%d&quot;,</a>
<a name="ln159">	      ip_hlen, PIM_IP_HEADER_MIN_LEN);</a>
<a name="ln160">    return -1;</a>
<a name="ln161">  }</a>
<a name="ln162">  if (ip_hlen &gt; PIM_IP_HEADER_MAX_LEN) {</a>
<a name="ln163">    zlog_warn(&quot;IP packet header size=%zu greater than maximum=%d&quot;,</a>
<a name="ln164">	      ip_hlen, PIM_IP_HEADER_MAX_LEN);</a>
<a name="ln165">    return -1;</a>
<a name="ln166">  }</a>
<a name="ln167"> </a>
<a name="ln168">  pim_msg = buf + ip_hlen;</a>
<a name="ln169">  pim_msg_len = len - ip_hlen;</a>
<a name="ln170"> </a>
<a name="ln171">  if (PIM_DEBUG_PIM_PACKETDUMP_RECV) {</a>
<a name="ln172">    pim_pkt_dump(__PRETTY_FUNCTION__, pim_msg, pim_msg_len);</a>
<a name="ln173">  }</a>
<a name="ln174"> </a>
<a name="ln175">  if (pim_msg_len &lt; PIM_PIM_MIN_LEN) {</a>
<a name="ln176">    zlog_warn(&quot;PIM message size=%d shorter than minimum=%d&quot;,</a>
<a name="ln177">	      pim_msg_len, PIM_PIM_MIN_LEN);</a>
<a name="ln178">    return -1;</a>
<a name="ln179">  }</a>
<a name="ln180"> </a>
<a name="ln181">  pim_version = PIM_MSG_HDR_GET_VERSION(pim_msg);</a>
<a name="ln182">  pim_type    = PIM_MSG_HDR_GET_TYPE(pim_msg);</a>
<a name="ln183"> </a>
<a name="ln184">  if (pim_version != PIM_PROTO_VERSION) {</a>
<a name="ln185">    zlog_warn(&quot;Ignoring PIM pkt from %s with unsupported version: %d&quot;,</a>
<a name="ln186">	      ifp-&gt;name, pim_version);</a>
<a name="ln187">    return -1;</a>
<a name="ln188">  }</a>
<a name="ln189"> </a>
<a name="ln190">  /* save received checksum */</a>
<a name="ln191">  pim_checksum = PIM_MSG_HDR_GET_CHECKSUM(pim_msg);</a>
<a name="ln192"> </a>
<a name="ln193">  /* for computing checksum */</a>
<a name="ln194">  *(uint16_t *) PIM_MSG_HDR_OFFSET_CHECKSUM(pim_msg) = 0;</a>
<a name="ln195"> </a>
<a name="ln196">  checksum = in_cksum(pim_msg, pim_msg_len);</a>
<a name="ln197">  if (checksum != pim_checksum) {</a>
<a name="ln198">    zlog_warn(&quot;Ignoring PIM pkt from %s with invalid checksum: received=%x calculated=%x&quot;,</a>
<a name="ln199">	      ifp-&gt;name, pim_checksum, checksum);</a>
<a name="ln200">    return -1;</a>
<a name="ln201">  }</a>
<a name="ln202"> </a>
<a name="ln203">  if (PIM_DEBUG_PIM_PACKETS) {</a>
<a name="ln204">    zlog_debug(&quot;Recv PIM packet from %s to %s on %s: ttl=%d pim_version=%d pim_type=%d pim_msg_size=%d checksum=%x&quot;,</a>
<a name="ln205">	       src_str, dst_str, ifp-&gt;name, ip_hdr-&gt;ip_ttl,</a>
<a name="ln206">	       pim_version, pim_type, pim_msg_len, checksum);</a>
<a name="ln207">  }</a>
<a name="ln208"> </a>
<a name="ln209">  if (pim_type == PIM_MSG_TYPE_REGISTER  ||</a>
<a name="ln210">      pim_type == PIM_MSG_TYPE_REG_STOP  ||</a>
<a name="ln211">      pim_type == PIM_MSG_TYPE_BOOTSTRAP ||</a>
<a name="ln212">      pim_type == PIM_MSG_TYPE_GRAFT     ||</a>
<a name="ln213">      pim_type == PIM_MSG_TYPE_GRAFT_ACK ||</a>
<a name="ln214">      pim_type == PIM_MSG_TYPE_CANDIDATE)</a>
<a name="ln215">    {</a>
<a name="ln216">      if (PIM_DEBUG_PIM_PACKETS) {</a>
<a name="ln217">	zlog_debug(&quot;Recv PIM packet type %d which is not currently understood&quot;,</a>
<a name="ln218">		   pim_type);</a>
<a name="ln219">      }</a>
<a name="ln220">      return -1;</a>
<a name="ln221">    }</a>
<a name="ln222"> </a>
<a name="ln223">  if (pim_type == PIM_MSG_TYPE_HELLO) {</a>
<a name="ln224">    int result = pim_hello_recv(ifp,</a>
<a name="ln225">                 ip_hdr-&gt;ip_src,</a>
<a name="ln226">                 pim_msg + PIM_MSG_HEADER_LEN,</a>
<a name="ln227">                 pim_msg_len - PIM_MSG_HEADER_LEN);</a>
<a name="ln228">    return result;</a>
<a name="ln229">  }</a>
<a name="ln230"> </a>
<a name="ln231">  neigh = pim_neighbor_find(ifp, ip_hdr-&gt;ip_src);</a>
<a name="ln232">  if (!neigh) {</a>
<a name="ln233">    zlog_warn(&quot;%s %s: non-hello PIM message type=%d from non-neighbor %s on %s&quot;,</a>
<a name="ln234">	      __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln235">	      pim_type, src_str, ifp-&gt;name);</a>
<a name="ln236">    return -1;</a>
<a name="ln237">  }</a>
<a name="ln238"> </a>
<a name="ln239">  switch (pim_type) {</a>
<a name="ln240">  case PIM_MSG_TYPE_JOIN_PRUNE:</a>
<a name="ln241">    return pim_joinprune_recv(ifp, neigh,</a>
<a name="ln242">			      ip_hdr-&gt;ip_src,</a>
<a name="ln243">			      pim_msg + PIM_MSG_HEADER_LEN,</a>
<a name="ln244">			      pim_msg_len - PIM_MSG_HEADER_LEN);</a>
<a name="ln245">  case PIM_MSG_TYPE_ASSERT:</a>
<a name="ln246">    return pim_assert_recv(ifp, neigh,</a>
<a name="ln247">			   ip_hdr-&gt;ip_src,</a>
<a name="ln248">			   pim_msg + PIM_MSG_HEADER_LEN,</a>
<a name="ln249">			   pim_msg_len - PIM_MSG_HEADER_LEN);</a>
<a name="ln250">  default:</a>
<a name="ln251">    zlog_warn(&quot;%s %s: unsupported PIM message type=%d from %s on %s&quot;,</a>
<a name="ln252">	      __FILE__, __PRETTY_FUNCTION__,</a>
<a name="ln253">	      pim_type, src_str, ifp-&gt;name);</a>
<a name="ln254">  }</a>
<a name="ln255"> </a>
<a name="ln256">  return -1;</a>
<a name="ln257">}</a>
<a name="ln258"> </a>
<a name="ln259">static void pim_sock_read_on(struct interface *ifp);</a>
<a name="ln260"> </a>
<a name="ln261">static int pim_sock_read(struct thread *t)</a>
<a name="ln262">{</a>
<a name="ln263">  struct interface *ifp;</a>
<a name="ln264">  struct pim_interface *pim_ifp;</a>
<a name="ln265">  int fd;</a>
<a name="ln266">  struct sockaddr_in from;</a>
<a name="ln267">  struct sockaddr_in to;</a>
<a name="ln268">  socklen_t fromlen = sizeof(from);</a>
<a name="ln269">  socklen_t tolen = sizeof(to);</a>
<a name="ln270">  uint8_t buf[PIM_PIM_BUFSIZE_READ];</a>
<a name="ln271">  int len;</a>
<a name="ln272">  ifindex_t ifindex = -1;</a>
<a name="ln273">  int result = -1; /* defaults to bad */</a>
<a name="ln274"> </a>
<a name="ln275">  zassert(t);</a>
<a name="ln276"> </a>
<a name="ln277">  ifp = THREAD_ARG(t);</a>
<a name="ln278">  zassert(ifp);</a>
<a name="ln279"> </a>
<a name="ln280">  fd = THREAD_FD(t);</a>
<a name="ln281"> </a>
<a name="ln282">  pim_ifp = ifp-&gt;info;</a>
<a name="ln283">  zassert(pim_ifp);</a>
<a name="ln284"> </a>
<a name="ln285">  zassert(fd == pim_ifp-&gt;pim_sock_fd);</a>
<a name="ln286"> </a>
<a name="ln287">  len = pim_socket_recvfromto(fd, buf, sizeof(buf),</a>
<a name="ln288">			      &amp;from, &amp;fromlen,</a>
<a name="ln289">			      &amp;to, &amp;tolen,</a>
<a name="ln290">			      &amp;ifindex);</a>
<a name="ln291">  if (len &lt; 0) {</a>
<a name="ln292">    zlog_warn(&quot;Failure receiving IP PIM packet on fd=%d: errno=%d: %s&quot;,</a>
<a name="ln293">	      fd, errno, safe_strerror(errno));</a>
<a name="ln294">    goto done;</a>
<a name="ln295">  }</a>
<a name="ln296"> </a>
<a name="ln297">  if (PIM_DEBUG_PIM_PACKETS) {</a>
<a name="ln298">    char from_str[100];</a>
<a name="ln299">    char to_str[100];</a>
<a name="ln300">    </a>
<a name="ln301">    if (!inet_ntop(AF_INET, &amp;from.sin_addr, from_str, sizeof(from_str)))</a>
<a name="ln302">      sprintf(from_str, &quot;&lt;from?&gt;&quot;);</a>
<a name="ln303">    if (!inet_ntop(AF_INET, &amp;to.sin_addr, to_str, sizeof(to_str)))</a>
<a name="ln304">      sprintf(to_str, &quot;&lt;to?&gt;&quot;);</a>
<a name="ln305">    </a>
<a name="ln306">    zlog_debug(&quot;Recv IP PIM pkt size=%d from %s to %s on fd=%d on ifindex=%d (sock_ifindex=%d)&quot;,</a>
<a name="ln307">	       len, from_str, to_str, fd, ifindex, ifp-&gt;ifindex);</a>
<a name="ln308">  }</a>
<a name="ln309"> </a>
<a name="ln310">  if (PIM_DEBUG_PIM_PACKETDUMP_RECV) {</a>
<a name="ln311">    pim_pkt_dump(__PRETTY_FUNCTION__, buf, len);</a>
<a name="ln312">  }</a>
<a name="ln313"> </a>
<a name="ln314">#ifdef PIM_CHECK_RECV_IFINDEX_SANITY</a>
<a name="ln315">  /* ifindex sanity check */</a>
<a name="ln316">  if (ifindex != (int) ifp-&gt;ifindex) {</a>
<a name="ln317">    char from_str[100];</a>
<a name="ln318">    char to_str[100];</a>
<a name="ln319">    struct interface *recv_ifp;</a>
<a name="ln320"> </a>
<a name="ln321">    if (!inet_ntop(AF_INET, &amp;from.sin_addr, from_str , sizeof(from_str)))</a>
<a name="ln322">      sprintf(from_str, &quot;&lt;from?&gt;&quot;);</a>
<a name="ln323">    if (!inet_ntop(AF_INET, &amp;to.sin_addr, to_str , sizeof(to_str)))</a>
<a name="ln324">      sprintf(to_str, &quot;&lt;to?&gt;&quot;);</a>
<a name="ln325"> </a>
<a name="ln326">    recv_ifp = if_lookup_by_index(ifindex);</a>
<a name="ln327">    if (recv_ifp) {</a>
<a name="ln328">      zassert(ifindex == (int) recv_ifp-&gt;ifindex);</a>
<a name="ln329">    }</a>
<a name="ln330"> </a>
<a name="ln331">#ifdef PIM_REPORT_RECV_IFINDEX_MISMATCH</a>
<a name="ln332">    zlog_warn(&quot;Interface mismatch: recv PIM pkt from %s to %s on fd=%d: recv_ifindex=%d (%s) sock_ifindex=%d (%s)&quot;,</a>
<a name="ln333">	      from_str, to_str, fd,</a>
<a name="ln334">	      ifindex, recv_ifp ? recv_ifp-&gt;name : &quot;&lt;if-notfound&gt;&quot;,</a>
<a name="ln335">	      ifp-&gt;ifindex, ifp-&gt;name);</a>
<a name="ln336">#endif</a>
<a name="ln337">    goto done;</a>
<a name="ln338">  }</a>
<a name="ln339">#endif</a>
<a name="ln340"> </a>
<a name="ln341">  int fail = pim_pim_packet(ifp, buf, len);</a>
<a name="ln342">  if (fail) {</a>
<a name="ln343">    zlog_warn(&quot;%s: pim_pim_packet() return=%d&quot;,</a>
<a name="ln344">              __PRETTY_FUNCTION__, fail);</a>
<a name="ln345">    goto done;</a>
<a name="ln346">  }</a>
<a name="ln347"> </a>
<a name="ln348">  result = 0; /* good */</a>
<a name="ln349"> </a>
<a name="ln350"> done:</a>
<a name="ln351">  pim_sock_read_on(ifp);</a>
<a name="ln352"> </a>
<a name="ln353">  if (result) {</a>
<a name="ln354">    ++pim_ifp-&gt;pim_ifstat_hello_recvfail;</a>
<a name="ln355">  }</a>
<a name="ln356"> </a>
<a name="ln357">  return result;</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">static void pim_sock_read_on(struct interface *ifp)</a>
<a name="ln361">{</a>
<a name="ln362">  struct pim_interface *pim_ifp;</a>
<a name="ln363"> </a>
<a name="ln364">  zassert(ifp);</a>
<a name="ln365">  zassert(ifp-&gt;info);</a>
<a name="ln366"> </a>
<a name="ln367">  pim_ifp = ifp-&gt;info;</a>
<a name="ln368"> </a>
<a name="ln369">  if (PIM_DEBUG_PIM_TRACE) {</a>
<a name="ln370">    zlog_debug(&quot;Scheduling READ event on PIM socket fd=%d&quot;,</a>
<a name="ln371">	       pim_ifp-&gt;pim_sock_fd);</a>
<a name="ln372">  }</a>
<a name="ln373">  pim_ifp-&gt;t_pim_sock_read = 0;</a>
<a name="ln374">  zassert(!pim_ifp-&gt;t_pim_sock_read);</a>
<a name="ln375">  THREAD_READ_ON(master, pim_ifp-&gt;t_pim_sock_read, pim_sock_read, ifp,</a>
<a name="ln376">		 pim_ifp-&gt;pim_sock_fd);</a>
<a name="ln377">}</a>
<a name="ln378"> </a>
<a name="ln379">static int pim_sock_open(struct in_addr ifaddr, ifindex_t ifindex)</a>
<a name="ln380">{</a>
<a name="ln381">  int fd;</a>
<a name="ln382"> </a>
<a name="ln383">  fd = pim_socket_mcast(IPPROTO_PIM, ifaddr, 0 /* loop=false */);</a>
<a name="ln384">  if (fd &lt; 0)</a>
<a name="ln385">    return -1;</a>
<a name="ln386"> </a>
<a name="ln387">  if (pim_socket_join(fd, qpim_all_pim_routers_addr, ifaddr, ifindex)) {</a>
<a name="ln388">    close(fd);</a>
<a name="ln389">    return -2;</a>
<a name="ln390">  }</a>
<a name="ln391"> </a>
<a name="ln392">  return fd;</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">void pim_ifstat_reset(struct interface *ifp)</a>
<a name="ln396">{</a>
<a name="ln397">  struct pim_interface *pim_ifp;</a>
<a name="ln398"> </a>
<a name="ln399">  zassert(ifp);</a>
<a name="ln400"> </a>
<a name="ln401">  pim_ifp = ifp-&gt;info;</a>
<a name="ln402">  if (!pim_ifp) {</a>
<a name="ln403">    return;</a>
<a name="ln404">  }</a>
<a name="ln405"> </a>
<a name="ln406">  pim_ifp-&gt;pim_ifstat_start          = pim_time_monotonic_sec();</a>
<a name="ln407">  pim_ifp-&gt;pim_ifstat_hello_sent     = 0;</a>
<a name="ln408">  pim_ifp-&gt;pim_ifstat_hello_sendfail = 0;</a>
<a name="ln409">  pim_ifp-&gt;pim_ifstat_hello_recv     = 0;</a>
<a name="ln410">  pim_ifp-&gt;pim_ifstat_hello_recvfail = 0;</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">void pim_sock_reset(struct interface *ifp)</a>
<a name="ln414">{</a>
<a name="ln415">  struct pim_interface *pim_ifp;</a>
<a name="ln416"> </a>
<a name="ln417">  zassert(ifp);</a>
<a name="ln418">  zassert(ifp-&gt;info);</a>
<a name="ln419"> </a>
<a name="ln420">  pim_ifp = ifp-&gt;info;</a>
<a name="ln421"> </a>
<a name="ln422">  pim_ifp-&gt;primary_address = pim_find_primary_addr(ifp);</a>
<a name="ln423"> </a>
<a name="ln424">  pim_ifp-&gt;pim_sock_fd       = -1;</a>
<a name="ln425">  pim_ifp-&gt;pim_sock_creation = 0;</a>
<a name="ln426">  pim_ifp-&gt;t_pim_sock_read   = 0;</a>
<a name="ln427"> </a>
<a name="ln428">  pim_ifp-&gt;t_pim_hello_timer          = 0;</a>
<a name="ln429">  pim_ifp-&gt;pim_hello_period           = PIM_DEFAULT_HELLO_PERIOD;</a>
<a name="ln430">  pim_ifp-&gt;pim_default_holdtime       = -1; /* unset: means 3.5 * pim_hello_period */</a>
<a name="ln431">  pim_ifp-&gt;pim_triggered_hello_delay  = PIM_DEFAULT_TRIGGERED_HELLO_DELAY;</a>
<a name="ln432">  pim_ifp-&gt;pim_dr_priority            = PIM_DEFAULT_DR_PRIORITY;</a>
<a name="ln433">  pim_ifp-&gt;pim_propagation_delay_msec = PIM_DEFAULT_PROPAGATION_DELAY_MSEC;</a>
<a name="ln434">  pim_ifp-&gt;pim_override_interval_msec = PIM_DEFAULT_OVERRIDE_INTERVAL_MSEC;</a>
<a name="ln435">  if (PIM_DEFAULT_CAN_DISABLE_JOIN_SUPPRESSION) {</a>
<a name="ln436">    PIM_IF_DO_PIM_CAN_DISABLE_JOIN_SUPRESSION(pim_ifp-&gt;options);</a>
<a name="ln437">  }</a>
<a name="ln438">  else {</a>
<a name="ln439">    PIM_IF_DONT_PIM_CAN_DISABLE_JOIN_SUPRESSION(pim_ifp-&gt;options);</a>
<a name="ln440">  }</a>
<a name="ln441"> </a>
<a name="ln442">  /* neighbors without lan_delay */</a>
<a name="ln443">  pim_ifp-&gt;pim_number_of_nonlandelay_neighbors = 0;</a>
<a name="ln444">  pim_ifp-&gt;pim_neighbors_highest_propagation_delay_msec = 0;</a>
<a name="ln445">  pim_ifp-&gt;pim_neighbors_highest_override_interval_msec = 0;</a>
<a name="ln446"> </a>
<a name="ln447">  /* DR Election */</a>
<a name="ln448">  pim_ifp-&gt;pim_dr_election_last          = 0; /* timestamp */</a>
<a name="ln449">  pim_ifp-&gt;pim_dr_election_count         = 0;</a>
<a name="ln450">  pim_ifp-&gt;pim_dr_election_changes       = 0;</a>
<a name="ln451">  pim_ifp-&gt;pim_dr_num_nondrpri_neighbors = 0; /* neighbors without dr_pri */</a>
<a name="ln452">  pim_ifp-&gt;pim_dr_addr                   = pim_ifp-&gt;primary_address;</a>
<a name="ln453"> </a>
<a name="ln454">  pim_ifstat_reset(ifp);</a>
<a name="ln455">}</a>
<a name="ln456"> </a>
<a name="ln457">int pim_msg_send(int fd,</a>
<a name="ln458">		 struct in_addr dst,</a>
<a name="ln459">		 uint8_t *pim_msg,</a>
<a name="ln460">		 int pim_msg_size,</a>
<a name="ln461">		 const char *ifname)</a>
<a name="ln462">{</a>
<a name="ln463">  ssize_t            sent;</a>
<a name="ln464">  struct sockaddr_in to;</a>
<a name="ln465">  socklen_t          tolen;</a>
<a name="ln466"> </a>
<a name="ln467">  if (PIM_DEBUG_PIM_PACKETS) {</a>
<a name="ln468">    char dst_str[100];</a>
<a name="ln469">    pim_inet4_dump(&quot;&lt;dst?&gt;&quot;, dst, dst_str, sizeof(dst_str));</a>
<a name="ln470">    zlog_debug(&quot;%s: to %s on %s: msg_size=%d checksum=%x&quot;,</a>
<a name="ln471">	       __PRETTY_FUNCTION__,</a>
<a name="ln472">	       dst_str, ifname, pim_msg_size,</a>
<a name="ln473">	       *(uint16_t *) PIM_MSG_HDR_OFFSET_CHECKSUM(pim_msg));</a>
<a name="ln474">  }</a>
<a name="ln475"> </a>
<a name="ln476">  memset(&amp;to, 0, sizeof(to));</a>
<a name="ln477">  to.sin_family = AF_INET;</a>
<a name="ln478">  to.sin_addr = dst;</a>
<a name="ln479">  tolen = sizeof(to);</a>
<a name="ln480"> </a>
<a name="ln481">  if (PIM_DEBUG_PIM_PACKETDUMP_SEND) {</a>
<a name="ln482">    pim_pkt_dump(__PRETTY_FUNCTION__, pim_msg, pim_msg_size);</a>
<a name="ln483">  }</a>
<a name="ln484"> </a>
<a name="ln485">  sent = sendto(fd, pim_msg, pim_msg_size, MSG_DONTWAIT,</a>
<a name="ln486">                (struct sockaddr *)&amp;to, tolen);</a>
<a name="ln487">  if (sent != (ssize_t) pim_msg_size) {</a>
<a name="ln488">    int e = errno;</a>
<a name="ln489">    char dst_str[100];</a>
<a name="ln490">    pim_inet4_dump(&quot;&lt;dst?&gt;&quot;, dst, dst_str, sizeof(dst_str));</a>
<a name="ln491">    if (sent &lt; 0) {</a>
<a name="ln492">      zlog_warn(&quot;%s: sendto() failure to %s on %s: fd=%d msg_size=%d: errno=%d: %s&quot;,</a>
<a name="ln493">		__PRETTY_FUNCTION__,</a>
<a name="ln494">		dst_str, ifname, fd, pim_msg_size,</a>
<a name="ln495">		e, safe_strerror(e));</a>
<a name="ln496">    }</a>
<a name="ln497">    else {</a>
<a name="ln498">      zlog_warn(&quot;%s: sendto() partial to %s on %s: fd=%d msg_size=%d: sent=%zd&quot;,</a>
<a name="ln499">		__PRETTY_FUNCTION__,</a>
<a name="ln500">		dst_str, ifname, fd,</a>
<a name="ln501">		pim_msg_size, sent);</a>
<a name="ln502">    }</a>
<a name="ln503">    return -1;</a>
<a name="ln504">  }</a>
<a name="ln505"> </a>
<a name="ln506">  return 0;</a>
<a name="ln507">}</a>
<a name="ln508"> </a>
<a name="ln509">static int hello_send(struct interface *ifp,</a>
<a name="ln510">		      uint16_t holdtime)</a>
<a name="ln511">{</a>
<a name="ln512">  uint8_t pim_msg[PIM_PIM_BUFSIZE_WRITE];</a>
<a name="ln513">  struct pim_interface *pim_ifp;</a>
<a name="ln514">  int pim_tlv_size;</a>
<a name="ln515">  int pim_msg_size;</a>
<a name="ln516"> </a>
<a name="ln517">  pim_ifp = ifp-&gt;info;</a>
<a name="ln518"> </a>
<a name="ln519">  if (PIM_DEBUG_PIM_HELLO) {</a>
<a name="ln520">    char dst_str[100];</a>
<a name="ln521">    pim_inet4_dump(&quot;&lt;dst?&gt;&quot;, qpim_all_pim_routers_addr, dst_str, sizeof(dst_str));</a>
<a name="ln522">    zlog_debug(&quot;%s: to %s on %s: holdt=%u prop_d=%u overr_i=%u dis_join_supp=%d dr_prio=%u gen_id=%08x addrs=%d&quot;,</a>
<a name="ln523">	       __PRETTY_FUNCTION__,</a>
<a name="ln524">	       dst_str, ifp-&gt;name,</a>
<a name="ln525">	       holdtime,</a>
<a name="ln526">	       pim_ifp-&gt;pim_propagation_delay_msec, pim_ifp-&gt;pim_override_interval_msec,</a>
<a name="ln527">	       PIM_IF_TEST_PIM_CAN_DISABLE_JOIN_SUPRESSION(pim_ifp-&gt;options),</a>
<a name="ln528">	       pim_ifp-&gt;pim_dr_priority, pim_ifp-&gt;pim_generation_id,</a>
<a name="ln529">	       listcount(ifp-&gt;connected));</a>
<a name="ln530">  }</a>
<a name="ln531"> </a>
<a name="ln532">  pim_tlv_size = pim_hello_build_tlv(ifp-&gt;name,</a>
<a name="ln533">				     pim_msg + PIM_PIM_MIN_LEN,</a>
<a name="ln534">				     sizeof(pim_msg) - PIM_PIM_MIN_LEN,</a>
<a name="ln535">				     holdtime,</a>
<a name="ln536">				     pim_ifp-&gt;pim_dr_priority,</a>
<a name="ln537">				     pim_ifp-&gt;pim_generation_id,</a>
<a name="ln538">				     pim_ifp-&gt;pim_propagation_delay_msec,</a>
<a name="ln539">				     pim_ifp-&gt;pim_override_interval_msec,</a>
<a name="ln540">				     PIM_IF_TEST_PIM_CAN_DISABLE_JOIN_SUPRESSION(pim_ifp-&gt;options),</a>
<a name="ln541">				     ifp-&gt;connected);</a>
<a name="ln542">  if (pim_tlv_size &lt; 0) {</a>
<a name="ln543">    return -1;</a>
<a name="ln544">  }</a>
<a name="ln545"> </a>
<a name="ln546">  pim_msg_size = pim_tlv_size + PIM_PIM_MIN_LEN;</a>
<a name="ln547"> </a>
<a name="ln548">  zassert(pim_msg_size &gt;= PIM_PIM_MIN_LEN);</a>
<a name="ln549">  zassert(pim_msg_size &lt;= PIM_PIM_BUFSIZE_WRITE);</a>
<a name="ln550"> </a>
<a name="ln551">  pim_msg_build_header(pim_msg, pim_msg_size,</a>
<a name="ln552">		       PIM_MSG_TYPE_HELLO);</a>
<a name="ln553"> </a>
<a name="ln554">  if (pim_msg_send(pim_ifp-&gt;pim_sock_fd,</a>
<a name="ln555">		   qpim_all_pim_routers_addr,</a>
<a name="ln556">		   pim_msg,</a>
<a name="ln557">		   pim_msg_size,</a>
<a name="ln558">		   ifp-&gt;name)) {</a>
<a name="ln559">    if (PIM_DEBUG_PIM_HELLO) {</a>
<a name="ln560">      zlog_debug(&quot;%s: could not send PIM message on interface %s&quot;,</a>
<a name="ln561">		 __PRETTY_FUNCTION__, ifp-&gt;name);</a>
<a name="ln562">    }</a>
<a name="ln563">    return -2;</a>
<a name="ln564">  }</a>
<a name="ln565"> </a>
<a name="ln566">  return 0;</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">static int pim_hello_send(struct interface *ifp,</a>
<a name="ln570">			  uint16_t holdtime)</a>
<a name="ln571">{</a>
<a name="ln572">  struct pim_interface *pim_ifp;</a>
<a name="ln573"> </a>
<a name="ln574">  zassert(ifp);</a>
<a name="ln575">  pim_ifp = ifp-&gt;info;</a>
<a name="ln576">  zassert(pim_ifp);</a>
<a name="ln577"> </a>
<a name="ln578">  if (hello_send(ifp, holdtime)) {</a>
<a name="ln579">    ++pim_ifp-&gt;pim_ifstat_hello_sendfail;</a>
<a name="ln580"> </a>
<a name="ln581">    if (PIM_DEBUG_PIM_HELLO) {</a>
<a name="ln582">      zlog_warn(&quot;Could not send PIM hello on interface %s&quot;,</a>
<a name="ln583">		ifp-&gt;name);</a>
<a name="ln584">    }</a>
<a name="ln585">    return -1;</a>
<a name="ln586">  }</a>
<a name="ln587"> </a>
<a name="ln588">  ++pim_ifp-&gt;pim_ifstat_hello_sent;</a>
<a name="ln589"> </a>
<a name="ln590">  return 0;</a>
<a name="ln591">}</a>
<a name="ln592"> </a>
<a name="ln593">static void hello_resched(struct interface *ifp)</a>
<a name="ln594">{</a>
<a name="ln595">  struct pim_interface *pim_ifp;</a>
<a name="ln596"> </a>
<a name="ln597">  zassert(ifp);</a>
<a name="ln598">  pim_ifp = ifp-&gt;info;</a>
<a name="ln599">  zassert(pim_ifp);</a>
<a name="ln600"> </a>
<a name="ln601">  if (PIM_DEBUG_PIM_HELLO) {</a>
<a name="ln602">    zlog_debug(&quot;Rescheduling %d sec hello on interface %s&quot;,</a>
<a name="ln603">	       pim_ifp-&gt;pim_hello_period, ifp-&gt;name);</a>
<a name="ln604">  }</a>
<a name="ln605">  THREAD_OFF(pim_ifp-&gt;t_pim_hello_timer);</a>
<a name="ln606">  THREAD_TIMER_ON(master, pim_ifp-&gt;t_pim_hello_timer,</a>
<a name="ln607">		  on_pim_hello_send,</a>
<a name="ln608">		  ifp, pim_ifp-&gt;pim_hello_period);</a>
<a name="ln609">}</a>
<a name="ln610"> </a>
<a name="ln611">/*</a>
<a name="ln612">  Periodic hello timer</a>
<a name="ln613"> */</a>
<a name="ln614">static int on_pim_hello_send(struct thread *t)</a>
<a name="ln615">{</a>
<a name="ln616">  struct pim_interface *pim_ifp;</a>
<a name="ln617">  struct interface *ifp;</a>
<a name="ln618"> </a>
<a name="ln619">  zassert(t);</a>
<a name="ln620">  ifp = THREAD_ARG(t);</a>
<a name="ln621">  zassert(ifp);</a>
<a name="ln622"> </a>
<a name="ln623">  pim_ifp = ifp-&gt;info;</a>
<a name="ln624"> </a>
<a name="ln625">  /*</a>
<a name="ln626">   * Schedule next hello</a>
<a name="ln627">   */</a>
<a name="ln628">  pim_ifp-&gt;t_pim_hello_timer = 0;</a>
<a name="ln629">  hello_resched(ifp);</a>
<a name="ln630"> </a>
<a name="ln631">  /*</a>
<a name="ln632">   * Send hello</a>
<a name="ln633">   */</a>
<a name="ln634">  return pim_hello_send(ifp, PIM_IF_DEFAULT_HOLDTIME(pim_ifp));</a>
<a name="ln635">}</a>
<a name="ln636"> </a>
<a name="ln637">/*</a>
<a name="ln638">  RFC 4601: 4.3.1.  Sending Hello Messages</a>
<a name="ln639"> </a>
<a name="ln640">  Thus, if a router needs to send a Join/Prune or Assert message on an</a>
<a name="ln641">  interface on which it has not yet sent a Hello message with the</a>
<a name="ln642">  currently configured IP address, then it MUST immediately send the</a>
<a name="ln643">  relevant Hello message without waiting for the Hello Timer to</a>
<a name="ln644">  expire, followed by the Join/Prune or Assert message.</a>
<a name="ln645"> */</a>
<a name="ln646">void pim_hello_restart_now(struct interface *ifp)</a>
<a name="ln647">{</a>
<a name="ln648">  struct pim_interface *pim_ifp;</a>
<a name="ln649"> </a>
<a name="ln650">  zassert(ifp);</a>
<a name="ln651">  pim_ifp = ifp-&gt;info;</a>
<a name="ln652">  zassert(pim_ifp);</a>
<a name="ln653"> </a>
<a name="ln654">  /*</a>
<a name="ln655">   * Reset next hello timer</a>
<a name="ln656">   */</a>
<a name="ln657">  hello_resched(ifp);</a>
<a name="ln658"> </a>
<a name="ln659">  /*</a>
<a name="ln660">   * Immediately send hello</a>
<a name="ln661">   */</a>
<a name="ln662">  pim_hello_send(ifp, PIM_IF_DEFAULT_HOLDTIME(pim_ifp));</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">/*</a>
<a name="ln666">  RFC 4601: 4.3.1.  Sending Hello Messages</a>
<a name="ln667"> </a>
<a name="ln668">  To allow new or rebooting routers to learn of PIM neighbors quickly,</a>
<a name="ln669">  when a Hello message is received from a new neighbor, or a Hello</a>
<a name="ln670">  message with a new GenID is received from an existing neighbor, a</a>
<a name="ln671">  new Hello message should be sent on this interface after a</a>
<a name="ln672">  randomized delay between 0 and Triggered_Hello_Delay.</a>
<a name="ln673"> */</a>
<a name="ln674">void pim_hello_restart_triggered(struct interface *ifp)</a>
<a name="ln675">{</a>
<a name="ln676">  struct pim_interface *pim_ifp;</a>
<a name="ln677">  int triggered_hello_delay_msec;</a>
<a name="ln678">  int random_msec;</a>
<a name="ln679"> </a>
<a name="ln680">  zassert(ifp);</a>
<a name="ln681">  pim_ifp = ifp-&gt;info;</a>
<a name="ln682">  zassert(pim_ifp);</a>
<a name="ln683"> </a>
<a name="ln684">  triggered_hello_delay_msec = 1000 * pim_ifp-&gt;pim_triggered_hello_delay;</a>
<a name="ln685"> </a>
<a name="ln686">  if (pim_ifp-&gt;t_pim_hello_timer) {</a>
<a name="ln687">    long remain_msec = pim_time_timer_remain_msec(pim_ifp-&gt;t_pim_hello_timer);</a>
<a name="ln688">    if (remain_msec &lt;= triggered_hello_delay_msec) {</a>
<a name="ln689">      /* Rescheduling hello would increase the delay, then it's faster</a>
<a name="ln690">	 to just wait for the scheduled periodic hello. */</a>
<a name="ln691">      return;</a>
<a name="ln692">    }</a>
<a name="ln693"> </a>
<a name="ln694">    THREAD_OFF(pim_ifp-&gt;t_pim_hello_timer);</a>
<a name="ln695">    pim_ifp-&gt;t_pim_hello_timer = 0;</a>
<a name="ln696">  }</a>
<a name="ln697">  zassert(!pim_ifp-&gt;t_pim_hello_timer);</a>
<a name="ln698"> </a>
<a name="ln699">  random_msec = random() % (triggered_hello_delay_msec + 1);</a>
<a name="ln700"> </a>
<a name="ln701">  if (PIM_DEBUG_PIM_HELLO) {</a>
<a name="ln702">    zlog_debug(&quot;Scheduling %d msec triggered hello on interface %s&quot;,</a>
<a name="ln703">	       random_msec, ifp-&gt;name);</a>
<a name="ln704">  }</a>
<a name="ln705"> </a>
<a name="ln706">  THREAD_TIMER_MSEC_ON(master, pim_ifp-&gt;t_pim_hello_timer,</a>
<a name="ln707">		       on_pim_hello_send,</a>
<a name="ln708">		       ifp, random_msec);</a>
<a name="ln709">}</a>
<a name="ln710"> </a>
<a name="ln711">int pim_sock_add(struct interface *ifp)</a>
<a name="ln712">{</a>
<a name="ln713">  struct pim_interface *pim_ifp;</a>
<a name="ln714">  struct in_addr ifaddr;</a>
<a name="ln715">  uint32_t old_genid;</a>
<a name="ln716"> </a>
<a name="ln717">  pim_ifp = ifp-&gt;info;</a>
<a name="ln718">  zassert(pim_ifp);</a>
<a name="ln719"> </a>
<a name="ln720">  if (pim_ifp-&gt;pim_sock_fd &gt;= 0) {</a>
<a name="ln721">    zlog_warn(&quot;Can't recreate existing PIM socket fd=%d for interface %s&quot;,</a>
<a name="ln722">	      pim_ifp-&gt;pim_sock_fd, ifp-&gt;name);</a>
<a name="ln723">    return -1;</a>
<a name="ln724">  }</a>
<a name="ln725"> </a>
<a name="ln726">  ifaddr = pim_ifp-&gt;primary_address;</a>
<a name="ln727"> </a>
<a name="ln728">  pim_ifp-&gt;pim_sock_fd = pim_sock_open(ifaddr, ifp-&gt;ifindex);</a>
<a name="ln729">  if (pim_ifp-&gt;pim_sock_fd &lt; 0) {</a>
<a name="ln730">    zlog_warn(&quot;Could not open PIM socket on interface %s&quot;,</a>
<a name="ln731">	      ifp-&gt;name);</a>
<a name="ln732">    return -2;</a>
<a name="ln733">  }</a>
<a name="ln734"> </a>
<a name="ln735">  pim_ifp-&gt;t_pim_sock_read   = 0;</a>
<a name="ln736">  pim_ifp-&gt;pim_sock_creation = pim_time_monotonic_sec();</a>
<a name="ln737"> </a>
<a name="ln738">  /*</a>
<a name="ln739">   * Just ensure that the new generation id</a>
<a name="ln740">   * actually chooses something different.</a>
<a name="ln741">   * Actually ran across a case where this</a>
<a name="ln742">   * happened, pre-switch to random().</a>
<a name="ln743">   * While this is unlikely to happen now</a>
<a name="ln744">   * let's make sure it doesn't.</a>
<a name="ln745">   */</a>
<a name="ln746">  old_genid = pim_ifp-&gt;pim_generation_id;</a>
<a name="ln747"> </a>
<a name="ln748">  while (old_genid == pim_ifp-&gt;pim_generation_id)</a>
<a name="ln749">    pim_ifp-&gt;pim_generation_id = random();</a>
<a name="ln750"> </a>
<a name="ln751">  zlog_info(&quot;PIM INTERFACE UP: on interface %s ifindex=%d&quot;,</a>
<a name="ln752">	    ifp-&gt;name, ifp-&gt;ifindex);</a>
<a name="ln753"> </a>
<a name="ln754">  /*</a>
<a name="ln755">   * Start receiving PIM messages</a>
<a name="ln756">   */</a>
<a name="ln757">  pim_sock_read_on(ifp);</a>
<a name="ln758"> </a>
<a name="ln759">  /*</a>
<a name="ln760">   * Start sending PIM hello's</a>
<a name="ln761">   */</a>
<a name="ln762">  pim_hello_restart_triggered(ifp);</a>
<a name="ln763"> </a>
<a name="ln764">  return 0;</a>
<a name="ln765">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="695"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1048/" target="_blank">V1048</a> The 'pim_ifp->t_pim_hello_timer' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
