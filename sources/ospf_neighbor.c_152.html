
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_neighbor.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF Neighbor functions.</a>
<a name="ln3"> * Copyright (C) 1999, 2000 Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> * </a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln8"> * it under the terms of the GNU General Public License as published</a>
<a name="ln9"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln10"> * option) any later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln20"> * Boston, MA 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;linklist.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;command.h&quot;</a>
<a name="ln29">#include &quot;thread.h&quot;</a>
<a name="ln30">#include &quot;stream.h&quot;</a>
<a name="ln31">#include &quot;table.h&quot;</a>
<a name="ln32">#include &quot;log.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln35">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln36">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_network.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_flood.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">/* Fill in the the 'key' as appropriate to retrieve the entry for nbr</a>
<a name="ln47"> * from the ospf_interface's nbrs table. Indexed by interface address</a>
<a name="ln48"> * for all cases except Virtual-link and PointToPoint interfaces, where</a>
<a name="ln49"> * neighbours are indexed by router-ID instead.</a>
<a name="ln50"> */</a>
<a name="ln51">static void</a>
<a name="ln52">ospf_nbr_key (struct ospf_interface *oi, struct ospf_neighbor *nbr,</a>
<a name="ln53">              struct prefix *key)</a>
<a name="ln54">{</a>
<a name="ln55">  key-&gt;family = AF_INET;</a>
<a name="ln56">  key-&gt;prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln57"> </a>
<a name="ln58">  /* vlinks are indexed by router-id */</a>
<a name="ln59">  if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK ||</a>
<a name="ln60">      oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)</a>
<a name="ln61">    key-&gt;u.prefix4 = nbr-&gt;router_id;</a>
<a name="ln62">  else</a>
<a name="ln63">    key-&gt;u.prefix4 = nbr-&gt;src;</a>
<a name="ln64">  return;</a>
<a name="ln65">}</a>
<a name="ln66"> </a>
<a name="ln67">struct ospf_neighbor *</a>
<a name="ln68">ospf_nbr_new (struct ospf_interface *oi)</a>
<a name="ln69">{</a>
<a name="ln70">  struct ospf_neighbor *nbr;</a>
<a name="ln71"> </a>
<a name="ln72">  /* Allcate new neighbor. */</a>
<a name="ln73">  nbr = XCALLOC (MTYPE_OSPF_NEIGHBOR, sizeof (struct ospf_neighbor));</a>
<a name="ln74"> </a>
<a name="ln75">  /* Relate neighbor to the interface. */</a>
<a name="ln76">  nbr-&gt;oi = oi;</a>
<a name="ln77"> </a>
<a name="ln78">  /* Set default values. */</a>
<a name="ln79">  nbr-&gt;state = NSM_Down;</a>
<a name="ln80"> </a>
<a name="ln81">  /* Set inheritance values. */</a>
<a name="ln82">  nbr-&gt;v_inactivity = OSPF_IF_PARAM (oi, v_wait);</a>
<a name="ln83">  nbr-&gt;v_db_desc = OSPF_IF_PARAM (oi, retransmit_interval);</a>
<a name="ln84">  nbr-&gt;v_ls_req = OSPF_IF_PARAM (oi, retransmit_interval);</a>
<a name="ln85">  nbr-&gt;v_ls_upd = OSPF_IF_PARAM (oi, retransmit_interval);</a>
<a name="ln86">  nbr-&gt;priority = -1;</a>
<a name="ln87"> </a>
<a name="ln88">  /* DD flags. */</a>
<a name="ln89">  nbr-&gt;dd_flags = OSPF_DD_FLAG_MS|OSPF_DD_FLAG_M|OSPF_DD_FLAG_I;</a>
<a name="ln90"> </a>
<a name="ln91">  /* Last received and sent DD. */</a>
<a name="ln92">  nbr-&gt;last_send = NULL;</a>
<a name="ln93"> </a>
<a name="ln94">  nbr-&gt;nbr_nbma = NULL;</a>
<a name="ln95"> </a>
<a name="ln96">  ospf_lsdb_init (&amp;nbr-&gt;db_sum);</a>
<a name="ln97">  ospf_lsdb_init (&amp;nbr-&gt;ls_rxmt);</a>
<a name="ln98">  ospf_lsdb_init (&amp;nbr-&gt;ls_req);</a>
<a name="ln99"> </a>
<a name="ln100">  nbr-&gt;crypt_seqnum = 0;</a>
<a name="ln101"> </a>
<a name="ln102">  return nbr;</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">void</a>
<a name="ln106">ospf_nbr_free (struct ospf_neighbor *nbr)</a>
<a name="ln107">{</a>
<a name="ln108">  /* Free DB summary list. */</a>
<a name="ln109">  if (ospf_db_summary_count (nbr))</a>
<a name="ln110">    ospf_db_summary_clear (nbr);</a>
<a name="ln111">    /* ospf_db_summary_delete_all (nbr); */</a>
<a name="ln112"> </a>
<a name="ln113">  /* Free ls request list. */</a>
<a name="ln114">  if (ospf_ls_request_count (nbr))</a>
<a name="ln115">    ospf_ls_request_delete_all (nbr);</a>
<a name="ln116"> </a>
<a name="ln117">  /* Free retransmit list. */</a>
<a name="ln118">  if (ospf_ls_retransmit_count (nbr))</a>
<a name="ln119">    ospf_ls_retransmit_clear (nbr);</a>
<a name="ln120"> </a>
<a name="ln121">  /* Cleanup LSDBs. */</a>
<a name="ln122">  ospf_lsdb_cleanup (&amp;nbr-&gt;db_sum);</a>
<a name="ln123">  ospf_lsdb_cleanup (&amp;nbr-&gt;ls_req);</a>
<a name="ln124">  ospf_lsdb_cleanup (&amp;nbr-&gt;ls_rxmt);</a>
<a name="ln125">  </a>
<a name="ln126">  /* Clear last send packet. */</a>
<a name="ln127">  if (nbr-&gt;last_send)</a>
<a name="ln128">    ospf_packet_free (nbr-&gt;last_send);</a>
<a name="ln129"> </a>
<a name="ln130">  if (nbr-&gt;nbr_nbma)</a>
<a name="ln131">    {</a>
<a name="ln132">      nbr-&gt;nbr_nbma-&gt;nbr = NULL;</a>
<a name="ln133">      nbr-&gt;nbr_nbma = NULL;</a>
<a name="ln134">    }</a>
<a name="ln135"> </a>
<a name="ln136">  /* Cancel all timers. */</a>
<a name="ln137">  OSPF_NSM_TIMER_OFF (nbr-&gt;t_inactivity);</a>
<a name="ln138">  OSPF_NSM_TIMER_OFF (nbr-&gt;t_db_desc);</a>
<a name="ln139">  OSPF_NSM_TIMER_OFF (nbr-&gt;t_ls_req);</a>
<a name="ln140">  OSPF_NSM_TIMER_OFF (nbr-&gt;t_ls_upd);</a>
<a name="ln141"> </a>
<a name="ln142">  /* Cancel all events. *//* Thread lookup cost would be negligible. */</a>
<a name="ln143">  thread_cancel_event (master, nbr);</a>
<a name="ln144"> </a>
<a name="ln145">  XFREE (MTYPE_OSPF_NEIGHBOR, nbr);</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">/* Delete specified OSPF neighbor from interface. */</a>
<a name="ln149">void</a>
<a name="ln150">ospf_nbr_delete (struct ospf_neighbor *nbr)</a>
<a name="ln151">{</a>
<a name="ln152">  struct ospf_interface *oi;</a>
<a name="ln153">  struct route_node *rn;</a>
<a name="ln154">  struct prefix p;</a>
<a name="ln155"> </a>
<a name="ln156">  oi = nbr-&gt;oi;</a>
<a name="ln157">  </a>
<a name="ln158">  /* get appropriate prefix 'key' */</a>
<a name="ln159">  ospf_nbr_key (oi, nbr, &amp;p);</a>
<a name="ln160"> </a>
<a name="ln161">  rn = route_node_lookup (oi-&gt;nbrs, &amp;p);</a>
<a name="ln162">  if (rn)</a>
<a name="ln163">    {</a>
<a name="ln164">      /* If lookup for a NBR succeeds, the leaf route_node could</a>
<a name="ln165">       * only exist because there is (or was) a nbr there.</a>
<a name="ln166">       * If the nbr was deleted, the leaf route_node should have</a>
<a name="ln167">       * lost its last refcount too, and be deleted.</a>
<a name="ln168">       * Therefore a looked-up leaf route_node in nbrs table</a>
<a name="ln169">       * should never have NULL info.</a>
<a name="ln170">       */</a>
<a name="ln171">      assert (rn-&gt;info);</a>
<a name="ln172">      </a>
<a name="ln173">      if (rn-&gt;info)</a>
<a name="ln174">	{</a>
<a name="ln175">	  rn-&gt;info = NULL;</a>
<a name="ln176">	  route_unlock_node (rn);</a>
<a name="ln177">	}</a>
<a name="ln178">      else</a>
<a name="ln179">	zlog_info (&quot;Can't find neighbor %s in the interface %s&quot;,</a>
<a name="ln180">		   inet_ntoa (nbr-&gt;src), IF_NAME (oi));</a>
<a name="ln181"> </a>
<a name="ln182">      route_unlock_node (rn);</a>
<a name="ln183">    }</a>
<a name="ln184">  else</a>
<a name="ln185">    {</a>
<a name="ln186">      /*</a>
<a name="ln187">       * This neighbor was not found, but before we move on and</a>
<a name="ln188">       * free the neighbor structre, make sure that it was not</a>
<a name="ln189">       * indexed incorrectly and ended up in the &quot;worng&quot; place</a>
<a name="ln190">       */</a>
<a name="ln191"> </a>
<a name="ln192">      /* Reverse the lookup rules */</a>
<a name="ln193">      if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK ||</a>
<a name="ln194">	  oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)</a>
<a name="ln195">	p.u.prefix4 = nbr-&gt;src;</a>
<a name="ln196">      else</a>
<a name="ln197">	p.u.prefix4 = nbr-&gt;router_id;</a>
<a name="ln198"> </a>
<a name="ln199">      rn = route_node_lookup (oi-&gt;nbrs, &amp;p);</a>
<a name="ln200">      if (rn){</a>
<a name="ln201">	/* We found the neighbor!</a>
<a name="ln202">	 * Now make sure it is not the exact same neighbor</a>
<a name="ln203">	 * structure that we are about to free</a>
<a name="ln204">	 */</a>
<a name="ln205">	if (nbr == rn-&gt;info){</a>
<a name="ln206">	  /* Same neighbor, drop the reference to it */</a>
<a name="ln207">	  rn-&gt;info = NULL;</a>
<a name="ln208">	  route_unlock_node (rn);</a>
<a name="ln209">	}</a>
<a name="ln210">	route_unlock_node (rn);</a>
<a name="ln211">      }</a>
<a name="ln212">    }</a>
<a name="ln213"> </a>
<a name="ln214">  /* Free ospf_neighbor structure. */</a>
<a name="ln215">  ospf_nbr_free (nbr);</a>
<a name="ln216">}</a>
<a name="ln217"> </a>
<a name="ln218">/* Check myself is in the neighbor list. */</a>
<a name="ln219">int</a>
<a name="ln220">ospf_nbr_bidirectional (struct in_addr *router_id,</a>
<a name="ln221">			struct in_addr *neighbors, int size)</a>
<a name="ln222">{</a>
<a name="ln223">  int i;</a>
<a name="ln224">  int max;</a>
<a name="ln225"> </a>
<a name="ln226">  max = size / sizeof (struct in_addr);</a>
<a name="ln227"> </a>
<a name="ln228">  for (i = 0; i &lt; max; i ++)</a>
<a name="ln229">    if (IPV4_ADDR_SAME (router_id, &amp;neighbors[i]))</a>
<a name="ln230">      return 1;</a>
<a name="ln231"> </a>
<a name="ln232">  return 0;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235">/* reset nbr_self */</a>
<a name="ln236">void</a>
<a name="ln237">ospf_nbr_self_reset (struct ospf_interface *oi)</a>
<a name="ln238">{</a>
<a name="ln239">  if (oi-&gt;nbr_self)</a>
<a name="ln240">    ospf_nbr_delete (oi-&gt;nbr_self);</a>
<a name="ln241"> </a>
<a name="ln242">  oi-&gt;nbr_self = ospf_nbr_new (oi);</a>
<a name="ln243">  ospf_nbr_add_self (oi);</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">/* Add self to nbr list. */</a>
<a name="ln247">void</a>
<a name="ln248">ospf_nbr_add_self (struct ospf_interface *oi)</a>
<a name="ln249">{</a>
<a name="ln250">  struct prefix p;</a>
<a name="ln251">  struct route_node *rn;</a>
<a name="ln252"> </a>
<a name="ln253">  /* Initial state */</a>
<a name="ln254">  oi-&gt;nbr_self-&gt;address = *oi-&gt;address;</a>
<a name="ln255">  oi-&gt;nbr_self-&gt;priority = OSPF_IF_PARAM (oi, priority);</a>
<a name="ln256">  oi-&gt;nbr_self-&gt;router_id = oi-&gt;ospf-&gt;router_id;</a>
<a name="ln257">  oi-&gt;nbr_self-&gt;src = oi-&gt;address-&gt;u.prefix4;</a>
<a name="ln258">  oi-&gt;nbr_self-&gt;state = NSM_TwoWay;</a>
<a name="ln259">  </a>
<a name="ln260">  switch (oi-&gt;area-&gt;external_routing)</a>
<a name="ln261">    {</a>
<a name="ln262">      case OSPF_AREA_DEFAULT:</a>
<a name="ln263">        SET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_E);</a>
<a name="ln264">        break;</a>
<a name="ln265">      case OSPF_AREA_STUB:</a>
<a name="ln266">        UNSET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_E);</a>
<a name="ln267">        break;</a>
<a name="ln268">      case OSPF_AREA_NSSA:</a>
<a name="ln269">        UNSET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_E);</a>
<a name="ln270">        SET_FLAG (oi-&gt;nbr_self-&gt;options, OSPF_OPTION_NP);</a>
<a name="ln271">        break;</a>
<a name="ln272">    }</a>
<a name="ln273">  </a>
<a name="ln274">  /* Add nbr_self to nbrs table */</a>
<a name="ln275">  ospf_nbr_key (oi, oi-&gt;nbr_self, &amp;p);</a>
<a name="ln276">  </a>
<a name="ln277">  rn = route_node_get (oi-&gt;nbrs, &amp;p);</a>
<a name="ln278">  if (rn-&gt;info)</a>
<a name="ln279">    {</a>
<a name="ln280">      /* There is already pseudo neighbor. */</a>
<a name="ln281">      assert (oi-&gt;nbr_self == rn-&gt;info);</a>
<a name="ln282">      route_unlock_node (rn);</a>
<a name="ln283">    }</a>
<a name="ln284">  else</a>
<a name="ln285">    rn-&gt;info = oi-&gt;nbr_self;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">/* Get neighbor count by status.</a>
<a name="ln289">   Specify status = 0, get all neighbor other than myself. */</a>
<a name="ln290">int</a>
<a name="ln291">ospf_nbr_count (struct ospf_interface *oi, int state)</a>
<a name="ln292">{</a>
<a name="ln293">  struct ospf_neighbor *nbr;</a>
<a name="ln294">  struct route_node *rn;</a>
<a name="ln295">  int count = 0;</a>
<a name="ln296"> </a>
<a name="ln297">  for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln298">    if ((nbr = rn-&gt;info))</a>
<a name="ln299">      if (!IPV4_ADDR_SAME (&amp;nbr-&gt;router_id, &amp;oi-&gt;ospf-&gt;router_id))</a>
<a name="ln300">	if (state == 0 || nbr-&gt;state == state)</a>
<a name="ln301">	  count++;</a>
<a name="ln302"> </a>
<a name="ln303">  return count;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">int</a>
<a name="ln307">ospf_nbr_count_opaque_capable (struct ospf_interface *oi)</a>
<a name="ln308">{</a>
<a name="ln309">  struct ospf_neighbor *nbr;</a>
<a name="ln310">  struct route_node *rn;</a>
<a name="ln311">  int count = 0;</a>
<a name="ln312"> </a>
<a name="ln313">  for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln314">    if ((nbr = rn-&gt;info))</a>
<a name="ln315">      if (!IPV4_ADDR_SAME (&amp;nbr-&gt;router_id, &amp;oi-&gt;ospf-&gt;router_id))</a>
<a name="ln316">	if (nbr-&gt;state == NSM_Full)</a>
<a name="ln317">	  if (CHECK_FLAG (nbr-&gt;options, OSPF_OPTION_O))</a>
<a name="ln318">	    count++;</a>
<a name="ln319"> </a>
<a name="ln320">  return count;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">/* lookup nbr by address - use this only if you know you must</a>
<a name="ln324"> * otherwise use the ospf_nbr_lookup() wrapper, which deals</a>
<a name="ln325"> * with virtual link and PointToPoint neighbours</a>
<a name="ln326"> */</a>
<a name="ln327">struct ospf_neighbor *</a>
<a name="ln328">ospf_nbr_lookup_by_addr (struct route_table *nbrs,</a>
<a name="ln329">			 struct in_addr *addr)</a>
<a name="ln330">{</a>
<a name="ln331">  struct prefix p;</a>
<a name="ln332">  struct route_node *rn;</a>
<a name="ln333">  struct ospf_neighbor *nbr;</a>
<a name="ln334"> </a>
<a name="ln335">  p.family = AF_INET;</a>
<a name="ln336">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln337">  p.u.prefix4 = *addr;</a>
<a name="ln338"> </a>
<a name="ln339">  rn = route_node_lookup (nbrs, &amp;p);</a>
<a name="ln340">  if (! rn)</a>
<a name="ln341">    return NULL;</a>
<a name="ln342">  </a>
<a name="ln343">  /* See comment in ospf_nbr_delete */</a>
<a name="ln344">  assert (rn-&gt;info);</a>
<a name="ln345"> </a>
<a name="ln346">  if (rn-&gt;info == NULL)</a>
<a name="ln347">    {</a>
<a name="ln348">      route_unlock_node (rn);</a>
<a name="ln349">      return NULL;</a>
<a name="ln350">    }</a>
<a name="ln351"> </a>
<a name="ln352">  nbr = (struct ospf_neighbor *) rn-&gt;info;</a>
<a name="ln353">  route_unlock_node (rn);</a>
<a name="ln354"> </a>
<a name="ln355">  return nbr;</a>
<a name="ln356">}</a>
<a name="ln357"> </a>
<a name="ln358">struct ospf_neighbor *</a>
<a name="ln359">ospf_nbr_lookup_by_routerid (struct route_table *nbrs,</a>
<a name="ln360">			     struct in_addr *id)</a>
<a name="ln361">{</a>
<a name="ln362">  struct route_node *rn;</a>
<a name="ln363">  struct ospf_neighbor *nbr;</a>
<a name="ln364"> </a>
<a name="ln365">  for (rn = route_top (nbrs); rn; rn = route_next (rn))</a>
<a name="ln366">    if ((nbr = rn-&gt;info) != NULL)</a>
<a name="ln367">      if (IPV4_ADDR_SAME (&amp;nbr-&gt;router_id, id))</a>
<a name="ln368">	{</a>
<a name="ln369">	  route_unlock_node(rn);</a>
<a name="ln370">	  return nbr;</a>
<a name="ln371">	}</a>
<a name="ln372"> </a>
<a name="ln373">  return NULL;</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">void</a>
<a name="ln377">ospf_renegotiate_optional_capabilities (struct ospf *top)</a>
<a name="ln378">{</a>
<a name="ln379">  struct listnode *node;</a>
<a name="ln380">  struct ospf_interface *oi;</a>
<a name="ln381">  struct route_table *nbrs;</a>
<a name="ln382">  struct route_node *rn;</a>
<a name="ln383">  struct ospf_neighbor *nbr;</a>
<a name="ln384"> </a>
<a name="ln385">  /* At first, flush self-originated LSAs from routing domain. */</a>
<a name="ln386">  ospf_flush_self_originated_lsas_now (top);</a>
<a name="ln387"> </a>
<a name="ln388">  /* Revert all neighbor status to ExStart. */</a>
<a name="ln389">  for (ALL_LIST_ELEMENTS_RO (top-&gt;oiflist, node, oi))</a>
<a name="ln390">    {</a>
<a name="ln391">      if ((nbrs = oi-&gt;nbrs) == NULL)</a>
<a name="ln392">        continue;</a>
<a name="ln393"> </a>
<a name="ln394">      for (rn = route_top (nbrs); rn; rn = route_next (rn))</a>
<a name="ln395">        {</a>
<a name="ln396">          if ((nbr = rn-&gt;info) == NULL || nbr == oi-&gt;nbr_self)</a>
<a name="ln397">            continue;</a>
<a name="ln398"> </a>
<a name="ln399">          if (nbr-&gt;state &lt; NSM_ExStart)</a>
<a name="ln400">            continue;</a>
<a name="ln401"> </a>
<a name="ln402">          if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln403">            zlog_debug (&quot;Renegotiate optional capabilities with neighbor(%s)&quot;, inet_ntoa (nbr-&gt;router_id));</a>
<a name="ln404"> </a>
<a name="ln405">          OSPF_NSM_EVENT_SCHEDULE (nbr, NSM_SeqNumberMismatch);</a>
<a name="ln406">        }</a>
<a name="ln407">    }</a>
<a name="ln408"> </a>
<a name="ln409">  return;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412"> </a>
<a name="ln413">struct ospf_neighbor *</a>
<a name="ln414">ospf_nbr_lookup (struct ospf_interface *oi, struct ip *iph,</a>
<a name="ln415">                 struct ospf_header *ospfh)</a>
<a name="ln416">{</a>
<a name="ln417">  if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK ||</a>
<a name="ln418">      oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)</a>
<a name="ln419">    return (ospf_nbr_lookup_by_routerid (oi-&gt;nbrs, &amp;ospfh-&gt;router_id));</a>
<a name="ln420">  else</a>
<a name="ln421">    return (ospf_nbr_lookup_by_addr (oi-&gt;nbrs, &amp;iph-&gt;ip_src));</a>
<a name="ln422">}</a>
<a name="ln423"> </a>
<a name="ln424">static struct ospf_neighbor *</a>
<a name="ln425">ospf_nbr_add (struct ospf_interface *oi, struct ospf_header *ospfh,</a>
<a name="ln426">              struct prefix *p)</a>
<a name="ln427">{</a>
<a name="ln428">  struct ospf_neighbor *nbr;</a>
<a name="ln429">  </a>
<a name="ln430">  nbr = ospf_nbr_new (oi);</a>
<a name="ln431">  nbr-&gt;state = NSM_Down;</a>
<a name="ln432">  nbr-&gt;src = p-&gt;u.prefix4;</a>
<a name="ln433">  memcpy (&amp;nbr-&gt;address, p, sizeof (struct prefix));</a>
<a name="ln434"> </a>
<a name="ln435">  nbr-&gt;nbr_nbma = NULL;</a>
<a name="ln436">  if (oi-&gt;type == OSPF_IFTYPE_NBMA)</a>
<a name="ln437">    {</a>
<a name="ln438">      struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln439">      struct listnode *node;</a>
<a name="ln440"> </a>
<a name="ln441">      for (ALL_LIST_ELEMENTS_RO (oi-&gt;nbr_nbma, node, nbr_nbma))</a>
<a name="ln442">        {</a>
<a name="ln443">          if (IPV4_ADDR_SAME(&amp;nbr_nbma-&gt;addr, &amp;nbr-&gt;src))</a>
<a name="ln444">            {</a>
<a name="ln445">              nbr_nbma-&gt;nbr = nbr;</a>
<a name="ln446">              nbr-&gt;nbr_nbma = nbr_nbma;</a>
<a name="ln447"> </a>
<a name="ln448">              if (nbr_nbma-&gt;t_poll)</a>
<a name="ln449">                OSPF_POLL_TIMER_OFF (nbr_nbma-&gt;t_poll);</a>
<a name="ln450"> </a>
<a name="ln451">              nbr-&gt;state_change = nbr_nbma-&gt;state_change + 1;</a>
<a name="ln452">            }</a>
<a name="ln453">        }</a>
<a name="ln454">    }</a>
<a name="ln455">      </a>
<a name="ln456">  /* New nbr, save the crypto sequence number if necessary */</a>
<a name="ln457">  if (ntohs (ospfh-&gt;auth_type) == OSPF_AUTH_CRYPTOGRAPHIC)</a>
<a name="ln458">    nbr-&gt;crypt_seqnum = ospfh-&gt;u.crypt.crypt_seqnum;</a>
<a name="ln459">  </a>
<a name="ln460">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln461">    zlog_debug (&quot;NSM[%s:%s]: start&quot;, IF_NAME (nbr-&gt;oi),</a>
<a name="ln462">               inet_ntoa (nbr-&gt;router_id));</a>
<a name="ln463">  </a>
<a name="ln464">  return nbr;</a>
<a name="ln465">}</a>
<a name="ln466"> </a>
<a name="ln467">struct ospf_neighbor *</a>
<a name="ln468">ospf_nbr_get (struct ospf_interface *oi, struct ospf_header *ospfh,</a>
<a name="ln469">              struct ip *iph, struct prefix *p)</a>
<a name="ln470">{</a>
<a name="ln471">  struct route_node *rn;</a>
<a name="ln472">  struct prefix key;</a>
<a name="ln473">  struct ospf_neighbor *nbr;</a>
<a name="ln474">  </a>
<a name="ln475">  key.family = AF_INET;</a>
<a name="ln476">  key.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln477"> </a>
<a name="ln478">  if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK ||</a>
<a name="ln479">      oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)</a>
<a name="ln480">    key.u.prefix4 = ospfh-&gt;router_id;/* index vlink and ptp nbrs by router-id */</a>
<a name="ln481">  else</a>
<a name="ln482">    key.u.prefix4 = iph-&gt;ip_src;</a>
<a name="ln483"> </a>
<a name="ln484">  rn = route_node_get (oi-&gt;nbrs, &amp;key);</a>
<a name="ln485">  if (rn-&gt;info)</a>
<a name="ln486">    {</a>
<a name="ln487">      route_unlock_node (rn);</a>
<a name="ln488">      nbr = rn-&gt;info;</a>
<a name="ln489">      </a>
<a name="ln490">      if (oi-&gt;type == OSPF_IFTYPE_NBMA &amp;&amp; nbr-&gt;state == NSM_Attempt)</a>
<a name="ln491">        {</a>
<a name="ln492">          nbr-&gt;src = iph-&gt;ip_src;</a>
<a name="ln493">          memcpy (&amp;nbr-&gt;address, p, sizeof (struct prefix));</a>
<a name="ln494">        }</a>
<a name="ln495">    }</a>
<a name="ln496">  else</a>
<a name="ln497">    {</a>
<a name="ln498">      rn-&gt;info = nbr = ospf_nbr_add (oi, ospfh, p);</a>
<a name="ln499">    }</a>
<a name="ln500">  </a>
<a name="ln501">  nbr-&gt;router_id = ospfh-&gt;router_id;</a>
<a name="ln502"> </a>
<a name="ln503">  return nbr;</a>
<a name="ln504">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="173"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'rn->info' is always true.</p></div>
<div class="balloon" rel="346"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'rn->info == NULL' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
