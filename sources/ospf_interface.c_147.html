
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_interface.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF Interface functions.</a>
<a name="ln3"> * Copyright (C) 1999, 2000 Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> * </a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln8"> * it under the terms of the GNU General Public License as published</a>
<a name="ln9"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln10"> * option) any later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln20"> * Boston, MA 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;linklist.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;if.h&quot;</a>
<a name="ln29">#include &quot;table.h&quot;</a>
<a name="ln30">#include &quot;memory.h&quot;</a>
<a name="ln31">#include &quot;command.h&quot;</a>
<a name="ln32">#include &quot;stream.h&quot;</a>
<a name="ln33">#include &quot;log.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln36">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_packet.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_abr.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_network.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln48">#ifdef HAVE_SNMP</a>
<a name="ln49">#include &quot;ospfd/ospf_snmp.h&quot;</a>
<a name="ln50">#endif /* HAVE_SNMP */</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">int</a>
<a name="ln54">ospf_if_get_output_cost (struct ospf_interface *oi)</a>
<a name="ln55">{</a>
<a name="ln56">  /* If all else fails, use default OSPF cost */</a>
<a name="ln57">  u_int32_t cost;</a>
<a name="ln58">  u_int32_t bw, refbw;</a>
<a name="ln59"> </a>
<a name="ln60">  bw = oi-&gt;ifp-&gt;bandwidth ? oi-&gt;ifp-&gt;bandwidth : OSPF_DEFAULT_BANDWIDTH;</a>
<a name="ln61">  refbw = oi-&gt;ospf-&gt;ref_bandwidth;</a>
<a name="ln62"> </a>
<a name="ln63">  /* A specifed ip ospf cost overrides a calculated one. */</a>
<a name="ln64">  if (OSPF_IF_PARAM_CONFIGURED (IF_DEF_PARAMS (oi-&gt;ifp), output_cost_cmd) ||</a>
<a name="ln65">      OSPF_IF_PARAM_CONFIGURED (oi-&gt;params, output_cost_cmd))</a>
<a name="ln66">    cost = OSPF_IF_PARAM (oi, output_cost_cmd);</a>
<a name="ln67">  /* See if a cost can be calculated from the zebra processes</a>
<a name="ln68">     interface bandwidth field. */</a>
<a name="ln69">  else</a>
<a name="ln70">    {</a>
<a name="ln71">      cost = (u_int32_t) ((double)refbw / (double)bw + (double)0.5);</a>
<a name="ln72">      if (cost &lt; 1)</a>
<a name="ln73">	cost = 1;</a>
<a name="ln74">      else if (cost &gt; 65535)</a>
<a name="ln75">	cost = 65535;</a>
<a name="ln76">    }</a>
<a name="ln77"> </a>
<a name="ln78">  return cost;</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">void</a>
<a name="ln82">ospf_if_recalculate_output_cost (struct interface *ifp)</a>
<a name="ln83">{</a>
<a name="ln84">  u_int32_t newcost;</a>
<a name="ln85">  struct route_node *rn;</a>
<a name="ln86">  </a>
<a name="ln87">  for (rn = route_top (IF_OIFS (ifp)); rn; rn = route_next (rn))</a>
<a name="ln88">    {</a>
<a name="ln89">      struct ospf_interface *oi;</a>
<a name="ln90">      </a>
<a name="ln91">      if ( (oi = rn-&gt;info) == NULL)</a>
<a name="ln92">	continue;</a>
<a name="ln93"> </a>
<a name="ln94">      newcost = ospf_if_get_output_cost (oi);</a>
<a name="ln95"> </a>
<a name="ln96">      /* Is actual output cost changed? */</a>
<a name="ln97">      if (oi-&gt;output_cost != newcost)</a>
<a name="ln98">	{</a>
<a name="ln99">	  oi-&gt;output_cost = newcost;</a>
<a name="ln100">	  ospf_router_lsa_update_area (oi-&gt;area);</a>
<a name="ln101">	}</a>
<a name="ln102">    }</a>
<a name="ln103">}</a>
<a name="ln104"> </a>
<a name="ln105">/* Simulate down/up on the interface.  This is needed, for example, when </a>
<a name="ln106">   the MTU changes. */</a>
<a name="ln107">void</a>
<a name="ln108">ospf_if_reset(struct interface *ifp)</a>
<a name="ln109">{</a>
<a name="ln110">  struct route_node *rn;</a>
<a name="ln111">  </a>
<a name="ln112">  for (rn = route_top (IF_OIFS (ifp)); rn; rn = route_next (rn))</a>
<a name="ln113">    {</a>
<a name="ln114">      struct ospf_interface *oi;</a>
<a name="ln115">      </a>
<a name="ln116">      if ( (oi = rn-&gt;info) == NULL)</a>
<a name="ln117">	continue;</a>
<a name="ln118"> </a>
<a name="ln119">      ospf_if_down(oi);</a>
<a name="ln120">      ospf_if_up(oi);</a>
<a name="ln121">    }</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">void</a>
<a name="ln125">ospf_if_reset_variables (struct ospf_interface *oi)</a>
<a name="ln126">{</a>
<a name="ln127">  /* Set default values. */</a>
<a name="ln128">  /* don't clear this flag.  oi-&gt;flag = OSPF_IF_DISABLE; */</a>
<a name="ln129"> </a>
<a name="ln130">  if (oi-&gt;vl_data)</a>
<a name="ln131">    oi-&gt;type = OSPF_IFTYPE_VIRTUALLINK;</a>
<a name="ln132">  else </a>
<a name="ln133">  /* preserve network-type */</a>
<a name="ln134">  if (oi-&gt;type != OSPF_IFTYPE_NBMA)</a>
<a name="ln135">    oi-&gt;type = OSPF_IFTYPE_BROADCAST;</a>
<a name="ln136"> </a>
<a name="ln137">  oi-&gt;state = ISM_Down;</a>
<a name="ln138"> </a>
<a name="ln139">  oi-&gt;crypt_seqnum = 0;</a>
<a name="ln140"> </a>
<a name="ln141">  /* This must be short, (less than RxmtInterval) </a>
<a name="ln142">     - RFC 2328 Section 13.5 para 3.  Set to 1 second to avoid Acks being</a>
<a name="ln143">       held back for too long - MAG */</a>
<a name="ln144">  oi-&gt;v_ls_ack = 1;  </a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">void</a>
<a name="ln148">ospf_if_reset_type (struct interface *ifp, u_char type)</a>
<a name="ln149">{</a>
<a name="ln150">  struct route_node *rn;</a>
<a name="ln151">  </a>
<a name="ln152">  for (rn = route_top (IF_OIFS (ifp)); rn; rn = route_next (rn))</a>
<a name="ln153">    {</a>
<a name="ln154">      struct ospf_interface *oi = rn-&gt;info;</a>
<a name="ln155">      u_char orig_ism_state;</a>
<a name="ln156">      </a>
<a name="ln157">      if (!oi)</a>
<a name="ln158">	continue;</a>
<a name="ln159">      </a>
<a name="ln160">      orig_ism_state = oi-&gt;state;</a>
<a name="ln161">      OSPF_ISM_EVENT_EXECUTE (oi, ISM_InterfaceDown);</a>
<a name="ln162">      </a>
<a name="ln163">      oi-&gt;type = IF_DEF_PARAMS (ifp)-&gt;type;</a>
<a name="ln164">      </a>
<a name="ln165">      if (orig_ism_state &gt; ISM_Down)</a>
<a name="ln166">        OSPF_ISM_EVENT_EXECUTE (oi, ISM_InterfaceUp);</a>
<a name="ln167">    }</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">/* lookup oi for specified prefix/ifp */</a>
<a name="ln171">struct ospf_interface *</a>
<a name="ln172">ospf_if_table_lookup (struct interface *ifp, struct prefix *prefix)</a>
<a name="ln173">{</a>
<a name="ln174">  struct prefix p;</a>
<a name="ln175">  struct route_node *rn;</a>
<a name="ln176">  struct ospf_interface *rninfo = NULL;</a>
<a name="ln177">  </a>
<a name="ln178">  p = *prefix;</a>
<a name="ln179">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln180">  </a>
<a name="ln181">  /* route_node_get implicitely locks */</a>
<a name="ln182">  if ((rn = route_node_lookup (IF_OIFS (ifp), &amp;p)))</a>
<a name="ln183">    {</a>
<a name="ln184">      rninfo = (struct ospf_interface *) rn-&gt;info;</a>
<a name="ln185">      route_unlock_node (rn);</a>
<a name="ln186">    }</a>
<a name="ln187">  </a>
<a name="ln188">  return rninfo;</a>
<a name="ln189">}</a>
<a name="ln190"> </a>
<a name="ln191">static void</a>
<a name="ln192">ospf_add_to_if (struct interface *ifp, struct ospf_interface *oi)</a>
<a name="ln193">{</a>
<a name="ln194">  struct route_node *rn;</a>
<a name="ln195">  struct prefix p;</a>
<a name="ln196"> </a>
<a name="ln197">  p = *oi-&gt;address;</a>
<a name="ln198">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln199"> </a>
<a name="ln200">  rn = route_node_get (IF_OIFS (ifp), &amp;p);</a>
<a name="ln201">  /* rn-&gt;info should either be NULL or equal to this oi</a>
<a name="ln202">   * as route_node_get may return an existing node</a>
<a name="ln203">   */</a>
<a name="ln204">  assert (!rn-&gt;info || rn-&gt;info == oi);</a>
<a name="ln205">  rn-&gt;info = oi;</a>
<a name="ln206">}</a>
<a name="ln207"> </a>
<a name="ln208">static void</a>
<a name="ln209">ospf_delete_from_if (struct interface *ifp, struct ospf_interface *oi)</a>
<a name="ln210">{</a>
<a name="ln211">  struct route_node *rn;</a>
<a name="ln212">  struct prefix p;</a>
<a name="ln213"> </a>
<a name="ln214">  p = *oi-&gt;address;</a>
<a name="ln215">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln216"> </a>
<a name="ln217">  rn = route_node_lookup (IF_OIFS (oi-&gt;ifp), &amp;p);</a>
<a name="ln218">  assert (rn);</a>
<a name="ln219">  assert (rn-&gt;info);</a>
<a name="ln220">  rn-&gt;info = NULL;</a>
<a name="ln221">  route_unlock_node (rn);</a>
<a name="ln222">  route_unlock_node (rn);</a>
<a name="ln223">}</a>
<a name="ln224"> </a>
<a name="ln225">struct ospf_interface *</a>
<a name="ln226">ospf_if_new (struct ospf *ospf, struct interface *ifp, struct prefix *p)</a>
<a name="ln227">{</a>
<a name="ln228">  struct ospf_interface *oi;</a>
<a name="ln229"> </a>
<a name="ln230">  if ((oi = ospf_if_table_lookup (ifp, p)) == NULL)</a>
<a name="ln231">    {</a>
<a name="ln232">      oi = XCALLOC (MTYPE_OSPF_IF, sizeof (struct ospf_interface));</a>
<a name="ln233">      memset (oi, 0, sizeof (struct ospf_interface));</a>
<a name="ln234">    }</a>
<a name="ln235">  else</a>
<a name="ln236">    return oi;</a>
<a name="ln237">    </a>
<a name="ln238">  /* Set zebra interface pointer. */</a>
<a name="ln239">  oi-&gt;ifp = ifp;</a>
<a name="ln240">  oi-&gt;address = p;</a>
<a name="ln241">  </a>
<a name="ln242">  ospf_add_to_if (ifp, oi);</a>
<a name="ln243">  listnode_add (ospf-&gt;oiflist, oi);</a>
<a name="ln244">  </a>
<a name="ln245">  /* Initialize neighbor list. */</a>
<a name="ln246">  oi-&gt;nbrs = route_table_init ();</a>
<a name="ln247"> </a>
<a name="ln248">  /* Initialize static neighbor list. */</a>
<a name="ln249">  oi-&gt;nbr_nbma = list_new ();</a>
<a name="ln250"> </a>
<a name="ln251">  /* Initialize Link State Acknowledgment list. */</a>
<a name="ln252">  oi-&gt;ls_ack = list_new ();</a>
<a name="ln253">  oi-&gt;ls_ack_direct.ls_ack = list_new ();</a>
<a name="ln254"> </a>
<a name="ln255">  /* Set default values. */</a>
<a name="ln256">  ospf_if_reset_variables (oi);</a>
<a name="ln257"> </a>
<a name="ln258">  /* Set pseudo neighbor to Null */</a>
<a name="ln259">  oi-&gt;nbr_self = NULL;</a>
<a name="ln260"> </a>
<a name="ln261">  oi-&gt;ls_upd_queue = route_table_init ();</a>
<a name="ln262">  oi-&gt;t_ls_upd_event = NULL;</a>
<a name="ln263">  oi-&gt;t_ls_ack_direct = NULL;</a>
<a name="ln264"> </a>
<a name="ln265">  oi-&gt;crypt_seqnum = time (NULL);</a>
<a name="ln266"> </a>
<a name="ln267">  ospf_opaque_type9_lsa_init (oi);</a>
<a name="ln268"> </a>
<a name="ln269">  oi-&gt;ospf = ospf;</a>
<a name="ln270">  </a>
<a name="ln271">  return oi;</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">/* Restore an interface to its pre UP state</a>
<a name="ln275">   Used from ism_interface_down only */</a>
<a name="ln276">void</a>
<a name="ln277">ospf_if_cleanup (struct ospf_interface *oi)</a>
<a name="ln278">{</a>
<a name="ln279">  struct route_node *rn;</a>
<a name="ln280">  struct listnode *node, *nnode;</a>
<a name="ln281">  struct ospf_neighbor *nbr;</a>
<a name="ln282">  struct ospf_nbr_nbma *nbr_nbma;</a>
<a name="ln283">  struct ospf_lsa *lsa;</a>
<a name="ln284"> </a>
<a name="ln285">  /* oi-&gt;nbrs and oi-&gt;nbr_nbma should be deleted on InterfaceDown event */</a>
<a name="ln286">  /* delete all static neighbors attached to this interface */</a>
<a name="ln287">  for (ALL_LIST_ELEMENTS (oi-&gt;nbr_nbma, node, nnode, nbr_nbma))</a>
<a name="ln288">    {</a>
<a name="ln289">      OSPF_POLL_TIMER_OFF (nbr_nbma-&gt;t_poll);</a>
<a name="ln290"> </a>
<a name="ln291">      if (nbr_nbma-&gt;nbr)</a>
<a name="ln292">	{</a>
<a name="ln293">	  nbr_nbma-&gt;nbr-&gt;nbr_nbma = NULL;</a>
<a name="ln294">	  nbr_nbma-&gt;nbr = NULL;</a>
<a name="ln295">	}</a>
<a name="ln296"> </a>
<a name="ln297">      nbr_nbma-&gt;oi = NULL;</a>
<a name="ln298">      </a>
<a name="ln299">      listnode_delete (oi-&gt;nbr_nbma, nbr_nbma);</a>
<a name="ln300">    }</a>
<a name="ln301"> </a>
<a name="ln302">  /* send Neighbor event KillNbr to all associated neighbors. */</a>
<a name="ln303">  for (rn = route_top (oi-&gt;nbrs); rn; rn = route_next (rn))</a>
<a name="ln304">    if ((nbr = rn-&gt;info) != NULL)</a>
<a name="ln305">      if (nbr != oi-&gt;nbr_self)</a>
<a name="ln306">	OSPF_NSM_EVENT_EXECUTE (nbr, NSM_KillNbr);</a>
<a name="ln307"> </a>
<a name="ln308">  /* Cleanup Link State Acknowlegdment list. */</a>
<a name="ln309">  for (ALL_LIST_ELEMENTS (oi-&gt;ls_ack, node, nnode, lsa))</a>
<a name="ln310">    ospf_lsa_unlock (&amp;lsa); /* oi-&gt;ls_ack */</a>
<a name="ln311">  list_delete_all_node (oi-&gt;ls_ack);</a>
<a name="ln312"> </a>
<a name="ln313">  oi-&gt;crypt_seqnum = 0;</a>
<a name="ln314">  </a>
<a name="ln315">  /* Empty link state update queue */</a>
<a name="ln316">  ospf_ls_upd_queue_empty (oi);</a>
<a name="ln317">  </a>
<a name="ln318">  /* Reset pseudo neighbor. */</a>
<a name="ln319">  ospf_nbr_self_reset (oi);</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">void</a>
<a name="ln323">ospf_if_free (struct ospf_interface *oi)</a>
<a name="ln324">{</a>
<a name="ln325">  ospf_if_down (oi);</a>
<a name="ln326"> </a>
<a name="ln327">  assert (oi-&gt;state == ISM_Down);</a>
<a name="ln328"> </a>
<a name="ln329">  ospf_opaque_type9_lsa_term (oi);</a>
<a name="ln330"> </a>
<a name="ln331">  /* Free Pseudo Neighbour */</a>
<a name="ln332">  ospf_nbr_delete (oi-&gt;nbr_self);</a>
<a name="ln333">  </a>
<a name="ln334">  route_table_finish (oi-&gt;nbrs);</a>
<a name="ln335">  route_table_finish (oi-&gt;ls_upd_queue);</a>
<a name="ln336">  </a>
<a name="ln337">  /* Free any lists that should be freed */</a>
<a name="ln338">  list_free (oi-&gt;nbr_nbma);</a>
<a name="ln339">  </a>
<a name="ln340">  list_free (oi-&gt;ls_ack);</a>
<a name="ln341">  list_free (oi-&gt;ls_ack_direct.ls_ack);</a>
<a name="ln342">  </a>
<a name="ln343">  ospf_delete_from_if (oi-&gt;ifp, oi);</a>
<a name="ln344"> </a>
<a name="ln345">  listnode_delete (oi-&gt;ospf-&gt;oiflist, oi);</a>
<a name="ln346">  listnode_delete (oi-&gt;area-&gt;oiflist, oi);</a>
<a name="ln347"> </a>
<a name="ln348">  thread_cancel_event (master, oi);</a>
<a name="ln349"> </a>
<a name="ln350">  memset (oi, 0, sizeof (*oi));</a>
<a name="ln351">  XFREE (MTYPE_OSPF_IF, oi);</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354"> </a>
<a name="ln355">/*</a>
<a name="ln356">*  check if interface with given address is configured and</a>
<a name="ln357">*  return it if yes.  special treatment for PtP networks.</a>
<a name="ln358">*/</a>
<a name="ln359">struct ospf_interface *</a>
<a name="ln360">ospf_if_is_configured (struct ospf *ospf, struct in_addr *address)</a>
<a name="ln361">{</a>
<a name="ln362">  struct listnode *node, *nnode;</a>
<a name="ln363">  struct ospf_interface *oi;</a>
<a name="ln364">  struct prefix_ipv4 addr;</a>
<a name="ln365"> </a>
<a name="ln366">  addr.family = AF_INET;</a>
<a name="ln367">  addr.prefix = *address;</a>
<a name="ln368">  addr.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln369"> </a>
<a name="ln370">  for (ALL_LIST_ELEMENTS (ospf-&gt;oiflist, node, nnode, oi))</a>
<a name="ln371">    if (oi-&gt;type != OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln372">      {</a>
<a name="ln373">        if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)</a>
<a name="ln374">	  {</a>
<a name="ln375">	    /* special leniency: match if addr is anywhere on peer subnet */</a>
<a name="ln376">	    if (prefix_match(CONNECTED_PREFIX(oi-&gt;connected),</a>
<a name="ln377">			     (struct prefix *)&amp;addr))</a>
<a name="ln378">	      return oi;</a>
<a name="ln379">	  }</a>
<a name="ln380">        else</a>
<a name="ln381">	  {</a>
<a name="ln382">	    if (IPV4_ADDR_SAME (address, &amp;oi-&gt;address-&gt;u.prefix4))</a>
<a name="ln383">	      return oi;</a>
<a name="ln384">	  }</a>
<a name="ln385">      }</a>
<a name="ln386">  return NULL;</a>
<a name="ln387">}</a>
<a name="ln388"> </a>
<a name="ln389">int</a>
<a name="ln390">ospf_if_is_up (struct ospf_interface *oi)</a>
<a name="ln391">{</a>
<a name="ln392">  return if_is_up (oi-&gt;ifp);</a>
<a name="ln393">}</a>
<a name="ln394"> </a>
<a name="ln395">struct ospf_interface *</a>
<a name="ln396">ospf_if_exists (struct ospf_interface *oic)</a>
<a name="ln397">{ </a>
<a name="ln398">  struct listnode *node;</a>
<a name="ln399">  struct ospf *ospf;</a>
<a name="ln400">  struct ospf_interface *oi;</a>
<a name="ln401"> </a>
<a name="ln402">  if ((ospf = ospf_lookup ()) == NULL)</a>
<a name="ln403">    return NULL;</a>
<a name="ln404"> </a>
<a name="ln405">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, node, oi))</a>
<a name="ln406">    if (oi == oic)</a>
<a name="ln407">      return oi;</a>
<a name="ln408"> </a>
<a name="ln409">  return NULL;</a>
<a name="ln410">}</a>
<a name="ln411"> </a>
<a name="ln412">/* Lookup OSPF interface by router LSA posistion */</a>
<a name="ln413">struct ospf_interface *</a>
<a name="ln414">ospf_if_lookup_by_lsa_pos (struct ospf_area *area, int lsa_pos)</a>
<a name="ln415">{</a>
<a name="ln416">  struct listnode *node;</a>
<a name="ln417">  struct ospf_interface *oi;</a>
<a name="ln418"> </a>
<a name="ln419">  for (ALL_LIST_ELEMENTS_RO (area-&gt;oiflist, node, oi))</a>
<a name="ln420">    {</a>
<a name="ln421">      if (lsa_pos &gt;= oi-&gt;lsa_pos_beg &amp;&amp; lsa_pos &lt; oi-&gt;lsa_pos_end)</a>
<a name="ln422">	return oi;</a>
<a name="ln423">    }</a>
<a name="ln424">  return NULL;</a>
<a name="ln425">}</a>
<a name="ln426"> </a>
<a name="ln427">struct ospf_interface *</a>
<a name="ln428">ospf_if_lookup_by_local_addr (struct ospf *ospf,</a>
<a name="ln429">			      struct interface *ifp, struct in_addr address)</a>
<a name="ln430">{</a>
<a name="ln431">  struct listnode *node;</a>
<a name="ln432">  struct ospf_interface *oi;</a>
<a name="ln433">  </a>
<a name="ln434">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, node, oi))</a>
<a name="ln435">    if (oi-&gt;type != OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln436">      {</a>
<a name="ln437">	if (ifp &amp;&amp; oi-&gt;ifp != ifp)</a>
<a name="ln438">	  continue;</a>
<a name="ln439">	</a>
<a name="ln440">	if (IPV4_ADDR_SAME (&amp;address, &amp;oi-&gt;address-&gt;u.prefix4))</a>
<a name="ln441">	  return oi;</a>
<a name="ln442">      }</a>
<a name="ln443"> </a>
<a name="ln444">  return NULL;</a>
<a name="ln445">}</a>
<a name="ln446"> </a>
<a name="ln447">struct ospf_interface *</a>
<a name="ln448">ospf_if_lookup_by_prefix (struct ospf *ospf, struct prefix_ipv4 *p)</a>
<a name="ln449">{</a>
<a name="ln450">  struct listnode *node;</a>
<a name="ln451">  struct ospf_interface *oi;</a>
<a name="ln452">  </a>
<a name="ln453">  /* Check each Interface. */</a>
<a name="ln454">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;oiflist, node, oi))</a>
<a name="ln455">    {</a>
<a name="ln456">      if (oi-&gt;type != OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln457">	{</a>
<a name="ln458">	  struct prefix ptmp;</a>
<a name="ln459"> </a>
<a name="ln460">	  prefix_copy (&amp;ptmp, CONNECTED_PREFIX(oi-&gt;connected));</a>
<a name="ln461">	  apply_mask (&amp;ptmp);</a>
<a name="ln462">	  if (prefix_same (&amp;ptmp, (struct prefix *) p))</a>
<a name="ln463">	    return oi;</a>
<a name="ln464">	}</a>
<a name="ln465">    }</a>
<a name="ln466">  return NULL;</a>
<a name="ln467">}</a>
<a name="ln468"> </a>
<a name="ln469">/* determine receiving interface by ifp and source address */</a>
<a name="ln470">struct ospf_interface *</a>
<a name="ln471">ospf_if_lookup_recv_if (struct ospf *ospf, struct in_addr src,</a>
<a name="ln472">			struct interface *ifp)</a>
<a name="ln473">{</a>
<a name="ln474">  struct route_node *rn;</a>
<a name="ln475">  struct prefix_ipv4 addr;</a>
<a name="ln476">  struct ospf_interface *oi, *match;</a>
<a name="ln477"> </a>
<a name="ln478">  addr.family = AF_INET;</a>
<a name="ln479">  addr.prefix = src;</a>
<a name="ln480">  addr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln481"> </a>
<a name="ln482">  match = NULL;</a>
<a name="ln483"> </a>
<a name="ln484">  for (rn = route_top (IF_OIFS (ifp)); rn; rn = route_next (rn))</a>
<a name="ln485">    {</a>
<a name="ln486">      oi = rn-&gt;info;</a>
<a name="ln487"> </a>
<a name="ln488">      if (!oi) /* oi can be NULL for PtP aliases */</a>
<a name="ln489">	continue;</a>
<a name="ln490"> </a>
<a name="ln491">      if (oi-&gt;type == OSPF_IFTYPE_VIRTUALLINK)</a>
<a name="ln492">	continue;</a>
<a name="ln493"> </a>
<a name="ln494">      if (if_is_loopback (oi-&gt;ifp))</a>
<a name="ln495">        continue;</a>
<a name="ln496"> </a>
<a name="ln497">      if (prefix_match (CONNECTED_PREFIX(oi-&gt;connected),</a>
<a name="ln498">      			(struct prefix *) &amp;addr))</a>
<a name="ln499">	{</a>
<a name="ln500">	  if ( (match == NULL) || </a>
<a name="ln501">	       (match-&gt;address-&gt;prefixlen &lt; oi-&gt;address-&gt;prefixlen)</a>
<a name="ln502">	     )</a>
<a name="ln503">	    match = oi;</a>
<a name="ln504">	}</a>
<a name="ln505">    }</a>
<a name="ln506"> </a>
<a name="ln507">  return match;</a>
<a name="ln508">}</a>
<a name="ln509"> </a>
<a name="ln510">void</a>
<a name="ln511">ospf_if_stream_set (struct ospf_interface *oi)</a>
<a name="ln512">{</a>
<a name="ln513">  /* set output fifo queue. */</a>
<a name="ln514">  if (oi-&gt;obuf == NULL) </a>
<a name="ln515">    oi-&gt;obuf = ospf_fifo_new ();</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">void</a>
<a name="ln519">ospf_if_stream_unset (struct ospf_interface *oi)</a>
<a name="ln520">{</a>
<a name="ln521">  struct ospf *ospf = oi-&gt;ospf;</a>
<a name="ln522"> </a>
<a name="ln523">  if (oi-&gt;obuf)</a>
<a name="ln524">    {</a>
<a name="ln525">     ospf_fifo_free (oi-&gt;obuf);</a>
<a name="ln526">     oi-&gt;obuf = NULL;</a>
<a name="ln527"> </a>
<a name="ln528">     if (oi-&gt;on_write_q)</a>
<a name="ln529">       {</a>
<a name="ln530">	 listnode_delete (ospf-&gt;oi_write_q, oi);</a>
<a name="ln531">         if (list_isempty(ospf-&gt;oi_write_q))</a>
<a name="ln532">           OSPF_TIMER_OFF (ospf-&gt;t_write);</a>
<a name="ln533">	 oi-&gt;on_write_q = 0;</a>
<a name="ln534">       }</a>
<a name="ln535">    }</a>
<a name="ln536">}</a>
<a name="ln537"> </a>
<a name="ln538"> </a>
<a name="ln539">static struct ospf_if_params *</a>
<a name="ln540">ospf_new_if_params (void)</a>
<a name="ln541">{</a>
<a name="ln542">  struct ospf_if_params *oip;</a>
<a name="ln543"> </a>
<a name="ln544">  oip = XCALLOC (MTYPE_OSPF_IF_PARAMS, sizeof (struct ospf_if_params));</a>
<a name="ln545"> </a>
<a name="ln546">  if (!oip)</a>
<a name="ln547">    return NULL;</a>
<a name="ln548"> </a>
<a name="ln549">  UNSET_IF_PARAM (oip, output_cost_cmd);</a>
<a name="ln550">  UNSET_IF_PARAM (oip, transmit_delay);</a>
<a name="ln551">  UNSET_IF_PARAM (oip, retransmit_interval);</a>
<a name="ln552">  UNSET_IF_PARAM (oip, passive_interface);</a>
<a name="ln553">  UNSET_IF_PARAM (oip, v_hello);</a>
<a name="ln554">  UNSET_IF_PARAM (oip, fast_hello);</a>
<a name="ln555">  UNSET_IF_PARAM (oip, v_wait);</a>
<a name="ln556">  UNSET_IF_PARAM (oip, priority);</a>
<a name="ln557">  UNSET_IF_PARAM (oip, type);</a>
<a name="ln558">  UNSET_IF_PARAM (oip, auth_simple);</a>
<a name="ln559">  UNSET_IF_PARAM (oip, auth_crypt);</a>
<a name="ln560">  UNSET_IF_PARAM (oip, auth_type);</a>
<a name="ln561"> </a>
<a name="ln562">  oip-&gt;auth_crypt = list_new ();</a>
<a name="ln563">  </a>
<a name="ln564">  oip-&gt;network_lsa_seqnum = htonl(OSPF_INITIAL_SEQUENCE_NUMBER);</a>
<a name="ln565"> </a>
<a name="ln566">  return oip;</a>
<a name="ln567">}</a>
<a name="ln568"> </a>
<a name="ln569">void</a>
<a name="ln570">ospf_del_if_params (struct ospf_if_params *oip)</a>
<a name="ln571">{</a>
<a name="ln572">  list_delete (oip-&gt;auth_crypt);</a>
<a name="ln573">  XFREE (MTYPE_OSPF_IF_PARAMS, oip);</a>
<a name="ln574">}</a>
<a name="ln575"> </a>
<a name="ln576">void</a>
<a name="ln577">ospf_free_if_params (struct interface *ifp, struct in_addr addr)</a>
<a name="ln578">{</a>
<a name="ln579">  struct ospf_if_params *oip;</a>
<a name="ln580">  struct prefix_ipv4 p;</a>
<a name="ln581">  struct route_node *rn;</a>
<a name="ln582"> </a>
<a name="ln583">  p.family = AF_INET;</a>
<a name="ln584">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln585">  p.prefix = addr;</a>
<a name="ln586">  rn = route_node_lookup (IF_OIFS_PARAMS (ifp), (struct prefix*)&amp;p);</a>
<a name="ln587">  if (!rn || !rn-&gt;info)</a>
<a name="ln588">    return;</a>
<a name="ln589"> </a>
<a name="ln590">  oip = rn-&gt;info;</a>
<a name="ln591">  route_unlock_node (rn);</a>
<a name="ln592">  </a>
<a name="ln593">  if (!OSPF_IF_PARAM_CONFIGURED (oip, output_cost_cmd) &amp;&amp;</a>
<a name="ln594">      !OSPF_IF_PARAM_CONFIGURED (oip, transmit_delay) &amp;&amp;</a>
<a name="ln595">      !OSPF_IF_PARAM_CONFIGURED (oip, retransmit_interval) &amp;&amp;</a>
<a name="ln596">      !OSPF_IF_PARAM_CONFIGURED (oip, passive_interface) &amp;&amp;</a>
<a name="ln597">      !OSPF_IF_PARAM_CONFIGURED (oip, v_hello) &amp;&amp;</a>
<a name="ln598">      !OSPF_IF_PARAM_CONFIGURED (oip, fast_hello) &amp;&amp;</a>
<a name="ln599">      !OSPF_IF_PARAM_CONFIGURED (oip, v_wait) &amp;&amp;</a>
<a name="ln600">      !OSPF_IF_PARAM_CONFIGURED (oip, priority) &amp;&amp;</a>
<a name="ln601">      !OSPF_IF_PARAM_CONFIGURED (oip, type) &amp;&amp;</a>
<a name="ln602">      !OSPF_IF_PARAM_CONFIGURED (oip, auth_simple) &amp;&amp;</a>
<a name="ln603">      !OSPF_IF_PARAM_CONFIGURED (oip, auth_type) &amp;&amp;</a>
<a name="ln604">      listcount (oip-&gt;auth_crypt) == 0 &amp;&amp;</a>
<a name="ln605">      ntohl (oip-&gt;network_lsa_seqnum) != OSPF_INITIAL_SEQUENCE_NUMBER)</a>
<a name="ln606">    {</a>
<a name="ln607">      ospf_del_if_params (oip);</a>
<a name="ln608">      rn-&gt;info = NULL;</a>
<a name="ln609">      route_unlock_node (rn);</a>
<a name="ln610">    }</a>
<a name="ln611">}</a>
<a name="ln612"> </a>
<a name="ln613">struct ospf_if_params *</a>
<a name="ln614">ospf_lookup_if_params (struct interface *ifp, struct in_addr addr)</a>
<a name="ln615">{</a>
<a name="ln616">  struct prefix_ipv4 p;</a>
<a name="ln617">  struct route_node *rn;</a>
<a name="ln618"> </a>
<a name="ln619">  p.family = AF_INET;</a>
<a name="ln620">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln621">  p.prefix = addr;</a>
<a name="ln622"> </a>
<a name="ln623">  rn = route_node_lookup (IF_OIFS_PARAMS (ifp), (struct prefix*)&amp;p);</a>
<a name="ln624">  </a>
<a name="ln625">  if (rn)</a>
<a name="ln626">    {</a>
<a name="ln627">      route_unlock_node (rn);</a>
<a name="ln628">      return rn-&gt;info;</a>
<a name="ln629">    }</a>
<a name="ln630"> </a>
<a name="ln631">  return NULL;</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">struct ospf_if_params *</a>
<a name="ln635">ospf_get_if_params (struct interface *ifp, struct in_addr addr)</a>
<a name="ln636">{</a>
<a name="ln637">  struct prefix_ipv4 p;</a>
<a name="ln638">  struct route_node *rn;</a>
<a name="ln639"> </a>
<a name="ln640">  p.family = AF_INET;</a>
<a name="ln641">  p.prefixlen = IPV4_MAX_PREFIXLEN;</a>
<a name="ln642">  p.prefix = addr;</a>
<a name="ln643"> </a>
<a name="ln644">  rn = route_node_get (IF_OIFS_PARAMS (ifp), (struct prefix*)&amp;p);</a>
<a name="ln645">  </a>
<a name="ln646">  if (rn-&gt;info == NULL)</a>
<a name="ln647">    rn-&gt;info = ospf_new_if_params ();</a>
<a name="ln648">  else</a>
<a name="ln649">    route_unlock_node (rn);</a>
<a name="ln650">  </a>
<a name="ln651">  return rn-&gt;info;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">void</a>
<a name="ln655">ospf_if_update_params (struct interface *ifp, struct in_addr addr)</a>
<a name="ln656">{</a>
<a name="ln657">  struct route_node *rn;</a>
<a name="ln658">  struct ospf_interface *oi;</a>
<a name="ln659">  </a>
<a name="ln660">  for (rn = route_top (IF_OIFS (ifp)); rn; rn = route_next (rn))</a>
<a name="ln661">    {</a>
<a name="ln662">      if ((oi = rn-&gt;info) == NULL)</a>
<a name="ln663">	continue;</a>
<a name="ln664"> </a>
<a name="ln665">      if (IPV4_ADDR_SAME (&amp;oi-&gt;address-&gt;u.prefix4, &amp;addr))</a>
<a name="ln666">	oi-&gt;params = ospf_lookup_if_params (ifp, oi-&gt;address-&gt;u.prefix4);</a>
<a name="ln667">    }</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">int</a>
<a name="ln671">ospf_if_new_hook (struct interface *ifp)</a>
<a name="ln672">{</a>
<a name="ln673">  int rc = 0;</a>
<a name="ln674"> </a>
<a name="ln675">  ifp-&gt;info = XCALLOC (MTYPE_OSPF_IF_INFO, sizeof (struct ospf_if_info));</a>
<a name="ln676">  </a>
<a name="ln677">  IF_OIFS (ifp) = route_table_init ();</a>
<a name="ln678">  IF_OIFS_PARAMS (ifp) = route_table_init ();</a>
<a name="ln679">  </a>
<a name="ln680">  IF_DEF_PARAMS (ifp) = ospf_new_if_params ();</a>
<a name="ln681">  </a>
<a name="ln682">  SET_IF_PARAM (IF_DEF_PARAMS (ifp), transmit_delay);</a>
<a name="ln683">  IF_DEF_PARAMS (ifp)-&gt;transmit_delay = OSPF_TRANSMIT_DELAY_DEFAULT;</a>
<a name="ln684">  </a>
<a name="ln685">  SET_IF_PARAM (IF_DEF_PARAMS (ifp), retransmit_interval);</a>
<a name="ln686">  IF_DEF_PARAMS (ifp)-&gt;retransmit_interval = OSPF_RETRANSMIT_INTERVAL_DEFAULT;</a>
<a name="ln687"> </a>
<a name="ln688">  SET_IF_PARAM (IF_DEF_PARAMS (ifp), priority);</a>
<a name="ln689">  IF_DEF_PARAMS (ifp)-&gt;priority = OSPF_ROUTER_PRIORITY_DEFAULT;</a>
<a name="ln690"> </a>
<a name="ln691">  IF_DEF_PARAMS (ifp)-&gt;mtu_ignore = OSPF_MTU_IGNORE_DEFAULT;</a>
<a name="ln692"> </a>
<a name="ln693">  SET_IF_PARAM (IF_DEF_PARAMS (ifp), v_hello);</a>
<a name="ln694">  IF_DEF_PARAMS (ifp)-&gt;v_hello = OSPF_HELLO_INTERVAL_DEFAULT;</a>
<a name="ln695"> </a>
<a name="ln696">  SET_IF_PARAM (IF_DEF_PARAMS (ifp), fast_hello);</a>
<a name="ln697">  IF_DEF_PARAMS (ifp)-&gt;fast_hello = OSPF_FAST_HELLO_DEFAULT;</a>
<a name="ln698"> </a>
<a name="ln699">  SET_IF_PARAM (IF_DEF_PARAMS (ifp), v_wait);</a>
<a name="ln700">  IF_DEF_PARAMS (ifp)-&gt;v_wait = OSPF_ROUTER_DEAD_INTERVAL_DEFAULT;</a>
<a name="ln701"> </a>
<a name="ln702">  SET_IF_PARAM (IF_DEF_PARAMS (ifp), auth_simple);</a>
<a name="ln703">  memset (IF_DEF_PARAMS (ifp)-&gt;auth_simple, 0, OSPF_AUTH_SIMPLE_SIZE);</a>
<a name="ln704">  </a>
<a name="ln705">  SET_IF_PARAM (IF_DEF_PARAMS (ifp), auth_type);</a>
<a name="ln706">  IF_DEF_PARAMS (ifp)-&gt;auth_type = OSPF_AUTH_NOTSET;</a>
<a name="ln707">  </a>
<a name="ln708">  rc = ospf_opaque_new_if (ifp);</a>
<a name="ln709">  return rc;</a>
<a name="ln710">}</a>
<a name="ln711"> </a>
<a name="ln712">static int</a>
<a name="ln713">ospf_if_delete_hook (struct interface *ifp)</a>
<a name="ln714">{</a>
<a name="ln715">  int rc = 0;</a>
<a name="ln716">  struct route_node *rn;</a>
<a name="ln717">  rc = ospf_opaque_del_if (ifp);</a>
<a name="ln718"> </a>
<a name="ln719">  route_table_finish (IF_OIFS (ifp));</a>
<a name="ln720"> </a>
<a name="ln721">  for (rn = route_top (IF_OIFS_PARAMS (ifp)); rn; rn = route_next (rn))</a>
<a name="ln722">    if (rn-&gt;info)</a>
<a name="ln723">      ospf_del_if_params (rn-&gt;info);</a>
<a name="ln724">  route_table_finish (IF_OIFS_PARAMS (ifp));</a>
<a name="ln725"> </a>
<a name="ln726">  ospf_del_if_params ((struct ospf_if_params *) IF_DEF_PARAMS (ifp));</a>
<a name="ln727">  XFREE (MTYPE_OSPF_IF_INFO, ifp-&gt;info);</a>
<a name="ln728">  ifp-&gt;info = NULL;</a>
<a name="ln729"> </a>
<a name="ln730">  return rc;</a>
<a name="ln731">}</a>
<a name="ln732"> </a>
<a name="ln733">int</a>
<a name="ln734">ospf_if_is_enable (struct ospf_interface *oi)</a>
<a name="ln735">{</a>
<a name="ln736">  if (!if_is_loopback (oi-&gt;ifp))</a>
<a name="ln737">    if (if_is_up (oi-&gt;ifp))</a>
<a name="ln738">	return 1;</a>
<a name="ln739"> </a>
<a name="ln740">  return 0;</a>
<a name="ln741">}</a>
<a name="ln742"> </a>
<a name="ln743">void</a>
<a name="ln744">ospf_if_set_multicast(struct ospf_interface *oi)</a>
<a name="ln745">{</a>
<a name="ln746">  if ((oi-&gt;state &gt; ISM_Loopback) &amp;&amp;</a>
<a name="ln747">      (oi-&gt;type != OSPF_IFTYPE_LOOPBACK) &amp;&amp;</a>
<a name="ln748">      (oi-&gt;type != OSPF_IFTYPE_VIRTUALLINK) &amp;&amp;</a>
<a name="ln749">      (OSPF_IF_PASSIVE_STATUS(oi) == OSPF_IF_ACTIVE))</a>
<a name="ln750">    {</a>
<a name="ln751">      /* The interface should belong to the OSPF-all-routers group. */</a>
<a name="ln752">      if (!OI_MEMBER_CHECK(oi, MEMBER_ALLROUTERS) &amp;&amp;</a>
<a name="ln753">	  (ospf_if_add_allspfrouters(oi-&gt;ospf, oi-&gt;address,</a>
<a name="ln754">				     oi-&gt;ifp-&gt;ifindex) &gt;= 0))</a>
<a name="ln755">	  /* Set the flag only if the system call to join succeeded. */</a>
<a name="ln756">	  OI_MEMBER_JOINED(oi, MEMBER_ALLROUTERS);</a>
<a name="ln757">    }</a>
<a name="ln758">  else</a>
<a name="ln759">    {</a>
<a name="ln760">      /* The interface should NOT belong to the OSPF-all-routers group. */</a>
<a name="ln761">      if (OI_MEMBER_CHECK(oi, MEMBER_ALLROUTERS))</a>
<a name="ln762">        {</a>
<a name="ln763">          /* Only actually drop if this is the last reference */</a>
<a name="ln764">          if (OI_MEMBER_COUNT(oi, MEMBER_ALLROUTERS) == 1)</a>
<a name="ln765">	    ospf_if_drop_allspfrouters (oi-&gt;ospf, oi-&gt;address,</a>
<a name="ln766">	                                oi-&gt;ifp-&gt;ifindex);</a>
<a name="ln767">	  /* Unset the flag regardless of whether the system call to leave</a>
<a name="ln768">	     the group succeeded, since it's much safer to assume that</a>
<a name="ln769">	     we are not a member. */</a>
<a name="ln770">          OI_MEMBER_LEFT(oi,MEMBER_ALLROUTERS);</a>
<a name="ln771">        }</a>
<a name="ln772">    }</a>
<a name="ln773"> </a>
<a name="ln774">  if (((oi-&gt;type == OSPF_IFTYPE_BROADCAST) ||</a>
<a name="ln775">       (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)) &amp;&amp;</a>
<a name="ln776">      ((oi-&gt;state == ISM_DR) || (oi-&gt;state == ISM_Backup)) &amp;&amp;</a>
<a name="ln777">      (OSPF_IF_PASSIVE_STATUS(oi) == OSPF_IF_ACTIVE))</a>
<a name="ln778">    {</a>
<a name="ln779">      /* The interface should belong to the OSPF-designated-routers group. */</a>
<a name="ln780">      if (!OI_MEMBER_CHECK(oi, MEMBER_DROUTERS) &amp;&amp;</a>
<a name="ln781">	  (ospf_if_add_alldrouters(oi-&gt;ospf, oi-&gt;address,</a>
<a name="ln782">	  			   oi-&gt;ifp-&gt;ifindex) &gt;= 0))</a>
<a name="ln783">	/* Set the flag only if the system call to join succeeded. */</a>
<a name="ln784">	OI_MEMBER_JOINED(oi, MEMBER_DROUTERS);</a>
<a name="ln785">    }</a>
<a name="ln786">  else</a>
<a name="ln787">    {</a>
<a name="ln788">      /* The interface should NOT belong to the OSPF-designated-routers group */</a>
<a name="ln789">      if (OI_MEMBER_CHECK(oi, MEMBER_DROUTERS))</a>
<a name="ln790">        {</a>
<a name="ln791">          /* drop only if last reference */</a>
<a name="ln792">          if (OI_MEMBER_COUNT(oi, MEMBER_DROUTERS) == 1)</a>
<a name="ln793">	    ospf_if_drop_alldrouters(oi-&gt;ospf, oi-&gt;address, oi-&gt;ifp-&gt;ifindex);</a>
<a name="ln794">          </a>
<a name="ln795">	  /* Unset the flag regardless of whether the system call to leave</a>
<a name="ln796">	     the group succeeded, since it's much safer to assume that</a>
<a name="ln797">	     we are not a member. */</a>
<a name="ln798">          OI_MEMBER_LEFT(oi, MEMBER_DROUTERS);</a>
<a name="ln799">        }</a>
<a name="ln800">    }</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803">int</a>
<a name="ln804">ospf_if_up (struct ospf_interface *oi)</a>
<a name="ln805">{</a>
<a name="ln806">  if (oi == NULL)</a>
<a name="ln807">    return 0;</a>
<a name="ln808"> </a>
<a name="ln809">  if (oi-&gt;type == OSPF_IFTYPE_LOOPBACK)</a>
<a name="ln810">    OSPF_ISM_EVENT_SCHEDULE (oi, ISM_LoopInd);</a>
<a name="ln811">  else</a>
<a name="ln812">    {</a>
<a name="ln813">      struct ospf *ospf = ospf_lookup ();</a>
<a name="ln814">      if (ospf != NULL)</a>
<a name="ln815">        ospf_adjust_sndbuflen (ospf, oi-&gt;ifp-&gt;mtu);</a>
<a name="ln816">      else</a>
<a name="ln817">        zlog_warn (&quot;%s: ospf_lookup() returned NULL&quot;, __func__);</a>
<a name="ln818">      ospf_if_stream_set (oi);</a>
<a name="ln819">      OSPF_ISM_EVENT_SCHEDULE (oi, ISM_InterfaceUp);</a>
<a name="ln820">    }</a>
<a name="ln821"> </a>
<a name="ln822">  return 1;</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825">int</a>
<a name="ln826">ospf_if_down (struct ospf_interface *oi)</a>
<a name="ln827">{</a>
<a name="ln828">  if (oi == NULL)</a>
<a name="ln829">    return 0;</a>
<a name="ln830"> </a>
<a name="ln831">  OSPF_ISM_EVENT_EXECUTE (oi, ISM_InterfaceDown);</a>
<a name="ln832">  /* delete position in router LSA */</a>
<a name="ln833">  oi-&gt;lsa_pos_beg = 0;</a>
<a name="ln834">  oi-&gt;lsa_pos_end = 0;</a>
<a name="ln835">  /* Shutdown packet reception and sending */</a>
<a name="ln836">  ospf_if_stream_unset (oi);</a>
<a name="ln837"> </a>
<a name="ln838">  return 1;</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841"> </a>
<a name="ln842">/* Virtual Link related functions. */</a>
<a name="ln843"> </a>
<a name="ln844">struct ospf_vl_data *</a>
<a name="ln845">ospf_vl_data_new (struct ospf_area *area, struct in_addr vl_peer)</a>
<a name="ln846">{</a>
<a name="ln847">  struct ospf_vl_data *vl_data;</a>
<a name="ln848"> </a>
<a name="ln849">  vl_data = XCALLOC (MTYPE_OSPF_VL_DATA, sizeof (struct ospf_vl_data));</a>
<a name="ln850"> </a>
<a name="ln851">  vl_data-&gt;vl_peer.s_addr = vl_peer.s_addr;</a>
<a name="ln852">  vl_data-&gt;vl_area_id = area-&gt;area_id;</a>
<a name="ln853">  vl_data-&gt;format = area-&gt;format;</a>
<a name="ln854"> </a>
<a name="ln855">  return vl_data;</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">void</a>
<a name="ln859">ospf_vl_data_free (struct ospf_vl_data *vl_data)</a>
<a name="ln860">{</a>
<a name="ln861">  XFREE (MTYPE_OSPF_VL_DATA, vl_data);</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">u_int vlink_count = 0;</a>
<a name="ln865"> </a>
<a name="ln866">struct ospf_interface * </a>
<a name="ln867">ospf_vl_new (struct ospf *ospf, struct ospf_vl_data *vl_data)</a>
<a name="ln868">{</a>
<a name="ln869">  struct ospf_interface * voi;</a>
<a name="ln870">  struct interface * vi;</a>
<a name="ln871">  char   ifname[INTERFACE_NAMSIZ + 1];</a>
<a name="ln872">  struct ospf_area *area;</a>
<a name="ln873">  struct in_addr area_id;</a>
<a name="ln874">  struct connected *co;</a>
<a name="ln875">  struct prefix_ipv4 *p;</a>
<a name="ln876">  </a>
<a name="ln877">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln878">    zlog_debug (&quot;ospf_vl_new(): Start&quot;);</a>
<a name="ln879">  if (vlink_count == OSPF_VL_MAX_COUNT)</a>
<a name="ln880">    {</a>
<a name="ln881">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln882">	zlog_debug (&quot;ospf_vl_new(): Alarm: &quot;</a>
<a name="ln883">		   &quot;cannot create more than OSPF_MAX_VL_COUNT virtual links&quot;);</a>
<a name="ln884">      return NULL;</a>
<a name="ln885">    }</a>
<a name="ln886"> </a>
<a name="ln887">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln888">    zlog_debug (&quot;ospf_vl_new(): creating pseudo zebra interface&quot;);</a>
<a name="ln889"> </a>
<a name="ln890">  snprintf (ifname, sizeof(ifname), &quot;VLINK%d&quot;, vlink_count);</a>
<a name="ln891">  vi = if_create (ifname, strnlen(ifname, sizeof(ifname)));</a>
<a name="ln892">  /* Ensure that linkdetection is not enabled on the stub interfaces</a>
<a name="ln893">   * created for OSPF virtual links. */</a>
<a name="ln894">  UNSET_FLAG(vi-&gt;status, ZEBRA_INTERFACE_LINKDETECTION);</a>
<a name="ln895">  co = connected_new ();</a>
<a name="ln896">  co-&gt;ifp = vi;</a>
<a name="ln897">  listnode_add (vi-&gt;connected, co);</a>
<a name="ln898"> </a>
<a name="ln899">  p = prefix_ipv4_new ();</a>
<a name="ln900">  p-&gt;family = AF_INET;</a>
<a name="ln901">  p-&gt;prefix.s_addr = 0;</a>
<a name="ln902">  p-&gt;prefixlen = 0;</a>
<a name="ln903"> </a>
<a name="ln904">  co-&gt;address = (struct prefix *)p;</a>
<a name="ln905">  </a>
<a name="ln906">  voi = ospf_if_new (ospf, vi, co-&gt;address);</a>
<a name="ln907">  if (voi == NULL)</a>
<a name="ln908">    {</a>
<a name="ln909">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln910">	zlog_debug (&quot;ospf_vl_new(): Alarm: OSPF int structure is not created&quot;);</a>
<a name="ln911">      return NULL;</a>
<a name="ln912">    }</a>
<a name="ln913">  voi-&gt;connected = co;</a>
<a name="ln914">  voi-&gt;vl_data = vl_data;</a>
<a name="ln915">  voi-&gt;ifp-&gt;mtu = OSPF_VL_MTU;</a>
<a name="ln916">  voi-&gt;type = OSPF_IFTYPE_VIRTUALLINK;</a>
<a name="ln917"> </a>
<a name="ln918">  vlink_count++;</a>
<a name="ln919">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln920">    zlog_debug (&quot;ospf_vl_new(): Created name: %s&quot;, ifname);</a>
<a name="ln921">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln922">    zlog_debug (&quot;ospf_vl_new(): set if-&gt;name to %s&quot;, vi-&gt;name);</a>
<a name="ln923"> </a>
<a name="ln924">  area_id.s_addr = 0;</a>
<a name="ln925">  area = ospf_area_get (ospf, area_id, OSPF_AREA_ID_FORMAT_ADDRESS);</a>
<a name="ln926">  voi-&gt;area = area;</a>
<a name="ln927"> </a>
<a name="ln928">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln929">    zlog_debug (&quot;ospf_vl_new(): set associated area to the backbone&quot;);</a>
<a name="ln930"> </a>
<a name="ln931">  /* Add pseudo neighbor. */</a>
<a name="ln932">  ospf_nbr_self_reset (voi);</a>
<a name="ln933"> </a>
<a name="ln934">  ospf_area_add_if (voi-&gt;area, voi);</a>
<a name="ln935"> </a>
<a name="ln936">  ospf_if_stream_set (voi);</a>
<a name="ln937"> </a>
<a name="ln938">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln939">    zlog_debug (&quot;ospf_vl_new(): Stop&quot;);</a>
<a name="ln940">  return voi;</a>
<a name="ln941">}</a>
<a name="ln942"> </a>
<a name="ln943">static void</a>
<a name="ln944">ospf_vl_if_delete (struct ospf_vl_data *vl_data)</a>
<a name="ln945">{</a>
<a name="ln946">  struct interface *ifp = vl_data-&gt;vl_oi-&gt;ifp;</a>
<a name="ln947">  vl_data-&gt;vl_oi-&gt;address-&gt;u.prefix4.s_addr = 0;</a>
<a name="ln948">  vl_data-&gt;vl_oi-&gt;address-&gt;prefixlen = 0;</a>
<a name="ln949">  ospf_if_free (vl_data-&gt;vl_oi);</a>
<a name="ln950">  if_delete (ifp);</a>
<a name="ln951">  vlink_count--;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">/* Look up vl_data for given peer, optionally qualified to be in the</a>
<a name="ln955"> * specified area. NULL area returns first found..</a>
<a name="ln956"> */</a>
<a name="ln957">struct ospf_vl_data *</a>
<a name="ln958">ospf_vl_lookup (struct ospf *ospf, struct ospf_area *area,</a>
<a name="ln959">                struct in_addr vl_peer)</a>
<a name="ln960">{</a>
<a name="ln961">  struct ospf_vl_data *vl_data;</a>
<a name="ln962">  struct listnode *node;</a>
<a name="ln963">  </a>
<a name="ln964">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln965">    {</a>
<a name="ln966">      zlog_debug (&quot;%s: Looking for %s&quot;, __func__, inet_ntoa (vl_peer));</a>
<a name="ln967">      if (area)</a>
<a name="ln968">        zlog_debug (&quot;%s: in area %s&quot;, __func__, inet_ntoa (area-&gt;area_id));</a>
<a name="ln969">    }</a>
<a name="ln970">  </a>
<a name="ln971">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;vlinks, node, vl_data))</a>
<a name="ln972">    {</a>
<a name="ln973">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln974">        zlog_debug (&quot;%s: VL %s, peer %s&quot;, __func__,</a>
<a name="ln975">                    vl_data-&gt;vl_oi-&gt;ifp-&gt;name,</a>
<a name="ln976">                    inet_ntoa (vl_data-&gt;vl_peer));</a>
<a name="ln977">      </a>
<a name="ln978">      if (area &amp;&amp; !IPV4_ADDR_SAME (&amp;vl_data-&gt;vl_area_id, &amp;area-&gt;area_id))</a>
<a name="ln979">        continue;</a>
<a name="ln980">      </a>
<a name="ln981">      if (IPV4_ADDR_SAME (&amp;vl_data-&gt;vl_peer, &amp;vl_peer))</a>
<a name="ln982">        return vl_data;</a>
<a name="ln983">    }</a>
<a name="ln984"> </a>
<a name="ln985">  return NULL;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">static void </a>
<a name="ln989">ospf_vl_shutdown (struct ospf_vl_data *vl_data)</a>
<a name="ln990">{</a>
<a name="ln991">  struct ospf_interface *oi;</a>
<a name="ln992"> </a>
<a name="ln993">  if ((oi = vl_data-&gt;vl_oi) == NULL)</a>
<a name="ln994">    return;</a>
<a name="ln995"> </a>
<a name="ln996">  oi-&gt;address-&gt;u.prefix4.s_addr = 0;</a>
<a name="ln997">  oi-&gt;address-&gt;prefixlen = 0;</a>
<a name="ln998"> </a>
<a name="ln999">  UNSET_FLAG (oi-&gt;ifp-&gt;flags, IFF_UP);</a>
<a name="ln1000">  /* OSPF_ISM_EVENT_SCHEDULE (oi, ISM_InterfaceDown); */</a>
<a name="ln1001">  OSPF_ISM_EVENT_EXECUTE (oi, ISM_InterfaceDown);</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>
<a name="ln1004">void</a>
<a name="ln1005">ospf_vl_add (struct ospf *ospf, struct ospf_vl_data *vl_data)</a>
<a name="ln1006">{</a>
<a name="ln1007">  listnode_add (ospf-&gt;vlinks, vl_data);</a>
<a name="ln1008">#ifdef HAVE_SNMP</a>
<a name="ln1009">  ospf_snmp_vl_add (vl_data);</a>
<a name="ln1010">#endif /* HAVE_SNMP */</a>
<a name="ln1011">}</a>
<a name="ln1012"> </a>
<a name="ln1013">void</a>
<a name="ln1014">ospf_vl_delete (struct ospf *ospf, struct ospf_vl_data *vl_data)</a>
<a name="ln1015">{</a>
<a name="ln1016">  ospf_vl_shutdown (vl_data);</a>
<a name="ln1017">  ospf_vl_if_delete (vl_data);</a>
<a name="ln1018"> </a>
<a name="ln1019">#ifdef HAVE_SNMP</a>
<a name="ln1020">  ospf_snmp_vl_delete (vl_data);</a>
<a name="ln1021">#endif /* HAVE_SNMP */</a>
<a name="ln1022">  listnode_delete (ospf-&gt;vlinks, vl_data);</a>
<a name="ln1023"> </a>
<a name="ln1024">  ospf_vl_data_free (vl_data);</a>
<a name="ln1025">}</a>
<a name="ln1026"> </a>
<a name="ln1027">static int</a>
<a name="ln1028">ospf_vl_set_params (struct ospf_vl_data *vl_data, struct vertex *v)</a>
<a name="ln1029">{</a>
<a name="ln1030">  int changed = 0;</a>
<a name="ln1031">  struct ospf_interface *voi;</a>
<a name="ln1032">  struct listnode *node;</a>
<a name="ln1033">  struct vertex_parent *vp = NULL;</a>
<a name="ln1034">  unsigned int i;</a>
<a name="ln1035">  struct router_lsa *rl;</a>
<a name="ln1036"> </a>
<a name="ln1037">  voi = vl_data-&gt;vl_oi;</a>
<a name="ln1038"> </a>
<a name="ln1039">  if (voi-&gt;output_cost != v-&gt;distance)</a>
<a name="ln1040">    {</a>
<a name="ln1041">     </a>
<a name="ln1042">      voi-&gt;output_cost = v-&gt;distance;</a>
<a name="ln1043">      changed = 1;</a>
<a name="ln1044">    }</a>
<a name="ln1045"> </a>
<a name="ln1046">  for (ALL_LIST_ELEMENTS_RO (v-&gt;parents, node, vp))</a>
<a name="ln1047">    {</a>
<a name="ln1048">      vl_data-&gt;nexthop.oi = vp-&gt;nexthop-&gt;oi;</a>
<a name="ln1049">      vl_data-&gt;nexthop.router = vp-&gt;nexthop-&gt;router;</a>
<a name="ln1050">      </a>
<a name="ln1051">      if (!IPV4_ADDR_SAME(&amp;voi-&gt;address-&gt;u.prefix4,</a>
<a name="ln1052">                          &amp;vl_data-&gt;nexthop.oi-&gt;address-&gt;u.prefix4))</a>
<a name="ln1053">        changed = 1;</a>
<a name="ln1054">        </a>
<a name="ln1055">      voi-&gt;address-&gt;u.prefix4 = vl_data-&gt;nexthop.oi-&gt;address-&gt;u.prefix4;</a>
<a name="ln1056">      voi-&gt;address-&gt;prefixlen = vl_data-&gt;nexthop.oi-&gt;address-&gt;prefixlen;</a>
<a name="ln1057"> </a>
<a name="ln1058">      break; /* We take the first interface. */</a>
<a name="ln1059">    }</a>
<a name="ln1060"> </a>
<a name="ln1061">  rl = (struct router_lsa *)v-&gt;lsa;</a>
<a name="ln1062"> </a>
<a name="ln1063">  /* use SPF determined backlink index in struct vertex</a>
<a name="ln1064">   * for virtual link destination address</a>
<a name="ln1065">   */</a>
<a name="ln1066">  if (vp &amp;&amp; vp-&gt;backlink &gt;= 0)</a>
<a name="ln1067">    {</a>
<a name="ln1068">      if (!IPV4_ADDR_SAME (&amp;vl_data-&gt;peer_addr,</a>
<a name="ln1069">                           &amp;rl-&gt;link[vp-&gt;backlink].link_data))</a>
<a name="ln1070">        changed = 1;</a>
<a name="ln1071">      vl_data-&gt;peer_addr = rl-&gt;link[vp-&gt;backlink].link_data;</a>
<a name="ln1072">    }</a>
<a name="ln1073">  else</a>
<a name="ln1074">    {</a>
<a name="ln1075">      /* This is highly odd, there is no backlink index</a>
<a name="ln1076">       * there should be due to the ospf_spf_has_link() check</a>
<a name="ln1077">       * in SPF. Lets warn and try pick a link anyway.</a>
<a name="ln1078">       */</a>
<a name="ln1079">      zlog_warn (&quot;ospf_vl_set_params: No backlink for %s!&quot;,</a>
<a name="ln1080">                 vl_data-&gt;vl_oi-&gt;ifp-&gt;name);</a>
<a name="ln1081">      for (i = 0; i &lt; ntohs (rl-&gt;links); i++)</a>
<a name="ln1082">        {</a>
<a name="ln1083">          switch (rl-&gt;link[i].type)</a>
<a name="ln1084">            {</a>
<a name="ln1085">              case LSA_LINK_TYPE_VIRTUALLINK:</a>
<a name="ln1086">                if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1087">                  zlog_debug (&quot;found back link through VL&quot;);</a>
<a name="ln1088">              case LSA_LINK_TYPE_TRANSIT:</a>
<a name="ln1089">              case LSA_LINK_TYPE_POINTOPOINT:</a>
<a name="ln1090">                if (!IPV4_ADDR_SAME (&amp;vl_data-&gt;peer_addr,</a>
<a name="ln1091">                                     &amp;rl-&gt;link[i].link_data))</a>
<a name="ln1092">                  changed = 1;</a>
<a name="ln1093">                vl_data-&gt;peer_addr = rl-&gt;link[i].link_data;</a>
<a name="ln1094">            }</a>
<a name="ln1095">        }</a>
<a name="ln1096">    }</a>
<a name="ln1097">    </a>
<a name="ln1098">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1099">    zlog_debug (&quot;%s: %s peer address: %s, cost: %d,%schanged&quot;, __func__,</a>
<a name="ln1100">               vl_data-&gt;vl_oi-&gt;ifp-&gt;name,</a>
<a name="ln1101">               inet_ntoa(vl_data-&gt;peer_addr),</a>
<a name="ln1102">               voi-&gt;output_cost,</a>
<a name="ln1103">               (changed ? &quot; &quot; : &quot; un&quot;));</a>
<a name="ln1104">               </a>
<a name="ln1105">  return changed;</a>
<a name="ln1106">}</a>
<a name="ln1107"> </a>
<a name="ln1108"> </a>
<a name="ln1109">void</a>
<a name="ln1110">ospf_vl_up_check (struct ospf_area *area, struct in_addr rid,</a>
<a name="ln1111">                  struct vertex *v)</a>
<a name="ln1112">{</a>
<a name="ln1113">  struct ospf *ospf = area-&gt;ospf;</a>
<a name="ln1114">  struct listnode *node;</a>
<a name="ln1115">  struct ospf_vl_data *vl_data;</a>
<a name="ln1116">  struct ospf_interface *oi;</a>
<a name="ln1117"> </a>
<a name="ln1118">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1119">    {</a>
<a name="ln1120">      zlog_debug (&quot;ospf_vl_up_check(): Start&quot;);</a>
<a name="ln1121">      zlog_debug (&quot;ospf_vl_up_check(): Router ID is %s&quot;, inet_ntoa (rid));</a>
<a name="ln1122">      zlog_debug (&quot;ospf_vl_up_check(): Area is %s&quot;, inet_ntoa (area-&gt;area_id));</a>
<a name="ln1123">    }</a>
<a name="ln1124"> </a>
<a name="ln1125">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;vlinks, node, vl_data))</a>
<a name="ln1126">    {</a>
<a name="ln1127">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1128">	{</a>
<a name="ln1129">	  zlog_debug (&quot;%s: considering VL, %s in area %s&quot;, __func__,</a>
<a name="ln1130">		     vl_data-&gt;vl_oi-&gt;ifp-&gt;name,</a>
<a name="ln1131">		     inet_ntoa (vl_data-&gt;vl_area_id));</a>
<a name="ln1132">	  zlog_debug (&quot;%s: peer ID: %s&quot;, __func__,</a>
<a name="ln1133">		     inet_ntoa (vl_data-&gt;vl_peer));</a>
<a name="ln1134">	}</a>
<a name="ln1135"> </a>
<a name="ln1136">      if (IPV4_ADDR_SAME (&amp;vl_data-&gt;vl_peer, &amp;rid) &amp;&amp;</a>
<a name="ln1137">          IPV4_ADDR_SAME (&amp;vl_data-&gt;vl_area_id, &amp;area-&gt;area_id))</a>
<a name="ln1138">        {</a>
<a name="ln1139">          oi = vl_data-&gt;vl_oi;</a>
<a name="ln1140">          SET_FLAG (vl_data-&gt;flags, OSPF_VL_FLAG_APPROVED);</a>
<a name="ln1141"> </a>
<a name="ln1142">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1143">	    zlog_debug (&quot;ospf_vl_up_check(): this VL matched&quot;);</a>
<a name="ln1144"> </a>
<a name="ln1145">          if (oi-&gt;state == ISM_Down)</a>
<a name="ln1146">            {</a>
<a name="ln1147">	      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1148">		zlog_debug (&quot;ospf_vl_up_check(): VL is down, waking it up&quot;);</a>
<a name="ln1149">              SET_FLAG (oi-&gt;ifp-&gt;flags, IFF_UP);</a>
<a name="ln1150">              OSPF_ISM_EVENT_EXECUTE(oi,ISM_InterfaceUp);</a>
<a name="ln1151">            }</a>
<a name="ln1152"> </a>
<a name="ln1153">         if (ospf_vl_set_params (vl_data, v))</a>
<a name="ln1154">           {</a>
<a name="ln1155">             if (IS_DEBUG_OSPF (ism, ISM_EVENTS))</a>
<a name="ln1156">               zlog_debug (&quot;ospf_vl_up_check: VL cost change,&quot;</a>
<a name="ln1157">                          &quot; scheduling router lsa refresh&quot;);</a>
<a name="ln1158">             if (ospf-&gt;backbone)</a>
<a name="ln1159">               ospf_router_lsa_update_area (ospf-&gt;backbone);</a>
<a name="ln1160">             else if (IS_DEBUG_OSPF (ism, ISM_EVENTS))</a>
<a name="ln1161">               zlog_debug (&quot;ospf_vl_up_check: VL cost change, no backbone!&quot;);</a>
<a name="ln1162">           }</a>
<a name="ln1163">        }</a>
<a name="ln1164">    }</a>
<a name="ln1165">}</a>
<a name="ln1166"> </a>
<a name="ln1167">void</a>
<a name="ln1168">ospf_vl_unapprove (struct ospf *ospf)</a>
<a name="ln1169">{</a>
<a name="ln1170">  struct listnode *node;</a>
<a name="ln1171">  struct ospf_vl_data *vl_data;</a>
<a name="ln1172"> </a>
<a name="ln1173">  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;vlinks, node, vl_data))</a>
<a name="ln1174">    UNSET_FLAG (vl_data-&gt;flags, OSPF_VL_FLAG_APPROVED);</a>
<a name="ln1175">}</a>
<a name="ln1176"> </a>
<a name="ln1177">void</a>
<a name="ln1178">ospf_vl_shut_unapproved (struct ospf *ospf)</a>
<a name="ln1179">{</a>
<a name="ln1180">  struct listnode *node, *nnode;</a>
<a name="ln1181">  struct ospf_vl_data *vl_data;</a>
<a name="ln1182"> </a>
<a name="ln1183">  for (ALL_LIST_ELEMENTS (ospf-&gt;vlinks, node, nnode, vl_data))</a>
<a name="ln1184">    if (!CHECK_FLAG (vl_data-&gt;flags, OSPF_VL_FLAG_APPROVED))</a>
<a name="ln1185">      ospf_vl_shutdown (vl_data);</a>
<a name="ln1186">}</a>
<a name="ln1187"> </a>
<a name="ln1188">int</a>
<a name="ln1189">ospf_full_virtual_nbrs (struct ospf_area *area)</a>
<a name="ln1190">{</a>
<a name="ln1191">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln1192">    {</a>
<a name="ln1193">      zlog_debug (&quot;counting fully adjacent virtual neighbors in area %s&quot;,</a>
<a name="ln1194">		 inet_ntoa (area-&gt;area_id));</a>
<a name="ln1195">      zlog_debug (&quot;there are %d of them&quot;, area-&gt;full_vls);</a>
<a name="ln1196">    }</a>
<a name="ln1197"> </a>
<a name="ln1198">  return area-&gt;full_vls;</a>
<a name="ln1199">}</a>
<a name="ln1200"> </a>
<a name="ln1201">int</a>
<a name="ln1202">ospf_vls_in_area (struct ospf_area *area)</a>
<a name="ln1203">{</a>
<a name="ln1204">  struct listnode *node;</a>
<a name="ln1205">  struct ospf_vl_data *vl_data;</a>
<a name="ln1206">  int c = 0;</a>
<a name="ln1207"> </a>
<a name="ln1208">  for (ALL_LIST_ELEMENTS_RO (area-&gt;ospf-&gt;vlinks, node, vl_data))</a>
<a name="ln1209">    if (IPV4_ADDR_SAME (&amp;vl_data-&gt;vl_area_id, &amp;area-&gt;area_id))</a>
<a name="ln1210">      c++;</a>
<a name="ln1211"> </a>
<a name="ln1212">  return c;</a>
<a name="ln1213">}</a>
<a name="ln1214"> </a>
<a name="ln1215"> </a>
<a name="ln1216">struct crypt_key *</a>
<a name="ln1217">ospf_crypt_key_new ()</a>
<a name="ln1218">{</a>
<a name="ln1219">  return XCALLOC (MTYPE_OSPF_CRYPT_KEY, sizeof (struct crypt_key));</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>
<a name="ln1222">void</a>
<a name="ln1223">ospf_crypt_key_add (struct list *crypt, struct crypt_key *ck)</a>
<a name="ln1224">{</a>
<a name="ln1225">  listnode_add (crypt, ck);</a>
<a name="ln1226">}</a>
<a name="ln1227"> </a>
<a name="ln1228">struct crypt_key *</a>
<a name="ln1229">ospf_crypt_key_lookup (struct list *auth_crypt, u_char key_id)</a>
<a name="ln1230">{</a>
<a name="ln1231">  struct listnode *node;</a>
<a name="ln1232">  struct crypt_key *ck;</a>
<a name="ln1233"> </a>
<a name="ln1234">  for (ALL_LIST_ELEMENTS_RO (auth_crypt, node, ck))</a>
<a name="ln1235">    if (ck-&gt;key_id == key_id)</a>
<a name="ln1236">      return ck;</a>
<a name="ln1237"> </a>
<a name="ln1238">  return NULL;</a>
<a name="ln1239">}</a>
<a name="ln1240"> </a>
<a name="ln1241">int</a>
<a name="ln1242">ospf_crypt_key_delete (struct list *auth_crypt, u_char key_id)</a>
<a name="ln1243">{</a>
<a name="ln1244">  struct listnode *node, *nnode;</a>
<a name="ln1245">  struct crypt_key *ck;</a>
<a name="ln1246"> </a>
<a name="ln1247">  for (ALL_LIST_ELEMENTS (auth_crypt, node, nnode, ck))</a>
<a name="ln1248">    {</a>
<a name="ln1249">      if (ck-&gt;key_id == key_id)</a>
<a name="ln1250">        {</a>
<a name="ln1251">          listnode_delete (auth_crypt, ck);</a>
<a name="ln1252">          XFREE (MTYPE_OSPF_CRYPT_KEY, ck);</a>
<a name="ln1253">          return 1;</a>
<a name="ln1254">        }</a>
<a name="ln1255">    }</a>
<a name="ln1256"> </a>
<a name="ln1257">  return 0;</a>
<a name="ln1258">}</a>
<a name="ln1259"> </a>
<a name="ln1260">u_char</a>
<a name="ln1261">ospf_default_iftype(struct interface *ifp)</a>
<a name="ln1262">{</a>
<a name="ln1263">  if (if_is_pointopoint (ifp))</a>
<a name="ln1264">    return OSPF_IFTYPE_POINTOPOINT;</a>
<a name="ln1265">  else if (if_is_loopback (ifp))</a>
<a name="ln1266">    return OSPF_IFTYPE_LOOPBACK;</a>
<a name="ln1267">  else</a>
<a name="ln1268">    return OSPF_IFTYPE_BROADCAST;</a>
<a name="ln1269">}</a>
<a name="ln1270"> </a>
<a name="ln1271">void</a>
<a name="ln1272">ospf_if_init ()</a>
<a name="ln1273">{</a>
<a name="ln1274">  /* Initialize Zebra interface data structure. */</a>
<a name="ln1275">  om-&gt;iflist = iflist;</a>
<a name="ln1276">  if_add_hook (IF_NEW_HOOK, ospf_if_new_hook);</a>
<a name="ln1277">  if_add_hook (IF_DELETE_HOOK, ospf_if_delete_hook);</a>
<a name="ln1278">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="593"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="594"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="595"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="596"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="597"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="598"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="599"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="600"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="601"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="602"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="603"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v560/" target="_blank">V560</a> A part of conditional expression is always true: (oip).</p></div>
<div class="balloon" rel="703"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v512/" target="_blank">V512</a> A call of the 'memset' function will lead to a buffer underflow.</p></div>
<div class="balloon" rel="1058"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v612/" target="_blank">V612</a> An unconditional 'break' within a loop.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
