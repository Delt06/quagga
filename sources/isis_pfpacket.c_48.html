
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_pfpacket.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol - isis_pfpacket.c</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2001,2002    Sampo Saaristo</a>
<a name="ln5"> *                            Tampere University of Technology      </a>
<a name="ln6"> *                            Institute of Communications Engineering</a>
<a name="ln7"> *</a>
<a name="ln8"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln9"> * under the terms of the GNU General Public Licenseas published by the Free </a>
<a name="ln10"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln11"> * any later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln14"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln15"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln16"> * more details.</a>
<a name="ln17"> </a>
<a name="ln18"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln19"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln20"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24">#if ISIS_METHOD == ISIS_METHOD_PFPACKET</a>
<a name="ln25">#include &lt;net/ethernet.h&gt;	/* the L2 protocols */</a>
<a name="ln26">#include &lt;netpacket/packet.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;log.h&quot;</a>
<a name="ln29">#include &quot;network.h&quot;</a>
<a name="ln30">#include &quot;stream.h&quot;</a>
<a name="ln31">#include &quot;if.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;isisd/dict.h&quot;</a>
<a name="ln34">#include &quot;isisd/include-netbsd/iso.h&quot;</a>
<a name="ln35">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln36">#include &quot;isisd/isis_common.h&quot;</a>
<a name="ln37">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln38">#include &quot;isisd/isis_flags.h&quot;</a>
<a name="ln39">#include &quot;isisd/isisd.h&quot;</a>
<a name="ln40">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln41">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln42">#include &quot;isisd/isis_network.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">#include &quot;privs.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">extern struct zebra_privs_t isisd_privs;</a>
<a name="ln47"> </a>
<a name="ln48">/*</a>
<a name="ln49"> * Table 9 - Architectural constants for use with ISO 8802 subnetworks</a>
<a name="ln50"> * ISO 10589 - 8.4.8</a>
<a name="ln51"> */</a>
<a name="ln52"> </a>
<a name="ln53">u_char ALL_L1_ISS[6] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x14 };</a>
<a name="ln54">u_char ALL_L2_ISS[6] = { 0x01, 0x80, 0xC2, 0x00, 0x00, 0x15 };</a>
<a name="ln55">u_char ALL_ISS[6] = { 0x09, 0x00, 0x2B, 0x00, 0x00, 0x05 };</a>
<a name="ln56">u_char ALL_ESS[6] = { 0x09, 0x00, 0x2B, 0x00, 0x00, 0x04 };</a>
<a name="ln57"> </a>
<a name="ln58">static uint8_t discard_buff[8192];</a>
<a name="ln59">static uint8_t sock_buff[8192];</a>
<a name="ln60"> </a>
<a name="ln61">/*</a>
<a name="ln62"> * if level is 0 we are joining p2p multicast</a>
<a name="ln63"> * FIXME: and the p2p multicast being ???</a>
<a name="ln64"> */</a>
<a name="ln65">static int</a>
<a name="ln66">isis_multicast_join (int fd, int registerto, int if_num)</a>
<a name="ln67">{</a>
<a name="ln68">  struct packet_mreq mreq;</a>
<a name="ln69"> </a>
<a name="ln70">  memset (&amp;mreq, 0, sizeof (mreq));</a>
<a name="ln71">  mreq.mr_ifindex = if_num;</a>
<a name="ln72">  if (registerto)</a>
<a name="ln73">    {</a>
<a name="ln74">      mreq.mr_type = PACKET_MR_MULTICAST;</a>
<a name="ln75">      mreq.mr_alen = ETH_ALEN;</a>
<a name="ln76">      if (registerto == 1)</a>
<a name="ln77">	memcpy (&amp;mreq.mr_address, ALL_L1_ISS, ETH_ALEN);</a>
<a name="ln78">      else if (registerto == 2)</a>
<a name="ln79">	memcpy (&amp;mreq.mr_address, ALL_L2_ISS, ETH_ALEN);</a>
<a name="ln80">      else if (registerto == 3)</a>
<a name="ln81">	memcpy (&amp;mreq.mr_address, ALL_ISS, ETH_ALEN);</a>
<a name="ln82">      else</a>
<a name="ln83">	memcpy (&amp;mreq.mr_address, ALL_ESS, ETH_ALEN);</a>
<a name="ln84"> </a>
<a name="ln85">    }</a>
<a name="ln86">  else</a>
<a name="ln87">    {</a>
<a name="ln88">      mreq.mr_type = PACKET_MR_ALLMULTI;</a>
<a name="ln89">    }</a>
<a name="ln90">#ifdef EXTREME_DEBUG</a>
<a name="ln91">  zlog_debug (&quot;isis_multicast_join(): fd=%d, reg_to=%d, if_num=%d, &quot;</a>
<a name="ln92">	      &quot;address = %02x:%02x:%02x:%02x:%02x:%02x&quot;,</a>
<a name="ln93">	      fd, registerto, if_num, mreq.mr_address[0], mreq.mr_address[1],</a>
<a name="ln94">	      mreq.mr_address[2], mreq.mr_address[3], mreq.mr_address[4],</a>
<a name="ln95">	      mreq.mr_address[5]);</a>
<a name="ln96">#endif /* EXTREME_DEBUG */</a>
<a name="ln97">  if (setsockopt (fd, SOL_PACKET, PACKET_ADD_MEMBERSHIP, &amp;mreq,</a>
<a name="ln98">		  sizeof (struct packet_mreq)))</a>
<a name="ln99">    {</a>
<a name="ln100">      zlog_warn (&quot;isis_multicast_join(): setsockopt(): %s&quot;, safe_strerror (errno));</a>
<a name="ln101">      return ISIS_WARNING;</a>
<a name="ln102">    }</a>
<a name="ln103"> </a>
<a name="ln104">  return ISIS_OK;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">static int</a>
<a name="ln108">open_packet_socket (struct isis_circuit *circuit)</a>
<a name="ln109">{</a>
<a name="ln110">  struct sockaddr_ll s_addr;</a>
<a name="ln111">  int fd, retval = ISIS_OK;</a>
<a name="ln112"> </a>
<a name="ln113">  fd = socket (PF_PACKET, SOCK_DGRAM, htons (ETH_P_ALL));</a>
<a name="ln114">  if (fd &lt; 0)</a>
<a name="ln115">    {</a>
<a name="ln116">      zlog_warn (&quot;open_packet_socket(): socket() failed %s&quot;,</a>
<a name="ln117">		 safe_strerror (errno));</a>
<a name="ln118">      return ISIS_WARNING;</a>
<a name="ln119">    }</a>
<a name="ln120"> </a>
<a name="ln121">  /*</a>
<a name="ln122">   * Bind to the physical interface</a>
<a name="ln123">   */</a>
<a name="ln124">  memset (&amp;s_addr, 0, sizeof (struct sockaddr_ll));</a>
<a name="ln125">  s_addr.sll_family = AF_PACKET;</a>
<a name="ln126">  s_addr.sll_protocol = htons (ETH_P_ALL);</a>
<a name="ln127">  s_addr.sll_ifindex = circuit-&gt;interface-&gt;ifindex;</a>
<a name="ln128"> </a>
<a name="ln129">  if (bind (fd, (struct sockaddr *) (&amp;s_addr),</a>
<a name="ln130">	    sizeof (struct sockaddr_ll)) &lt; 0)</a>
<a name="ln131">    {</a>
<a name="ln132">      zlog_warn (&quot;open_packet_socket(): bind() failed: %s&quot;, safe_strerror (errno));</a>
<a name="ln133">      close (fd);</a>
<a name="ln134">      return ISIS_WARNING;</a>
<a name="ln135">    }</a>
<a name="ln136"> </a>
<a name="ln137">  circuit-&gt;fd = fd;</a>
<a name="ln138"> </a>
<a name="ln139">  if (if_is_broadcast (circuit-&gt;interface))</a>
<a name="ln140">    {</a>
<a name="ln141">      /*</a>
<a name="ln142">       * Join to multicast groups</a>
<a name="ln143">       * according to</a>
<a name="ln144">       * 8.4.2 - Broadcast subnetwork IIH PDUs</a>
<a name="ln145">       * FIXME: is there a case only one will fail??</a>
<a name="ln146">       */</a>
<a name="ln147">      /* joining ALL_L1_ISS */</a>
<a name="ln148">      retval |= isis_multicast_join (circuit-&gt;fd, 1,</a>
<a name="ln149">                                      circuit-&gt;interface-&gt;ifindex);</a>
<a name="ln150">      /* joining ALL_L2_ISS */</a>
<a name="ln151">      retval |= isis_multicast_join (circuit-&gt;fd, 2,</a>
<a name="ln152">                                      circuit-&gt;interface-&gt;ifindex);</a>
<a name="ln153">      /* joining ALL_ISS (used in RFC 5309 p2p-over-lan as well) */</a>
<a name="ln154">      retval |= isis_multicast_join (circuit-&gt;fd, 3,</a>
<a name="ln155">                                    circuit-&gt;interface-&gt;ifindex);</a>
<a name="ln156">    }</a>
<a name="ln157">  else</a>
<a name="ln158">    {</a>
<a name="ln159">      retval =</a>
<a name="ln160">        isis_multicast_join (circuit-&gt;fd, 0, circuit-&gt;interface-&gt;ifindex);</a>
<a name="ln161">    }</a>
<a name="ln162"> </a>
<a name="ln163">  return retval;</a>
<a name="ln164">}</a>
<a name="ln165"> </a>
<a name="ln166">/*</a>
<a name="ln167"> * Create the socket and set the tx/rx funcs</a>
<a name="ln168"> */</a>
<a name="ln169">int</a>
<a name="ln170">isis_sock_init (struct isis_circuit *circuit)</a>
<a name="ln171">{</a>
<a name="ln172">  int retval = ISIS_OK;</a>
<a name="ln173"> </a>
<a name="ln174">  if (isisd_privs.change (ZPRIVS_RAISE))</a>
<a name="ln175">    zlog_err (&quot;%s: could not raise privs, %s&quot;, __func__, safe_strerror (errno));</a>
<a name="ln176"> </a>
<a name="ln177">  retval = open_packet_socket (circuit);</a>
<a name="ln178"> </a>
<a name="ln179">  if (retval != ISIS_OK)</a>
<a name="ln180">    {</a>
<a name="ln181">      zlog_warn (&quot;%s: could not initialize the socket&quot;, __func__);</a>
<a name="ln182">      goto end;</a>
<a name="ln183">    }</a>
<a name="ln184"> </a>
<a name="ln185">  /* Assign Rx and Tx callbacks are based on real if type */</a>
<a name="ln186">  if (if_is_broadcast (circuit-&gt;interface))</a>
<a name="ln187">    {</a>
<a name="ln188">      circuit-&gt;tx = isis_send_pdu_bcast;</a>
<a name="ln189">      circuit-&gt;rx = isis_recv_pdu_bcast;</a>
<a name="ln190">    }</a>
<a name="ln191">  else if (if_is_pointopoint (circuit-&gt;interface))</a>
<a name="ln192">    {</a>
<a name="ln193">      circuit-&gt;tx = isis_send_pdu_p2p;</a>
<a name="ln194">      circuit-&gt;rx = isis_recv_pdu_p2p;</a>
<a name="ln195">    }</a>
<a name="ln196">  else</a>
<a name="ln197">    {</a>
<a name="ln198">      zlog_warn (&quot;isis_sock_init(): unknown circuit type&quot;);</a>
<a name="ln199">      retval = ISIS_WARNING;</a>
<a name="ln200">      goto end;</a>
<a name="ln201">    }</a>
<a name="ln202"> </a>
<a name="ln203">end:</a>
<a name="ln204">  if (isisd_privs.change (ZPRIVS_LOWER))</a>
<a name="ln205">    zlog_err (&quot;%s: could not lower privs, %s&quot;, __func__, safe_strerror (errno));</a>
<a name="ln206"> </a>
<a name="ln207">  return retval;</a>
<a name="ln208">}</a>
<a name="ln209"> </a>
<a name="ln210">static inline int</a>
<a name="ln211">llc_check (u_char * llc)</a>
<a name="ln212">{</a>
<a name="ln213">  if (*llc != ISO_SAP || *(llc + 1) != ISO_SAP || *(llc + 2) != 3)</a>
<a name="ln214">    return 0;</a>
<a name="ln215"> </a>
<a name="ln216">  return 1;</a>
<a name="ln217">}</a>
<a name="ln218"> </a>
<a name="ln219">int</a>
<a name="ln220">isis_recv_pdu_bcast (struct isis_circuit *circuit, u_char * ssnpa)</a>
<a name="ln221">{</a>
<a name="ln222">  int bytesread, addr_len;</a>
<a name="ln223">  struct sockaddr_ll s_addr;</a>
<a name="ln224">  u_char llc[LLC_LEN];</a>
<a name="ln225"> </a>
<a name="ln226">  addr_len = sizeof (s_addr);</a>
<a name="ln227"> </a>
<a name="ln228">  memset (&amp;s_addr, 0, sizeof (struct sockaddr_ll));</a>
<a name="ln229"> </a>
<a name="ln230">  bytesread = recvfrom (circuit-&gt;fd, (void *) &amp;llc,</a>
<a name="ln231">			LLC_LEN, MSG_PEEK,</a>
<a name="ln232">			(struct sockaddr *) &amp;s_addr, (socklen_t *) &amp;addr_len);</a>
<a name="ln233"> </a>
<a name="ln234">  if ((bytesread &lt; 0) || (s_addr.sll_ifindex != (int)circuit-&gt;interface-&gt;ifindex))</a>
<a name="ln235">    {</a>
<a name="ln236">      if (bytesread &lt; 0)</a>
<a name="ln237">        {</a>
<a name="ln238">          zlog_warn (&quot;isis_recv_packet_bcast(): ifname %s, fd %d, &quot;</a>
<a name="ln239">                     &quot;bytesread %d, recvfrom(): %s&quot;,</a>
<a name="ln240">                     circuit-&gt;interface-&gt;name, circuit-&gt;fd, bytesread,</a>
<a name="ln241">                     safe_strerror (errno));</a>
<a name="ln242">        }</a>
<a name="ln243">      if (s_addr.sll_ifindex != (int)circuit-&gt;interface-&gt;ifindex)</a>
<a name="ln244">        {</a>
<a name="ln245">          zlog_warn(&quot;packet is received on multiple interfaces: &quot;</a>
<a name="ln246">                    &quot;socket interface %d, circuit interface %d, &quot;</a>
<a name="ln247">                    &quot;packet type %u&quot;,</a>
<a name="ln248">                    s_addr.sll_ifindex, circuit-&gt;interface-&gt;ifindex,</a>
<a name="ln249">                    s_addr.sll_pkttype);</a>
<a name="ln250">        }</a>
<a name="ln251"> </a>
<a name="ln252">      /* get rid of the packet */</a>
<a name="ln253">      bytesread = recvfrom (circuit-&gt;fd, discard_buff, sizeof (discard_buff),</a>
<a name="ln254">                            MSG_DONTWAIT, (struct sockaddr *) &amp;s_addr,</a>
<a name="ln255">                            (socklen_t *) &amp;addr_len);</a>
<a name="ln256">      return ISIS_WARNING;</a>
<a name="ln257">    }</a>
<a name="ln258">  /*</a>
<a name="ln259">   * Filtering by llc field, discard packets sent by this host (other circuit)</a>
<a name="ln260">   */</a>
<a name="ln261">  if (!llc_check (llc) || s_addr.sll_pkttype == PACKET_OUTGOING)</a>
<a name="ln262">    {</a>
<a name="ln263">      /*  Read the packet into discard buff */</a>
<a name="ln264">      bytesread = recvfrom (circuit-&gt;fd, discard_buff, sizeof (discard_buff),</a>
<a name="ln265">                            MSG_DONTWAIT, (struct sockaddr *) &amp;s_addr,</a>
<a name="ln266">                            (socklen_t *) &amp;addr_len);</a>
<a name="ln267">      if (bytesread &lt; 0)</a>
<a name="ln268">	zlog_warn (&quot;isis_recv_pdu_bcast(): recvfrom() failed&quot;);</a>
<a name="ln269">      return ISIS_WARNING;</a>
<a name="ln270">    }</a>
<a name="ln271"> </a>
<a name="ln272">  /* on lan we have to read to the static buff first */</a>
<a name="ln273">  bytesread = recvfrom (circuit-&gt;fd, sock_buff, sizeof (sock_buff), MSG_DONTWAIT,</a>
<a name="ln274">			(struct sockaddr *) &amp;s_addr, (socklen_t *) &amp;addr_len);</a>
<a name="ln275">  if (bytesread &lt; 0)</a>
<a name="ln276">    {</a>
<a name="ln277">      zlog_warn (&quot;isis_recv_pdu_bcast(): recvfrom() failed&quot;);</a>
<a name="ln278">      return ISIS_WARNING;</a>
<a name="ln279">    }</a>
<a name="ln280"> </a>
<a name="ln281">  /* then we lose the LLC */</a>
<a name="ln282">  stream_write (circuit-&gt;rcv_stream, sock_buff + LLC_LEN, bytesread - LLC_LEN);</a>
<a name="ln283"> </a>
<a name="ln284">  memcpy (ssnpa, &amp;s_addr.sll_addr, s_addr.sll_halen);</a>
<a name="ln285"> </a>
<a name="ln286">  return ISIS_OK;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">int</a>
<a name="ln290">isis_recv_pdu_p2p (struct isis_circuit *circuit, u_char * ssnpa)</a>
<a name="ln291">{</a>
<a name="ln292">  int bytesread, addr_len;</a>
<a name="ln293">  struct sockaddr_ll s_addr;</a>
<a name="ln294"> </a>
<a name="ln295">  memset (&amp;s_addr, 0, sizeof (struct sockaddr_ll));</a>
<a name="ln296">  addr_len = sizeof (s_addr);</a>
<a name="ln297"> </a>
<a name="ln298">  /* we can read directly to the stream */</a>
<a name="ln299">  bytesread = stream_recvfrom (circuit-&gt;rcv_stream, circuit-&gt;fd,</a>
<a name="ln300">                               circuit-&gt;interface-&gt;mtu, 0,</a>
<a name="ln301">                               (struct sockaddr *) &amp;s_addr, </a>
<a name="ln302">                               (socklen_t *) &amp;addr_len);</a>
<a name="ln303"> </a>
<a name="ln304">  if (s_addr.sll_pkttype == PACKET_OUTGOING)</a>
<a name="ln305">    {</a>
<a name="ln306">      /*  Read the packet into discard buff */</a>
<a name="ln307">      bytesread = recvfrom (circuit-&gt;fd, discard_buff, sizeof (discard_buff),</a>
<a name="ln308">                            MSG_DONTWAIT, (struct sockaddr *) &amp;s_addr,</a>
<a name="ln309">                            (socklen_t *) &amp;addr_len);</a>
<a name="ln310">      if (bytesread &lt; 0)</a>
<a name="ln311">	zlog_warn (&quot;isis_recv_pdu_p2p(): recvfrom() failed&quot;);</a>
<a name="ln312">      return ISIS_WARNING;</a>
<a name="ln313">    }</a>
<a name="ln314"> </a>
<a name="ln315">  /* If we don't have protocol type 0x00FE which is</a>
<a name="ln316">   * ISO over GRE we exit with pain :)</a>
<a name="ln317">   */</a>
<a name="ln318">  if (ntohs (s_addr.sll_protocol) != 0x00FE)</a>
<a name="ln319">    {</a>
<a name="ln320">      zlog_warn (&quot;isis_recv_pdu_p2p(): protocol mismatch(): %X&quot;,</a>
<a name="ln321">		 ntohs (s_addr.sll_protocol));</a>
<a name="ln322">      return ISIS_WARNING;</a>
<a name="ln323">    }</a>
<a name="ln324"> </a>
<a name="ln325">  memcpy (ssnpa, &amp;s_addr.sll_addr, s_addr.sll_halen);</a>
<a name="ln326"> </a>
<a name="ln327">  return ISIS_OK;</a>
<a name="ln328">}</a>
<a name="ln329"> </a>
<a name="ln330">int</a>
<a name="ln331">isis_send_pdu_bcast (struct isis_circuit *circuit, int level)</a>
<a name="ln332">{</a>
<a name="ln333">  struct msghdr msg;</a>
<a name="ln334">  struct iovec iov[2];</a>
<a name="ln335"> </a>
<a name="ln336">  /* we need to do the LLC in here because of P2P circuits, which will</a>
<a name="ln337">   * not need it</a>
<a name="ln338">   */</a>
<a name="ln339">  struct sockaddr_ll sa;</a>
<a name="ln340"> </a>
<a name="ln341">  stream_set_getp (circuit-&gt;snd_stream, 0);</a>
<a name="ln342">  memset (&amp;sa, 0, sizeof (struct sockaddr_ll));</a>
<a name="ln343">  sa.sll_family = AF_PACKET;</a>
<a name="ln344">  sa.sll_protocol = htons (stream_get_endp (circuit-&gt;snd_stream) + LLC_LEN);</a>
<a name="ln345">  sa.sll_ifindex = circuit-&gt;interface-&gt;ifindex;</a>
<a name="ln346">  sa.sll_halen = ETH_ALEN;</a>
<a name="ln347">  /* RFC5309 section 4.1 recommends ALL_ISS */</a>
<a name="ln348">  if (circuit-&gt;circ_type == CIRCUIT_T_P2P)</a>
<a name="ln349">    memcpy (&amp;sa.sll_addr, ALL_ISS, ETH_ALEN);</a>
<a name="ln350">  else if (level == 1)</a>
<a name="ln351">    memcpy (&amp;sa.sll_addr, ALL_L1_ISS, ETH_ALEN);</a>
<a name="ln352">  else</a>
<a name="ln353">    memcpy (&amp;sa.sll_addr, ALL_L2_ISS, ETH_ALEN);</a>
<a name="ln354"> </a>
<a name="ln355">  /* on a broadcast circuit */</a>
<a name="ln356">  /* first we put the LLC in */</a>
<a name="ln357">  sock_buff[0] = 0xFE;</a>
<a name="ln358">  sock_buff[1] = 0xFE;</a>
<a name="ln359">  sock_buff[2] = 0x03;</a>
<a name="ln360"> </a>
<a name="ln361">  memset (&amp;msg, 0, sizeof (msg));</a>
<a name="ln362">  msg.msg_name = &amp;sa;</a>
<a name="ln363">  msg.msg_namelen = sizeof (struct sockaddr_ll);</a>
<a name="ln364">  msg.msg_iov = iov;</a>
<a name="ln365">  msg.msg_iovlen = 2;</a>
<a name="ln366">  iov[0].iov_base = sock_buff;</a>
<a name="ln367">  iov[0].iov_len = LLC_LEN;</a>
<a name="ln368">  iov[1].iov_base = circuit-&gt;snd_stream-&gt;data;</a>
<a name="ln369">  iov[1].iov_len = stream_get_endp (circuit-&gt;snd_stream);</a>
<a name="ln370"> </a>
<a name="ln371">  if (sendmsg(circuit-&gt;fd, &amp;msg, 0) &lt; 0)</a>
<a name="ln372">    {</a>
<a name="ln373">      zlog_warn(&quot;IS-IS pfpacket: could not transmit packet on %s: %s&quot;,</a>
<a name="ln374">                circuit-&gt;interface-&gt;name, safe_strerror(errno));</a>
<a name="ln375">      if (ERRNO_IO_RETRY(errno))</a>
<a name="ln376">        return ISIS_WARNING;</a>
<a name="ln377">      return ISIS_ERROR;</a>
<a name="ln378">    }</a>
<a name="ln379">  return ISIS_OK;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">int</a>
<a name="ln383">isis_send_pdu_p2p (struct isis_circuit *circuit, int level)</a>
<a name="ln384">{</a>
<a name="ln385">  struct sockaddr_ll sa;</a>
<a name="ln386">  ssize_t rv;</a>
<a name="ln387"> </a>
<a name="ln388">  stream_set_getp (circuit-&gt;snd_stream, 0);</a>
<a name="ln389">  memset (&amp;sa, 0, sizeof (struct sockaddr_ll));</a>
<a name="ln390">  sa.sll_family = AF_PACKET;</a>
<a name="ln391">  sa.sll_protocol = htons (stream_get_endp (circuit-&gt;snd_stream) + LLC_LEN);</a>
<a name="ln392">  sa.sll_ifindex = circuit-&gt;interface-&gt;ifindex;</a>
<a name="ln393">  sa.sll_halen = ETH_ALEN;</a>
<a name="ln394">  if (level == 1)</a>
<a name="ln395">    memcpy (&amp;sa.sll_addr, ALL_L1_ISS, ETH_ALEN);</a>
<a name="ln396">  else</a>
<a name="ln397">    memcpy (&amp;sa.sll_addr, ALL_L2_ISS, ETH_ALEN);</a>
<a name="ln398"> </a>
<a name="ln399"> </a>
<a name="ln400">  /* lets try correcting the protocol */</a>
<a name="ln401">  sa.sll_protocol = htons (0x00FE);</a>
<a name="ln402">  rv = sendto(circuit-&gt;fd, circuit-&gt;snd_stream-&gt;data,</a>
<a name="ln403">	      stream_get_endp (circuit-&gt;snd_stream), 0,</a>
<a name="ln404">	      (struct sockaddr *) &amp;sa,</a>
<a name="ln405">	      sizeof (struct sockaddr_ll));</a>
<a name="ln406">  if (rv &lt; 0)</a>
<a name="ln407">    {</a>
<a name="ln408">      zlog_warn(&quot;IS-IS pfpacket: could not transmit packet on %s: %s&quot;,</a>
<a name="ln409">                circuit-&gt;interface-&gt;name, safe_strerror(errno));</a>
<a name="ln410">      if (ERRNO_IO_RETRY(errno))</a>
<a name="ln411">        return ISIS_WARNING;</a>
<a name="ln412">      return ISIS_ERROR;</a>
<a name="ln413">    }</a>
<a name="ln414">  return ISIS_OK;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">#endif /* ISIS_METHOD == ISIS_METHOD_PFPACKET */</a>

</code></pre>
<div class="balloon" rel="15"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="129"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& s_addr' buffer is not a multiple of the element size of the type 'struct sockaddr'.</p></div>
<div class="balloon" rel="232"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& s_addr' buffer is not a multiple of the element size of the type 'struct sockaddr'.</p></div>
<div class="balloon" rel="254"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& s_addr' buffer is not a multiple of the element size of the type 'struct sockaddr'.</p></div>
<div class="balloon" rel="253"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1001/" target="_blank">V1001</a> The 'bytesread' variable is assigned but is not used by the end of the function.</p></div>
<div class="balloon" rel="265"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& s_addr' buffer is not a multiple of the element size of the type 'struct sockaddr'.</p></div>
<div class="balloon" rel="274"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& s_addr' buffer is not a multiple of the element size of the type 'struct sockaddr'.</p></div>
<div class="balloon" rel="301"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& s_addr' buffer is not a multiple of the element size of the type 'struct sockaddr'.</p></div>
<div class="balloon" rel="308"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& s_addr' buffer is not a multiple of the element size of the type 'struct sockaddr'.</p></div>
<div class="balloon" rel="404"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v641/" target="_blank">V641</a> The size of the '& sa' buffer is not a multiple of the element size of the type 'struct sockaddr'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
