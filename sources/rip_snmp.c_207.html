
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>rip_snmp.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* RIP SNMP support</a>
<a name="ln2"> * Copyright (C) 1999 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#ifdef HAVE_SNMP</a>
<a name="ln25">#include &lt;net-snmp/net-snmp-config.h&gt;</a>
<a name="ln26">#include &lt;net-snmp/net-snmp-includes.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;if.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;prefix.h&quot;</a>
<a name="ln31">#include &quot;command.h&quot;</a>
<a name="ln32">#include &quot;table.h&quot;</a>
<a name="ln33">#include &quot;smux.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;ripd/ripd.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">/* RIPv2-MIB. */</a>
<a name="ln38">#define RIPV2MIB 1,3,6,1,2,1,23</a>
<a name="ln39"> </a>
<a name="ln40">/* RIPv2-MIB rip2Globals values. */</a>
<a name="ln41">#define RIP2GLOBALROUTECHANGES  1</a>
<a name="ln42">#define RIP2GLOBALQUERIES       2</a>
<a name="ln43"> </a>
<a name="ln44">/* RIPv2-MIB rip2IfStatEntry. */</a>
<a name="ln45">#define RIP2IFSTATENTRY         1</a>
<a name="ln46"> </a>
<a name="ln47">/* RIPv2-MIB rip2IfStatTable. */</a>
<a name="ln48">#define RIP2IFSTATADDRESS       1</a>
<a name="ln49">#define RIP2IFSTATRCVBADPACKETS 2</a>
<a name="ln50">#define RIP2IFSTATRCVBADROUTES  3</a>
<a name="ln51">#define RIP2IFSTATSENTUPDATES   4</a>
<a name="ln52">#define RIP2IFSTATSTATUS        5</a>
<a name="ln53"> </a>
<a name="ln54">/* RIPv2-MIB rip2IfConfTable. */</a>
<a name="ln55">#define RIP2IFCONFADDRESS       1</a>
<a name="ln56">#define RIP2IFCONFDOMAIN        2</a>
<a name="ln57">#define RIP2IFCONFAUTHTYPE      3</a>
<a name="ln58">#define RIP2IFCONFAUTHKEY       4</a>
<a name="ln59">#define RIP2IFCONFSEND          5</a>
<a name="ln60">#define RIP2IFCONFRECEIVE       6</a>
<a name="ln61">#define RIP2IFCONFDEFAULTMETRIC 7</a>
<a name="ln62">#define RIP2IFCONFSTATUS        8</a>
<a name="ln63">#define RIP2IFCONFSRCADDRESS    9</a>
<a name="ln64"> </a>
<a name="ln65">/* RIPv2-MIB rip2PeerTable. */</a>
<a name="ln66">#define RIP2PEERADDRESS         1</a>
<a name="ln67">#define RIP2PEERDOMAIN          2</a>
<a name="ln68">#define RIP2PEERLASTUPDATE      3</a>
<a name="ln69">#define RIP2PEERVERSION         4</a>
<a name="ln70">#define RIP2PEERRCVBADPACKETS   5</a>
<a name="ln71">#define RIP2PEERRCVBADROUTES    6</a>
<a name="ln72"> </a>
<a name="ln73">/* SNMP value hack. */</a>
<a name="ln74">#define COUNTER     ASN_COUNTER</a>
<a name="ln75">#define INTEGER     ASN_INTEGER</a>
<a name="ln76">#define TIMETICKS   ASN_TIMETICKS</a>
<a name="ln77">#define IPADDRESS   ASN_IPADDRESS</a>
<a name="ln78">#define STRING      ASN_OCTET_STR</a>
<a name="ln79"> </a>
<a name="ln80">/* Define SNMP local variables. */</a>
<a name="ln81">SNMP_LOCAL_VARIABLES</a>
<a name="ln82"> </a>
<a name="ln83">/* RIP-MIB instances. */</a>
<a name="ln84">oid rip_oid [] = { RIPV2MIB };</a>
<a name="ln85"> </a>
<a name="ln86">/* Interface cache table sorted by interface's address. */</a>
<a name="ln87">struct route_table *rip_ifaddr_table;</a>
<a name="ln88"> </a>
<a name="ln89">/* Hook functions. */</a>
<a name="ln90">static u_char *rip2Globals (struct variable *, oid [], size_t *,</a>
<a name="ln91">			    int, size_t *, WriteMethod **);</a>
<a name="ln92">static u_char *rip2IfStatEntry (struct variable *, oid [], size_t *,</a>
<a name="ln93">				int, size_t *, WriteMethod **);</a>
<a name="ln94">static u_char *rip2IfConfAddress (struct variable *, oid [], size_t *,</a>
<a name="ln95">				  int, size_t *, WriteMethod **);</a>
<a name="ln96">static u_char *rip2PeerTable (struct variable *, oid [], size_t *,</a>
<a name="ln97">			      int, size_t *, WriteMethod **);</a>
<a name="ln98"> </a>
<a name="ln99">struct variable rip_variables[] = </a>
<a name="ln100">{</a>
<a name="ln101">  /* RIP Global Counters. */</a>
<a name="ln102">  {RIP2GLOBALROUTECHANGES,    COUNTER, RONLY, rip2Globals,</a>
<a name="ln103">   2, {1, 1}},</a>
<a name="ln104">  {RIP2GLOBALQUERIES,         COUNTER, RONLY, rip2Globals,</a>
<a name="ln105">   2, {1, 2}},</a>
<a name="ln106">  /* RIP Interface Tables. */</a>
<a name="ln107">  {RIP2IFSTATADDRESS,         IPADDRESS, RONLY, rip2IfStatEntry,</a>
<a name="ln108">   3, {2, 1, 1}},</a>
<a name="ln109">  {RIP2IFSTATRCVBADPACKETS,   COUNTER, RONLY, rip2IfStatEntry,</a>
<a name="ln110">   3, {2, 1, 2}},</a>
<a name="ln111">  {RIP2IFSTATRCVBADROUTES,    COUNTER, RONLY, rip2IfStatEntry,</a>
<a name="ln112">   3, {2, 1, 3}},</a>
<a name="ln113">  {RIP2IFSTATSENTUPDATES,     COUNTER, RONLY, rip2IfStatEntry,</a>
<a name="ln114">   3, {2, 1, 4}},</a>
<a name="ln115">  {RIP2IFSTATSTATUS,          COUNTER, RWRITE, rip2IfStatEntry,</a>
<a name="ln116">   3, {2, 1, 5}},</a>
<a name="ln117">  {RIP2IFCONFADDRESS,         IPADDRESS, RONLY, rip2IfConfAddress,</a>
<a name="ln118">   /* RIP Interface Configuration Table. */</a>
<a name="ln119">   3, {3, 1, 1}},</a>
<a name="ln120">  {RIP2IFCONFDOMAIN,          STRING, RONLY, rip2IfConfAddress,</a>
<a name="ln121">   3, {3, 1, 2}},</a>
<a name="ln122">  {RIP2IFCONFAUTHTYPE,        COUNTER, RONLY, rip2IfConfAddress,</a>
<a name="ln123">   3, {3, 1, 3}},</a>
<a name="ln124">  {RIP2IFCONFAUTHKEY,         STRING, RONLY, rip2IfConfAddress,</a>
<a name="ln125">   3, {3, 1, 4}},</a>
<a name="ln126">  {RIP2IFCONFSEND,            COUNTER, RONLY, rip2IfConfAddress,</a>
<a name="ln127">   3, {3, 1, 5}},</a>
<a name="ln128">  {RIP2IFCONFRECEIVE,         COUNTER, RONLY, rip2IfConfAddress,</a>
<a name="ln129">   3, {3, 1, 6}},</a>
<a name="ln130">  {RIP2IFCONFDEFAULTMETRIC,   COUNTER, RONLY, rip2IfConfAddress,</a>
<a name="ln131">   3, {3, 1, 7}},</a>
<a name="ln132">  {RIP2IFCONFSTATUS,          COUNTER, RONLY, rip2IfConfAddress,</a>
<a name="ln133">   3, {3, 1, 8}},</a>
<a name="ln134">  {RIP2IFCONFSRCADDRESS,      IPADDRESS, RONLY, rip2IfConfAddress,</a>
<a name="ln135">   3, {3, 1, 9}},</a>
<a name="ln136">  {RIP2PEERADDRESS,           IPADDRESS, RONLY, rip2PeerTable,</a>
<a name="ln137">   /* RIP Peer Table. */</a>
<a name="ln138">   3, {4, 1, 1}},</a>
<a name="ln139">  {RIP2PEERDOMAIN,            STRING, RONLY, rip2PeerTable,</a>
<a name="ln140">   3, {4, 1, 2}},</a>
<a name="ln141">  {RIP2PEERLASTUPDATE,        TIMETICKS, RONLY, rip2PeerTable,</a>
<a name="ln142">   3, {4, 1, 3}},</a>
<a name="ln143">  {RIP2PEERVERSION,           INTEGER, RONLY, rip2PeerTable,</a>
<a name="ln144">   3, {4, 1, 4}},</a>
<a name="ln145">  {RIP2PEERRCVBADPACKETS,     COUNTER, RONLY, rip2PeerTable,</a>
<a name="ln146">   3, {4, 1, 5}},</a>
<a name="ln147">  {RIP2PEERRCVBADROUTES,      COUNTER, RONLY, rip2PeerTable,</a>
<a name="ln148">   3, {4, 1, 6}}</a>
<a name="ln149">};</a>
<a name="ln150"> </a>
<a name="ln151">extern struct thread_master *master;</a>
<a name="ln152"> </a>
<a name="ln153">static u_char *</a>
<a name="ln154">rip2Globals (struct variable *v, oid name[], size_t *length,</a>
<a name="ln155">	     int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln156">{</a>
<a name="ln157">  if (smux_header_generic(v, name, length, exact, var_len, write_method)</a>
<a name="ln158">      == MATCH_FAILED)</a>
<a name="ln159">    return NULL;</a>
<a name="ln160"> </a>
<a name="ln161">  /* Retrun global counter. */</a>
<a name="ln162">  switch (v-&gt;magic)</a>
<a name="ln163">    {</a>
<a name="ln164">    case RIP2GLOBALROUTECHANGES:</a>
<a name="ln165">      return SNMP_INTEGER (rip_global_route_changes);</a>
<a name="ln166">      break;</a>
<a name="ln167">    case RIP2GLOBALQUERIES:</a>
<a name="ln168">      return SNMP_INTEGER (rip_global_queries);</a>
<a name="ln169">      break;</a>
<a name="ln170">    default:</a>
<a name="ln171">      return NULL;</a>
<a name="ln172">      break;</a>
<a name="ln173">    }</a>
<a name="ln174">  return NULL;</a>
<a name="ln175">}</a>
<a name="ln176"> </a>
<a name="ln177">void</a>
<a name="ln178">rip_ifaddr_add (struct interface *ifp, struct connected *ifc)</a>
<a name="ln179">{</a>
<a name="ln180">  struct prefix *p;</a>
<a name="ln181">  struct route_node *rn;</a>
<a name="ln182"> </a>
<a name="ln183">  p = ifc-&gt;address;</a>
<a name="ln184"> </a>
<a name="ln185">  if (p-&gt;family != AF_INET)</a>
<a name="ln186">    return;</a>
<a name="ln187"> </a>
<a name="ln188">  rn = route_node_get (rip_ifaddr_table, p);</a>
<a name="ln189">  rn-&gt;info = ifp;</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">void</a>
<a name="ln193">rip_ifaddr_delete (struct interface *ifp, struct connected *ifc)</a>
<a name="ln194">{</a>
<a name="ln195">  struct prefix *p;</a>
<a name="ln196">  struct route_node *rn;</a>
<a name="ln197">  struct interface *i;</a>
<a name="ln198"> </a>
<a name="ln199">  p = ifc-&gt;address;</a>
<a name="ln200"> </a>
<a name="ln201">  if (p-&gt;family != AF_INET)</a>
<a name="ln202">    return;</a>
<a name="ln203"> </a>
<a name="ln204">  rn = route_node_lookup (rip_ifaddr_table, p);</a>
<a name="ln205">  if (! rn)</a>
<a name="ln206">    return;</a>
<a name="ln207">  i = rn-&gt;info;</a>
<a name="ln208">  if (rn &amp;&amp; !strncmp(i-&gt;name,ifp-&gt;name,INTERFACE_NAMSIZ))</a>
<a name="ln209">    {</a>
<a name="ln210">      rn-&gt;info = NULL;</a>
<a name="ln211">      route_unlock_node (rn);</a>
<a name="ln212">      route_unlock_node (rn);</a>
<a name="ln213">    }</a>
<a name="ln214">}</a>
<a name="ln215"> </a>
<a name="ln216">static struct interface *</a>
<a name="ln217">rip_ifaddr_lookup_next (struct in_addr *addr)</a>
<a name="ln218">{</a>
<a name="ln219">  struct prefix_ipv4 p;</a>
<a name="ln220">  struct route_node *rn;</a>
<a name="ln221">  struct interface *ifp;</a>
<a name="ln222"> </a>
<a name="ln223">  p.family = AF_INET;</a>
<a name="ln224">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln225">  p.prefix = *addr;</a>
<a name="ln226"> </a>
<a name="ln227">  rn = route_node_get (rip_ifaddr_table, (struct prefix *) &amp;p);</a>
<a name="ln228"> </a>
<a name="ln229">  for (rn = route_next (rn); rn; rn = route_next (rn))</a>
<a name="ln230">    if (rn-&gt;info)</a>
<a name="ln231">      break;</a>
<a name="ln232"> </a>
<a name="ln233">  if (rn &amp;&amp; rn-&gt;info)</a>
<a name="ln234">    {</a>
<a name="ln235">      ifp = rn-&gt;info;</a>
<a name="ln236">      *addr = rn-&gt;p.u.prefix4;</a>
<a name="ln237">      route_unlock_node (rn);</a>
<a name="ln238">      return ifp;</a>
<a name="ln239">    }</a>
<a name="ln240">  return NULL;</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">static struct interface *</a>
<a name="ln244">rip2IfLookup (struct variable *v, oid name[], size_t *length, </a>
<a name="ln245">	      struct in_addr *addr, int exact)</a>
<a name="ln246">{</a>
<a name="ln247">  int len;</a>
<a name="ln248">  struct interface *ifp;</a>
<a name="ln249">  </a>
<a name="ln250">  if (exact)</a>
<a name="ln251">    {</a>
<a name="ln252">      /* Check the length. */</a>
<a name="ln253">      if (*length - v-&gt;namelen != sizeof (struct in_addr))</a>
<a name="ln254">	return NULL;</a>
<a name="ln255"> </a>
<a name="ln256">      oid2in_addr (name + v-&gt;namelen, sizeof (struct in_addr), addr);</a>
<a name="ln257"> </a>
<a name="ln258">      return if_lookup_exact_address (*addr);</a>
<a name="ln259">    }</a>
<a name="ln260">  else</a>
<a name="ln261">    {</a>
<a name="ln262">      len = *length - v-&gt;namelen;</a>
<a name="ln263">      if (len &gt; 4) len = 4;</a>
<a name="ln264"> </a>
<a name="ln265">      oid2in_addr (name + v-&gt;namelen, len, addr);</a>
<a name="ln266"> </a>
<a name="ln267">      ifp = rip_ifaddr_lookup_next (addr);</a>
<a name="ln268"> </a>
<a name="ln269">      if (ifp == NULL)</a>
<a name="ln270">	return NULL;</a>
<a name="ln271"> </a>
<a name="ln272">      oid_copy_addr (name + v-&gt;namelen, addr, sizeof (struct in_addr));</a>
<a name="ln273"> </a>
<a name="ln274">      *length = v-&gt;namelen + sizeof (struct in_addr);</a>
<a name="ln275"> </a>
<a name="ln276">      return ifp;</a>
<a name="ln277">    }</a>
<a name="ln278">  return NULL;</a>
<a name="ln279">}</a>
<a name="ln280"> </a>
<a name="ln281">static struct rip_peer *</a>
<a name="ln282">rip2PeerLookup (struct variable *v, oid name[], size_t *length, </a>
<a name="ln283">		struct in_addr *addr, int exact)</a>
<a name="ln284">{</a>
<a name="ln285">  int len;</a>
<a name="ln286">  struct rip_peer *peer;</a>
<a name="ln287">  </a>
<a name="ln288">  if (exact)</a>
<a name="ln289">    {</a>
<a name="ln290">      /* Check the length. */</a>
<a name="ln291">      if (*length - v-&gt;namelen != sizeof (struct in_addr) + 1)</a>
<a name="ln292">	return NULL;</a>
<a name="ln293"> </a>
<a name="ln294">      oid2in_addr (name + v-&gt;namelen, sizeof (struct in_addr), addr);</a>
<a name="ln295"> </a>
<a name="ln296">      peer = rip_peer_lookup (addr);</a>
<a name="ln297"> </a>
<a name="ln298">      if (peer-&gt;domain == (int)name[v-&gt;namelen + sizeof (struct in_addr)])</a>
<a name="ln299">	return peer;</a>
<a name="ln300"> </a>
<a name="ln301">      return NULL;</a>
<a name="ln302">    }</a>
<a name="ln303">  else</a>
<a name="ln304">    {</a>
<a name="ln305">      len = *length - v-&gt;namelen;</a>
<a name="ln306">      if (len &gt; 4) len = 4;</a>
<a name="ln307"> </a>
<a name="ln308">      oid2in_addr (name + v-&gt;namelen, len, addr);</a>
<a name="ln309"> </a>
<a name="ln310">      len = *length - v-&gt;namelen;</a>
<a name="ln311">      peer = rip_peer_lookup (addr);</a>
<a name="ln312">      if (peer)</a>
<a name="ln313">	{</a>
<a name="ln314">	  if ((len &lt; (int)sizeof (struct in_addr) + 1) ||</a>
<a name="ln315">	      (peer-&gt;domain &gt; (int)name[v-&gt;namelen + sizeof (struct in_addr)]))</a>
<a name="ln316">	    {</a>
<a name="ln317">	      oid_copy_addr (name + v-&gt;namelen, &amp;peer-&gt;addr,</a>
<a name="ln318">			     sizeof (struct in_addr));</a>
<a name="ln319">	      name[v-&gt;namelen + sizeof (struct in_addr)] = peer-&gt;domain;</a>
<a name="ln320">	      *length = sizeof (struct in_addr) + v-&gt;namelen + 1;</a>
<a name="ln321">	      return peer;</a>
<a name="ln322">	    }</a>
<a name="ln323">        } </a>
<a name="ln324">      peer = rip_peer_lookup_next (addr);</a>
<a name="ln325"> </a>
<a name="ln326">      if (! peer)</a>
<a name="ln327">	return NULL;</a>
<a name="ln328"> </a>
<a name="ln329">      oid_copy_addr (name + v-&gt;namelen, &amp;peer-&gt;addr,</a>
<a name="ln330">		     sizeof (struct in_addr));</a>
<a name="ln331">      name[v-&gt;namelen + sizeof (struct in_addr)] = peer-&gt;domain;</a>
<a name="ln332">      *length = sizeof (struct in_addr) + v-&gt;namelen + 1;</a>
<a name="ln333"> </a>
<a name="ln334">      return peer;</a>
<a name="ln335">    }</a>
<a name="ln336">  return NULL;</a>
<a name="ln337">}</a>
<a name="ln338"> </a>
<a name="ln339">static u_char *</a>
<a name="ln340">rip2IfStatEntry (struct variable *v, oid name[], size_t *length,</a>
<a name="ln341">	         int exact, size_t *var_len, WriteMethod **write_method)</a>
<a name="ln342">{</a>
<a name="ln343">  struct interface *ifp;</a>
<a name="ln344">  struct rip_interface *ri;</a>
<a name="ln345">  static struct in_addr addr;</a>
<a name="ln346">  static long valid = SNMP_VALID;</a>
<a name="ln347"> </a>
<a name="ln348">  if (smux_header_table(v, name, length, exact, var_len, write_method)</a>
<a name="ln349">      == MATCH_FAILED)</a>
<a name="ln350">    return NULL;</a>
<a name="ln351"> </a>
<a name="ln352">  memset (&amp;addr, 0, sizeof (struct in_addr));</a>
<a name="ln353">  </a>
<a name="ln354">  /* Lookup interface. */</a>
<a name="ln355">  ifp = rip2IfLookup (v, name, length, &amp;addr, exact);</a>
<a name="ln356">  if (! ifp)</a>
<a name="ln357">    return NULL;</a>
<a name="ln358"> </a>
<a name="ln359">  /* Fetch rip_interface information. */</a>
<a name="ln360">  ri = ifp-&gt;info;</a>
<a name="ln361"> </a>
<a name="ln362">  switch (v-&gt;magic)</a>
<a name="ln363">    {</a>
<a name="ln364">    case RIP2IFSTATADDRESS:</a>
<a name="ln365">      return SNMP_IPADDRESS (addr);</a>
<a name="ln366">      break;</a>
<a name="ln367">    case RIP2IFSTATRCVBADPACKETS:</a>
<a name="ln368">      *var_len = sizeof (long);</a>
<a name="ln369">      return (u_char *) &amp;ri-&gt;recv_badpackets;</a>
<a name="ln370"> </a>
<a name="ln371">    case RIP2IFSTATRCVBADROUTES:</a>
<a name="ln372">      *var_len = sizeof (long);</a>
<a name="ln373">      return (u_char *) &amp;ri-&gt;recv_badroutes;</a>
<a name="ln374"> </a>
<a name="ln375">    case RIP2IFSTATSENTUPDATES:</a>
<a name="ln376">      *var_len = sizeof (long);</a>
<a name="ln377">      return (u_char *) &amp;ri-&gt;sent_updates;</a>
<a name="ln378"> </a>
<a name="ln379">    case RIP2IFSTATSTATUS:</a>
<a name="ln380">      *var_len = sizeof (long);</a>
<a name="ln381">      v-&gt;type = ASN_INTEGER;</a>
<a name="ln382">      return (u_char *) &amp;valid;</a>
<a name="ln383"> </a>
<a name="ln384">    default:</a>
<a name="ln385">      return NULL;</a>
<a name="ln386"> </a>
<a name="ln387">    }</a>
<a name="ln388">  return NULL;</a>
<a name="ln389">}</a>
<a name="ln390"> </a>
<a name="ln391">static long</a>
<a name="ln392">rip2IfConfSend (struct rip_interface *ri)</a>
<a name="ln393">{</a>
<a name="ln394">#define doNotSend       1</a>
<a name="ln395">#define ripVersion1     2</a>
<a name="ln396">#define rip1Compatible  3</a>
<a name="ln397">#define ripVersion2     4</a>
<a name="ln398">#define ripV1Demand     5</a>
<a name="ln399">#define ripV2Demand     6</a>
<a name="ln400"> </a>
<a name="ln401">  if (! ri-&gt;running)</a>
<a name="ln402">    return doNotSend;</a>
<a name="ln403">    </a>
<a name="ln404">  if (ri-&gt;ri_send &amp; RIPv2)</a>
<a name="ln405">    return ripVersion2;</a>
<a name="ln406">  else if (ri-&gt;ri_send &amp; RIPv1)</a>
<a name="ln407">    return ripVersion1;</a>
<a name="ln408">  else if (rip)</a>
<a name="ln409">    {</a>
<a name="ln410">      if (rip-&gt;version_send == RIPv2)</a>
<a name="ln411">	return ripVersion2;</a>
<a name="ln412">      else if (rip-&gt;version_send == RIPv1)</a>
<a name="ln413">	return ripVersion1;</a>
<a name="ln414">    }</a>
<a name="ln415">  return doNotSend;</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">static long</a>
<a name="ln419">rip2IfConfReceive (struct rip_interface *ri)</a>
<a name="ln420">{</a>
<a name="ln421">#define rip1            1</a>
<a name="ln422">#define rip2            2</a>
<a name="ln423">#define rip1OrRip2      3</a>
<a name="ln424">#define doNotReceive    4</a>
<a name="ln425"> </a>
<a name="ln426">  int recvv;</a>
<a name="ln427"> </a>
<a name="ln428">  if (! ri-&gt;running)</a>
<a name="ln429">    return doNotReceive;</a>
<a name="ln430"> </a>
<a name="ln431">  recvv = (ri-&gt;ri_receive == RI_RIP_UNSPEC) ?  rip-&gt;version_recv :</a>
<a name="ln432">                                               ri-&gt;ri_receive;</a>
<a name="ln433">  if (recvv == RI_RIP_VERSION_1_AND_2)</a>
<a name="ln434">    return rip1OrRip2;</a>
<a name="ln435">  else if (recvv &amp; RIPv2)</a>
<a name="ln436">    return rip2;</a>
<a name="ln437">  else if (recvv &amp; RIPv1)</a>
<a name="ln438">    return rip1;</a>
<a name="ln439">  else</a>
<a name="ln440">    return doNotReceive;</a>
<a name="ln441">}</a>
<a name="ln442"> </a>
<a name="ln443">static u_char *</a>
<a name="ln444">rip2IfConfAddress (struct variable *v, oid name[], size_t *length,</a>
<a name="ln445">	           int exact, size_t *val_len, WriteMethod **write_method)</a>
<a name="ln446">{</a>
<a name="ln447">  static struct in_addr addr;</a>
<a name="ln448">  static long valid = SNMP_INVALID;</a>
<a name="ln449">  static long domain = 0;</a>
<a name="ln450">  static long config = 0;</a>
<a name="ln451">  static u_int auth = 0;</a>
<a name="ln452">  struct interface *ifp;</a>
<a name="ln453">  struct rip_interface *ri;</a>
<a name="ln454"> </a>
<a name="ln455">  if (smux_header_table(v, name, length, exact, val_len, write_method)</a>
<a name="ln456">      == MATCH_FAILED)</a>
<a name="ln457">    return NULL;</a>
<a name="ln458"> </a>
<a name="ln459">  memset (&amp;addr, 0, sizeof (struct in_addr));</a>
<a name="ln460">  </a>
<a name="ln461">  /* Lookup interface. */</a>
<a name="ln462">  ifp = rip2IfLookup (v, name, length, &amp;addr, exact);</a>
<a name="ln463">  if (! ifp)</a>
<a name="ln464">    return NULL;</a>
<a name="ln465"> </a>
<a name="ln466">  /* Fetch rip_interface information. */</a>
<a name="ln467">  ri = ifp-&gt;info;</a>
<a name="ln468"> </a>
<a name="ln469">  switch (v-&gt;magic)</a>
<a name="ln470">    {</a>
<a name="ln471">    case RIP2IFCONFADDRESS:</a>
<a name="ln472">      *val_len = sizeof (struct in_addr);</a>
<a name="ln473">      return (u_char *) &amp;addr;</a>
<a name="ln474"> </a>
<a name="ln475">    case RIP2IFCONFDOMAIN:</a>
<a name="ln476">      *val_len = 2;</a>
<a name="ln477">      return (u_char *) &amp;domain;</a>
<a name="ln478"> </a>
<a name="ln479">    case RIP2IFCONFAUTHTYPE:</a>
<a name="ln480">      auth = ri-&gt;auth_type;</a>
<a name="ln481">      *val_len = sizeof (long);</a>
<a name="ln482">      v-&gt;type = ASN_INTEGER;</a>
<a name="ln483">      return (u_char *)&amp;auth;</a>
<a name="ln484"> </a>
<a name="ln485">    case RIP2IFCONFAUTHKEY:</a>
<a name="ln486">      *val_len = 0;</a>
<a name="ln487">      return (u_char *) &amp;domain;</a>
<a name="ln488">    case RIP2IFCONFSEND:</a>
<a name="ln489">      config = rip2IfConfSend (ri);</a>
<a name="ln490">      *val_len = sizeof (long);</a>
<a name="ln491">      v-&gt;type = ASN_INTEGER;</a>
<a name="ln492">      return (u_char *) &amp;config;</a>
<a name="ln493">    case RIP2IFCONFRECEIVE:</a>
<a name="ln494">      config = rip2IfConfReceive (ri);</a>
<a name="ln495">      *val_len = sizeof (long);</a>
<a name="ln496">      v-&gt;type = ASN_INTEGER;</a>
<a name="ln497">      return (u_char *) &amp;config;</a>
<a name="ln498"> </a>
<a name="ln499">    case RIP2IFCONFDEFAULTMETRIC:</a>
<a name="ln500">      *val_len = sizeof (long);</a>
<a name="ln501">      v-&gt;type = ASN_INTEGER;</a>
<a name="ln502">      return (u_char *) &amp;ifp-&gt;metric;</a>
<a name="ln503">    case RIP2IFCONFSTATUS:</a>
<a name="ln504">      *val_len = sizeof (long);</a>
<a name="ln505">      v-&gt;type = ASN_INTEGER;</a>
<a name="ln506">      return (u_char *) &amp;valid;</a>
<a name="ln507">    case RIP2IFCONFSRCADDRESS:</a>
<a name="ln508">      *val_len = sizeof (struct in_addr);</a>
<a name="ln509">      return (u_char *) &amp;addr;</a>
<a name="ln510"> </a>
<a name="ln511">    default:</a>
<a name="ln512">      return NULL;</a>
<a name="ln513"> </a>
<a name="ln514">    }</a>
<a name="ln515">  return NULL;</a>
<a name="ln516">}</a>
<a name="ln517"> </a>
<a name="ln518">static u_char *</a>
<a name="ln519">rip2PeerTable (struct variable *v, oid name[], size_t *length,</a>
<a name="ln520">	       int exact, size_t *val_len, WriteMethod **write_method)</a>
<a name="ln521">{</a>
<a name="ln522">  static struct in_addr addr;</a>
<a name="ln523">  static int domain = 0;</a>
<a name="ln524">  static int version;</a>
<a name="ln525">  /* static time_t uptime; */</a>
<a name="ln526"> </a>
<a name="ln527">  struct rip_peer *peer;</a>
<a name="ln528"> </a>
<a name="ln529">  if (smux_header_table(v, name, length, exact, val_len, write_method)</a>
<a name="ln530">      == MATCH_FAILED)</a>
<a name="ln531">    return NULL;</a>
<a name="ln532"> </a>
<a name="ln533">  memset (&amp;addr, 0, sizeof (struct in_addr));</a>
<a name="ln534">  </a>
<a name="ln535">  /* Lookup interface. */</a>
<a name="ln536">  peer = rip2PeerLookup (v, name, length, &amp;addr, exact);</a>
<a name="ln537">  if (! peer)</a>
<a name="ln538">    return NULL;</a>
<a name="ln539"> </a>
<a name="ln540">  switch (v-&gt;magic)</a>
<a name="ln541">    {</a>
<a name="ln542">    case RIP2PEERADDRESS:</a>
<a name="ln543">      *val_len = sizeof (struct in_addr);</a>
<a name="ln544">      return (u_char *) &amp;peer-&gt;addr;</a>
<a name="ln545"> </a>
<a name="ln546">    case RIP2PEERDOMAIN:</a>
<a name="ln547">      *val_len = 2;</a>
<a name="ln548">      return (u_char *) &amp;domain;</a>
<a name="ln549"> </a>
<a name="ln550">    case RIP2PEERLASTUPDATE:</a>
<a name="ln551">#if 0 </a>
<a name="ln552">      /* We don't know the SNMP agent startup time. We have two choices here:</a>
<a name="ln553">       * - assume ripd startup time equals SNMP agent startup time</a>
<a name="ln554">       * - don't support this variable, at all</a>
<a name="ln555">       * Currently, we do the latter...</a>
<a name="ln556">       */</a>
<a name="ln557">      *val_len = sizeof (time_t);</a>
<a name="ln558">      uptime = peer-&gt;uptime; /* now - snmp_agent_startup - peer-&gt;uptime */</a>
<a name="ln559">      return (u_char *) &amp;uptime;</a>
<a name="ln560">#else</a>
<a name="ln561">      return (u_char *) NULL;</a>
<a name="ln562">#endif</a>
<a name="ln563"> </a>
<a name="ln564">    case RIP2PEERVERSION:</a>
<a name="ln565">      *val_len = sizeof (int);</a>
<a name="ln566">      version = peer-&gt;version;</a>
<a name="ln567">      return (u_char *) &amp;version;</a>
<a name="ln568"> </a>
<a name="ln569">    case RIP2PEERRCVBADPACKETS:</a>
<a name="ln570">      *val_len = sizeof (int);</a>
<a name="ln571">      return (u_char *) &amp;peer-&gt;recv_badpackets;</a>
<a name="ln572"> </a>
<a name="ln573">    case RIP2PEERRCVBADROUTES:</a>
<a name="ln574">      *val_len = sizeof (int);</a>
<a name="ln575">      return (u_char *) &amp;peer-&gt;recv_badroutes;</a>
<a name="ln576"> </a>
<a name="ln577">    default:</a>
<a name="ln578">      return NULL;</a>
<a name="ln579"> </a>
<a name="ln580">    }</a>
<a name="ln581">  return NULL;</a>
<a name="ln582">}</a>
<a name="ln583"> </a>
<a name="ln584">/* Register RIPv2-MIB. */</a>
<a name="ln585">void</a>
<a name="ln586">rip_snmp_init ()</a>
<a name="ln587">{</a>
<a name="ln588">  rip_ifaddr_table = route_table_init ();</a>
<a name="ln589"> </a>
<a name="ln590">  smux_init (master);</a>
<a name="ln591">  REGISTER_MIB(&quot;mibII/rip&quot;, rip_variables, variable, rip_oid);</a>
<a name="ln592">}</a>
<a name="ln593">#endif /* HAVE_SNMP */</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
