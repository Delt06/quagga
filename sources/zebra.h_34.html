
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>zebra.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Zebra common header.</a>
<a name="ln2">   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#ifndef _ZEBRA_H</a>
<a name="ln22">#define _ZEBRA_H</a>
<a name="ln23"> </a>
<a name="ln24">#ifdef HAVE_CONFIG_H</a>
<a name="ln25">#include &quot;config.h&quot;</a>
<a name="ln26">#endif /* HAVE_CONFIG_H */</a>
<a name="ln27"> </a>
<a name="ln28">#ifdef SUNOS_5</a>
<a name="ln29">#define _XPG4_2</a>
<a name="ln30">typedef unsigned int    u_int32_t;</a>
<a name="ln31">typedef unsigned short  u_int16_t;</a>
<a name="ln32">typedef unsigned char   u_int8_t;</a>
<a name="ln33">#endif /* SUNOS_5 */</a>
<a name="ln34"> </a>
<a name="ln35">#ifndef HAVE_SOCKLEN_T</a>
<a name="ln36">typedef int socklen_t;</a>
<a name="ln37">#endif /* HAVE_SOCKLEN_T */</a>
<a name="ln38"> </a>
<a name="ln39">#include &lt;unistd.h&gt;</a>
<a name="ln40">#include &lt;stdio.h&gt;</a>
<a name="ln41">#include &lt;stdlib.h&gt;</a>
<a name="ln42">#include &lt;stddef.h&gt;</a>
<a name="ln43">#include &lt;ctype.h&gt;</a>
<a name="ln44">#include &lt;errno.h&gt;</a>
<a name="ln45">#include &lt;fcntl.h&gt;</a>
<a name="ln46">#include &lt;signal.h&gt;</a>
<a name="ln47">#include &lt;string.h&gt;</a>
<a name="ln48">#include &lt;pwd.h&gt;</a>
<a name="ln49">#include &lt;grp.h&gt;</a>
<a name="ln50">#ifdef HAVE_STROPTS_H</a>
<a name="ln51">#include &lt;stropts.h&gt;</a>
<a name="ln52">#endif /* HAVE_STROPTS_H */</a>
<a name="ln53">#ifdef HAVE_SYS_SELECT_H</a>
<a name="ln54">#include &lt;sys/select.h&gt;</a>
<a name="ln55">#endif /* HAVE_SYS_SELECT_H */</a>
<a name="ln56">#include &lt;sys/stat.h&gt;</a>
<a name="ln57">#include &lt;sys/types.h&gt;</a>
<a name="ln58">#include &lt;sys/param.h&gt;</a>
<a name="ln59">#ifdef HAVE_SYS_SYSCTL_H</a>
<a name="ln60">#ifdef GNU_LINUX</a>
<a name="ln61">#include &lt;linux/types.h&gt;</a>
<a name="ln62">#endif</a>
<a name="ln63">#include &lt;sys/sysctl.h&gt;</a>
<a name="ln64">#endif /* HAVE_SYS_SYSCTL_H */</a>
<a name="ln65">#include &lt;sys/ioctl.h&gt;</a>
<a name="ln66">#ifdef HAVE_SYS_CONF_H</a>
<a name="ln67">#include &lt;sys/conf.h&gt;</a>
<a name="ln68">#endif /* HAVE_SYS_CONF_H */</a>
<a name="ln69">#ifdef HAVE_SYS_KSYM_H</a>
<a name="ln70">#include &lt;sys/ksym.h&gt;</a>
<a name="ln71">#endif /* HAVE_SYS_KSYM_H */</a>
<a name="ln72">#include &lt;syslog.h&gt;</a>
<a name="ln73">#ifdef TIME_WITH_SYS_TIME</a>
<a name="ln74"># include &lt;sys/time.h&gt;</a>
<a name="ln75"># include &lt;time.h&gt;</a>
<a name="ln76">#else</a>
<a name="ln77"># ifdef HAVE_SYS_TIME_H</a>
<a name="ln78">#  include &lt;sys/time.h&gt;</a>
<a name="ln79"># else</a>
<a name="ln80">#  include &lt;time.h&gt;</a>
<a name="ln81"># endif</a>
<a name="ln82">#endif /* TIME_WITH_SYS_TIME */</a>
<a name="ln83">#include &lt;sys/uio.h&gt;</a>
<a name="ln84">#include &lt;sys/utsname.h&gt;</a>
<a name="ln85">#ifdef HAVE_RUSAGE</a>
<a name="ln86">#include &lt;sys/resource.h&gt;</a>
<a name="ln87">#endif /* HAVE_RUSAGE */</a>
<a name="ln88">#ifdef HAVE_LIMITS_H</a>
<a name="ln89">#include &lt;limits.h&gt;</a>
<a name="ln90">#endif /* HAVE_LIMITS_H */</a>
<a name="ln91">#ifdef HAVE_INTTYPES_H</a>
<a name="ln92">#include &lt;inttypes.h&gt;</a>
<a name="ln93">#endif /* HAVE_INTTYPES_H */</a>
<a name="ln94">#ifdef HAVE_STDBOOL_H</a>
<a name="ln95">#include &lt;stdbool.h&gt;</a>
<a name="ln96">#endif</a>
<a name="ln97">/* primarily for __STDC_IEC_559__ with clang */</a>
<a name="ln98">#ifdef HAVE_FEATURES_H</a>
<a name="ln99">#include &lt;features.h&gt;</a>
<a name="ln100">#endif</a>
<a name="ln101"> </a>
<a name="ln102">/* machine dependent includes */</a>
<a name="ln103">#ifdef SUNOS_5</a>
<a name="ln104">#include &lt;strings.h&gt;</a>
<a name="ln105">#endif /* SUNOS_5 */</a>
<a name="ln106"> </a>
<a name="ln107">/* machine dependent includes */</a>
<a name="ln108">#ifdef HAVE_LINUX_VERSION_H</a>
<a name="ln109">#include &lt;linux/version.h&gt;</a>
<a name="ln110">#endif /* HAVE_LINUX_VERSION_H */</a>
<a name="ln111"> </a>
<a name="ln112">#ifdef HAVE_ASM_TYPES_H</a>
<a name="ln113">#include &lt;asm/types.h&gt;</a>
<a name="ln114">#endif /* HAVE_ASM_TYPES_H */</a>
<a name="ln115"> </a>
<a name="ln116">/* misc include group */</a>
<a name="ln117">#include &lt;stdarg.h&gt;</a>
<a name="ln118">#if !(defined(__STDC_VERSION__) &amp;&amp; __STDC_VERSION__ &gt;= 199901L)</a>
<a name="ln119">/* Not C99; do we need to define va_copy? */</a>
<a name="ln120">#ifndef va_copy</a>
<a name="ln121">#ifdef __va_copy</a>
<a name="ln122">#define va_copy(DST,SRC) __va_copy(DST,SRC)</a>
<a name="ln123">#else</a>
<a name="ln124">/* Now we are desperate; this should work on many typical platforms. </a>
<a name="ln125">   But this is slightly dangerous, because the standard does not require</a>
<a name="ln126">   va_copy to be a macro. */</a>
<a name="ln127">#define va_copy(DST,SRC) memcpy(&amp;(DST), &amp;(SRC), sizeof(va_list))</a>
<a name="ln128">#warning &quot;Not C99 and no va_copy macro available, falling back to memcpy&quot;</a>
<a name="ln129">#endif /* __va_copy */</a>
<a name="ln130">#endif /* !va_copy */</a>
<a name="ln131">#endif /* !C99 */</a>
<a name="ln132"> </a>
<a name="ln133"> </a>
<a name="ln134">#ifdef HAVE_LCAPS</a>
<a name="ln135">#include &lt;sys/capability.h&gt;</a>
<a name="ln136">#include &lt;sys/prctl.h&gt;</a>
<a name="ln137">#endif /* HAVE_LCAPS */</a>
<a name="ln138"> </a>
<a name="ln139">#ifdef HAVE_SOLARIS_CAPABILITIES</a>
<a name="ln140">#include &lt;priv.h&gt;</a>
<a name="ln141">#endif /* HAVE_SOLARIS_CAPABILITIES */</a>
<a name="ln142"> </a>
<a name="ln143">/* network include group */</a>
<a name="ln144"> </a>
<a name="ln145">#include &lt;sys/socket.h&gt;</a>
<a name="ln146"> </a>
<a name="ln147">#ifdef HAVE_SYS_SOCKIO_H</a>
<a name="ln148">#include &lt;sys/sockio.h&gt;</a>
<a name="ln149">#endif /* HAVE_SYS_SOCKIO_H */</a>
<a name="ln150"> </a>
<a name="ln151">#ifdef __APPLE__</a>
<a name="ln152">#define __APPLE_USE_RFC_3542</a>
<a name="ln153">#endif</a>
<a name="ln154"> </a>
<a name="ln155">#ifdef HAVE_NETINET_IN_H</a>
<a name="ln156">#include &lt;netinet/in.h&gt;</a>
<a name="ln157">#endif /* HAVE_NETINET_IN_H */</a>
<a name="ln158">#include &lt;netinet/in_systm.h&gt;</a>
<a name="ln159">#include &lt;netinet/ip.h&gt;</a>
<a name="ln160">#include &lt;netinet/tcp.h&gt;</a>
<a name="ln161"> </a>
<a name="ln162">#ifdef HAVE_NET_NETOPT_H</a>
<a name="ln163">#include &lt;net/netopt.h&gt;</a>
<a name="ln164">#endif /* HAVE_NET_NETOPT_H */</a>
<a name="ln165"> </a>
<a name="ln166">#include &lt;net/if.h&gt;</a>
<a name="ln167"> </a>
<a name="ln168">#ifdef HAVE_NET_IF_DL_H</a>
<a name="ln169">#include &lt;net/if_dl.h&gt;</a>
<a name="ln170">#endif /* HAVE_NET_IF_DL_H */</a>
<a name="ln171"> </a>
<a name="ln172">#ifdef HAVE_NET_IF_VAR_H</a>
<a name="ln173">#include &lt;net/if_var.h&gt;</a>
<a name="ln174">#endif /* HAVE_NET_IF_VAR_H */</a>
<a name="ln175"> </a>
<a name="ln176">#ifdef HAVE_NET_ROUTE_H</a>
<a name="ln177">#include &lt;net/route.h&gt;</a>
<a name="ln178">#endif /* HAVE_NET_ROUTE_H */</a>
<a name="ln179"> </a>
<a name="ln180">#ifdef HAVE_NETLINK</a>
<a name="ln181">#include &lt;linux/netlink.h&gt;</a>
<a name="ln182">#include &lt;linux/rtnetlink.h&gt;</a>
<a name="ln183">#include &lt;linux/filter.h&gt;</a>
<a name="ln184">#else</a>
<a name="ln185">#define RT_TABLE_MAIN		0</a>
<a name="ln186">#endif /* HAVE_NETLINK */</a>
<a name="ln187"> </a>
<a name="ln188">#ifdef HAVE_NETDB_H</a>
<a name="ln189">#include &lt;netdb.h&gt;</a>
<a name="ln190">#endif /* HAVE_NETDB_H */</a>
<a name="ln191"> </a>
<a name="ln192">#include &lt;arpa/inet.h&gt;</a>
<a name="ln193"> </a>
<a name="ln194">#ifdef HAVE_INET_ND_H</a>
<a name="ln195">#include &lt;inet/nd.h&gt;</a>
<a name="ln196">#endif /* HAVE_INET_ND_H */</a>
<a name="ln197"> </a>
<a name="ln198">#ifdef HAVE_NETINET_IN_VAR_H</a>
<a name="ln199">#include &lt;netinet/in_var.h&gt;</a>
<a name="ln200">#endif /* HAVE_NETINET_IN_VAR_H */</a>
<a name="ln201"> </a>
<a name="ln202">#ifdef HAVE_NETINET6_IN6_VAR_H</a>
<a name="ln203">#include &lt;netinet6/in6_var.h&gt;</a>
<a name="ln204">#endif /* HAVE_NETINET6_IN6_VAR_H */</a>
<a name="ln205"> </a>
<a name="ln206">#ifdef HAVE_NETINET_IN6_VAR_H</a>
<a name="ln207">#include &lt;netinet/in6_var.h&gt;</a>
<a name="ln208">#endif /* HAVE_NETINET_IN6_VAR_H */</a>
<a name="ln209"> </a>
<a name="ln210">#ifdef HAVE_NETINET6_IN_H</a>
<a name="ln211">#include &lt;netinet6/in.h&gt;</a>
<a name="ln212">#endif /* HAVE_NETINET6_IN_H */</a>
<a name="ln213"> </a>
<a name="ln214"> </a>
<a name="ln215">#ifdef HAVE_NETINET6_IP6_H</a>
<a name="ln216">#include &lt;netinet6/ip6.h&gt;</a>
<a name="ln217">#endif /* HAVE_NETINET6_IP6_H */</a>
<a name="ln218"> </a>
<a name="ln219">#ifdef HAVE_NETINET_ICMP6_H</a>
<a name="ln220">#include &lt;netinet/icmp6.h&gt;</a>
<a name="ln221">#endif /* HAVE_NETINET_ICMP6_H */</a>
<a name="ln222"> </a>
<a name="ln223">#ifdef HAVE_NETINET6_ND6_H</a>
<a name="ln224">#include &lt;netinet6/nd6.h&gt;</a>
<a name="ln225">#endif /* HAVE_NETINET6_ND6_H */</a>
<a name="ln226"> </a>
<a name="ln227">/* Some systems do not define UINT32_MAX, etc.. from inttypes.h</a>
<a name="ln228"> * e.g. this makes life easier for FBSD 4.11 users.</a>
<a name="ln229"> */</a>
<a name="ln230">#ifndef INT8_MAX</a>
<a name="ln231">#define INT8_MAX	(127)</a>
<a name="ln232">#endif</a>
<a name="ln233">#ifndef INT16_MAX</a>
<a name="ln234">#define INT16_MAX	(32767)</a>
<a name="ln235">#endif</a>
<a name="ln236">#ifndef INT32_MAX</a>
<a name="ln237">#define INT32_MAX	(2147483647)</a>
<a name="ln238">#endif</a>
<a name="ln239">#ifndef UINT8_MAX</a>
<a name="ln240">#define UINT8_MAX	(255U)</a>
<a name="ln241">#endif</a>
<a name="ln242">#ifndef UINT16_MAX</a>
<a name="ln243">#define UINT16_MAX	(65535U)</a>
<a name="ln244">#endif</a>
<a name="ln245">#ifndef UINT32_MAX</a>
<a name="ln246">#define UINT32_MAX	(4294967295U)</a>
<a name="ln247">#endif</a>
<a name="ln248"> </a>
<a name="ln249">#ifdef HAVE_GLIBC_BACKTRACE</a>
<a name="ln250">#include &lt;execinfo.h&gt;</a>
<a name="ln251">#endif /* HAVE_GLIBC_BACKTRACE */</a>
<a name="ln252"> </a>
<a name="ln253">/* Local includes: */</a>
<a name="ln254">#if !(defined(__GNUC__) || defined(VTYSH_EXTRACT_PL)) </a>
<a name="ln255">#define __attribute__(x)</a>
<a name="ln256">#endif  /* !__GNUC__ || VTYSH_EXTRACT_PL */</a>
<a name="ln257"> </a>
<a name="ln258">#include &quot;zassert.h&quot;</a>
<a name="ln259">#include &quot;str.h&quot;</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">#ifdef HAVE_BROKEN_CMSG_FIRSTHDR</a>
<a name="ln263">/* This bug is present in Solaris 8 and pre-patch Solaris 9 &lt;sys/socket.h&gt;;</a>
<a name="ln264">   please refer to http://bugzilla.quagga.net/show_bug.cgi?id=142 */</a>
<a name="ln265"> </a>
<a name="ln266">/* Check that msg_controllen is large enough. */</a>
<a name="ln267">#define ZCMSG_FIRSTHDR(mhdr) \</a>
<a name="ln268">  (((size_t)((mhdr)-&gt;msg_controllen) &gt;= sizeof(struct cmsghdr)) ? \</a>
<a name="ln269">   CMSG_FIRSTHDR(mhdr) : (struct cmsghdr *)NULL)</a>
<a name="ln270"> </a>
<a name="ln271">#warning &quot;CMSG_FIRSTHDR is broken on this platform, using a workaround&quot;</a>
<a name="ln272"> </a>
<a name="ln273">#else /* HAVE_BROKEN_CMSG_FIRSTHDR */</a>
<a name="ln274">#define ZCMSG_FIRSTHDR(M) CMSG_FIRSTHDR(M)</a>
<a name="ln275">#endif /* HAVE_BROKEN_CMSG_FIRSTHDR */</a>
<a name="ln276"> </a>
<a name="ln277"> </a>
<a name="ln278"> </a>
<a name="ln279">/* </a>
<a name="ln280"> * RFC 3542 defines several macros for using struct cmsghdr.</a>
<a name="ln281"> * Here, we define those that are not present</a>
<a name="ln282"> */</a>
<a name="ln283"> </a>
<a name="ln284">/*</a>
<a name="ln285"> * Internal defines, for use only in this file.</a>
<a name="ln286"> * These are likely wrong on other than ILP32 machines, so warn.</a>
<a name="ln287"> */</a>
<a name="ln288">#ifndef _CMSG_DATA_ALIGN</a>
<a name="ln289">#define _CMSG_DATA_ALIGN(n)           (((n) + 3) &amp; ~3)</a>
<a name="ln290">#endif /* _CMSG_DATA_ALIGN */</a>
<a name="ln291"> </a>
<a name="ln292">#ifndef _CMSG_HDR_ALIGN</a>
<a name="ln293">#define _CMSG_HDR_ALIGN(n)            (((n) + 3) &amp; ~3)</a>
<a name="ln294">#endif /* _CMSG_HDR_ALIGN */</a>
<a name="ln295"> </a>
<a name="ln296">/*</a>
<a name="ln297"> * CMSG_SPACE and CMSG_LEN are required in RFC3542, but were new in that</a>
<a name="ln298"> * version.</a>
<a name="ln299"> */</a>
<a name="ln300">#ifndef CMSG_SPACE</a>
<a name="ln301">#define CMSG_SPACE(l)       (_CMSG_DATA_ALIGN(sizeof(struct cmsghdr)) + \</a>
<a name="ln302">                              _CMSG_HDR_ALIGN(l))</a>
<a name="ln303">#warning &quot;assuming 4-byte alignment for CMSG_SPACE&quot;</a>
<a name="ln304">#endif  /* CMSG_SPACE */</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">#ifndef CMSG_LEN</a>
<a name="ln308">#define CMSG_LEN(l)         (_CMSG_DATA_ALIGN(sizeof(struct cmsghdr)) + (l))</a>
<a name="ln309">#warning &quot;assuming 4-byte alignment for CMSG_LEN&quot;</a>
<a name="ln310">#endif /* CMSG_LEN */</a>
<a name="ln311"> </a>
<a name="ln312"> </a>
<a name="ln313">/*  The definition of struct in_pktinfo is missing in old version of</a>
<a name="ln314">    GLIBC 2.1 (Redhat 6.1).  */</a>
<a name="ln315">#if defined (GNU_LINUX) &amp;&amp; ! defined (HAVE_STRUCT_IN_PKTINFO)</a>
<a name="ln316">struct in_pktinfo</a>
<a name="ln317">{</a>
<a name="ln318">  int ipi_ifindex;</a>
<a name="ln319">  struct in_addr ipi_spec_dst;</a>
<a name="ln320">  struct in_addr ipi_addr;</a>
<a name="ln321">};</a>
<a name="ln322">#endif</a>
<a name="ln323"> </a>
<a name="ln324">/* </a>
<a name="ln325"> * OSPF Fragmentation / fragmented writes</a>
<a name="ln326"> *</a>
<a name="ln327"> * ospfd can support writing fragmented packets, for cases where</a>
<a name="ln328"> * kernel will not fragment IP_HDRINCL and/or multicast destined</a>
<a name="ln329"> * packets (ie TTBOMK all kernels, BSD, SunOS, Linux). However,</a>
<a name="ln330"> * SunOS, probably BSD too, clobber the user supplied IP ID and IP</a>
<a name="ln331"> * flags fields, hence user-space fragmentation will not work.</a>
<a name="ln332"> * Only Linux is known to leave IP header unmolested.</a>
<a name="ln333"> * Further, fragmentation really should be done the kernel, which already</a>
<a name="ln334"> * supports it, and which avoids nasty IP ID state problems.</a>
<a name="ln335"> *</a>
<a name="ln336"> * Fragmentation of OSPF packets can be required on networks with router</a>
<a name="ln337"> * with many many interfaces active in one area, or on networks with links</a>
<a name="ln338"> * with low MTUs.</a>
<a name="ln339"> */</a>
<a name="ln340">#ifdef GNU_LINUX</a>
<a name="ln341">#define WANT_OSPF_WRITE_FRAGMENT</a>
<a name="ln342">#endif</a>
<a name="ln343"> </a>
<a name="ln344">/* </a>
<a name="ln345"> * IP_HDRINCL / struct ip byte order</a>
<a name="ln346"> *</a>
<a name="ln347"> * Linux: network byte order</a>
<a name="ln348"> * *BSD: network, except for length and offset. (cf Stevens)</a>
<a name="ln349"> * SunOS: nominally as per BSD. but bug: network order on LE.</a>
<a name="ln350"> * OpenBSD: network byte order, apart from older versions which are as per </a>
<a name="ln351"> *          *BSD</a>
<a name="ln352"> */</a>
<a name="ln353">#if defined(__NetBSD__) \</a>
<a name="ln354">   || (defined(__FreeBSD__) &amp;&amp; (__FreeBSD_version &lt; 1100030)) \</a>
<a name="ln355">   || (defined(__OpenBSD__) &amp;&amp; (OpenBSD &lt; 200311)) \</a>
<a name="ln356">   || (defined(__APPLE__)) \</a>
<a name="ln357">   || (defined(SUNOS_5) &amp;&amp; defined(WORDS_BIGENDIAN))</a>
<a name="ln358">#define HAVE_IP_HDRINCL_BSD_ORDER</a>
<a name="ln359">#endif</a>
<a name="ln360"> </a>
<a name="ln361">/* Define BYTE_ORDER, if not defined. Useful for compiler conditional</a>
<a name="ln362"> * code, rather than preprocessor conditional.</a>
<a name="ln363"> * Not all the world has this BSD define.</a>
<a name="ln364"> */</a>
<a name="ln365">#ifndef BYTE_ORDER</a>
<a name="ln366">#define BIG_ENDIAN	4321	/* least-significant byte first (vax, pc) */</a>
<a name="ln367">#define LITTLE_ENDIAN	1234	/* most-significant byte first (IBM, net) */</a>
<a name="ln368">#define PDP_ENDIAN	3412	/* LSB first in word, MSW first in long (pdp) */</a>
<a name="ln369"> </a>
<a name="ln370">#if defined(WORDS_BIGENDIAN)</a>
<a name="ln371">#define BYTE_ORDER	BIG_ENDIAN</a>
<a name="ln372">#else /* !WORDS_BIGENDIAN */</a>
<a name="ln373">#define BYTE_ORDER	LITTLE_ENDIAN</a>
<a name="ln374">#endif /* WORDS_BIGENDIAN */</a>
<a name="ln375"> </a>
<a name="ln376">#endif /* ndef BYTE_ORDER */</a>
<a name="ln377"> </a>
<a name="ln378">/* MAX / MIN are not commonly defined, but useful */</a>
<a name="ln379">#ifndef MAX</a>
<a name="ln380">#define MAX(a, b) \</a>
<a name="ln381">	({ typeof (a) _a = (a); \</a>
<a name="ln382">	   typeof (b) _b = (b); \</a>
<a name="ln383">	   _a &gt; _b ? _a : _b; })</a>
<a name="ln384">#endif</a>
<a name="ln385">#ifndef MIN</a>
<a name="ln386">#define MIN(a, b) \</a>
<a name="ln387">	({ typeof (a) _a = (a); \</a>
<a name="ln388">	   typeof (b) _b = (b); \</a>
<a name="ln389">	   _a &lt; _b ? _a : _b; })</a>
<a name="ln390">#endif</a>
<a name="ln391"> </a>
<a name="ln392">#define ZEBRA_NUM_OF(x) (sizeof (x) / sizeof (x[0]))</a>
<a name="ln393"> </a>
<a name="ln394">/* For old definition. */</a>
<a name="ln395">#ifndef IN6_ARE_ADDR_EQUAL</a>
<a name="ln396">#define IN6_ARE_ADDR_EQUAL IN6_IS_ADDR_EQUAL</a>
<a name="ln397">#endif /* IN6_ARE_ADDR_EQUAL */</a>
<a name="ln398"> </a>
<a name="ln399">/* default zebra TCP port for zclient */</a>
<a name="ln400">#define ZEBRA_PORT			2600</a>
<a name="ln401"> </a>
<a name="ln402">/* Zebra message types. */</a>
<a name="ln403">#define ZEBRA_INTERFACE_ADD                1</a>
<a name="ln404">#define ZEBRA_INTERFACE_DELETE             2</a>
<a name="ln405">#define ZEBRA_INTERFACE_ADDRESS_ADD        3</a>
<a name="ln406">#define ZEBRA_INTERFACE_ADDRESS_DELETE     4</a>
<a name="ln407">#define ZEBRA_INTERFACE_UP                 5</a>
<a name="ln408">#define ZEBRA_INTERFACE_DOWN               6</a>
<a name="ln409">#define ZEBRA_IPV4_ROUTE_ADD               7</a>
<a name="ln410">#define ZEBRA_IPV4_ROUTE_DELETE            8</a>
<a name="ln411">#define ZEBRA_IPV6_ROUTE_ADD               9</a>
<a name="ln412">#define ZEBRA_IPV6_ROUTE_DELETE           10</a>
<a name="ln413">#define ZEBRA_REDISTRIBUTE_ADD            11</a>
<a name="ln414">#define ZEBRA_REDISTRIBUTE_DELETE         12</a>
<a name="ln415">#define ZEBRA_REDISTRIBUTE_DEFAULT_ADD    13</a>
<a name="ln416">#define ZEBRA_REDISTRIBUTE_DEFAULT_DELETE 14</a>
<a name="ln417">#define ZEBRA_IPV4_NEXTHOP_LOOKUP         15</a>
<a name="ln418">#define ZEBRA_IPV6_NEXTHOP_LOOKUP         16</a>
<a name="ln419">#define ZEBRA_IPV4_IMPORT_LOOKUP          17</a>
<a name="ln420">#define ZEBRA_IPV6_IMPORT_LOOKUP          18</a>
<a name="ln421">#define ZEBRA_INTERFACE_RENAME            19</a>
<a name="ln422">#define ZEBRA_ROUTER_ID_ADD               20</a>
<a name="ln423">#define ZEBRA_ROUTER_ID_DELETE            21</a>
<a name="ln424">#define ZEBRA_ROUTER_ID_UPDATE            22</a>
<a name="ln425">#define ZEBRA_HELLO                       23</a>
<a name="ln426">#define ZEBRA_IPV4_NEXTHOP_LOOKUP_MRIB    24</a>
<a name="ln427">#define ZEBRA_VRF_UNREGISTER              25</a>
<a name="ln428">#define ZEBRA_INTERFACE_LINK_PARAMS       26</a>
<a name="ln429">#define ZEBRA_NEXTHOP_REGISTER            27</a>
<a name="ln430">#define ZEBRA_NEXTHOP_UNREGISTER          28</a>
<a name="ln431">#define ZEBRA_NEXTHOP_UPDATE              29</a>
<a name="ln432">#define ZEBRA_MESSAGE_MAX                 30</a>
<a name="ln433"> </a>
<a name="ln434">/* Marker value used in new Zserv, in the byte location corresponding</a>
<a name="ln435"> * the command value in the old zserv header. To allow old and new</a>
<a name="ln436"> * Zserv headers to be distinguished from each other.</a>
<a name="ln437"> */</a>
<a name="ln438">#define ZEBRA_HEADER_MARKER              255</a>
<a name="ln439"> </a>
<a name="ln440">/* Zebra route's types are defined in route_types.h */</a>
<a name="ln441">#include &quot;route_types.h&quot;</a>
<a name="ln442"> </a>
<a name="ln443">/* Note: whenever a new route-type or zserv-command is added the</a>
<a name="ln444"> * corresponding {command,route}_types[] table in lib/log.c MUST be</a>
<a name="ln445"> * updated! */</a>
<a name="ln446"> </a>
<a name="ln447">/* Map a route type to a string.  For example, ZEBRA_ROUTE_RIPNG -&gt; &quot;ripng&quot;. */</a>
<a name="ln448">extern const char *zebra_route_string(unsigned int route_type);</a>
<a name="ln449">/* Map a route type to a char.  For example, ZEBRA_ROUTE_RIPNG -&gt; 'R'. */</a>
<a name="ln450">extern char zebra_route_char(unsigned int route_type);</a>
<a name="ln451">/* Map a zserv command type to the same string, </a>
<a name="ln452"> * e.g. ZEBRA_INTERFACE_ADD -&gt; &quot;ZEBRA_INTERFACE_ADD&quot; */</a>
<a name="ln453">/* Map a protocol name to its number. e.g. ZEBRA_ROUTE_BGP-&gt;9*/</a>
<a name="ln454">extern int proto_name2num(const char *s);</a>
<a name="ln455">/* Map redistribute X argument to protocol number.</a>
<a name="ln456"> * unlike proto_name2num, this accepts shorthands and takes</a>
<a name="ln457"> * an AFI value to restrict input */</a>
<a name="ln458">extern int proto_redistnum(int afi, const char *s);</a>
<a name="ln459"> </a>
<a name="ln460">extern const char *zserv_command_string (unsigned int command);</a>
<a name="ln461"> </a>
<a name="ln462">/* Error codes of zebra. */</a>
<a name="ln463">#define ZEBRA_ERR_NOERROR                0</a>
<a name="ln464">#define ZEBRA_ERR_RTEXIST               -1</a>
<a name="ln465">#define ZEBRA_ERR_RTUNREACH             -2</a>
<a name="ln466">#define ZEBRA_ERR_EPERM                 -3</a>
<a name="ln467">#define ZEBRA_ERR_RTNOEXIST             -4</a>
<a name="ln468">#define ZEBRA_ERR_KERNEL                -5</a>
<a name="ln469"> </a>
<a name="ln470">/* Zebra message flags */</a>
<a name="ln471">#define ZEBRA_FLAG_INTERNAL           0x01</a>
<a name="ln472">#define ZEBRA_FLAG_SELFROUTE          0x02</a>
<a name="ln473">#define ZEBRA_FLAG_BLACKHOLE          0x04</a>
<a name="ln474">#define ZEBRA_FLAG_IBGP               0x08</a>
<a name="ln475">#define ZEBRA_FLAG_SELECTED           0x10</a>
<a name="ln476">#define ZEBRA_FLAG_FIB_OVERRIDE       0x20</a>
<a name="ln477">#define ZEBRA_FLAG_STATIC             0x40</a>
<a name="ln478">#define ZEBRA_FLAG_REJECT             0x80</a>
<a name="ln479"> </a>
<a name="ln480">/* Zebra nexthop flags. */</a>
<a name="ln481">#define ZEBRA_NEXTHOP_IFINDEX            1</a>
<a name="ln482">#define ZEBRA_NEXTHOP_IFNAME             2</a>
<a name="ln483">#define ZEBRA_NEXTHOP_IPV4               3</a>
<a name="ln484">#define ZEBRA_NEXTHOP_IPV4_IFINDEX       4</a>
<a name="ln485">#define ZEBRA_NEXTHOP_IPV4_IFNAME        5</a>
<a name="ln486">#define ZEBRA_NEXTHOP_IPV6               6</a>
<a name="ln487">#define ZEBRA_NEXTHOP_IPV6_IFINDEX       7</a>
<a name="ln488">#define ZEBRA_NEXTHOP_IPV6_IFNAME        8</a>
<a name="ln489">#define ZEBRA_NEXTHOP_BLACKHOLE          9</a>
<a name="ln490"> </a>
<a name="ln491">#ifndef INADDR_LOOPBACK</a>
<a name="ln492">#define	INADDR_LOOPBACK	0x7f000001	/* Internet address 127.0.0.1.  */</a>
<a name="ln493">#endif</a>
<a name="ln494"> </a>
<a name="ln495">/* Address family numbers from RFC1700. */</a>
<a name="ln496">typedef enum {</a>
<a name="ln497">  AFI_IP  = 1,</a>
<a name="ln498">  AFI_IP6 = 2,</a>
<a name="ln499">  AFI_ETHER = 3,                /* RFC 1700 has &quot;6&quot; for 802.* */</a>
<a name="ln500">#define AFI_MAX 4</a>
<a name="ln501">} afi_t;</a>
<a name="ln502"> </a>
<a name="ln503">/* Subsequent Address Family Identifier. */</a>
<a name="ln504">#define SAFI_UNICAST              1</a>
<a name="ln505">#define SAFI_MULTICAST            2</a>
<a name="ln506">#define SAFI_RESERVED_3           3</a>
<a name="ln507">#define SAFI_MPLS_VPN             4</a>
<a name="ln508">#define SAFI_ENCAP		  7 /* per IANA */</a>
<a name="ln509">#define SAFI_MAX                  8</a>
<a name="ln510"> </a>
<a name="ln511">/* Default Administrative Distance of each protocol. */</a>
<a name="ln512">#define ZEBRA_KERNEL_DISTANCE_DEFAULT      0</a>
<a name="ln513">#define ZEBRA_CONNECT_DISTANCE_DEFAULT     0</a>
<a name="ln514">#define ZEBRA_STATIC_DISTANCE_DEFAULT      1</a>
<a name="ln515">#define ZEBRA_RIP_DISTANCE_DEFAULT       120</a>
<a name="ln516">#define ZEBRA_RIPNG_DISTANCE_DEFAULT     120</a>
<a name="ln517">#define ZEBRA_OSPF_DISTANCE_DEFAULT      110</a>
<a name="ln518">#define ZEBRA_OSPF6_DISTANCE_DEFAULT     110</a>
<a name="ln519">#define ZEBRA_ISIS_DISTANCE_DEFAULT      115</a>
<a name="ln520">#define ZEBRA_IBGP_DISTANCE_DEFAULT      200</a>
<a name="ln521">#define ZEBRA_EBGP_DISTANCE_DEFAULT       20</a>
<a name="ln522"> </a>
<a name="ln523">/* Flag manipulation macros. */</a>
<a name="ln524">#define CHECK_FLAG(V,F)      ((V) &amp; (F))</a>
<a name="ln525">#define SET_FLAG(V,F)        (V) |= (F)</a>
<a name="ln526">#define UNSET_FLAG(V,F)      (V) &amp;= ~(F)</a>
<a name="ln527">#define RESET_FLAG(V)        (V) = 0</a>
<a name="ln528"> </a>
<a name="ln529">typedef u_int8_t safi_t;</a>
<a name="ln530"> </a>
<a name="ln531">/* Zebra types. Used in Zserv message header. */</a>
<a name="ln532">typedef u_int16_t zebra_size_t;</a>
<a name="ln533">typedef u_int16_t zebra_command_t;</a>
<a name="ln534"> </a>
<a name="ln535">/* VRF ID type. */</a>
<a name="ln536">typedef u_int16_t vrf_id_t;</a>
<a name="ln537"> </a>
<a name="ln538">typedef uint32_t route_tag_t;</a>
<a name="ln539">#define ROUTE_TAG_MAX UINT32_MAX</a>
<a name="ln540"> </a>
<a name="ln541">#endif /* _ZEBRA_H */</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
