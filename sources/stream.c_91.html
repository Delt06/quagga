
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>stream.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">  /*</a>
<a name="ln2"> * Packet interface</a>
<a name="ln3"> * Copyright (C) 1999 Kunihiro Ishiguro</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.  </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24">#include &lt;stddef.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;stream.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;network.h&quot;</a>
<a name="ln29">#include &quot;prefix.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">/* Tests whether a position is valid */ </a>
<a name="ln33">#define GETP_VALID(S,G) \</a>
<a name="ln34">  ((G) &lt;= (S)-&gt;endp)</a>
<a name="ln35">#define PUT_AT_VALID(S,G) GETP_VALID(S,G)</a>
<a name="ln36">#define ENDP_VALID(S,E) \</a>
<a name="ln37">  ((E) &lt;= (S)-&gt;size)</a>
<a name="ln38"> </a>
<a name="ln39">/* asserting sanity checks. Following must be true before</a>
<a name="ln40"> * stream functions are called:</a>
<a name="ln41"> *</a>
<a name="ln42"> * Following must always be true of stream elements</a>
<a name="ln43"> * before and after calls to stream functions:</a>
<a name="ln44"> *</a>
<a name="ln45"> * getp &lt;= endp &lt;= size</a>
<a name="ln46"> *</a>
<a name="ln47"> * Note that after a stream function is called following may be true:</a>
<a name="ln48"> * if (getp == endp) then stream is no longer readable</a>
<a name="ln49"> * if (endp == size) then stream is no longer writeable</a>
<a name="ln50"> *</a>
<a name="ln51"> * It is valid to put to anywhere within the size of the stream, but only</a>
<a name="ln52"> * using stream_put..._at() functions.</a>
<a name="ln53"> */</a>
<a name="ln54">#define STREAM_WARN_OFFSETS(S) \</a>
<a name="ln55">  zlog_warn (&quot;&amp;(struct stream): %p, size: %lu, getp: %lu, endp: %lu\n&quot;, \</a>
<a name="ln56">             (void *)(S), \</a>
<a name="ln57">             (unsigned long) (S)-&gt;size, \</a>
<a name="ln58">             (unsigned long) (S)-&gt;getp, \</a>
<a name="ln59">             (unsigned long) (S)-&gt;endp)\</a>
<a name="ln60"> </a>
<a name="ln61">#define STREAM_VERIFY_SANE(S) \</a>
<a name="ln62">  do { \</a>
<a name="ln63">    if ( !(GETP_VALID(S, (S)-&gt;getp) &amp;&amp; ENDP_VALID(S, (S)-&gt;endp)) ) \</a>
<a name="ln64">      STREAM_WARN_OFFSETS(S); \</a>
<a name="ln65">    assert ( GETP_VALID(S, (S)-&gt;getp) ); \</a>
<a name="ln66">    assert ( ENDP_VALID(S, (S)-&gt;endp) ); \</a>
<a name="ln67">  } while (0)</a>
<a name="ln68"> </a>
<a name="ln69">#define STREAM_BOUND_WARN(S, WHAT) \</a>
<a name="ln70">  do { \</a>
<a name="ln71">    zlog_warn (&quot;%s: Attempt to %s out of bounds&quot;, __func__, (WHAT)); \</a>
<a name="ln72">    STREAM_WARN_OFFSETS(S); \</a>
<a name="ln73">    assert (0); \</a>
<a name="ln74">  } while (0)</a>
<a name="ln75"> </a>
<a name="ln76">/* XXX: Deprecated macro: do not use */</a>
<a name="ln77">#define CHECK_SIZE(S, Z) \</a>
<a name="ln78">  do { \</a>
<a name="ln79">    if (((S)-&gt;endp + (Z)) &gt; (S)-&gt;size) \</a>
<a name="ln80">      { \</a>
<a name="ln81">        zlog_warn (&quot;CHECK_SIZE: truncating requested size %lu\n&quot;, \</a>
<a name="ln82">                   (unsigned long) (Z)); \</a>
<a name="ln83">        STREAM_WARN_OFFSETS(S); \</a>
<a name="ln84">        (Z) = (S)-&gt;size - (S)-&gt;endp; \</a>
<a name="ln85">      } \</a>
<a name="ln86">  } while (0);</a>
<a name="ln87"> </a>
<a name="ln88">/* Make stream buffer. */</a>
<a name="ln89">struct stream *</a>
<a name="ln90">stream_new (size_t size)</a>
<a name="ln91">{</a>
<a name="ln92">  struct stream *s;</a>
<a name="ln93"> </a>
<a name="ln94">  assert (size &gt; 0);</a>
<a name="ln95">  </a>
<a name="ln96">  if (size == 0)</a>
<a name="ln97">    {</a>
<a name="ln98">      zlog_warn (&quot;stream_new(): called with 0 size!&quot;);</a>
<a name="ln99">      return NULL;</a>
<a name="ln100">    }</a>
<a name="ln101">  </a>
<a name="ln102">  s = XCALLOC (MTYPE_STREAM, sizeof (struct stream));</a>
<a name="ln103"> </a>
<a name="ln104">  if (s == NULL)</a>
<a name="ln105">    return s;</a>
<a name="ln106">  </a>
<a name="ln107">  if ( (s-&gt;data = XMALLOC (MTYPE_STREAM_DATA, size)) == NULL)</a>
<a name="ln108">    {</a>
<a name="ln109">      XFREE (MTYPE_STREAM, s);</a>
<a name="ln110">      return NULL;</a>
<a name="ln111">    }</a>
<a name="ln112">  </a>
<a name="ln113">  s-&gt;size = size;</a>
<a name="ln114">  return s;</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">/* Free it now. */</a>
<a name="ln118">void</a>
<a name="ln119">stream_free (struct stream *s)</a>
<a name="ln120">{</a>
<a name="ln121">  if (!s)</a>
<a name="ln122">    return;</a>
<a name="ln123">  </a>
<a name="ln124">  XFREE (MTYPE_STREAM_DATA, s-&gt;data);</a>
<a name="ln125">  XFREE (MTYPE_STREAM, s);</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">struct stream *</a>
<a name="ln129">stream_copy (struct stream *new, struct stream *src)</a>
<a name="ln130">{</a>
<a name="ln131">  STREAM_VERIFY_SANE (src);</a>
<a name="ln132">  </a>
<a name="ln133">  assert (new != NULL);</a>
<a name="ln134">  assert (STREAM_SIZE(new) &gt;= src-&gt;endp);</a>
<a name="ln135"> </a>
<a name="ln136">  new-&gt;endp = src-&gt;endp;</a>
<a name="ln137">  new-&gt;getp = src-&gt;getp;</a>
<a name="ln138">  </a>
<a name="ln139">  memcpy (new-&gt;data, src-&gt;data, src-&gt;endp);</a>
<a name="ln140">  </a>
<a name="ln141">  return new;</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">struct stream *</a>
<a name="ln145">stream_dup (struct stream *s)</a>
<a name="ln146">{</a>
<a name="ln147">  struct stream *new;</a>
<a name="ln148"> </a>
<a name="ln149">  STREAM_VERIFY_SANE (s);</a>
<a name="ln150"> </a>
<a name="ln151">  if ( (new = stream_new (s-&gt;endp)) == NULL)</a>
<a name="ln152">    return NULL;</a>
<a name="ln153"> </a>
<a name="ln154">  return (stream_copy (new, s));</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">struct stream *</a>
<a name="ln158">stream_dupcat (struct stream *s1, struct stream *s2, size_t offset)</a>
<a name="ln159">{</a>
<a name="ln160">  struct stream *new;</a>
<a name="ln161"> </a>
<a name="ln162">  STREAM_VERIFY_SANE (s1);</a>
<a name="ln163">  STREAM_VERIFY_SANE (s2);</a>
<a name="ln164"> </a>
<a name="ln165">  if ( (new = stream_new (s1-&gt;endp + s2-&gt;endp)) == NULL)</a>
<a name="ln166">    return NULL;</a>
<a name="ln167"> </a>
<a name="ln168">  memcpy (new-&gt;data, s1-&gt;data, offset);</a>
<a name="ln169">  memcpy (new-&gt;data + offset, s2-&gt;data, s2-&gt;endp);</a>
<a name="ln170">  memcpy (new-&gt;data + offset + s2-&gt;endp, s1-&gt;data + offset,</a>
<a name="ln171">	  (s1-&gt;endp - offset));</a>
<a name="ln172">  new-&gt;endp = s1-&gt;endp + s2-&gt;endp;</a>
<a name="ln173">  return new;</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">size_t</a>
<a name="ln177">stream_resize (struct stream *s, size_t newsize)</a>
<a name="ln178">{</a>
<a name="ln179">  u_char *newdata;</a>
<a name="ln180">  STREAM_VERIFY_SANE (s);</a>
<a name="ln181">  </a>
<a name="ln182">  newdata = XREALLOC (MTYPE_STREAM_DATA, s-&gt;data, newsize);</a>
<a name="ln183">  </a>
<a name="ln184">  if (newdata == NULL)</a>
<a name="ln185">    return s-&gt;size;</a>
<a name="ln186">  </a>
<a name="ln187">  s-&gt;data = newdata;</a>
<a name="ln188">  s-&gt;size = newsize;</a>
<a name="ln189">  </a>
<a name="ln190">  if (s-&gt;endp &gt; s-&gt;size)</a>
<a name="ln191">    s-&gt;endp = s-&gt;size;</a>
<a name="ln192">  if (s-&gt;getp &gt; s-&gt;endp)</a>
<a name="ln193">    s-&gt;getp = s-&gt;endp;</a>
<a name="ln194">  </a>
<a name="ln195">  STREAM_VERIFY_SANE (s);</a>
<a name="ln196">  </a>
<a name="ln197">  return s-&gt;size;</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">size_t</a>
<a name="ln201">stream_get_getp (struct stream *s)</a>
<a name="ln202">{</a>
<a name="ln203">  STREAM_VERIFY_SANE(s);</a>
<a name="ln204">  return s-&gt;getp;</a>
<a name="ln205">}</a>
<a name="ln206"> </a>
<a name="ln207">size_t</a>
<a name="ln208">stream_get_endp (struct stream *s)</a>
<a name="ln209">{</a>
<a name="ln210">  STREAM_VERIFY_SANE(s);</a>
<a name="ln211">  return s-&gt;endp;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">size_t</a>
<a name="ln215">stream_get_size (struct stream *s)</a>
<a name="ln216">{</a>
<a name="ln217">  STREAM_VERIFY_SANE(s);</a>
<a name="ln218">  return s-&gt;size;</a>
<a name="ln219">}</a>
<a name="ln220"> </a>
<a name="ln221">/* Stream structre' stream pointer related functions.  */</a>
<a name="ln222">void</a>
<a name="ln223">stream_set_getp (struct stream *s, size_t pos)</a>
<a name="ln224">{</a>
<a name="ln225">  STREAM_VERIFY_SANE(s);</a>
<a name="ln226">  </a>
<a name="ln227">  if (!GETP_VALID (s, pos))</a>
<a name="ln228">    {</a>
<a name="ln229">      STREAM_BOUND_WARN (s, &quot;set getp&quot;);</a>
<a name="ln230">      pos = s-&gt;endp;</a>
<a name="ln231">    }</a>
<a name="ln232"> </a>
<a name="ln233">  s-&gt;getp = pos;</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">void</a>
<a name="ln237">stream_set_endp (struct stream *s, size_t pos)</a>
<a name="ln238">{</a>
<a name="ln239">  STREAM_VERIFY_SANE(s);</a>
<a name="ln240"> </a>
<a name="ln241">  if (!ENDP_VALID(s, pos))</a>
<a name="ln242">    {</a>
<a name="ln243">      STREAM_BOUND_WARN (s, &quot;set endp&quot;);</a>
<a name="ln244">      return;</a>
<a name="ln245">    }</a>
<a name="ln246"> </a>
<a name="ln247">  /*</a>
<a name="ln248">   * Make sure the current read pointer is not beyond the new endp.</a>
<a name="ln249">   */</a>
<a name="ln250">  if (s-&gt;getp &gt; pos)</a>
<a name="ln251">    {</a>
<a name="ln252">      STREAM_BOUND_WARN(s, &quot;set endp&quot;);</a>
<a name="ln253">      return;</a>
<a name="ln254">    }</a>
<a name="ln255"> </a>
<a name="ln256">  s-&gt;endp = pos;</a>
<a name="ln257">  STREAM_VERIFY_SANE(s);</a>
<a name="ln258">}</a>
<a name="ln259"> </a>
<a name="ln260">/* Forward pointer. */</a>
<a name="ln261">void</a>
<a name="ln262">stream_forward_getp (struct stream *s, size_t size)</a>
<a name="ln263">{</a>
<a name="ln264">  STREAM_VERIFY_SANE(s);</a>
<a name="ln265">  </a>
<a name="ln266">  if (!GETP_VALID (s, s-&gt;getp + size))</a>
<a name="ln267">    {</a>
<a name="ln268">      STREAM_BOUND_WARN (s, &quot;seek getp&quot;);</a>
<a name="ln269">      return;</a>
<a name="ln270">    }</a>
<a name="ln271">  </a>
<a name="ln272">  s-&gt;getp += size;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">void</a>
<a name="ln276">stream_forward_endp (struct stream *s, size_t size)</a>
<a name="ln277">{</a>
<a name="ln278">  STREAM_VERIFY_SANE(s);</a>
<a name="ln279">  </a>
<a name="ln280">  if (!ENDP_VALID (s, s-&gt;endp + size))</a>
<a name="ln281">    {</a>
<a name="ln282">      STREAM_BOUND_WARN (s, &quot;seek endp&quot;);</a>
<a name="ln283">      return;</a>
<a name="ln284">    }</a>
<a name="ln285">  </a>
<a name="ln286">  s-&gt;endp += size;</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">/* Copy from stream to destination. */</a>
<a name="ln290">void</a>
<a name="ln291">stream_get (void *dst, struct stream *s, size_t size)</a>
<a name="ln292">{</a>
<a name="ln293">  STREAM_VERIFY_SANE(s);</a>
<a name="ln294">  </a>
<a name="ln295">  if (STREAM_READABLE(s) &lt; size)</a>
<a name="ln296">    {</a>
<a name="ln297">      STREAM_BOUND_WARN (s, &quot;get&quot;);</a>
<a name="ln298">      return;</a>
<a name="ln299">    }</a>
<a name="ln300">  </a>
<a name="ln301">  memcpy (dst, s-&gt;data + s-&gt;getp, size);</a>
<a name="ln302">  s-&gt;getp += size;</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">/* Get next character from the stream. */</a>
<a name="ln306">u_char</a>
<a name="ln307">stream_getc (struct stream *s)</a>
<a name="ln308">{</a>
<a name="ln309">  u_char c;</a>
<a name="ln310">  </a>
<a name="ln311">  STREAM_VERIFY_SANE (s);</a>
<a name="ln312"> </a>
<a name="ln313">  if (STREAM_READABLE(s) &lt; sizeof (u_char))</a>
<a name="ln314">    {</a>
<a name="ln315">      STREAM_BOUND_WARN (s, &quot;get char&quot;);</a>
<a name="ln316">      return 0;</a>
<a name="ln317">    }</a>
<a name="ln318">  c = s-&gt;data[s-&gt;getp++];</a>
<a name="ln319">  </a>
<a name="ln320">  return c;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">/* Get next character from the stream. */</a>
<a name="ln324">u_char</a>
<a name="ln325">stream_getc_from (struct stream *s, size_t from)</a>
<a name="ln326">{</a>
<a name="ln327">  u_char c;</a>
<a name="ln328"> </a>
<a name="ln329">  STREAM_VERIFY_SANE(s);</a>
<a name="ln330">  </a>
<a name="ln331">  if (!GETP_VALID (s, from + sizeof (u_char)))</a>
<a name="ln332">    {</a>
<a name="ln333">      STREAM_BOUND_WARN (s, &quot;get char&quot;);</a>
<a name="ln334">      return 0;</a>
<a name="ln335">    }</a>
<a name="ln336">  </a>
<a name="ln337">  c = s-&gt;data[from];</a>
<a name="ln338">  </a>
<a name="ln339">  return c;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">/* Get next word from the stream. */</a>
<a name="ln343">u_int16_t</a>
<a name="ln344">stream_getw (struct stream *s)</a>
<a name="ln345">{</a>
<a name="ln346">  u_int16_t w;</a>
<a name="ln347"> </a>
<a name="ln348">  STREAM_VERIFY_SANE (s);</a>
<a name="ln349"> </a>
<a name="ln350">  if (STREAM_READABLE (s) &lt; sizeof (u_int16_t))</a>
<a name="ln351">    {</a>
<a name="ln352">      STREAM_BOUND_WARN (s, &quot;get &quot;);</a>
<a name="ln353">      return 0;</a>
<a name="ln354">    }</a>
<a name="ln355">  </a>
<a name="ln356">  w = s-&gt;data[s-&gt;getp++] &lt;&lt; 8;</a>
<a name="ln357">  w |= s-&gt;data[s-&gt;getp++];</a>
<a name="ln358">  </a>
<a name="ln359">  return w;</a>
<a name="ln360">}</a>
<a name="ln361"> </a>
<a name="ln362">/* Get next word from the stream. */</a>
<a name="ln363">u_int16_t</a>
<a name="ln364">stream_getw_from (struct stream *s, size_t from)</a>
<a name="ln365">{</a>
<a name="ln366">  u_int16_t w;</a>
<a name="ln367"> </a>
<a name="ln368">  STREAM_VERIFY_SANE(s);</a>
<a name="ln369">  </a>
<a name="ln370">  if (!GETP_VALID (s, from + sizeof (u_int16_t)))</a>
<a name="ln371">    {</a>
<a name="ln372">      STREAM_BOUND_WARN (s, &quot;get &quot;);</a>
<a name="ln373">      return 0;</a>
<a name="ln374">    }</a>
<a name="ln375">  </a>
<a name="ln376">  w = s-&gt;data[from++] &lt;&lt; 8;</a>
<a name="ln377">  w |= s-&gt;data[from];</a>
<a name="ln378">  </a>
<a name="ln379">  return w;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">/* Get next long word from the stream. */</a>
<a name="ln383">u_int32_t</a>
<a name="ln384">stream_getl_from (struct stream *s, size_t from)</a>
<a name="ln385">{</a>
<a name="ln386">  u_int32_t l;</a>
<a name="ln387"> </a>
<a name="ln388">  STREAM_VERIFY_SANE(s);</a>
<a name="ln389">  </a>
<a name="ln390">  if (!GETP_VALID (s, from + sizeof (u_int32_t)))</a>
<a name="ln391">    {</a>
<a name="ln392">      STREAM_BOUND_WARN (s, &quot;get long&quot;);</a>
<a name="ln393">      return 0;</a>
<a name="ln394">    }</a>
<a name="ln395">  </a>
<a name="ln396">  l  = s-&gt;data[from++] &lt;&lt; 24;</a>
<a name="ln397">  l |= s-&gt;data[from++] &lt;&lt; 16;</a>
<a name="ln398">  l |= s-&gt;data[from++] &lt;&lt; 8;</a>
<a name="ln399">  l |= s-&gt;data[from];</a>
<a name="ln400">  </a>
<a name="ln401">  return l;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">u_int32_t</a>
<a name="ln405">stream_getl (struct stream *s)</a>
<a name="ln406">{</a>
<a name="ln407">  u_int32_t l;</a>
<a name="ln408"> </a>
<a name="ln409">  STREAM_VERIFY_SANE(s);</a>
<a name="ln410">  </a>
<a name="ln411">  if (STREAM_READABLE (s) &lt; sizeof (u_int32_t))</a>
<a name="ln412">    {</a>
<a name="ln413">      STREAM_BOUND_WARN (s, &quot;get long&quot;);</a>
<a name="ln414">      return 0;</a>
<a name="ln415">    }</a>
<a name="ln416">  </a>
<a name="ln417">  l  = s-&gt;data[s-&gt;getp++] &lt;&lt; 24;</a>
<a name="ln418">  l |= s-&gt;data[s-&gt;getp++] &lt;&lt; 16;</a>
<a name="ln419">  l |= s-&gt;data[s-&gt;getp++] &lt;&lt; 8;</a>
<a name="ln420">  l |= s-&gt;data[s-&gt;getp++];</a>
<a name="ln421">  </a>
<a name="ln422">  return l;</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">/* Get next quad word from the stream. */</a>
<a name="ln426">uint64_t</a>
<a name="ln427">stream_getq_from (struct stream *s, size_t from)</a>
<a name="ln428">{</a>
<a name="ln429">  uint64_t q;</a>
<a name="ln430"> </a>
<a name="ln431">  STREAM_VERIFY_SANE(s);</a>
<a name="ln432">  </a>
<a name="ln433">  if (!GETP_VALID (s, from + sizeof (uint64_t)))</a>
<a name="ln434">    {</a>
<a name="ln435">      STREAM_BOUND_WARN (s, &quot;get quad&quot;);</a>
<a name="ln436">      return 0;</a>
<a name="ln437">    }</a>
<a name="ln438">  </a>
<a name="ln439">  q  = ((uint64_t) s-&gt;data[from++]) &lt;&lt; 56;</a>
<a name="ln440">  q |= ((uint64_t) s-&gt;data[from++]) &lt;&lt; 48;</a>
<a name="ln441">  q |= ((uint64_t) s-&gt;data[from++]) &lt;&lt; 40;</a>
<a name="ln442">  q |= ((uint64_t) s-&gt;data[from++]) &lt;&lt; 32;  </a>
<a name="ln443">  q |= ((uint64_t) s-&gt;data[from++]) &lt;&lt; 24;</a>
<a name="ln444">  q |= ((uint64_t) s-&gt;data[from++]) &lt;&lt; 16;</a>
<a name="ln445">  q |= ((uint64_t) s-&gt;data[from++]) &lt;&lt; 8;</a>
<a name="ln446">  q |= ((uint64_t) s-&gt;data[from++]);</a>
<a name="ln447">  </a>
<a name="ln448">  return q;</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">uint64_t</a>
<a name="ln452">stream_getq (struct stream *s)</a>
<a name="ln453">{</a>
<a name="ln454">  uint64_t q;</a>
<a name="ln455"> </a>
<a name="ln456">  STREAM_VERIFY_SANE(s);</a>
<a name="ln457">  </a>
<a name="ln458">  if (STREAM_READABLE (s) &lt; sizeof (uint64_t))</a>
<a name="ln459">    {</a>
<a name="ln460">      STREAM_BOUND_WARN (s, &quot;get quad&quot;);</a>
<a name="ln461">      return 0;</a>
<a name="ln462">    }</a>
<a name="ln463">  </a>
<a name="ln464">  q  = ((uint64_t) s-&gt;data[s-&gt;getp++]) &lt;&lt; 56;</a>
<a name="ln465">  q |= ((uint64_t) s-&gt;data[s-&gt;getp++]) &lt;&lt; 48;</a>
<a name="ln466">  q |= ((uint64_t) s-&gt;data[s-&gt;getp++]) &lt;&lt; 40;</a>
<a name="ln467">  q |= ((uint64_t) s-&gt;data[s-&gt;getp++]) &lt;&lt; 32;  </a>
<a name="ln468">  q |= ((uint64_t) s-&gt;data[s-&gt;getp++]) &lt;&lt; 24;</a>
<a name="ln469">  q |= ((uint64_t) s-&gt;data[s-&gt;getp++]) &lt;&lt; 16;</a>
<a name="ln470">  q |= ((uint64_t) s-&gt;data[s-&gt;getp++]) &lt;&lt; 8;</a>
<a name="ln471">  q |= ((uint64_t) s-&gt;data[s-&gt;getp++]);</a>
<a name="ln472">  </a>
<a name="ln473">  return q;</a>
<a name="ln474">}</a>
<a name="ln475"> </a>
<a name="ln476">/* Get next long word from the stream. */</a>
<a name="ln477">u_int32_t</a>
<a name="ln478">stream_get_ipv4 (struct stream *s)</a>
<a name="ln479">{</a>
<a name="ln480">  u_int32_t l;</a>
<a name="ln481"> </a>
<a name="ln482">  STREAM_VERIFY_SANE(s);</a>
<a name="ln483">  </a>
<a name="ln484">  if (STREAM_READABLE (s) &lt; sizeof(u_int32_t))</a>
<a name="ln485">    {</a>
<a name="ln486">      STREAM_BOUND_WARN (s, &quot;get ipv4&quot;);</a>
<a name="ln487">      return 0;</a>
<a name="ln488">    }</a>
<a name="ln489">  </a>
<a name="ln490">  memcpy (&amp;l, s-&gt;data + s-&gt;getp, sizeof(u_int32_t));</a>
<a name="ln491">  s-&gt;getp += sizeof(u_int32_t);</a>
<a name="ln492"> </a>
<a name="ln493">  return l;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">float</a>
<a name="ln497">stream_getf (struct stream *s)</a>
<a name="ln498">{</a>
<a name="ln499">#if !defined(__STDC_IEC_559__) &amp;&amp; __GCC_IEC_559 &lt; 1</a>
<a name="ln500">#warning &quot;Unknown floating-point format, __func__ may be wrong&quot;</a>
<a name="ln501">#endif</a>
<a name="ln502">/* we assume 'float' is in the single precision IEC 60559 binary</a>
<a name="ln503">   format, in host byte order */</a>
<a name="ln504">  union {</a>
<a name="ln505">    float r;</a>
<a name="ln506">    uint32_t d;</a>
<a name="ln507">  } u;</a>
<a name="ln508">  u.d = stream_getl (s);</a>
<a name="ln509">  return u.r;</a>
<a name="ln510">}</a>
<a name="ln511"> </a>
<a name="ln512">double</a>
<a name="ln513">stream_getd (struct stream *s)</a>
<a name="ln514">{</a>
<a name="ln515">#if !defined(__STDC_IEC_559__) &amp;&amp; __GCC_IEC_559 &lt; 1</a>
<a name="ln516">#warning &quot;Unknown floating-point format, __func__ may be wrong&quot;</a>
<a name="ln517">#endif</a>
<a name="ln518">  union {</a>
<a name="ln519">    double r;</a>
<a name="ln520">    uint64_t d;</a>
<a name="ln521">  } u;</a>
<a name="ln522">  u.d = stream_getq (s);</a>
<a name="ln523">  return u.r;</a>
<a name="ln524">}</a>
<a name="ln525"> </a>
<a name="ln526">/* Copy to source to stream.</a>
<a name="ln527"> *</a>
<a name="ln528"> * XXX: This uses CHECK_SIZE and hence has funny semantics -&gt; Size will wrap</a>
<a name="ln529"> * around. This should be fixed once the stream updates are working.</a>
<a name="ln530"> *</a>
<a name="ln531"> * stream_write() is saner</a>
<a name="ln532"> */</a>
<a name="ln533">void</a>
<a name="ln534">stream_put (struct stream *s, const void *src, size_t size)</a>
<a name="ln535">{</a>
<a name="ln536"> </a>
<a name="ln537">  /* XXX: CHECK_SIZE has strange semantics. It should be deprecated */</a>
<a name="ln538">  CHECK_SIZE(s, size);</a>
<a name="ln539">  </a>
<a name="ln540">  STREAM_VERIFY_SANE(s);</a>
<a name="ln541">  </a>
<a name="ln542">  if (STREAM_WRITEABLE (s) &lt; size)</a>
<a name="ln543">    {</a>
<a name="ln544">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln545">      return;</a>
<a name="ln546">    }</a>
<a name="ln547">  </a>
<a name="ln548">  if (src)</a>
<a name="ln549">    memcpy (s-&gt;data + s-&gt;endp, src, size);</a>
<a name="ln550">  else</a>
<a name="ln551">    memset (s-&gt;data + s-&gt;endp, 0, size);</a>
<a name="ln552"> </a>
<a name="ln553">  s-&gt;endp += size;</a>
<a name="ln554">}</a>
<a name="ln555"> </a>
<a name="ln556">/* Put character to the stream. */</a>
<a name="ln557">int</a>
<a name="ln558">stream_putc (struct stream *s, u_char c)</a>
<a name="ln559">{</a>
<a name="ln560">  STREAM_VERIFY_SANE(s);</a>
<a name="ln561">  </a>
<a name="ln562">  if (STREAM_WRITEABLE (s) &lt; sizeof(u_char))</a>
<a name="ln563">    {</a>
<a name="ln564">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln565">      return 0;</a>
<a name="ln566">    }</a>
<a name="ln567">  </a>
<a name="ln568">  s-&gt;data[s-&gt;endp++] = c;</a>
<a name="ln569">  return sizeof (u_char);</a>
<a name="ln570">}</a>
<a name="ln571"> </a>
<a name="ln572">/* Put word to the stream. */</a>
<a name="ln573">int</a>
<a name="ln574">stream_putw (struct stream *s, u_int16_t w)</a>
<a name="ln575">{</a>
<a name="ln576">  STREAM_VERIFY_SANE (s);</a>
<a name="ln577"> </a>
<a name="ln578">  if (STREAM_WRITEABLE (s) &lt; sizeof (u_int16_t))</a>
<a name="ln579">    {</a>
<a name="ln580">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln581">      return 0;</a>
<a name="ln582">    }</a>
<a name="ln583">  </a>
<a name="ln584">  s-&gt;data[s-&gt;endp++] = (u_char)(w &gt;&gt;  8);</a>
<a name="ln585">  s-&gt;data[s-&gt;endp++] = (u_char) w;</a>
<a name="ln586"> </a>
<a name="ln587">  return 2;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">/* Put long word to the stream. */</a>
<a name="ln591">int</a>
<a name="ln592">stream_putl (struct stream *s, u_int32_t l)</a>
<a name="ln593">{</a>
<a name="ln594">  STREAM_VERIFY_SANE (s);</a>
<a name="ln595"> </a>
<a name="ln596">  if (STREAM_WRITEABLE (s) &lt; sizeof (u_int32_t))</a>
<a name="ln597">    {</a>
<a name="ln598">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln599">      return 0;</a>
<a name="ln600">    }</a>
<a name="ln601">  </a>
<a name="ln602">  s-&gt;data[s-&gt;endp++] = (u_char)(l &gt;&gt; 24);</a>
<a name="ln603">  s-&gt;data[s-&gt;endp++] = (u_char)(l &gt;&gt; 16);</a>
<a name="ln604">  s-&gt;data[s-&gt;endp++] = (u_char)(l &gt;&gt;  8);</a>
<a name="ln605">  s-&gt;data[s-&gt;endp++] = (u_char)l;</a>
<a name="ln606"> </a>
<a name="ln607">  return 4;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">/* Put quad word to the stream. */</a>
<a name="ln611">int</a>
<a name="ln612">stream_putq (struct stream *s, uint64_t q)</a>
<a name="ln613">{</a>
<a name="ln614">  STREAM_VERIFY_SANE (s);</a>
<a name="ln615"> </a>
<a name="ln616">  if (STREAM_WRITEABLE (s) &lt; sizeof (uint64_t))</a>
<a name="ln617">    {</a>
<a name="ln618">      STREAM_BOUND_WARN (s, &quot;put quad&quot;);</a>
<a name="ln619">      return 0;</a>
<a name="ln620">    }</a>
<a name="ln621">  </a>
<a name="ln622">  s-&gt;data[s-&gt;endp++] = (u_char)(q &gt;&gt; 56);</a>
<a name="ln623">  s-&gt;data[s-&gt;endp++] = (u_char)(q &gt;&gt; 48);</a>
<a name="ln624">  s-&gt;data[s-&gt;endp++] = (u_char)(q &gt;&gt; 40);</a>
<a name="ln625">  s-&gt;data[s-&gt;endp++] = (u_char)(q &gt;&gt; 32);</a>
<a name="ln626">  s-&gt;data[s-&gt;endp++] = (u_char)(q &gt;&gt; 24);</a>
<a name="ln627">  s-&gt;data[s-&gt;endp++] = (u_char)(q &gt;&gt; 16);</a>
<a name="ln628">  s-&gt;data[s-&gt;endp++] = (u_char)(q &gt;&gt;  8);</a>
<a name="ln629">  s-&gt;data[s-&gt;endp++] = (u_char)q;</a>
<a name="ln630"> </a>
<a name="ln631">  return 8;</a>
<a name="ln632">}</a>
<a name="ln633"> </a>
<a name="ln634">int</a>
<a name="ln635">stream_putf (struct stream *s, float f)</a>
<a name="ln636">{</a>
<a name="ln637">#if !defined(__STDC_IEC_559__) &amp;&amp; __GCC_IEC_559 &lt; 1</a>
<a name="ln638">#warning &quot;Unknown floating-point format, __func__ may be wrong&quot;</a>
<a name="ln639">#endif</a>
<a name="ln640"> </a>
<a name="ln641">/* we can safely assume 'float' is in the single precision</a>
<a name="ln642">   IEC 60559 binary format in host order */</a>
<a name="ln643">  union {</a>
<a name="ln644">    float i;</a>
<a name="ln645">    uint32_t o;</a>
<a name="ln646">  } u;</a>
<a name="ln647">  u.i = f;</a>
<a name="ln648">  return stream_putl (s, u.o);</a>
<a name="ln649">}</a>
<a name="ln650"> </a>
<a name="ln651">int</a>
<a name="ln652">stream_putd (struct stream *s, double d)</a>
<a name="ln653">{</a>
<a name="ln654">#if !defined(__STDC_IEC_559__) &amp;&amp; __GCC_IEC_559 &lt; 1</a>
<a name="ln655">#warning &quot;Unknown floating-point format, __func__ may be wrong&quot;</a>
<a name="ln656">#endif</a>
<a name="ln657">  union {</a>
<a name="ln658">    double i;</a>
<a name="ln659">    uint64_t o;</a>
<a name="ln660">  } u;</a>
<a name="ln661">  u.i = d;</a>
<a name="ln662">  return stream_putq (s, u.o);</a>
<a name="ln663">}</a>
<a name="ln664"> </a>
<a name="ln665">int</a>
<a name="ln666">stream_putc_at (struct stream *s, size_t putp, u_char c)</a>
<a name="ln667">{</a>
<a name="ln668">  STREAM_VERIFY_SANE(s);</a>
<a name="ln669">  </a>
<a name="ln670">  if (!PUT_AT_VALID (s, putp + sizeof (u_char)))</a>
<a name="ln671">    {</a>
<a name="ln672">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln673">      return 0;</a>
<a name="ln674">    }</a>
<a name="ln675">  </a>
<a name="ln676">  s-&gt;data[putp] = c;</a>
<a name="ln677">  </a>
<a name="ln678">  return 1;</a>
<a name="ln679">}</a>
<a name="ln680"> </a>
<a name="ln681">int</a>
<a name="ln682">stream_putw_at (struct stream *s, size_t putp, u_int16_t w)</a>
<a name="ln683">{</a>
<a name="ln684">  STREAM_VERIFY_SANE(s);</a>
<a name="ln685">  </a>
<a name="ln686">  if (!PUT_AT_VALID (s, putp + sizeof (u_int16_t)))</a>
<a name="ln687">    {</a>
<a name="ln688">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln689">      return 0;</a>
<a name="ln690">    }</a>
<a name="ln691">  </a>
<a name="ln692">  s-&gt;data[putp] = (u_char)(w &gt;&gt;  8);</a>
<a name="ln693">  s-&gt;data[putp + 1] = (u_char) w;</a>
<a name="ln694">  </a>
<a name="ln695">  return 2;</a>
<a name="ln696">}</a>
<a name="ln697"> </a>
<a name="ln698">int</a>
<a name="ln699">stream_putl_at (struct stream *s, size_t putp, u_int32_t l)</a>
<a name="ln700">{</a>
<a name="ln701">  STREAM_VERIFY_SANE(s);</a>
<a name="ln702">  </a>
<a name="ln703">  if (!PUT_AT_VALID (s, putp + sizeof (u_int32_t)))</a>
<a name="ln704">    {</a>
<a name="ln705">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln706">      return 0;</a>
<a name="ln707">    }</a>
<a name="ln708">  s-&gt;data[putp] = (u_char)(l &gt;&gt; 24);</a>
<a name="ln709">  s-&gt;data[putp + 1] = (u_char)(l &gt;&gt; 16);</a>
<a name="ln710">  s-&gt;data[putp + 2] = (u_char)(l &gt;&gt;  8);</a>
<a name="ln711">  s-&gt;data[putp + 3] = (u_char)l;</a>
<a name="ln712">  </a>
<a name="ln713">  return 4;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">int</a>
<a name="ln717">stream_putq_at (struct stream *s, size_t putp, uint64_t q)</a>
<a name="ln718">{</a>
<a name="ln719">  STREAM_VERIFY_SANE(s);</a>
<a name="ln720">  </a>
<a name="ln721">  if (!PUT_AT_VALID (s, putp + sizeof (uint64_t)))</a>
<a name="ln722">    {</a>
<a name="ln723">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln724">      return 0;</a>
<a name="ln725">    }</a>
<a name="ln726">  s-&gt;data[putp] =     (u_char)(q &gt;&gt; 56);</a>
<a name="ln727">  s-&gt;data[putp + 1] = (u_char)(q &gt;&gt; 48);</a>
<a name="ln728">  s-&gt;data[putp + 2] = (u_char)(q &gt;&gt; 40);</a>
<a name="ln729">  s-&gt;data[putp + 3] = (u_char)(q &gt;&gt; 32);</a>
<a name="ln730">  s-&gt;data[putp + 4] = (u_char)(q &gt;&gt; 24);</a>
<a name="ln731">  s-&gt;data[putp + 5] = (u_char)(q &gt;&gt; 16);</a>
<a name="ln732">  s-&gt;data[putp + 6] = (u_char)(q &gt;&gt;  8);</a>
<a name="ln733">  s-&gt;data[putp + 7] = (u_char)q;</a>
<a name="ln734">  </a>
<a name="ln735">  return 8;</a>
<a name="ln736">}</a>
<a name="ln737"> </a>
<a name="ln738">/* Put long word to the stream. */</a>
<a name="ln739">int</a>
<a name="ln740">stream_put_ipv4 (struct stream *s, u_int32_t l)</a>
<a name="ln741">{</a>
<a name="ln742">  STREAM_VERIFY_SANE(s);</a>
<a name="ln743">  </a>
<a name="ln744">  if (STREAM_WRITEABLE (s) &lt; sizeof (u_int32_t))</a>
<a name="ln745">    {</a>
<a name="ln746">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln747">      return 0;</a>
<a name="ln748">    }</a>
<a name="ln749">  memcpy (s-&gt;data + s-&gt;endp, &amp;l, sizeof (u_int32_t));</a>
<a name="ln750">  s-&gt;endp += sizeof (u_int32_t);</a>
<a name="ln751"> </a>
<a name="ln752">  return sizeof (u_int32_t);</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">/* Put long word to the stream. */</a>
<a name="ln756">int</a>
<a name="ln757">stream_put_in_addr (struct stream *s, struct in_addr *addr)</a>
<a name="ln758">{</a>
<a name="ln759">  STREAM_VERIFY_SANE(s);</a>
<a name="ln760">  </a>
<a name="ln761">  if (STREAM_WRITEABLE (s) &lt; sizeof (u_int32_t))</a>
<a name="ln762">    {</a>
<a name="ln763">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln764">      return 0;</a>
<a name="ln765">    }</a>
<a name="ln766"> </a>
<a name="ln767">  memcpy (s-&gt;data + s-&gt;endp, addr, sizeof (u_int32_t));</a>
<a name="ln768">  s-&gt;endp += sizeof (u_int32_t);</a>
<a name="ln769"> </a>
<a name="ln770">  return sizeof (u_int32_t);</a>
<a name="ln771">}</a>
<a name="ln772"> </a>
<a name="ln773">/* Put prefix by nlri type format. */</a>
<a name="ln774">int</a>
<a name="ln775">stream_put_prefix (struct stream *s, struct prefix *p)</a>
<a name="ln776">{</a>
<a name="ln777">  size_t psize;</a>
<a name="ln778">  </a>
<a name="ln779">  STREAM_VERIFY_SANE(s);</a>
<a name="ln780">  </a>
<a name="ln781">  psize = PSIZE (p-&gt;prefixlen);</a>
<a name="ln782">  </a>
<a name="ln783">  if (STREAM_WRITEABLE (s) &lt; (psize + sizeof (u_char)))</a>
<a name="ln784">    {</a>
<a name="ln785">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln786">      return 0;</a>
<a name="ln787">    }</a>
<a name="ln788">  </a>
<a name="ln789">  s-&gt;data[s-&gt;endp++] = p-&gt;prefixlen;</a>
<a name="ln790">  memcpy (s-&gt;data + s-&gt;endp, &amp;p-&gt;u.prefix, psize);</a>
<a name="ln791">  s-&gt;endp += psize;</a>
<a name="ln792">  </a>
<a name="ln793">  return psize;</a>
<a name="ln794">}</a>
<a name="ln795"> </a>
<a name="ln796">/* Read size from fd. */</a>
<a name="ln797">int</a>
<a name="ln798">stream_read (struct stream *s, int fd, size_t size)</a>
<a name="ln799">{</a>
<a name="ln800">  int nbytes;</a>
<a name="ln801"> </a>
<a name="ln802">  STREAM_VERIFY_SANE(s);</a>
<a name="ln803">  </a>
<a name="ln804">  if (STREAM_WRITEABLE (s) &lt; size)</a>
<a name="ln805">    {</a>
<a name="ln806">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln807">      return 0;</a>
<a name="ln808">    }</a>
<a name="ln809">  </a>
<a name="ln810">  nbytes = readn (fd, s-&gt;data + s-&gt;endp, size);</a>
<a name="ln811"> </a>
<a name="ln812">  if (nbytes &gt; 0)</a>
<a name="ln813">    s-&gt;endp += nbytes;</a>
<a name="ln814">  </a>
<a name="ln815">  return nbytes;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">ssize_t</a>
<a name="ln819">stream_read_try(struct stream *s, int fd, size_t size)</a>
<a name="ln820">{</a>
<a name="ln821">  ssize_t nbytes;</a>
<a name="ln822"> </a>
<a name="ln823">  STREAM_VERIFY_SANE(s);</a>
<a name="ln824">  </a>
<a name="ln825">  if (STREAM_WRITEABLE(s) &lt; size)</a>
<a name="ln826">    {</a>
<a name="ln827">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln828">      /* Fatal (not transient) error, since retrying will not help</a>
<a name="ln829">         (stream is too small to contain the desired data). */</a>
<a name="ln830">      return -1;</a>
<a name="ln831">    }</a>
<a name="ln832"> </a>
<a name="ln833">  if ((nbytes = read(fd, s-&gt;data + s-&gt;endp, size)) &gt;= 0)</a>
<a name="ln834">    {</a>
<a name="ln835">      s-&gt;endp += nbytes;</a>
<a name="ln836">      return nbytes;</a>
<a name="ln837">    }</a>
<a name="ln838">  /* Error: was it transient (return -2) or fatal (return -1)? */</a>
<a name="ln839">  if (ERRNO_IO_RETRY(errno))</a>
<a name="ln840">    return -2;</a>
<a name="ln841">  zlog_warn(&quot;%s: read failed on fd %d: %s&quot;, __func__, fd, safe_strerror(errno));</a>
<a name="ln842">  return -1;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">/* Read up to size bytes into the stream from the fd, using recvmsgfrom</a>
<a name="ln846"> * whose arguments match the remaining arguments to this function</a>
<a name="ln847"> */</a>
<a name="ln848">ssize_t </a>
<a name="ln849">stream_recvfrom (struct stream *s, int fd, size_t size, int flags,</a>
<a name="ln850">                 struct sockaddr *from, socklen_t *fromlen)                     </a>
<a name="ln851">{</a>
<a name="ln852">  ssize_t nbytes;</a>
<a name="ln853"> </a>
<a name="ln854">  STREAM_VERIFY_SANE(s);</a>
<a name="ln855">  </a>
<a name="ln856">  if (STREAM_WRITEABLE(s) &lt; size)</a>
<a name="ln857">    {</a>
<a name="ln858">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln859">      /* Fatal (not transient) error, since retrying will not help</a>
<a name="ln860">         (stream is too small to contain the desired data). */</a>
<a name="ln861">      return -1;</a>
<a name="ln862">    }</a>
<a name="ln863"> </a>
<a name="ln864">  if ((nbytes = recvfrom (fd, s-&gt;data + s-&gt;endp, size, </a>
<a name="ln865">                          flags, from, fromlen)) &gt;= 0)</a>
<a name="ln866">    {</a>
<a name="ln867">      s-&gt;endp += nbytes;</a>
<a name="ln868">      return nbytes;</a>
<a name="ln869">    }</a>
<a name="ln870">  /* Error: was it transient (return -2) or fatal (return -1)? */</a>
<a name="ln871">  if (ERRNO_IO_RETRY(errno))</a>
<a name="ln872">    return -2;</a>
<a name="ln873">  zlog_warn(&quot;%s: read failed on fd %d: %s&quot;, __func__, fd, safe_strerror(errno));</a>
<a name="ln874">  return -1;</a>
<a name="ln875">}</a>
<a name="ln876"> </a>
<a name="ln877">/* Read up to smaller of size or SIZE_REMAIN() bytes to the stream, starting</a>
<a name="ln878"> * from endp.</a>
<a name="ln879"> * First iovec will be used to receive the data.</a>
<a name="ln880"> * Stream need not be empty.</a>
<a name="ln881"> */</a>
<a name="ln882">ssize_t</a>
<a name="ln883">stream_recvmsg (struct stream *s, int fd, struct msghdr *msgh, int flags, </a>
<a name="ln884">                size_t size)</a>
<a name="ln885">{</a>
<a name="ln886">  int nbytes;</a>
<a name="ln887">  struct iovec *iov;</a>
<a name="ln888">  </a>
<a name="ln889">  STREAM_VERIFY_SANE(s);</a>
<a name="ln890">  assert (msgh-&gt;msg_iovlen &gt; 0);  </a>
<a name="ln891">  </a>
<a name="ln892">  if (STREAM_WRITEABLE (s) &lt; size)</a>
<a name="ln893">    {</a>
<a name="ln894">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln895">      /* This is a logic error in the calling code: the stream is too small</a>
<a name="ln896">         to hold the desired data! */</a>
<a name="ln897">      return -1;</a>
<a name="ln898">    }</a>
<a name="ln899">  </a>
<a name="ln900">  iov = &amp;(msgh-&gt;msg_iov[0]);</a>
<a name="ln901">  iov-&gt;iov_base = (s-&gt;data + s-&gt;endp);</a>
<a name="ln902">  iov-&gt;iov_len = size;</a>
<a name="ln903">  </a>
<a name="ln904">  nbytes = recvmsg (fd, msgh, flags);</a>
<a name="ln905">  </a>
<a name="ln906">  if (nbytes &gt; 0)</a>
<a name="ln907">    s-&gt;endp += nbytes;</a>
<a name="ln908">  </a>
<a name="ln909">  return nbytes;</a>
<a name="ln910">}</a>
<a name="ln911">  </a>
<a name="ln912">/* Write data to buffer. */</a>
<a name="ln913">size_t</a>
<a name="ln914">stream_write (struct stream *s, const void *ptr, size_t size)</a>
<a name="ln915">{</a>
<a name="ln916"> </a>
<a name="ln917">  CHECK_SIZE(s, size);</a>
<a name="ln918"> </a>
<a name="ln919">  STREAM_VERIFY_SANE(s);</a>
<a name="ln920">  </a>
<a name="ln921">  if (STREAM_WRITEABLE (s) &lt; size)</a>
<a name="ln922">    {</a>
<a name="ln923">      STREAM_BOUND_WARN (s, &quot;put&quot;);</a>
<a name="ln924">      return 0;</a>
<a name="ln925">    }</a>
<a name="ln926">  </a>
<a name="ln927">  memcpy (s-&gt;data + s-&gt;endp, ptr, size);</a>
<a name="ln928">  s-&gt;endp += size;</a>
<a name="ln929"> </a>
<a name="ln930">  return size;</a>
<a name="ln931">}</a>
<a name="ln932"> </a>
<a name="ln933">/* Return current read pointer. </a>
<a name="ln934"> * DEPRECATED!</a>
<a name="ln935"> * Use stream_get_pnt_to if you must, but decoding streams properly</a>
<a name="ln936"> * is preferred</a>
<a name="ln937"> */</a>
<a name="ln938">u_char *</a>
<a name="ln939">stream_pnt (struct stream *s)</a>
<a name="ln940">{</a>
<a name="ln941">  STREAM_VERIFY_SANE(s);</a>
<a name="ln942">  return s-&gt;data + s-&gt;getp;</a>
<a name="ln943">}</a>
<a name="ln944"> </a>
<a name="ln945">/* Check does this stream empty? */</a>
<a name="ln946">int</a>
<a name="ln947">stream_empty (struct stream *s)</a>
<a name="ln948">{</a>
<a name="ln949">  STREAM_VERIFY_SANE(s);</a>
<a name="ln950"> </a>
<a name="ln951">  return (s-&gt;endp == 0);</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">/* Reset stream. */</a>
<a name="ln955">void</a>
<a name="ln956">stream_reset (struct stream *s)</a>
<a name="ln957">{</a>
<a name="ln958">  STREAM_VERIFY_SANE (s);</a>
<a name="ln959"> </a>
<a name="ln960">  s-&gt;getp = s-&gt;endp = 0;</a>
<a name="ln961">}</a>
<a name="ln962"> </a>
<a name="ln963">/* Discard read data (prior to the getp), and move the unread data</a>
<a name="ln964"> * to the beginning of the stream.</a>
<a name="ln965"> *</a>
<a name="ln966"> * See also stream_fifo_* functions, for another approach to managing</a>
<a name="ln967"> * streams.</a>
<a name="ln968"> */</a>
<a name="ln969">void</a>
<a name="ln970">stream_discard (struct stream *s)</a>
<a name="ln971">{</a>
<a name="ln972">  STREAM_VERIFY_SANE (s);</a>
<a name="ln973">  </a>
<a name="ln974">  if (s-&gt;getp == 0)</a>
<a name="ln975">    return;</a>
<a name="ln976">  </a>
<a name="ln977">  if (s-&gt;getp == s-&gt;endp)</a>
<a name="ln978">    {</a>
<a name="ln979">      stream_reset (s);</a>
<a name="ln980">      return;</a>
<a name="ln981">    }</a>
<a name="ln982">  </a>
<a name="ln983">  s-&gt;data = memmove (s-&gt;data, s-&gt;data + s-&gt;getp, s-&gt;endp - s-&gt;getp);</a>
<a name="ln984">  s-&gt;endp -= s-&gt;getp;</a>
<a name="ln985">  s-&gt;getp = 0;</a>
<a name="ln986">}</a>
<a name="ln987"> </a>
<a name="ln988">/* Write stream contens to the file discriptor. */</a>
<a name="ln989">int</a>
<a name="ln990">stream_flush (struct stream *s, int fd)</a>
<a name="ln991">{</a>
<a name="ln992">  int nbytes;</a>
<a name="ln993">  </a>
<a name="ln994">  STREAM_VERIFY_SANE(s);</a>
<a name="ln995">  </a>
<a name="ln996">  nbytes = write (fd, s-&gt;data + s-&gt;getp, s-&gt;endp - s-&gt;getp);</a>
<a name="ln997">  </a>
<a name="ln998">  return nbytes;</a>
<a name="ln999">}</a>
<a name="ln1000"> </a>
<a name="ln1001">/* Stream first in first out queue. */</a>
<a name="ln1002"> </a>
<a name="ln1003">struct stream_fifo *</a>
<a name="ln1004">stream_fifo_new (void)</a>
<a name="ln1005">{</a>
<a name="ln1006">  struct stream_fifo *new;</a>
<a name="ln1007"> </a>
<a name="ln1008">  new = XCALLOC (MTYPE_STREAM_FIFO, sizeof (struct stream_fifo));</a>
<a name="ln1009">  return new;</a>
<a name="ln1010">}</a>
<a name="ln1011"> </a>
<a name="ln1012">/* Add new stream to fifo. */</a>
<a name="ln1013">void</a>
<a name="ln1014">stream_fifo_push (struct stream_fifo *fifo, struct stream *s)</a>
<a name="ln1015">{</a>
<a name="ln1016">  if (fifo-&gt;tail)</a>
<a name="ln1017">    fifo-&gt;tail-&gt;next = s;</a>
<a name="ln1018">  else</a>
<a name="ln1019">    fifo-&gt;head = s;</a>
<a name="ln1020">     </a>
<a name="ln1021">  fifo-&gt;tail = s;</a>
<a name="ln1022"> </a>
<a name="ln1023">  fifo-&gt;count++;</a>
<a name="ln1024">}</a>
<a name="ln1025"> </a>
<a name="ln1026">/* Delete first stream from fifo. */</a>
<a name="ln1027">struct stream *</a>
<a name="ln1028">stream_fifo_pop (struct stream_fifo *fifo)</a>
<a name="ln1029">{</a>
<a name="ln1030">  struct stream *s;</a>
<a name="ln1031">  </a>
<a name="ln1032">  s = fifo-&gt;head; </a>
<a name="ln1033"> </a>
<a name="ln1034">  if (s)</a>
<a name="ln1035">    { </a>
<a name="ln1036">      fifo-&gt;head = s-&gt;next;</a>
<a name="ln1037"> </a>
<a name="ln1038">      if (fifo-&gt;head == NULL)</a>
<a name="ln1039">	fifo-&gt;tail = NULL;</a>
<a name="ln1040"> </a>
<a name="ln1041">      fifo-&gt;count--;</a>
<a name="ln1042">    }</a>
<a name="ln1043"> </a>
<a name="ln1044">  return s; </a>
<a name="ln1045">}</a>
<a name="ln1046"> </a>
<a name="ln1047">/* Return first fifo entry. */</a>
<a name="ln1048">struct stream *</a>
<a name="ln1049">stream_fifo_head (struct stream_fifo *fifo)</a>
<a name="ln1050">{</a>
<a name="ln1051">  return fifo-&gt;head;</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">void</a>
<a name="ln1055">stream_fifo_clean (struct stream_fifo *fifo)</a>
<a name="ln1056">{</a>
<a name="ln1057">  struct stream *s;</a>
<a name="ln1058">  struct stream *next;</a>
<a name="ln1059"> </a>
<a name="ln1060">  for (s = fifo-&gt;head; s; s = next)</a>
<a name="ln1061">    {</a>
<a name="ln1062">      next = s-&gt;next;</a>
<a name="ln1063">      stream_free (s);</a>
<a name="ln1064">    }</a>
<a name="ln1065">  fifo-&gt;head = fifo-&gt;tail = NULL;</a>
<a name="ln1066">  fifo-&gt;count = 0;</a>
<a name="ln1067">}</a>
<a name="ln1068"> </a>
<a name="ln1069">void</a>
<a name="ln1070">stream_fifo_free (struct stream_fifo *fifo)</a>
<a name="ln1071">{</a>
<a name="ln1072">  stream_fifo_clean (fifo);</a>
<a name="ln1073">  XFREE (MTYPE_STREAM_FIFO, fifo);</a>
<a name="ln1074">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="96"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'size == 0' is always false.</p></div>
<div class="balloon" rel="230"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
