
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_lcommunity.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* BGP Large Communities Attribute</a>
<a name="ln2"> </a>
<a name="ln3">Copyright (C) 2016 Keyur Patel &lt;keyur@arrcus.com&gt;</a>
<a name="ln4"> </a>
<a name="ln5">This file is part of GNU Zebra.</a>
<a name="ln6"> </a>
<a name="ln7">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8">under the terms of the GNU General Public License as published by the</a>
<a name="ln9">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10">later version.</a>
<a name="ln11"> </a>
<a name="ln12">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15">General Public License for more details.</a>
<a name="ln16"> </a>
<a name="ln17">You should have received a copy of the GNU General Public License</a>
<a name="ln18">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20">02111-1307, USA.  */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;hash.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;command.h&quot;</a>
<a name="ln28">#include &quot;filter.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln31">#include &quot;bgpd/bgp_lcommunity.h&quot;</a>
<a name="ln32">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">/* Hash of community attribute. */</a>
<a name="ln35">static struct hash *lcomhash;</a>
<a name="ln36"> </a>
<a name="ln37">/* Allocate a new lcommunities.  */</a>
<a name="ln38">static struct lcommunity *</a>
<a name="ln39">lcommunity_new (void)</a>
<a name="ln40">{</a>
<a name="ln41">  return (struct lcommunity *) XCALLOC (MTYPE_LCOMMUNITY,</a>
<a name="ln42">					sizeof (struct lcommunity));</a>
<a name="ln43">}</a>
<a name="ln44"> </a>
<a name="ln45">/* Allocate lcommunities.  */</a>
<a name="ln46">void</a>
<a name="ln47">lcommunity_free (struct lcommunity **lcom)</a>
<a name="ln48">{</a>
<a name="ln49">  if ((*lcom)-&gt;val)</a>
<a name="ln50">    XFREE (MTYPE_LCOMMUNITY_VAL, (*lcom)-&gt;val);</a>
<a name="ln51">  if ((*lcom)-&gt;str)</a>
<a name="ln52">    XFREE (MTYPE_LCOMMUNITY_STR, (*lcom)-&gt;str);</a>
<a name="ln53">  XFREE (MTYPE_LCOMMUNITY, *lcom);</a>
<a name="ln54">  lcom = NULL;</a>
<a name="ln55">}</a>
<a name="ln56"> </a>
<a name="ln57">/* Add a new Large Communities value to Large Communities</a>
<a name="ln58">   Attribute structure.  When the value is already exists in the</a>
<a name="ln59">   structure, we don't add the value.  Newly added value is sorted by</a>
<a name="ln60">   numerical order.  When the value is added to the structure return 1</a>
<a name="ln61">   else return 0.  */</a>
<a name="ln62">static int</a>
<a name="ln63">lcommunity_add_val (struct lcommunity *lcom, struct lcommunity_val *lval)</a>
<a name="ln64">{</a>
<a name="ln65">  u_int8_t *p;</a>
<a name="ln66">  int ret;</a>
<a name="ln67">  int c;</a>
<a name="ln68"> </a>
<a name="ln69">  /* When this is fist value, just add it.  */</a>
<a name="ln70">  if (lcom-&gt;val == NULL)</a>
<a name="ln71">    {</a>
<a name="ln72">      lcom-&gt;size++;</a>
<a name="ln73">      lcom-&gt;val = XMALLOC (MTYPE_LCOMMUNITY_VAL, lcom_length (lcom));</a>
<a name="ln74">      memcpy (lcom-&gt;val, lval-&gt;val, LCOMMUNITY_SIZE);</a>
<a name="ln75">      return 1;</a>
<a name="ln76">    }</a>
<a name="ln77"> </a>
<a name="ln78">  /* If the value already exists in the structure return 0.  */</a>
<a name="ln79">  c = 0;</a>
<a name="ln80">  for (p = lcom-&gt;val; c &lt; lcom-&gt;size; p += LCOMMUNITY_SIZE, c++)</a>
<a name="ln81">    {</a>
<a name="ln82">      ret = memcmp (p, lval-&gt;val, LCOMMUNITY_SIZE);</a>
<a name="ln83">      if (ret == 0)</a>
<a name="ln84">        return 0;</a>
<a name="ln85">      if (ret &gt; 0)</a>
<a name="ln86">        break;</a>
<a name="ln87">    }</a>
<a name="ln88"> </a>
<a name="ln89">  /* Add the value to the structure with numerical sorting.  */</a>
<a name="ln90">  lcom-&gt;size++;</a>
<a name="ln91">  lcom-&gt;val = XREALLOC (MTYPE_LCOMMUNITY_VAL, lcom-&gt;val, lcom_length (lcom));</a>
<a name="ln92"> </a>
<a name="ln93">  memmove (lcom-&gt;val + (c + 1) * LCOMMUNITY_SIZE,</a>
<a name="ln94">	   lcom-&gt;val + c * LCOMMUNITY_SIZE,</a>
<a name="ln95">	   (lcom-&gt;size - 1 - c) * LCOMMUNITY_SIZE);</a>
<a name="ln96">  memcpy (lcom-&gt;val + c * LCOMMUNITY_SIZE, lval-&gt;val, LCOMMUNITY_SIZE);</a>
<a name="ln97"> </a>
<a name="ln98">  return 1;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">/* This function takes pointer to Large Communites strucutre then</a>
<a name="ln102">   create a new Large Communities structure by uniq and sort each</a>
<a name="ln103">   Large Communities value.  */</a>
<a name="ln104">struct lcommunity *</a>
<a name="ln105">lcommunity_uniq_sort (struct lcommunity *lcom)</a>
<a name="ln106">{</a>
<a name="ln107">  int i;</a>
<a name="ln108">  struct lcommunity *new;</a>
<a name="ln109">  struct lcommunity_val *lval;</a>
<a name="ln110"> </a>
<a name="ln111">  if (! lcom)</a>
<a name="ln112">    return NULL;</a>
<a name="ln113"> </a>
<a name="ln114">  new = lcommunity_new ();</a>
<a name="ln115"> </a>
<a name="ln116">  for (i = 0; i &lt; lcom-&gt;size; i++)</a>
<a name="ln117">    {</a>
<a name="ln118">      lval = (struct lcommunity_val *) (lcom-&gt;val + (i * LCOMMUNITY_SIZE));</a>
<a name="ln119">      lcommunity_add_val (new, lval);</a>
<a name="ln120">    }</a>
<a name="ln121">  return new;</a>
<a name="ln122">}</a>
<a name="ln123"> </a>
<a name="ln124">/* Parse Large Communites Attribute in BGP packet.  */</a>
<a name="ln125">struct lcommunity *</a>
<a name="ln126">lcommunity_parse (u_int8_t *pnt, u_short length)</a>
<a name="ln127">{</a>
<a name="ln128">  struct lcommunity tmp;</a>
<a name="ln129">  struct lcommunity *new;</a>
<a name="ln130"> </a>
<a name="ln131">  /* Length check.  */</a>
<a name="ln132">  if (length % LCOMMUNITY_SIZE)</a>
<a name="ln133">    return NULL;</a>
<a name="ln134"> </a>
<a name="ln135">  /* Prepare tmporary structure for making a new Large Communities</a>
<a name="ln136">     Attribute.  */</a>
<a name="ln137">  tmp.size = length / LCOMMUNITY_SIZE;</a>
<a name="ln138">  tmp.val = pnt;</a>
<a name="ln139"> </a>
<a name="ln140">  /* Create a new Large Communities Attribute by uniq and sort each</a>
<a name="ln141">     Large Communities value  */</a>
<a name="ln142">  new = lcommunity_uniq_sort (&amp;tmp);</a>
<a name="ln143"> </a>
<a name="ln144">  return lcommunity_intern (new);</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">/* Duplicate the Large Communities Attribute structure.  */</a>
<a name="ln148">struct lcommunity *</a>
<a name="ln149">lcommunity_dup (struct lcommunity *lcom)</a>
<a name="ln150">{</a>
<a name="ln151">  struct lcommunity *new;</a>
<a name="ln152"> </a>
<a name="ln153">  new = XCALLOC (MTYPE_LCOMMUNITY, sizeof (struct lcommunity));</a>
<a name="ln154">  new-&gt;size = lcom-&gt;size;</a>
<a name="ln155">  if (new-&gt;size)</a>
<a name="ln156">    {</a>
<a name="ln157">      new-&gt;val = XMALLOC (MTYPE_LCOMMUNITY_VAL, lcom-&gt;size * LCOMMUNITY_SIZE);</a>
<a name="ln158">      memcpy (new-&gt;val, lcom-&gt;val, lcom-&gt;size * LCOMMUNITY_SIZE);</a>
<a name="ln159">    }</a>
<a name="ln160">  else</a>
<a name="ln161">    new-&gt;val = NULL;</a>
<a name="ln162">  return new;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">/* Retrun string representation of communities attribute. */</a>
<a name="ln166">char *</a>
<a name="ln167">lcommunity_str (struct lcommunity *lcom)</a>
<a name="ln168">{</a>
<a name="ln169">  if (! lcom-&gt;str)</a>
<a name="ln170">    lcom-&gt;str = lcommunity_lcom2str (lcom, LCOMMUNITY_FORMAT_DISPLAY);</a>
<a name="ln171">  return lcom-&gt;str;</a>
<a name="ln172">}</a>
<a name="ln173"> </a>
<a name="ln174">/* Merge two Large Communities Attribute structure.  */</a>
<a name="ln175">struct lcommunity *</a>
<a name="ln176">lcommunity_merge (struct lcommunity *lcom1, struct lcommunity *lcom2)</a>
<a name="ln177">{</a>
<a name="ln178">  if (lcom1-&gt;val)</a>
<a name="ln179">    lcom1-&gt;val = XREALLOC (MTYPE_LCOMMUNITY_VAL, lcom1-&gt;val,</a>
<a name="ln180">			   (lcom1-&gt;size + lcom2-&gt;size) * LCOMMUNITY_SIZE);</a>
<a name="ln181">  else</a>
<a name="ln182">    lcom1-&gt;val = XMALLOC (MTYPE_LCOMMUNITY_VAL,</a>
<a name="ln183">			  (lcom1-&gt;size + lcom2-&gt;size) * LCOMMUNITY_SIZE);</a>
<a name="ln184"> </a>
<a name="ln185">  memcpy (lcom1-&gt;val + (lcom1-&gt;size * LCOMMUNITY_SIZE),</a>
<a name="ln186">	  lcom2-&gt;val, lcom2-&gt;size * LCOMMUNITY_SIZE);</a>
<a name="ln187">  lcom1-&gt;size += lcom2-&gt;size;</a>
<a name="ln188"> </a>
<a name="ln189">  return lcom1;</a>
<a name="ln190">}</a>
<a name="ln191"> </a>
<a name="ln192">/* Intern Large Communities Attribute.  */</a>
<a name="ln193">struct lcommunity *</a>
<a name="ln194">lcommunity_intern (struct lcommunity *lcom)</a>
<a name="ln195">{</a>
<a name="ln196">  struct lcommunity *find;</a>
<a name="ln197"> </a>
<a name="ln198">  assert (lcom-&gt;refcnt == 0);</a>
<a name="ln199"> </a>
<a name="ln200">  find = (struct lcommunity *) hash_get (lcomhash, lcom, hash_alloc_intern);</a>
<a name="ln201"> </a>
<a name="ln202">  if (find != lcom)</a>
<a name="ln203">    lcommunity_free (&amp;lcom);</a>
<a name="ln204"> </a>
<a name="ln205">  find-&gt;refcnt++;</a>
<a name="ln206"> </a>
<a name="ln207">  if (! find-&gt;str)</a>
<a name="ln208">    find-&gt;str = lcommunity_lcom2str (find, LCOMMUNITY_FORMAT_DISPLAY);</a>
<a name="ln209"> </a>
<a name="ln210">  return find;</a>
<a name="ln211">}</a>
<a name="ln212"> </a>
<a name="ln213">/* Unintern Large Communities Attribute.  */</a>
<a name="ln214">void</a>
<a name="ln215">lcommunity_unintern (struct lcommunity **lcom)</a>
<a name="ln216">{</a>
<a name="ln217">  struct lcommunity *ret;</a>
<a name="ln218"> </a>
<a name="ln219">  if ((*lcom)-&gt;refcnt)</a>
<a name="ln220">    (*lcom)-&gt;refcnt--;</a>
<a name="ln221"> </a>
<a name="ln222">  /* Pull off from hash.  */</a>
<a name="ln223">  if ((*lcom)-&gt;refcnt == 0)</a>
<a name="ln224">    {</a>
<a name="ln225">      /* Large community must be in the hash.  */</a>
<a name="ln226">      ret = (struct lcommunity *) hash_release (lcomhash, *lcom);</a>
<a name="ln227">      assert (ret != NULL);</a>
<a name="ln228"> </a>
<a name="ln229">      lcommunity_free (lcom);</a>
<a name="ln230">    }</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">/* Utility function to make hash key.  */</a>
<a name="ln234">unsigned int</a>
<a name="ln235">lcommunity_hash_make (void *arg)</a>
<a name="ln236">{</a>
<a name="ln237">  const struct lcommunity *lcom = arg;</a>
<a name="ln238">  int size = lcom-&gt;size * LCOMMUNITY_SIZE;</a>
<a name="ln239">  u_int8_t *pnt = lcom-&gt;val;</a>
<a name="ln240">  unsigned int key = 0;</a>
<a name="ln241">  int c;</a>
<a name="ln242"> </a>
<a name="ln243">  for (c = 0; c &lt; size; c += LCOMMUNITY_SIZE)</a>
<a name="ln244">    {</a>
<a name="ln245">      key += pnt[c];</a>
<a name="ln246">      key += pnt[c + 1];</a>
<a name="ln247">      key += pnt[c + 2];</a>
<a name="ln248">      key += pnt[c + 3];</a>
<a name="ln249">      key += pnt[c + 4];</a>
<a name="ln250">      key += pnt[c + 5];</a>
<a name="ln251">      key += pnt[c + 6];</a>
<a name="ln252">      key += pnt[c + 7];</a>
<a name="ln253">      key += pnt[c + 8];</a>
<a name="ln254">      key += pnt[c + 9];</a>
<a name="ln255">      key += pnt[c + 10];</a>
<a name="ln256">      key += pnt[c + 11];</a>
<a name="ln257">    }</a>
<a name="ln258"> </a>
<a name="ln259">  return key;</a>
<a name="ln260">}</a>
<a name="ln261"> </a>
<a name="ln262">/* Compare two Large Communities Attribute structure.  */</a>
<a name="ln263">int</a>
<a name="ln264">lcommunity_cmp (const void *arg1, const void *arg2)</a>
<a name="ln265">{</a>
<a name="ln266">  const struct lcommunity *lcom1 = arg1;</a>
<a name="ln267">  const struct lcommunity *lcom2 = arg2;</a>
<a name="ln268"> </a>
<a name="ln269">  return (lcom1-&gt;size == lcom2-&gt;size</a>
<a name="ln270">	  &amp;&amp; memcmp (lcom1-&gt;val, lcom2-&gt;val, lcom1-&gt;size * LCOMMUNITY_SIZE) == 0);</a>
<a name="ln271">}</a>
<a name="ln272"> </a>
<a name="ln273">/* Return communities hash.  */</a>
<a name="ln274">struct hash *</a>
<a name="ln275">lcommunity_hash (void)</a>
<a name="ln276">{</a>
<a name="ln277">  return lcomhash;</a>
<a name="ln278">}</a>
<a name="ln279"> </a>
<a name="ln280">/* Initialize Large Comminities related hash. */</a>
<a name="ln281">void</a>
<a name="ln282">lcommunity_init (void)</a>
<a name="ln283">{</a>
<a name="ln284">  lcomhash = hash_create (lcommunity_hash_make, lcommunity_cmp);</a>
<a name="ln285">}</a>
<a name="ln286"> </a>
<a name="ln287">void</a>
<a name="ln288">lcommunity_finish (void)</a>
<a name="ln289">{</a>
<a name="ln290">  hash_free (lcomhash);</a>
<a name="ln291">  lcomhash = NULL;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294">/* Large Communities token enum. */</a>
<a name="ln295">enum lcommunity_token</a>
<a name="ln296">{</a>
<a name="ln297">  lcommunity_token_unknown = 0,</a>
<a name="ln298">  lcommunity_token_val,</a>
<a name="ln299">};</a>
<a name="ln300"> </a>
<a name="ln301">/* Get next Large Communities token from the string. */</a>
<a name="ln302">static const char *</a>
<a name="ln303">lcommunity_gettoken (const char *str, struct lcommunity_val *lval,</a>
<a name="ln304">		     enum lcommunity_token *token)</a>
<a name="ln305">{</a>
<a name="ln306">  const char *p = str;</a>
<a name="ln307"> </a>
<a name="ln308">  /* Skip white space. */</a>
<a name="ln309">  while (isspace ((int) *p))</a>
<a name="ln310">    {</a>
<a name="ln311">      p++;</a>
<a name="ln312">      str++;</a>
<a name="ln313">    }</a>
<a name="ln314"> </a>
<a name="ln315">  /* Check the end of the line. */</a>
<a name="ln316">  if (*p == '\0')</a>
<a name="ln317">    return NULL;</a>
<a name="ln318"> </a>
<a name="ln319">  /* Community value. */</a>
<a name="ln320">  if (isdigit ((int) *p))</a>
<a name="ln321">    {</a>
<a name="ln322">      int separator = 0;</a>
<a name="ln323">      int digit = 0;</a>
<a name="ln324">      u_int32_t globaladmin = 0;</a>
<a name="ln325">      u_int32_t localdata1 = 0;</a>
<a name="ln326">      u_int32_t localdata2 = 0;</a>
<a name="ln327"> </a>
<a name="ln328">      while (isdigit ((int) *p) || *p == ':')</a>
<a name="ln329">	{</a>
<a name="ln330">	  if (*p == ':')</a>
<a name="ln331">	    {</a>
<a name="ln332">	      if (separator == 2)</a>
<a name="ln333">		{</a>
<a name="ln334">		  *token = lcommunity_token_unknown;</a>
<a name="ln335">		  return NULL;</a>
<a name="ln336">		}</a>
<a name="ln337">	      else</a>
<a name="ln338">		{</a>
<a name="ln339">		  separator++;</a>
<a name="ln340">		  digit = 0;</a>
<a name="ln341">		  if (separator == 1) {</a>
<a name="ln342">		    globaladmin = localdata2;</a>
<a name="ln343">		  } else {</a>
<a name="ln344">		    localdata1 = localdata2;</a>
<a name="ln345">		  }</a>
<a name="ln346">		  localdata2 = 0;</a>
<a name="ln347">		}</a>
<a name="ln348">	    }</a>
<a name="ln349">	  else</a>
<a name="ln350">	    {</a>
<a name="ln351">	      digit = 1;</a>
<a name="ln352">	      localdata2 *= 10;</a>
<a name="ln353">	      localdata2 += (*p - '0');</a>
<a name="ln354">	    }</a>
<a name="ln355">	  p++;</a>
<a name="ln356">	}</a>
<a name="ln357">      if (! digit)</a>
<a name="ln358">	{</a>
<a name="ln359">	  *token = lcommunity_token_unknown;</a>
<a name="ln360">	  return NULL;</a>
<a name="ln361">	}</a>
<a name="ln362"> </a>
<a name="ln363">      /*</a>
<a name="ln364">       * Copy the large comm.</a>
<a name="ln365">       */</a>
<a name="ln366">      lval-&gt;val[0] = (globaladmin &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln367">      lval-&gt;val[1] = (globaladmin &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln368">      lval-&gt;val[2] = (globaladmin &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln369">      lval-&gt;val[3] = globaladmin &amp; 0xff;</a>
<a name="ln370">      lval-&gt;val[4] = (localdata1 &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln371">      lval-&gt;val[5] = (localdata1 &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln372">      lval-&gt;val[6] = (localdata1 &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln373">      lval-&gt;val[7] = localdata1 &amp; 0xff;</a>
<a name="ln374">      lval-&gt;val[8] = (localdata2 &gt;&gt; 24) &amp; 0xff;</a>
<a name="ln375">      lval-&gt;val[9] = (localdata2 &gt;&gt; 16) &amp; 0xff;</a>
<a name="ln376">      lval-&gt;val[10] = (localdata2 &gt;&gt; 8) &amp; 0xff;</a>
<a name="ln377">      lval-&gt;val[11] = localdata2 &amp; 0xff;</a>
<a name="ln378"> </a>
<a name="ln379">      *token = lcommunity_token_val;</a>
<a name="ln380">      return p;</a>
<a name="ln381">    }</a>
<a name="ln382">  *token = lcommunity_token_unknown;</a>
<a name="ln383">  return p;</a>
<a name="ln384">}</a>
<a name="ln385"> </a>
<a name="ln386">/*</a>
<a name="ln387">  Convert string to large community attribute.</a>
<a name="ln388">  When type is already known, please specify both str and type.</a>
<a name="ln389"> </a>
<a name="ln390">  When string includes keyword for each large community value.</a>
<a name="ln391">  Please specify keyword_included as non-zero value.</a>
<a name="ln392">*/</a>
<a name="ln393">struct lcommunity *</a>
<a name="ln394">lcommunity_str2com (const char *str)</a>
<a name="ln395">{</a>
<a name="ln396">    struct lcommunity *lcom = NULL;</a>
<a name="ln397">    enum lcommunity_token token = lcommunity_token_unknown;</a>
<a name="ln398">    struct lcommunity_val lval;</a>
<a name="ln399"> </a>
<a name="ln400">    while ((str = lcommunity_gettoken (str, &amp;lval, &amp;token)))</a>
<a name="ln401">    {</a>
<a name="ln402">        switch (token)</a>
<a name="ln403">        {</a>
<a name="ln404">            case lcommunity_token_val:</a>
<a name="ln405">                if (lcom == NULL)</a>
<a name="ln406">                    lcom = lcommunity_new ();</a>
<a name="ln407">                lcommunity_add_val (lcom, &amp;lval);</a>
<a name="ln408">                break;</a>
<a name="ln409">            case lcommunity_token_unknown:</a>
<a name="ln410">            default:</a>
<a name="ln411">                if (lcom)</a>
<a name="ln412">                    lcommunity_free (&amp;lcom);</a>
<a name="ln413">                return NULL;</a>
<a name="ln414">        }</a>
<a name="ln415">    }</a>
<a name="ln416">    return lcom;</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">int</a>
<a name="ln420">lcommunity_include (struct lcommunity *lcom, u_char *ptr)</a>
<a name="ln421">{</a>
<a name="ln422">  int i;</a>
<a name="ln423">  u_char *lcom_ptr;</a>
<a name="ln424"> </a>
<a name="ln425">  for (i = 0; i &lt; lcom-&gt;size; i++) {</a>
<a name="ln426">    lcom_ptr = lcom-&gt;val + (i * LCOMMUNITY_SIZE);</a>
<a name="ln427">    if (memcmp (ptr, lcom_ptr, LCOMMUNITY_SIZE) == 0)</a>
<a name="ln428">      return 1;</a>
<a name="ln429">  }</a>
<a name="ln430">  return 0;</a>
<a name="ln431">}</a>
<a name="ln432"> </a>
<a name="ln433">/* Convert large community attribute to string.</a>
<a name="ln434">   The large coms will be in 65535:65531:0 format.</a>
<a name="ln435">*/</a>
<a name="ln436">char *</a>
<a name="ln437">lcommunity_lcom2str (struct lcommunity *lcom, int format)</a>
<a name="ln438">{</a>
<a name="ln439">  int i;</a>
<a name="ln440">  u_int8_t *pnt;</a>
<a name="ln441">#define LCOMMUNITY_STR_DEFAULT_LEN  40</a>
<a name="ln442">  int str_size;</a>
<a name="ln443">  int str_pnt;</a>
<a name="ln444">  char *str_buf;</a>
<a name="ln445">  int len = 0;</a>
<a name="ln446">  int first = 1;</a>
<a name="ln447">  u_int32_t  globaladmin, localdata1, localdata2;</a>
<a name="ln448"> </a>
<a name="ln449">  if (lcom-&gt;size == 0)</a>
<a name="ln450">    {</a>
<a name="ln451">      str_buf = XMALLOC (MTYPE_LCOMMUNITY_STR, 1);</a>
<a name="ln452">      str_buf[0] = '\0';</a>
<a name="ln453">      return str_buf;</a>
<a name="ln454">    }</a>
<a name="ln455"> </a>
<a name="ln456">  /* Prepare buffer.  */</a>
<a name="ln457">  str_buf = XMALLOC (MTYPE_LCOMMUNITY_STR, LCOMMUNITY_STR_DEFAULT_LEN + 1);</a>
<a name="ln458">  str_size = LCOMMUNITY_STR_DEFAULT_LEN + 1;</a>
<a name="ln459">  str_pnt = 0;</a>
<a name="ln460"> </a>
<a name="ln461">  for (i = 0; i &lt; lcom-&gt;size; i++)</a>
<a name="ln462">    {</a>
<a name="ln463">      /* Make it sure size is enough.  */</a>
<a name="ln464">      while (str_pnt + LCOMMUNITY_STR_DEFAULT_LEN &gt;= str_size)</a>
<a name="ln465">	{</a>
<a name="ln466">	  str_size *= 2;</a>
<a name="ln467">	  str_buf = XREALLOC (MTYPE_LCOMMUNITY_STR, str_buf, str_size);</a>
<a name="ln468">	}</a>
<a name="ln469"> </a>
<a name="ln470">      /* Space between each value.  */</a>
<a name="ln471">      if (! first)</a>
<a name="ln472">	str_buf[str_pnt++] = ' ';</a>
<a name="ln473"> </a>
<a name="ln474">      pnt = lcom-&gt;val + (i * 12);</a>
<a name="ln475"> </a>
<a name="ln476">      globaladmin = (*pnt++ &lt;&lt; 24);</a>
<a name="ln477">      globaladmin |= (*pnt++ &lt;&lt; 16);</a>
<a name="ln478">      globaladmin |= (*pnt++ &lt;&lt; 8);</a>
<a name="ln479">      globaladmin |= (*pnt++);</a>
<a name="ln480"> </a>
<a name="ln481">      localdata1 = (*pnt++ &lt;&lt; 24);</a>
<a name="ln482">      localdata1 |= (*pnt++ &lt;&lt; 16);</a>
<a name="ln483">      localdata1 |= (*pnt++ &lt;&lt; 8);</a>
<a name="ln484">      localdata1 |= (*pnt++);</a>
<a name="ln485"> </a>
<a name="ln486">      localdata2 = (*pnt++ &lt;&lt; 24);</a>
<a name="ln487">      localdata2 |= (*pnt++ &lt;&lt; 16);</a>
<a name="ln488">      localdata2 |= (*pnt++ &lt;&lt; 8);</a>
<a name="ln489">      localdata2 |= (*pnt++);</a>
<a name="ln490"> </a>
<a name="ln491">      len = sprintf( str_buf + str_pnt, &quot;%u:%u:%u&quot;, globaladmin,</a>
<a name="ln492">		     localdata1, localdata2);</a>
<a name="ln493">      str_pnt += len;</a>
<a name="ln494">      first = 0;</a>
<a name="ln495">    }</a>
<a name="ln496">  return str_buf;</a>
<a name="ln497">}</a>
<a name="ln498"> </a>
<a name="ln499">int</a>
<a name="ln500">lcommunity_match (const struct lcommunity *lcom1,</a>
<a name="ln501">                  const struct lcommunity *lcom2)</a>
<a name="ln502">{</a>
<a name="ln503">  int i = 0;</a>
<a name="ln504">  int j = 0;</a>
<a name="ln505"> </a>
<a name="ln506">  if (lcom1 == NULL &amp;&amp; lcom2 == NULL)</a>
<a name="ln507">    return 1;</a>
<a name="ln508"> </a>
<a name="ln509">  if (lcom1 == NULL || lcom2 == NULL)</a>
<a name="ln510">    return 0;</a>
<a name="ln511"> </a>
<a name="ln512">  if (lcom1-&gt;size &lt; lcom2-&gt;size)</a>
<a name="ln513">    return 0;</a>
<a name="ln514"> </a>
<a name="ln515">  /* Every community on com2 needs to be on com1 for this to match */</a>
<a name="ln516">  while (i &lt; lcom1-&gt;size &amp;&amp; j &lt; lcom2-&gt;size)</a>
<a name="ln517">    {</a>
<a name="ln518">      if (memcmp (lcom1-&gt;val + (i*12), lcom2-&gt;val + (j*12), LCOMMUNITY_SIZE) == 0)</a>
<a name="ln519">        j++;</a>
<a name="ln520">      i++;</a>
<a name="ln521">    }</a>
<a name="ln522"> </a>
<a name="ln523">  if (j == lcom2-&gt;size)</a>
<a name="ln524">    return 1;</a>
<a name="ln525">  else</a>
<a name="ln526">    return 0;</a>
<a name="ln527">}</a>
<a name="ln528"> </a>
<a name="ln529">/* Delete one lcommunity. */</a>
<a name="ln530">void</a>
<a name="ln531">lcommunity_del_val (struct lcommunity *lcom, u_char *ptr)</a>
<a name="ln532">{</a>
<a name="ln533">  int i = 0;</a>
<a name="ln534">  int c = 0;</a>
<a name="ln535"> </a>
<a name="ln536">  if (! lcom-&gt;val)</a>
<a name="ln537">    return;</a>
<a name="ln538"> </a>
<a name="ln539">  while (i &lt; lcom-&gt;size)</a>
<a name="ln540">    {</a>
<a name="ln541">      if (memcmp (lcom-&gt;val + i*LCOMMUNITY_SIZE, ptr, LCOMMUNITY_SIZE) == 0)</a>
<a name="ln542">	{</a>
<a name="ln543">	  c = lcom-&gt;size -i -1;</a>
<a name="ln544"> </a>
<a name="ln545">	  if (c &gt; 0)</a>
<a name="ln546">	    memmove (lcom-&gt;val + i*LCOMMUNITY_SIZE, lcom-&gt;val + (i + 1)*LCOMMUNITY_SIZE, c * LCOMMUNITY_SIZE);</a>
<a name="ln547"> </a>
<a name="ln548">	  lcom-&gt;size--;</a>
<a name="ln549"> </a>
<a name="ln550">	  if (lcom-&gt;size &gt; 0)</a>
<a name="ln551">	    lcom-&gt;val = XREALLOC (MTYPE_COMMUNITY_VAL, lcom-&gt;val,</a>
<a name="ln552">				 lcom_length (lcom));</a>
<a name="ln553">	  else</a>
<a name="ln554">	    {</a>
<a name="ln555">	      XFREE (MTYPE_COMMUNITY_VAL, lcom-&gt;val);</a>
<a name="ln556">	      lcom-&gt;val = NULL;</a>
<a name="ln557">	    }</a>
<a name="ln558">	  return;</a>
<a name="ln559">	}</a>
<a name="ln560">      i++;</a>
<a name="ln561">    }</a>
<a name="ln562">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
