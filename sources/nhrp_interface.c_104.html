
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>nhrp_interface.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* NHRP interface</a>
<a name="ln2"> * Copyright (c) 2014-2015 Timo Ter√§s</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is free software: you may copy, redistribute and/or modify</a>
<a name="ln5"> * it under the terms of the GNU General Public License as published by</a>
<a name="ln6"> * the Free Software Foundation, either version 2 of the License, or</a>
<a name="ln7"> * (at your option) any later version.</a>
<a name="ln8"> */</a>
<a name="ln9"> </a>
<a name="ln10">#include &lt;net/if_arp.h&gt;</a>
<a name="ln11">#include &quot;zebra.h&quot;</a>
<a name="ln12">#include &quot;linklist.h&quot;</a>
<a name="ln13">#include &quot;memory.h&quot;</a>
<a name="ln14">#include &quot;thread.h&quot;</a>
<a name="ln15"> </a>
<a name="ln16">#include &quot;nhrpd.h&quot;</a>
<a name="ln17">#include &quot;os.h&quot;</a>
<a name="ln18">#include &quot;netlink.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">static int nhrp_if_new_hook(struct interface *ifp)</a>
<a name="ln21">{</a>
<a name="ln22">	struct nhrp_interface *nifp;</a>
<a name="ln23">	afi_t afi;</a>
<a name="ln24"> </a>
<a name="ln25">	nifp = XCALLOC(MTYPE_NHRP_IF, sizeof(struct nhrp_interface));</a>
<a name="ln26">	if (!nifp) return 0;</a>
<a name="ln27"> </a>
<a name="ln28">	ifp-&gt;info = nifp;</a>
<a name="ln29">	nifp-&gt;ifp = ifp;</a>
<a name="ln30"> </a>
<a name="ln31">	notifier_init(&amp;nifp-&gt;notifier_list);</a>
<a name="ln32">	for (afi = 0; afi &lt; AFI_MAX; afi++) {</a>
<a name="ln33">		struct nhrp_afi_data *ad = &amp;nifp-&gt;afi[afi];</a>
<a name="ln34">		ad-&gt;holdtime = NHRPD_DEFAULT_HOLDTIME;</a>
<a name="ln35">		list_init(&amp;ad-&gt;nhslist_head);</a>
<a name="ln36">	}</a>
<a name="ln37"> </a>
<a name="ln38">	return 0;</a>
<a name="ln39">}</a>
<a name="ln40"> </a>
<a name="ln41">static int nhrp_if_delete_hook(struct interface *ifp)</a>
<a name="ln42">{</a>
<a name="ln43">	XFREE(MTYPE_NHRP_IF, ifp-&gt;info);</a>
<a name="ln44">	return 0;</a>
<a name="ln45">}</a>
<a name="ln46"> </a>
<a name="ln47">void nhrp_interface_init(void)</a>
<a name="ln48">{</a>
<a name="ln49">	if_add_hook(IF_NEW_HOOK,    nhrp_if_new_hook);</a>
<a name="ln50">	if_add_hook(IF_DELETE_HOOK, nhrp_if_delete_hook);</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">void nhrp_interface_update_mtu(struct interface *ifp, afi_t afi)</a>
<a name="ln54">{</a>
<a name="ln55">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln56">	struct nhrp_afi_data *if_ad = &amp;nifp-&gt;afi[afi];</a>
<a name="ln57">	unsigned short new_mtu;</a>
<a name="ln58"> </a>
<a name="ln59">	if (if_ad-&gt;configured_mtu &lt; 0)</a>
<a name="ln60">		new_mtu = nifp-&gt;nbmaifp ? nifp-&gt;nbmaifp-&gt;mtu : 0;</a>
<a name="ln61">	else</a>
<a name="ln62">		new_mtu = if_ad-&gt;configured_mtu;</a>
<a name="ln63">	if (new_mtu &gt;= 1500)</a>
<a name="ln64">		new_mtu = 0;</a>
<a name="ln65"> </a>
<a name="ln66">	if (new_mtu != if_ad-&gt;mtu) {</a>
<a name="ln67">		debugf(NHRP_DEBUG_IF, &quot;%s: MTU changed to %d&quot;, ifp-&gt;name, new_mtu);</a>
<a name="ln68">		if_ad-&gt;mtu = new_mtu;</a>
<a name="ln69">		notifier_call(&amp;nifp-&gt;notifier_list, NOTIFY_INTERFACE_MTU_CHANGED);</a>
<a name="ln70">	}</a>
<a name="ln71">}</a>
<a name="ln72"> </a>
<a name="ln73">static void nhrp_interface_update_source(struct interface *ifp)</a>
<a name="ln74">{</a>
<a name="ln75">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln76"> </a>
<a name="ln77">	if (!nifp-&gt;source || !nifp-&gt;nbmaifp ||</a>
<a name="ln78">	    nifp-&gt;linkidx == nifp-&gt;nbmaifp-&gt;ifindex)</a>
<a name="ln79">		return;</a>
<a name="ln80"> </a>
<a name="ln81">	nifp-&gt;linkidx = nifp-&gt;nbmaifp-&gt;ifindex;</a>
<a name="ln82">	debugf(NHRP_DEBUG_IF, &quot;%s: bound device index changed to %d&quot;, ifp-&gt;name, nifp-&gt;linkidx);</a>
<a name="ln83">	netlink_gre_set_link(ifp-&gt;ifindex, nifp-&gt;linkidx);</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">static void nhrp_interface_interface_notifier(struct notifier_block *n, unsigned long cmd)</a>
<a name="ln87">{</a>
<a name="ln88">	struct nhrp_interface *nifp = container_of(n, struct nhrp_interface, nbmanifp_notifier);</a>
<a name="ln89">	struct interface *nbmaifp = nifp-&gt;nbmaifp;</a>
<a name="ln90">	struct nhrp_interface *nbmanifp = nbmaifp-&gt;info;</a>
<a name="ln91">	char buf[SU_ADDRSTRLEN];</a>
<a name="ln92"> </a>
<a name="ln93">	switch (cmd) {</a>
<a name="ln94">	case NOTIFY_INTERFACE_CHANGED:</a>
<a name="ln95">		nhrp_interface_update_mtu(nifp-&gt;ifp, AFI_IP);</a>
<a name="ln96">		nhrp_interface_update_source(nifp-&gt;ifp);</a>
<a name="ln97">		break;</a>
<a name="ln98">	case NOTIFY_INTERFACE_ADDRESS_CHANGED:</a>
<a name="ln99">		nifp-&gt;nbma = nbmanifp-&gt;afi[AFI_IP].addr;</a>
<a name="ln100">		nhrp_interface_update(nifp-&gt;ifp);</a>
<a name="ln101">		notifier_call(&amp;nifp-&gt;notifier_list, NOTIFY_INTERFACE_NBMA_CHANGED);</a>
<a name="ln102">		debugf(NHRP_DEBUG_IF, &quot;%s: NBMA change: address %s&quot;,</a>
<a name="ln103">			nifp-&gt;ifp-&gt;name,</a>
<a name="ln104">			sockunion2str(&amp;nifp-&gt;nbma, buf, sizeof buf));</a>
<a name="ln105">		break;</a>
<a name="ln106">	}</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">static void nhrp_interface_update_nbma(struct interface *ifp)</a>
<a name="ln110">{</a>
<a name="ln111">	struct nhrp_interface *nifp = ifp-&gt;info, *nbmanifp = NULL;</a>
<a name="ln112">	struct interface *nbmaifp = NULL;</a>
<a name="ln113">	union sockunion nbma;</a>
<a name="ln114"> </a>
<a name="ln115">	sockunion_family(&amp;nbma) = AF_UNSPEC;</a>
<a name="ln116"> </a>
<a name="ln117">	if (nifp-&gt;source)</a>
<a name="ln118">		nbmaifp = if_lookup_by_name(nifp-&gt;source);</a>
<a name="ln119"> </a>
<a name="ln120">	switch (ifp-&gt;ll_type) {</a>
<a name="ln121">	case ZEBRA_LLT_IPGRE: {</a>
<a name="ln122">			struct in_addr saddr = {0};</a>
<a name="ln123">			netlink_gre_get_info(ifp-&gt;ifindex, &amp;nifp-&gt;grekey, &amp;nifp-&gt;linkidx, &amp;saddr);</a>
<a name="ln124">			debugf(NHRP_DEBUG_IF, &quot;%s: GRE: %x %x %x&quot;, ifp-&gt;name, nifp-&gt;grekey, nifp-&gt;linkidx, saddr.s_addr);</a>
<a name="ln125">			if (saddr.s_addr)</a>
<a name="ln126">				sockunion_set(&amp;nbma, AF_INET, (u_char *) &amp;saddr.s_addr, sizeof(saddr.s_addr));</a>
<a name="ln127">			else if (!nbmaifp &amp;&amp; nifp-&gt;linkidx != IFINDEX_INTERNAL)</a>
<a name="ln128">				nbmaifp = if_lookup_by_index(nifp-&gt;linkidx);</a>
<a name="ln129">		}</a>
<a name="ln130">		break;</a>
<a name="ln131">	default:</a>
<a name="ln132">		break;</a>
<a name="ln133">	}</a>
<a name="ln134"> </a>
<a name="ln135">	if (nbmaifp)</a>
<a name="ln136">		nbmanifp = nbmaifp-&gt;info;</a>
<a name="ln137"> </a>
<a name="ln138">	if (nbmaifp != nifp-&gt;nbmaifp) {</a>
<a name="ln139">		if (nifp-&gt;nbmaifp)</a>
<a name="ln140">			notifier_del(&amp;nifp-&gt;nbmanifp_notifier);</a>
<a name="ln141">		nifp-&gt;nbmaifp = nbmaifp;</a>
<a name="ln142">		if (nbmaifp) {</a>
<a name="ln143">			notifier_add(&amp;nifp-&gt;nbmanifp_notifier, &amp;nbmanifp-&gt;notifier_list, nhrp_interface_interface_notifier);</a>
<a name="ln144">			debugf(NHRP_DEBUG_IF, &quot;%s: bound to %s&quot;, ifp-&gt;name, nbmaifp-&gt;name);</a>
<a name="ln145">		}</a>
<a name="ln146">	}</a>
<a name="ln147"> </a>
<a name="ln148">	if (nbmaifp) {</a>
<a name="ln149">		if (sockunion_family(&amp;nbma) == AF_UNSPEC)</a>
<a name="ln150">			nbma = nbmanifp-&gt;afi[AFI_IP].addr;</a>
<a name="ln151">		nhrp_interface_update_mtu(ifp, AFI_IP);</a>
<a name="ln152">		nhrp_interface_update_source(ifp);</a>
<a name="ln153">	}</a>
<a name="ln154"> </a>
<a name="ln155">	if (!sockunion_same(&amp;nbma, &amp;nifp-&gt;nbma)) {</a>
<a name="ln156">		nifp-&gt;nbma = nbma;</a>
<a name="ln157">		nhrp_interface_update(nifp-&gt;ifp);</a>
<a name="ln158">		debugf(NHRP_DEBUG_IF, &quot;%s: NBMA address changed&quot;, ifp-&gt;name);</a>
<a name="ln159">		notifier_call(&amp;nifp-&gt;notifier_list, NOTIFY_INTERFACE_NBMA_CHANGED);</a>
<a name="ln160">	}</a>
<a name="ln161"> </a>
<a name="ln162">	nhrp_interface_update(ifp);</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">static void nhrp_interface_update_address(struct interface *ifp, afi_t afi, int force)</a>
<a name="ln166">{</a>
<a name="ln167">	const int family = afi2family(afi);</a>
<a name="ln168">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln169">	struct nhrp_afi_data *if_ad = &amp;nifp-&gt;afi[afi];</a>
<a name="ln170">	struct nhrp_cache *nc;</a>
<a name="ln171">	struct connected *c, *best;</a>
<a name="ln172">	struct listnode *cnode;</a>
<a name="ln173">	union sockunion addr;</a>
<a name="ln174">	char buf[PREFIX_STRLEN];</a>
<a name="ln175"> </a>
<a name="ln176">	/* Select new best match preferring primary address */</a>
<a name="ln177">	best = NULL;</a>
<a name="ln178">	for (ALL_LIST_ELEMENTS_RO(ifp-&gt;connected, cnode, c)) {</a>
<a name="ln179">		if (PREFIX_FAMILY(c-&gt;address) != family)</a>
<a name="ln180">			continue;</a>
<a name="ln181">		if (best == NULL) {</a>
<a name="ln182">			best = c;</a>
<a name="ln183">			continue;</a>
<a name="ln184">		}</a>
<a name="ln185">		if ((best-&gt;flags &amp; ZEBRA_IFA_SECONDARY) &amp;&amp; !(c-&gt;flags &amp; ZEBRA_IFA_SECONDARY)) {</a>
<a name="ln186">			best = c;</a>
<a name="ln187">			continue;</a>
<a name="ln188">		}</a>
<a name="ln189">		if (!(best-&gt;flags &amp; ZEBRA_IFA_SECONDARY) &amp;&amp; (c-&gt;flags &amp; ZEBRA_IFA_SECONDARY))</a>
<a name="ln190">			continue;</a>
<a name="ln191">		if (best-&gt;address-&gt;prefixlen &gt; c-&gt;address-&gt;prefixlen) {</a>
<a name="ln192">			best = c;</a>
<a name="ln193">			continue;</a>
<a name="ln194">		}</a>
<a name="ln195">		if (best-&gt;address-&gt;prefixlen &lt; c-&gt;address-&gt;prefixlen)</a>
<a name="ln196">			continue;</a>
<a name="ln197">	}</a>
<a name="ln198"> </a>
<a name="ln199">	/* On NHRP interfaces a host prefix is required */</a>
<a name="ln200">	if (best &amp;&amp; if_ad-&gt;configured &amp;&amp; best-&gt;address-&gt;prefixlen != 8 * prefix_blen(best-&gt;address)) {</a>
<a name="ln201">		zlog_notice(&quot;%s: %s is not a host prefix&quot;, ifp-&gt;name,</a>
<a name="ln202">			prefix2str(best-&gt;address, buf, sizeof buf));</a>
<a name="ln203">		best = NULL;</a>
<a name="ln204">	}</a>
<a name="ln205"> </a>
<a name="ln206">	/* Update address if it changed */</a>
<a name="ln207">	if (best)</a>
<a name="ln208">		prefix2sockunion(best-&gt;address, &amp;addr);</a>
<a name="ln209">	else</a>
<a name="ln210">		memset(&amp;addr, 0, sizeof(addr));</a>
<a name="ln211"> </a>
<a name="ln212">	if (!force &amp;&amp; sockunion_same(&amp;if_ad-&gt;addr, &amp;addr))</a>
<a name="ln213">		return;</a>
<a name="ln214"> </a>
<a name="ln215">	if (sockunion_family(&amp;if_ad-&gt;addr) != AF_UNSPEC) {</a>
<a name="ln216">		nc = nhrp_cache_get(ifp, &amp;if_ad-&gt;addr, 0);</a>
<a name="ln217">		if (nc) nhrp_cache_update_binding(nc, NHRP_CACHE_LOCAL, -1, NULL, 0, NULL);</a>
<a name="ln218">	}</a>
<a name="ln219"> </a>
<a name="ln220">	debugf(NHRP_DEBUG_KERNEL, &quot;%s: IPv%d address changed to %s&quot;,</a>
<a name="ln221">		ifp-&gt;name, afi == AFI_IP ? 4 : 6,</a>
<a name="ln222">		best ? prefix2str(best-&gt;address, buf, sizeof buf) : &quot;(none)&quot;);</a>
<a name="ln223">	if_ad-&gt;addr = addr;</a>
<a name="ln224"> </a>
<a name="ln225">	if (if_ad-&gt;configured &amp;&amp; sockunion_family(&amp;if_ad-&gt;addr) != AF_UNSPEC) {</a>
<a name="ln226">		nc = nhrp_cache_get(ifp, &amp;addr, 1);</a>
<a name="ln227">		if (nc) nhrp_cache_update_binding(nc, NHRP_CACHE_LOCAL, 0, NULL, 0, NULL);</a>
<a name="ln228">	}</a>
<a name="ln229"> </a>
<a name="ln230">	notifier_call(&amp;nifp-&gt;notifier_list, NOTIFY_INTERFACE_ADDRESS_CHANGED);</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">void nhrp_interface_update(struct interface *ifp)</a>
<a name="ln234">{</a>
<a name="ln235">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln236">	struct nhrp_afi_data *if_ad;</a>
<a name="ln237">	afi_t afi;</a>
<a name="ln238">	int enabled = 0;</a>
<a name="ln239"> </a>
<a name="ln240">	notifier_call(&amp;nifp-&gt;notifier_list, NOTIFY_INTERFACE_CHANGED);</a>
<a name="ln241"> </a>
<a name="ln242">	for (afi = 0; afi &lt; AFI_MAX; afi++) {</a>
<a name="ln243">		if_ad = &amp;nifp-&gt;afi[afi];</a>
<a name="ln244"> </a>
<a name="ln245">		if (sockunion_family(&amp;nifp-&gt;nbma) == AF_UNSPEC ||</a>
<a name="ln246">		    ifp-&gt;ifindex == IFINDEX_INTERNAL || !if_is_up(ifp) ||</a>
<a name="ln247">		    !if_ad-&gt;network_id) {</a>
<a name="ln248">			if (if_ad-&gt;configured) {</a>
<a name="ln249">				if_ad-&gt;configured = 0;</a>
<a name="ln250">				nhrp_interface_update_address(ifp, afi, 1);</a>
<a name="ln251">			}</a>
<a name="ln252">			continue;</a>
<a name="ln253">		}</a>
<a name="ln254"> </a>
<a name="ln255">		if (!if_ad-&gt;configured) {</a>
<a name="ln256">			os_configure_dmvpn(ifp-&gt;ifindex, ifp-&gt;name, afi2family(afi));</a>
<a name="ln257">			if_ad-&gt;configured = 1;</a>
<a name="ln258">			nhrp_interface_update_address(ifp, afi, 1);</a>
<a name="ln259">		}</a>
<a name="ln260"> </a>
<a name="ln261">		enabled = 1;</a>
<a name="ln262">	}</a>
<a name="ln263"> </a>
<a name="ln264">	if (enabled != nifp-&gt;enabled) {</a>
<a name="ln265">		nifp-&gt;enabled = enabled;</a>
<a name="ln266">		notifier_call(&amp;nifp-&gt;notifier_list, enabled ? NOTIFY_INTERFACE_UP : NOTIFY_INTERFACE_DOWN);</a>
<a name="ln267">	}</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">int nhrp_interface_add(int cmd, struct zclient *client, zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln271">{</a>
<a name="ln272">	struct interface *ifp;</a>
<a name="ln273"> </a>
<a name="ln274">	/* read and add the interface in the iflist. */</a>
<a name="ln275">	ifp = zebra_interface_add_read(client-&gt;ibuf, vrf_id);</a>
<a name="ln276">	if (ifp == NULL)</a>
<a name="ln277">		return 0;</a>
<a name="ln278"> </a>
<a name="ln279">	debugf(NHRP_DEBUG_IF, &quot;if-add: %s, ifindex: %u, hw_type: %d %s&quot;,</a>
<a name="ln280">		ifp-&gt;name, ifp-&gt;ifindex,</a>
<a name="ln281">		ifp-&gt;ll_type, if_link_type_str(ifp-&gt;ll_type));</a>
<a name="ln282"> </a>
<a name="ln283">	nhrp_interface_update_nbma(ifp);</a>
<a name="ln284"> </a>
<a name="ln285">	return 0;</a>
<a name="ln286">}</a>
<a name="ln287"> </a>
<a name="ln288">int nhrp_interface_delete(int cmd, struct zclient *client,</a>
<a name="ln289">			  zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln290">{</a>
<a name="ln291">	struct interface *ifp;</a>
<a name="ln292">	struct stream *s;</a>
<a name="ln293"> </a>
<a name="ln294">	s = client-&gt;ibuf;</a>
<a name="ln295">	ifp = zebra_interface_state_read(s, vrf_id);</a>
<a name="ln296">	if (ifp == NULL)</a>
<a name="ln297">		return 0;</a>
<a name="ln298"> </a>
<a name="ln299">	debugf(NHRP_DEBUG_IF, &quot;if-delete: %s&quot;, ifp-&gt;name);</a>
<a name="ln300">	ifp-&gt;ifindex = IFINDEX_INTERNAL;</a>
<a name="ln301">	nhrp_interface_update(ifp);</a>
<a name="ln302">	/* if_delete(ifp); */</a>
<a name="ln303">	return 0;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">int nhrp_interface_up(int cmd, struct zclient *client,</a>
<a name="ln307">		      zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln308">{</a>
<a name="ln309">	struct interface *ifp;</a>
<a name="ln310"> </a>
<a name="ln311">	ifp = zebra_interface_state_read(client-&gt;ibuf, vrf_id);</a>
<a name="ln312">	if (ifp == NULL)</a>
<a name="ln313">		return 0;</a>
<a name="ln314"> </a>
<a name="ln315">	debugf(NHRP_DEBUG_IF, &quot;if-up: %s&quot;, ifp-&gt;name);</a>
<a name="ln316">	nhrp_interface_update_nbma(ifp);</a>
<a name="ln317"> </a>
<a name="ln318">	return 0;</a>
<a name="ln319">}</a>
<a name="ln320"> </a>
<a name="ln321">int nhrp_interface_down(int cmd, struct zclient *client,</a>
<a name="ln322">			zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln323">{</a>
<a name="ln324">	struct interface *ifp;</a>
<a name="ln325"> </a>
<a name="ln326">	ifp = zebra_interface_state_read(client-&gt;ibuf, vrf_id);</a>
<a name="ln327">	if (ifp == NULL)</a>
<a name="ln328">		return 0;</a>
<a name="ln329"> </a>
<a name="ln330">	debugf(NHRP_DEBUG_IF, &quot;if-down: %s&quot;, ifp-&gt;name);</a>
<a name="ln331">	nhrp_interface_update(ifp);</a>
<a name="ln332">	return 0;</a>
<a name="ln333">}</a>
<a name="ln334"> </a>
<a name="ln335">int nhrp_interface_address_add(int cmd, struct zclient *client,</a>
<a name="ln336">			       zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln337">{</a>
<a name="ln338">	struct connected *ifc;</a>
<a name="ln339">	char buf[PREFIX_STRLEN];</a>
<a name="ln340"> </a>
<a name="ln341">	ifc = zebra_interface_address_read(cmd, client-&gt;ibuf, vrf_id);</a>
<a name="ln342">	if (ifc == NULL)</a>
<a name="ln343">		return 0;</a>
<a name="ln344"> </a>
<a name="ln345">	debugf(NHRP_DEBUG_IF, &quot;if-addr-add: %s: %s&quot;,</a>
<a name="ln346">		ifc-&gt;ifp-&gt;name,</a>
<a name="ln347">		prefix2str(ifc-&gt;address, buf, sizeof buf));</a>
<a name="ln348"> </a>
<a name="ln349">	nhrp_interface_update_address(ifc-&gt;ifp, family2afi(PREFIX_FAMILY(ifc-&gt;address)), 0);</a>
<a name="ln350"> </a>
<a name="ln351">	return 0;</a>
<a name="ln352">}</a>
<a name="ln353"> </a>
<a name="ln354">int nhrp_interface_address_delete(int cmd, struct zclient *client,</a>
<a name="ln355">				  zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln356">{</a>
<a name="ln357">	struct connected *ifc;</a>
<a name="ln358">	char buf[PREFIX_STRLEN];</a>
<a name="ln359"> </a>
<a name="ln360">	ifc = zebra_interface_address_read(cmd, client-&gt;ibuf, vrf_id);</a>
<a name="ln361">	if (ifc == NULL)</a>
<a name="ln362">		return 0;</a>
<a name="ln363"> </a>
<a name="ln364">	debugf(NHRP_DEBUG_IF, &quot;if-addr-del: %s: %s&quot;,</a>
<a name="ln365">		ifc-&gt;ifp-&gt;name,</a>
<a name="ln366">		prefix2str(ifc-&gt;address, buf, sizeof buf));</a>
<a name="ln367"> </a>
<a name="ln368">	nhrp_interface_update_address(ifc-&gt;ifp, family2afi(PREFIX_FAMILY(ifc-&gt;address)), 0);</a>
<a name="ln369">	connected_free(ifc);</a>
<a name="ln370"> </a>
<a name="ln371">	return 0;</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">void nhrp_interface_notify_add(struct interface *ifp, struct notifier_block *n, notifier_fn_t fn)</a>
<a name="ln375">{</a>
<a name="ln376">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln377">	notifier_add(n, &amp;nifp-&gt;notifier_list, fn);</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">void nhrp_interface_notify_del(struct interface *ifp, struct notifier_block *n)</a>
<a name="ln381">{</a>
<a name="ln382">	notifier_del(n);</a>
<a name="ln383">}</a>
<a name="ln384"> </a>
<a name="ln385">void nhrp_interface_set_protection(struct interface *ifp, const char *profile, const char *fallback_profile)</a>
<a name="ln386">{</a>
<a name="ln387">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln388"> </a>
<a name="ln389">	if (nifp-&gt;ipsec_profile) free(nifp-&gt;ipsec_profile);</a>
<a name="ln390">	nifp-&gt;ipsec_profile = profile ? strdup(profile) : NULL;</a>
<a name="ln391"> </a>
<a name="ln392">	if (nifp-&gt;ipsec_fallback_profile) free(nifp-&gt;ipsec_fallback_profile);</a>
<a name="ln393">	nifp-&gt;ipsec_fallback_profile = fallback_profile ? strdup(fallback_profile) : NULL;</a>
<a name="ln394"> </a>
<a name="ln395">	notifier_call(&amp;nifp-&gt;notifier_list, NOTIFY_INTERFACE_ADDRESS_CHANGED);</a>
<a name="ln396">}</a>
<a name="ln397"> </a>
<a name="ln398">void nhrp_interface_set_source(struct interface *ifp, const char *ifname)</a>
<a name="ln399">{</a>
<a name="ln400">	struct nhrp_interface *nifp = ifp-&gt;info;</a>
<a name="ln401"> </a>
<a name="ln402">	if (nifp-&gt;source) free(nifp-&gt;source);</a>
<a name="ln403">	nifp-&gt;source = ifname ? strdup(ifname) : NULL;</a>
<a name="ln404"> </a>
<a name="ln405">	nhrp_interface_update_nbma(ifp);</a>
<a name="ln406">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="392"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'nifp->ipsec_profile' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
