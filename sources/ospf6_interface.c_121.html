
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf6_interface.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Copyright (C) 2003 Yasuhiro Ohara</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the </a>
<a name="ln18"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330, </a>
<a name="ln19"> * Boston, MA 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;memory.h&quot;</a>
<a name="ln25">#include &quot;if.h&quot;</a>
<a name="ln26">#include &quot;log.h&quot;</a>
<a name="ln27">#include &quot;command.h&quot;</a>
<a name="ln28">#include &quot;thread.h&quot;</a>
<a name="ln29">#include &quot;prefix.h&quot;</a>
<a name="ln30">#include &quot;plist.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">#include &quot;ospf6_lsa.h&quot;</a>
<a name="ln33">#include &quot;ospf6_lsdb.h&quot;</a>
<a name="ln34">#include &quot;ospf6_network.h&quot;</a>
<a name="ln35">#include &quot;ospf6_message.h&quot;</a>
<a name="ln36">#include &quot;ospf6_route.h&quot;</a>
<a name="ln37">#include &quot;ospf6_top.h&quot;</a>
<a name="ln38">#include &quot;ospf6_area.h&quot;</a>
<a name="ln39">#include &quot;ospf6_interface.h&quot;</a>
<a name="ln40">#include &quot;ospf6_neighbor.h&quot;</a>
<a name="ln41">#include &quot;ospf6_intra.h&quot;</a>
<a name="ln42">#include &quot;ospf6_spf.h&quot;</a>
<a name="ln43">#include &quot;ospf6_snmp.h&quot;</a>
<a name="ln44">#include &quot;ospf6d.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">unsigned char conf_debug_ospf6_interface = 0;</a>
<a name="ln47"> </a>
<a name="ln48">const char *ospf6_interface_state_str[] =</a>
<a name="ln49">{</a>
<a name="ln50">  &quot;None&quot;,</a>
<a name="ln51">  &quot;Down&quot;,</a>
<a name="ln52">  &quot;Loopback&quot;,</a>
<a name="ln53">  &quot;Waiting&quot;,</a>
<a name="ln54">  &quot;PointToPoint&quot;,</a>
<a name="ln55">  &quot;DROther&quot;,</a>
<a name="ln56">  &quot;BDR&quot;,</a>
<a name="ln57">  &quot;DR&quot;,</a>
<a name="ln58">  NULL</a>
<a name="ln59">};</a>
<a name="ln60"> </a>
<a name="ln61">struct ospf6_interface *</a>
<a name="ln62">ospf6_interface_lookup_by_ifindex (ifindex_t ifindex)</a>
<a name="ln63">{</a>
<a name="ln64">  struct ospf6_interface *oi;</a>
<a name="ln65">  struct interface *ifp;</a>
<a name="ln66"> </a>
<a name="ln67">  ifp = if_lookup_by_index (ifindex);</a>
<a name="ln68">  if (ifp == NULL)</a>
<a name="ln69">    return (struct ospf6_interface *) NULL;</a>
<a name="ln70"> </a>
<a name="ln71">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln72">  return oi;</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">/* schedule routing table recalculation */</a>
<a name="ln76">static void</a>
<a name="ln77">ospf6_interface_lsdb_hook (struct ospf6_lsa *lsa, unsigned int reason)</a>
<a name="ln78">{</a>
<a name="ln79">  struct ospf6_interface *oi;</a>
<a name="ln80"> </a>
<a name="ln81">  if (lsa == NULL)</a>
<a name="ln82">    return;</a>
<a name="ln83"> </a>
<a name="ln84">  oi = lsa-&gt;lsdb-&gt;data;</a>
<a name="ln85">  switch (ntohs (lsa-&gt;header-&gt;type))</a>
<a name="ln86">    {</a>
<a name="ln87">      case OSPF6_LSTYPE_LINK:</a>
<a name="ln88">        if (oi-&gt;state == OSPF6_INTERFACE_DR)</a>
<a name="ln89">          OSPF6_INTRA_PREFIX_LSA_SCHEDULE_TRANSIT (oi);</a>
<a name="ln90">        ospf6_spf_schedule (oi-&gt;area-&gt;ospf6, reason);</a>
<a name="ln91">        break;</a>
<a name="ln92"> </a>
<a name="ln93">      default:</a>
<a name="ln94">        break;</a>
<a name="ln95">    }</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">static void</a>
<a name="ln99">ospf6_interface_lsdb_hook_add (struct ospf6_lsa *lsa)</a>
<a name="ln100">{</a>
<a name="ln101">  ospf6_interface_lsdb_hook(lsa, ospf6_lsadd_to_spf_reason(lsa));</a>
<a name="ln102">}</a>
<a name="ln103"> </a>
<a name="ln104">static void</a>
<a name="ln105">ospf6_interface_lsdb_hook_remove (struct ospf6_lsa *lsa)</a>
<a name="ln106">{</a>
<a name="ln107">  ospf6_interface_lsdb_hook(lsa, ospf6_lsremove_to_spf_reason(lsa));</a>
<a name="ln108">}</a>
<a name="ln109"> </a>
<a name="ln110">static u_char</a>
<a name="ln111">ospf6_default_iftype(struct interface *ifp)</a>
<a name="ln112">{</a>
<a name="ln113">  if (if_is_pointopoint (ifp))</a>
<a name="ln114">    return OSPF_IFTYPE_POINTOPOINT;</a>
<a name="ln115">  else if (if_is_loopback (ifp))</a>
<a name="ln116">    return OSPF_IFTYPE_LOOPBACK;</a>
<a name="ln117">  else</a>
<a name="ln118">    return OSPF_IFTYPE_BROADCAST;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">static u_int32_t</a>
<a name="ln122">ospf6_interface_get_cost (struct ospf6_interface *oi)</a>
<a name="ln123">{</a>
<a name="ln124">  /* If all else fails, use default OSPF cost */</a>
<a name="ln125">  u_int32_t cost;</a>
<a name="ln126">  u_int32_t bw, refbw;</a>
<a name="ln127"> </a>
<a name="ln128">  bw = oi-&gt;interface-&gt;bandwidth ? oi-&gt;interface-&gt;bandwidth : OSPF6_INTERFACE_BANDWIDTH;</a>
<a name="ln129">  refbw = ospf6 ? ospf6-&gt;ref_bandwidth : OSPF6_REFERENCE_BANDWIDTH;</a>
<a name="ln130"> </a>
<a name="ln131">  /* A specifed ip ospf cost overrides a calculated one. */</a>
<a name="ln132">  if (CHECK_FLAG (oi-&gt;flag, OSPF6_INTERFACE_NOAUTOCOST))</a>
<a name="ln133">    cost = oi-&gt;cost;</a>
<a name="ln134">  else</a>
<a name="ln135">    {</a>
<a name="ln136">      cost = (u_int32_t) ((double)refbw / (double)bw + (double)0.5);</a>
<a name="ln137">      if (cost &lt; 1) cost = 1;</a>
<a name="ln138">      else if (cost &gt; UINT32_MAX) cost = UINT32_MAX;</a>
<a name="ln139">    }</a>
<a name="ln140"> </a>
<a name="ln141">  return cost;</a>
<a name="ln142">}</a>
<a name="ln143"> </a>
<a name="ln144">static void</a>
<a name="ln145">ospf6_interface_recalculate_cost (struct ospf6_interface *oi)</a>
<a name="ln146">{</a>
<a name="ln147">  u_int32_t newcost;</a>
<a name="ln148"> </a>
<a name="ln149">  newcost = ospf6_interface_get_cost (oi);</a>
<a name="ln150">  if (newcost == oi-&gt;cost) return;</a>
<a name="ln151">  oi-&gt;cost = newcost;</a>
<a name="ln152"> </a>
<a name="ln153">  /* update cost held in route_connected list in ospf6_interface */</a>
<a name="ln154">  ospf6_interface_connected_route_update (oi-&gt;interface);</a>
<a name="ln155"> </a>
<a name="ln156">  /* execute LSA hooks */</a>
<a name="ln157">  if (oi-&gt;area)</a>
<a name="ln158">    {</a>
<a name="ln159">      OSPF6_LINK_LSA_SCHEDULE (oi);</a>
<a name="ln160">      OSPF6_ROUTER_LSA_SCHEDULE (oi-&gt;area);</a>
<a name="ln161">      OSPF6_NETWORK_LSA_SCHEDULE (oi);</a>
<a name="ln162">      OSPF6_INTRA_PREFIX_LSA_SCHEDULE_TRANSIT (oi);</a>
<a name="ln163">      OSPF6_INTRA_PREFIX_LSA_SCHEDULE_STUB (oi-&gt;area);</a>
<a name="ln164">    }</a>
<a name="ln165">}</a>
<a name="ln166"> </a>
<a name="ln167">/* Create new ospf6 interface structure */</a>
<a name="ln168">struct ospf6_interface *</a>
<a name="ln169">ospf6_interface_create (struct interface *ifp)</a>
<a name="ln170">{</a>
<a name="ln171">  struct ospf6_interface *oi;</a>
<a name="ln172">  unsigned int iobuflen;</a>
<a name="ln173"> </a>
<a name="ln174">  oi = (struct ospf6_interface *)</a>
<a name="ln175">    XCALLOC (MTYPE_OSPF6_IF, sizeof (struct ospf6_interface));</a>
<a name="ln176"> </a>
<a name="ln177">  if (!oi)</a>
<a name="ln178">    {</a>
<a name="ln179">      zlog_err (&quot;Can't malloc ospf6_interface for ifindex %d&quot;, ifp-&gt;ifindex);</a>
<a name="ln180">      return (struct ospf6_interface *) NULL;</a>
<a name="ln181">    }</a>
<a name="ln182"> </a>
<a name="ln183">  oi-&gt;area = (struct ospf6_area *) NULL;</a>
<a name="ln184">  oi-&gt;neighbor_list = list_new ();</a>
<a name="ln185">  oi-&gt;neighbor_list-&gt;cmp = ospf6_neighbor_cmp;</a>
<a name="ln186">  oi-&gt;linklocal_addr = (struct in6_addr *) NULL;</a>
<a name="ln187">  oi-&gt;instance_id = OSPF6_INTERFACE_INSTANCE_ID;</a>
<a name="ln188">  oi-&gt;transdelay = OSPF6_INTERFACE_TRANSDELAY;</a>
<a name="ln189">  oi-&gt;priority = OSPF6_INTERFACE_PRIORITY;</a>
<a name="ln190"> </a>
<a name="ln191">  oi-&gt;hello_interval = OSPF_HELLO_INTERVAL_DEFAULT;</a>
<a name="ln192">  oi-&gt;dead_interval = OSPF_ROUTER_DEAD_INTERVAL_DEFAULT;</a>
<a name="ln193">  oi-&gt;rxmt_interval = OSPF_RETRANSMIT_INTERVAL_DEFAULT;</a>
<a name="ln194">  oi-&gt;type = ospf6_default_iftype (ifp);</a>
<a name="ln195">  oi-&gt;state = OSPF6_INTERFACE_DOWN;</a>
<a name="ln196">  oi-&gt;flag = 0;</a>
<a name="ln197">  oi-&gt;mtu_ignore = 0;</a>
<a name="ln198"> </a>
<a name="ln199">  /* Try to adjust I/O buffer size with IfMtu */</a>
<a name="ln200">  oi-&gt;ifmtu = ifp-&gt;mtu6;</a>
<a name="ln201">  iobuflen = ospf6_iobuf_size (ifp-&gt;mtu6);</a>
<a name="ln202">  if (oi-&gt;ifmtu &gt; iobuflen)</a>
<a name="ln203">    {</a>
<a name="ln204">      if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln205">        zlog_debug (&quot;Interface %s: IfMtu is adjusted to I/O buffer size: %d.&quot;,</a>
<a name="ln206">		    ifp-&gt;name, iobuflen);</a>
<a name="ln207">      oi-&gt;ifmtu = iobuflen;</a>
<a name="ln208">    }</a>
<a name="ln209"> </a>
<a name="ln210">  oi-&gt;lsupdate_list = ospf6_lsdb_create (oi);</a>
<a name="ln211">  oi-&gt;lsack_list = ospf6_lsdb_create (oi);</a>
<a name="ln212">  oi-&gt;lsdb = ospf6_lsdb_create (oi);</a>
<a name="ln213">  oi-&gt;lsdb-&gt;hook_add = ospf6_interface_lsdb_hook_add;</a>
<a name="ln214">  oi-&gt;lsdb-&gt;hook_remove = ospf6_interface_lsdb_hook_remove;</a>
<a name="ln215">  oi-&gt;lsdb_self = ospf6_lsdb_create (oi);</a>
<a name="ln216"> </a>
<a name="ln217">  oi-&gt;route_connected = OSPF6_ROUTE_TABLE_CREATE (INTERFACE, CONNECTED_ROUTES);</a>
<a name="ln218">  oi-&gt;route_connected-&gt;scope = oi;</a>
<a name="ln219"> </a>
<a name="ln220">  /* link both */</a>
<a name="ln221">  oi-&gt;interface = ifp;</a>
<a name="ln222">  ifp-&gt;info = oi;</a>
<a name="ln223"> </a>
<a name="ln224">  /* Compute cost. */</a>
<a name="ln225">  oi-&gt;cost = ospf6_interface_get_cost(oi);</a>
<a name="ln226"> </a>
<a name="ln227">  return oi;</a>
<a name="ln228">}</a>
<a name="ln229"> </a>
<a name="ln230">void</a>
<a name="ln231">ospf6_interface_delete (struct ospf6_interface *oi)</a>
<a name="ln232">{</a>
<a name="ln233">  struct listnode *node, *nnode;</a>
<a name="ln234">  struct ospf6_neighbor *on;</a>
<a name="ln235"> </a>
<a name="ln236">  for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln237">      ospf6_neighbor_delete (on);</a>
<a name="ln238">  </a>
<a name="ln239">  list_delete (oi-&gt;neighbor_list);</a>
<a name="ln240"> </a>
<a name="ln241">  THREAD_OFF (oi-&gt;thread_send_hello);</a>
<a name="ln242">  THREAD_OFF (oi-&gt;thread_send_lsupdate);</a>
<a name="ln243">  THREAD_OFF (oi-&gt;thread_send_lsack);</a>
<a name="ln244"> </a>
<a name="ln245">  ospf6_lsdb_remove_all (oi-&gt;lsdb);</a>
<a name="ln246">  ospf6_lsdb_remove_all (oi-&gt;lsupdate_list);</a>
<a name="ln247">  ospf6_lsdb_remove_all (oi-&gt;lsack_list);</a>
<a name="ln248"> </a>
<a name="ln249">  ospf6_lsdb_delete (oi-&gt;lsdb);</a>
<a name="ln250">  ospf6_lsdb_delete (oi-&gt;lsdb_self);</a>
<a name="ln251"> </a>
<a name="ln252">  ospf6_lsdb_delete (oi-&gt;lsupdate_list);</a>
<a name="ln253">  ospf6_lsdb_delete (oi-&gt;lsack_list);</a>
<a name="ln254"> </a>
<a name="ln255">  ospf6_route_table_delete (oi-&gt;route_connected);</a>
<a name="ln256"> </a>
<a name="ln257">  /* cut link */</a>
<a name="ln258">  oi-&gt;interface-&gt;info = NULL;</a>
<a name="ln259"> </a>
<a name="ln260">  /* plist_name */</a>
<a name="ln261">  if (oi-&gt;plist_name)</a>
<a name="ln262">    XFREE (MTYPE_PREFIX_LIST_STR, oi-&gt;plist_name);</a>
<a name="ln263"> </a>
<a name="ln264">  XFREE (MTYPE_OSPF6_IF, oi);</a>
<a name="ln265">}</a>
<a name="ln266"> </a>
<a name="ln267">void</a>
<a name="ln268">ospf6_interface_enable (struct ospf6_interface *oi)</a>
<a name="ln269">{</a>
<a name="ln270">  UNSET_FLAG (oi-&gt;flag, OSPF6_INTERFACE_DISABLE);</a>
<a name="ln271">  ospf6_interface_state_update (oi-&gt;interface);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">void</a>
<a name="ln275">ospf6_interface_disable (struct ospf6_interface *oi)</a>
<a name="ln276">{</a>
<a name="ln277">  SET_FLAG (oi-&gt;flag, OSPF6_INTERFACE_DISABLE);</a>
<a name="ln278"> </a>
<a name="ln279">  thread_execute (master, interface_down, oi, 0);</a>
<a name="ln280"> </a>
<a name="ln281">  ospf6_lsdb_remove_all (oi-&gt;lsdb);</a>
<a name="ln282">  ospf6_lsdb_remove_all (oi-&gt;lsdb_self);</a>
<a name="ln283">  ospf6_lsdb_remove_all (oi-&gt;lsupdate_list);</a>
<a name="ln284">  ospf6_lsdb_remove_all (oi-&gt;lsack_list);</a>
<a name="ln285"> </a>
<a name="ln286">  THREAD_OFF (oi-&gt;thread_send_hello);</a>
<a name="ln287">  THREAD_OFF (oi-&gt;thread_send_lsupdate);</a>
<a name="ln288">  THREAD_OFF (oi-&gt;thread_send_lsack);</a>
<a name="ln289"> </a>
<a name="ln290">  THREAD_OFF (oi-&gt;thread_network_lsa);</a>
<a name="ln291">  THREAD_OFF (oi-&gt;thread_link_lsa);</a>
<a name="ln292">  THREAD_OFF (oi-&gt;thread_intra_prefix_lsa);</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">static struct in6_addr *</a>
<a name="ln296">ospf6_interface_get_linklocal_address (struct interface *ifp)</a>
<a name="ln297">{</a>
<a name="ln298">  struct listnode *n;</a>
<a name="ln299">  struct connected *c;</a>
<a name="ln300">  struct in6_addr *l = (struct in6_addr *) NULL;</a>
<a name="ln301"> </a>
<a name="ln302">  /* for each connected address */</a>
<a name="ln303">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, n, c))</a>
<a name="ln304">    {</a>
<a name="ln305">      /* if family not AF_INET6, ignore */</a>
<a name="ln306">      if (c-&gt;address-&gt;family != AF_INET6)</a>
<a name="ln307">        continue;</a>
<a name="ln308"> </a>
<a name="ln309">      /* linklocal scope check */</a>
<a name="ln310">      if (IN6_IS_ADDR_LINKLOCAL (&amp;c-&gt;address-&gt;u.prefix6))</a>
<a name="ln311">        l = &amp;c-&gt;address-&gt;u.prefix6;</a>
<a name="ln312">    }</a>
<a name="ln313">  return l;</a>
<a name="ln314">}</a>
<a name="ln315"> </a>
<a name="ln316">void</a>
<a name="ln317">ospf6_interface_if_add (struct interface *ifp)</a>
<a name="ln318">{</a>
<a name="ln319">  struct ospf6_interface *oi;</a>
<a name="ln320">  unsigned int iobuflen;</a>
<a name="ln321"> </a>
<a name="ln322">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln323">  if (oi == NULL)</a>
<a name="ln324">    return;</a>
<a name="ln325"> </a>
<a name="ln326">  /* Try to adjust I/O buffer size with IfMtu */</a>
<a name="ln327">  if (oi-&gt;ifmtu == 0)</a>
<a name="ln328">    oi-&gt;ifmtu = ifp-&gt;mtu6;</a>
<a name="ln329">  iobuflen = ospf6_iobuf_size (ifp-&gt;mtu6);</a>
<a name="ln330">  if (oi-&gt;ifmtu &gt; iobuflen)</a>
<a name="ln331">    {</a>
<a name="ln332">      if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln333">        zlog_debug (&quot;Interface %s: IfMtu is adjusted to I/O buffer size: %d.&quot;,</a>
<a name="ln334">		    ifp-&gt;name, iobuflen);</a>
<a name="ln335">      oi-&gt;ifmtu = iobuflen;</a>
<a name="ln336">    }</a>
<a name="ln337"> </a>
<a name="ln338">  /* interface start */</a>
<a name="ln339">  ospf6_interface_state_update(oi-&gt;interface);</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">void</a>
<a name="ln343">ospf6_interface_state_update (struct interface *ifp)</a>
<a name="ln344">{</a>
<a name="ln345">  struct ospf6_interface *oi;</a>
<a name="ln346"> </a>
<a name="ln347">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln348">  if (oi == NULL)</a>
<a name="ln349">    return;</a>
<a name="ln350">  if (oi-&gt;area == NULL)</a>
<a name="ln351">    return;</a>
<a name="ln352">  if (CHECK_FLAG (oi-&gt;flag, OSPF6_INTERFACE_DISABLE))</a>
<a name="ln353">    return;</a>
<a name="ln354"> </a>
<a name="ln355">  if (if_is_operative (ifp)</a>
<a name="ln356">      &amp;&amp; (ospf6_interface_get_linklocal_address(oi-&gt;interface)</a>
<a name="ln357">          || if_is_loopback(oi-&gt;interface)))</a>
<a name="ln358">    thread_add_event (master, interface_up, oi, 0);</a>
<a name="ln359">  else</a>
<a name="ln360">    thread_add_event (master, interface_down, oi, 0);</a>
<a name="ln361"> </a>
<a name="ln362">  return;</a>
<a name="ln363">}</a>
<a name="ln364"> </a>
<a name="ln365">void</a>
<a name="ln366">ospf6_interface_connected_route_update (struct interface *ifp)</a>
<a name="ln367">{</a>
<a name="ln368">  struct ospf6_interface *oi;</a>
<a name="ln369">  struct ospf6_route *route;</a>
<a name="ln370">  struct connected *c;</a>
<a name="ln371">  struct listnode *node, *nnode;</a>
<a name="ln372"> </a>
<a name="ln373">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln374">  if (oi == NULL)</a>
<a name="ln375">    return;</a>
<a name="ln376"> </a>
<a name="ln377">  /* reset linklocal pointer */</a>
<a name="ln378">  oi-&gt;linklocal_addr = ospf6_interface_get_linklocal_address (ifp);</a>
<a name="ln379"> </a>
<a name="ln380">  /* if area is null, do not make connected-route list */</a>
<a name="ln381">  if (oi-&gt;area == NULL)</a>
<a name="ln382">    return;</a>
<a name="ln383"> </a>
<a name="ln384">  if (CHECK_FLAG (oi-&gt;flag, OSPF6_INTERFACE_DISABLE))</a>
<a name="ln385">    return;</a>
<a name="ln386"> </a>
<a name="ln387">  /* update &quot;route to advertise&quot; interface route table */</a>
<a name="ln388">  ospf6_route_remove_all (oi-&gt;route_connected);</a>
<a name="ln389"> </a>
<a name="ln390">  for (ALL_LIST_ELEMENTS (oi-&gt;interface-&gt;connected, node, nnode, c))</a>
<a name="ln391">    {</a>
<a name="ln392">      if (c-&gt;address-&gt;family != AF_INET6)</a>
<a name="ln393">        continue;</a>
<a name="ln394"> </a>
<a name="ln395">      CONTINUE_IF_ADDRESS_LINKLOCAL (IS_OSPF6_DEBUG_INTERFACE, c-&gt;address);</a>
<a name="ln396">      CONTINUE_IF_ADDRESS_UNSPECIFIED (IS_OSPF6_DEBUG_INTERFACE, c-&gt;address);</a>
<a name="ln397">      CONTINUE_IF_ADDRESS_LOOPBACK (IS_OSPF6_DEBUG_INTERFACE, c-&gt;address);</a>
<a name="ln398">      CONTINUE_IF_ADDRESS_V4COMPAT (IS_OSPF6_DEBUG_INTERFACE, c-&gt;address);</a>
<a name="ln399">      CONTINUE_IF_ADDRESS_V4MAPPED (IS_OSPF6_DEBUG_INTERFACE, c-&gt;address);</a>
<a name="ln400"> </a>
<a name="ln401">      /* apply filter */</a>
<a name="ln402">      if (oi-&gt;plist_name)</a>
<a name="ln403">        {</a>
<a name="ln404">          struct prefix_list *plist;</a>
<a name="ln405">          enum prefix_list_type ret;</a>
<a name="ln406">          char buf[128];</a>
<a name="ln407"> </a>
<a name="ln408">          prefix2str (c-&gt;address, buf, sizeof (buf));</a>
<a name="ln409">          plist = prefix_list_lookup (AFI_IP6, oi-&gt;plist_name);</a>
<a name="ln410">          ret = prefix_list_apply (plist, (void *) c-&gt;address);</a>
<a name="ln411">          if (ret == PREFIX_DENY)</a>
<a name="ln412">            {</a>
<a name="ln413">              if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln414">                zlog_debug (&quot;%s on %s filtered by prefix-list %s &quot;,</a>
<a name="ln415">			    buf, oi-&gt;interface-&gt;name, oi-&gt;plist_name);</a>
<a name="ln416">              continue;</a>
<a name="ln417">            }</a>
<a name="ln418">        }</a>
<a name="ln419"> </a>
<a name="ln420">      route = ospf6_route_create ();</a>
<a name="ln421">      memcpy (&amp;route-&gt;prefix, c-&gt;address, sizeof (struct prefix));</a>
<a name="ln422">      apply_mask (&amp;route-&gt;prefix);</a>
<a name="ln423">      route-&gt;type = OSPF6_DEST_TYPE_NETWORK;</a>
<a name="ln424">      route-&gt;path.area_id = oi-&gt;area-&gt;area_id;</a>
<a name="ln425">      route-&gt;path.type = OSPF6_PATH_TYPE_INTRA;</a>
<a name="ln426">      route-&gt;path.cost = oi-&gt;cost;</a>
<a name="ln427">      route-&gt;nexthop[0].ifindex = oi-&gt;interface-&gt;ifindex;</a>
<a name="ln428">      inet_pton (AF_INET6, &quot;::1&quot;, &amp;route-&gt;nexthop[0].address);</a>
<a name="ln429">      ospf6_route_add (route, oi-&gt;route_connected);</a>
<a name="ln430">    }</a>
<a name="ln431"> </a>
<a name="ln432">  /* create new Link-LSA */</a>
<a name="ln433">  OSPF6_LINK_LSA_SCHEDULE (oi);</a>
<a name="ln434">  OSPF6_INTRA_PREFIX_LSA_SCHEDULE_TRANSIT (oi);</a>
<a name="ln435">  OSPF6_INTRA_PREFIX_LSA_SCHEDULE_STUB (oi-&gt;area);</a>
<a name="ln436">}</a>
<a name="ln437"> </a>
<a name="ln438">static void</a>
<a name="ln439">ospf6_interface_state_change (u_char next_state, struct ospf6_interface *oi)</a>
<a name="ln440">{</a>
<a name="ln441">  u_char prev_state;</a>
<a name="ln442"> </a>
<a name="ln443">  prev_state = oi-&gt;state;</a>
<a name="ln444">  oi-&gt;state = next_state;</a>
<a name="ln445"> </a>
<a name="ln446">  if (prev_state == next_state)</a>
<a name="ln447">    return;</a>
<a name="ln448"> </a>
<a name="ln449">  /* log */</a>
<a name="ln450">  if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln451">    {</a>
<a name="ln452">      zlog_debug (&quot;Interface state change %s: %s -&gt; %s&quot;, oi-&gt;interface-&gt;name,</a>
<a name="ln453">		  ospf6_interface_state_str[prev_state],</a>
<a name="ln454">		  ospf6_interface_state_str[next_state]);</a>
<a name="ln455">    }</a>
<a name="ln456">  oi-&gt;state_change++;</a>
<a name="ln457"> </a>
<a name="ln458">  if ((prev_state == OSPF6_INTERFACE_DR ||</a>
<a name="ln459">       prev_state == OSPF6_INTERFACE_BDR) &amp;&amp;</a>
<a name="ln460">      (next_state != OSPF6_INTERFACE_DR &amp;&amp;</a>
<a name="ln461">       next_state != OSPF6_INTERFACE_BDR))</a>
<a name="ln462">    ospf6_sso (oi-&gt;interface-&gt;ifindex, &amp;alldrouters6, IPV6_LEAVE_GROUP);</a>
<a name="ln463"> </a>
<a name="ln464">  if ((prev_state != OSPF6_INTERFACE_DR &amp;&amp;</a>
<a name="ln465">       prev_state != OSPF6_INTERFACE_BDR) &amp;&amp;</a>
<a name="ln466">      (next_state == OSPF6_INTERFACE_DR ||</a>
<a name="ln467">       next_state == OSPF6_INTERFACE_BDR))</a>
<a name="ln468">    ospf6_sso (oi-&gt;interface-&gt;ifindex, &amp;alldrouters6, IPV6_JOIN_GROUP);</a>
<a name="ln469"> </a>
<a name="ln470">  OSPF6_ROUTER_LSA_SCHEDULE (oi-&gt;area);</a>
<a name="ln471">  if (next_state == OSPF6_INTERFACE_DOWN)</a>
<a name="ln472">    {</a>
<a name="ln473">      OSPF6_NETWORK_LSA_EXECUTE (oi);</a>
<a name="ln474">      OSPF6_INTRA_PREFIX_LSA_EXECUTE_TRANSIT (oi);</a>
<a name="ln475">      OSPF6_INTRA_PREFIX_LSA_SCHEDULE_STUB (oi-&gt;area);</a>
<a name="ln476">    }</a>
<a name="ln477">  else if (prev_state == OSPF6_INTERFACE_DR ||</a>
<a name="ln478">           next_state == OSPF6_INTERFACE_DR)</a>
<a name="ln479">    {</a>
<a name="ln480">      OSPF6_NETWORK_LSA_SCHEDULE (oi);</a>
<a name="ln481">      OSPF6_INTRA_PREFIX_LSA_SCHEDULE_TRANSIT (oi);</a>
<a name="ln482">      OSPF6_INTRA_PREFIX_LSA_SCHEDULE_STUB (oi-&gt;area);</a>
<a name="ln483">    }</a>
<a name="ln484"> </a>
<a name="ln485">#ifdef HAVE_SNMP</a>
<a name="ln486">  /* Terminal state or regression */ </a>
<a name="ln487">  if ((next_state == OSPF6_INTERFACE_POINTTOPOINT) ||</a>
<a name="ln488">      (next_state == OSPF6_INTERFACE_DROTHER) ||</a>
<a name="ln489">      (next_state == OSPF6_INTERFACE_BDR) ||</a>
<a name="ln490">      (next_state == OSPF6_INTERFACE_DR) ||</a>
<a name="ln491">      (next_state &lt; prev_state))</a>
<a name="ln492">    ospf6TrapIfStateChange (oi);</a>
<a name="ln493">#endif</a>
<a name="ln494"> </a>
<a name="ln495">}</a>
<a name="ln496"> </a>
<a name="ln497"> </a>
<a name="ln498">/* DR Election, RFC2328 section 9.4 */</a>
<a name="ln499"> </a>
<a name="ln500">#define IS_ELIGIBLE(n) \</a>
<a name="ln501">  ((n)-&gt;state &gt;= OSPF6_NEIGHBOR_TWOWAY &amp;&amp; (n)-&gt;priority != 0)</a>
<a name="ln502"> </a>
<a name="ln503">static struct ospf6_neighbor *</a>
<a name="ln504">better_bdrouter (struct ospf6_neighbor *a, struct ospf6_neighbor *b)</a>
<a name="ln505">{</a>
<a name="ln506">  if ((a == NULL || ! IS_ELIGIBLE (a) || a-&gt;drouter == a-&gt;router_id) &amp;&amp;</a>
<a name="ln507">      (b == NULL || ! IS_ELIGIBLE (b) || b-&gt;drouter == b-&gt;router_id))</a>
<a name="ln508">    return NULL;</a>
<a name="ln509">  else if (a == NULL || ! IS_ELIGIBLE (a) || a-&gt;drouter == a-&gt;router_id)</a>
<a name="ln510">    return b;</a>
<a name="ln511">  else if (b == NULL || ! IS_ELIGIBLE (b) || b-&gt;drouter == b-&gt;router_id)</a>
<a name="ln512">    return a;</a>
<a name="ln513"> </a>
<a name="ln514">  if (a-&gt;bdrouter == a-&gt;router_id &amp;&amp; b-&gt;bdrouter != b-&gt;router_id)</a>
<a name="ln515">    return a;</a>
<a name="ln516">  if (a-&gt;bdrouter != a-&gt;router_id &amp;&amp; b-&gt;bdrouter == b-&gt;router_id)</a>
<a name="ln517">    return b;</a>
<a name="ln518"> </a>
<a name="ln519">  if (a-&gt;priority &gt; b-&gt;priority)</a>
<a name="ln520">    return a;</a>
<a name="ln521">  if (a-&gt;priority &lt; b-&gt;priority)</a>
<a name="ln522">    return b;</a>
<a name="ln523"> </a>
<a name="ln524">  if (ntohl (a-&gt;router_id) &gt; ntohl (b-&gt;router_id))</a>
<a name="ln525">    return a;</a>
<a name="ln526">  if (ntohl (a-&gt;router_id) &lt; ntohl (b-&gt;router_id))</a>
<a name="ln527">    return b;</a>
<a name="ln528"> </a>
<a name="ln529">  zlog_warn (&quot;Router-ID duplicate ?&quot;);</a>
<a name="ln530">  return a;</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533">static struct ospf6_neighbor *</a>
<a name="ln534">better_drouter (struct ospf6_neighbor *a, struct ospf6_neighbor *b)</a>
<a name="ln535">{</a>
<a name="ln536">  if ((a == NULL || ! IS_ELIGIBLE (a) || a-&gt;drouter != a-&gt;router_id) &amp;&amp;</a>
<a name="ln537">      (b == NULL || ! IS_ELIGIBLE (b) || b-&gt;drouter != b-&gt;router_id))</a>
<a name="ln538">    return NULL;</a>
<a name="ln539">  else if (a == NULL || ! IS_ELIGIBLE (a) || a-&gt;drouter != a-&gt;router_id)</a>
<a name="ln540">    return b;</a>
<a name="ln541">  else if (b == NULL || ! IS_ELIGIBLE (b) || b-&gt;drouter != b-&gt;router_id)</a>
<a name="ln542">    return a;</a>
<a name="ln543"> </a>
<a name="ln544">  if (a-&gt;drouter == a-&gt;router_id &amp;&amp; b-&gt;drouter != b-&gt;router_id)</a>
<a name="ln545">    return a;</a>
<a name="ln546">  if (a-&gt;drouter != a-&gt;router_id &amp;&amp; b-&gt;drouter == b-&gt;router_id)</a>
<a name="ln547">    return b;</a>
<a name="ln548"> </a>
<a name="ln549">  if (a-&gt;priority &gt; b-&gt;priority)</a>
<a name="ln550">    return a;</a>
<a name="ln551">  if (a-&gt;priority &lt; b-&gt;priority)</a>
<a name="ln552">    return b;</a>
<a name="ln553"> </a>
<a name="ln554">  if (ntohl (a-&gt;router_id) &gt; ntohl (b-&gt;router_id))</a>
<a name="ln555">    return a;</a>
<a name="ln556">  if (ntohl (a-&gt;router_id) &lt; ntohl (b-&gt;router_id))</a>
<a name="ln557">    return b;</a>
<a name="ln558"> </a>
<a name="ln559">  zlog_warn (&quot;Router-ID duplicate ?&quot;);</a>
<a name="ln560">  return a;</a>
<a name="ln561">}</a>
<a name="ln562"> </a>
<a name="ln563">static u_char</a>
<a name="ln564">dr_election (struct ospf6_interface *oi)</a>
<a name="ln565">{</a>
<a name="ln566">  struct listnode *node, *nnode;</a>
<a name="ln567">  struct ospf6_neighbor *on, *drouter, *bdrouter, myself;</a>
<a name="ln568">  struct ospf6_neighbor *best_drouter, *best_bdrouter;</a>
<a name="ln569">  u_char next_state = 0;</a>
<a name="ln570"> </a>
<a name="ln571">  drouter = bdrouter = NULL;</a>
<a name="ln572">  best_drouter = best_bdrouter = NULL;</a>
<a name="ln573"> </a>
<a name="ln574">  /* pseudo neighbor myself, including noting current DR/BDR (1) */</a>
<a name="ln575">  memset (&amp;myself, 0, sizeof (myself));</a>
<a name="ln576">  inet_ntop (AF_INET, &amp;oi-&gt;area-&gt;ospf6-&gt;router_id, myself.name,</a>
<a name="ln577">             sizeof (myself.name));</a>
<a name="ln578">  myself.state = OSPF6_NEIGHBOR_TWOWAY;</a>
<a name="ln579">  myself.drouter = oi-&gt;drouter;</a>
<a name="ln580">  myself.bdrouter = oi-&gt;bdrouter;</a>
<a name="ln581">  myself.priority = oi-&gt;priority;</a>
<a name="ln582">  myself.router_id = oi-&gt;area-&gt;ospf6-&gt;router_id;</a>
<a name="ln583"> </a>
<a name="ln584">  /* Electing BDR (2) */</a>
<a name="ln585">  for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln586">    bdrouter = better_bdrouter (bdrouter, on);</a>
<a name="ln587">  </a>
<a name="ln588">  best_bdrouter = bdrouter;</a>
<a name="ln589">  bdrouter = better_bdrouter (best_bdrouter, &amp;myself);</a>
<a name="ln590"> </a>
<a name="ln591">  /* Electing DR (3) */</a>
<a name="ln592">  for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln593">    drouter = better_drouter (drouter, on);</a>
<a name="ln594"> </a>
<a name="ln595">  best_drouter = drouter;</a>
<a name="ln596">  drouter = better_drouter (best_drouter, &amp;myself);</a>
<a name="ln597">  if (drouter == NULL)</a>
<a name="ln598">    drouter = bdrouter;</a>
<a name="ln599"> </a>
<a name="ln600">  /* the router itself is newly/no longer DR/BDR (4) */</a>
<a name="ln601">  if ((drouter == &amp;myself &amp;&amp; myself.drouter != myself.router_id) ||</a>
<a name="ln602">      (drouter != &amp;myself &amp;&amp; myself.drouter == myself.router_id) ||</a>
<a name="ln603">      (bdrouter == &amp;myself &amp;&amp; myself.bdrouter != myself.router_id) ||</a>
<a name="ln604">      (bdrouter != &amp;myself &amp;&amp; myself.bdrouter == myself.router_id))</a>
<a name="ln605">    {</a>
<a name="ln606">      myself.drouter = (drouter ? drouter-&gt;router_id : htonl (0));</a>
<a name="ln607">      myself.bdrouter = (bdrouter ? bdrouter-&gt;router_id : htonl (0));</a>
<a name="ln608"> </a>
<a name="ln609">      /* compatible to Electing BDR (2) */</a>
<a name="ln610">      bdrouter = better_bdrouter (best_bdrouter, &amp;myself);</a>
<a name="ln611"> </a>
<a name="ln612">      /* compatible to Electing DR (3) */</a>
<a name="ln613">      drouter = better_drouter (best_drouter, &amp;myself);</a>
<a name="ln614">      if (drouter == NULL)</a>
<a name="ln615">        drouter = bdrouter;</a>
<a name="ln616">    }</a>
<a name="ln617"> </a>
<a name="ln618">  /* Set interface state accordingly (5) */</a>
<a name="ln619">  if (drouter &amp;&amp; drouter == &amp;myself)</a>
<a name="ln620">    next_state = OSPF6_INTERFACE_DR;</a>
<a name="ln621">  else if (bdrouter &amp;&amp; bdrouter == &amp;myself)</a>
<a name="ln622">    next_state = OSPF6_INTERFACE_BDR;</a>
<a name="ln623">  else</a>
<a name="ln624">    next_state = OSPF6_INTERFACE_DROTHER;</a>
<a name="ln625"> </a>
<a name="ln626">  /* If NBMA, schedule Start for each neighbor having priority of 0 (6) */</a>
<a name="ln627">  /* XXX */</a>
<a name="ln628"> </a>
<a name="ln629">  /* If DR or BDR change, invoke AdjOK? for each neighbor (7) */</a>
<a name="ln630">  /* RFC 2328 section 12.4. Originating LSAs (3) will be handled</a>
<a name="ln631">     accordingly after AdjOK */</a>
<a name="ln632">  if (oi-&gt;drouter != (drouter ? drouter-&gt;router_id : htonl (0)) ||</a>
<a name="ln633">      oi-&gt;bdrouter != (bdrouter ? bdrouter-&gt;router_id : htonl (0)))</a>
<a name="ln634">    {</a>
<a name="ln635">      if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln636">        zlog_debug (&quot;DR Election on %s: DR: %s BDR: %s&quot;, oi-&gt;interface-&gt;name,</a>
<a name="ln637">		    (drouter ? drouter-&gt;name : &quot;0.0.0.0&quot;),</a>
<a name="ln638">		    (bdrouter ? bdrouter-&gt;name : &quot;0.0.0.0&quot;));</a>
<a name="ln639"> </a>
<a name="ln640">      for (ALL_LIST_ELEMENTS_RO (oi-&gt;neighbor_list, node, on))</a>
<a name="ln641">        {</a>
<a name="ln642">          if (on-&gt;state &lt; OSPF6_NEIGHBOR_TWOWAY)</a>
<a name="ln643">            continue;</a>
<a name="ln644">          /* Schedule AdjOK. */</a>
<a name="ln645">          thread_add_event (master, adj_ok, on, 0);</a>
<a name="ln646">        }</a>
<a name="ln647">    }</a>
<a name="ln648"> </a>
<a name="ln649">  oi-&gt;drouter = (drouter ? drouter-&gt;router_id : htonl (0));</a>
<a name="ln650">  oi-&gt;bdrouter = (bdrouter ? bdrouter-&gt;router_id : htonl (0));</a>
<a name="ln651">  return next_state;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654"> </a>
<a name="ln655">/* Interface State Machine */</a>
<a name="ln656">int</a>
<a name="ln657">interface_up (struct thread *thread)</a>
<a name="ln658">{</a>
<a name="ln659">  struct ospf6_interface *oi;</a>
<a name="ln660"> </a>
<a name="ln661">  oi = (struct ospf6_interface *) THREAD_ARG (thread);</a>
<a name="ln662">  assert (oi &amp;&amp; oi-&gt;interface);</a>
<a name="ln663"> </a>
<a name="ln664">  if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln665">    zlog_debug (&quot;Interface Event %s: [InterfaceUp]&quot;,</a>
<a name="ln666">		oi-&gt;interface-&gt;name);</a>
<a name="ln667"> </a>
<a name="ln668">  /* check physical interface is up */</a>
<a name="ln669">  if (! if_is_operative (oi-&gt;interface))</a>
<a name="ln670">    {</a>
<a name="ln671">      if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln672">        zlog_debug (&quot;Interface %s is down, can't execute [InterfaceUp]&quot;,</a>
<a name="ln673">		    oi-&gt;interface-&gt;name);</a>
<a name="ln674">      return 0;</a>
<a name="ln675">    }</a>
<a name="ln676"> </a>
<a name="ln677">  /* check interface has a link-local address */</a>
<a name="ln678">  if (! (ospf6_interface_get_linklocal_address(oi-&gt;interface)</a>
<a name="ln679">         || if_is_loopback(oi-&gt;interface)))</a>
<a name="ln680">    {</a>
<a name="ln681">      if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln682">	zlog_debug (&quot;Interface %s has no link local address, can't execute [InterfaceUp]&quot;,</a>
<a name="ln683">		    oi-&gt;interface-&gt;name);</a>
<a name="ln684">      return 0;</a>
<a name="ln685">    }</a>
<a name="ln686"> </a>
<a name="ln687">  /* Recompute cost */</a>
<a name="ln688">  ospf6_interface_recalculate_cost (oi);</a>
<a name="ln689"> </a>
<a name="ln690">  /* if already enabled, do nothing */</a>
<a name="ln691">  if (oi-&gt;state &gt; OSPF6_INTERFACE_DOWN)</a>
<a name="ln692">    {</a>
<a name="ln693">      if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln694">        zlog_debug (&quot;Interface %s already enabled&quot;,</a>
<a name="ln695">		    oi-&gt;interface-&gt;name);</a>
<a name="ln696">      return 0;</a>
<a name="ln697">    }</a>
<a name="ln698"> </a>
<a name="ln699">  /* If no area assigned, return */</a>
<a name="ln700">  if (oi-&gt;area == NULL)</a>
<a name="ln701">    {</a>
<a name="ln702">      zlog_debug (&quot;%s: Not scheduleing Hello for %s as there is no area assigned yet&quot;, __func__,</a>
<a name="ln703">		  oi-&gt;interface-&gt;name);</a>
<a name="ln704">      return 0;</a>
<a name="ln705">    }</a>
<a name="ln706"> </a>
<a name="ln707">  /* Join AllSPFRouters */</a>
<a name="ln708">  if (ospf6_sso (oi-&gt;interface-&gt;ifindex, &amp;allspfrouters6, IPV6_JOIN_GROUP) &lt; 0)</a>
<a name="ln709">    {</a>
<a name="ln710">      if (oi-&gt;sso_try_cnt++ &lt; OSPF6_INTERFACE_SSO_RETRY_MAX)</a>
<a name="ln711">        {</a>
<a name="ln712">          zlog_info(&quot;Scheduling %s for sso retry, trial count: %d&quot;,</a>
<a name="ln713">                    oi-&gt;interface-&gt;name, oi-&gt;sso_try_cnt);</a>
<a name="ln714">          thread_add_timer (master, interface_up, oi,</a>
<a name="ln715">                            OSPF6_INTERFACE_SSO_RETRY_INT);</a>
<a name="ln716">        }</a>
<a name="ln717">      return 0;</a>
<a name="ln718">    }</a>
<a name="ln719">  oi-&gt;sso_try_cnt = 0; /* Reset on success */</a>
<a name="ln720"> </a>
<a name="ln721">  /* Update interface route */</a>
<a name="ln722">  ospf6_interface_connected_route_update (oi-&gt;interface);</a>
<a name="ln723"> </a>
<a name="ln724">  /* Schedule Hello */</a>
<a name="ln725">  if (! CHECK_FLAG (oi-&gt;flag, OSPF6_INTERFACE_PASSIVE))</a>
<a name="ln726">    oi-&gt;thread_send_hello = thread_add_event (master, ospf6_hello_send, oi, 0);</a>
<a name="ln727"> </a>
<a name="ln728">  /* decide next interface state */</a>
<a name="ln729">  if ((if_is_pointopoint (oi-&gt;interface)) ||</a>
<a name="ln730">      (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)) {</a>
<a name="ln731">    ospf6_interface_state_change (OSPF6_INTERFACE_POINTTOPOINT, oi);</a>
<a name="ln732">  }</a>
<a name="ln733">  else if (oi-&gt;priority == 0)</a>
<a name="ln734">    ospf6_interface_state_change (OSPF6_INTERFACE_DROTHER, oi);</a>
<a name="ln735">  else</a>
<a name="ln736">    {</a>
<a name="ln737">      ospf6_interface_state_change (OSPF6_INTERFACE_WAITING, oi);</a>
<a name="ln738">      thread_add_timer (master, wait_timer, oi, oi-&gt;dead_interval);</a>
<a name="ln739">    }</a>
<a name="ln740"> </a>
<a name="ln741">  return 0;</a>
<a name="ln742">}</a>
<a name="ln743"> </a>
<a name="ln744">int</a>
<a name="ln745">wait_timer (struct thread *thread)</a>
<a name="ln746">{</a>
<a name="ln747">  struct ospf6_interface *oi;</a>
<a name="ln748"> </a>
<a name="ln749">  oi = (struct ospf6_interface *) THREAD_ARG (thread);</a>
<a name="ln750">  assert (oi &amp;&amp; oi-&gt;interface);</a>
<a name="ln751"> </a>
<a name="ln752">  if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln753">    zlog_debug (&quot;Interface Event %s: [WaitTimer]&quot;,</a>
<a name="ln754">		oi-&gt;interface-&gt;name);</a>
<a name="ln755"> </a>
<a name="ln756">  if (oi-&gt;state == OSPF6_INTERFACE_WAITING)</a>
<a name="ln757">    ospf6_interface_state_change (dr_election (oi), oi);</a>
<a name="ln758"> </a>
<a name="ln759">  return 0;</a>
<a name="ln760">}</a>
<a name="ln761"> </a>
<a name="ln762">int</a>
<a name="ln763">backup_seen (struct thread *thread)</a>
<a name="ln764">{</a>
<a name="ln765">  struct ospf6_interface *oi;</a>
<a name="ln766"> </a>
<a name="ln767">  oi = (struct ospf6_interface *) THREAD_ARG (thread);</a>
<a name="ln768">  assert (oi &amp;&amp; oi-&gt;interface);</a>
<a name="ln769"> </a>
<a name="ln770">  if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln771">    zlog_debug (&quot;Interface Event %s: [BackupSeen]&quot;,</a>
<a name="ln772">		oi-&gt;interface-&gt;name);</a>
<a name="ln773"> </a>
<a name="ln774">  if (oi-&gt;state == OSPF6_INTERFACE_WAITING)</a>
<a name="ln775">    ospf6_interface_state_change (dr_election (oi), oi);</a>
<a name="ln776"> </a>
<a name="ln777">  return 0;</a>
<a name="ln778">}</a>
<a name="ln779"> </a>
<a name="ln780">int</a>
<a name="ln781">neighbor_change (struct thread *thread)</a>
<a name="ln782">{</a>
<a name="ln783">  struct ospf6_interface *oi;</a>
<a name="ln784"> </a>
<a name="ln785">  oi = (struct ospf6_interface *) THREAD_ARG (thread);</a>
<a name="ln786">  assert (oi &amp;&amp; oi-&gt;interface);</a>
<a name="ln787"> </a>
<a name="ln788">  if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln789">    zlog_debug (&quot;Interface Event %s: [NeighborChange]&quot;,</a>
<a name="ln790">		oi-&gt;interface-&gt;name);</a>
<a name="ln791"> </a>
<a name="ln792">  if (oi-&gt;state == OSPF6_INTERFACE_DROTHER ||</a>
<a name="ln793">      oi-&gt;state == OSPF6_INTERFACE_BDR ||</a>
<a name="ln794">      oi-&gt;state == OSPF6_INTERFACE_DR)</a>
<a name="ln795">    ospf6_interface_state_change (dr_election (oi), oi);</a>
<a name="ln796"> </a>
<a name="ln797">  return 0;</a>
<a name="ln798">}</a>
<a name="ln799"> </a>
<a name="ln800">int</a>
<a name="ln801">interface_down (struct thread *thread)</a>
<a name="ln802">{</a>
<a name="ln803">  struct ospf6_interface *oi;</a>
<a name="ln804">  struct listnode *node, *nnode;</a>
<a name="ln805">  struct ospf6_neighbor *on;</a>
<a name="ln806"> </a>
<a name="ln807">  oi = (struct ospf6_interface *) THREAD_ARG (thread);</a>
<a name="ln808">  assert (oi &amp;&amp; oi-&gt;interface);</a>
<a name="ln809"> </a>
<a name="ln810">  if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln811">    zlog_debug (&quot;Interface Event %s: [InterfaceDown]&quot;,</a>
<a name="ln812">		oi-&gt;interface-&gt;name);</a>
<a name="ln813"> </a>
<a name="ln814">  /* Stop Hellos */</a>
<a name="ln815">  THREAD_OFF (oi-&gt;thread_send_hello);</a>
<a name="ln816"> </a>
<a name="ln817">  /* Leave AllSPFRouters */</a>
<a name="ln818">  if (oi-&gt;state &gt; OSPF6_INTERFACE_DOWN)</a>
<a name="ln819">    ospf6_sso (oi-&gt;interface-&gt;ifindex, &amp;allspfrouters6, IPV6_LEAVE_GROUP);</a>
<a name="ln820"> </a>
<a name="ln821">  ospf6_interface_state_change (OSPF6_INTERFACE_DOWN, oi);</a>
<a name="ln822"> </a>
<a name="ln823">  for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln824">    ospf6_neighbor_delete (on);</a>
<a name="ln825">  </a>
<a name="ln826">  list_delete_all_node (oi-&gt;neighbor_list);</a>
<a name="ln827"> </a>
<a name="ln828">  /* When interface state is reset, also reset information about</a>
<a name="ln829">   * DR election, as it is no longer valid. */</a>
<a name="ln830">  oi-&gt;drouter = oi-&gt;prev_drouter = htonl(0);</a>
<a name="ln831">  oi-&gt;bdrouter = oi-&gt;prev_bdrouter = htonl(0);</a>
<a name="ln832">  return 0;</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835"> </a>
<a name="ln836">/* show specified interface structure */</a>
<a name="ln837">static int</a>
<a name="ln838">ospf6_interface_show (struct vty *vty, struct interface *ifp)</a>
<a name="ln839">{</a>
<a name="ln840">  struct ospf6_interface *oi;</a>
<a name="ln841">  struct connected *c;</a>
<a name="ln842">  struct prefix *p;</a>
<a name="ln843">  struct listnode *i;</a>
<a name="ln844">  char strbuf[64], drouter[32], bdrouter[32];</a>
<a name="ln845">  const char *updown[3] = {&quot;down&quot;, &quot;up&quot;, NULL};</a>
<a name="ln846">  const char *type;</a>
<a name="ln847">  struct timeval res, now;</a>
<a name="ln848">  char duration[32];</a>
<a name="ln849">  struct ospf6_lsa *lsa;</a>
<a name="ln850"> </a>
<a name="ln851">  /* check physical interface type */</a>
<a name="ln852">  if (if_is_loopback (ifp))</a>
<a name="ln853">    type = &quot;LOOPBACK&quot;;</a>
<a name="ln854">  else if (if_is_broadcast (ifp))</a>
<a name="ln855">    type = &quot;BROADCAST&quot;;</a>
<a name="ln856">  else if (if_is_pointopoint (ifp))</a>
<a name="ln857">    type = &quot;POINTOPOINT&quot;;</a>
<a name="ln858">  else</a>
<a name="ln859">    type = &quot;UNKNOWN&quot;;</a>
<a name="ln860"> </a>
<a name="ln861">  vty_out (vty, &quot;%s is %s, type %s%s&quot;,</a>
<a name="ln862">           ifp-&gt;name, updown[if_is_operative (ifp)], type,</a>
<a name="ln863">	   VNL);</a>
<a name="ln864">  vty_out (vty, &quot;  Interface ID: %d%s&quot;, ifp-&gt;ifindex, VNL);</a>
<a name="ln865"> </a>
<a name="ln866">  if (ifp-&gt;info == NULL)</a>
<a name="ln867">    {</a>
<a name="ln868">      vty_out (vty, &quot;   OSPF not enabled on this interface%s&quot;, VNL);</a>
<a name="ln869">      return 0;</a>
<a name="ln870">    }</a>
<a name="ln871">  else</a>
<a name="ln872">    oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln873"> </a>
<a name="ln874">  vty_out (vty, &quot;  Internet Address:%s&quot;, VNL);</a>
<a name="ln875"> </a>
<a name="ln876">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, i, c))</a>
<a name="ln877">    {</a>
<a name="ln878">      p = c-&gt;address;</a>
<a name="ln879">      prefix2str (p, strbuf, sizeof (strbuf));</a>
<a name="ln880">      switch (p-&gt;family)</a>
<a name="ln881">        {</a>
<a name="ln882">        case AF_INET:</a>
<a name="ln883">          vty_out (vty, &quot;    inet : %s%s&quot;, strbuf,</a>
<a name="ln884">		   VNL);</a>
<a name="ln885">          break;</a>
<a name="ln886">        case AF_INET6:</a>
<a name="ln887">          vty_out (vty, &quot;    inet6: %s%s&quot;, strbuf,</a>
<a name="ln888">		   VNL);</a>
<a name="ln889">          break;</a>
<a name="ln890">        default:</a>
<a name="ln891">          vty_out (vty, &quot;    ???  : %s%s&quot;, strbuf,</a>
<a name="ln892">		   VNL);</a>
<a name="ln893">          break;</a>
<a name="ln894">        }</a>
<a name="ln895">    }</a>
<a name="ln896"> </a>
<a name="ln897">  if (oi-&gt;area)</a>
<a name="ln898">    {</a>
<a name="ln899">      vty_out (vty, &quot;  Instance ID %d, Interface MTU %d (autodetect: %d)%s&quot;,</a>
<a name="ln900">	       oi-&gt;instance_id, oi-&gt;ifmtu, ifp-&gt;mtu6, VNL);</a>
<a name="ln901">      vty_out (vty, &quot;  MTU mismatch detection: %s%s&quot;, oi-&gt;mtu_ignore ?</a>
<a name="ln902">	       &quot;disabled&quot; : &quot;enabled&quot;, VNL);</a>
<a name="ln903">      inet_ntop (AF_INET, &amp;oi-&gt;area-&gt;area_id,</a>
<a name="ln904">                 strbuf, sizeof (strbuf));</a>
<a name="ln905">      vty_out (vty, &quot;  Area ID %s, Cost %u%s&quot;, strbuf, oi-&gt;cost,</a>
<a name="ln906">	       VNL);</a>
<a name="ln907">    }</a>
<a name="ln908">  else</a>
<a name="ln909">    vty_out (vty, &quot;  Not Attached to Area%s&quot;, VNL);</a>
<a name="ln910"> </a>
<a name="ln911">  vty_out (vty, &quot;  State %s, Transmit Delay %d sec, Priority %d%s&quot;,</a>
<a name="ln912">           ospf6_interface_state_str[oi-&gt;state],</a>
<a name="ln913">           oi-&gt;transdelay, oi-&gt;priority,</a>
<a name="ln914">	   VNL);</a>
<a name="ln915">  vty_out (vty, &quot;  Timer intervals configured:%s&quot;, VNL);</a>
<a name="ln916">  vty_out (vty, &quot;   Hello %d, Dead %d, Retransmit %d%s&quot;,</a>
<a name="ln917">           oi-&gt;hello_interval, oi-&gt;dead_interval, oi-&gt;rxmt_interval,</a>
<a name="ln918">	   VNL);</a>
<a name="ln919"> </a>
<a name="ln920">  inet_ntop (AF_INET, &amp;oi-&gt;drouter, drouter, sizeof (drouter));</a>
<a name="ln921">  inet_ntop (AF_INET, &amp;oi-&gt;bdrouter, bdrouter, sizeof (bdrouter));</a>
<a name="ln922">  vty_out (vty, &quot;  DR: %s BDR: %s%s&quot;, drouter, bdrouter, VNL);</a>
<a name="ln923"> </a>
<a name="ln924">  vty_out (vty, &quot;  Number of I/F scoped LSAs is %u%s&quot;,</a>
<a name="ln925">           oi-&gt;lsdb-&gt;count, VNL);</a>
<a name="ln926"> </a>
<a name="ln927">  quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;now);</a>
<a name="ln928"> </a>
<a name="ln929">  timerclear (&amp;res);</a>
<a name="ln930">  if (oi-&gt;thread_send_lsupdate)</a>
<a name="ln931">    timersub (&amp;oi-&gt;thread_send_lsupdate-&gt;u.sands, &amp;now, &amp;res);</a>
<a name="ln932">  timerstring (&amp;res, duration, sizeof (duration));</a>
<a name="ln933">  vty_out (vty, &quot;    %d Pending LSAs for LSUpdate in Time %s [thread %s]%s&quot;,</a>
<a name="ln934">           oi-&gt;lsupdate_list-&gt;count, duration,</a>
<a name="ln935">           (oi-&gt;thread_send_lsupdate ? &quot;on&quot; : &quot;off&quot;),</a>
<a name="ln936">           VNL);</a>
<a name="ln937">  for (lsa = ospf6_lsdb_head (oi-&gt;lsupdate_list); lsa;</a>
<a name="ln938">       lsa = ospf6_lsdb_next (lsa))</a>
<a name="ln939">    vty_out (vty, &quot;      %s%s&quot;, lsa-&gt;name, VNL);</a>
<a name="ln940"> </a>
<a name="ln941">  timerclear (&amp;res);</a>
<a name="ln942">  if (oi-&gt;thread_send_lsack)</a>
<a name="ln943">    timersub (&amp;oi-&gt;thread_send_lsack-&gt;u.sands, &amp;now, &amp;res);</a>
<a name="ln944">  timerstring (&amp;res, duration, sizeof (duration));</a>
<a name="ln945">  vty_out (vty, &quot;    %d Pending LSAs for LSAck in Time %s [thread %s]%s&quot;,</a>
<a name="ln946">           oi-&gt;lsack_list-&gt;count, duration,</a>
<a name="ln947">           (oi-&gt;thread_send_lsack ? &quot;on&quot; : &quot;off&quot;),</a>
<a name="ln948">           VNL);</a>
<a name="ln949">  for (lsa = ospf6_lsdb_head (oi-&gt;lsack_list); lsa;</a>
<a name="ln950">       lsa = ospf6_lsdb_next (lsa))</a>
<a name="ln951">    vty_out (vty, &quot;      %s%s&quot;, lsa-&gt;name, VNL);</a>
<a name="ln952"> </a>
<a name="ln953">  return 0;</a>
<a name="ln954">}</a>
<a name="ln955"> </a>
<a name="ln956">/* show interface */</a>
<a name="ln957">DEFUN (show_ipv6_ospf6_interface,</a>
<a name="ln958">       show_ipv6_ospf6_interface_ifname_cmd,</a>
<a name="ln959">       &quot;show ipv6 ospf6 interface IFNAME&quot;,</a>
<a name="ln960">       SHOW_STR</a>
<a name="ln961">       IP6_STR</a>
<a name="ln962">       OSPF6_STR</a>
<a name="ln963">       INTERFACE_STR</a>
<a name="ln964">       IFNAME_STR</a>
<a name="ln965">       )</a>
<a name="ln966">{</a>
<a name="ln967">  struct interface *ifp;</a>
<a name="ln968">  struct listnode *i;</a>
<a name="ln969"> </a>
<a name="ln970">  if (argc)</a>
<a name="ln971">    {</a>
<a name="ln972">      ifp = if_lookup_by_name (argv[0]);</a>
<a name="ln973">      if (ifp == NULL)</a>
<a name="ln974">        {</a>
<a name="ln975">          vty_out (vty, &quot;No such Interface: %s%s&quot;, argv[0],</a>
<a name="ln976">                   VNL);</a>
<a name="ln977">          return CMD_WARNING;</a>
<a name="ln978">        }</a>
<a name="ln979">      ospf6_interface_show (vty, ifp);</a>
<a name="ln980">    }</a>
<a name="ln981">  else</a>
<a name="ln982">    {</a>
<a name="ln983">      for (ALL_LIST_ELEMENTS_RO (iflist, i, ifp))</a>
<a name="ln984">        ospf6_interface_show (vty, ifp);</a>
<a name="ln985">    }</a>
<a name="ln986"> </a>
<a name="ln987">  return CMD_SUCCESS;</a>
<a name="ln988">}</a>
<a name="ln989"> </a>
<a name="ln990">ALIAS (show_ipv6_ospf6_interface,</a>
<a name="ln991">       show_ipv6_ospf6_interface_cmd,</a>
<a name="ln992">       &quot;show ipv6 ospf6 interface&quot;,</a>
<a name="ln993">       SHOW_STR</a>
<a name="ln994">       IP6_STR</a>
<a name="ln995">       OSPF6_STR</a>
<a name="ln996">       INTERFACE_STR</a>
<a name="ln997">       )</a>
<a name="ln998"> </a>
<a name="ln999">DEFUN (show_ipv6_ospf6_interface_ifname_prefix,</a>
<a name="ln1000">       show_ipv6_ospf6_interface_ifname_prefix_cmd,</a>
<a name="ln1001">       &quot;show ipv6 ospf6 interface IFNAME prefix&quot;,</a>
<a name="ln1002">       SHOW_STR</a>
<a name="ln1003">       IP6_STR</a>
<a name="ln1004">       OSPF6_STR</a>
<a name="ln1005">       INTERFACE_STR</a>
<a name="ln1006">       IFNAME_STR</a>
<a name="ln1007">       &quot;Display connected prefixes to advertise\n&quot;</a>
<a name="ln1008">       )</a>
<a name="ln1009">{</a>
<a name="ln1010">  struct interface *ifp;</a>
<a name="ln1011">  struct ospf6_interface *oi;</a>
<a name="ln1012"> </a>
<a name="ln1013">  ifp = if_lookup_by_name (argv[0]);</a>
<a name="ln1014">  if (ifp == NULL)</a>
<a name="ln1015">    {</a>
<a name="ln1016">      vty_out (vty, &quot;No such Interface: %s%s&quot;, argv[0], VNL);</a>
<a name="ln1017">      return CMD_WARNING;</a>
<a name="ln1018">    }</a>
<a name="ln1019"> </a>
<a name="ln1020">  oi = ifp-&gt;info;</a>
<a name="ln1021">  if (oi == NULL)</a>
<a name="ln1022">    {</a>
<a name="ln1023">      vty_out (vty, &quot;OSPFv3 is not enabled on %s%s&quot;, argv[0], VNL);</a>
<a name="ln1024">      return CMD_WARNING;</a>
<a name="ln1025">    }</a>
<a name="ln1026"> </a>
<a name="ln1027">  argc--;</a>
<a name="ln1028">  argv++;</a>
<a name="ln1029">  ospf6_route_table_show (vty, argc, argv, oi-&gt;route_connected);</a>
<a name="ln1030"> </a>
<a name="ln1031">  return CMD_SUCCESS;</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">ALIAS (show_ipv6_ospf6_interface_ifname_prefix,</a>
<a name="ln1035">       show_ipv6_ospf6_interface_ifname_prefix_detail_cmd,</a>
<a name="ln1036">       &quot;show ipv6 ospf6 interface IFNAME prefix (X:X::X:X|X:X::X:X/M|detail)&quot;,</a>
<a name="ln1037">       SHOW_STR</a>
<a name="ln1038">       IP6_STR</a>
<a name="ln1039">       OSPF6_STR</a>
<a name="ln1040">       INTERFACE_STR</a>
<a name="ln1041">       IFNAME_STR</a>
<a name="ln1042">       &quot;Display connected prefixes to advertise\n&quot;</a>
<a name="ln1043">       OSPF6_ROUTE_ADDRESS_STR</a>
<a name="ln1044">       OSPF6_ROUTE_PREFIX_STR</a>
<a name="ln1045">       &quot;Display details of the prefixes\n&quot;</a>
<a name="ln1046">       )</a>
<a name="ln1047"> </a>
<a name="ln1048">ALIAS (show_ipv6_ospf6_interface_ifname_prefix,</a>
<a name="ln1049">       show_ipv6_ospf6_interface_ifname_prefix_match_cmd,</a>
<a name="ln1050">       &quot;show ipv6 ospf6 interface IFNAME prefix X:X::X:X/M (match|detail)&quot;,</a>
<a name="ln1051">       SHOW_STR</a>
<a name="ln1052">       IP6_STR</a>
<a name="ln1053">       OSPF6_STR</a>
<a name="ln1054">       INTERFACE_STR</a>
<a name="ln1055">       IFNAME_STR</a>
<a name="ln1056">       &quot;Display connected prefixes to advertise\n&quot;</a>
<a name="ln1057">       OSPF6_ROUTE_PREFIX_STR</a>
<a name="ln1058">       OSPF6_ROUTE_MATCH_STR</a>
<a name="ln1059">       &quot;Display details of the prefixes\n&quot;</a>
<a name="ln1060">       )</a>
<a name="ln1061"> </a>
<a name="ln1062">DEFUN (show_ipv6_ospf6_interface_prefix,</a>
<a name="ln1063">       show_ipv6_ospf6_interface_prefix_cmd,</a>
<a name="ln1064">       &quot;show ipv6 ospf6 interface prefix&quot;,</a>
<a name="ln1065">       SHOW_STR</a>
<a name="ln1066">       IP6_STR</a>
<a name="ln1067">       OSPF6_STR</a>
<a name="ln1068">       INTERFACE_STR</a>
<a name="ln1069">       &quot;Display connected prefixes to advertise\n&quot;</a>
<a name="ln1070">       )</a>
<a name="ln1071">{</a>
<a name="ln1072">  struct listnode *i;</a>
<a name="ln1073">  struct ospf6_interface *oi;</a>
<a name="ln1074">  struct interface *ifp;</a>
<a name="ln1075"> </a>
<a name="ln1076">  for (ALL_LIST_ELEMENTS_RO (iflist, i, ifp))</a>
<a name="ln1077">    {</a>
<a name="ln1078">      oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1079">      if (oi == NULL)</a>
<a name="ln1080">        continue;</a>
<a name="ln1081"> </a>
<a name="ln1082">      ospf6_route_table_show (vty, argc, argv, oi-&gt;route_connected);</a>
<a name="ln1083">    }</a>
<a name="ln1084"> </a>
<a name="ln1085">  return CMD_SUCCESS;</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">ALIAS (show_ipv6_ospf6_interface_prefix,</a>
<a name="ln1089">       show_ipv6_ospf6_interface_prefix_detail_cmd,</a>
<a name="ln1090">       &quot;show ipv6 ospf6 interface prefix (X:X::X:X|X:X::X:X/M|detail)&quot;,</a>
<a name="ln1091">       SHOW_STR</a>
<a name="ln1092">       IP6_STR</a>
<a name="ln1093">       OSPF6_STR</a>
<a name="ln1094">       INTERFACE_STR</a>
<a name="ln1095">       &quot;Display connected prefixes to advertise\n&quot;</a>
<a name="ln1096">       OSPF6_ROUTE_ADDRESS_STR</a>
<a name="ln1097">       OSPF6_ROUTE_PREFIX_STR</a>
<a name="ln1098">       &quot;Display details of the prefixes\n&quot;</a>
<a name="ln1099">       )</a>
<a name="ln1100"> </a>
<a name="ln1101">ALIAS (show_ipv6_ospf6_interface_prefix,</a>
<a name="ln1102">       show_ipv6_ospf6_interface_prefix_match_cmd,</a>
<a name="ln1103">       &quot;show ipv6 ospf6 interface prefix X:X::X:X/M (match|detail)&quot;,</a>
<a name="ln1104">       SHOW_STR</a>
<a name="ln1105">       IP6_STR</a>
<a name="ln1106">       OSPF6_STR</a>
<a name="ln1107">       INTERFACE_STR</a>
<a name="ln1108">       &quot;Display connected prefixes to advertise\n&quot;</a>
<a name="ln1109">       OSPF6_ROUTE_PREFIX_STR</a>
<a name="ln1110">       OSPF6_ROUTE_MATCH_STR</a>
<a name="ln1111">       &quot;Display details of the prefixes\n&quot;</a>
<a name="ln1112">       )</a>
<a name="ln1113"> </a>
<a name="ln1114"> </a>
<a name="ln1115">/* interface variable set command */</a>
<a name="ln1116">DEFUN (ipv6_ospf6_ifmtu,</a>
<a name="ln1117">       ipv6_ospf6_ifmtu_cmd,</a>
<a name="ln1118">       &quot;ipv6 ospf6 ifmtu &lt;1-65535&gt;&quot;,</a>
<a name="ln1119">       IP6_STR</a>
<a name="ln1120">       OSPF6_STR</a>
<a name="ln1121">       &quot;Interface MTU\n&quot;</a>
<a name="ln1122">       &quot;OSPFv3 Interface MTU\n&quot;</a>
<a name="ln1123">       )</a>
<a name="ln1124">{</a>
<a name="ln1125">  struct ospf6_interface *oi;</a>
<a name="ln1126">  struct interface *ifp;</a>
<a name="ln1127">  unsigned int ifmtu, iobuflen;</a>
<a name="ln1128">  struct listnode *node, *nnode;</a>
<a name="ln1129">  struct ospf6_neighbor *on;</a>
<a name="ln1130"> </a>
<a name="ln1131">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1132">  assert (ifp);</a>
<a name="ln1133"> </a>
<a name="ln1134">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1135">  if (oi == NULL)</a>
<a name="ln1136">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1137">  assert (oi);</a>
<a name="ln1138"> </a>
<a name="ln1139">  ifmtu = strtol (argv[0], NULL, 10);</a>
<a name="ln1140"> </a>
<a name="ln1141">  if (oi-&gt;ifmtu == ifmtu)</a>
<a name="ln1142">    return CMD_SUCCESS;</a>
<a name="ln1143"> </a>
<a name="ln1144">  if (ifp-&gt;mtu6 != 0 &amp;&amp; ifp-&gt;mtu6 &lt; ifmtu)</a>
<a name="ln1145">    {</a>
<a name="ln1146">      vty_out (vty, &quot;%s's ospf6 ifmtu cannot go beyond physical mtu (%d)%s&quot;,</a>
<a name="ln1147">               ifp-&gt;name, ifp-&gt;mtu6, VNL);</a>
<a name="ln1148">      return CMD_WARNING;</a>
<a name="ln1149">    }</a>
<a name="ln1150"> </a>
<a name="ln1151">  if (oi-&gt;ifmtu &lt; ifmtu)</a>
<a name="ln1152">    {</a>
<a name="ln1153">      iobuflen = ospf6_iobuf_size (ifmtu);</a>
<a name="ln1154">      if (iobuflen &lt; ifmtu)</a>
<a name="ln1155">        {</a>
<a name="ln1156">          vty_out (vty, &quot;%s's ifmtu is adjusted to I/O buffer size (%d).%s&quot;,</a>
<a name="ln1157">                   ifp-&gt;name, iobuflen, VNL);</a>
<a name="ln1158">          oi-&gt;ifmtu = iobuflen;</a>
<a name="ln1159">        }</a>
<a name="ln1160">      else</a>
<a name="ln1161">        oi-&gt;ifmtu = ifmtu;</a>
<a name="ln1162">    }</a>
<a name="ln1163">  else</a>
<a name="ln1164">    oi-&gt;ifmtu = ifmtu;</a>
<a name="ln1165"> </a>
<a name="ln1166">  /* re-establish adjacencies */</a>
<a name="ln1167">  for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln1168">    {</a>
<a name="ln1169">      THREAD_OFF (on-&gt;inactivity_timer);</a>
<a name="ln1170">      thread_add_event (master, inactivity_timer, on, 0);</a>
<a name="ln1171">    }</a>
<a name="ln1172"> </a>
<a name="ln1173">  return CMD_SUCCESS;</a>
<a name="ln1174">}</a>
<a name="ln1175"> </a>
<a name="ln1176">DEFUN (no_ipv6_ospf6_ifmtu,</a>
<a name="ln1177">       no_ipv6_ospf6_ifmtu_cmd,</a>
<a name="ln1178">       &quot;no ipv6 ospf6 ifmtu&quot;,</a>
<a name="ln1179">       NO_STR</a>
<a name="ln1180">       IP6_STR</a>
<a name="ln1181">       OSPF6_STR</a>
<a name="ln1182">       &quot;Interface MTU\n&quot;</a>
<a name="ln1183">       )</a>
<a name="ln1184">{</a>
<a name="ln1185">  struct ospf6_interface *oi;</a>
<a name="ln1186">  struct interface *ifp;</a>
<a name="ln1187">  unsigned int iobuflen;</a>
<a name="ln1188">  struct listnode *node, *nnode;</a>
<a name="ln1189">  struct ospf6_neighbor *on;</a>
<a name="ln1190"> </a>
<a name="ln1191">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1192">  assert (ifp);</a>
<a name="ln1193"> </a>
<a name="ln1194">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1195">  if (oi == NULL)</a>
<a name="ln1196">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1197">  assert (oi);</a>
<a name="ln1198"> </a>
<a name="ln1199">  if (oi-&gt;ifmtu &lt; ifp-&gt;mtu)</a>
<a name="ln1200">    {</a>
<a name="ln1201">      iobuflen = ospf6_iobuf_size (ifp-&gt;mtu);</a>
<a name="ln1202">      if (iobuflen &lt; ifp-&gt;mtu)</a>
<a name="ln1203">        {</a>
<a name="ln1204">          vty_out (vty, &quot;%s's ifmtu is adjusted to I/O buffer size (%d).%s&quot;,</a>
<a name="ln1205">                   ifp-&gt;name, iobuflen, VNL);</a>
<a name="ln1206">          oi-&gt;ifmtu = iobuflen;</a>
<a name="ln1207">        }</a>
<a name="ln1208">      else</a>
<a name="ln1209">        oi-&gt;ifmtu = ifp-&gt;mtu;</a>
<a name="ln1210">    }</a>
<a name="ln1211">  else</a>
<a name="ln1212">    oi-&gt;ifmtu = ifp-&gt;mtu;</a>
<a name="ln1213"> </a>
<a name="ln1214">  /* re-establish adjacencies */</a>
<a name="ln1215">  for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln1216">    {</a>
<a name="ln1217">      THREAD_OFF (on-&gt;inactivity_timer);</a>
<a name="ln1218">      thread_add_event (master, inactivity_timer, on, 0);</a>
<a name="ln1219">    }</a>
<a name="ln1220"> </a>
<a name="ln1221">  return CMD_SUCCESS;</a>
<a name="ln1222">}</a>
<a name="ln1223"> </a>
<a name="ln1224">DEFUN (ipv6_ospf6_cost,</a>
<a name="ln1225">       ipv6_ospf6_cost_cmd,</a>
<a name="ln1226">       &quot;ipv6 ospf6 cost &lt;1-65535&gt;&quot;,</a>
<a name="ln1227">       IP6_STR</a>
<a name="ln1228">       OSPF6_STR</a>
<a name="ln1229">       &quot;Interface cost\n&quot;</a>
<a name="ln1230">       &quot;Outgoing metric of this interface\n&quot;</a>
<a name="ln1231">       )</a>
<a name="ln1232">{</a>
<a name="ln1233">  struct ospf6_interface *oi;</a>
<a name="ln1234">  struct interface *ifp;</a>
<a name="ln1235">  unsigned long int lcost;</a>
<a name="ln1236"> </a>
<a name="ln1237">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1238">  assert (ifp);</a>
<a name="ln1239"> </a>
<a name="ln1240">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1241">  if (oi == NULL)</a>
<a name="ln1242">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1243">  assert (oi);</a>
<a name="ln1244"> </a>
<a name="ln1245">  lcost = strtol (argv[0], NULL, 10);</a>
<a name="ln1246"> </a>
<a name="ln1247">  if (lcost &gt; UINT32_MAX)</a>
<a name="ln1248">    {</a>
<a name="ln1249">      vty_out (vty, &quot;Cost %ld is out of range%s&quot;, lcost, VNL);</a>
<a name="ln1250">      return CMD_WARNING;</a>
<a name="ln1251">    }</a>
<a name="ln1252">  </a>
<a name="ln1253">  if (oi-&gt;cost == lcost)</a>
<a name="ln1254">    return CMD_SUCCESS;</a>
<a name="ln1255">  </a>
<a name="ln1256">  oi-&gt;cost = lcost;</a>
<a name="ln1257">  SET_FLAG (oi-&gt;flag, OSPF6_INTERFACE_NOAUTOCOST);</a>
<a name="ln1258"> </a>
<a name="ln1259">  ospf6_interface_recalculate_cost(oi);</a>
<a name="ln1260"> </a>
<a name="ln1261">  return CMD_SUCCESS;</a>
<a name="ln1262">}</a>
<a name="ln1263"> </a>
<a name="ln1264">DEFUN (no_ipv6_ospf6_cost,</a>
<a name="ln1265">       no_ipv6_ospf6_cost_cmd,</a>
<a name="ln1266">       &quot;no ipv6 ospf6 cost&quot;,</a>
<a name="ln1267">       NO_STR</a>
<a name="ln1268">       IP6_STR</a>
<a name="ln1269">       OSPF6_STR</a>
<a name="ln1270">       &quot;Calculate interface cost from bandwidth\n&quot;</a>
<a name="ln1271">       )</a>
<a name="ln1272">{</a>
<a name="ln1273">  struct ospf6_interface *oi;</a>
<a name="ln1274">  struct interface *ifp;</a>
<a name="ln1275"> </a>
<a name="ln1276">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1277">  assert (ifp);</a>
<a name="ln1278"> </a>
<a name="ln1279">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1280">  if (oi == NULL)</a>
<a name="ln1281">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1282">  assert (oi);</a>
<a name="ln1283"> </a>
<a name="ln1284">  UNSET_FLAG (oi-&gt;flag, OSPF6_INTERFACE_NOAUTOCOST);</a>
<a name="ln1285"> </a>
<a name="ln1286">  ospf6_interface_recalculate_cost(oi);</a>
<a name="ln1287"> </a>
<a name="ln1288">  return CMD_SUCCESS;</a>
<a name="ln1289">}</a>
<a name="ln1290"> </a>
<a name="ln1291">DEFUN (auto_cost_reference_bandwidth,</a>
<a name="ln1292">       auto_cost_reference_bandwidth_cmd,</a>
<a name="ln1293">       &quot;auto-cost reference-bandwidth &lt;1-4294967&gt;&quot;,</a>
<a name="ln1294">       &quot;Calculate OSPF interface cost according to bandwidth\n&quot;</a>
<a name="ln1295">       &quot;Use reference bandwidth method to assign OSPF cost\n&quot;</a>
<a name="ln1296">       &quot;The reference bandwidth in terms of Mbits per second\n&quot;)</a>
<a name="ln1297">{</a>
<a name="ln1298">  struct ospf6 *o = vty-&gt;index;</a>
<a name="ln1299">  struct ospf6_area *oa;</a>
<a name="ln1300">  struct ospf6_interface *oi;</a>
<a name="ln1301">  struct listnode *i, *j;</a>
<a name="ln1302">  u_int32_t refbw;</a>
<a name="ln1303"> </a>
<a name="ln1304">  refbw = strtol (argv[0], NULL, 10);</a>
<a name="ln1305">  if (refbw &lt; 1 || refbw &gt; 4294967)</a>
<a name="ln1306">    {</a>
<a name="ln1307">      vty_out (vty, &quot;reference-bandwidth value is invalid%s&quot;, VTY_NEWLINE);</a>
<a name="ln1308">      return CMD_WARNING;</a>
<a name="ln1309">    }</a>
<a name="ln1310"> </a>
<a name="ln1311">  /* If reference bandwidth is changed. */</a>
<a name="ln1312">  if ((refbw * 1000) == o-&gt;ref_bandwidth)</a>
<a name="ln1313">    return CMD_SUCCESS;</a>
<a name="ln1314"> </a>
<a name="ln1315">  o-&gt;ref_bandwidth = refbw * 1000;</a>
<a name="ln1316">  for (ALL_LIST_ELEMENTS_RO (o-&gt;area_list, i, oa))</a>
<a name="ln1317">      for (ALL_LIST_ELEMENTS_RO (oa-&gt;if_list, j, oi))</a>
<a name="ln1318">          ospf6_interface_recalculate_cost (oi);</a>
<a name="ln1319"> </a>
<a name="ln1320">  return CMD_SUCCESS;</a>
<a name="ln1321">}</a>
<a name="ln1322"> </a>
<a name="ln1323">DEFUN (no_auto_cost_reference_bandwidth,</a>
<a name="ln1324">       no_auto_cost_reference_bandwidth_cmd,</a>
<a name="ln1325">       &quot;no auto-cost reference-bandwidth&quot;,</a>
<a name="ln1326">       NO_STR</a>
<a name="ln1327">       &quot;Calculate OSPF interface cost according to bandwidth\n&quot;</a>
<a name="ln1328">       &quot;Use reference bandwidth method to assign OSPF cost\n&quot;)</a>
<a name="ln1329">{</a>
<a name="ln1330">  struct ospf6 *o = vty-&gt;index;</a>
<a name="ln1331">  struct ospf6_area *oa;</a>
<a name="ln1332">  struct ospf6_interface *oi;</a>
<a name="ln1333">  struct listnode *i, *j;</a>
<a name="ln1334"> </a>
<a name="ln1335">  if (o-&gt;ref_bandwidth == OSPF6_REFERENCE_BANDWIDTH)</a>
<a name="ln1336">    return CMD_SUCCESS;</a>
<a name="ln1337"> </a>
<a name="ln1338">  o-&gt;ref_bandwidth = OSPF6_REFERENCE_BANDWIDTH;</a>
<a name="ln1339">  for (ALL_LIST_ELEMENTS_RO (o-&gt;area_list, i, oa))</a>
<a name="ln1340">      for (ALL_LIST_ELEMENTS_RO (oa-&gt;if_list, j, oi))</a>
<a name="ln1341">          ospf6_interface_recalculate_cost (oi);</a>
<a name="ln1342"> </a>
<a name="ln1343">  return CMD_SUCCESS;</a>
<a name="ln1344">}</a>
<a name="ln1345"> </a>
<a name="ln1346">DEFUN (ipv6_ospf6_hellointerval,</a>
<a name="ln1347">       ipv6_ospf6_hellointerval_cmd,</a>
<a name="ln1348">       &quot;ipv6 ospf6 hello-interval &lt;1-65535&gt;&quot;,</a>
<a name="ln1349">       IP6_STR</a>
<a name="ln1350">       OSPF6_STR</a>
<a name="ln1351">       &quot;Interval time of Hello packets\n&quot;</a>
<a name="ln1352">       SECONDS_STR</a>
<a name="ln1353">       )</a>
<a name="ln1354">{</a>
<a name="ln1355">  struct ospf6_interface *oi;</a>
<a name="ln1356">  struct interface *ifp;</a>
<a name="ln1357"> </a>
<a name="ln1358">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1359">  assert (ifp);</a>
<a name="ln1360"> </a>
<a name="ln1361">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1362">  if (oi == NULL)</a>
<a name="ln1363">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1364">  assert (oi);</a>
<a name="ln1365"> </a>
<a name="ln1366">  oi-&gt;hello_interval = strtol (argv[0], NULL, 10);</a>
<a name="ln1367">  return CMD_SUCCESS;</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>
<a name="ln1370">/* interface variable set command */</a>
<a name="ln1371">DEFUN (ipv6_ospf6_deadinterval,</a>
<a name="ln1372">       ipv6_ospf6_deadinterval_cmd,</a>
<a name="ln1373">       &quot;ipv6 ospf6 dead-interval &lt;1-65535&gt;&quot;,</a>
<a name="ln1374">       IP6_STR</a>
<a name="ln1375">       OSPF6_STR</a>
<a name="ln1376">       &quot;Interval time after which a neighbor is declared down\n&quot;</a>
<a name="ln1377">       SECONDS_STR</a>
<a name="ln1378">       )</a>
<a name="ln1379">{</a>
<a name="ln1380">  struct ospf6_interface *oi;</a>
<a name="ln1381">  struct interface *ifp;</a>
<a name="ln1382"> </a>
<a name="ln1383">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1384">  assert (ifp);</a>
<a name="ln1385"> </a>
<a name="ln1386">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1387">  if (oi == NULL)</a>
<a name="ln1388">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1389">  assert (oi);</a>
<a name="ln1390"> </a>
<a name="ln1391">  oi-&gt;dead_interval = strtol (argv[0], NULL, 10);</a>
<a name="ln1392">  return CMD_SUCCESS;</a>
<a name="ln1393">}</a>
<a name="ln1394"> </a>
<a name="ln1395">/* interface variable set command */</a>
<a name="ln1396">DEFUN (ipv6_ospf6_transmitdelay,</a>
<a name="ln1397">       ipv6_ospf6_transmitdelay_cmd,</a>
<a name="ln1398">       &quot;ipv6 ospf6 transmit-delay &lt;1-3600&gt;&quot;,</a>
<a name="ln1399">       IP6_STR</a>
<a name="ln1400">       OSPF6_STR</a>
<a name="ln1401">       &quot;Transmit delay of this interface\n&quot;</a>
<a name="ln1402">       SECONDS_STR</a>
<a name="ln1403">       )</a>
<a name="ln1404">{</a>
<a name="ln1405">  struct ospf6_interface *oi;</a>
<a name="ln1406">  struct interface *ifp;</a>
<a name="ln1407"> </a>
<a name="ln1408">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1409">  assert (ifp);</a>
<a name="ln1410"> </a>
<a name="ln1411">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1412">  if (oi == NULL)</a>
<a name="ln1413">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1414">  assert (oi);</a>
<a name="ln1415"> </a>
<a name="ln1416">  oi-&gt;transdelay = strtol (argv[0], NULL, 10);</a>
<a name="ln1417">  return CMD_SUCCESS;</a>
<a name="ln1418">}</a>
<a name="ln1419"> </a>
<a name="ln1420">/* interface variable set command */</a>
<a name="ln1421">DEFUN (ipv6_ospf6_retransmitinterval,</a>
<a name="ln1422">       ipv6_ospf6_retransmitinterval_cmd,</a>
<a name="ln1423">       &quot;ipv6 ospf6 retransmit-interval &lt;1-65535&gt;&quot;,</a>
<a name="ln1424">       IP6_STR</a>
<a name="ln1425">       OSPF6_STR</a>
<a name="ln1426">       &quot;Time between retransmitting lost link state advertisements\n&quot;</a>
<a name="ln1427">       SECONDS_STR</a>
<a name="ln1428">       )</a>
<a name="ln1429">{</a>
<a name="ln1430">  struct ospf6_interface *oi;</a>
<a name="ln1431">  struct interface *ifp;</a>
<a name="ln1432"> </a>
<a name="ln1433">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1434">  assert (ifp);</a>
<a name="ln1435"> </a>
<a name="ln1436">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1437">  if (oi == NULL)</a>
<a name="ln1438">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1439">  assert (oi);</a>
<a name="ln1440"> </a>
<a name="ln1441">  oi-&gt;rxmt_interval = strtol (argv[0], NULL, 10);</a>
<a name="ln1442">  return CMD_SUCCESS;</a>
<a name="ln1443">}</a>
<a name="ln1444"> </a>
<a name="ln1445">/* interface variable set command */</a>
<a name="ln1446">DEFUN (ipv6_ospf6_priority,</a>
<a name="ln1447">       ipv6_ospf6_priority_cmd,</a>
<a name="ln1448">       &quot;ipv6 ospf6 priority &lt;0-255&gt;&quot;,</a>
<a name="ln1449">       IP6_STR</a>
<a name="ln1450">       OSPF6_STR</a>
<a name="ln1451">       &quot;Router priority\n&quot;</a>
<a name="ln1452">       &quot;Priority value\n&quot;</a>
<a name="ln1453">       )</a>
<a name="ln1454">{</a>
<a name="ln1455">  struct ospf6_interface *oi;</a>
<a name="ln1456">  struct interface *ifp;</a>
<a name="ln1457"> </a>
<a name="ln1458">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1459">  assert (ifp);</a>
<a name="ln1460"> </a>
<a name="ln1461">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1462">  if (oi == NULL)</a>
<a name="ln1463">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1464">  assert (oi);</a>
<a name="ln1465"> </a>
<a name="ln1466">  oi-&gt;priority = strtol (argv[0], NULL, 10);</a>
<a name="ln1467"> </a>
<a name="ln1468">  if (oi-&gt;area &amp;&amp;</a>
<a name="ln1469">      (oi-&gt;state == OSPF6_INTERFACE_DROTHER ||</a>
<a name="ln1470">       oi-&gt;state == OSPF6_INTERFACE_BDR ||</a>
<a name="ln1471">       oi-&gt;state == OSPF6_INTERFACE_DR))</a>
<a name="ln1472">    ospf6_interface_state_change (dr_election (oi), oi);</a>
<a name="ln1473"> </a>
<a name="ln1474">  return CMD_SUCCESS;</a>
<a name="ln1475">}</a>
<a name="ln1476"> </a>
<a name="ln1477">DEFUN (ipv6_ospf6_instance,</a>
<a name="ln1478">       ipv6_ospf6_instance_cmd,</a>
<a name="ln1479">       &quot;ipv6 ospf6 instance-id &lt;0-255&gt;&quot;,</a>
<a name="ln1480">       IP6_STR</a>
<a name="ln1481">       OSPF6_STR</a>
<a name="ln1482">       &quot;Instance ID for this interface\n&quot;</a>
<a name="ln1483">       &quot;Instance ID value\n&quot;</a>
<a name="ln1484">       )</a>
<a name="ln1485">{</a>
<a name="ln1486">  struct ospf6_interface *oi;</a>
<a name="ln1487">  struct interface *ifp;</a>
<a name="ln1488"> </a>
<a name="ln1489">  ifp = (struct interface *)vty-&gt;index;</a>
<a name="ln1490">  assert (ifp);</a>
<a name="ln1491"> </a>
<a name="ln1492">  oi = (struct ospf6_interface *)ifp-&gt;info;</a>
<a name="ln1493">  if (oi == NULL)</a>
<a name="ln1494">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1495">  assert (oi);</a>
<a name="ln1496"> </a>
<a name="ln1497">  oi-&gt;instance_id = strtol (argv[0], NULL, 10);</a>
<a name="ln1498">  return CMD_SUCCESS;</a>
<a name="ln1499">}</a>
<a name="ln1500"> </a>
<a name="ln1501">DEFUN (ipv6_ospf6_passive,</a>
<a name="ln1502">       ipv6_ospf6_passive_cmd,</a>
<a name="ln1503">       &quot;ipv6 ospf6 passive&quot;,</a>
<a name="ln1504">       IP6_STR</a>
<a name="ln1505">       OSPF6_STR</a>
<a name="ln1506">       &quot;passive interface, No adjacency will be formed on this interface\n&quot;</a>
<a name="ln1507">       )</a>
<a name="ln1508">{</a>
<a name="ln1509">  struct ospf6_interface *oi;</a>
<a name="ln1510">  struct interface *ifp;</a>
<a name="ln1511">  struct listnode *node, *nnode;</a>
<a name="ln1512">  struct ospf6_neighbor *on;</a>
<a name="ln1513"> </a>
<a name="ln1514">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1515">  assert (ifp);</a>
<a name="ln1516"> </a>
<a name="ln1517">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1518">  if (oi == NULL)</a>
<a name="ln1519">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1520">  assert (oi);</a>
<a name="ln1521"> </a>
<a name="ln1522">  SET_FLAG (oi-&gt;flag, OSPF6_INTERFACE_PASSIVE);</a>
<a name="ln1523">  THREAD_OFF (oi-&gt;thread_send_hello);</a>
<a name="ln1524"> </a>
<a name="ln1525">  for (ALL_LIST_ELEMENTS (oi-&gt;neighbor_list, node, nnode, on))</a>
<a name="ln1526">    {</a>
<a name="ln1527">      THREAD_OFF (on-&gt;inactivity_timer);</a>
<a name="ln1528">      thread_add_event (master, inactivity_timer, on, 0);</a>
<a name="ln1529">    }</a>
<a name="ln1530"> </a>
<a name="ln1531">  return CMD_SUCCESS;</a>
<a name="ln1532">}</a>
<a name="ln1533"> </a>
<a name="ln1534">DEFUN (no_ipv6_ospf6_passive,</a>
<a name="ln1535">       no_ipv6_ospf6_passive_cmd,</a>
<a name="ln1536">       &quot;no ipv6 ospf6 passive&quot;,</a>
<a name="ln1537">       NO_STR</a>
<a name="ln1538">       IP6_STR</a>
<a name="ln1539">       OSPF6_STR</a>
<a name="ln1540">       &quot;passive interface: No Adjacency will be formed on this I/F\n&quot;</a>
<a name="ln1541">       )</a>
<a name="ln1542">{</a>
<a name="ln1543">  struct ospf6_interface *oi;</a>
<a name="ln1544">  struct interface *ifp;</a>
<a name="ln1545"> </a>
<a name="ln1546">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1547">  assert (ifp);</a>
<a name="ln1548"> </a>
<a name="ln1549">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1550">  if (oi == NULL)</a>
<a name="ln1551">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1552">  assert (oi);</a>
<a name="ln1553"> </a>
<a name="ln1554">  UNSET_FLAG (oi-&gt;flag, OSPF6_INTERFACE_PASSIVE);</a>
<a name="ln1555">  THREAD_OFF (oi-&gt;thread_send_hello);</a>
<a name="ln1556">  oi-&gt;thread_send_hello =</a>
<a name="ln1557">    thread_add_event (master, ospf6_hello_send, oi, 0);</a>
<a name="ln1558"> </a>
<a name="ln1559">  return CMD_SUCCESS;</a>
<a name="ln1560">}</a>
<a name="ln1561"> </a>
<a name="ln1562">DEFUN (ipv6_ospf6_mtu_ignore,</a>
<a name="ln1563">       ipv6_ospf6_mtu_ignore_cmd,</a>
<a name="ln1564">       &quot;ipv6 ospf6 mtu-ignore&quot;,</a>
<a name="ln1565">       IP6_STR</a>
<a name="ln1566">       OSPF6_STR</a>
<a name="ln1567">       &quot;Ignore MTU mismatch on this interface\n&quot;</a>
<a name="ln1568">       )</a>
<a name="ln1569">{</a>
<a name="ln1570">  struct ospf6_interface *oi;</a>
<a name="ln1571">  struct interface *ifp;</a>
<a name="ln1572"> </a>
<a name="ln1573">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1574">  assert (ifp);</a>
<a name="ln1575"> </a>
<a name="ln1576">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1577">  if (oi == NULL)</a>
<a name="ln1578">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1579">  assert (oi);</a>
<a name="ln1580"> </a>
<a name="ln1581">  oi-&gt;mtu_ignore = 1;</a>
<a name="ln1582"> </a>
<a name="ln1583">  return CMD_SUCCESS;</a>
<a name="ln1584">}</a>
<a name="ln1585"> </a>
<a name="ln1586">DEFUN (no_ipv6_ospf6_mtu_ignore,</a>
<a name="ln1587">       no_ipv6_ospf6_mtu_ignore_cmd,</a>
<a name="ln1588">       &quot;no ipv6 ospf6 mtu-ignore&quot;,</a>
<a name="ln1589">       NO_STR</a>
<a name="ln1590">       IP6_STR</a>
<a name="ln1591">       OSPF6_STR</a>
<a name="ln1592">       &quot;Ignore MTU mismatch on this interface\n&quot;</a>
<a name="ln1593">       )</a>
<a name="ln1594">{</a>
<a name="ln1595">  struct ospf6_interface *oi;</a>
<a name="ln1596">  struct interface *ifp;</a>
<a name="ln1597"> </a>
<a name="ln1598">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1599">  assert (ifp);</a>
<a name="ln1600"> </a>
<a name="ln1601">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1602">  if (oi == NULL)</a>
<a name="ln1603">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1604">  assert (oi);</a>
<a name="ln1605"> </a>
<a name="ln1606">  oi-&gt;mtu_ignore = 0;</a>
<a name="ln1607"> </a>
<a name="ln1608">  return CMD_SUCCESS;</a>
<a name="ln1609">}</a>
<a name="ln1610"> </a>
<a name="ln1611">DEFUN (ipv6_ospf6_advertise_prefix_list,</a>
<a name="ln1612">       ipv6_ospf6_advertise_prefix_list_cmd,</a>
<a name="ln1613">       &quot;ipv6 ospf6 advertise prefix-list WORD&quot;,</a>
<a name="ln1614">       IP6_STR</a>
<a name="ln1615">       OSPF6_STR</a>
<a name="ln1616">       &quot;Advertising options\n&quot;</a>
<a name="ln1617">       &quot;Filter prefix using prefix-list\n&quot;</a>
<a name="ln1618">       &quot;Prefix list name\n&quot;</a>
<a name="ln1619">       )</a>
<a name="ln1620">{</a>
<a name="ln1621">  struct ospf6_interface *oi;</a>
<a name="ln1622">  struct interface *ifp;</a>
<a name="ln1623"> </a>
<a name="ln1624">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1625">  assert (ifp);</a>
<a name="ln1626"> </a>
<a name="ln1627">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1628">  if (oi == NULL)</a>
<a name="ln1629">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1630">  assert (oi);</a>
<a name="ln1631"> </a>
<a name="ln1632">  if (oi-&gt;plist_name)</a>
<a name="ln1633">    XFREE (MTYPE_PREFIX_LIST_STR, oi-&gt;plist_name);</a>
<a name="ln1634">  oi-&gt;plist_name = XSTRDUP (MTYPE_PREFIX_LIST_STR, argv[0]);</a>
<a name="ln1635"> </a>
<a name="ln1636">  ospf6_interface_connected_route_update (oi-&gt;interface);</a>
<a name="ln1637"> </a>
<a name="ln1638">  if (oi-&gt;area)</a>
<a name="ln1639">    {</a>
<a name="ln1640">      OSPF6_LINK_LSA_SCHEDULE (oi);</a>
<a name="ln1641">      if (oi-&gt;state == OSPF6_INTERFACE_DR)</a>
<a name="ln1642">        {</a>
<a name="ln1643">          OSPF6_NETWORK_LSA_SCHEDULE (oi);</a>
<a name="ln1644">          OSPF6_INTRA_PREFIX_LSA_SCHEDULE_TRANSIT (oi);</a>
<a name="ln1645">        }</a>
<a name="ln1646">      OSPF6_INTRA_PREFIX_LSA_SCHEDULE_STUB (oi-&gt;area);</a>
<a name="ln1647">    }</a>
<a name="ln1648"> </a>
<a name="ln1649">  return CMD_SUCCESS;</a>
<a name="ln1650">}</a>
<a name="ln1651"> </a>
<a name="ln1652">DEFUN (no_ipv6_ospf6_advertise_prefix_list,</a>
<a name="ln1653">       no_ipv6_ospf6_advertise_prefix_list_cmd,</a>
<a name="ln1654">       &quot;no ipv6 ospf6 advertise prefix-list&quot;,</a>
<a name="ln1655">       NO_STR</a>
<a name="ln1656">       IP6_STR</a>
<a name="ln1657">       OSPF6_STR</a>
<a name="ln1658">       &quot;Advertising options\n&quot;</a>
<a name="ln1659">       &quot;Filter prefix using prefix-list\n&quot;</a>
<a name="ln1660">       )</a>
<a name="ln1661">{</a>
<a name="ln1662">  struct ospf6_interface *oi;</a>
<a name="ln1663">  struct interface *ifp;</a>
<a name="ln1664"> </a>
<a name="ln1665">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1666">  assert (ifp);</a>
<a name="ln1667"> </a>
<a name="ln1668">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1669">  if (oi == NULL)</a>
<a name="ln1670">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1671">  assert (oi);</a>
<a name="ln1672"> </a>
<a name="ln1673">  if (oi-&gt;plist_name)</a>
<a name="ln1674">    {</a>
<a name="ln1675">      XFREE (MTYPE_PREFIX_LIST_STR, oi-&gt;plist_name);</a>
<a name="ln1676">      oi-&gt;plist_name = NULL;</a>
<a name="ln1677">    }</a>
<a name="ln1678"> </a>
<a name="ln1679">  ospf6_interface_connected_route_update (oi-&gt;interface);</a>
<a name="ln1680"> </a>
<a name="ln1681">  if (oi-&gt;area)</a>
<a name="ln1682">    {</a>
<a name="ln1683">      OSPF6_LINK_LSA_SCHEDULE (oi);</a>
<a name="ln1684">      if (oi-&gt;state == OSPF6_INTERFACE_DR)</a>
<a name="ln1685">        {</a>
<a name="ln1686">          OSPF6_NETWORK_LSA_SCHEDULE (oi);</a>
<a name="ln1687">          OSPF6_INTRA_PREFIX_LSA_SCHEDULE_TRANSIT (oi);</a>
<a name="ln1688">        }</a>
<a name="ln1689">      OSPF6_INTRA_PREFIX_LSA_SCHEDULE_STUB (oi-&gt;area);</a>
<a name="ln1690">    }</a>
<a name="ln1691"> </a>
<a name="ln1692">  return CMD_SUCCESS;</a>
<a name="ln1693">}</a>
<a name="ln1694"> </a>
<a name="ln1695">DEFUN (ipv6_ospf6_network,</a>
<a name="ln1696">       ipv6_ospf6_network_cmd,</a>
<a name="ln1697">       &quot;ipv6 ospf6 network (broadcast|point-to-point)&quot;,</a>
<a name="ln1698">       IP6_STR</a>
<a name="ln1699">       OSPF6_STR</a>
<a name="ln1700">       &quot;Network Type\n&quot;</a>
<a name="ln1701">       &quot;Specify OSPFv6 broadcast network\n&quot;</a>
<a name="ln1702">       &quot;Specify OSPF6 point-to-point network\n&quot;</a>
<a name="ln1703">       )</a>
<a name="ln1704">{</a>
<a name="ln1705">  struct ospf6_interface *oi;</a>
<a name="ln1706">  struct interface *ifp;</a>
<a name="ln1707"> </a>
<a name="ln1708">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1709">  assert (ifp);</a>
<a name="ln1710"> </a>
<a name="ln1711">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1712">  if (oi == NULL) {</a>
<a name="ln1713">    oi = ospf6_interface_create (ifp);</a>
<a name="ln1714">  }</a>
<a name="ln1715">  assert (oi);</a>
<a name="ln1716"> </a>
<a name="ln1717">  if (strncmp (argv[0], &quot;b&quot;, 1) == 0)</a>
<a name="ln1718">    {</a>
<a name="ln1719">      if (oi-&gt;type == OSPF_IFTYPE_BROADCAST)</a>
<a name="ln1720">	return CMD_SUCCESS;</a>
<a name="ln1721"> </a>
<a name="ln1722">      oi-&gt;type = OSPF_IFTYPE_BROADCAST;</a>
<a name="ln1723">    }</a>
<a name="ln1724">    else if (strncmp (argv[0], &quot;point-to-p&quot;, 10) == 0)</a>
<a name="ln1725">      {</a>
<a name="ln1726">	if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT) {</a>
<a name="ln1727">	  return CMD_SUCCESS;</a>
<a name="ln1728">	}</a>
<a name="ln1729">	oi-&gt;type = OSPF_IFTYPE_POINTOPOINT;</a>
<a name="ln1730">      }</a>
<a name="ln1731"> </a>
<a name="ln1732">  /* Reset the interface */</a>
<a name="ln1733">  thread_add_event (master, interface_down, oi, 0);</a>
<a name="ln1734">  thread_add_event (master, interface_up, oi, 0);</a>
<a name="ln1735"> </a>
<a name="ln1736">  return CMD_SUCCESS;</a>
<a name="ln1737">}</a>
<a name="ln1738"> </a>
<a name="ln1739">DEFUN (no_ipv6_ospf6_network,</a>
<a name="ln1740">       no_ipv6_ospf6_network_cmd,</a>
<a name="ln1741">       &quot;no ipv6 ospf6 network&quot;,</a>
<a name="ln1742">       NO_STR</a>
<a name="ln1743">       IP6_STR</a>
<a name="ln1744">       OSPF6_STR</a>
<a name="ln1745">       &quot;Network Type\n&quot;</a>
<a name="ln1746">       &quot;Default to whatever interface type system specifies&quot;</a>
<a name="ln1747">       )</a>
<a name="ln1748">{</a>
<a name="ln1749">  struct ospf6_interface *oi;</a>
<a name="ln1750">  struct interface *ifp;</a>
<a name="ln1751">  int type;</a>
<a name="ln1752"> </a>
<a name="ln1753">  ifp = (struct interface *) vty-&gt;index;</a>
<a name="ln1754">  assert (ifp);</a>
<a name="ln1755"> </a>
<a name="ln1756">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1757">  if (oi == NULL) {</a>
<a name="ln1758">    return CMD_SUCCESS;</a>
<a name="ln1759">  }</a>
<a name="ln1760"> </a>
<a name="ln1761">  type = ospf6_default_iftype (ifp);</a>
<a name="ln1762">  if (oi-&gt;type == type)</a>
<a name="ln1763">    {</a>
<a name="ln1764">      return CMD_SUCCESS;</a>
<a name="ln1765">    }</a>
<a name="ln1766">  oi-&gt;type = type;</a>
<a name="ln1767"> </a>
<a name="ln1768">  /* Reset the interface */</a>
<a name="ln1769">  thread_add_event (master, interface_down, oi, 0);</a>
<a name="ln1770">  thread_add_event (master, interface_up, oi, 0);</a>
<a name="ln1771"> </a>
<a name="ln1772">  return CMD_SUCCESS;</a>
<a name="ln1773">}</a>
<a name="ln1774"> </a>
<a name="ln1775">static int</a>
<a name="ln1776">config_write_ospf6_interface (struct vty *vty)</a>
<a name="ln1777">{</a>
<a name="ln1778">  struct listnode *i;</a>
<a name="ln1779">  struct ospf6_interface *oi;</a>
<a name="ln1780">  struct interface *ifp;</a>
<a name="ln1781"> </a>
<a name="ln1782">  for (ALL_LIST_ELEMENTS_RO (iflist, i, ifp))</a>
<a name="ln1783">    {</a>
<a name="ln1784">      oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1785">      if (oi == NULL)</a>
<a name="ln1786">        continue;</a>
<a name="ln1787"> </a>
<a name="ln1788">      vty_out (vty, &quot;interface %s%s&quot;,</a>
<a name="ln1789">               oi-&gt;interface-&gt;name, VNL);</a>
<a name="ln1790"> </a>
<a name="ln1791">      if (ifp-&gt;desc)</a>
<a name="ln1792">        vty_out (vty, &quot; description %s%s&quot;, ifp-&gt;desc, VNL);</a>
<a name="ln1793">      if (ifp-&gt;mtu6 != oi-&gt;ifmtu)</a>
<a name="ln1794">        vty_out (vty, &quot; ipv6 ospf6 ifmtu %d%s&quot;, oi-&gt;ifmtu, VNL);</a>
<a name="ln1795"> </a>
<a name="ln1796">      if (CHECK_FLAG (oi-&gt;flag, OSPF6_INTERFACE_NOAUTOCOST))</a>
<a name="ln1797">        vty_out (vty, &quot; ipv6 ospf6 cost %d%s&quot;,</a>
<a name="ln1798">                 oi-&gt;cost, VNL);</a>
<a name="ln1799"> </a>
<a name="ln1800">      if (oi-&gt;hello_interval != OSPF6_INTERFACE_HELLO_INTERVAL)</a>
<a name="ln1801">        vty_out (vty, &quot; ipv6 ospf6 hello-interval %d%s&quot;,</a>
<a name="ln1802">                 oi-&gt;hello_interval, VNL);</a>
<a name="ln1803"> </a>
<a name="ln1804">      if (oi-&gt;dead_interval != OSPF6_INTERFACE_DEAD_INTERVAL)</a>
<a name="ln1805">        vty_out (vty, &quot; ipv6 ospf6 dead-interval %d%s&quot;,</a>
<a name="ln1806">                 oi-&gt;dead_interval, VNL);</a>
<a name="ln1807"> </a>
<a name="ln1808">      if (oi-&gt;rxmt_interval != OSPF6_INTERFACE_RXMT_INTERVAL)</a>
<a name="ln1809">        vty_out (vty, &quot; ipv6 ospf6 retransmit-interval %d%s&quot;,</a>
<a name="ln1810">                 oi-&gt;rxmt_interval, VNL);</a>
<a name="ln1811"> </a>
<a name="ln1812">      if (oi-&gt;priority != OSPF6_INTERFACE_PRIORITY)</a>
<a name="ln1813">        vty_out (vty, &quot; ipv6 ospf6 priority %d%s&quot;,</a>
<a name="ln1814">                 oi-&gt;priority, VNL);</a>
<a name="ln1815"> </a>
<a name="ln1816">      if (oi-&gt;transdelay != OSPF6_INTERFACE_TRANSDELAY)</a>
<a name="ln1817">        vty_out (vty, &quot; ipv6 ospf6 transmit-delay %d%s&quot;,</a>
<a name="ln1818">                 oi-&gt;transdelay, VNL);</a>
<a name="ln1819"> </a>
<a name="ln1820">      if (oi-&gt;instance_id != OSPF6_INTERFACE_INSTANCE_ID)</a>
<a name="ln1821">        vty_out (vty, &quot; ipv6 ospf6 instance-id %d%s&quot;,</a>
<a name="ln1822">                 oi-&gt;instance_id, VNL);</a>
<a name="ln1823"> </a>
<a name="ln1824">      if (oi-&gt;plist_name)</a>
<a name="ln1825">        vty_out (vty, &quot; ipv6 ospf6 advertise prefix-list %s%s&quot;,</a>
<a name="ln1826">                 oi-&gt;plist_name, VNL);</a>
<a name="ln1827"> </a>
<a name="ln1828">      if (CHECK_FLAG (oi-&gt;flag, OSPF6_INTERFACE_PASSIVE))</a>
<a name="ln1829">        vty_out (vty, &quot; ipv6 ospf6 passive%s&quot;, VNL);</a>
<a name="ln1830"> </a>
<a name="ln1831">      if (oi-&gt;mtu_ignore)</a>
<a name="ln1832">        vty_out (vty, &quot; ipv6 ospf6 mtu-ignore%s&quot;, VNL);</a>
<a name="ln1833"> </a>
<a name="ln1834">      if (oi-&gt;type == OSPF_IFTYPE_POINTOPOINT)</a>
<a name="ln1835">        vty_out (vty, &quot; ipv6 ospf6 network point-to-point%s&quot;, VNL);</a>
<a name="ln1836">      else if (oi-&gt;type == OSPF_IFTYPE_BROADCAST)</a>
<a name="ln1837">	vty_out (vty, &quot; ipv6 ospf6 network broadcast%s&quot;, VNL);</a>
<a name="ln1838"> </a>
<a name="ln1839">      vty_out (vty, &quot;!%s&quot;, VNL);</a>
<a name="ln1840">    }</a>
<a name="ln1841">  return 0;</a>
<a name="ln1842">}</a>
<a name="ln1843"> </a>
<a name="ln1844">static struct cmd_node interface_node =</a>
<a name="ln1845">{</a>
<a name="ln1846">  INTERFACE_NODE,</a>
<a name="ln1847">  &quot;%s(config-if)# &quot;,</a>
<a name="ln1848">  1 /* VTYSH */</a>
<a name="ln1849">};</a>
<a name="ln1850"> </a>
<a name="ln1851">void</a>
<a name="ln1852">ospf6_interface_init (void)</a>
<a name="ln1853">{</a>
<a name="ln1854">  /* Install interface node. */</a>
<a name="ln1855">  install_node (&amp;interface_node, config_write_ospf6_interface);</a>
<a name="ln1856"> </a>
<a name="ln1857">  install_element (VIEW_NODE, &amp;show_ipv6_ospf6_interface_cmd);</a>
<a name="ln1858">  install_element (VIEW_NODE, &amp;show_ipv6_ospf6_interface_prefix_cmd);</a>
<a name="ln1859">  install_element (VIEW_NODE, &amp;show_ipv6_ospf6_interface_prefix_detail_cmd);</a>
<a name="ln1860">  install_element (VIEW_NODE, &amp;show_ipv6_ospf6_interface_prefix_match_cmd);</a>
<a name="ln1861">  install_element (VIEW_NODE, &amp;show_ipv6_ospf6_interface_ifname_cmd);</a>
<a name="ln1862">  install_element (VIEW_NODE, &amp;show_ipv6_ospf6_interface_ifname_prefix_cmd);</a>
<a name="ln1863">  install_element (VIEW_NODE, &amp;show_ipv6_ospf6_interface_ifname_prefix_detail_cmd);</a>
<a name="ln1864">  install_element (VIEW_NODE, &amp;show_ipv6_ospf6_interface_ifname_prefix_match_cmd);</a>
<a name="ln1865"> </a>
<a name="ln1866">  install_element (CONFIG_NODE, &amp;interface_cmd);</a>
<a name="ln1867">  install_default (INTERFACE_NODE);</a>
<a name="ln1868">  install_element (INTERFACE_NODE, &amp;interface_desc_cmd);</a>
<a name="ln1869">  install_element (INTERFACE_NODE, &amp;no_interface_desc_cmd);</a>
<a name="ln1870">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_cost_cmd);</a>
<a name="ln1871">  install_element (INTERFACE_NODE, &amp;no_ipv6_ospf6_cost_cmd);</a>
<a name="ln1872">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_ifmtu_cmd);</a>
<a name="ln1873">  install_element (INTERFACE_NODE, &amp;no_ipv6_ospf6_ifmtu_cmd);</a>
<a name="ln1874">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_deadinterval_cmd);</a>
<a name="ln1875">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_hellointerval_cmd);</a>
<a name="ln1876">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_priority_cmd);</a>
<a name="ln1877">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_retransmitinterval_cmd);</a>
<a name="ln1878">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_transmitdelay_cmd);</a>
<a name="ln1879">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_instance_cmd);</a>
<a name="ln1880"> </a>
<a name="ln1881">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_passive_cmd);</a>
<a name="ln1882">  install_element (INTERFACE_NODE, &amp;no_ipv6_ospf6_passive_cmd);</a>
<a name="ln1883"> </a>
<a name="ln1884">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_mtu_ignore_cmd);</a>
<a name="ln1885">  install_element (INTERFACE_NODE, &amp;no_ipv6_ospf6_mtu_ignore_cmd);</a>
<a name="ln1886"> </a>
<a name="ln1887">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_advertise_prefix_list_cmd);</a>
<a name="ln1888">  install_element (INTERFACE_NODE, &amp;no_ipv6_ospf6_advertise_prefix_list_cmd);</a>
<a name="ln1889"> </a>
<a name="ln1890">  install_element (INTERFACE_NODE, &amp;ipv6_ospf6_network_cmd);</a>
<a name="ln1891">  install_element (INTERFACE_NODE, &amp;no_ipv6_ospf6_network_cmd);</a>
<a name="ln1892"> </a>
<a name="ln1893">  /* reference bandwidth commands */</a>
<a name="ln1894">  install_element (OSPF6_NODE, &amp;auto_cost_reference_bandwidth_cmd);</a>
<a name="ln1895">  install_element (OSPF6_NODE, &amp;no_auto_cost_reference_bandwidth_cmd);</a>
<a name="ln1896">}</a>
<a name="ln1897"> </a>
<a name="ln1898">/* Clear the specified interface structure */</a>
<a name="ln1899">static void</a>
<a name="ln1900">ospf6_interface_clear (struct vty *vty, struct interface *ifp)</a>
<a name="ln1901">{</a>
<a name="ln1902">  struct ospf6_interface *oi;</a>
<a name="ln1903"> </a>
<a name="ln1904">  if (!if_is_operative (ifp))</a>
<a name="ln1905">    return;</a>
<a name="ln1906"> </a>
<a name="ln1907">  if (ifp-&gt;info == NULL)</a>
<a name="ln1908">    return;</a>
<a name="ln1909"> </a>
<a name="ln1910">  oi = (struct ospf6_interface *) ifp-&gt;info;</a>
<a name="ln1911"> </a>
<a name="ln1912">  if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln1913">    zlog_debug (&quot;Interface %s: clear by reset&quot;, ifp-&gt;name);</a>
<a name="ln1914"> </a>
<a name="ln1915">  /* Reset the interface */</a>
<a name="ln1916">  thread_add_event (master, interface_down, oi, 0);</a>
<a name="ln1917">  thread_add_event (master, interface_up, oi, 0);</a>
<a name="ln1918">}</a>
<a name="ln1919"> </a>
<a name="ln1920">/* Clear interface */</a>
<a name="ln1921">DEFUN (clear_ipv6_ospf6_interface,</a>
<a name="ln1922">       clear_ipv6_ospf6_interface_cmd,</a>
<a name="ln1923">       &quot;clear ipv6 ospf6 interface [IFNAME]&quot;,</a>
<a name="ln1924">       CLEAR_STR</a>
<a name="ln1925">       IP6_STR</a>
<a name="ln1926">       OSPF6_STR</a>
<a name="ln1927">       INTERFACE_STR</a>
<a name="ln1928">       IFNAME_STR</a>
<a name="ln1929">       )</a>
<a name="ln1930">{</a>
<a name="ln1931">  struct interface *ifp;</a>
<a name="ln1932">  struct listnode *node;</a>
<a name="ln1933"> </a>
<a name="ln1934">  if (argc == 0) /* Clear all the ospfv3 interfaces. */</a>
<a name="ln1935">    {</a>
<a name="ln1936">      for (ALL_LIST_ELEMENTS_RO (iflist, node, ifp))</a>
<a name="ln1937">        ospf6_interface_clear (vty, ifp);</a>
<a name="ln1938">    }</a>
<a name="ln1939">  else /* Interface name is specified. */</a>
<a name="ln1940">    {</a>
<a name="ln1941">      if ((ifp = if_lookup_by_name (argv[0])) == NULL)</a>
<a name="ln1942">        {</a>
<a name="ln1943">          vty_out (vty, &quot;No such Interface: %s%s&quot;, argv[0], VNL);</a>
<a name="ln1944">          return CMD_WARNING;</a>
<a name="ln1945">        }</a>
<a name="ln1946">      ospf6_interface_clear (vty, ifp);</a>
<a name="ln1947">    }</a>
<a name="ln1948"> </a>
<a name="ln1949">  return CMD_SUCCESS;</a>
<a name="ln1950">}</a>
<a name="ln1951"> </a>
<a name="ln1952">void</a>
<a name="ln1953">install_element_ospf6_clear_interface (void)</a>
<a name="ln1954">{</a>
<a name="ln1955">  install_element (ENABLE_NODE, &amp;clear_ipv6_ospf6_interface_cmd);</a>
<a name="ln1956">}</a>
<a name="ln1957"> </a>
<a name="ln1958">DEFUN (debug_ospf6_interface,</a>
<a name="ln1959">       debug_ospf6_interface_cmd,</a>
<a name="ln1960">       &quot;debug ospf6 interface&quot;,</a>
<a name="ln1961">       DEBUG_STR</a>
<a name="ln1962">       OSPF6_STR</a>
<a name="ln1963">       &quot;Debug OSPFv3 Interface\n&quot;</a>
<a name="ln1964">      )</a>
<a name="ln1965">{</a>
<a name="ln1966">  OSPF6_DEBUG_INTERFACE_ON ();</a>
<a name="ln1967">  return CMD_SUCCESS;</a>
<a name="ln1968">}</a>
<a name="ln1969"> </a>
<a name="ln1970">DEFUN (no_debug_ospf6_interface,</a>
<a name="ln1971">       no_debug_ospf6_interface_cmd,</a>
<a name="ln1972">       &quot;no debug ospf6 interface&quot;,</a>
<a name="ln1973">       NO_STR</a>
<a name="ln1974">       DEBUG_STR</a>
<a name="ln1975">       OSPF6_STR</a>
<a name="ln1976">       &quot;Debug OSPFv3 Interface\n&quot;</a>
<a name="ln1977">      )</a>
<a name="ln1978">{</a>
<a name="ln1979">  OSPF6_DEBUG_INTERFACE_OFF ();</a>
<a name="ln1980">  return CMD_SUCCESS;</a>
<a name="ln1981">}</a>
<a name="ln1982"> </a>
<a name="ln1983">int</a>
<a name="ln1984">config_write_ospf6_debug_interface (struct vty *vty)</a>
<a name="ln1985">{</a>
<a name="ln1986">  if (IS_OSPF6_DEBUG_INTERFACE)</a>
<a name="ln1987">    vty_out (vty, &quot;debug ospf6 interface%s&quot;, VNL);</a>
<a name="ln1988">  return 0;</a>
<a name="ln1989">}</a>
<a name="ln1990"> </a>
<a name="ln1991">void</a>
<a name="ln1992">install_element_ospf6_debug_interface (void)</a>
<a name="ln1993">{</a>
<a name="ln1994">  install_element (ENABLE_NODE, &amp;debug_ospf6_interface_cmd);</a>
<a name="ln1995">  install_element (ENABLE_NODE, &amp;no_debug_ospf6_interface_cmd);</a>
<a name="ln1996">  install_element (CONFIG_NODE, &amp;debug_ospf6_interface_cmd);</a>
<a name="ln1997">  install_element (CONFIG_NODE, &amp;no_debug_ospf6_interface_cmd);</a>
<a name="ln1998">}</a>
<a name="ln1999"> </a>
<a name="ln2000"> </a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="138"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'cost > (4294967295U)' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
