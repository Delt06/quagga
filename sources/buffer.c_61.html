
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>buffer.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Buffering of output and input. </a>
<a name="ln3"> * Copyright (C) 1998 Kunihiro Ishiguro</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln8"> * it under the terms of the GNU General Public License as published</a>
<a name="ln9"> * by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln10"> * option) any later version.</a>
<a name="ln11"> * </a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln19"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln20"> * Boston, MA 02111-1307, USA. </a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;buffer.h&quot;</a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &quot;network.h&quot;</a>
<a name="ln29">#include &lt;stddef.h&gt;</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32"> </a>
<a name="ln33">/* Buffer master. */</a>
<a name="ln34">struct buffer</a>
<a name="ln35">{</a>
<a name="ln36">  /* Data list. */</a>
<a name="ln37">  struct buffer_data *head;</a>
<a name="ln38">  struct buffer_data *tail;</a>
<a name="ln39">  </a>
<a name="ln40">  /* Size of each buffer_data chunk. */</a>
<a name="ln41">  size_t size;</a>
<a name="ln42">};</a>
<a name="ln43"> </a>
<a name="ln44">/* Data container. */</a>
<a name="ln45">struct buffer_data</a>
<a name="ln46">{</a>
<a name="ln47">  struct buffer_data *next;</a>
<a name="ln48"> </a>
<a name="ln49">  /* Location to add new data. */</a>
<a name="ln50">  size_t cp;</a>
<a name="ln51"> </a>
<a name="ln52">  /* Pointer to data not yet flushed. */</a>
<a name="ln53">  size_t sp;</a>
<a name="ln54"> </a>
<a name="ln55">  /* Actual data stream (variable length). */</a>
<a name="ln56">  unsigned char data[];  /* real dimension is buffer-&gt;size */</a>
<a name="ln57">};</a>
<a name="ln58"> </a>
<a name="ln59">/* It should always be true that: 0 &lt;= sp &lt;= cp &lt;= size */</a>
<a name="ln60"> </a>
<a name="ln61">/* Default buffer size (used if none specified).  It is rounded up to the</a>
<a name="ln62">   next page boundery. */</a>
<a name="ln63">#define BUFFER_SIZE_DEFAULT		4096</a>
<a name="ln64"> </a>
<a name="ln65"> </a>
<a name="ln66">#define BUFFER_DATA_FREE(D) XFREE(MTYPE_BUFFER_DATA, (D))</a>
<a name="ln67"> </a>
<a name="ln68">/* Make new buffer. */</a>
<a name="ln69">struct buffer *</a>
<a name="ln70">buffer_new (size_t size)</a>
<a name="ln71">{</a>
<a name="ln72">  struct buffer *b;</a>
<a name="ln73"> </a>
<a name="ln74">  b = XCALLOC (MTYPE_BUFFER, sizeof (struct buffer));</a>
<a name="ln75"> </a>
<a name="ln76">  if (size)</a>
<a name="ln77">    b-&gt;size = size;</a>
<a name="ln78">  else</a>
<a name="ln79">    {</a>
<a name="ln80">      static size_t default_size;</a>
<a name="ln81">      if (!default_size)</a>
<a name="ln82">        {</a>
<a name="ln83">	  long pgsz = sysconf(_SC_PAGESIZE);</a>
<a name="ln84">	  default_size = ((((BUFFER_SIZE_DEFAULT-1)/pgsz)+1)*pgsz);</a>
<a name="ln85">	}</a>
<a name="ln86">      b-&gt;size = default_size;</a>
<a name="ln87">    }</a>
<a name="ln88"> </a>
<a name="ln89">  return b;</a>
<a name="ln90">}</a>
<a name="ln91"> </a>
<a name="ln92">/* Free buffer. */</a>
<a name="ln93">void</a>
<a name="ln94">buffer_free (struct buffer *b)</a>
<a name="ln95">{</a>
<a name="ln96">  buffer_reset(b);</a>
<a name="ln97">  XFREE (MTYPE_BUFFER, b);</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">/* Make string clone. */</a>
<a name="ln101">char *</a>
<a name="ln102">buffer_getstr (struct buffer *b)</a>
<a name="ln103">{</a>
<a name="ln104">  size_t totlen = 0;</a>
<a name="ln105">  struct buffer_data *data;</a>
<a name="ln106">  char *s;</a>
<a name="ln107">  char *p;</a>
<a name="ln108"> </a>
<a name="ln109">  for (data = b-&gt;head; data; data = data-&gt;next)</a>
<a name="ln110">    totlen += data-&gt;cp - data-&gt;sp;</a>
<a name="ln111">  if (!(s = XMALLOC(MTYPE_TMP, totlen+1)))</a>
<a name="ln112">    return NULL;</a>
<a name="ln113">  p = s;</a>
<a name="ln114">  for (data = b-&gt;head; data; data = data-&gt;next)</a>
<a name="ln115">    {</a>
<a name="ln116">      memcpy(p, data-&gt;data + data-&gt;sp, data-&gt;cp - data-&gt;sp);</a>
<a name="ln117">      p += data-&gt;cp - data-&gt;sp;</a>
<a name="ln118">    }</a>
<a name="ln119">  *p = '\0';</a>
<a name="ln120">  return s;</a>
<a name="ln121">}</a>
<a name="ln122"> </a>
<a name="ln123">/* Return 1 if buffer is empty. */</a>
<a name="ln124">int</a>
<a name="ln125">buffer_empty (struct buffer *b)</a>
<a name="ln126">{</a>
<a name="ln127">  return (b-&gt;head == NULL);</a>
<a name="ln128">}</a>
<a name="ln129"> </a>
<a name="ln130">/* Clear and free all allocated data. */</a>
<a name="ln131">void</a>
<a name="ln132">buffer_reset (struct buffer *b)</a>
<a name="ln133">{</a>
<a name="ln134">  struct buffer_data *data;</a>
<a name="ln135">  struct buffer_data *next;</a>
<a name="ln136">  </a>
<a name="ln137">  for (data = b-&gt;head; data; data = next)</a>
<a name="ln138">    {</a>
<a name="ln139">      next = data-&gt;next;</a>
<a name="ln140">      BUFFER_DATA_FREE(data);</a>
<a name="ln141">    }</a>
<a name="ln142">  b-&gt;head = b-&gt;tail = NULL;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">/* Add buffer_data to the end of buffer. */</a>
<a name="ln146">static struct buffer_data *</a>
<a name="ln147">buffer_add (struct buffer *b)</a>
<a name="ln148">{</a>
<a name="ln149">  struct buffer_data *d;</a>
<a name="ln150"> </a>
<a name="ln151">  d = XMALLOC(MTYPE_BUFFER_DATA, offsetof(struct buffer_data, data) + b-&gt;size);</a>
<a name="ln152">  d-&gt;cp = d-&gt;sp = 0;</a>
<a name="ln153">  d-&gt;next = NULL;</a>
<a name="ln154"> </a>
<a name="ln155">  if (b-&gt;tail)</a>
<a name="ln156">    b-&gt;tail-&gt;next = d;</a>
<a name="ln157">  else</a>
<a name="ln158">    b-&gt;head = d;</a>
<a name="ln159">  b-&gt;tail = d;</a>
<a name="ln160"> </a>
<a name="ln161">  return d;</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">/* Write data to buffer. */</a>
<a name="ln165">void</a>
<a name="ln166">buffer_put(struct buffer *b, const void *p, size_t size)</a>
<a name="ln167">{</a>
<a name="ln168">  struct buffer_data *data = b-&gt;tail;</a>
<a name="ln169">  const char *ptr = p;</a>
<a name="ln170"> </a>
<a name="ln171">  /* We use even last one byte of data buffer. */</a>
<a name="ln172">  while (size)    </a>
<a name="ln173">    {</a>
<a name="ln174">      size_t chunk;</a>
<a name="ln175"> </a>
<a name="ln176">      /* If there is no data buffer add it. */</a>
<a name="ln177">      if (data == NULL || data-&gt;cp == b-&gt;size)</a>
<a name="ln178">	data = buffer_add (b);</a>
<a name="ln179"> </a>
<a name="ln180">      chunk = ((size &lt;= (b-&gt;size - data-&gt;cp)) ? size : (b-&gt;size - data-&gt;cp));</a>
<a name="ln181">      memcpy ((data-&gt;data + data-&gt;cp), ptr, chunk);</a>
<a name="ln182">      size -= chunk;</a>
<a name="ln183">      ptr += chunk;</a>
<a name="ln184">      data-&gt;cp += chunk;</a>
<a name="ln185">    }</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">/* Insert character into the buffer. */</a>
<a name="ln189">void</a>
<a name="ln190">buffer_putc (struct buffer *b, u_char c)</a>
<a name="ln191">{</a>
<a name="ln192">  buffer_put(b, &amp;c, 1);</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">/* Put string to the buffer. */</a>
<a name="ln196">void</a>
<a name="ln197">buffer_putstr (struct buffer *b, const char *c)</a>
<a name="ln198">{</a>
<a name="ln199">  buffer_put(b, c, strlen(c));</a>
<a name="ln200">}</a>
<a name="ln201"> </a>
<a name="ln202">/* Keep flushing data to the fd until the buffer is empty or an error is</a>
<a name="ln203">   encountered or the operation would block. */</a>
<a name="ln204">buffer_status_t</a>
<a name="ln205">buffer_flush_all (struct buffer *b, int fd)</a>
<a name="ln206">{</a>
<a name="ln207">  buffer_status_t ret;</a>
<a name="ln208">  struct buffer_data *head;</a>
<a name="ln209">  size_t head_sp;</a>
<a name="ln210"> </a>
<a name="ln211">  if (!b-&gt;head)</a>
<a name="ln212">    return BUFFER_EMPTY;</a>
<a name="ln213">  head_sp = (head = b-&gt;head)-&gt;sp;</a>
<a name="ln214">  /* Flush all data. */</a>
<a name="ln215">  while ((ret = buffer_flush_available(b, fd)) == BUFFER_PENDING)</a>
<a name="ln216">    {</a>
<a name="ln217">      if ((b-&gt;head == head) &amp;&amp; (head_sp == head-&gt;sp) &amp;&amp; (errno != EINTR))</a>
<a name="ln218">        /* No data was flushed, so kernel buffer must be full. */</a>
<a name="ln219">	return ret;</a>
<a name="ln220">      head_sp = (head = b-&gt;head)-&gt;sp;</a>
<a name="ln221">    }</a>
<a name="ln222"> </a>
<a name="ln223">  return ret;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/* Flush enough data to fill a terminal window of the given scene (used only</a>
<a name="ln227">   by vty telnet interface). */</a>
<a name="ln228">buffer_status_t</a>
<a name="ln229">buffer_flush_window (struct buffer *b, int fd, int width, int height, </a>
<a name="ln230">		     int erase_flag, int no_more_flag)</a>
<a name="ln231">{</a>
<a name="ln232">  int nbytes;</a>
<a name="ln233">  int iov_alloc;</a>
<a name="ln234">  int iov_index;</a>
<a name="ln235">  struct iovec *iov;</a>
<a name="ln236">  struct iovec small_iov[3];</a>
<a name="ln237">  char more[] = &quot; --More-- &quot;;</a>
<a name="ln238">  char erase[] = { 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08,</a>
<a name="ln239">		   ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ',</a>
<a name="ln240">		   0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08};</a>
<a name="ln241">  struct buffer_data *data;</a>
<a name="ln242">  int column;</a>
<a name="ln243"> </a>
<a name="ln244">  if (!b-&gt;head)</a>
<a name="ln245">    return BUFFER_EMPTY;</a>
<a name="ln246"> </a>
<a name="ln247">  if (height &lt; 1)</a>
<a name="ln248">    {</a>
<a name="ln249">      zlog_warn(&quot;%s called with non-positive window height %d, forcing to 1&quot;,</a>
<a name="ln250">      		__func__, height);</a>
<a name="ln251">      height = 1;</a>
<a name="ln252">    }</a>
<a name="ln253">  else if (height &gt;= 2)</a>
<a name="ln254">    height--;</a>
<a name="ln255">  if (width &lt; 1)</a>
<a name="ln256">    {</a>
<a name="ln257">      zlog_warn(&quot;%s called with non-positive window width %d, forcing to 1&quot;,</a>
<a name="ln258">      		__func__, width);</a>
<a name="ln259">      width = 1;</a>
<a name="ln260">    }</a>
<a name="ln261"> </a>
<a name="ln262">  /* For erase and more data add two to b's buffer_data count.*/</a>
<a name="ln263">  if (b-&gt;head-&gt;next == NULL)</a>
<a name="ln264">    {</a>
<a name="ln265">      iov_alloc = array_size(small_iov);</a>
<a name="ln266">      iov = small_iov;</a>
<a name="ln267">    }</a>
<a name="ln268">  else</a>
<a name="ln269">    {</a>
<a name="ln270">      iov_alloc = ((height*(width+2))/b-&gt;size)+10;</a>
<a name="ln271">      iov = XMALLOC(MTYPE_TMP, iov_alloc*sizeof(*iov));</a>
<a name="ln272">    }</a>
<a name="ln273">  iov_index = 0;</a>
<a name="ln274"> </a>
<a name="ln275">  /* Previously print out is performed. */</a>
<a name="ln276">  if (erase_flag)</a>
<a name="ln277">    {</a>
<a name="ln278">      iov[iov_index].iov_base = erase;</a>
<a name="ln279">      iov[iov_index].iov_len = sizeof erase;</a>
<a name="ln280">      iov_index++;</a>
<a name="ln281">    }</a>
<a name="ln282"> </a>
<a name="ln283">  /* Output data. */</a>
<a name="ln284">  column = 1;  /* Column position of next character displayed. */</a>
<a name="ln285">  for (data = b-&gt;head; data &amp;&amp; (height &gt; 0); data = data-&gt;next)</a>
<a name="ln286">    {</a>
<a name="ln287">      size_t cp;</a>
<a name="ln288"> </a>
<a name="ln289">      cp = data-&gt;sp;</a>
<a name="ln290">      while ((cp &lt; data-&gt;cp) &amp;&amp; (height &gt; 0))</a>
<a name="ln291">        {</a>
<a name="ln292">	  /* Calculate lines remaining and column position after displaying</a>
<a name="ln293">	     this character. */</a>
<a name="ln294">	  if (data-&gt;data[cp] == '\r')</a>
<a name="ln295">	    column = 1;</a>
<a name="ln296">	  else if ((data-&gt;data[cp] == '\n') || (column == width))</a>
<a name="ln297">	    {</a>
<a name="ln298">	      column = 1;</a>
<a name="ln299">	      height--;</a>
<a name="ln300">	    }</a>
<a name="ln301">	  else</a>
<a name="ln302">	    column++;</a>
<a name="ln303">	  cp++;</a>
<a name="ln304">        }</a>
<a name="ln305">      iov[iov_index].iov_base = (char *)(data-&gt;data + data-&gt;sp);</a>
<a name="ln306">      iov[iov_index++].iov_len = cp-data-&gt;sp;</a>
<a name="ln307">      data-&gt;sp = cp;</a>
<a name="ln308"> </a>
<a name="ln309">      if (iov_index == iov_alloc)</a>
<a name="ln310">	/* This should not ordinarily happen. */</a>
<a name="ln311">        {</a>
<a name="ln312">	  iov_alloc *= 2;</a>
<a name="ln313">	  if (iov != small_iov)</a>
<a name="ln314">	    {</a>
<a name="ln315">	      zlog_warn(&quot;%s: growing iov array to %d; &quot;</a>
<a name="ln316">			&quot;width %d, height %d, size %lu&quot;,</a>
<a name="ln317">			__func__, iov_alloc, width, height, (u_long)b-&gt;size);</a>
<a name="ln318">	      iov = XREALLOC(MTYPE_TMP, iov, iov_alloc*sizeof(*iov));</a>
<a name="ln319">	    }</a>
<a name="ln320">	  else</a>
<a name="ln321">	    {</a>
<a name="ln322">	      /* This should absolutely never occur. */</a>
<a name="ln323">	      zlog_err(&quot;%s: corruption detected: iov_small overflowed; &quot;</a>
<a name="ln324">		       &quot;head %p, tail %p, head-&gt;next %p&quot;,</a>
<a name="ln325">		       __func__, (void *)b-&gt;head, (void *)b-&gt;tail,</a>
<a name="ln326">		       (void *)b-&gt;head-&gt;next);</a>
<a name="ln327">	      iov = XMALLOC(MTYPE_TMP, iov_alloc*sizeof(*iov));</a>
<a name="ln328">	      memcpy(iov, small_iov, sizeof(small_iov));</a>
<a name="ln329">	    }</a>
<a name="ln330">	}</a>
<a name="ln331">    }</a>
<a name="ln332"> </a>
<a name="ln333">  /* In case of `more' display need. */</a>
<a name="ln334">  if (b-&gt;tail &amp;&amp; (b-&gt;tail-&gt;sp &lt; b-&gt;tail-&gt;cp) &amp;&amp; !no_more_flag)</a>
<a name="ln335">    {</a>
<a name="ln336">      iov[iov_index].iov_base = more;</a>
<a name="ln337">      iov[iov_index].iov_len = sizeof more;</a>
<a name="ln338">      iov_index++;</a>
<a name="ln339">    }</a>
<a name="ln340"> </a>
<a name="ln341"> </a>
<a name="ln342">#ifdef IOV_MAX</a>
<a name="ln343">  /* IOV_MAX are normally defined in &lt;sys/uio.h&gt; , Posix.1g.</a>
<a name="ln344">     example: Solaris2.6 are defined IOV_MAX size at 16.     */</a>
<a name="ln345">  {</a>
<a name="ln346">    struct iovec *c_iov = iov;</a>
<a name="ln347">    nbytes = 0; /* Make sure it's initialized. */</a>
<a name="ln348"> </a>
<a name="ln349">    while (iov_index &gt; 0)</a>
<a name="ln350">      {</a>
<a name="ln351">	 int iov_size;</a>
<a name="ln352"> </a>
<a name="ln353">	 iov_size = ((iov_index &gt; IOV_MAX) ? IOV_MAX : iov_index);</a>
<a name="ln354">	 if ((nbytes = writev(fd, c_iov, iov_size)) &lt; 0)</a>
<a name="ln355">	   {</a>
<a name="ln356">	     zlog_warn(&quot;%s: writev to fd %d failed: %s&quot;,</a>
<a name="ln357">		       __func__, fd, safe_strerror(errno));</a>
<a name="ln358">	     break;</a>
<a name="ln359">	   }</a>
<a name="ln360"> </a>
<a name="ln361">	 /* move pointer io-vector */</a>
<a name="ln362">	 c_iov += iov_size;</a>
<a name="ln363">	 iov_index -= iov_size;</a>
<a name="ln364">      }</a>
<a name="ln365">  }</a>
<a name="ln366">#else  /* IOV_MAX */</a>
<a name="ln367">   if ((nbytes = writev (fd, iov, iov_index)) &lt; 0)</a>
<a name="ln368">     zlog_warn(&quot;%s: writev to fd %d failed: %s&quot;,</a>
<a name="ln369">	       __func__, fd, safe_strerror(errno));</a>
<a name="ln370">#endif /* IOV_MAX */</a>
<a name="ln371"> </a>
<a name="ln372">  /* Free printed buffer data. */</a>
<a name="ln373">  while (b-&gt;head &amp;&amp; (b-&gt;head-&gt;sp == b-&gt;head-&gt;cp))</a>
<a name="ln374">    {</a>
<a name="ln375">      struct buffer_data *del;</a>
<a name="ln376">      if (!(b-&gt;head = (del = b-&gt;head)-&gt;next))</a>
<a name="ln377">        b-&gt;tail = NULL;</a>
<a name="ln378">      BUFFER_DATA_FREE(del);</a>
<a name="ln379">    }</a>
<a name="ln380"> </a>
<a name="ln381">  if (iov != small_iov)</a>
<a name="ln382">    XFREE (MTYPE_TMP, iov);</a>
<a name="ln383"> </a>
<a name="ln384">  return (nbytes &lt; 0) ? BUFFER_ERROR :</a>
<a name="ln385">  			(b-&gt;head ? BUFFER_PENDING : BUFFER_EMPTY);</a>
<a name="ln386">}</a>
<a name="ln387"> </a>
<a name="ln388">/* This function (unlike other buffer_flush* functions above) is designed</a>
<a name="ln389">to work with non-blocking sockets.  It does not attempt to write out</a>
<a name="ln390">all of the queued data, just a &quot;big&quot; chunk.  It returns 0 if it was</a>
<a name="ln391">able to empty out the buffers completely, 1 if more flushing is</a>
<a name="ln392">required later, or -1 on a fatal write error. */</a>
<a name="ln393">buffer_status_t</a>
<a name="ln394">buffer_flush_available(struct buffer *b, int fd)</a>
<a name="ln395">{</a>
<a name="ln396"> </a>
<a name="ln397">/* These are just reasonable values to make sure a significant amount of</a>
<a name="ln398">data is written.  There's no need to go crazy and try to write it all</a>
<a name="ln399">in one shot. */</a>
<a name="ln400">#ifdef IOV_MAX</a>
<a name="ln401">#define MAX_CHUNKS ((IOV_MAX &gt;= 16) ? 16 : IOV_MAX)</a>
<a name="ln402">#else</a>
<a name="ln403">#define MAX_CHUNKS 16</a>
<a name="ln404">#endif</a>
<a name="ln405">#define MAX_FLUSH 131072</a>
<a name="ln406"> </a>
<a name="ln407">  struct buffer_data *d;</a>
<a name="ln408">  size_t written;</a>
<a name="ln409">  struct iovec iov[MAX_CHUNKS];</a>
<a name="ln410">  size_t iovcnt = 0;</a>
<a name="ln411">  size_t nbyte = 0;</a>
<a name="ln412"> </a>
<a name="ln413">  for (d = b-&gt;head; d &amp;&amp; (iovcnt &lt; MAX_CHUNKS) &amp;&amp; (nbyte &lt; MAX_FLUSH);</a>
<a name="ln414">       d = d-&gt;next, iovcnt++)</a>
<a name="ln415">    {</a>
<a name="ln416">      iov[iovcnt].iov_base = d-&gt;data+d-&gt;sp;</a>
<a name="ln417">      nbyte += (iov[iovcnt].iov_len = d-&gt;cp-d-&gt;sp);</a>
<a name="ln418">    }</a>
<a name="ln419"> </a>
<a name="ln420">  if (!nbyte)</a>
<a name="ln421">    /* No data to flush: should we issue a warning message? */</a>
<a name="ln422">    return BUFFER_EMPTY;</a>
<a name="ln423"> </a>
<a name="ln424">  /* only place where written should be sign compared */</a>
<a name="ln425">  if ((ssize_t)(written = writev(fd,iov,iovcnt)) &lt; 0)</a>
<a name="ln426">    {</a>
<a name="ln427">      if (ERRNO_IO_RETRY(errno))</a>
<a name="ln428">	/* Calling code should try again later. */</a>
<a name="ln429">        return BUFFER_PENDING;</a>
<a name="ln430">      zlog_warn(&quot;%s: write error on fd %d: %s&quot;,</a>
<a name="ln431">		__func__, fd, safe_strerror(errno));</a>
<a name="ln432">      return BUFFER_ERROR;</a>
<a name="ln433">    }</a>
<a name="ln434"> </a>
<a name="ln435">  /* Free printed buffer data. */</a>
<a name="ln436">  while (written &gt; 0)</a>
<a name="ln437">    {</a>
<a name="ln438">      struct buffer_data *d;</a>
<a name="ln439">      if (!(d = b-&gt;head))</a>
<a name="ln440">        {</a>
<a name="ln441">          zlog_err(&quot;%s: corruption detected: buffer queue empty, &quot;</a>
<a name="ln442">		   &quot;but written is %lu&quot;, __func__, (u_long)written);</a>
<a name="ln443">	  break;</a>
<a name="ln444">        }</a>
<a name="ln445">      if (written &lt; d-&gt;cp-d-&gt;sp)</a>
<a name="ln446">        {</a>
<a name="ln447">	  d-&gt;sp += written;</a>
<a name="ln448">	  return BUFFER_PENDING;</a>
<a name="ln449">	}</a>
<a name="ln450"> </a>
<a name="ln451">      written -= (d-&gt;cp-d-&gt;sp);</a>
<a name="ln452">      if (!(b-&gt;head = d-&gt;next))</a>
<a name="ln453">        b-&gt;tail = NULL;</a>
<a name="ln454">      BUFFER_DATA_FREE(d);</a>
<a name="ln455">    }</a>
<a name="ln456"> </a>
<a name="ln457">  return b-&gt;head ? BUFFER_PENDING : BUFFER_EMPTY;</a>
<a name="ln458"> </a>
<a name="ln459">#undef MAX_CHUNKS</a>
<a name="ln460">#undef MAX_FLUSH</a>
<a name="ln461">}</a>
<a name="ln462"> </a>
<a name="ln463">buffer_status_t</a>
<a name="ln464">buffer_write(struct buffer *b, int fd, const void *p, size_t size)</a>
<a name="ln465">{</a>
<a name="ln466">  ssize_t nbytes;</a>
<a name="ln467"> </a>
<a name="ln468">#if 0</a>
<a name="ln469">  /* Should we attempt to drain any previously buffered data?  This could help</a>
<a name="ln470">     reduce latency in pushing out the data if we are stuck in a long-running</a>
<a name="ln471">     thread that is preventing the main select loop from calling the flush</a>
<a name="ln472">     thread... */</a>
<a name="ln473">  if (b-&gt;head &amp;&amp; (buffer_flush_available(b, fd) == BUFFER_ERROR))</a>
<a name="ln474">    return BUFFER_ERROR;</a>
<a name="ln475">#endif</a>
<a name="ln476">  if (b-&gt;head)</a>
<a name="ln477">    /* Buffer is not empty, so do not attempt to write the new data. */</a>
<a name="ln478">    nbytes = 0;</a>
<a name="ln479">  else if ((nbytes = write(fd, p, size)) &lt; 0)</a>
<a name="ln480">    {</a>
<a name="ln481">      if (ERRNO_IO_RETRY(errno))</a>
<a name="ln482">        nbytes = 0;</a>
<a name="ln483">      else</a>
<a name="ln484">        {</a>
<a name="ln485">	  zlog_warn(&quot;%s: write error on fd %d: %s&quot;,</a>
<a name="ln486">		    __func__, fd, safe_strerror(errno));</a>
<a name="ln487">	  return BUFFER_ERROR;</a>
<a name="ln488">	}</a>
<a name="ln489">    }</a>
<a name="ln490">  /* Add any remaining data to the buffer. */</a>
<a name="ln491">  {</a>
<a name="ln492">    size_t written = nbytes;</a>
<a name="ln493">    if (written &lt; size)</a>
<a name="ln494">      buffer_put(b, ((const char *)p)+written, size-written);</a>
<a name="ln495">  }</a>
<a name="ln496">  return b-&gt;head ? BUFFER_PENDING : BUFFER_EMPTY;</a>
<a name="ln497">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
