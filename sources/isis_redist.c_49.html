
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_redist.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol - isis_redist.c</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2013-2015 Christian Franke &lt;chris@opensourcerouting.org&gt;</a>
<a name="ln5"> *</a>
<a name="ln6"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the Free </a>
<a name="ln8"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln9"> * any later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln12"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln13"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln14"> * more details.</a>
<a name="ln15"> </a>
<a name="ln16"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln17"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln18"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln19"> */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;command.h&quot;</a>
<a name="ln24">#include &quot;if.h&quot;</a>
<a name="ln25">#include &quot;linklist.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;memtypes.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;routemap.h&quot;</a>
<a name="ln30">#include &quot;stream.h&quot;</a>
<a name="ln31">#include &quot;table.h&quot;</a>
<a name="ln32">#include &quot;vty.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;isisd/dict.h&quot;</a>
<a name="ln35">#include &quot;isisd/isis_constants.h&quot;</a>
<a name="ln36">#include &quot;isisd/isis_common.h&quot;</a>
<a name="ln37">#include &quot;isisd/isis_flags.h&quot;</a>
<a name="ln38">#include &quot;isisd/isis_misc.h&quot;</a>
<a name="ln39">#include &quot;isisd/isis_circuit.h&quot;</a>
<a name="ln40">#include &quot;isisd/isis_tlv.h&quot;</a>
<a name="ln41">#include &quot;isisd/isisd.h&quot;</a>
<a name="ln42">#include &quot;isisd/isis_lsp.h&quot;</a>
<a name="ln43">#include &quot;isisd/isis_route.h&quot;</a>
<a name="ln44">#include &quot;isisd/isis_zebra.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">static int</a>
<a name="ln47">redist_protocol(int family)</a>
<a name="ln48">{</a>
<a name="ln49">  if (family == AF_INET)</a>
<a name="ln50">    return 0;</a>
<a name="ln51">  if (family == AF_INET6)</a>
<a name="ln52">    return 1;</a>
<a name="ln53"> </a>
<a name="ln54">  assert(!&quot;Unsupported address family!&quot;);</a>
<a name="ln55">  return 0;</a>
<a name="ln56">}</a>
<a name="ln57"> </a>
<a name="ln58">static int</a>
<a name="ln59">is_default(struct prefix *p)</a>
<a name="ln60">{</a>
<a name="ln61">  if (p-&gt;family == AF_INET)</a>
<a name="ln62">    if (p-&gt;u.prefix4.s_addr == 0 &amp;&amp; p-&gt;prefixlen == 0)</a>
<a name="ln63">      return 1;</a>
<a name="ln64">  if (p-&gt;family == AF_INET6)</a>
<a name="ln65">    if (IN6_IS_ADDR_UNSPECIFIED(&amp;p-&gt;u.prefix6) &amp;&amp; p-&gt;prefixlen == 0)</a>
<a name="ln66">      return 1;</a>
<a name="ln67">  return 0;</a>
<a name="ln68">}</a>
<a name="ln69"> </a>
<a name="ln70">static struct route_table*</a>
<a name="ln71">get_ext_info(struct isis *i, int family)</a>
<a name="ln72">{</a>
<a name="ln73">  int protocol = redist_protocol(family);</a>
<a name="ln74"> </a>
<a name="ln75">  return i-&gt;ext_info[protocol];</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">static struct isis_redist*</a>
<a name="ln79">get_redist_settings(struct isis_area *area, int family, int type, int level)</a>
<a name="ln80">{</a>
<a name="ln81">  int protocol = redist_protocol(family);</a>
<a name="ln82"> </a>
<a name="ln83">  return &amp;area-&gt;redist_settings[protocol][type][level-1];</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">struct route_table*</a>
<a name="ln87">get_ext_reach(struct isis_area *area, int family, int level)</a>
<a name="ln88">{</a>
<a name="ln89">  int protocol = redist_protocol(family);</a>
<a name="ln90"> </a>
<a name="ln91">  return area-&gt;ext_reach[protocol][level-1];</a>
<a name="ln92">}</a>
<a name="ln93"> </a>
<a name="ln94">static struct route_node *</a>
<a name="ln95">isis_redist_route_node_create(route_table_delegate_t *delegate,</a>
<a name="ln96">                              struct route_table *table)</a>
<a name="ln97">{</a>
<a name="ln98">  struct route_node *node;</a>
<a name="ln99">  node = XCALLOC(MTYPE_ROUTE_NODE, sizeof(*node));</a>
<a name="ln100">  return node;</a>
<a name="ln101">}</a>
<a name="ln102"> </a>
<a name="ln103">static void</a>
<a name="ln104">isis_redist_route_node_destroy(route_table_delegate_t *delegate,</a>
<a name="ln105">                               struct route_table *table,</a>
<a name="ln106">                               struct route_node *node)</a>
<a name="ln107">{</a>
<a name="ln108">  if (node-&gt;info)</a>
<a name="ln109">    XFREE(MTYPE_ISIS, node-&gt;info);</a>
<a name="ln110">  XFREE (MTYPE_ROUTE_NODE, node);</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">static route_table_delegate_t isis_redist_rt_delegate = {</a>
<a name="ln114">  .create_node = isis_redist_route_node_create,</a>
<a name="ln115">  .destroy_node = isis_redist_route_node_destroy</a>
<a name="ln116">};</a>
<a name="ln117"> </a>
<a name="ln118">/* Install external reachability information into a</a>
<a name="ln119"> * specific area for a specific level.</a>
<a name="ln120"> * Schedule an lsp regenerate if necessary */</a>
<a name="ln121">static void</a>
<a name="ln122">isis_redist_install(struct isis_area *area, int level,</a>
<a name="ln123">                    struct prefix *p, struct isis_ext_info *info)</a>
<a name="ln124">{</a>
<a name="ln125">  int family = p-&gt;family;</a>
<a name="ln126">  struct route_table *er_table = get_ext_reach(area, family, level);</a>
<a name="ln127">  struct route_node *er_node;</a>
<a name="ln128"> </a>
<a name="ln129">  if (!er_table)</a>
<a name="ln130">    {</a>
<a name="ln131">      zlog_warn(&quot;%s: External reachability table of area %s&quot;</a>
<a name="ln132">                &quot; is not initialized.&quot;, __func__, area-&gt;area_tag);</a>
<a name="ln133">      return;</a>
<a name="ln134">    }</a>
<a name="ln135"> </a>
<a name="ln136">  er_node = route_node_get(er_table, p);</a>
<a name="ln137">  if (er_node-&gt;info)</a>
<a name="ln138">    {</a>
<a name="ln139">      route_unlock_node(er_node);</a>
<a name="ln140"> </a>
<a name="ln141">      /* Don't update/reschedule lsp generation if nothing changed. */</a>
<a name="ln142">      if (!memcmp(er_node-&gt;info, info, sizeof(*info)))</a>
<a name="ln143">        return;</a>
<a name="ln144">    }</a>
<a name="ln145">  else</a>
<a name="ln146">    {</a>
<a name="ln147">      er_node-&gt;info = XMALLOC(MTYPE_ISIS, sizeof(*info));</a>
<a name="ln148">    }</a>
<a name="ln149"> </a>
<a name="ln150">  memcpy(er_node-&gt;info, info, sizeof(*info));</a>
<a name="ln151">  lsp_regenerate_schedule(area, level, 0);</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">/* Remove external reachability information from a</a>
<a name="ln155"> * specific area for a specific level.</a>
<a name="ln156"> * Schedule an lsp regenerate if necessary. */</a>
<a name="ln157">static void</a>
<a name="ln158">isis_redist_uninstall(struct isis_area *area, int level, struct prefix *p)</a>
<a name="ln159">{</a>
<a name="ln160">  int family = p-&gt;family;</a>
<a name="ln161">  struct route_table *er_table = get_ext_reach(area, family, level);</a>
<a name="ln162">  struct route_node *er_node;</a>
<a name="ln163"> </a>
<a name="ln164">  if (!er_table)</a>
<a name="ln165">    {</a>
<a name="ln166">      zlog_warn(&quot;%s: External reachability table of area %s&quot;</a>
<a name="ln167">                &quot; is not initialized.&quot;, __func__, area-&gt;area_tag);</a>
<a name="ln168">      return;</a>
<a name="ln169">    }</a>
<a name="ln170"> </a>
<a name="ln171">  er_node = route_node_lookup(er_table, p);</a>
<a name="ln172">  if (!er_node)</a>
<a name="ln173">    return;</a>
<a name="ln174">  else</a>
<a name="ln175">    route_unlock_node(er_node);</a>
<a name="ln176"> </a>
<a name="ln177">  if (!er_node-&gt;info)</a>
<a name="ln178">    return;</a>
<a name="ln179"> </a>
<a name="ln180">  XFREE(MTYPE_ISIS, er_node-&gt;info);</a>
<a name="ln181">  route_unlock_node(er_node);</a>
<a name="ln182">  lsp_regenerate_schedule(area, level, 0);</a>
<a name="ln183">}</a>
<a name="ln184"> </a>
<a name="ln185">/* Update external reachability info of area for a given level</a>
<a name="ln186"> * and prefix, using the given redistribution settings. */</a>
<a name="ln187">static void</a>
<a name="ln188">isis_redist_update_ext_reach(struct isis_area *area, int level,</a>
<a name="ln189">                             struct isis_redist *redist, struct prefix *p,</a>
<a name="ln190">                             struct isis_ext_info *info)</a>
<a name="ln191">{</a>
<a name="ln192">  struct isis_ext_info area_info;</a>
<a name="ln193">  route_map_result_t map_ret;</a>
<a name="ln194"> </a>
<a name="ln195">  memcpy(&amp;area_info, info, sizeof(area_info));</a>
<a name="ln196">  if (redist-&gt;metric != 0xffffffff)</a>
<a name="ln197">    area_info.metric = redist-&gt;metric;</a>
<a name="ln198"> </a>
<a name="ln199">  if (redist-&gt;map_name)</a>
<a name="ln200">    {</a>
<a name="ln201">      map_ret = route_map_apply(redist-&gt;map, p, RMAP_ISIS, &amp;area_info);</a>
<a name="ln202">      if (map_ret == RMAP_DENYMATCH)</a>
<a name="ln203">        area_info.distance = 255;</a>
<a name="ln204">    }</a>
<a name="ln205"> </a>
<a name="ln206">  /* Allow synthesized default routes only on always orignate */</a>
<a name="ln207">  if (area_info.origin == DEFAULT_ROUTE</a>
<a name="ln208">      &amp;&amp; redist-&gt;redist != DEFAULT_ORIGINATE_ALWAYS)</a>
<a name="ln209">    area_info.distance = 255;</a>
<a name="ln210"> </a>
<a name="ln211">  if (area_info.distance &lt; 255)</a>
<a name="ln212">    isis_redist_install(area, level, p, &amp;area_info);</a>
<a name="ln213">  else</a>
<a name="ln214">    isis_redist_uninstall(area, level, p);</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">static void</a>
<a name="ln218">isis_redist_ensure_default(struct isis *isis, int family)</a>
<a name="ln219">{</a>
<a name="ln220">  struct prefix p;</a>
<a name="ln221">  struct route_table *ei_table = get_ext_info(isis, family);</a>
<a name="ln222">  struct route_node *ei_node;</a>
<a name="ln223">  struct isis_ext_info *info;</a>
<a name="ln224"> </a>
<a name="ln225">  if (family == AF_INET)</a>
<a name="ln226">    {</a>
<a name="ln227">      p.family = AF_INET;</a>
<a name="ln228">      p.prefixlen = 0;</a>
<a name="ln229">      memset(&amp;p.u.prefix4, 0, sizeof(p.u.prefix4));</a>
<a name="ln230">    }</a>
<a name="ln231">  else if (family == AF_INET6)</a>
<a name="ln232">    {</a>
<a name="ln233">      p.family = AF_INET6;</a>
<a name="ln234">      p.prefixlen = 0;</a>
<a name="ln235">      memset(&amp;p.u.prefix6, 0, sizeof(p.u.prefix6));</a>
<a name="ln236">    }</a>
<a name="ln237">  else</a>
<a name="ln238">    assert(!&quot;Unknown family!&quot;);</a>
<a name="ln239"> </a>
<a name="ln240">  ei_node = route_node_get(ei_table, &amp;p);</a>
<a name="ln241">  if (ei_node-&gt;info)</a>
<a name="ln242">    {</a>
<a name="ln243">      route_unlock_node(ei_node);</a>
<a name="ln244">      return;</a>
<a name="ln245">    }</a>
<a name="ln246"> </a>
<a name="ln247">  ei_node-&gt;info = XCALLOC(MTYPE_ISIS, sizeof(struct isis_ext_info));</a>
<a name="ln248"> </a>
<a name="ln249">  info = ei_node-&gt;info;</a>
<a name="ln250">  info-&gt;origin = DEFAULT_ROUTE;</a>
<a name="ln251">  info-&gt;distance = 254;</a>
<a name="ln252">  info-&gt;metric = MAX_WIDE_PATH_METRIC;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">/* Handle notification about route being added */</a>
<a name="ln256">void</a>
<a name="ln257">isis_redist_add(int type, struct prefix *p, u_char distance, uint32_t metric)</a>
<a name="ln258">{</a>
<a name="ln259">  int family = p-&gt;family;</a>
<a name="ln260">  struct route_table *ei_table = get_ext_info(isis, family);</a>
<a name="ln261">  struct route_node *ei_node;</a>
<a name="ln262">  struct isis_ext_info *info;</a>
<a name="ln263">  struct listnode *node;</a>
<a name="ln264">  struct isis_area *area;</a>
<a name="ln265">  int level;</a>
<a name="ln266">  struct isis_redist *redist;</a>
<a name="ln267"> </a>
<a name="ln268">  char debug_buf[BUFSIZ];</a>
<a name="ln269">  prefix2str(p, debug_buf, sizeof(debug_buf));</a>
<a name="ln270"> </a>
<a name="ln271">  zlog_debug(&quot;%s: New route %s from %s.&quot;, __func__, debug_buf,</a>
<a name="ln272">             zebra_route_string(type));</a>
<a name="ln273"> </a>
<a name="ln274">  if (!ei_table)</a>
<a name="ln275">    {</a>
<a name="ln276">      zlog_warn(&quot;%s: External information table not initialized.&quot;,</a>
<a name="ln277">                __func__);</a>
<a name="ln278">      return;</a>
<a name="ln279">    }</a>
<a name="ln280"> </a>
<a name="ln281">  ei_node = route_node_get(ei_table, p);</a>
<a name="ln282">  if (ei_node-&gt;info)</a>
<a name="ln283">    route_unlock_node(ei_node);</a>
<a name="ln284">  else</a>
<a name="ln285">    ei_node-&gt;info = XCALLOC(MTYPE_ISIS, sizeof(struct isis_ext_info));</a>
<a name="ln286"> </a>
<a name="ln287">  info = ei_node-&gt;info;</a>
<a name="ln288">  info-&gt;origin = type;</a>
<a name="ln289">  info-&gt;distance = distance;</a>
<a name="ln290">  info-&gt;metric = metric;</a>
<a name="ln291"> </a>
<a name="ln292">  if (is_default(p))</a>
<a name="ln293">    type = DEFAULT_ROUTE;</a>
<a name="ln294"> </a>
<a name="ln295">  for (ALL_LIST_ELEMENTS_RO(isis-&gt;area_list, node, area))</a>
<a name="ln296">    for (level = 1; level &lt;= ISIS_LEVELS; level++)</a>
<a name="ln297">      {</a>
<a name="ln298">        redist = get_redist_settings(area, family, type, level);</a>
<a name="ln299">        if (!redist-&gt;redist)</a>
<a name="ln300">          continue;</a>
<a name="ln301"> </a>
<a name="ln302">        isis_redist_update_ext_reach(area, level, redist, p, info);</a>
<a name="ln303">      }</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">void</a>
<a name="ln307">isis_redist_delete(int type, struct prefix *p)</a>
<a name="ln308">{</a>
<a name="ln309">  int family = p-&gt;family;</a>
<a name="ln310">  struct route_table *ei_table = get_ext_info(isis, family);</a>
<a name="ln311">  struct route_node *ei_node;</a>
<a name="ln312">  struct listnode *node;</a>
<a name="ln313">  struct isis_area *area;</a>
<a name="ln314">  int level;</a>
<a name="ln315">  struct isis_redist *redist;</a>
<a name="ln316"> </a>
<a name="ln317">  char debug_buf[BUFSIZ];</a>
<a name="ln318">  prefix2str(p, debug_buf, sizeof(debug_buf));</a>
<a name="ln319"> </a>
<a name="ln320">  zlog_debug(&quot;%s: Removing route %s from %s.&quot;, __func__, debug_buf,</a>
<a name="ln321">             zebra_route_string(type));</a>
<a name="ln322"> </a>
<a name="ln323">  if (is_default(p))</a>
<a name="ln324">    {</a>
<a name="ln325">      /* Don't remove default route but add synthetic route for use</a>
<a name="ln326">       * by &quot;default-information originate always&quot;. Areas without the</a>
<a name="ln327">       * &quot;always&quot; setting will ignore routes with origin DEFAULT_ROUTE. */</a>
<a name="ln328">      isis_redist_add(DEFAULT_ROUTE, p, 254, MAX_WIDE_PATH_METRIC);</a>
<a name="ln329">      return;</a>
<a name="ln330">    }</a>
<a name="ln331"> </a>
<a name="ln332">  if (!ei_table)</a>
<a name="ln333">    {</a>
<a name="ln334">      zlog_warn(&quot;%s: External information table not initialized.&quot;,</a>
<a name="ln335">                __func__);</a>
<a name="ln336">      return;</a>
<a name="ln337">    }</a>
<a name="ln338"> </a>
<a name="ln339">  ei_node = route_node_lookup(ei_table, p);</a>
<a name="ln340">  if (!ei_node || !ei_node-&gt;info)</a>
<a name="ln341">    {</a>
<a name="ln342">      char buf[BUFSIZ];</a>
<a name="ln343">      prefix2str(p, buf, sizeof(buf));</a>
<a name="ln344">      zlog_warn(&quot;%s: Got a delete for %s route %s, but that route&quot;</a>
<a name="ln345">                &quot; was never added.&quot;, __func__, zebra_route_string(type),</a>
<a name="ln346">                buf);</a>
<a name="ln347">      if (ei_node)</a>
<a name="ln348">        route_unlock_node(ei_node);</a>
<a name="ln349">      return;</a>
<a name="ln350">    }</a>
<a name="ln351">  route_unlock_node(ei_node);</a>
<a name="ln352"> </a>
<a name="ln353">  for (ALL_LIST_ELEMENTS_RO(isis-&gt;area_list, node, area))</a>
<a name="ln354">    for (level = 1; level &lt; ISIS_LEVELS; level++)</a>
<a name="ln355">      {</a>
<a name="ln356">        redist = get_redist_settings(area, family, type, level);</a>
<a name="ln357">        if (!redist-&gt;redist)</a>
<a name="ln358">          continue;</a>
<a name="ln359"> </a>
<a name="ln360">        isis_redist_uninstall(area, level, p);</a>
<a name="ln361">      }</a>
<a name="ln362"> </a>
<a name="ln363">  XFREE(MTYPE_ISIS, ei_node-&gt;info);</a>
<a name="ln364">  route_unlock_node(ei_node);</a>
<a name="ln365">}</a>
<a name="ln366"> </a>
<a name="ln367">static void</a>
<a name="ln368">isis_redist_routemap_set(struct isis_redist *redist, const char *routemap)</a>
<a name="ln369">{</a>
<a name="ln370">  if (redist-&gt;map_name) {</a>
<a name="ln371">    XFREE(MTYPE_ISIS, redist-&gt;map_name);</a>
<a name="ln372">    redist-&gt;map = NULL;</a>
<a name="ln373">  }</a>
<a name="ln374"> </a>
<a name="ln375">  if (routemap &amp;&amp; strlen(routemap)) {</a>
<a name="ln376">    redist-&gt;map_name = XSTRDUP(MTYPE_ISIS, routemap);</a>
<a name="ln377">    redist-&gt;map = route_map_lookup_by_name(routemap);</a>
<a name="ln378">  }</a>
<a name="ln379">}</a>
<a name="ln380"> </a>
<a name="ln381">static void</a>
<a name="ln382">isis_redist_update_zebra_subscriptions(struct isis *isis)</a>
<a name="ln383">{</a>
<a name="ln384">  struct listnode *node;</a>
<a name="ln385">  struct isis_area *area;</a>
<a name="ln386">  int type;</a>
<a name="ln387">  int level;</a>
<a name="ln388">  int protocol;</a>
<a name="ln389"> </a>
<a name="ln390">  char do_subscribe[ZEBRA_ROUTE_MAX + 1];</a>
<a name="ln391"> </a>
<a name="ln392">  memset(do_subscribe, 0, sizeof(do_subscribe));</a>
<a name="ln393"> </a>
<a name="ln394">  for (ALL_LIST_ELEMENTS_RO(isis-&gt;area_list, node, area))</a>
<a name="ln395">    for (protocol = 0; protocol &lt; REDIST_PROTOCOL_COUNT; protocol++)</a>
<a name="ln396">      for (type = 0; type &lt; ZEBRA_ROUTE_MAX + 1; type++)</a>
<a name="ln397">        for (level = 0; level &lt; ISIS_LEVELS; level++)</a>
<a name="ln398">          if (area-&gt;redist_settings[protocol][type][level].redist)</a>
<a name="ln399">            do_subscribe[type] = 1;</a>
<a name="ln400"> </a>
<a name="ln401">  for (type = 0; type &lt; ZEBRA_ROUTE_MAX + 1; type++)</a>
<a name="ln402">    {</a>
<a name="ln403">      /* This field is actually controlling transmission of the IS-IS</a>
<a name="ln404">       * routes to Zebra and has nothing to do with redistribution,</a>
<a name="ln405">       * so skip it. */</a>
<a name="ln406">      if (type == ZEBRA_ROUTE_ISIS)</a>
<a name="ln407">        continue;</a>
<a name="ln408"> </a>
<a name="ln409">      if (do_subscribe[type])</a>
<a name="ln410">        isis_zebra_redistribute_set(type);</a>
<a name="ln411">      else</a>
<a name="ln412">        isis_zebra_redistribute_unset(type);</a>
<a name="ln413">    }</a>
<a name="ln414">}</a>
<a name="ln415"> </a>
<a name="ln416">static void</a>
<a name="ln417">isis_redist_set(struct isis_area *area, int level,</a>
<a name="ln418">                int family, int type, uint32_t metric,</a>
<a name="ln419">                const char *routemap, int originate_type)</a>
<a name="ln420">{</a>
<a name="ln421">  int protocol = redist_protocol(family);</a>
<a name="ln422">  struct isis_redist *redist = get_redist_settings(area, family, type, level);</a>
<a name="ln423">  int i;</a>
<a name="ln424">  struct route_table *ei_table;</a>
<a name="ln425">  struct route_node *rn;</a>
<a name="ln426">  struct isis_ext_info *info;</a>
<a name="ln427"> </a>
<a name="ln428">  redist-&gt;redist = (type == DEFAULT_ROUTE) ? originate_type : 1;</a>
<a name="ln429">  redist-&gt;metric = metric;</a>
<a name="ln430">  isis_redist_routemap_set(redist, routemap);</a>
<a name="ln431"> </a>
<a name="ln432">  if (!area-&gt;ext_reach[protocol][level-1])</a>
<a name="ln433">    {</a>
<a name="ln434">      area-&gt;ext_reach[protocol][level-1] =</a>
<a name="ln435">          route_table_init_with_delegate(&amp;isis_redist_rt_delegate);</a>
<a name="ln436">    }</a>
<a name="ln437"> </a>
<a name="ln438">  for (i = 0; i &lt; REDIST_PROTOCOL_COUNT; i++)</a>
<a name="ln439">    if (!area-&gt;isis-&gt;ext_info[i])</a>
<a name="ln440">      {</a>
<a name="ln441">        area-&gt;isis-&gt;ext_info[i] =</a>
<a name="ln442">            route_table_init_with_delegate(&amp;isis_redist_rt_delegate);</a>
<a name="ln443">      }</a>
<a name="ln444"> </a>
<a name="ln445">  isis_redist_update_zebra_subscriptions(area-&gt;isis);</a>
<a name="ln446"> </a>
<a name="ln447">  if (type == DEFAULT_ROUTE &amp;&amp; originate_type == DEFAULT_ORIGINATE_ALWAYS)</a>
<a name="ln448">    isis_redist_ensure_default(area-&gt;isis, family);</a>
<a name="ln449"> </a>
<a name="ln450">  ei_table = get_ext_info(area-&gt;isis, family);</a>
<a name="ln451">  for (rn = route_top(ei_table); rn; rn = route_next(rn))</a>
<a name="ln452">    {</a>
<a name="ln453">      if (!rn-&gt;info)</a>
<a name="ln454">        continue;</a>
<a name="ln455">      info = rn-&gt;info;</a>
<a name="ln456"> </a>
<a name="ln457">      if (type == DEFAULT_ROUTE)</a>
<a name="ln458">        {</a>
<a name="ln459">          if (!is_default(&amp;rn-&gt;p))</a>
<a name="ln460">            continue;</a>
<a name="ln461">        }</a>
<a name="ln462">      else</a>
<a name="ln463">        {</a>
<a name="ln464">          if (info-&gt;origin != type)</a>
<a name="ln465">            continue;</a>
<a name="ln466">        }</a>
<a name="ln467"> </a>
<a name="ln468">      isis_redist_update_ext_reach(area, level, redist, &amp;rn-&gt;p, info);</a>
<a name="ln469">    }</a>
<a name="ln470">}</a>
<a name="ln471"> </a>
<a name="ln472">static void</a>
<a name="ln473">isis_redist_unset(struct isis_area *area, int level,</a>
<a name="ln474">                  int family, int type)</a>
<a name="ln475">{</a>
<a name="ln476">  struct isis_redist *redist = get_redist_settings(area, family, type, level);</a>
<a name="ln477">  struct route_table *er_table = get_ext_reach(area, family, level);</a>
<a name="ln478">  struct route_node *rn;</a>
<a name="ln479">  struct isis_ext_info *info;</a>
<a name="ln480"> </a>
<a name="ln481">  if (!redist-&gt;redist)</a>
<a name="ln482">    return;</a>
<a name="ln483"> </a>
<a name="ln484">  redist-&gt;redist = 0;</a>
<a name="ln485">  if (!er_table)</a>
<a name="ln486">    {</a>
<a name="ln487">      zlog_warn(&quot;%s: External reachability table uninitialized.&quot;, __func__);</a>
<a name="ln488">      return;</a>
<a name="ln489">    }</a>
<a name="ln490"> </a>
<a name="ln491">  for (rn = route_top(er_table); rn; rn = route_next(rn))</a>
<a name="ln492">    {</a>
<a name="ln493">      if (!rn-&gt;info)</a>
<a name="ln494">        continue;</a>
<a name="ln495">      info = rn-&gt;info;</a>
<a name="ln496"> </a>
<a name="ln497">      if (type == DEFAULT_ROUTE)</a>
<a name="ln498">        {</a>
<a name="ln499">          if (!is_default(&amp;rn-&gt;p))</a>
<a name="ln500">            continue;</a>
<a name="ln501">        }</a>
<a name="ln502">      else</a>
<a name="ln503">        {</a>
<a name="ln504">          if (info-&gt;origin != type)</a>
<a name="ln505">            continue;</a>
<a name="ln506">        }</a>
<a name="ln507"> </a>
<a name="ln508">      XFREE(MTYPE_ISIS, rn-&gt;info);</a>
<a name="ln509">      route_unlock_node(rn);</a>
<a name="ln510">    }</a>
<a name="ln511"> </a>
<a name="ln512">  lsp_regenerate_schedule(area, level, 0);</a>
<a name="ln513">  isis_redist_update_zebra_subscriptions(area-&gt;isis);</a>
<a name="ln514">}</a>
<a name="ln515"> </a>
<a name="ln516">void</a>
<a name="ln517">isis_redist_area_finish(struct isis_area *area)</a>
<a name="ln518">{</a>
<a name="ln519">  int protocol;</a>
<a name="ln520">  int level;</a>
<a name="ln521">  int type;</a>
<a name="ln522"> </a>
<a name="ln523">  for (protocol = 0; protocol &lt; REDIST_PROTOCOL_COUNT; protocol++)</a>
<a name="ln524">    for (level = 0; level &lt; ISIS_LEVELS; level++)</a>
<a name="ln525">      {</a>
<a name="ln526">        for (type = 0; type &lt; ZEBRA_ROUTE_MAX + 1; type++)</a>
<a name="ln527">          {</a>
<a name="ln528">            struct isis_redist *redist;</a>
<a name="ln529"> </a>
<a name="ln530">            redist = &amp;area-&gt;redist_settings[protocol][type][level];</a>
<a name="ln531">            redist-&gt;redist = 0;</a>
<a name="ln532">            if (redist-&gt;map_name)</a>
<a name="ln533">              XFREE(MTYPE_ISIS, redist-&gt;map_name);</a>
<a name="ln534">          }</a>
<a name="ln535">        route_table_finish(area-&gt;ext_reach[protocol][level]);</a>
<a name="ln536">      }</a>
<a name="ln537"> </a>
<a name="ln538">  isis_redist_update_zebra_subscriptions(area-&gt;isis);</a>
<a name="ln539">}</a>
<a name="ln540"> </a>
<a name="ln541">DEFUN(isis_redistribute,</a>
<a name="ln542">      isis_redistribute_cmd,</a>
<a name="ln543">      &quot;redistribute (ipv4|ipv6) &quot; QUAGGA_REDIST_STR_ISISD</a>
<a name="ln544">      &quot; (level-1|level-2) {metric &lt;0-16777215&gt;|route-map WORD}&quot;,</a>
<a name="ln545">      REDIST_STR</a>
<a name="ln546">      &quot;Redistribute IPv4 routes\n&quot;</a>
<a name="ln547">      &quot;Redistribute IPv6 routes\n&quot;</a>
<a name="ln548">      QUAGGA_REDIST_HELP_STR_ISISD</a>
<a name="ln549">      &quot;Redistribute into level-1\n&quot;</a>
<a name="ln550">      &quot;Redistribute into level-2\n&quot;</a>
<a name="ln551">      &quot;Metric for redistributed routes\n&quot;</a>
<a name="ln552">      &quot;ISIS default metric\n&quot;</a>
<a name="ln553">      &quot;Route map reference\n&quot;</a>
<a name="ln554">      &quot;Pointer to route-map entries\n&quot;)</a>
<a name="ln555">{</a>
<a name="ln556">  struct isis_area *area = vty-&gt;index;</a>
<a name="ln557">  int family;</a>
<a name="ln558">  int afi;</a>
<a name="ln559">  int type;</a>
<a name="ln560">  int level;</a>
<a name="ln561">  unsigned long metric;</a>
<a name="ln562">  const char *routemap;</a>
<a name="ln563"> </a>
<a name="ln564">  if (argc &lt; 5)</a>
<a name="ln565">    return CMD_WARNING;</a>
<a name="ln566"> </a>
<a name="ln567">  family = str2family(argv[0]);</a>
<a name="ln568">  if (family &lt; 0)</a>
<a name="ln569">    return CMD_WARNING;</a>
<a name="ln570"> </a>
<a name="ln571">  afi = family2afi(family);</a>
<a name="ln572">  if (!afi)</a>
<a name="ln573">    return CMD_WARNING;</a>
<a name="ln574"> </a>
<a name="ln575">  type = proto_redistnum(afi, argv[1]);</a>
<a name="ln576">  if (type &lt; 0 || type == ZEBRA_ROUTE_ISIS)</a>
<a name="ln577">    return CMD_WARNING;</a>
<a name="ln578"> </a>
<a name="ln579">  if (!strcmp(&quot;level-1&quot;, argv[2]))</a>
<a name="ln580">    level = 1;</a>
<a name="ln581">  else if (!strcmp(&quot;level-2&quot;, argv[2]))</a>
<a name="ln582">    level = 2;</a>
<a name="ln583">  else</a>
<a name="ln584">    return CMD_WARNING;</a>
<a name="ln585"> </a>
<a name="ln586">  if ((area-&gt;is_type &amp; level) != level)</a>
<a name="ln587">    {</a>
<a name="ln588">      vty_out(vty, &quot;Node is not a level-%d IS%s&quot;, level, VTY_NEWLINE);</a>
<a name="ln589">      return CMD_WARNING;</a>
<a name="ln590">    }</a>
<a name="ln591"> </a>
<a name="ln592">  if (argv[3])</a>
<a name="ln593">    {</a>
<a name="ln594">      char *endp;</a>
<a name="ln595">      metric = strtoul(argv[3], &amp;endp, 10);</a>
<a name="ln596">      if (argv[3][0] == '\0' || *endp != '\0')</a>
<a name="ln597">        return CMD_WARNING;</a>
<a name="ln598">    }</a>
<a name="ln599">  else</a>
<a name="ln600">    {</a>
<a name="ln601">      metric = 0xffffffff;</a>
<a name="ln602">    }</a>
<a name="ln603"> </a>
<a name="ln604">  routemap = argv[4];</a>
<a name="ln605"> </a>
<a name="ln606">  isis_redist_set(area, level, family, type, metric, routemap, 0);</a>
<a name="ln607">  return 0;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">DEFUN(no_isis_redistribute,</a>
<a name="ln611">      no_isis_redistribute_cmd,</a>
<a name="ln612">      &quot;no redistribute (ipv4|ipv6) &quot; QUAGGA_REDIST_STR_ISISD</a>
<a name="ln613">      &quot; (level-1|level-2)&quot;,</a>
<a name="ln614">      NO_STR</a>
<a name="ln615">      REDIST_STR</a>
<a name="ln616">      &quot;Redistribute IPv4 routes\n&quot;</a>
<a name="ln617">      &quot;Redistribute IPv6 routes\n&quot;</a>
<a name="ln618">      QUAGGA_REDIST_HELP_STR_ISISD</a>
<a name="ln619">      &quot;Redistribute into level-1\n&quot;</a>
<a name="ln620">      &quot;Redistribute into level-2\n&quot;)</a>
<a name="ln621">{</a>
<a name="ln622">  struct isis_area *area = vty-&gt;index;</a>
<a name="ln623">  int type;</a>
<a name="ln624">  int level;</a>
<a name="ln625">  int family;</a>
<a name="ln626">  int afi;</a>
<a name="ln627"> </a>
<a name="ln628">  if (argc &lt; 3)</a>
<a name="ln629">    return CMD_WARNING;</a>
<a name="ln630"> </a>
<a name="ln631">  family = str2family(argv[0]);</a>
<a name="ln632">  if (family &lt; 0)</a>
<a name="ln633">    return CMD_WARNING;</a>
<a name="ln634"> </a>
<a name="ln635">  afi = family2afi(family);</a>
<a name="ln636">  if (!afi)</a>
<a name="ln637">    return CMD_WARNING;</a>
<a name="ln638"> </a>
<a name="ln639">  type = proto_redistnum(afi, argv[1]);</a>
<a name="ln640">  if (type &lt; 0 || type == ZEBRA_ROUTE_ISIS)</a>
<a name="ln641">    return CMD_WARNING;</a>
<a name="ln642"> </a>
<a name="ln643">  if (!strcmp(&quot;level-1&quot;, argv[2]))</a>
<a name="ln644">    level = 1;</a>
<a name="ln645">  else if (!strcmp(&quot;level-2&quot;, argv[2]))</a>
<a name="ln646">    level = 2;</a>
<a name="ln647">  else</a>
<a name="ln648">    return CMD_WARNING;</a>
<a name="ln649"> </a>
<a name="ln650">  isis_redist_unset(area, level, family, type);</a>
<a name="ln651">  return 0;</a>
<a name="ln652">}</a>
<a name="ln653"> </a>
<a name="ln654">DEFUN(isis_default_originate,</a>
<a name="ln655">      isis_default_originate_cmd,</a>
<a name="ln656">      &quot;default-information originate (ipv4|ipv6) (level-1|level-2) &quot;</a>
<a name="ln657">        &quot;{always|metric &lt;0-16777215&gt;|route-map WORD}&quot;,</a>
<a name="ln658">      &quot;Control distribution of default information\n&quot;</a>
<a name="ln659">      &quot;Distribute a default route\n&quot;</a>
<a name="ln660">      &quot;Distribute default route for IPv4\n&quot;</a>
<a name="ln661">      &quot;Distribute default route for IPv6\n&quot;</a>
<a name="ln662">      &quot;Distribute default route into level-1\n&quot;</a>
<a name="ln663">      &quot;Distribute default route into level-2\n&quot;</a>
<a name="ln664">      &quot;Always advertise default route\n&quot;</a>
<a name="ln665">      &quot;Metric for default route\n&quot;</a>
<a name="ln666">      &quot;ISIS default metric\n&quot;</a>
<a name="ln667">      &quot;Route map reference\n&quot;</a>
<a name="ln668">      &quot;Pointer to route-map entries\n&quot;)</a>
<a name="ln669">{</a>
<a name="ln670">  struct isis_area *area = vty-&gt;index;</a>
<a name="ln671">  int family;</a>
<a name="ln672">  int originate_type;</a>
<a name="ln673">  int level;</a>
<a name="ln674">  unsigned long metric;</a>
<a name="ln675">  const char *routemap;</a>
<a name="ln676"> </a>
<a name="ln677">  if (argc &lt; 5)</a>
<a name="ln678">    return CMD_WARNING;</a>
<a name="ln679"> </a>
<a name="ln680">  family = str2family(argv[0]);</a>
<a name="ln681">  if (family &lt; 0)</a>
<a name="ln682">    return CMD_WARNING;</a>
<a name="ln683"> </a>
<a name="ln684">  if (!strcmp(&quot;level-1&quot;, argv[1]))</a>
<a name="ln685">    level = 1;</a>
<a name="ln686">  else if (!strcmp(&quot;level-2&quot;, argv[1]))</a>
<a name="ln687">    level = 2;</a>
<a name="ln688">  else</a>
<a name="ln689">    return CMD_WARNING;</a>
<a name="ln690"> </a>
<a name="ln691">  if ((area-&gt;is_type &amp; level) != level)</a>
<a name="ln692">    {</a>
<a name="ln693">      vty_out(vty, &quot;Node is not a level-%d IS%s&quot;, level, VTY_NEWLINE);</a>
<a name="ln694">      return CMD_WARNING;</a>
<a name="ln695">    }</a>
<a name="ln696"> </a>
<a name="ln697">  if (argv[2] &amp;&amp; *argv[2] != '\0')</a>
<a name="ln698">    originate_type = DEFAULT_ORIGINATE_ALWAYS;</a>
<a name="ln699">  else</a>
<a name="ln700">    originate_type = DEFAULT_ORIGINATE;</a>
<a name="ln701"> </a>
<a name="ln702">  if (family == AF_INET6 &amp;&amp; originate_type != DEFAULT_ORIGINATE_ALWAYS)</a>
<a name="ln703">    {</a>
<a name="ln704">      vty_out(vty, &quot;Zebra doesn't implement default-originate for IPv6 yet%s&quot;, VTY_NEWLINE);</a>
<a name="ln705">      vty_out(vty, &quot;so use with care or use default-originate always.%s&quot;, VTY_NEWLINE);</a>
<a name="ln706">    }</a>
<a name="ln707"> </a>
<a name="ln708">  if (argv[3])</a>
<a name="ln709">    {</a>
<a name="ln710">      char *endp;</a>
<a name="ln711">      metric = strtoul(argv[3], &amp;endp, 10);</a>
<a name="ln712">      if (argv[3][0] == '\0' || *endp != '\0')</a>
<a name="ln713">        return CMD_WARNING;</a>
<a name="ln714">    }</a>
<a name="ln715">  else</a>
<a name="ln716">    {</a>
<a name="ln717">      metric = 0xffffffff;</a>
<a name="ln718">    }</a>
<a name="ln719"> </a>
<a name="ln720">  routemap = argv[4];</a>
<a name="ln721"> </a>
<a name="ln722">  isis_redist_set(area, level, family, DEFAULT_ROUTE, metric, routemap, originate_type);</a>
<a name="ln723">  return 0;</a>
<a name="ln724">}</a>
<a name="ln725"> </a>
<a name="ln726">DEFUN(no_isis_default_originate,</a>
<a name="ln727">      no_isis_default_originate_cmd,</a>
<a name="ln728">      &quot;no default-information originate (ipv4|ipv6) (level-1|level-2)&quot;,</a>
<a name="ln729">      NO_STR</a>
<a name="ln730">      &quot;Control distribution of default information\n&quot;</a>
<a name="ln731">      &quot;Distribute a default route\n&quot;</a>
<a name="ln732">      &quot;Distribute default route for IPv4\n&quot;</a>
<a name="ln733">      &quot;Distribute default route for IPv6\n&quot;</a>
<a name="ln734">      &quot;Distribute default route into level-1\n&quot;</a>
<a name="ln735">      &quot;Distribute default route into level-2\n&quot;)</a>
<a name="ln736">{</a>
<a name="ln737">  struct isis_area *area = vty-&gt;index;</a>
<a name="ln738"> </a>
<a name="ln739">  int family;</a>
<a name="ln740">  int level;</a>
<a name="ln741"> </a>
<a name="ln742">  if (argc &lt; 2)</a>
<a name="ln743">    return CMD_WARNING;</a>
<a name="ln744"> </a>
<a name="ln745">  family = str2family(argv[0]);</a>
<a name="ln746">  if (family &lt; 0)</a>
<a name="ln747">    return CMD_WARNING;</a>
<a name="ln748"> </a>
<a name="ln749">  if (!strcmp(&quot;level-1&quot;, argv[1]))</a>
<a name="ln750">    level = 1;</a>
<a name="ln751">  else if (!strcmp(&quot;level-2&quot;, argv[1]))</a>
<a name="ln752">    level = 2;</a>
<a name="ln753">  else</a>
<a name="ln754">    return CMD_WARNING;</a>
<a name="ln755"> </a>
<a name="ln756">  isis_redist_unset(area, level, family, DEFAULT_ROUTE);</a>
<a name="ln757">  return 0;</a>
<a name="ln758">}</a>
<a name="ln759"> </a>
<a name="ln760">int</a>
<a name="ln761">isis_redist_config_write(struct vty *vty, struct isis_area *area,</a>
<a name="ln762">                         int family)</a>
<a name="ln763">{</a>
<a name="ln764">  int type;</a>
<a name="ln765">  int level;</a>
<a name="ln766">  int write = 0;</a>
<a name="ln767">  struct isis_redist *redist;</a>
<a name="ln768">  const char *family_str;</a>
<a name="ln769"> </a>
<a name="ln770">  if (family == AF_INET)</a>
<a name="ln771">    family_str = &quot;ipv4&quot;;</a>
<a name="ln772">  else if (family == AF_INET6)</a>
<a name="ln773">    family_str = &quot;ipv6&quot;;</a>
<a name="ln774">  else</a>
<a name="ln775">    return 0;</a>
<a name="ln776"> </a>
<a name="ln777">  for (type = 0; type &lt; ZEBRA_ROUTE_MAX; type++)</a>
<a name="ln778">    {</a>
<a name="ln779">      if (type == ZEBRA_ROUTE_ISIS)</a>
<a name="ln780">        continue;</a>
<a name="ln781"> </a>
<a name="ln782">      for (level = 1; level &lt;= ISIS_LEVELS; level++)</a>
<a name="ln783">        {</a>
<a name="ln784">          redist = get_redist_settings(area, family, type, level);</a>
<a name="ln785">          if (!redist-&gt;redist)</a>
<a name="ln786">            continue;</a>
<a name="ln787">          vty_out(vty, &quot; redistribute %s %s level-%d&quot;,</a>
<a name="ln788">                  family_str, zebra_route_string(type), level);</a>
<a name="ln789">          if (redist-&gt;metric != 0xffffffff)</a>
<a name="ln790">            vty_out(vty, &quot; metric %u&quot;, redist-&gt;metric);</a>
<a name="ln791">          if (redist-&gt;map_name)</a>
<a name="ln792">            vty_out(vty, &quot; route-map %s&quot;, redist-&gt;map_name);</a>
<a name="ln793">          vty_out(vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln794">          write++;</a>
<a name="ln795">        }</a>
<a name="ln796">    }</a>
<a name="ln797"> </a>
<a name="ln798">  for (level = 1; level &lt;= ISIS_LEVELS; level++)</a>
<a name="ln799">    {</a>
<a name="ln800">      redist = get_redist_settings(area, family, DEFAULT_ROUTE, level);</a>
<a name="ln801">      if (!redist-&gt;redist)</a>
<a name="ln802">        continue;</a>
<a name="ln803">      vty_out(vty, &quot; default-information originate %s level-%d&quot;,</a>
<a name="ln804">              family_str, level);</a>
<a name="ln805">      if (redist-&gt;redist == DEFAULT_ORIGINATE_ALWAYS)</a>
<a name="ln806">        vty_out(vty, &quot; always&quot;);</a>
<a name="ln807">      if (redist-&gt;metric != 0xffffffff)</a>
<a name="ln808">        vty_out(vty, &quot; metric %u&quot;, redist-&gt;metric);</a>
<a name="ln809">      if (redist-&gt;map_name)</a>
<a name="ln810">        vty_out(vty, &quot; route-map %s&quot;, redist-&gt;map_name);</a>
<a name="ln811">      vty_out(vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln812">      write++;</a>
<a name="ln813">    }</a>
<a name="ln814"> </a>
<a name="ln815">  return write;</a>
<a name="ln816">}</a>
<a name="ln817"> </a>
<a name="ln818">void</a>
<a name="ln819">isis_redist_init(void)</a>
<a name="ln820">{</a>
<a name="ln821">  install_element(ISIS_NODE, &amp;isis_redistribute_cmd);</a>
<a name="ln822">  install_element(ISIS_NODE, &amp;no_isis_redistribute_cmd);</a>
<a name="ln823">  install_element(ISIS_NODE, &amp;isis_default_originate_cmd);</a>
<a name="ln824">  install_element(ISIS_NODE, &amp;no_isis_default_originate_cmd);</a>
<a name="ln825">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
