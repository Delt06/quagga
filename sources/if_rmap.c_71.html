
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>if_rmap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* route-map for interface.</a>
<a name="ln2"> * Copyright (C) 1999 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &quot;hash.h&quot;</a>
<a name="ln25">#include &quot;command.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;if.h&quot;</a>
<a name="ln28">#include &quot;if_rmap.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">struct hash *ifrmaphash;</a>
<a name="ln31"> </a>
<a name="ln32">/* Hook functions. */</a>
<a name="ln33">static void (*if_rmap_add_hook) (struct if_rmap *) = NULL;</a>
<a name="ln34">static void (*if_rmap_delete_hook) (struct if_rmap *) = NULL;</a>
<a name="ln35"> </a>
<a name="ln36">static struct if_rmap *</a>
<a name="ln37">if_rmap_new (void)</a>
<a name="ln38">{</a>
<a name="ln39">  struct if_rmap *new;</a>
<a name="ln40"> </a>
<a name="ln41">  new = XCALLOC (MTYPE_IF_RMAP, sizeof (struct if_rmap));</a>
<a name="ln42"> </a>
<a name="ln43">  return new;</a>
<a name="ln44">}</a>
<a name="ln45"> </a>
<a name="ln46">static void</a>
<a name="ln47">if_rmap_free (struct if_rmap *if_rmap)</a>
<a name="ln48">{</a>
<a name="ln49">  if (if_rmap-&gt;ifname)</a>
<a name="ln50">    XFREE (MTYPE_IF_RMAP_NAME, if_rmap-&gt;ifname);</a>
<a name="ln51"> </a>
<a name="ln52">  if (if_rmap-&gt;routemap[IF_RMAP_IN])</a>
<a name="ln53">    XFREE (MTYPE_IF_RMAP_NAME, if_rmap-&gt;routemap[IF_RMAP_IN]);</a>
<a name="ln54">  if (if_rmap-&gt;routemap[IF_RMAP_OUT])</a>
<a name="ln55">    XFREE (MTYPE_IF_RMAP_NAME, if_rmap-&gt;routemap[IF_RMAP_OUT]);</a>
<a name="ln56"> </a>
<a name="ln57">  XFREE (MTYPE_IF_RMAP, if_rmap);</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">struct if_rmap *</a>
<a name="ln61">if_rmap_lookup (const char *ifname)</a>
<a name="ln62">{</a>
<a name="ln63">  struct if_rmap key;</a>
<a name="ln64">  struct if_rmap *if_rmap;</a>
<a name="ln65"> </a>
<a name="ln66">  /* temporary copy */</a>
<a name="ln67">  key.ifname = (char *)ifname;</a>
<a name="ln68"> </a>
<a name="ln69">  if_rmap = hash_lookup (ifrmaphash, &amp;key);</a>
<a name="ln70">  </a>
<a name="ln71">  return if_rmap;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">void</a>
<a name="ln75">if_rmap_hook_add (void (*func) (struct if_rmap *))</a>
<a name="ln76">{</a>
<a name="ln77">  if_rmap_add_hook = func;</a>
<a name="ln78">}</a>
<a name="ln79"> </a>
<a name="ln80">void</a>
<a name="ln81">if_rmap_hook_delete (void (*func) (struct if_rmap *))</a>
<a name="ln82">{</a>
<a name="ln83">  if_rmap_delete_hook = func;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">static void *</a>
<a name="ln87">if_rmap_hash_alloc (void *arg)</a>
<a name="ln88">{</a>
<a name="ln89">  struct if_rmap *ifarg = arg;</a>
<a name="ln90">  struct if_rmap *if_rmap;</a>
<a name="ln91"> </a>
<a name="ln92">  if_rmap = if_rmap_new ();</a>
<a name="ln93">  if_rmap-&gt;ifname = XSTRDUP (MTYPE_IF_RMAP_NAME, ifarg-&gt;ifname);</a>
<a name="ln94"> </a>
<a name="ln95">  return if_rmap;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">static struct if_rmap *</a>
<a name="ln99">if_rmap_get (const char *ifname)</a>
<a name="ln100">{</a>
<a name="ln101">  struct if_rmap key;</a>
<a name="ln102"> </a>
<a name="ln103">  /* temporary copy */</a>
<a name="ln104">  key.ifname = (char *)ifname;</a>
<a name="ln105"> </a>
<a name="ln106">  return (struct if_rmap *) hash_get (ifrmaphash, &amp;key, if_rmap_hash_alloc);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">static unsigned int</a>
<a name="ln110">if_rmap_hash_make (void *data)</a>
<a name="ln111">{</a>
<a name="ln112">  const struct if_rmap *if_rmap = data;</a>
<a name="ln113"> </a>
<a name="ln114">  return string_hash_make (if_rmap-&gt;ifname);</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">static int</a>
<a name="ln118">if_rmap_hash_cmp (const void *arg1, const void* arg2)</a>
<a name="ln119">{</a>
<a name="ln120">  const struct if_rmap *if_rmap1 = arg1;</a>
<a name="ln121">  const struct if_rmap *if_rmap2 = arg2;</a>
<a name="ln122"> </a>
<a name="ln123">  return strcmp (if_rmap1-&gt;ifname, if_rmap2-&gt;ifname) == 0;</a>
<a name="ln124">}</a>
<a name="ln125"> </a>
<a name="ln126">static struct if_rmap *</a>
<a name="ln127">if_rmap_set (const char *ifname, enum if_rmap_type type, </a>
<a name="ln128">             const char *routemap_name)</a>
<a name="ln129">{</a>
<a name="ln130">  struct if_rmap *if_rmap;</a>
<a name="ln131"> </a>
<a name="ln132">  if_rmap = if_rmap_get (ifname);</a>
<a name="ln133"> </a>
<a name="ln134">  if (type == IF_RMAP_IN)</a>
<a name="ln135">    {</a>
<a name="ln136">      if (if_rmap-&gt;routemap[IF_RMAP_IN])</a>
<a name="ln137">	XFREE (MTYPE_IF_RMAP_NAME, if_rmap-&gt;routemap[IF_RMAP_IN]);</a>
<a name="ln138">      if_rmap-&gt;routemap[IF_RMAP_IN] </a>
<a name="ln139">        = XSTRDUP (MTYPE_IF_RMAP_NAME, routemap_name);</a>
<a name="ln140">    }</a>
<a name="ln141">  if (type == IF_RMAP_OUT)</a>
<a name="ln142">    {</a>
<a name="ln143">      if (if_rmap-&gt;routemap[IF_RMAP_OUT])</a>
<a name="ln144">	XFREE (MTYPE_IF_RMAP_NAME, if_rmap-&gt;routemap[IF_RMAP_OUT]);</a>
<a name="ln145">      if_rmap-&gt;routemap[IF_RMAP_OUT] </a>
<a name="ln146">        = XSTRDUP (MTYPE_IF_RMAP_NAME, routemap_name);</a>
<a name="ln147">    }</a>
<a name="ln148"> </a>
<a name="ln149">  if (if_rmap_add_hook)</a>
<a name="ln150">    (*if_rmap_add_hook) (if_rmap);</a>
<a name="ln151">  </a>
<a name="ln152">  return if_rmap;</a>
<a name="ln153">}</a>
<a name="ln154"> </a>
<a name="ln155">static int</a>
<a name="ln156">if_rmap_unset (const char *ifname, enum if_rmap_type type, </a>
<a name="ln157">               const char *routemap_name)</a>
<a name="ln158">{</a>
<a name="ln159">  struct if_rmap *if_rmap;</a>
<a name="ln160"> </a>
<a name="ln161">  if_rmap = if_rmap_lookup (ifname);</a>
<a name="ln162">  if (!if_rmap)</a>
<a name="ln163">    return 0;</a>
<a name="ln164"> </a>
<a name="ln165">  if (type == IF_RMAP_IN)</a>
<a name="ln166">    {</a>
<a name="ln167">      if (!if_rmap-&gt;routemap[IF_RMAP_IN])</a>
<a name="ln168">	return 0;</a>
<a name="ln169">      if (strcmp (if_rmap-&gt;routemap[IF_RMAP_IN], routemap_name) != 0)</a>
<a name="ln170">	return 0;</a>
<a name="ln171"> </a>
<a name="ln172">      XFREE (MTYPE_IF_RMAP_NAME, if_rmap-&gt;routemap[IF_RMAP_IN]);</a>
<a name="ln173">      if_rmap-&gt;routemap[IF_RMAP_IN] = NULL;      </a>
<a name="ln174">    }</a>
<a name="ln175"> </a>
<a name="ln176">  if (type == IF_RMAP_OUT)</a>
<a name="ln177">    {</a>
<a name="ln178">      if (!if_rmap-&gt;routemap[IF_RMAP_OUT])</a>
<a name="ln179">	return 0;</a>
<a name="ln180">      if (strcmp (if_rmap-&gt;routemap[IF_RMAP_OUT], routemap_name) != 0)</a>
<a name="ln181">	return 0;</a>
<a name="ln182"> </a>
<a name="ln183">      XFREE (MTYPE_IF_RMAP_NAME, if_rmap-&gt;routemap[IF_RMAP_OUT]);</a>
<a name="ln184">      if_rmap-&gt;routemap[IF_RMAP_OUT] = NULL;      </a>
<a name="ln185">    }</a>
<a name="ln186"> </a>
<a name="ln187">  if (if_rmap_delete_hook)</a>
<a name="ln188">    (*if_rmap_delete_hook) (if_rmap);</a>
<a name="ln189"> </a>
<a name="ln190">  if (if_rmap-&gt;routemap[IF_RMAP_IN] == NULL &amp;&amp;</a>
<a name="ln191">      if_rmap-&gt;routemap[IF_RMAP_OUT] == NULL)</a>
<a name="ln192">    {</a>
<a name="ln193">      hash_release (ifrmaphash, if_rmap);</a>
<a name="ln194">      if_rmap_free (if_rmap);</a>
<a name="ln195">    }</a>
<a name="ln196"> </a>
<a name="ln197">  return 1;</a>
<a name="ln198">}</a>
<a name="ln199"> </a>
<a name="ln200">DEFUN (if_rmap,</a>
<a name="ln201">       if_rmap_cmd,</a>
<a name="ln202">       &quot;route-map RMAP_NAME (in|out) IFNAME&quot;,</a>
<a name="ln203">       &quot;Route map set\n&quot;</a>
<a name="ln204">       &quot;Route map name\n&quot;</a>
<a name="ln205">       &quot;Route map set for input filtering\n&quot;</a>
<a name="ln206">       &quot;Route map set for output filtering\n&quot;</a>
<a name="ln207">       &quot;Route map interface name\n&quot;)</a>
<a name="ln208">{</a>
<a name="ln209">  enum if_rmap_type type;</a>
<a name="ln210"> </a>
<a name="ln211">  if (strncmp (argv[1], &quot;i&quot;, 1) == 0)</a>
<a name="ln212">    type = IF_RMAP_IN;</a>
<a name="ln213">  else if (strncmp (argv[1], &quot;o&quot;, 1) == 0)</a>
<a name="ln214">    type = IF_RMAP_OUT;</a>
<a name="ln215">  else</a>
<a name="ln216">    {</a>
<a name="ln217">      vty_out (vty, &quot;route-map direction must be [in|out]%s&quot;, VTY_NEWLINE);</a>
<a name="ln218">      return CMD_WARNING;</a>
<a name="ln219">    }</a>
<a name="ln220"> </a>
<a name="ln221">  if_rmap_set (argv[2], type, argv[0]);</a>
<a name="ln222"> </a>
<a name="ln223">  return CMD_SUCCESS;</a>
<a name="ln224">}      </a>
<a name="ln225"> </a>
<a name="ln226">ALIAS (if_rmap,</a>
<a name="ln227">       if_ipv6_rmap_cmd,</a>
<a name="ln228">       &quot;route-map RMAP_NAME (in|out) IFNAME&quot;,</a>
<a name="ln229">       &quot;Route map set\n&quot;</a>
<a name="ln230">       &quot;Route map name\n&quot;</a>
<a name="ln231">       &quot;Route map set for input filtering\n&quot;</a>
<a name="ln232">       &quot;Route map set for output filtering\n&quot;</a>
<a name="ln233">       &quot;Route map interface name\n&quot;)</a>
<a name="ln234"> </a>
<a name="ln235">DEFUN (no_if_rmap,</a>
<a name="ln236">       no_if_rmap_cmd,</a>
<a name="ln237">       &quot;no route-map ROUTEMAP_NAME (in|out) IFNAME&quot;,</a>
<a name="ln238">       NO_STR</a>
<a name="ln239">       &quot;Route map unset\n&quot;</a>
<a name="ln240">       &quot;Route map name\n&quot;</a>
<a name="ln241">       &quot;Route map for input filtering\n&quot;</a>
<a name="ln242">       &quot;Route map for output filtering\n&quot;</a>
<a name="ln243">       &quot;Route map interface name\n&quot;)</a>
<a name="ln244">{</a>
<a name="ln245">  int ret;</a>
<a name="ln246">  enum if_rmap_type type;</a>
<a name="ln247"> </a>
<a name="ln248">  if (strncmp (argv[1], &quot;i&quot;, 1) == 0)</a>
<a name="ln249">    type = IF_RMAP_IN;</a>
<a name="ln250">  else if (strncmp (argv[1], &quot;o&quot;, 1) == 0)</a>
<a name="ln251">    type = IF_RMAP_OUT;</a>
<a name="ln252">  else</a>
<a name="ln253">    {</a>
<a name="ln254">      vty_out (vty, &quot;route-map direction must be [in|out]%s&quot;, VTY_NEWLINE);</a>
<a name="ln255">      return CMD_WARNING;</a>
<a name="ln256">    }</a>
<a name="ln257"> </a>
<a name="ln258">  ret = if_rmap_unset (argv[2], type, argv[0]);</a>
<a name="ln259">  if (! ret)</a>
<a name="ln260">    {</a>
<a name="ln261">      vty_out (vty, &quot;route-map doesn't exist%s&quot;, VTY_NEWLINE);</a>
<a name="ln262">      return CMD_WARNING;</a>
<a name="ln263">    }</a>
<a name="ln264">  return CMD_SUCCESS;</a>
<a name="ln265">}      </a>
<a name="ln266"> </a>
<a name="ln267">ALIAS (no_if_rmap,</a>
<a name="ln268">       no_if_ipv6_rmap_cmd,</a>
<a name="ln269">       &quot;no route-map ROUTEMAP_NAME (in|out) IFNAME&quot;,</a>
<a name="ln270">       NO_STR</a>
<a name="ln271">       &quot;Route map unset\n&quot;</a>
<a name="ln272">       &quot;Route map name\n&quot;</a>
<a name="ln273">       &quot;Route map for input filtering\n&quot;</a>
<a name="ln274">       &quot;Route map for output filtering\n&quot;</a>
<a name="ln275">       &quot;Route map interface name\n&quot;)</a>
<a name="ln276"> </a>
<a name="ln277">/* Configuration write function. */</a>
<a name="ln278">int</a>
<a name="ln279">config_write_if_rmap (struct vty *vty)</a>
<a name="ln280">{</a>
<a name="ln281">  unsigned int i;</a>
<a name="ln282">  struct hash_backet *mp;</a>
<a name="ln283">  int write = 0;</a>
<a name="ln284"> </a>
<a name="ln285">  for (i = 0; i &lt; ifrmaphash-&gt;size; i++)</a>
<a name="ln286">    for (mp = ifrmaphash-&gt;index[i]; mp; mp = mp-&gt;next)</a>
<a name="ln287">      {</a>
<a name="ln288">	struct if_rmap *if_rmap;</a>
<a name="ln289"> </a>
<a name="ln290">	if_rmap = mp-&gt;data;</a>
<a name="ln291"> </a>
<a name="ln292">	if (if_rmap-&gt;routemap[IF_RMAP_IN])</a>
<a name="ln293">	  {</a>
<a name="ln294">	    vty_out (vty, &quot; route-map %s in %s%s&quot;, </a>
<a name="ln295">		     if_rmap-&gt;routemap[IF_RMAP_IN],</a>
<a name="ln296">		     if_rmap-&gt;ifname,</a>
<a name="ln297">		     VTY_NEWLINE);</a>
<a name="ln298">	    write++;</a>
<a name="ln299">	  }</a>
<a name="ln300"> </a>
<a name="ln301">	if (if_rmap-&gt;routemap[IF_RMAP_OUT])</a>
<a name="ln302">	  {</a>
<a name="ln303">	    vty_out (vty, &quot; route-map %s out %s%s&quot;, </a>
<a name="ln304">		     if_rmap-&gt;routemap[IF_RMAP_OUT],</a>
<a name="ln305">		     if_rmap-&gt;ifname,</a>
<a name="ln306">		     VTY_NEWLINE);</a>
<a name="ln307">	    write++;</a>
<a name="ln308">	  }</a>
<a name="ln309">      }</a>
<a name="ln310">  return write;</a>
<a name="ln311">}</a>
<a name="ln312"> </a>
<a name="ln313">void</a>
<a name="ln314">if_rmap_reset ()</a>
<a name="ln315">{</a>
<a name="ln316">  hash_clean (ifrmaphash, (void (*) (void *)) if_rmap_free);</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">void</a>
<a name="ln320">if_rmap_init (int node)</a>
<a name="ln321">{</a>
<a name="ln322">  ifrmaphash = hash_create (if_rmap_hash_make, if_rmap_hash_cmp);</a>
<a name="ln323">  if (node == RIPNG_NODE) {</a>
<a name="ln324">    install_element (RIPNG_NODE, &amp;if_ipv6_rmap_cmd);</a>
<a name="ln325">    install_element (RIPNG_NODE, &amp;no_if_ipv6_rmap_cmd);</a>
<a name="ln326">  } else if (node == RIP_NODE) {</a>
<a name="ln327">    install_element (RIP_NODE, &amp;if_rmap_cmd);</a>
<a name="ln328">    install_element (RIP_NODE, &amp;no_if_rmap_cmd);</a>
<a name="ln329">  }</a>
<a name="ln330">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
