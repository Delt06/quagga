
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>main.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* zebra daemon main routine.</a>
<a name="ln2"> * Copyright (C) 1997, 98 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;zebra.h&gt;</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;lib/version.h&gt;</a>
<a name="ln25">#include &quot;getopt.h&quot;</a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;thread.h&quot;</a>
<a name="ln28">#include &quot;filter.h&quot;</a>
<a name="ln29">#include &quot;memory.h&quot;</a>
<a name="ln30">#include &quot;prefix.h&quot;</a>
<a name="ln31">#include &quot;log.h&quot;</a>
<a name="ln32">#include &quot;plist.h&quot;</a>
<a name="ln33">#include &quot;privs.h&quot;</a>
<a name="ln34">#include &quot;sigevent.h&quot;</a>
<a name="ln35">#include &quot;vrf.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;zebra/rib.h&quot;</a>
<a name="ln38">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln39">#include &quot;zebra/debug.h&quot;</a>
<a name="ln40">#include &quot;zebra/router-id.h&quot;</a>
<a name="ln41">#include &quot;zebra/irdp.h&quot;</a>
<a name="ln42">#include &quot;zebra/rtadv.h&quot;</a>
<a name="ln43">#include &quot;zebra/zebra_fpm.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">/* Zebra instance */</a>
<a name="ln46">struct zebra_t zebrad =</a>
<a name="ln47">{</a>
<a name="ln48">  .rtm_table_default = 0,</a>
<a name="ln49">};</a>
<a name="ln50"> </a>
<a name="ln51">/* process id. */</a>
<a name="ln52">pid_t pid;</a>
<a name="ln53"> </a>
<a name="ln54">/* Pacify zclient.o in libzebra, which expects this variable. */</a>
<a name="ln55">struct thread_master *master;</a>
<a name="ln56"> </a>
<a name="ln57">/* Route retain mode flag. */</a>
<a name="ln58">int retain_mode = 0;</a>
<a name="ln59"> </a>
<a name="ln60">/* Don't delete kernel route. */</a>
<a name="ln61">int keep_kernel_mode = 0;</a>
<a name="ln62"> </a>
<a name="ln63">#ifdef HAVE_NETLINK</a>
<a name="ln64">/* Receive buffer size for netlink socket */</a>
<a name="ln65">u_int32_t nl_rcvbufsize = 0;</a>
<a name="ln66">#endif /* HAVE_NETLINK */</a>
<a name="ln67"> </a>
<a name="ln68">/* Command line options. */</a>
<a name="ln69">struct option longopts[] = </a>
<a name="ln70">{</a>
<a name="ln71">  { &quot;batch&quot;,       no_argument,       NULL, 'b'},</a>
<a name="ln72">  { &quot;daemon&quot;,      no_argument,       NULL, 'd'},</a>
<a name="ln73">  { &quot;keep_kernel&quot;, no_argument,       NULL, 'k'},</a>
<a name="ln74">  { &quot;fpm_format&quot;,  required_argument, NULL, 'F'},</a>
<a name="ln75">  { &quot;config_file&quot;, required_argument, NULL, 'f'},</a>
<a name="ln76">  { &quot;pid_file&quot;,    required_argument, NULL, 'i'},</a>
<a name="ln77">  { &quot;socket&quot;,      required_argument, NULL, 'z'},</a>
<a name="ln78">  { &quot;help&quot;,        no_argument,       NULL, 'h'},</a>
<a name="ln79">  { &quot;vty_addr&quot;,    required_argument, NULL, 'A'},</a>
<a name="ln80">  { &quot;vty_port&quot;,    required_argument, NULL, 'P'},</a>
<a name="ln81">  { &quot;retain&quot;,      no_argument,       NULL, 'r'},</a>
<a name="ln82">  { &quot;dryrun&quot;,      no_argument,       NULL, 'C'},</a>
<a name="ln83">#ifdef HAVE_NETLINK</a>
<a name="ln84">  { &quot;nl-bufsize&quot;,  required_argument, NULL, 's'},</a>
<a name="ln85">#endif /* HAVE_NETLINK */</a>
<a name="ln86">  { &quot;user&quot;,        required_argument, NULL, 'u'},</a>
<a name="ln87">  { &quot;group&quot;,       required_argument, NULL, 'g'},</a>
<a name="ln88">  { &quot;version&quot;,     no_argument,       NULL, 'v'},</a>
<a name="ln89">  { 0 }</a>
<a name="ln90">};</a>
<a name="ln91"> </a>
<a name="ln92">zebra_capabilities_t _caps_p [] = </a>
<a name="ln93">{</a>
<a name="ln94">  ZCAP_NET_ADMIN,</a>
<a name="ln95">  ZCAP_SYS_ADMIN,</a>
<a name="ln96">  ZCAP_NET_RAW,</a>
<a name="ln97">};</a>
<a name="ln98"> </a>
<a name="ln99">/* zebra privileges to run with */</a>
<a name="ln100">struct zebra_privs_t zserv_privs =</a>
<a name="ln101">{</a>
<a name="ln102">#if defined(QUAGGA_USER) &amp;&amp; defined(QUAGGA_GROUP)</a>
<a name="ln103">  .user = QUAGGA_USER,</a>
<a name="ln104">  .group = QUAGGA_GROUP,</a>
<a name="ln105">#endif</a>
<a name="ln106">#ifdef VTY_GROUP</a>
<a name="ln107">  .vty_group = VTY_GROUP,</a>
<a name="ln108">#endif</a>
<a name="ln109">  .caps_p = _caps_p,</a>
<a name="ln110">  .cap_num_p = array_size(_caps_p),</a>
<a name="ln111">  .cap_num_i = 0</a>
<a name="ln112">};</a>
<a name="ln113"> </a>
<a name="ln114">/* Default configuration file path. */</a>
<a name="ln115">char config_default[] = SYSCONFDIR DEFAULT_CONFIG_FILE;</a>
<a name="ln116"> </a>
<a name="ln117">/* Process ID saved for use by init system */</a>
<a name="ln118">const char *pid_file = PATH_ZEBRA_PID;</a>
<a name="ln119"> </a>
<a name="ln120">/* Help information display. */</a>
<a name="ln121">static void</a>
<a name="ln122">usage (char *progname, int status)</a>
<a name="ln123">{</a>
<a name="ln124">  if (status != 0)</a>
<a name="ln125">    fprintf (stderr, &quot;Try `%s --help' for more information.\n&quot;, progname);</a>
<a name="ln126">  else</a>
<a name="ln127">    {    </a>
<a name="ln128">      printf (&quot;Usage : %s [OPTION...]\n\n&quot;\</a>
<a name="ln129">	      &quot;Daemon which manages kernel routing table management and &quot;\</a>
<a name="ln130">	      &quot;redistribution between different routing protocols.\n\n&quot;\</a>
<a name="ln131">	      &quot;-b, --batch        Runs in batch mode\n&quot;\</a>
<a name="ln132">	      &quot;-d, --daemon       Runs in daemon mode\n&quot;\</a>
<a name="ln133">	      &quot;-f, --config_file  Set configuration file name\n&quot;\</a>
<a name="ln134">	      &quot;-F, --fpm_format   Set fpm format to 'netlink' or 'protobuf'\n&quot;\</a>
<a name="ln135">	      &quot;-i, --pid_file     Set process identifier file name\n&quot;\</a>
<a name="ln136">	      &quot;-z, --socket       Set path of zebra socket\n&quot;\</a>
<a name="ln137">	      &quot;-k, --keep_kernel  Don't delete old routes which installed by &quot;\</a>
<a name="ln138">				  &quot;zebra.\n&quot;\</a>
<a name="ln139">	      &quot;-C, --dryrun       Check configuration for validity and exit\n&quot;\</a>
<a name="ln140">	      &quot;-A, --vty_addr     Set vty's bind address\n&quot;\</a>
<a name="ln141">	      &quot;-P, --vty_port     Set vty's port number\n&quot;\</a>
<a name="ln142">	      &quot;-r, --retain       When program terminates, retain added route &quot;\</a>
<a name="ln143">				  &quot;by zebra.\n&quot;\</a>
<a name="ln144">	      &quot;-u, --user         User to run as\n&quot;\</a>
<a name="ln145">	      &quot;-g, --group	  Group to run as\n&quot;, progname);</a>
<a name="ln146">#ifdef HAVE_NETLINK</a>
<a name="ln147">      printf (&quot;-s, --nl-bufsize   Set netlink receive buffer size\n&quot;);</a>
<a name="ln148">#endif /* HAVE_NETLINK */</a>
<a name="ln149">      printf (&quot;-v, --version      Print program version\n&quot;\</a>
<a name="ln150">	      &quot;-h, --help         Display this help and exit\n&quot;\</a>
<a name="ln151">	      &quot;\n&quot;\</a>
<a name="ln152">	      &quot;Report bugs to %s\n&quot;, ZEBRA_BUG_ADDRESS);</a>
<a name="ln153">    }</a>
<a name="ln154"> </a>
<a name="ln155">  exit (status);</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">/* SIGHUP handler. */</a>
<a name="ln159">static void </a>
<a name="ln160">sighup (void)</a>
<a name="ln161">{</a>
<a name="ln162">  zlog_info (&quot;SIGHUP received&quot;);</a>
<a name="ln163"> </a>
<a name="ln164">  /* Reload of config file. */</a>
<a name="ln165">  ;</a>
<a name="ln166">}</a>
<a name="ln167"> </a>
<a name="ln168">/* SIGINT handler. */</a>
<a name="ln169">static void</a>
<a name="ln170">sigint (void)</a>
<a name="ln171">{</a>
<a name="ln172">  zlog_notice (&quot;Terminating on signal&quot;);</a>
<a name="ln173"> </a>
<a name="ln174">  if (!retain_mode)</a>
<a name="ln175">    rib_close ();</a>
<a name="ln176">#ifdef HAVE_IRDP</a>
<a name="ln177">  irdp_finish();</a>
<a name="ln178">#endif</a>
<a name="ln179"> </a>
<a name="ln180">  exit (0);</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">/* SIGUSR1 handler. */</a>
<a name="ln184">static void</a>
<a name="ln185">sigusr1 (void)</a>
<a name="ln186">{</a>
<a name="ln187">  zlog_rotate (NULL);</a>
<a name="ln188">}</a>
<a name="ln189"> </a>
<a name="ln190">struct quagga_signal_t zebra_signals[] =</a>
<a name="ln191">{</a>
<a name="ln192">  { </a>
<a name="ln193">    .signal = SIGHUP, </a>
<a name="ln194">    .handler = &amp;sighup,</a>
<a name="ln195">  },</a>
<a name="ln196">  {</a>
<a name="ln197">    .signal = SIGUSR1,</a>
<a name="ln198">    .handler = &amp;sigusr1,</a>
<a name="ln199">  },</a>
<a name="ln200">  {</a>
<a name="ln201">    .signal = SIGINT,</a>
<a name="ln202">    .handler = &amp;sigint,</a>
<a name="ln203">  },</a>
<a name="ln204">  {</a>
<a name="ln205">    .signal = SIGTERM,</a>
<a name="ln206">    .handler = &amp;sigint,</a>
<a name="ln207">  },</a>
<a name="ln208">};</a>
<a name="ln209"> </a>
<a name="ln210">/* Callback upon creating a new VRF. */</a>
<a name="ln211">static int</a>
<a name="ln212">zebra_vrf_new (vrf_id_t vrf_id, void **info)</a>
<a name="ln213">{</a>
<a name="ln214">  struct zebra_vrf *zvrf = *info;</a>
<a name="ln215"> </a>
<a name="ln216">  if (! zvrf)</a>
<a name="ln217">    {</a>
<a name="ln218">      zvrf = zebra_vrf_alloc (vrf_id);</a>
<a name="ln219">      *info = (void *)zvrf;</a>
<a name="ln220">      router_id_init (zvrf);</a>
<a name="ln221">    }</a>
<a name="ln222"> </a>
<a name="ln223">  return 0;</a>
<a name="ln224">}</a>
<a name="ln225"> </a>
<a name="ln226">/* Callback upon enabling a VRF. */</a>
<a name="ln227">static int</a>
<a name="ln228">zebra_vrf_enable (vrf_id_t vrf_id, void **info)</a>
<a name="ln229">{</a>
<a name="ln230">  struct zebra_vrf *zvrf = (struct zebra_vrf *) (*info);</a>
<a name="ln231"> </a>
<a name="ln232">  assert (zvrf);</a>
<a name="ln233"> </a>
<a name="ln234">#if defined (HAVE_RTADV)</a>
<a name="ln235">  rtadv_init (zvrf);</a>
<a name="ln236">#endif</a>
<a name="ln237">  kernel_init (zvrf);</a>
<a name="ln238">  interface_list (zvrf);</a>
<a name="ln239">  route_read (zvrf);</a>
<a name="ln240"> </a>
<a name="ln241">  return 0;</a>
<a name="ln242">}</a>
<a name="ln243"> </a>
<a name="ln244">/* Callback upon disabling a VRF. */</a>
<a name="ln245">static int</a>
<a name="ln246">zebra_vrf_disable (vrf_id_t vrf_id, void **info)</a>
<a name="ln247">{</a>
<a name="ln248">  struct zebra_vrf *zvrf = (struct zebra_vrf *) (*info);</a>
<a name="ln249">  struct listnode *list_node;</a>
<a name="ln250">  struct interface *ifp;</a>
<a name="ln251"> </a>
<a name="ln252">  assert (zvrf);</a>
<a name="ln253"> </a>
<a name="ln254">  rib_close_table (zvrf-&gt;table[AFI_IP][SAFI_UNICAST]);</a>
<a name="ln255">  rib_close_table (zvrf-&gt;table[AFI_IP6][SAFI_UNICAST]);</a>
<a name="ln256"> </a>
<a name="ln257">  for (ALL_LIST_ELEMENTS_RO (vrf_iflist (vrf_id), list_node, ifp))</a>
<a name="ln258">    {</a>
<a name="ln259">      int operative = if_is_operative (ifp);</a>
<a name="ln260">      UNSET_FLAG (ifp-&gt;flags, IFF_UP);</a>
<a name="ln261">      if (operative)</a>
<a name="ln262">        if_down (ifp);</a>
<a name="ln263">    }</a>
<a name="ln264"> </a>
<a name="ln265">#if defined (HAVE_RTADV)</a>
<a name="ln266">  rtadv_terminate (zvrf);</a>
<a name="ln267">#endif</a>
<a name="ln268">  kernel_terminate (zvrf);</a>
<a name="ln269"> </a>
<a name="ln270">  list_delete_all_node (zvrf-&gt;rid_all_sorted_list);</a>
<a name="ln271">  list_delete_all_node (zvrf-&gt;rid_lo_sorted_list);</a>
<a name="ln272"> </a>
<a name="ln273">  return 0;</a>
<a name="ln274">}</a>
<a name="ln275"> </a>
<a name="ln276">/* Zebra VRF initialization. */</a>
<a name="ln277">static void</a>
<a name="ln278">zebra_vrf_init (void)</a>
<a name="ln279">{</a>
<a name="ln280">  vrf_add_hook (VRF_NEW_HOOK, zebra_vrf_new);</a>
<a name="ln281">  vrf_add_hook (VRF_ENABLE_HOOK, zebra_vrf_enable);</a>
<a name="ln282">  vrf_add_hook (VRF_DISABLE_HOOK, zebra_vrf_disable);</a>
<a name="ln283">  vrf_init ();</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">/* Main startup routine. */</a>
<a name="ln287">int</a>
<a name="ln288">main (int argc, char **argv)</a>
<a name="ln289">{</a>
<a name="ln290">  char *p;</a>
<a name="ln291">  char *vty_addr = NULL;</a>
<a name="ln292">  int vty_port = ZEBRA_VTY_PORT;</a>
<a name="ln293">  int dryrun = 0;</a>
<a name="ln294">  int batch_mode = 0;</a>
<a name="ln295">  int daemon_mode = 0;</a>
<a name="ln296">  char *config_file = NULL;</a>
<a name="ln297">  char *progname;</a>
<a name="ln298">  char *zserv_path = NULL;</a>
<a name="ln299">  char *fpm_format = NULL;</a>
<a name="ln300"> </a>
<a name="ln301">  /* Set umask before anything for security */</a>
<a name="ln302">  umask (0027);</a>
<a name="ln303"> </a>
<a name="ln304">  /* preserve my name */</a>
<a name="ln305">  progname = ((p = strrchr (argv[0], '/')) ? ++p : argv[0]);</a>
<a name="ln306"> </a>
<a name="ln307">  zlog_default = openzlog (progname, ZLOG_ZEBRA,</a>
<a name="ln308">			   LOG_CONS|LOG_NDELAY|LOG_PID, LOG_DAEMON);</a>
<a name="ln309"> </a>
<a name="ln310">  while (1) </a>
<a name="ln311">    {</a>
<a name="ln312">      int opt;</a>
<a name="ln313">  </a>
<a name="ln314">#ifdef HAVE_NETLINK  </a>
<a name="ln315">      opt = getopt_long (argc, argv, &quot;bdkf:F:i:z:hA:P:ru:g:vs:C&quot;, longopts, 0);</a>
<a name="ln316">#else</a>
<a name="ln317">      opt = getopt_long (argc, argv, &quot;bdkf:F:i:z:hA:P:ru:g:vC&quot;, longopts, 0);</a>
<a name="ln318">#endif /* HAVE_NETLINK */</a>
<a name="ln319"> </a>
<a name="ln320">      if (opt == EOF)</a>
<a name="ln321">	break;</a>
<a name="ln322"> </a>
<a name="ln323">      switch (opt) </a>
<a name="ln324">	{</a>
<a name="ln325">	case 0:</a>
<a name="ln326">	  break;</a>
<a name="ln327">	case 'b':</a>
<a name="ln328">	  batch_mode = 1;</a>
<a name="ln329">	case 'd':</a>
<a name="ln330">	  daemon_mode = 1;</a>
<a name="ln331">	  break;</a>
<a name="ln332">	case 'k':</a>
<a name="ln333">	  keep_kernel_mode = 1;</a>
<a name="ln334">	  break;</a>
<a name="ln335">	case 'C':</a>
<a name="ln336">	  dryrun = 1;</a>
<a name="ln337">	  break;</a>
<a name="ln338">	case 'f':</a>
<a name="ln339">	  config_file = optarg;</a>
<a name="ln340">	  break;</a>
<a name="ln341">	case 'F':</a>
<a name="ln342">	  fpm_format = optarg;</a>
<a name="ln343">	  break;</a>
<a name="ln344">	case 'A':</a>
<a name="ln345">	  vty_addr = optarg;</a>
<a name="ln346">	  break;</a>
<a name="ln347">        case 'i':</a>
<a name="ln348">          pid_file = optarg;</a>
<a name="ln349">          break;</a>
<a name="ln350">	case 'z':</a>
<a name="ln351">	  zserv_path = optarg;</a>
<a name="ln352">	  break;</a>
<a name="ln353">	case 'P':</a>
<a name="ln354">	  /* Deal with atoi() returning 0 on failure, and zebra not</a>
<a name="ln355">	     listening on zebra port... */</a>
<a name="ln356">	  if (strcmp(optarg, &quot;0&quot;) == 0) </a>
<a name="ln357">	    {</a>
<a name="ln358">	      vty_port = 0;</a>
<a name="ln359">	      break;</a>
<a name="ln360">	    } </a>
<a name="ln361">	  vty_port = atoi (optarg);</a>
<a name="ln362">	  if (vty_port &lt;= 0 || vty_port &gt; 0xffff)</a>
<a name="ln363">	    vty_port = ZEBRA_VTY_PORT;</a>
<a name="ln364">	  break;</a>
<a name="ln365">	case 'r':</a>
<a name="ln366">	  retain_mode = 1;</a>
<a name="ln367">	  break;</a>
<a name="ln368">#ifdef HAVE_NETLINK</a>
<a name="ln369">	case 's':</a>
<a name="ln370">	  nl_rcvbufsize = atoi (optarg);</a>
<a name="ln371">	  break;</a>
<a name="ln372">#endif /* HAVE_NETLINK */</a>
<a name="ln373">	case 'u':</a>
<a name="ln374">	  zserv_privs.user = optarg;</a>
<a name="ln375">	  break;</a>
<a name="ln376">	case 'g':</a>
<a name="ln377">	  zserv_privs.group = optarg;</a>
<a name="ln378">	  break;</a>
<a name="ln379">	case 'v':</a>
<a name="ln380">	  print_version (progname);</a>
<a name="ln381">	  exit (0);</a>
<a name="ln382">	  break;</a>
<a name="ln383">	case 'h':</a>
<a name="ln384">	  usage (progname, 0);</a>
<a name="ln385">	  break;</a>
<a name="ln386">	default:</a>
<a name="ln387">	  usage (progname, 1);</a>
<a name="ln388">	  break;</a>
<a name="ln389">	}</a>
<a name="ln390">    }</a>
<a name="ln391"> </a>
<a name="ln392">  /* Make master thread emulator. */</a>
<a name="ln393">  zebrad.master = thread_master_create ();</a>
<a name="ln394"> </a>
<a name="ln395">  /* privs initialise */</a>
<a name="ln396">  zprivs_init (&amp;zserv_privs);</a>
<a name="ln397"> </a>
<a name="ln398">  /* Vty related initialize. */</a>
<a name="ln399">  signal_init (zebrad.master, array_size(zebra_signals), zebra_signals);</a>
<a name="ln400">  cmd_init (1);</a>
<a name="ln401">  vty_init (zebrad.master);</a>
<a name="ln402">  memory_init ();</a>
<a name="ln403"> </a>
<a name="ln404">  /* Zebra related initialize. */</a>
<a name="ln405">  zebra_init ();</a>
<a name="ln406">  rib_init ();</a>
<a name="ln407">  zebra_if_init ();</a>
<a name="ln408">  zebra_debug_init ();</a>
<a name="ln409">  router_id_cmd_init ();</a>
<a name="ln410">  zebra_vty_init ();</a>
<a name="ln411">  access_list_init ();</a>
<a name="ln412">  prefix_list_init ();</a>
<a name="ln413">#if defined (HAVE_RTADV)</a>
<a name="ln414">  rtadv_cmd_init ();</a>
<a name="ln415">#endif</a>
<a name="ln416">#ifdef HAVE_IRDP</a>
<a name="ln417">  irdp_init();</a>
<a name="ln418">#endif</a>
<a name="ln419"> </a>
<a name="ln420">  /* For debug purpose. */</a>
<a name="ln421">  /* SET_FLAG (zebra_debug_event, ZEBRA_DEBUG_EVENT); */</a>
<a name="ln422"> </a>
<a name="ln423">  /* Initialize VRF module, and make kernel routing socket. */</a>
<a name="ln424">  zebra_vrf_init ();</a>
<a name="ln425"> </a>
<a name="ln426">#ifdef HAVE_SNMP</a>
<a name="ln427">  zebra_snmp_init ();</a>
<a name="ln428">#endif /* HAVE_SNMP */</a>
<a name="ln429"> </a>
<a name="ln430">#ifdef HAVE_FPM</a>
<a name="ln431">  zfpm_init (zebrad.master, 1, 0, fpm_format);</a>
<a name="ln432">#else</a>
<a name="ln433">  zfpm_init (zebrad.master, 0, 0, fpm_format);</a>
<a name="ln434">#endif</a>
<a name="ln435"> </a>
<a name="ln436">  /* Process the configuration file. Among other configuration</a>
<a name="ln437">  *  directives we can meet those installing static routes. Such</a>
<a name="ln438">  *  requests will not be executed immediately, but queued in</a>
<a name="ln439">  *  zebra-&gt;ribq structure until we enter the main execution loop.</a>
<a name="ln440">  *  The notifications from kernel will show originating PID equal</a>
<a name="ln441">  *  to that after daemon() completes (if ever called).</a>
<a name="ln442">  */</a>
<a name="ln443">  vty_read_config (config_file, config_default);</a>
<a name="ln444"> </a>
<a name="ln445">  /* Don't start execution if we are in dry-run mode */</a>
<a name="ln446">  if (dryrun)</a>
<a name="ln447">    return(0);</a>
<a name="ln448"> </a>
<a name="ln449">  /* Count up events for interfaces */</a>
<a name="ln450">  if_startup_count_up ();</a>
<a name="ln451"> </a>
<a name="ln452">  /* Clean up rib. */</a>
<a name="ln453">  rib_weed_tables ();</a>
<a name="ln454"> </a>
<a name="ln455">  /* Exit when zebra is working in batch mode. */</a>
<a name="ln456">  if (batch_mode)</a>
<a name="ln457">    exit (0);</a>
<a name="ln458"> </a>
<a name="ln459">  /* Daemonize. */</a>
<a name="ln460">  if (daemon_mode &amp;&amp; daemon (0, 0) &lt; 0)</a>
<a name="ln461">    {</a>
<a name="ln462">      zlog_err(&quot;Zebra daemon failed: %s&quot;, strerror(errno));</a>
<a name="ln463">      exit (1);</a>
<a name="ln464">    }</a>
<a name="ln465"> </a>
<a name="ln466">  /* Output pid of zebra. */</a>
<a name="ln467">  pid_output (pid_file);</a>
<a name="ln468"> </a>
<a name="ln469">  /* After we have successfully acquired the pidfile, we can be sure</a>
<a name="ln470">  *  about being the only copy of zebra process, which is submitting</a>
<a name="ln471">  *  changes to the FIB.</a>
<a name="ln472">  *  Clean up zebra-originated routes. The requests will be sent to OS</a>
<a name="ln473">  *  immediately, so originating PID in notifications from kernel</a>
<a name="ln474">  *  will be equal to the current getpid(). To know about such routes,</a>
<a name="ln475">  * we have to have route_read() called before.</a>
<a name="ln476">  */</a>
<a name="ln477">  if (! keep_kernel_mode)</a>
<a name="ln478">    rib_sweep_route ();</a>
<a name="ln479"> </a>
<a name="ln480">  /* Needed for BSD routing socket. */</a>
<a name="ln481">  pid = getpid ();</a>
<a name="ln482"> </a>
<a name="ln483">  /* This must be done only after locking pidfile (bug #403). */</a>
<a name="ln484">  zebra_zserv_socket_init (zserv_path);</a>
<a name="ln485"> </a>
<a name="ln486">  /* Make vty server socket. */</a>
<a name="ln487">  vty_serv_sock (vty_addr, vty_port, ZEBRA_VTYSH_PATH);</a>
<a name="ln488"> </a>
<a name="ln489">  /* Print banner. */</a>
<a name="ln490">  zlog_notice (&quot;Zebra %s starting: vty@%d&quot;, QUAGGA_VERSION, vty_port);</a>
<a name="ln491">  </a>
<a name="ln492">  thread_main (zebrad.master);</a>
<a name="ln493"> </a>
<a name="ln494">  return 0;</a>
<a name="ln495">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
