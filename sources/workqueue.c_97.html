
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>workqueue.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* </a>
<a name="ln2"> * Quagga Work Queue Support.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2005 Sun Microsystems, Inc.</a>
<a name="ln5"> *</a>
<a name="ln6"> * This file is part of GNU Zebra.</a>
<a name="ln7"> *</a>
<a name="ln8"> * Quagga is free software; you can redistribute it and/or modify it</a>
<a name="ln9"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln10"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln11"> * later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * Quagga is distributed in the hope that it will be useful, but</a>
<a name="ln14"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public License</a>
<a name="ln19"> * along with Quagga; see the file COPYING.  If not, write to the Free</a>
<a name="ln20"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln21"> * 02111-1307, USA.  </a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;memory.h&quot;</a>
<a name="ln27">#include &quot;workqueue.h&quot;</a>
<a name="ln28">#include &quot;linklist.h&quot;</a>
<a name="ln29">#include &quot;command.h&quot;</a>
<a name="ln30">#include &quot;log.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">/* master list of work_queues */</a>
<a name="ln33">static struct list _work_queues;</a>
<a name="ln34">/* pointer primarily to avoid an otherwise harmless warning on</a>
<a name="ln35"> * ALL_LIST_ELEMENTS_RO </a>
<a name="ln36"> */</a>
<a name="ln37">static struct list *work_queues = &amp;_work_queues;</a>
<a name="ln38"> </a>
<a name="ln39">#define WORK_QUEUE_MIN_GRANULARITY 1</a>
<a name="ln40"> </a>
<a name="ln41">static struct work_queue_item *</a>
<a name="ln42">work_queue_item_new (struct work_queue *wq)</a>
<a name="ln43">{</a>
<a name="ln44">  struct work_queue_item *item;</a>
<a name="ln45">  assert (wq);</a>
<a name="ln46"> </a>
<a name="ln47">  item = XCALLOC (MTYPE_WORK_QUEUE_ITEM, </a>
<a name="ln48">                  sizeof (struct work_queue_item));</a>
<a name="ln49">  </a>
<a name="ln50">  return item;</a>
<a name="ln51">}</a>
<a name="ln52"> </a>
<a name="ln53">static void</a>
<a name="ln54">work_queue_item_free (struct work_queue_item *item)</a>
<a name="ln55">{</a>
<a name="ln56">  XFREE (MTYPE_WORK_QUEUE_ITEM, item);</a>
<a name="ln57">  return;</a>
<a name="ln58">}</a>
<a name="ln59"> </a>
<a name="ln60">/* create new work queue */</a>
<a name="ln61">struct work_queue *</a>
<a name="ln62">work_queue_new (struct thread_master *m, const char *queue_name)</a>
<a name="ln63">{</a>
<a name="ln64">  struct work_queue *new;</a>
<a name="ln65">  </a>
<a name="ln66">  new = XCALLOC (MTYPE_WORK_QUEUE, sizeof (struct work_queue));</a>
<a name="ln67"> </a>
<a name="ln68">  if (new == NULL)</a>
<a name="ln69">    return new;</a>
<a name="ln70">  </a>
<a name="ln71">  new-&gt;name = XSTRDUP (MTYPE_WORK_QUEUE_NAME, queue_name);</a>
<a name="ln72">  new-&gt;master = m;</a>
<a name="ln73">  SET_FLAG (new-&gt;flags, WQ_UNPLUGGED);</a>
<a name="ln74">  </a>
<a name="ln75">  if ( (new-&gt;items = list_new ()) == NULL)</a>
<a name="ln76">    {</a>
<a name="ln77">      XFREE (MTYPE_WORK_QUEUE_NAME, new-&gt;name);</a>
<a name="ln78">      XFREE (MTYPE_WORK_QUEUE, new);</a>
<a name="ln79">      </a>
<a name="ln80">      return NULL;</a>
<a name="ln81">    }</a>
<a name="ln82">  </a>
<a name="ln83">  new-&gt;items-&gt;del = (void (*)(void *)) work_queue_item_free;  </a>
<a name="ln84">  </a>
<a name="ln85">  listnode_add (work_queues, new);</a>
<a name="ln86">  </a>
<a name="ln87">  new-&gt;cycles.granularity = WORK_QUEUE_MIN_GRANULARITY;</a>
<a name="ln88">  new-&gt;cycles.worst = UINT_MAX;</a>
<a name="ln89">  </a>
<a name="ln90">  /* Default values, can be overriden by caller */</a>
<a name="ln91">  new-&gt;spec.hold = WORK_QUEUE_DEFAULT_HOLD;</a>
<a name="ln92">    </a>
<a name="ln93">  return new;</a>
<a name="ln94">}</a>
<a name="ln95"> </a>
<a name="ln96">void</a>
<a name="ln97">work_queue_free (struct work_queue *wq)</a>
<a name="ln98">{</a>
<a name="ln99">  if (wq-&gt;thread != NULL)</a>
<a name="ln100">    thread_cancel(wq-&gt;thread);</a>
<a name="ln101">  </a>
<a name="ln102">  /* list_delete frees items via callback */</a>
<a name="ln103">  list_delete (wq-&gt;items);</a>
<a name="ln104">  listnode_delete (work_queues, wq);</a>
<a name="ln105">  </a>
<a name="ln106">  XFREE (MTYPE_WORK_QUEUE_NAME, wq-&gt;name);</a>
<a name="ln107">  XFREE (MTYPE_WORK_QUEUE, wq);</a>
<a name="ln108">  return;</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">bool</a>
<a name="ln112">work_queue_is_scheduled (struct work_queue *wq)</a>
<a name="ln113">{</a>
<a name="ln114">  return (wq-&gt;thread != NULL);</a>
<a name="ln115">}</a>
<a name="ln116"> </a>
<a name="ln117">static int</a>
<a name="ln118">work_queue_schedule (struct work_queue *wq, unsigned int delay)</a>
<a name="ln119">{</a>
<a name="ln120">  /* if appropriate, schedule work queue thread */</a>
<a name="ln121">  if ( CHECK_FLAG (wq-&gt;flags, WQ_UNPLUGGED)</a>
<a name="ln122">       &amp;&amp; (wq-&gt;thread == NULL)</a>
<a name="ln123">       &amp;&amp; (listcount (wq-&gt;items) &gt; 0) )</a>
<a name="ln124">    {</a>
<a name="ln125">      wq-&gt;thread = thread_add_background (wq-&gt;master, work_queue_run, </a>
<a name="ln126">                                          wq, delay);</a>
<a name="ln127">      return 1;</a>
<a name="ln128">    }</a>
<a name="ln129">  else</a>
<a name="ln130">    return 0;</a>
<a name="ln131">}</a>
<a name="ln132">  </a>
<a name="ln133">void</a>
<a name="ln134">work_queue_add (struct work_queue *wq, void *data)</a>
<a name="ln135">{</a>
<a name="ln136">  struct work_queue_item *item;</a>
<a name="ln137">  </a>
<a name="ln138">  assert (wq);</a>
<a name="ln139"> </a>
<a name="ln140">  if (!(item = work_queue_item_new (wq)))</a>
<a name="ln141">    {</a>
<a name="ln142">      zlog_err (&quot;%s: unable to get new queue item&quot;, __func__);</a>
<a name="ln143">      return;</a>
<a name="ln144">    }</a>
<a name="ln145">  </a>
<a name="ln146">  item-&gt;data = data;</a>
<a name="ln147">  listnode_add (wq-&gt;items, item);</a>
<a name="ln148">  </a>
<a name="ln149">  work_queue_schedule (wq, wq-&gt;spec.hold);</a>
<a name="ln150">  </a>
<a name="ln151">  return;</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">static void</a>
<a name="ln155">work_queue_item_remove (struct work_queue *wq, struct listnode *ln)</a>
<a name="ln156">{</a>
<a name="ln157">  struct work_queue_item *item = listgetdata (ln);</a>
<a name="ln158"> </a>
<a name="ln159">  assert (item &amp;&amp; item-&gt;data);</a>
<a name="ln160"> </a>
<a name="ln161">  /* call private data deletion callback if needed */  </a>
<a name="ln162">  if (wq-&gt;spec.del_item_data)</a>
<a name="ln163">    wq-&gt;spec.del_item_data (wq, item-&gt;data);</a>
<a name="ln164"> </a>
<a name="ln165">  list_delete_node (wq-&gt;items, ln);</a>
<a name="ln166">  work_queue_item_free (item);</a>
<a name="ln167">  </a>
<a name="ln168">  return;</a>
<a name="ln169">}</a>
<a name="ln170"> </a>
<a name="ln171">static void</a>
<a name="ln172">work_queue_item_requeue (struct work_queue *wq, struct listnode *ln)</a>
<a name="ln173">{</a>
<a name="ln174">  LISTNODE_DETACH (wq-&gt;items, ln);</a>
<a name="ln175">  LISTNODE_ATTACH (wq-&gt;items, ln); /* attach to end of list */</a>
<a name="ln176">}</a>
<a name="ln177"> </a>
<a name="ln178">DEFUN(show_work_queues,</a>
<a name="ln179">      show_work_queues_cmd,</a>
<a name="ln180">      &quot;show work-queues&quot;,</a>
<a name="ln181">      SHOW_STR</a>
<a name="ln182">      &quot;Work Queue information\n&quot;)</a>
<a name="ln183">{</a>
<a name="ln184">  struct listnode *node;</a>
<a name="ln185">  struct work_queue *wq;</a>
<a name="ln186">  </a>
<a name="ln187">  vty_out (vty, </a>
<a name="ln188">           &quot;%c %8s %5s %8s %21s %6s %5s%s&quot;,</a>
<a name="ln189">           ' ', &quot;List&quot;,&quot;(ms) &quot;,&quot;Q. Runs&quot;,&quot;Cycle Counts   &quot;,</a>
<a name="ln190">           &quot; &quot;,&quot;Worst&quot;,</a>
<a name="ln191">           VTY_NEWLINE);</a>
<a name="ln192">  vty_out (vty,</a>
<a name="ln193">           &quot;%c %8s %5s %8s %7s %6s %6s %6s %5s %s%s&quot;,</a>
<a name="ln194">           'P',</a>
<a name="ln195">           &quot;Items&quot;,</a>
<a name="ln196">           &quot;Hold&quot;,</a>
<a name="ln197">           &quot;Total&quot;,</a>
<a name="ln198">           &quot;Best&quot;,&quot;Worst&quot;,&quot;Gran.&quot;,&quot;Avg.&quot;, &quot;Lat.&quot;,</a>
<a name="ln199">           &quot;Name&quot;, </a>
<a name="ln200">           VTY_NEWLINE);</a>
<a name="ln201"> </a>
<a name="ln202">  for (ALL_LIST_ELEMENTS_RO (work_queues, node, wq))</a>
<a name="ln203">    {</a>
<a name="ln204">      vty_out (vty,&quot;%c %8u %5u %8lu %7u %6u %6u %6u %5lu %s%s&quot;,</a>
<a name="ln205">               (CHECK_FLAG (wq-&gt;flags, WQ_UNPLUGGED) ? ' ' : 'P'),</a>
<a name="ln206">               listcount (wq-&gt;items),</a>
<a name="ln207">               wq-&gt;spec.hold,</a>
<a name="ln208">               wq-&gt;runs,</a>
<a name="ln209">               wq-&gt;cycles.best, </a>
<a name="ln210">               MIN(wq-&gt;cycles.best, wq-&gt;cycles.worst),</a>
<a name="ln211">               wq-&gt;cycles.granularity,</a>
<a name="ln212">                 (wq-&gt;runs) ? </a>
<a name="ln213">                   (unsigned int) (wq-&gt;cycles.total / wq-&gt;runs) : 0,</a>
<a name="ln214">               wq-&gt;worst_usec,</a>
<a name="ln215">               wq-&gt;name,</a>
<a name="ln216">               VTY_NEWLINE);</a>
<a name="ln217">    }</a>
<a name="ln218">    </a>
<a name="ln219">  return CMD_SUCCESS;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">/* 'plug' a queue: Stop it from being scheduled,</a>
<a name="ln223"> * ie: prevent the queue from draining.</a>
<a name="ln224"> */</a>
<a name="ln225">void</a>
<a name="ln226">work_queue_plug (struct work_queue *wq)</a>
<a name="ln227">{</a>
<a name="ln228">  if (wq-&gt;thread)</a>
<a name="ln229">    thread_cancel (wq-&gt;thread);</a>
<a name="ln230">  </a>
<a name="ln231">  wq-&gt;thread = NULL;</a>
<a name="ln232">  </a>
<a name="ln233">  UNSET_FLAG (wq-&gt;flags, WQ_UNPLUGGED);</a>
<a name="ln234">}</a>
<a name="ln235"> </a>
<a name="ln236">/* unplug queue, schedule it again, if appropriate</a>
<a name="ln237"> * Ie: Allow the queue to be drained again</a>
<a name="ln238"> */</a>
<a name="ln239">void</a>
<a name="ln240">work_queue_unplug (struct work_queue *wq)</a>
<a name="ln241">{</a>
<a name="ln242">  SET_FLAG (wq-&gt;flags, WQ_UNPLUGGED);</a>
<a name="ln243"> </a>
<a name="ln244">  /* if thread isnt already waiting, add one */</a>
<a name="ln245">  work_queue_schedule (wq, wq-&gt;spec.hold);</a>
<a name="ln246">}</a>
<a name="ln247"> </a>
<a name="ln248">/* timer thread to process a work queue</a>
<a name="ln249"> * will reschedule itself if required,</a>
<a name="ln250"> * otherwise work_queue_item_add </a>
<a name="ln251"> */</a>
<a name="ln252">int</a>
<a name="ln253">work_queue_run (struct thread *thread)</a>
<a name="ln254">{</a>
<a name="ln255">  struct work_queue *wq;</a>
<a name="ln256">  struct work_queue_item *item;</a>
<a name="ln257">  unsigned long took;</a>
<a name="ln258">  wq_item_status ret;</a>
<a name="ln259">  unsigned int cycles = 0;</a>
<a name="ln260">  struct listnode *node, *nnode;</a>
<a name="ln261">  char yielded = 0;</a>
<a name="ln262"> </a>
<a name="ln263">  wq = THREAD_ARG (thread);</a>
<a name="ln264">  wq-&gt;thread = NULL;</a>
<a name="ln265"> </a>
<a name="ln266">  assert (wq &amp;&amp; wq-&gt;items);</a>
<a name="ln267"> </a>
<a name="ln268">  /* calculate cycle granularity:</a>
<a name="ln269">   * list iteration == 1 cycle</a>
<a name="ln270">   * granularity == # cycles between checks whether we should yield.</a>
<a name="ln271">   *</a>
<a name="ln272">   * granularity should be &gt; 0, and can increase slowly after each run to</a>
<a name="ln273">   * provide some hysteris, but not past cycles.best or 2*cycles.</a>
<a name="ln274">   *</a>
<a name="ln275">   * Best: starts low, can only increase</a>
<a name="ln276">   *</a>
<a name="ln277">   * Worst: starts at MAX, can only decrease.</a>
<a name="ln278">   *</a>
<a name="ln279">   * Granularity: starts at WORK_QUEUE_MIN_GRANULARITY, can be decreased </a>
<a name="ln280">   *              if we run to end of time slot, can increase otherwise </a>
<a name="ln281">   *              by a small factor.</a>
<a name="ln282">   *</a>
<a name="ln283">   * We could use just the average and save some work, however we want to be</a>
<a name="ln284">   * able to adjust quickly to CPU pressure. Average wont shift much if</a>
<a name="ln285">   * daemon has been running a long time.</a>
<a name="ln286">   */</a>
<a name="ln287">   if (wq-&gt;cycles.granularity == 0)</a>
<a name="ln288">     wq-&gt;cycles.granularity = WORK_QUEUE_MIN_GRANULARITY;</a>
<a name="ln289"> </a>
<a name="ln290">  for (ALL_LIST_ELEMENTS (wq-&gt;items, node, nnode, item))</a>
<a name="ln291">  {</a>
<a name="ln292">    assert (item &amp;&amp; item-&gt;data);</a>
<a name="ln293">    </a>
<a name="ln294">    /* dont run items which are past their allowed retries */</a>
<a name="ln295">    if (item-&gt;ran &gt; wq-&gt;spec.max_retries)</a>
<a name="ln296">      {</a>
<a name="ln297">        /* run error handler, if any */</a>
<a name="ln298">	if (wq-&gt;spec.errorfunc)</a>
<a name="ln299">	  wq-&gt;spec.errorfunc (wq, item-&gt;data);</a>
<a name="ln300">	work_queue_item_remove (wq, node);</a>
<a name="ln301">	continue;</a>
<a name="ln302">      }</a>
<a name="ln303"> </a>
<a name="ln304">    /* run and take care of items that want to be retried immediately */</a>
<a name="ln305">    do</a>
<a name="ln306">      {</a>
<a name="ln307">        ret = wq-&gt;spec.workfunc (wq, item-&gt;data);</a>
<a name="ln308">        item-&gt;ran++;</a>
<a name="ln309">      }</a>
<a name="ln310">    while ((ret == WQ_RETRY_NOW) </a>
<a name="ln311">           &amp;&amp; (item-&gt;ran &lt; wq-&gt;spec.max_retries));</a>
<a name="ln312"> </a>
<a name="ln313">    switch (ret)</a>
<a name="ln314">      {</a>
<a name="ln315">      case WQ_QUEUE_BLOCKED:</a>
<a name="ln316">        {</a>
<a name="ln317">          /* decrement item-&gt;ran again, cause this isn't an item</a>
<a name="ln318">           * specific error, and fall through to WQ_RETRY_LATER</a>
<a name="ln319">           */</a>
<a name="ln320">          item-&gt;ran--;</a>
<a name="ln321">        }</a>
<a name="ln322">      case WQ_RETRY_LATER:</a>
<a name="ln323">	{</a>
<a name="ln324">	  goto stats;</a>
<a name="ln325">	}</a>
<a name="ln326">      case WQ_REQUEUE:</a>
<a name="ln327">	{</a>
<a name="ln328">	  item-&gt;ran--;</a>
<a name="ln329">	  work_queue_item_requeue (wq, node);</a>
<a name="ln330">	  break;</a>
<a name="ln331">	}</a>
<a name="ln332">      case WQ_RETRY_NOW:</a>
<a name="ln333">        /* a RETRY_NOW that gets here has exceeded max_tries, same as ERROR */</a>
<a name="ln334">      case WQ_ERROR:</a>
<a name="ln335">	{</a>
<a name="ln336">	  if (wq-&gt;spec.errorfunc)</a>
<a name="ln337">	    wq-&gt;spec.errorfunc (wq, item);</a>
<a name="ln338">	}</a>
<a name="ln339">	/* fall through here is deliberate */</a>
<a name="ln340">      case WQ_SUCCESS:</a>
<a name="ln341">      default:</a>
<a name="ln342">	{</a>
<a name="ln343">	  work_queue_item_remove (wq, node);</a>
<a name="ln344">	  break;</a>
<a name="ln345">	}</a>
<a name="ln346">      }</a>
<a name="ln347"> </a>
<a name="ln348">    /* completed cycle */</a>
<a name="ln349">    cycles++;</a>
<a name="ln350"> </a>
<a name="ln351">    /* test if we should yield */</a>
<a name="ln352">    if ( !(cycles % wq-&gt;cycles.granularity) </a>
<a name="ln353">        &amp;&amp; (took = thread_should_yield (thread)))</a>
<a name="ln354">      {</a>
<a name="ln355">        yielded = 1;</a>
<a name="ln356">        goto stats;</a>
<a name="ln357">      }</a>
<a name="ln358">  }</a>
<a name="ln359"> </a>
<a name="ln360">stats:</a>
<a name="ln361"> </a>
<a name="ln362">#define WQ_HYSTERESIS_FACTOR 4</a>
<a name="ln363"> </a>
<a name="ln364">  if (cycles &gt; wq-&gt;cycles.best)</a>
<a name="ln365">    wq-&gt;cycles.best = cycles;</a>
<a name="ln366">  </a>
<a name="ln367">  if (took &gt; wq-&gt;worst_usec)</a>
<a name="ln368">    wq-&gt;worst_usec = took;</a>
<a name="ln369">    </a>
<a name="ln370">  /* we yielded, check whether granularity should be reduced */</a>
<a name="ln371">  if (yielded &amp;&amp; (cycles &lt; wq-&gt;cycles.granularity))</a>
<a name="ln372">    {</a>
<a name="ln373">      wq-&gt;cycles.granularity = ((cycles &gt; 0) ? cycles </a>
<a name="ln374">                                             : WORK_QUEUE_MIN_GRANULARITY);</a>
<a name="ln375">      if (cycles &lt; wq-&gt;cycles.worst)</a>
<a name="ln376">        wq-&gt;cycles.worst = cycles;</a>
<a name="ln377">    }</a>
<a name="ln378">  /* otherwise, should granularity increase? */</a>
<a name="ln379">  else if (cycles &gt;= (wq-&gt;cycles.granularity))</a>
<a name="ln380">    {</a>
<a name="ln381">      /* along with yielded check, provides hysteresis for granularity */      </a>
<a name="ln382">      if (cycles &gt; (wq-&gt;cycles.granularity * WQ_HYSTERESIS_FACTOR</a>
<a name="ln383">                                           * WQ_HYSTERESIS_FACTOR))</a>
<a name="ln384">        wq-&gt;cycles.granularity *= WQ_HYSTERESIS_FACTOR; /* quick ramp-up */</a>
<a name="ln385">      else if (cycles &gt; (wq-&gt;cycles.granularity * WQ_HYSTERESIS_FACTOR))</a>
<a name="ln386">        wq-&gt;cycles.granularity += WQ_HYSTERESIS_FACTOR;</a>
<a name="ln387">        </a>
<a name="ln388">      /* clamp granularity down to the worst yielded cycle count */</a>
<a name="ln389">      wq-&gt;cycles.granularity = MIN(wq-&gt;cycles.granularity, wq-&gt;cycles.worst);</a>
<a name="ln390">    }</a>
<a name="ln391">#undef WQ_HYSTERIS_FACTOR</a>
<a name="ln392">  </a>
<a name="ln393">  wq-&gt;runs++;</a>
<a name="ln394">  wq-&gt;cycles.total += cycles;</a>
<a name="ln395"> </a>
<a name="ln396">#if 0</a>
<a name="ln397">  printf (&quot;%s: cycles %d, new: best %d, worst %d\n&quot;,</a>
<a name="ln398">            __func__, cycles, wq-&gt;cycles.best, wq-&gt;cycles.granularity);</a>
<a name="ln399">#endif</a>
<a name="ln400">  </a>
<a name="ln401">  /* Is the queue done yet? If it is, call the completion callback. */</a>
<a name="ln402">  if (listcount (wq-&gt;items) &gt; 0)</a>
<a name="ln403">    work_queue_schedule (wq, 0);</a>
<a name="ln404">  else if (wq-&gt;spec.completion_func)</a>
<a name="ln405">    wq-&gt;spec.completion_func (wq);</a>
<a name="ln406">  </a>
<a name="ln407">  return 0;</a>
<a name="ln408">}</a>

</code></pre>
<div class="balloon" rel="9"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="264"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'wq' pointer was utilized before it was verified against nullptr. Check lines: 264, 266.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
