
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_community.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Community attribute related functions.</a>
<a name="ln2">   Copyright (C) 1998, 2001 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;hash.h&quot;</a>
<a name="ln24">#include &quot;memory.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;bgpd/bgp_community.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">/* Hash of community attribute. */</a>
<a name="ln29">static struct hash *comhash;</a>
<a name="ln30"> </a>
<a name="ln31">/* Allocate a new communities value.  */</a>
<a name="ln32">static struct community *</a>
<a name="ln33">community_new (void)</a>
<a name="ln34">{</a>
<a name="ln35">  return (struct community *) XCALLOC (MTYPE_COMMUNITY,</a>
<a name="ln36">				       sizeof (struct community));</a>
<a name="ln37">}</a>
<a name="ln38"> </a>
<a name="ln39">/* Free communities value.  */</a>
<a name="ln40">void</a>
<a name="ln41">community_free (struct community *com)</a>
<a name="ln42">{</a>
<a name="ln43">  if (com-&gt;val)</a>
<a name="ln44">    XFREE (MTYPE_COMMUNITY_VAL, com-&gt;val);</a>
<a name="ln45">  if (com-&gt;str)</a>
<a name="ln46">    XFREE (MTYPE_COMMUNITY_STR, com-&gt;str);</a>
<a name="ln47">  XFREE (MTYPE_COMMUNITY, com);</a>
<a name="ln48">}</a>
<a name="ln49"> </a>
<a name="ln50">/* Add one community value to the community. */</a>
<a name="ln51">static void</a>
<a name="ln52">community_add_val (struct community *com, u_int32_t val)</a>
<a name="ln53">{</a>
<a name="ln54">  com-&gt;size++;</a>
<a name="ln55">  if (com-&gt;val)</a>
<a name="ln56">    com-&gt;val = XREALLOC (MTYPE_COMMUNITY_VAL, com-&gt;val, com_length (com));</a>
<a name="ln57">  else</a>
<a name="ln58">    com-&gt;val = XMALLOC (MTYPE_COMMUNITY_VAL, com_length (com));</a>
<a name="ln59"> </a>
<a name="ln60">  val = htonl (val);</a>
<a name="ln61">  memcpy (com_lastval (com), &amp;val, sizeof (u_int32_t));</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">/* Delete one community. */</a>
<a name="ln65">void</a>
<a name="ln66">community_del_val (struct community *com, u_int32_t *val)</a>
<a name="ln67">{</a>
<a name="ln68">  int i = 0;</a>
<a name="ln69">  int c = 0;</a>
<a name="ln70"> </a>
<a name="ln71">  if (! com-&gt;val)</a>
<a name="ln72">    return;</a>
<a name="ln73"> </a>
<a name="ln74">  while (i &lt; com-&gt;size)</a>
<a name="ln75">    {</a>
<a name="ln76">      if (memcmp (com-&gt;val + i, val, sizeof (u_int32_t)) == 0)</a>
<a name="ln77">	{</a>
<a name="ln78">	  c = com-&gt;size -i -1;</a>
<a name="ln79"> </a>
<a name="ln80">	  if (c &gt; 0)</a>
<a name="ln81">	    memmove (com-&gt;val + i, com-&gt;val + (i + 1), c * sizeof (*val));</a>
<a name="ln82"> </a>
<a name="ln83">	  com-&gt;size--;</a>
<a name="ln84"> </a>
<a name="ln85">	  if (com-&gt;size &gt; 0)</a>
<a name="ln86">	    com-&gt;val = XREALLOC (MTYPE_COMMUNITY_VAL, com-&gt;val,</a>
<a name="ln87">				 com_length (com));</a>
<a name="ln88">	  else</a>
<a name="ln89">	    {</a>
<a name="ln90">	      XFREE (MTYPE_COMMUNITY_VAL, com-&gt;val);</a>
<a name="ln91">	      com-&gt;val = NULL;</a>
<a name="ln92">	    }</a>
<a name="ln93">	  return;</a>
<a name="ln94">	}</a>
<a name="ln95">      i++;</a>
<a name="ln96">    }</a>
<a name="ln97">}</a>
<a name="ln98"> </a>
<a name="ln99">/* Delete all communities listed in com2 from com1 */</a>
<a name="ln100">struct community *</a>
<a name="ln101">community_delete (struct community *com1, struct community *com2)</a>
<a name="ln102">{</a>
<a name="ln103">  int i = 0;</a>
<a name="ln104"> </a>
<a name="ln105">  while(i &lt; com2-&gt;size)</a>
<a name="ln106">    {</a>
<a name="ln107">      community_del_val (com1, com2-&gt;val + i);</a>
<a name="ln108">      i++;</a>
<a name="ln109">    }</a>
<a name="ln110"> </a>
<a name="ln111">  return com1;</a>
<a name="ln112">}</a>
<a name="ln113"> </a>
<a name="ln114">/* Callback function from qsort(). */</a>
<a name="ln115">static int</a>
<a name="ln116">community_compare (const void *a1, const void *a2)</a>
<a name="ln117">{</a>
<a name="ln118">  u_int32_t v1;</a>
<a name="ln119">  u_int32_t v2;</a>
<a name="ln120"> </a>
<a name="ln121">  memcpy (&amp;v1, a1, sizeof (u_int32_t));</a>
<a name="ln122">  memcpy (&amp;v2, a2, sizeof (u_int32_t));</a>
<a name="ln123">  v1 = ntohl (v1);</a>
<a name="ln124">  v2 = ntohl (v2);</a>
<a name="ln125"> </a>
<a name="ln126">  if (v1 &lt; v2)</a>
<a name="ln127">    return -1;</a>
<a name="ln128">  if (v1 &gt; v2)</a>
<a name="ln129">    return 1;</a>
<a name="ln130">  return 0;</a>
<a name="ln131">}</a>
<a name="ln132"> </a>
<a name="ln133">int</a>
<a name="ln134">community_include (struct community *com, u_int32_t val)</a>
<a name="ln135">{</a>
<a name="ln136">  int i;</a>
<a name="ln137"> </a>
<a name="ln138">  val = htonl (val);</a>
<a name="ln139"> </a>
<a name="ln140">  for (i = 0; i &lt; com-&gt;size; i++)</a>
<a name="ln141">    if (memcmp (&amp;val, com_nthval (com, i), sizeof (u_int32_t)) == 0)</a>
<a name="ln142">      return 1;</a>
<a name="ln143"> </a>
<a name="ln144">  return 0;</a>
<a name="ln145">}</a>
<a name="ln146"> </a>
<a name="ln147">u_int32_t</a>
<a name="ln148">community_val_get (struct community *com, int i)</a>
<a name="ln149">{</a>
<a name="ln150">  u_char *p;</a>
<a name="ln151">  u_int32_t val;</a>
<a name="ln152"> </a>
<a name="ln153">  p = (u_char *) com-&gt;val;</a>
<a name="ln154">  p += (i * 4);</a>
<a name="ln155"> </a>
<a name="ln156">  memcpy (&amp;val, p, sizeof (u_int32_t));</a>
<a name="ln157"> </a>
<a name="ln158">  return ntohl (val);</a>
<a name="ln159">}</a>
<a name="ln160"> </a>
<a name="ln161">/* Sort and uniq given community. */</a>
<a name="ln162">struct community *</a>
<a name="ln163">community_uniq_sort (struct community *com)</a>
<a name="ln164">{</a>
<a name="ln165">  int i;</a>
<a name="ln166">  struct community *new;</a>
<a name="ln167">  u_int32_t val;</a>
<a name="ln168"> </a>
<a name="ln169">  if (! com)</a>
<a name="ln170">    return NULL;</a>
<a name="ln171">  </a>
<a name="ln172">  new = community_new ();;</a>
<a name="ln173">  </a>
<a name="ln174">  for (i = 0; i &lt; com-&gt;size; i++)</a>
<a name="ln175">    {</a>
<a name="ln176">      val = community_val_get (com, i);</a>
<a name="ln177"> </a>
<a name="ln178">      if (! community_include (new, val))</a>
<a name="ln179">	community_add_val (new, val);</a>
<a name="ln180">    }</a>
<a name="ln181"> </a>
<a name="ln182">  qsort (new-&gt;val, new-&gt;size, sizeof (u_int32_t), community_compare);</a>
<a name="ln183"> </a>
<a name="ln184">  return new;</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">/* Convert communities attribute to string.</a>
<a name="ln188"> </a>
<a name="ln189">   For Well-known communities value, below keyword is used.</a>
<a name="ln190"> </a>
<a name="ln191">   0x0             &quot;internet&quot;    </a>
<a name="ln192">   0xFFFFFF01      &quot;no-export&quot;</a>
<a name="ln193">   0xFFFFFF02      &quot;no-advertise&quot;</a>
<a name="ln194">   0xFFFFFF03      &quot;local-AS&quot;</a>
<a name="ln195"> </a>
<a name="ln196">   For other values, &quot;AS:VAL&quot; format is used.  */</a>
<a name="ln197">static char *</a>
<a name="ln198">community_com2str  (struct community *com)</a>
<a name="ln199">{</a>
<a name="ln200">  int i;</a>
<a name="ln201">  char *str;</a>
<a name="ln202">  char *pnt;</a>
<a name="ln203">  int len;</a>
<a name="ln204">  int first;</a>
<a name="ln205">  u_int32_t comval;</a>
<a name="ln206">  u_int16_t as;</a>
<a name="ln207">  u_int16_t val;</a>
<a name="ln208"> </a>
<a name="ln209">  if (!com)</a>
<a name="ln210">    return NULL;</a>
<a name="ln211">  </a>
<a name="ln212">  /* When communities attribute is empty.  */</a>
<a name="ln213">  if (com-&gt;size == 0)</a>
<a name="ln214">    {</a>
<a name="ln215">      str = XMALLOC (MTYPE_COMMUNITY_STR, 1);</a>
<a name="ln216">      str[0] = '\0';</a>
<a name="ln217">      return str;</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">  /* Memory allocation is time consuming work.  So we calculate</a>
<a name="ln221">     required string length first.  */</a>
<a name="ln222">  len = 0;</a>
<a name="ln223"> </a>
<a name="ln224">  for (i = 0; i &lt; com-&gt;size; i++)</a>
<a name="ln225">    {</a>
<a name="ln226">      memcpy (&amp;comval, com_nthval (com, i), sizeof (u_int32_t));</a>
<a name="ln227">      comval = ntohl (comval);</a>
<a name="ln228"> </a>
<a name="ln229">      switch (comval) </a>
<a name="ln230">	{</a>
<a name="ln231">	case COMMUNITY_INTERNET:</a>
<a name="ln232">	  len += strlen (&quot; internet&quot;);</a>
<a name="ln233">	  break;</a>
<a name="ln234">	case COMMUNITY_NO_EXPORT:</a>
<a name="ln235">	  len += strlen (&quot; no-export&quot;);</a>
<a name="ln236">	  break;</a>
<a name="ln237">	case COMMUNITY_NO_ADVERTISE:</a>
<a name="ln238">	  len += strlen (&quot; no-advertise&quot;);</a>
<a name="ln239">	  break;</a>
<a name="ln240">	case COMMUNITY_LOCAL_AS:</a>
<a name="ln241">	  len += strlen (&quot; local-AS&quot;);</a>
<a name="ln242">	  break;</a>
<a name="ln243">	default:</a>
<a name="ln244">	  len += strlen (&quot; 65536:65535&quot;);</a>
<a name="ln245">	  break;</a>
<a name="ln246">	}</a>
<a name="ln247">    }</a>
<a name="ln248"> </a>
<a name="ln249">  /* Allocate memory.  */</a>
<a name="ln250">  str = pnt = XMALLOC (MTYPE_COMMUNITY_STR, len);</a>
<a name="ln251">  first = 1;</a>
<a name="ln252"> </a>
<a name="ln253">  /* Fill in string.  */</a>
<a name="ln254">  for (i = 0; i &lt; com-&gt;size; i++)</a>
<a name="ln255">    {</a>
<a name="ln256">      memcpy (&amp;comval, com_nthval (com, i), sizeof (u_int32_t));</a>
<a name="ln257">      comval = ntohl (comval);</a>
<a name="ln258"> </a>
<a name="ln259">      if (first)</a>
<a name="ln260">	first = 0;</a>
<a name="ln261">      else</a>
<a name="ln262">	*pnt++ = ' ';</a>
<a name="ln263"> </a>
<a name="ln264">      switch (comval) </a>
<a name="ln265">	{</a>
<a name="ln266">	case COMMUNITY_INTERNET:</a>
<a name="ln267">	  strcpy (pnt, &quot;internet&quot;);</a>
<a name="ln268">	  pnt += strlen (&quot;internet&quot;);</a>
<a name="ln269">	  break;</a>
<a name="ln270">	case COMMUNITY_NO_EXPORT:</a>
<a name="ln271">	  strcpy (pnt, &quot;no-export&quot;);</a>
<a name="ln272">	  pnt += strlen (&quot;no-export&quot;);</a>
<a name="ln273">	  break;</a>
<a name="ln274">	case COMMUNITY_NO_ADVERTISE:</a>
<a name="ln275">	  strcpy (pnt, &quot;no-advertise&quot;);</a>
<a name="ln276">	  pnt += strlen (&quot;no-advertise&quot;);</a>
<a name="ln277">	  break;</a>
<a name="ln278">	case COMMUNITY_LOCAL_AS:</a>
<a name="ln279">	  strcpy (pnt, &quot;local-AS&quot;);</a>
<a name="ln280">	  pnt += strlen (&quot;local-AS&quot;);</a>
<a name="ln281">	  break;</a>
<a name="ln282">	default:</a>
<a name="ln283">	  as = (comval &gt;&gt; 16) &amp; 0xFFFF;</a>
<a name="ln284">	  val = comval &amp; 0xFFFF;</a>
<a name="ln285">	  sprintf (pnt, &quot;%u:%d&quot;, as, val);</a>
<a name="ln286">	  pnt += strlen (pnt);</a>
<a name="ln287">	  break;</a>
<a name="ln288">	}</a>
<a name="ln289">    }</a>
<a name="ln290">  *pnt = '\0';</a>
<a name="ln291"> </a>
<a name="ln292">  return str;</a>
<a name="ln293">}</a>
<a name="ln294"> </a>
<a name="ln295">/* Intern communities attribute.  */</a>
<a name="ln296">struct community *</a>
<a name="ln297">community_intern (struct community *com)</a>
<a name="ln298">{</a>
<a name="ln299">  struct community *find;</a>
<a name="ln300"> </a>
<a name="ln301">  /* Assert this community structure is not interned. */</a>
<a name="ln302">  assert (com-&gt;refcnt == 0);</a>
<a name="ln303"> </a>
<a name="ln304">  /* Lookup community hash. */</a>
<a name="ln305">  find = (struct community *) hash_get (comhash, com, hash_alloc_intern);</a>
<a name="ln306"> </a>
<a name="ln307">  /* Arguemnt com is allocated temporary.  So when it is not used in</a>
<a name="ln308">     hash, it should be freed.  */</a>
<a name="ln309">  if (find != com)</a>
<a name="ln310">    community_free (com);</a>
<a name="ln311"> </a>
<a name="ln312">  /* Increment refrence counter.  */</a>
<a name="ln313">  find-&gt;refcnt++;</a>
<a name="ln314"> </a>
<a name="ln315">  /* Make string.  */</a>
<a name="ln316">  if (! find-&gt;str)</a>
<a name="ln317">    find-&gt;str = community_com2str (find);</a>
<a name="ln318"> </a>
<a name="ln319">  return find;</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">/* Free community attribute. */</a>
<a name="ln323">void</a>
<a name="ln324">community_unintern (struct community **com)</a>
<a name="ln325">{</a>
<a name="ln326">  struct community *ret;</a>
<a name="ln327"> </a>
<a name="ln328">  if ((*com)-&gt;refcnt)</a>
<a name="ln329">    (*com)-&gt;refcnt--;</a>
<a name="ln330"> </a>
<a name="ln331">  /* Pull off from hash.  */</a>
<a name="ln332">  if ((*com)-&gt;refcnt == 0)</a>
<a name="ln333">    {</a>
<a name="ln334">      /* Community value com must exist in hash. */</a>
<a name="ln335">      ret = (struct community *) hash_release (comhash, *com);</a>
<a name="ln336">      assert (ret != NULL);</a>
<a name="ln337"> </a>
<a name="ln338">      community_free (*com);</a>
<a name="ln339">      *com = NULL;</a>
<a name="ln340">    }</a>
<a name="ln341">}</a>
<a name="ln342"> </a>
<a name="ln343">/* Create new community attribute. */</a>
<a name="ln344">struct community *</a>
<a name="ln345">community_parse (u_int32_t *pnt, u_short length)</a>
<a name="ln346">{</a>
<a name="ln347">  struct community tmp;</a>
<a name="ln348">  struct community *new;</a>
<a name="ln349"> </a>
<a name="ln350">  /* If length is malformed return NULL. */</a>
<a name="ln351">  if (length % 4)</a>
<a name="ln352">    return NULL;</a>
<a name="ln353"> </a>
<a name="ln354">  /* Make temporary community for hash look up. */</a>
<a name="ln355">  tmp.size = length / 4;</a>
<a name="ln356">  tmp.val = pnt;</a>
<a name="ln357"> </a>
<a name="ln358">  new = community_uniq_sort (&amp;tmp);</a>
<a name="ln359"> </a>
<a name="ln360">  return community_intern (new);</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">struct community *</a>
<a name="ln364">community_dup (struct community *com)</a>
<a name="ln365">{</a>
<a name="ln366">  struct community *new;</a>
<a name="ln367"> </a>
<a name="ln368">  new = XCALLOC (MTYPE_COMMUNITY, sizeof (struct community));</a>
<a name="ln369">  new-&gt;size = com-&gt;size;</a>
<a name="ln370">  if (new-&gt;size)</a>
<a name="ln371">    {</a>
<a name="ln372">      new-&gt;val = XMALLOC (MTYPE_COMMUNITY_VAL, com-&gt;size * 4);</a>
<a name="ln373">      memcpy (new-&gt;val, com-&gt;val, com-&gt;size * 4);</a>
<a name="ln374">    }</a>
<a name="ln375">  else</a>
<a name="ln376">    new-&gt;val = NULL;</a>
<a name="ln377">  return new;</a>
<a name="ln378">}</a>
<a name="ln379"> </a>
<a name="ln380">/* Retrun string representation of communities attribute. */</a>
<a name="ln381">char *</a>
<a name="ln382">community_str (struct community *com)</a>
<a name="ln383">{</a>
<a name="ln384">  if (!com)</a>
<a name="ln385">    return NULL;</a>
<a name="ln386">  </a>
<a name="ln387">  if (! com-&gt;str)</a>
<a name="ln388">    com-&gt;str = community_com2str (com);</a>
<a name="ln389">  return com-&gt;str;</a>
<a name="ln390">}</a>
<a name="ln391"> </a>
<a name="ln392">/* Make hash value of community attribute. This function is used by</a>
<a name="ln393">   hash package.*/</a>
<a name="ln394">unsigned int</a>
<a name="ln395">community_hash_make (struct community *com)</a>
<a name="ln396">{</a>
<a name="ln397">  unsigned char *pnt = (unsigned char *)com-&gt;val;</a>
<a name="ln398">  int size = com-&gt;size * 4;</a>
<a name="ln399">  unsigned int key = 0;</a>
<a name="ln400">  int c;</a>
<a name="ln401"> </a>
<a name="ln402">  for (c = 0; c &lt; size; c += 4)</a>
<a name="ln403">    {</a>
<a name="ln404">      key += pnt[c];</a>
<a name="ln405">      key += pnt[c + 1];</a>
<a name="ln406">      key += pnt[c + 2];</a>
<a name="ln407">      key += pnt[c + 3];</a>
<a name="ln408">    }</a>
<a name="ln409"> </a>
<a name="ln410">  return key;</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">int</a>
<a name="ln414">community_match (const struct community *com1, const struct community *com2)</a>
<a name="ln415">{</a>
<a name="ln416">  int i = 0;</a>
<a name="ln417">  int j = 0;</a>
<a name="ln418"> </a>
<a name="ln419">  if (com1 == NULL &amp;&amp; com2 == NULL)</a>
<a name="ln420">    return 1;</a>
<a name="ln421"> </a>
<a name="ln422">  if (com1 == NULL || com2 == NULL)</a>
<a name="ln423">    return 0;</a>
<a name="ln424"> </a>
<a name="ln425">  if (com1-&gt;size &lt; com2-&gt;size)</a>
<a name="ln426">    return 0;</a>
<a name="ln427"> </a>
<a name="ln428">  /* Every community on com2 needs to be on com1 for this to match */</a>
<a name="ln429">  while (i &lt; com1-&gt;size &amp;&amp; j &lt; com2-&gt;size)</a>
<a name="ln430">    {</a>
<a name="ln431">      if (memcmp (com1-&gt;val + i, com2-&gt;val + j, sizeof (u_int32_t)) == 0)</a>
<a name="ln432">	j++;</a>
<a name="ln433">      i++;</a>
<a name="ln434">    }</a>
<a name="ln435"> </a>
<a name="ln436">  if (j == com2-&gt;size)</a>
<a name="ln437">    return 1;</a>
<a name="ln438">  else</a>
<a name="ln439">    return 0;</a>
<a name="ln440">}</a>
<a name="ln441"> </a>
<a name="ln442">/* If two aspath have same value then return 1 else return 0. This</a>
<a name="ln443">   function is used by hash package. */</a>
<a name="ln444">int</a>
<a name="ln445">community_cmp (const struct community *com1, const struct community *com2)</a>
<a name="ln446">{</a>
<a name="ln447">  if (com1 == NULL &amp;&amp; com2 == NULL)</a>
<a name="ln448">    return 1;</a>
<a name="ln449">  if (com1 == NULL || com2 == NULL)</a>
<a name="ln450">    return 0;</a>
<a name="ln451"> </a>
<a name="ln452">  if (com1-&gt;size == com2-&gt;size)</a>
<a name="ln453">    if (memcmp (com1-&gt;val, com2-&gt;val, com1-&gt;size * 4) == 0)</a>
<a name="ln454">      return 1;</a>
<a name="ln455">  return 0;</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">/* Add com2 to the end of com1. */</a>
<a name="ln459">struct community *</a>
<a name="ln460">community_merge (struct community *com1, struct community *com2)</a>
<a name="ln461">{</a>
<a name="ln462">  if (com1-&gt;val)</a>
<a name="ln463">    com1-&gt;val = XREALLOC (MTYPE_COMMUNITY_VAL, com1-&gt;val, </a>
<a name="ln464">			  (com1-&gt;size + com2-&gt;size) * 4);</a>
<a name="ln465">  else</a>
<a name="ln466">    com1-&gt;val = XMALLOC (MTYPE_COMMUNITY_VAL, (com1-&gt;size + com2-&gt;size) * 4);</a>
<a name="ln467"> </a>
<a name="ln468">  memcpy (com1-&gt;val + com1-&gt;size, com2-&gt;val, com2-&gt;size * 4);</a>
<a name="ln469">  com1-&gt;size += com2-&gt;size;</a>
<a name="ln470"> </a>
<a name="ln471">  return com1;</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">/* Community token enum. */</a>
<a name="ln475">enum community_token</a>
<a name="ln476">{</a>
<a name="ln477">  community_token_val,</a>
<a name="ln478">  community_token_no_export,</a>
<a name="ln479">  community_token_no_advertise,</a>
<a name="ln480">  community_token_local_as,</a>
<a name="ln481">  community_token_unknown</a>
<a name="ln482">};</a>
<a name="ln483"> </a>
<a name="ln484">/* Get next community token from string. */</a>
<a name="ln485">static const char *</a>
<a name="ln486">community_gettoken (const char *buf, enum community_token *token, </a>
<a name="ln487">                    u_int32_t *val)</a>
<a name="ln488">{</a>
<a name="ln489">  const char *p = buf;</a>
<a name="ln490"> </a>
<a name="ln491">  /* Skip white space. */</a>
<a name="ln492">  while (isspace ((int) *p))</a>
<a name="ln493">    p++;</a>
<a name="ln494"> </a>
<a name="ln495">  /* Check the end of the line. */</a>
<a name="ln496">  if (*p == '\0')</a>
<a name="ln497">    return NULL;</a>
<a name="ln498"> </a>
<a name="ln499">  /* Well known community string check. */</a>
<a name="ln500">  if (isalpha ((int) *p)) </a>
<a name="ln501">    {</a>
<a name="ln502">      if (strncmp (p, &quot;internet&quot;, strlen (&quot;internet&quot;)) == 0)</a>
<a name="ln503">	{</a>
<a name="ln504">	  *val = COMMUNITY_INTERNET;</a>
<a name="ln505">	  *token = community_token_no_export;</a>
<a name="ln506">	  p += strlen (&quot;internet&quot;);</a>
<a name="ln507">	  return p;</a>
<a name="ln508">	}</a>
<a name="ln509">      if (strncmp (p, &quot;no-export&quot;, strlen (&quot;no-export&quot;)) == 0)</a>
<a name="ln510">	{</a>
<a name="ln511">	  *val = COMMUNITY_NO_EXPORT;</a>
<a name="ln512">	  *token = community_token_no_export;</a>
<a name="ln513">	  p += strlen (&quot;no-export&quot;);</a>
<a name="ln514">	  return p;</a>
<a name="ln515">	}</a>
<a name="ln516">      if (strncmp (p, &quot;no-advertise&quot;, strlen (&quot;no-advertise&quot;)) == 0)</a>
<a name="ln517">	{</a>
<a name="ln518">	  *val = COMMUNITY_NO_ADVERTISE;</a>
<a name="ln519">	  *token = community_token_no_advertise;</a>
<a name="ln520">	  p += strlen (&quot;no-advertise&quot;);</a>
<a name="ln521">	  return p;</a>
<a name="ln522">	}</a>
<a name="ln523">      if (strncmp (p, &quot;local-AS&quot;, strlen (&quot;local-AS&quot;)) == 0)</a>
<a name="ln524">	{</a>
<a name="ln525">	  *val = COMMUNITY_LOCAL_AS;</a>
<a name="ln526">	  *token = community_token_local_as;</a>
<a name="ln527">	  p += strlen (&quot;local-AS&quot;);</a>
<a name="ln528">	  return p;</a>
<a name="ln529">	}</a>
<a name="ln530"> </a>
<a name="ln531">      /* Unknown string. */</a>
<a name="ln532">      *token = community_token_unknown;</a>
<a name="ln533">      return NULL;</a>
<a name="ln534">    }</a>
<a name="ln535"> </a>
<a name="ln536">  /* Community value. */</a>
<a name="ln537">  if (isdigit ((int) *p)) </a>
<a name="ln538">    {</a>
<a name="ln539">      int separator = 0;</a>
<a name="ln540">      int digit = 0;</a>
<a name="ln541">      u_int32_t community_low = 0;</a>
<a name="ln542">      u_int32_t community_high = 0;</a>
<a name="ln543"> </a>
<a name="ln544">      while (isdigit ((int) *p) || *p == ':') </a>
<a name="ln545">	{</a>
<a name="ln546">	  if (*p == ':') </a>
<a name="ln547">	    {</a>
<a name="ln548">	      if (separator)</a>
<a name="ln549">		{</a>
<a name="ln550">		  *token = community_token_unknown;</a>
<a name="ln551">		  return NULL;</a>
<a name="ln552">		}</a>
<a name="ln553">	      else</a>
<a name="ln554">		{</a>
<a name="ln555">		  separator = 1;</a>
<a name="ln556">		  digit = 0;</a>
<a name="ln557">		  community_high = community_low &lt;&lt; 16;</a>
<a name="ln558">		  community_low = 0;</a>
<a name="ln559">		}</a>
<a name="ln560">	    }</a>
<a name="ln561">	  else </a>
<a name="ln562">	    {</a>
<a name="ln563">	      digit = 1;</a>
<a name="ln564">	      community_low *= 10;</a>
<a name="ln565">	      community_low += (*p - '0');</a>
<a name="ln566">	    }</a>
<a name="ln567">	  p++;</a>
<a name="ln568">	}</a>
<a name="ln569">      if (! digit)</a>
<a name="ln570">	{</a>
<a name="ln571">	  *token = community_token_unknown;</a>
<a name="ln572">	  return NULL;</a>
<a name="ln573">	}</a>
<a name="ln574">      *val = community_high + community_low;</a>
<a name="ln575">      *token = community_token_val;</a>
<a name="ln576">      return p;</a>
<a name="ln577">    }</a>
<a name="ln578">  *token = community_token_unknown;</a>
<a name="ln579">  return NULL;</a>
<a name="ln580">}</a>
<a name="ln581"> </a>
<a name="ln582">/* convert string to community structure */</a>
<a name="ln583">struct community *</a>
<a name="ln584">community_str2com (const char *str)</a>
<a name="ln585">{</a>
<a name="ln586">  struct community *com = NULL;</a>
<a name="ln587">  struct community *com_sort = NULL;</a>
<a name="ln588">  u_int32_t val = 0;</a>
<a name="ln589">  enum community_token token = community_token_unknown;</a>
<a name="ln590"> </a>
<a name="ln591">  do </a>
<a name="ln592">    {</a>
<a name="ln593">      str = community_gettoken (str, &amp;token, &amp;val);</a>
<a name="ln594">      </a>
<a name="ln595">      switch (token)</a>
<a name="ln596">	{</a>
<a name="ln597">	case community_token_val:</a>
<a name="ln598">	case community_token_no_export:</a>
<a name="ln599">	case community_token_no_advertise:</a>
<a name="ln600">	case community_token_local_as:</a>
<a name="ln601">	  if (com == NULL)</a>
<a name="ln602">	    com = community_new();</a>
<a name="ln603">	  community_add_val (com, val);</a>
<a name="ln604">	  break;</a>
<a name="ln605">	case community_token_unknown:</a>
<a name="ln606">	default:</a>
<a name="ln607">	  if (com)</a>
<a name="ln608">	    community_free (com);</a>
<a name="ln609">	  return NULL;</a>
<a name="ln610">	}</a>
<a name="ln611">    } while (str);</a>
<a name="ln612">  </a>
<a name="ln613">  if (! com)</a>
<a name="ln614">    return NULL;</a>
<a name="ln615"> </a>
<a name="ln616">  com_sort = community_uniq_sort (com);</a>
<a name="ln617">  community_free (com);</a>
<a name="ln618"> </a>
<a name="ln619">  return com_sort;</a>
<a name="ln620">}</a>
<a name="ln621"> </a>
<a name="ln622">/* Return communities hash entry count.  */</a>
<a name="ln623">unsigned long</a>
<a name="ln624">community_count (void)</a>
<a name="ln625">{</a>
<a name="ln626">  return comhash-&gt;count;</a>
<a name="ln627">}</a>
<a name="ln628"> </a>
<a name="ln629">/* Return communities hash.  */</a>
<a name="ln630">struct hash *</a>
<a name="ln631">community_hash (void)</a>
<a name="ln632">{</a>
<a name="ln633">  return comhash;</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">/* Initialize comminity related hash. */</a>
<a name="ln637">void</a>
<a name="ln638">community_init (void)</a>
<a name="ln639">{</a>
<a name="ln640">  comhash = hash_create ((unsigned int (*) (void *))community_hash_make,</a>
<a name="ln641">			 (int (*) (const void *, const void *))community_cmp);</a>
<a name="ln642">}</a>
<a name="ln643"> </a>
<a name="ln644">void</a>
<a name="ln645">community_finish (void)</a>
<a name="ln646">{</a>
<a name="ln647">  hash_free (comhash);</a>
<a name="ln648">  comhash = NULL;</a>
<a name="ln649">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
