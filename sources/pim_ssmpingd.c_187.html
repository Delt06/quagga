
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pim_ssmpingd.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2">  PIM for Quagga</a>
<a name="ln3">  Copyright (C) 2008  Everton da Silva Marques</a>
<a name="ln4"> </a>
<a name="ln5">  This program is free software; you can redistribute it and/or modify</a>
<a name="ln6">  it under the terms of the GNU General Public License as published by</a>
<a name="ln7">  the Free Software Foundation; either version 2 of the License, or</a>
<a name="ln8">  (at your option) any later version.</a>
<a name="ln9"> </a>
<a name="ln10">  This program is distributed in the hope that it will be useful, but</a>
<a name="ln11">  WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13">  General Public License for more details.</a>
<a name="ln14">  </a>
<a name="ln15">  You should have received a copy of the GNU General Public License</a>
<a name="ln16">  along with this program; see the file COPYING; if not, write to the</a>
<a name="ln17">  Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,</a>
<a name="ln18">  MA 02110-1301 USA</a>
<a name="ln19">  </a>
<a name="ln20">  $QuaggaId: $Format:%an, %ai, %h$ $</a>
<a name="ln21">*/</a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;zebra.h&gt;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;if.h&quot;</a>
<a name="ln26">#include &quot;log.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;pim_ssmpingd.h&quot;</a>
<a name="ln30">#include &quot;pim_time.h&quot;</a>
<a name="ln31">#include &quot;pim_sock.h&quot;</a>
<a name="ln32">#include &quot;pim_str.h&quot;</a>
<a name="ln33">#include &quot;pimd.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">static const char * const PIM_SSMPINGD_REPLY_GROUP = &quot;232.43.211.234&quot;;</a>
<a name="ln36"> </a>
<a name="ln37">enum {</a>
<a name="ln38">  PIM_SSMPINGD_REQUEST = 'Q',</a>
<a name="ln39">  PIM_SSMPINGD_REPLY   = 'A'</a>
<a name="ln40">};</a>
<a name="ln41"> </a>
<a name="ln42">static void ssmpingd_read_on(struct ssmpingd_sock *ss);</a>
<a name="ln43"> </a>
<a name="ln44">void pim_ssmpingd_init()</a>
<a name="ln45">{</a>
<a name="ln46">  int result;</a>
<a name="ln47"> </a>
<a name="ln48">  zassert(!qpim_ssmpingd_list);</a>
<a name="ln49"> </a>
<a name="ln50">  result = inet_pton(AF_INET, PIM_SSMPINGD_REPLY_GROUP, &amp;qpim_ssmpingd_group_addr);</a>
<a name="ln51">  </a>
<a name="ln52">  zassert(result &gt; 0);</a>
<a name="ln53">}</a>
<a name="ln54"> </a>
<a name="ln55">void pim_ssmpingd_destroy()</a>
<a name="ln56">{</a>
<a name="ln57">  if (qpim_ssmpingd_list) {</a>
<a name="ln58">    list_free(qpim_ssmpingd_list);</a>
<a name="ln59">    qpim_ssmpingd_list = 0;</a>
<a name="ln60">  }</a>
<a name="ln61">}</a>
<a name="ln62"> </a>
<a name="ln63">static struct ssmpingd_sock *ssmpingd_find(struct in_addr source_addr)</a>
<a name="ln64">{</a>
<a name="ln65">  struct listnode      *node;</a>
<a name="ln66">  struct ssmpingd_sock *ss;</a>
<a name="ln67"> </a>
<a name="ln68">  if (!qpim_ssmpingd_list)</a>
<a name="ln69">    return 0;</a>
<a name="ln70"> </a>
<a name="ln71">  for (ALL_LIST_ELEMENTS_RO(qpim_ssmpingd_list, node, ss))</a>
<a name="ln72">    if (source_addr.s_addr == ss-&gt;source_addr.s_addr)</a>
<a name="ln73">      return ss;</a>
<a name="ln74"> </a>
<a name="ln75">  return 0;</a>
<a name="ln76">}</a>
<a name="ln77"> </a>
<a name="ln78">static void ssmpingd_free(struct ssmpingd_sock *ss)</a>
<a name="ln79">{</a>
<a name="ln80">  XFREE(MTYPE_PIM_SSMPINGD, ss);</a>
<a name="ln81">}</a>
<a name="ln82"> </a>
<a name="ln83">static int ssmpingd_socket(struct in_addr addr, int port, int mttl)</a>
<a name="ln84">{</a>
<a name="ln85">  struct sockaddr_in sockaddr;</a>
<a name="ln86">  int fd;</a>
<a name="ln87"> </a>
<a name="ln88">  fd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</a>
<a name="ln89">  if (fd &lt; 0) {</a>
<a name="ln90">    zlog_err(&quot;%s: could not create socket: errno=%d: %s&quot;,</a>
<a name="ln91">	     __PRETTY_FUNCTION__, errno, safe_strerror(errno));</a>
<a name="ln92">    return -1;</a>
<a name="ln93">  }</a>
<a name="ln94"> </a>
<a name="ln95">  sockaddr.sin_family = AF_INET;</a>
<a name="ln96">  sockaddr.sin_addr   = addr;</a>
<a name="ln97">  sockaddr.sin_port   = htons(port);</a>
<a name="ln98"> </a>
<a name="ln99">  if (bind(fd, (struct sockaddr *)&amp;sockaddr, sizeof(sockaddr))) {</a>
<a name="ln100">    char addr_str[100];</a>
<a name="ln101">    pim_inet4_dump(&quot;&lt;addr?&gt;&quot;, addr, addr_str, sizeof(addr_str));</a>
<a name="ln102">    zlog_warn(&quot;%s: bind(fd=%d,addr=%s,port=%d,len=%zu) failure: errno=%d: %s&quot;,</a>
<a name="ln103">	      __PRETTY_FUNCTION__,</a>
<a name="ln104">	      fd, addr_str, port, sizeof(sockaddr),</a>
<a name="ln105">	      errno, safe_strerror(errno));</a>
<a name="ln106">    close(fd);</a>
<a name="ln107">    return -1;</a>
<a name="ln108">  }</a>
<a name="ln109"> </a>
<a name="ln110">  /* Needed to obtain destination address from recvmsg() */</a>
<a name="ln111">  {</a>
<a name="ln112">#if defined(HAVE_IP_PKTINFO)</a>
<a name="ln113">    /* Linux and Solaris IP_PKTINFO */</a>
<a name="ln114">    int opt = 1;</a>
<a name="ln115">    if (setsockopt(fd, IPPROTO_IP, IP_PKTINFO, &amp;opt, sizeof(opt))) {</a>
<a name="ln116">      zlog_warn(&quot;%s: could not set IP_PKTINFO on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln117">		__PRETTY_FUNCTION__, fd, errno, safe_strerror(errno));</a>
<a name="ln118">    }</a>
<a name="ln119">#elif defined(HAVE_IP_RECVDSTADDR)</a>
<a name="ln120">    /* BSD IP_RECVDSTADDR */</a>
<a name="ln121">    int opt = 1;</a>
<a name="ln122">    if (setsockopt(fd, IPPROTO_IP, IP_RECVDSTADDR, &amp;opt, sizeof(opt))) {</a>
<a name="ln123">      zlog_warn(&quot;%s: could not set IP_RECVDSTADDR on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln124">		__PRETTY_FUNCTION__, fd, errno, safe_strerror(errno));</a>
<a name="ln125">    }</a>
<a name="ln126">#else</a>
<a name="ln127">    zlog_err(&quot;%s %s: missing IP_PKTINFO and IP_RECVDSTADDR: unable to get dst addr from recvmsg()&quot;,</a>
<a name="ln128">	     __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln129">    close(fd);</a>
<a name="ln130">    return -1;</a>
<a name="ln131">#endif</a>
<a name="ln132">  }</a>
<a name="ln133">  </a>
<a name="ln134">  {</a>
<a name="ln135">    int reuse = 1;</a>
<a name="ln136">    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR,</a>
<a name="ln137">		   (void *) &amp;reuse, sizeof(reuse))) {</a>
<a name="ln138">      zlog_warn(&quot;%s: could not set Reuse Address Option on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln139">		__PRETTY_FUNCTION__, fd, errno, safe_strerror(errno));</a>
<a name="ln140">      close(fd);</a>
<a name="ln141">      return -1;</a>
<a name="ln142">    }</a>
<a name="ln143">  }</a>
<a name="ln144"> </a>
<a name="ln145">  if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_TTL,</a>
<a name="ln146">		 (void *) &amp;mttl, sizeof(mttl))) {</a>
<a name="ln147">    zlog_warn(&quot;%s: could not set multicast TTL=%d on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln148">	      __PRETTY_FUNCTION__, mttl, fd, errno, safe_strerror(errno));</a>
<a name="ln149">    close(fd);</a>
<a name="ln150">    return -1;</a>
<a name="ln151">  }</a>
<a name="ln152"> </a>
<a name="ln153">  {</a>
<a name="ln154">    int loop = 0;</a>
<a name="ln155">    if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_LOOP,</a>
<a name="ln156">		   (void *) &amp;loop, sizeof(loop))) {</a>
<a name="ln157">      zlog_warn(&quot;%s: could not %s Multicast Loopback Option on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln158">		__PRETTY_FUNCTION__,</a>
<a name="ln159">		loop ? &quot;enable&quot; : &quot;disable&quot;,</a>
<a name="ln160">		fd, errno, safe_strerror(errno));</a>
<a name="ln161">      close(fd);</a>
<a name="ln162">      return PIM_SOCK_ERR_LOOP;</a>
<a name="ln163">    }</a>
<a name="ln164">  }</a>
<a name="ln165"> </a>
<a name="ln166">  if (setsockopt(fd, IPPROTO_IP, IP_MULTICAST_IF,</a>
<a name="ln167">		 (void *) &amp;addr, sizeof(addr))) {</a>
<a name="ln168">    zlog_warn(&quot;%s: could not set Outgoing Interface Option on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln169">	      __PRETTY_FUNCTION__, fd, errno, safe_strerror(errno));</a>
<a name="ln170">    close(fd);</a>
<a name="ln171">    return -1;</a>
<a name="ln172">  }</a>
<a name="ln173"> </a>
<a name="ln174">  {</a>
<a name="ln175">    long flags;</a>
<a name="ln176"> </a>
<a name="ln177">    flags = fcntl(fd, F_GETFL, 0);</a>
<a name="ln178">    if (flags &lt; 0) {</a>
<a name="ln179">      zlog_warn(&quot;%s: could not get fcntl(F_GETFL,O_NONBLOCK) on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln180">		__PRETTY_FUNCTION__, fd, errno, safe_strerror(errno));</a>
<a name="ln181">      close(fd);</a>
<a name="ln182">      return -1;</a>
<a name="ln183">    }</a>
<a name="ln184"> </a>
<a name="ln185">    if (fcntl(fd, F_SETFL, flags | O_NONBLOCK)) {</a>
<a name="ln186">      zlog_warn(&quot;%s: could not set fcntl(F_SETFL,O_NONBLOCK) on socket fd=%d: errno=%d: %s&quot;,</a>
<a name="ln187">		__PRETTY_FUNCTION__, fd, errno, safe_strerror(errno));</a>
<a name="ln188">      close(fd);</a>
<a name="ln189">      return -1;</a>
<a name="ln190">    }</a>
<a name="ln191">  }</a>
<a name="ln192"> </a>
<a name="ln193">  return fd;</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196">static void ssmpingd_delete(struct ssmpingd_sock *ss)</a>
<a name="ln197">{</a>
<a name="ln198">  zassert(ss);</a>
<a name="ln199">  zassert(qpim_ssmpingd_list);</a>
<a name="ln200"> </a>
<a name="ln201">  THREAD_OFF(ss-&gt;t_sock_read);</a>
<a name="ln202"> </a>
<a name="ln203">  if (close(ss-&gt;sock_fd)) {</a>
<a name="ln204">    int e = errno;</a>
<a name="ln205">    char source_str[100];</a>
<a name="ln206">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ss-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln207">    zlog_warn(&quot;%s: failure closing ssmpingd sock_fd=%d for source %s: errno=%d: %s&quot;,</a>
<a name="ln208">	      __PRETTY_FUNCTION__,</a>
<a name="ln209">	      ss-&gt;sock_fd, source_str, e, safe_strerror(e));</a>
<a name="ln210">    /* warning only */</a>
<a name="ln211">  }</a>
<a name="ln212"> </a>
<a name="ln213">  listnode_delete(qpim_ssmpingd_list, ss);</a>
<a name="ln214">  ssmpingd_free(ss);</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">static void ssmpingd_sendto(struct ssmpingd_sock *ss,</a>
<a name="ln218">			    const uint8_t *buf,</a>
<a name="ln219">			    int len,</a>
<a name="ln220">			    struct sockaddr_in to)</a>
<a name="ln221">{</a>
<a name="ln222">  socklen_t tolen = sizeof(to);</a>
<a name="ln223">  int sent;</a>
<a name="ln224"> </a>
<a name="ln225">  sent = sendto(ss-&gt;sock_fd, buf, len, MSG_DONTWAIT,</a>
<a name="ln226">                (struct sockaddr *)&amp;to, tolen);</a>
<a name="ln227">  if (sent != len) {</a>
<a name="ln228">    int e = errno;</a>
<a name="ln229">    char to_str[100];</a>
<a name="ln230">    pim_inet4_dump(&quot;&lt;to?&gt;&quot;, to.sin_addr, to_str, sizeof(to_str));</a>
<a name="ln231">    if (sent &lt; 0) {</a>
<a name="ln232">      zlog_warn(&quot;%s: sendto() failure to %s,%d: fd=%d len=%d: errno=%d: %s&quot;,</a>
<a name="ln233">		__PRETTY_FUNCTION__,</a>
<a name="ln234">		to_str, ntohs(to.sin_port), ss-&gt;sock_fd, len,</a>
<a name="ln235">		e, safe_strerror(e));</a>
<a name="ln236">    }</a>
<a name="ln237">    else {</a>
<a name="ln238">      zlog_warn(&quot;%s: sendto() partial to %s,%d: fd=%d len=%d: sent=%d&quot;,</a>
<a name="ln239">		__PRETTY_FUNCTION__,</a>
<a name="ln240">		to_str, ntohs(to.sin_port), ss-&gt;sock_fd,</a>
<a name="ln241">		len, sent);</a>
<a name="ln242">    }</a>
<a name="ln243">  }</a>
<a name="ln244">}</a>
<a name="ln245"> </a>
<a name="ln246">static int ssmpingd_read_msg(struct ssmpingd_sock *ss)</a>
<a name="ln247">{</a>
<a name="ln248">  struct interface *ifp;</a>
<a name="ln249">  struct sockaddr_in from;</a>
<a name="ln250">  struct sockaddr_in to;</a>
<a name="ln251">  socklen_t fromlen = sizeof(from);</a>
<a name="ln252">  socklen_t tolen = sizeof(to);</a>
<a name="ln253">  ifindex_t ifindex = -1;</a>
<a name="ln254">  uint8_t buf[1000];</a>
<a name="ln255">  int len;</a>
<a name="ln256"> </a>
<a name="ln257">  ++ss-&gt;requests;</a>
<a name="ln258"> </a>
<a name="ln259">  len = pim_socket_recvfromto(ss-&gt;sock_fd, buf, sizeof(buf),</a>
<a name="ln260">			      &amp;from, &amp;fromlen,</a>
<a name="ln261">			      &amp;to, &amp;tolen,</a>
<a name="ln262">			      &amp;ifindex);</a>
<a name="ln263">  if (len &lt; 0) {</a>
<a name="ln264">    char source_str[100];</a>
<a name="ln265">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ss-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln266">    zlog_warn(&quot;%s: failure receiving ssmping for source %s on fd=%d: errno=%d: %s&quot;,</a>
<a name="ln267">	      __PRETTY_FUNCTION__, source_str, ss-&gt;sock_fd, errno, safe_strerror(errno));</a>
<a name="ln268">    return -1;</a>
<a name="ln269">  }</a>
<a name="ln270"> </a>
<a name="ln271">  ifp = if_lookup_by_index(ifindex);</a>
<a name="ln272"> </a>
<a name="ln273">  if (buf[0] != PIM_SSMPINGD_REQUEST) {</a>
<a name="ln274">    char source_str[100];</a>
<a name="ln275">    char from_str[100];</a>
<a name="ln276">    char to_str[100];</a>
<a name="ln277">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ss-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln278">    pim_inet4_dump(&quot;&lt;from?&gt;&quot;, from.sin_addr, from_str, sizeof(from_str));</a>
<a name="ln279">    pim_inet4_dump(&quot;&lt;to?&gt;&quot;, to.sin_addr, to_str, sizeof(to_str));</a>
<a name="ln280">    zlog_warn(&quot;%s: bad ssmping type=%d from %s,%d to %s,%d on interface %s ifindex=%d fd=%d src=%s&quot;,</a>
<a name="ln281">	      __PRETTY_FUNCTION__,</a>
<a name="ln282">	      buf[0],</a>
<a name="ln283">	      from_str, ntohs(from.sin_port),</a>
<a name="ln284">	      to_str, ntohs(to.sin_port),</a>
<a name="ln285">	      ifp ? ifp-&gt;name : &quot;&lt;iface?&gt;&quot;,</a>
<a name="ln286">	      ifindex, ss-&gt;sock_fd,</a>
<a name="ln287">	      source_str);</a>
<a name="ln288">    return 0;</a>
<a name="ln289">  }</a>
<a name="ln290"> </a>
<a name="ln291">  if (PIM_DEBUG_SSMPINGD) {</a>
<a name="ln292">    char source_str[100];</a>
<a name="ln293">    char from_str[100];</a>
<a name="ln294">    char to_str[100];</a>
<a name="ln295">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, ss-&gt;source_addr, source_str, sizeof(source_str));</a>
<a name="ln296">    pim_inet4_dump(&quot;&lt;from?&gt;&quot;, from.sin_addr, from_str, sizeof(from_str));</a>
<a name="ln297">    pim_inet4_dump(&quot;&lt;to?&gt;&quot;, to.sin_addr, to_str, sizeof(to_str));</a>
<a name="ln298">    zlog_debug(&quot;%s: recv ssmping from %s,%d to %s,%d on interface %s ifindex=%d fd=%d src=%s&quot;,</a>
<a name="ln299">	       __PRETTY_FUNCTION__,</a>
<a name="ln300">	       from_str, ntohs(from.sin_port),</a>
<a name="ln301">	       to_str, ntohs(to.sin_port),</a>
<a name="ln302">	       ifp ? ifp-&gt;name : &quot;&lt;iface?&gt;&quot;,</a>
<a name="ln303">	       ifindex, ss-&gt;sock_fd,</a>
<a name="ln304">	       source_str);</a>
<a name="ln305">  }</a>
<a name="ln306"> </a>
<a name="ln307">  buf[0] = PIM_SSMPINGD_REPLY;</a>
<a name="ln308"> </a>
<a name="ln309">  /* unicast reply */</a>
<a name="ln310">  ssmpingd_sendto(ss, buf, len, from);</a>
<a name="ln311"> </a>
<a name="ln312">  /* multicast reply */</a>
<a name="ln313">  from.sin_addr = qpim_ssmpingd_group_addr;</a>
<a name="ln314">  ssmpingd_sendto(ss, buf, len, from);</a>
<a name="ln315"> </a>
<a name="ln316">  return 0;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319">static int ssmpingd_sock_read(struct thread *t)</a>
<a name="ln320">{</a>
<a name="ln321">  struct ssmpingd_sock *ss;</a>
<a name="ln322">  int sock_fd;</a>
<a name="ln323">  int result;</a>
<a name="ln324"> </a>
<a name="ln325">  zassert(t);</a>
<a name="ln326"> </a>
<a name="ln327">  ss = THREAD_ARG(t);</a>
<a name="ln328">  zassert(ss);</a>
<a name="ln329"> </a>
<a name="ln330">  sock_fd = THREAD_FD(t);</a>
<a name="ln331">  zassert(sock_fd == ss-&gt;sock_fd);</a>
<a name="ln332"> </a>
<a name="ln333">  result = ssmpingd_read_msg(ss);</a>
<a name="ln334"> </a>
<a name="ln335">  /* Keep reading */</a>
<a name="ln336">  ss-&gt;t_sock_read = 0;</a>
<a name="ln337">  ssmpingd_read_on(ss);</a>
<a name="ln338"> </a>
<a name="ln339">  return result;</a>
<a name="ln340">}</a>
<a name="ln341"> </a>
<a name="ln342">static void ssmpingd_read_on(struct ssmpingd_sock *ss)</a>
<a name="ln343">{</a>
<a name="ln344">  zassert(!ss-&gt;t_sock_read);</a>
<a name="ln345">  THREAD_READ_ON(master, ss-&gt;t_sock_read,</a>
<a name="ln346">		 ssmpingd_sock_read, ss, ss-&gt;sock_fd);</a>
<a name="ln347">}</a>
<a name="ln348"> </a>
<a name="ln349">static struct ssmpingd_sock *ssmpingd_new(struct in_addr source_addr)</a>
<a name="ln350">{</a>
<a name="ln351">  struct ssmpingd_sock *ss;</a>
<a name="ln352">  int sock_fd;</a>
<a name="ln353"> </a>
<a name="ln354">  if (!qpim_ssmpingd_list) {</a>
<a name="ln355">    qpim_ssmpingd_list = list_new();</a>
<a name="ln356">    if (!qpim_ssmpingd_list) {</a>
<a name="ln357">      zlog_err(&quot;%s %s: failure: qpim_ssmpingd_list=list_new()&quot;,</a>
<a name="ln358">	       __FILE__, __PRETTY_FUNCTION__);</a>
<a name="ln359">      return 0;</a>
<a name="ln360">    }</a>
<a name="ln361">    qpim_ssmpingd_list-&gt;del = (void (*)(void *)) ssmpingd_free;</a>
<a name="ln362">  }</a>
<a name="ln363"> </a>
<a name="ln364">  sock_fd = ssmpingd_socket(source_addr, /* port: */ 4321, /* mTTL: */ 64);</a>
<a name="ln365">  if (sock_fd &lt; 0) {</a>
<a name="ln366">    char source_str[100];</a>
<a name="ln367">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln368">    zlog_warn(&quot;%s: ssmpingd_socket() failure for source %s&quot;,</a>
<a name="ln369">	      __PRETTY_FUNCTION__, source_str);</a>
<a name="ln370">    return 0;</a>
<a name="ln371">  }</a>
<a name="ln372"> </a>
<a name="ln373">  ss = XMALLOC(MTYPE_PIM_SSMPINGD, sizeof(*ss));</a>
<a name="ln374">  if (!ss) {</a>
<a name="ln375">    char source_str[100];</a>
<a name="ln376">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln377">    zlog_err(&quot;%s: XMALLOC(%zu) failure for ssmpingd source %s&quot;,</a>
<a name="ln378">	     __PRETTY_FUNCTION__,</a>
<a name="ln379">	     sizeof(*ss), source_str);</a>
<a name="ln380">    close(sock_fd);</a>
<a name="ln381">    return 0;</a>
<a name="ln382">  }</a>
<a name="ln383"> </a>
<a name="ln384">  ss-&gt;sock_fd     = sock_fd;</a>
<a name="ln385">  ss-&gt;t_sock_read = 0;</a>
<a name="ln386">  ss-&gt;source_addr = source_addr;</a>
<a name="ln387">  ss-&gt;creation    = pim_time_monotonic_sec();</a>
<a name="ln388">  ss-&gt;requests    = 0;</a>
<a name="ln389"> </a>
<a name="ln390">  listnode_add(qpim_ssmpingd_list, ss);</a>
<a name="ln391"> </a>
<a name="ln392">  ssmpingd_read_on(ss);</a>
<a name="ln393"> </a>
<a name="ln394">  return ss;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">int pim_ssmpingd_start(struct in_addr source_addr)</a>
<a name="ln398">{</a>
<a name="ln399">  struct ssmpingd_sock *ss;</a>
<a name="ln400"> </a>
<a name="ln401">  ss = ssmpingd_find(source_addr);</a>
<a name="ln402">  if (ss) {</a>
<a name="ln403">    /* silently ignore request to recreate entry */</a>
<a name="ln404">    return 0;</a>
<a name="ln405">  }</a>
<a name="ln406"> </a>
<a name="ln407">  {</a>
<a name="ln408">    char source_str[100];</a>
<a name="ln409">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln410">    zlog_info(&quot;%s: starting ssmpingd for source %s&quot;,</a>
<a name="ln411">	      __PRETTY_FUNCTION__, source_str);</a>
<a name="ln412">  }</a>
<a name="ln413"> </a>
<a name="ln414">  ss = ssmpingd_new(source_addr);</a>
<a name="ln415">  if (!ss) {</a>
<a name="ln416">    char source_str[100];</a>
<a name="ln417">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln418">    zlog_warn(&quot;%s: ssmpingd_new() failure for source %s&quot;,</a>
<a name="ln419">	      __PRETTY_FUNCTION__, source_str);</a>
<a name="ln420">    return -1;</a>
<a name="ln421">  }</a>
<a name="ln422"> </a>
<a name="ln423">  return 0;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">int pim_ssmpingd_stop(struct in_addr source_addr)</a>
<a name="ln427">{</a>
<a name="ln428">  struct ssmpingd_sock *ss;</a>
<a name="ln429"> </a>
<a name="ln430">  ss = ssmpingd_find(source_addr);</a>
<a name="ln431">  if (!ss) {</a>
<a name="ln432">    char source_str[100];</a>
<a name="ln433">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln434">    zlog_warn(&quot;%s: could not find ssmpingd for source %s&quot;,</a>
<a name="ln435">	      __PRETTY_FUNCTION__, source_str);</a>
<a name="ln436">    return -1;</a>
<a name="ln437">  }</a>
<a name="ln438"> </a>
<a name="ln439">  {</a>
<a name="ln440">    char source_str[100];</a>
<a name="ln441">    pim_inet4_dump(&quot;&lt;src?&gt;&quot;, source_addr, source_str, sizeof(source_str));</a>
<a name="ln442">    zlog_info(&quot;%s: stopping ssmpingd for source %s&quot;,</a>
<a name="ln443">	      __PRETTY_FUNCTION__, source_str);</a>
<a name="ln444">  }</a>
<a name="ln445"> </a>
<a name="ln446">  ssmpingd_delete(ss);</a>
<a name="ln447"> </a>
<a name="ln448">  return 0;</a>
<a name="ln449">}</a>

</code></pre>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
