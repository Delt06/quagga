
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>isis_routemap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * IS-IS Rout(e)ing protocol - isis_routemap.c</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2013-2015 Christian Franke &lt;chris@opensourcerouting.org&gt;</a>
<a name="ln5"> *</a>
<a name="ln6"> * This program is free software; you can redistribute it and/or modify it </a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the Free </a>
<a name="ln8"> * Software Foundation; either version 2 of the License, or (at your option) </a>
<a name="ln9"> * any later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * This program is distributed in the hope that it will be useful,but WITHOUT </a>
<a name="ln12"> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or </a>
<a name="ln13"> * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for </a>
<a name="ln14"> * more details.</a>
<a name="ln15"> </a>
<a name="ln16"> * You should have received a copy of the GNU General Public License along </a>
<a name="ln17"> * with this program; if not, write to the Free Software Foundation, Inc., </a>
<a name="ln18"> * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.</a>
<a name="ln19"> */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;command.h&quot;</a>
<a name="ln24">#include &quot;filter.h&quot;</a>
<a name="ln25">#include &quot;hash.h&quot;</a>
<a name="ln26">#include &quot;if.h&quot;</a>
<a name="ln27">#include &quot;linklist.h&quot;</a>
<a name="ln28">#include &quot;log.h&quot;</a>
<a name="ln29">#include &quot;memory.h&quot;</a>
<a name="ln30">#include &quot;prefix.h&quot;</a>
<a name="ln31">#include &quot;plist.h&quot;</a>
<a name="ln32">#include &quot;routemap.h&quot;</a>
<a name="ln33">#include &quot;table.h&quot;</a>
<a name="ln34">#include &quot;thread.h&quot;</a>
<a name="ln35">#include &quot;vty.h&quot;</a>
<a name="ln36"> </a>
<a name="ln37">#include &quot;isis_constants.h&quot;</a>
<a name="ln38">#include &quot;isis_common.h&quot;</a>
<a name="ln39">#include &quot;isis_flags.h&quot;</a>
<a name="ln40">#include &quot;dict.h&quot;</a>
<a name="ln41">#include &quot;isisd.h&quot;</a>
<a name="ln42">#include &quot;isis_misc.h&quot;</a>
<a name="ln43">#include &quot;isis_adjacency.h&quot;</a>
<a name="ln44">#include &quot;isis_circuit.h&quot;</a>
<a name="ln45">#include &quot;isis_tlv.h&quot;</a>
<a name="ln46">#include &quot;isis_pdu.h&quot;</a>
<a name="ln47">#include &quot;isis_lsp.h&quot;</a>
<a name="ln48">#include &quot;isis_spf.h&quot;</a>
<a name="ln49">#include &quot;isis_route.h&quot;</a>
<a name="ln50">#include &quot;isis_zebra.h&quot;</a>
<a name="ln51">#include &quot;isis_routemap.h&quot;</a>
<a name="ln52"> </a>
<a name="ln53">static route_map_result_t</a>
<a name="ln54">route_match_ip_address(void *rule, struct prefix *prefix,</a>
<a name="ln55">                       route_map_object_t type, void *object)</a>
<a name="ln56">{</a>
<a name="ln57">  struct access_list *alist;</a>
<a name="ln58"> </a>
<a name="ln59">  if (type != RMAP_ISIS)</a>
<a name="ln60">    return RMAP_NOMATCH;</a>
<a name="ln61"> </a>
<a name="ln62">  alist = access_list_lookup(AFI_IP, (char*)rule);</a>
<a name="ln63">  if (access_list_apply(alist, prefix) != FILTER_DENY)</a>
<a name="ln64">    return RMAP_MATCH;</a>
<a name="ln65"> </a>
<a name="ln66">  return RMAP_NOMATCH;</a>
<a name="ln67">}</a>
<a name="ln68"> </a>
<a name="ln69">static void *</a>
<a name="ln70">route_match_ip_address_compile(const char *arg)</a>
<a name="ln71">{</a>
<a name="ln72">  return XSTRDUP(MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln73">}</a>
<a name="ln74"> </a>
<a name="ln75">static void</a>
<a name="ln76">route_match_ip_address_free(void *rule)</a>
<a name="ln77">{</a>
<a name="ln78">  XFREE(MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln79">}</a>
<a name="ln80"> </a>
<a name="ln81">static struct route_map_rule_cmd route_match_ip_address_cmd =</a>
<a name="ln82">{</a>
<a name="ln83">  &quot;ip address&quot;,</a>
<a name="ln84">  route_match_ip_address,</a>
<a name="ln85">  route_match_ip_address_compile,</a>
<a name="ln86">  route_match_ip_address_free</a>
<a name="ln87">};</a>
<a name="ln88"> </a>
<a name="ln89">/* ------------------------------------------------------------*/</a>
<a name="ln90"> </a>
<a name="ln91">static route_map_result_t</a>
<a name="ln92">route_match_ip_address_prefix_list(void *rule, struct prefix *prefix,</a>
<a name="ln93">                                   route_map_object_t type, void *object)</a>
<a name="ln94">{</a>
<a name="ln95">  struct prefix_list *plist;</a>
<a name="ln96"> </a>
<a name="ln97">  if (type != RMAP_ISIS)</a>
<a name="ln98">    return RMAP_NOMATCH;</a>
<a name="ln99"> </a>
<a name="ln100">  plist = prefix_list_lookup(AFI_IP, (char*)rule);</a>
<a name="ln101">  if (prefix_list_apply(plist, prefix) != PREFIX_DENY)</a>
<a name="ln102">    return RMAP_MATCH;</a>
<a name="ln103"> </a>
<a name="ln104">  return RMAP_NOMATCH;</a>
<a name="ln105">}</a>
<a name="ln106"> </a>
<a name="ln107">static void *</a>
<a name="ln108">route_match_ip_address_prefix_list_compile(const char *arg)</a>
<a name="ln109">{</a>
<a name="ln110">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln111">}</a>
<a name="ln112"> </a>
<a name="ln113">static void</a>
<a name="ln114">route_match_ip_address_prefix_list_free (void *rule)</a>
<a name="ln115">{</a>
<a name="ln116">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln117">}</a>
<a name="ln118"> </a>
<a name="ln119">struct route_map_rule_cmd route_match_ip_address_prefix_list_cmd =</a>
<a name="ln120">{</a>
<a name="ln121">  &quot;ip address prefix-list&quot;,</a>
<a name="ln122">  route_match_ip_address_prefix_list,</a>
<a name="ln123">  route_match_ip_address_prefix_list_compile,</a>
<a name="ln124">  route_match_ip_address_prefix_list_free</a>
<a name="ln125">};</a>
<a name="ln126"> </a>
<a name="ln127">/* ------------------------------------------------------------*/</a>
<a name="ln128"> </a>
<a name="ln129">static route_map_result_t</a>
<a name="ln130">route_match_ipv6_address(void *rule, struct prefix *prefix,</a>
<a name="ln131">                         route_map_object_t type, void *object)</a>
<a name="ln132">{</a>
<a name="ln133">  struct access_list *alist;</a>
<a name="ln134"> </a>
<a name="ln135">  if (type != RMAP_ISIS)</a>
<a name="ln136">    return RMAP_NOMATCH;</a>
<a name="ln137"> </a>
<a name="ln138">  alist = access_list_lookup(AFI_IP6, (char*)rule);</a>
<a name="ln139">  if (access_list_apply(alist, prefix) != FILTER_DENY)</a>
<a name="ln140">    return RMAP_MATCH;</a>
<a name="ln141"> </a>
<a name="ln142">  return RMAP_NOMATCH;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">static void *</a>
<a name="ln146">route_match_ipv6_address_compile(const char *arg)</a>
<a name="ln147">{</a>
<a name="ln148">  return XSTRDUP(MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">static void</a>
<a name="ln152">route_match_ipv6_address_free(void *rule)</a>
<a name="ln153">{</a>
<a name="ln154">  XFREE(MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln155">}</a>
<a name="ln156"> </a>
<a name="ln157">static struct route_map_rule_cmd route_match_ipv6_address_cmd =</a>
<a name="ln158">{</a>
<a name="ln159">  &quot;ipv6 address&quot;,</a>
<a name="ln160">  route_match_ipv6_address,</a>
<a name="ln161">  route_match_ipv6_address_compile,</a>
<a name="ln162">  route_match_ipv6_address_free</a>
<a name="ln163">};</a>
<a name="ln164"> </a>
<a name="ln165">/* ------------------------------------------------------------*/</a>
<a name="ln166"> </a>
<a name="ln167">static route_map_result_t</a>
<a name="ln168">route_match_ipv6_address_prefix_list(void *rule, struct prefix *prefix,</a>
<a name="ln169">                                     route_map_object_t type, void *object)</a>
<a name="ln170">{</a>
<a name="ln171">  struct prefix_list *plist;</a>
<a name="ln172"> </a>
<a name="ln173">  if (type != RMAP_ISIS)</a>
<a name="ln174">    return RMAP_NOMATCH;</a>
<a name="ln175"> </a>
<a name="ln176">  plist = prefix_list_lookup(AFI_IP6, (char*)rule);</a>
<a name="ln177">  if (prefix_list_apply(plist, prefix) != PREFIX_DENY)</a>
<a name="ln178">    return RMAP_MATCH;</a>
<a name="ln179"> </a>
<a name="ln180">  return RMAP_NOMATCH;</a>
<a name="ln181">}</a>
<a name="ln182"> </a>
<a name="ln183">static void *</a>
<a name="ln184">route_match_ipv6_address_prefix_list_compile(const char *arg)</a>
<a name="ln185">{</a>
<a name="ln186">  return XSTRDUP (MTYPE_ROUTE_MAP_COMPILED, arg);</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">static void</a>
<a name="ln190">route_match_ipv6_address_prefix_list_free (void *rule)</a>
<a name="ln191">{</a>
<a name="ln192">  XFREE (MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln193">}</a>
<a name="ln194"> </a>
<a name="ln195">struct route_map_rule_cmd route_match_ipv6_address_prefix_list_cmd =</a>
<a name="ln196">{</a>
<a name="ln197">  &quot;ipv6 address prefix-list&quot;,</a>
<a name="ln198">  route_match_ipv6_address_prefix_list,</a>
<a name="ln199">  route_match_ipv6_address_prefix_list_compile,</a>
<a name="ln200">  route_match_ipv6_address_prefix_list_free</a>
<a name="ln201">};</a>
<a name="ln202"> </a>
<a name="ln203">/* ------------------------------------------------------------*/</a>
<a name="ln204"> </a>
<a name="ln205">static route_map_result_t</a>
<a name="ln206">route_set_metric(void *rule, struct prefix *prefix,</a>
<a name="ln207">                 route_map_object_t type, void *object)</a>
<a name="ln208">{</a>
<a name="ln209">  uint32_t *metric;</a>
<a name="ln210">  struct isis_ext_info *info;</a>
<a name="ln211"> </a>
<a name="ln212">  if (type == RMAP_ISIS)</a>
<a name="ln213">    {</a>
<a name="ln214">      metric = rule;</a>
<a name="ln215">      info = object;</a>
<a name="ln216"> </a>
<a name="ln217">      info-&gt;metric = *metric;</a>
<a name="ln218">    }</a>
<a name="ln219">  return RMAP_OKAY;</a>
<a name="ln220">}</a>
<a name="ln221"> </a>
<a name="ln222">static void *</a>
<a name="ln223">route_set_metric_compile(const char *arg)</a>
<a name="ln224">{</a>
<a name="ln225">  unsigned long metric;</a>
<a name="ln226">  char *endp;</a>
<a name="ln227">  uint32_t *ret;</a>
<a name="ln228"> </a>
<a name="ln229">  metric = strtoul(arg, &amp;endp, 10);</a>
<a name="ln230">  if (arg[0] == '\0' || *endp != '\0' || metric &gt; MAX_WIDE_PATH_METRIC)</a>
<a name="ln231">    return NULL;</a>
<a name="ln232"> </a>
<a name="ln233">  ret = XCALLOC(MTYPE_ROUTE_MAP_COMPILED, sizeof(*ret));</a>
<a name="ln234">  *ret = metric;</a>
<a name="ln235"> </a>
<a name="ln236">  return ret;</a>
<a name="ln237">}</a>
<a name="ln238"> </a>
<a name="ln239">static void</a>
<a name="ln240">route_set_metric_free(void *rule)</a>
<a name="ln241">{</a>
<a name="ln242">  XFREE(MTYPE_ROUTE_MAP_COMPILED, rule);</a>
<a name="ln243">}</a>
<a name="ln244"> </a>
<a name="ln245">static struct route_map_rule_cmd route_set_metric_cmd =</a>
<a name="ln246">{</a>
<a name="ln247">  &quot;metric&quot;,</a>
<a name="ln248">  route_set_metric,</a>
<a name="ln249">  route_set_metric_compile,</a>
<a name="ln250">  route_set_metric_free</a>
<a name="ln251">};</a>
<a name="ln252"> </a>
<a name="ln253">/* ------------------------------------------------------------*/</a>
<a name="ln254"> </a>
<a name="ln255">static int</a>
<a name="ln256">isis_route_match_add(struct vty *vty, struct route_map_index *index,</a>
<a name="ln257">                      const char *command, const char *arg)</a>
<a name="ln258">{</a>
<a name="ln259">  int ret;</a>
<a name="ln260"> </a>
<a name="ln261">  ret = route_map_add_match (index, command, arg);</a>
<a name="ln262">  if (ret)</a>
<a name="ln263">    {</a>
<a name="ln264">      switch (ret)</a>
<a name="ln265">        {</a>
<a name="ln266">        case RMAP_RULE_MISSING:</a>
<a name="ln267">          vty_out (vty, &quot;%% Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln268">          return CMD_WARNING;</a>
<a name="ln269">        case RMAP_COMPILE_ERROR:</a>
<a name="ln270">          vty_out (vty, &quot;%% Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln271">          return CMD_WARNING;</a>
<a name="ln272">        }</a>
<a name="ln273">    }</a>
<a name="ln274">  return CMD_SUCCESS;</a>
<a name="ln275">}</a>
<a name="ln276"> </a>
<a name="ln277">static int</a>
<a name="ln278">isis_route_match_delete(struct vty *vty, struct route_map_index *index,</a>
<a name="ln279">                        const char *command, const char *arg)</a>
<a name="ln280">{</a>
<a name="ln281">  int ret;</a>
<a name="ln282"> </a>
<a name="ln283">  ret = route_map_delete_match (index, command, arg);</a>
<a name="ln284">  if (ret)</a>
<a name="ln285">    {</a>
<a name="ln286">      switch (ret)</a>
<a name="ln287">        {</a>
<a name="ln288">        case RMAP_RULE_MISSING:</a>
<a name="ln289">          vty_out (vty, &quot;%% Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln290">          return CMD_WARNING;</a>
<a name="ln291">        case RMAP_COMPILE_ERROR:</a>
<a name="ln292">          vty_out (vty, &quot;%% Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln293">          return CMD_WARNING;</a>
<a name="ln294">        }</a>
<a name="ln295">    }</a>
<a name="ln296">  return CMD_SUCCESS;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">static int</a>
<a name="ln300">isis_route_set_add(struct vty *vty, struct route_map_index *index,</a>
<a name="ln301">                   const char *command, const char *arg)</a>
<a name="ln302">{</a>
<a name="ln303">  int ret;</a>
<a name="ln304"> </a>
<a name="ln305">  ret = route_map_add_set(index, command, arg);</a>
<a name="ln306">  if (ret)</a>
<a name="ln307">    {</a>
<a name="ln308">      switch (ret)</a>
<a name="ln309">        {</a>
<a name="ln310">        case RMAP_RULE_MISSING:</a>
<a name="ln311">          vty_out (vty, &quot;%% Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln312">          return CMD_WARNING;</a>
<a name="ln313">        case RMAP_COMPILE_ERROR:</a>
<a name="ln314">          vty_out (vty, &quot;%% Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln315">          return CMD_WARNING;</a>
<a name="ln316">        }</a>
<a name="ln317">    }</a>
<a name="ln318"> </a>
<a name="ln319">  return CMD_SUCCESS;</a>
<a name="ln320">}</a>
<a name="ln321"> </a>
<a name="ln322">static int</a>
<a name="ln323">isis_route_set_delete (struct vty *vty, struct route_map_index *index,</a>
<a name="ln324">		       const char *command, const char *arg)</a>
<a name="ln325">{</a>
<a name="ln326">  int ret;</a>
<a name="ln327"> </a>
<a name="ln328">  ret = route_map_delete_set (index, command, arg);</a>
<a name="ln329">  if (ret)</a>
<a name="ln330">    {</a>
<a name="ln331">      switch (ret)</a>
<a name="ln332">        {</a>
<a name="ln333">        case RMAP_RULE_MISSING:</a>
<a name="ln334">          vty_out (vty, &quot;%% Can't find rule.%s&quot;, VTY_NEWLINE);</a>
<a name="ln335">          return CMD_WARNING;</a>
<a name="ln336">        case RMAP_COMPILE_ERROR:</a>
<a name="ln337">          vty_out (vty, &quot;%% Argument is malformed.%s&quot;, VTY_NEWLINE);</a>
<a name="ln338">          return CMD_WARNING;</a>
<a name="ln339">        }</a>
<a name="ln340">    }</a>
<a name="ln341"> </a>
<a name="ln342">  return CMD_SUCCESS;</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">/* ------------------------------------------------------------*/</a>
<a name="ln346"> </a>
<a name="ln347">DEFUN(match_ip_address,</a>
<a name="ln348">      match_ip_address_cmd,</a>
<a name="ln349">      &quot;match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln350">      MATCH_STR</a>
<a name="ln351">      IP_STR</a>
<a name="ln352">      &quot;Match address of route\n&quot;</a>
<a name="ln353">      &quot;IP access-list number\n&quot;</a>
<a name="ln354">      &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln355">      &quot;IP Access-list name\n&quot;)</a>
<a name="ln356">{</a>
<a name="ln357">  return isis_route_match_add(vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln358">}</a>
<a name="ln359"> </a>
<a name="ln360">DEFUN(no_match_ip_address,</a>
<a name="ln361">      no_match_ip_address_val_cmd,</a>
<a name="ln362">      &quot;no match ip address (&lt;1-199&gt;|&lt;1300-2699&gt;|WORD)&quot;,</a>
<a name="ln363">      NO_STR</a>
<a name="ln364">      MATCH_STR</a>
<a name="ln365">      IP_STR</a>
<a name="ln366">      &quot;Match address of route\n&quot;</a>
<a name="ln367">      &quot;IP access-list number\n&quot;</a>
<a name="ln368">      &quot;IP access-list number (expanded range)\n&quot;</a>
<a name="ln369">      &quot;IP Access-list name\n&quot;)</a>
<a name="ln370">{</a>
<a name="ln371">  if (argc == 0)</a>
<a name="ln372">    return isis_route_match_delete(vty, vty-&gt;index, &quot;ip address&quot;, NULL);</a>
<a name="ln373">  return isis_route_match_delete(vty, vty-&gt;index, &quot;ip address&quot;, argv[0]);</a>
<a name="ln374">}</a>
<a name="ln375"> </a>
<a name="ln376">ALIAS(no_match_ip_address,</a>
<a name="ln377">      no_match_ip_address_cmd,</a>
<a name="ln378">      &quot;no match ip address&quot;,</a>
<a name="ln379">      NO_STR</a>
<a name="ln380">      MATCH_STR</a>
<a name="ln381">      IP_STR</a>
<a name="ln382">      &quot;Match address of route\n&quot;</a>
<a name="ln383">);</a>
<a name="ln384"> </a>
<a name="ln385">/* ------------------------------------------------------------*/</a>
<a name="ln386"> </a>
<a name="ln387">DEFUN(match_ip_address_prefix_list,</a>
<a name="ln388">      match_ip_address_prefix_list_cmd,</a>
<a name="ln389">      &quot;match ip address prefix-list WORD&quot;,</a>
<a name="ln390">      MATCH_STR</a>
<a name="ln391">      IP_STR</a>
<a name="ln392">      &quot;Match address of route\n&quot;</a>
<a name="ln393">      &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln394">      &quot;IP prefix-list name\n&quot;)</a>
<a name="ln395">{</a>
<a name="ln396">  return isis_route_match_add(vty, vty-&gt;index, &quot;ip address prefix-list&quot;, argv[0]);</a>
<a name="ln397">}</a>
<a name="ln398"> </a>
<a name="ln399">DEFUN(no_match_ip_address_prefix_list,</a>
<a name="ln400">      no_match_ip_address_prefix_list_cmd,</a>
<a name="ln401">      &quot;no match ip address prefix-list&quot;,</a>
<a name="ln402">      NO_STR</a>
<a name="ln403">      MATCH_STR</a>
<a name="ln404">      IP_STR</a>
<a name="ln405">      &quot;Match address of route\n&quot;</a>
<a name="ln406">      &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln407">{</a>
<a name="ln408">  if (argc == 0)</a>
<a name="ln409">    return isis_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, NULL);</a>
<a name="ln410">  return isis_route_match_delete (vty, vty-&gt;index, &quot;ip address prefix-list&quot;, argv[0]);</a>
<a name="ln411">}</a>
<a name="ln412"> </a>
<a name="ln413">ALIAS(no_match_ip_address_prefix_list,</a>
<a name="ln414">      no_match_ip_address_prefix_list_val_cmd,</a>
<a name="ln415">      &quot;no match ip address prefix-list WORD&quot;,</a>
<a name="ln416">      NO_STR</a>
<a name="ln417">      MATCH_STR</a>
<a name="ln418">      IP_STR</a>
<a name="ln419">      &quot;Match address of route\n&quot;</a>
<a name="ln420">      &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln421">      &quot;IP prefix-list name\n&quot;</a>
<a name="ln422">);</a>
<a name="ln423"> </a>
<a name="ln424">/* ------------------------------------------------------------*/</a>
<a name="ln425"> </a>
<a name="ln426">DEFUN(match_ipv6_address,</a>
<a name="ln427">      match_ipv6_address_cmd,</a>
<a name="ln428">      &quot;match ipv6 address WORD&quot;,</a>
<a name="ln429">      MATCH_STR</a>
<a name="ln430">      IPV6_STR</a>
<a name="ln431">      &quot;Match IPv6 address of route\n&quot;</a>
<a name="ln432">      &quot;IPv6 access-list name\n&quot;)</a>
<a name="ln433">{</a>
<a name="ln434">  return isis_route_match_add(vty, vty-&gt;index, &quot;ipv6 address&quot;, argv[0]);</a>
<a name="ln435">}</a>
<a name="ln436"> </a>
<a name="ln437">DEFUN(no_match_ipv6_address,</a>
<a name="ln438">      no_match_ipv6_address_val_cmd,</a>
<a name="ln439">      &quot;no match ipv6 address WORD&quot;,</a>
<a name="ln440">      NO_STR</a>
<a name="ln441">      MATCH_STR</a>
<a name="ln442">      IPV6_STR</a>
<a name="ln443">      &quot;Match IPv6 address of route\n&quot;</a>
<a name="ln444">      &quot;IPv6 access-list name\n&quot;)</a>
<a name="ln445">{</a>
<a name="ln446">  if (argc == 0)</a>
<a name="ln447">    return isis_route_match_delete(vty, vty-&gt;index, &quot;ipv6 address&quot;, NULL);</a>
<a name="ln448">  return isis_route_match_delete(vty, vty-&gt;index, &quot;ipv6 address&quot;, argv[0]);</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">ALIAS(no_match_ipv6_address,</a>
<a name="ln452">      no_match_ipv6_address_cmd,</a>
<a name="ln453">      &quot;no match ipv6 address&quot;,</a>
<a name="ln454">      NO_STR</a>
<a name="ln455">      MATCH_STR</a>
<a name="ln456">      IPV6_STR</a>
<a name="ln457">      &quot;Match IPv6 address of route\n&quot;</a>
<a name="ln458">);</a>
<a name="ln459"> </a>
<a name="ln460">/* ------------------------------------------------------------*/</a>
<a name="ln461"> </a>
<a name="ln462">DEFUN(match_ipv6_address_prefix_list,</a>
<a name="ln463">      match_ipv6_address_prefix_list_cmd,</a>
<a name="ln464">      &quot;match ipv6 address prefix-list WORD&quot;,</a>
<a name="ln465">      MATCH_STR</a>
<a name="ln466">      IPV6_STR</a>
<a name="ln467">      &quot;Match address of route\n&quot;</a>
<a name="ln468">      &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln469">      &quot;IP prefix-list name\n&quot;)</a>
<a name="ln470">{</a>
<a name="ln471">  return isis_route_match_add(vty, vty-&gt;index, &quot;ipv6 address prefix-list&quot;, argv[0]);</a>
<a name="ln472">}</a>
<a name="ln473"> </a>
<a name="ln474">DEFUN(no_match_ipv6_address_prefix_list,</a>
<a name="ln475">      no_match_ipv6_address_prefix_list_cmd,</a>
<a name="ln476">      &quot;no match ipv6 address prefix-list&quot;,</a>
<a name="ln477">      NO_STR</a>
<a name="ln478">      MATCH_STR</a>
<a name="ln479">      IPV6_STR</a>
<a name="ln480">      &quot;Match address of route\n&quot;</a>
<a name="ln481">      &quot;Match entries of prefix-lists\n&quot;)</a>
<a name="ln482">{</a>
<a name="ln483">  if (argc == 0)</a>
<a name="ln484">    return isis_route_match_delete (vty, vty-&gt;index, &quot;ipv6 address prefix-list&quot;, NULL);</a>
<a name="ln485">  return isis_route_match_delete (vty, vty-&gt;index, &quot;ipv6 address prefix-list&quot;, argv[0]);</a>
<a name="ln486">}</a>
<a name="ln487"> </a>
<a name="ln488">ALIAS(no_match_ipv6_address_prefix_list,</a>
<a name="ln489">      no_match_ipv6_address_prefix_list_val_cmd,</a>
<a name="ln490">      &quot;no match ipv6 address prefix-list WORD&quot;,</a>
<a name="ln491">      NO_STR</a>
<a name="ln492">      MATCH_STR</a>
<a name="ln493">      IPV6_STR</a>
<a name="ln494">      &quot;Match address of route\n&quot;</a>
<a name="ln495">      &quot;Match entries of prefix-lists\n&quot;</a>
<a name="ln496">      &quot;IP prefix-list name\n&quot;</a>
<a name="ln497">);</a>
<a name="ln498"> </a>
<a name="ln499">/* ------------------------------------------------------------*/</a>
<a name="ln500"> </a>
<a name="ln501">/* set metric already exists e.g. in the ospf routemap. vtysh doesn't cope well with different</a>
<a name="ln502"> * commands at the same node, therefore add set metric with the same 32-bit range as ospf and</a>
<a name="ln503"> * verify that the input is a valid isis metric */</a>
<a name="ln504">DEFUN(set_metric,</a>
<a name="ln505">      set_metric_cmd,</a>
<a name="ln506">      &quot;set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln507">      SET_STR</a>
<a name="ln508">      &quot;Metric vale for destination routing protocol\n&quot;</a>
<a name="ln509">      &quot;Metric value\n&quot;)</a>
<a name="ln510">{</a>
<a name="ln511">  return isis_route_set_add(vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln512">}</a>
<a name="ln513"> </a>
<a name="ln514">DEFUN(no_set_metric,</a>
<a name="ln515">      no_set_metric_val_cmd,</a>
<a name="ln516">      &quot;no set metric &lt;0-4294967295&gt;&quot;,</a>
<a name="ln517">      NO_STR</a>
<a name="ln518">      SET_STR</a>
<a name="ln519">      &quot;Metric value for destination routing protocol\n&quot;</a>
<a name="ln520">      &quot;Metric value\n&quot;)</a>
<a name="ln521">{</a>
<a name="ln522">  if (argc == 0)</a>
<a name="ln523">    return isis_route_set_delete(vty, vty-&gt;index, &quot;metric&quot;, NULL);</a>
<a name="ln524">  return isis_route_set_delete(vty, vty-&gt;index, &quot;metric&quot;, argv[0]);</a>
<a name="ln525">}</a>
<a name="ln526"> </a>
<a name="ln527">ALIAS(no_set_metric,</a>
<a name="ln528">      no_set_metric_cmd,</a>
<a name="ln529">      &quot;no set metric&quot;,</a>
<a name="ln530">      NO_STR</a>
<a name="ln531">      SET_STR</a>
<a name="ln532">      &quot;Metric vale for destination routing protocol\n&quot;</a>
<a name="ln533">);</a>
<a name="ln534"> </a>
<a name="ln535">void</a>
<a name="ln536">isis_route_map_init(void)</a>
<a name="ln537">{</a>
<a name="ln538">  route_map_init();</a>
<a name="ln539">  route_map_init_vty();</a>
<a name="ln540"> </a>
<a name="ln541">  route_map_install_match(&amp;route_match_ip_address_cmd);</a>
<a name="ln542">  install_element(RMAP_NODE, &amp;match_ip_address_cmd);</a>
<a name="ln543">  install_element(RMAP_NODE, &amp;no_match_ip_address_val_cmd);</a>
<a name="ln544">  install_element(RMAP_NODE, &amp;no_match_ip_address_cmd);</a>
<a name="ln545"> </a>
<a name="ln546">  route_map_install_match(&amp;route_match_ip_address_prefix_list_cmd);</a>
<a name="ln547">  install_element(RMAP_NODE, &amp;match_ip_address_prefix_list_cmd);</a>
<a name="ln548">  install_element(RMAP_NODE, &amp;no_match_ip_address_prefix_list_val_cmd);</a>
<a name="ln549">  install_element(RMAP_NODE, &amp;no_match_ip_address_prefix_list_cmd);</a>
<a name="ln550"> </a>
<a name="ln551">  route_map_install_match(&amp;route_match_ipv6_address_cmd);</a>
<a name="ln552">  install_element(RMAP_NODE, &amp;match_ipv6_address_cmd);</a>
<a name="ln553">  install_element(RMAP_NODE, &amp;no_match_ipv6_address_val_cmd);</a>
<a name="ln554">  install_element(RMAP_NODE, &amp;no_match_ipv6_address_cmd);</a>
<a name="ln555"> </a>
<a name="ln556">  route_map_install_match(&amp;route_match_ipv6_address_prefix_list_cmd);</a>
<a name="ln557">  install_element(RMAP_NODE, &amp;match_ipv6_address_prefix_list_cmd);</a>
<a name="ln558">  install_element(RMAP_NODE, &amp;no_match_ipv6_address_prefix_list_val_cmd);</a>
<a name="ln559">  install_element(RMAP_NODE, &amp;no_match_ipv6_address_prefix_list_cmd);</a>
<a name="ln560"> </a>
<a name="ln561">  route_map_install_set(&amp;route_set_metric_cmd);</a>
<a name="ln562">  install_element(RMAP_NODE, &amp;set_metric_cmd);</a>
<a name="ln563">  install_element(RMAP_NODE, &amp;no_set_metric_val_cmd);</a>
<a name="ln564">  install_element(RMAP_NODE, &amp;no_set_metric_cmd);</a>
<a name="ln565">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
