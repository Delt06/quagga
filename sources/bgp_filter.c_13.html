
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_filter.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* AS path filter list.</a>
<a name="ln2">   Copyright (C) 1999 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18">Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19">02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;command.h&quot;</a>
<a name="ln24">#include &quot;log.h&quot;</a>
<a name="ln25">#include &quot;memory.h&quot;</a>
<a name="ln26">#include &quot;buffer.h&quot;</a>
<a name="ln27">#include &quot;filter.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln30">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln31">#include &quot;bgpd/bgp_regex.h&quot;</a>
<a name="ln32">#include &quot;bgpd/bgp_filter.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">/* List of AS filter list. */</a>
<a name="ln35">struct as_list_list</a>
<a name="ln36">{</a>
<a name="ln37">  struct as_list *head;</a>
<a name="ln38">  struct as_list *tail;</a>
<a name="ln39">};</a>
<a name="ln40"> </a>
<a name="ln41">/* AS path filter master. */</a>
<a name="ln42">struct as_list_master</a>
<a name="ln43">{</a>
<a name="ln44">  /* List of access_list which name is number. */</a>
<a name="ln45">  struct as_list_list num;</a>
<a name="ln46"> </a>
<a name="ln47">  /* List of access_list which name is string. */</a>
<a name="ln48">  struct as_list_list str;</a>
<a name="ln49"> </a>
<a name="ln50">  /* Hook function which is executed when new access_list is added. */</a>
<a name="ln51">  void (*add_hook) (void);</a>
<a name="ln52"> </a>
<a name="ln53">  /* Hook function which is executed when access_list is deleted. */</a>
<a name="ln54">  void (*delete_hook) (void);</a>
<a name="ln55">};</a>
<a name="ln56"> </a>
<a name="ln57">/* Element of AS path filter. */</a>
<a name="ln58">struct as_filter</a>
<a name="ln59">{</a>
<a name="ln60">  struct as_filter *next;</a>
<a name="ln61">  struct as_filter *prev;</a>
<a name="ln62"> </a>
<a name="ln63">  enum as_filter_type type;</a>
<a name="ln64"> </a>
<a name="ln65">  regex_t *reg;</a>
<a name="ln66">  char *reg_str;</a>
<a name="ln67">};</a>
<a name="ln68"> </a>
<a name="ln69">/* AS path filter list. */</a>
<a name="ln70">struct as_list</a>
<a name="ln71">{</a>
<a name="ln72">  char *name;</a>
<a name="ln73"> </a>
<a name="ln74">  enum access_type type;</a>
<a name="ln75"> </a>
<a name="ln76">  struct as_list *next;</a>
<a name="ln77">  struct as_list *prev;</a>
<a name="ln78"> </a>
<a name="ln79">  struct as_filter *head;</a>
<a name="ln80">  struct as_filter *tail;</a>
<a name="ln81">};</a>
<a name="ln82"> </a>
<a name="ln83">/* ip as-path access-list 10 permit AS1. */</a>
<a name="ln84"> </a>
<a name="ln85">static struct as_list_master as_list_master =</a>
<a name="ln86">{</a>
<a name="ln87">  {NULL, NULL},</a>
<a name="ln88">  {NULL, NULL},</a>
<a name="ln89">  NULL,</a>
<a name="ln90">  NULL</a>
<a name="ln91">};</a>
<a name="ln92"> </a>
<a name="ln93">/* Allocate new AS filter. */</a>
<a name="ln94">static struct as_filter *</a>
<a name="ln95">as_filter_new (void)</a>
<a name="ln96">{</a>
<a name="ln97">  return XCALLOC (MTYPE_AS_FILTER, sizeof (struct as_filter));</a>
<a name="ln98">}</a>
<a name="ln99"> </a>
<a name="ln100">/* Free allocated AS filter. */</a>
<a name="ln101">static void</a>
<a name="ln102">as_filter_free (struct as_filter *asfilter)</a>
<a name="ln103">{</a>
<a name="ln104">  if (asfilter-&gt;reg)</a>
<a name="ln105">    bgp_regex_free (asfilter-&gt;reg);</a>
<a name="ln106">  if (asfilter-&gt;reg_str)</a>
<a name="ln107">    XFREE (MTYPE_AS_FILTER_STR, asfilter-&gt;reg_str);</a>
<a name="ln108">  XFREE (MTYPE_AS_FILTER, asfilter);</a>
<a name="ln109">}</a>
<a name="ln110"> </a>
<a name="ln111">/* Make new AS filter. */</a>
<a name="ln112">static struct as_filter *</a>
<a name="ln113">as_filter_make (regex_t *reg, const char *reg_str, enum as_filter_type type)</a>
<a name="ln114">{</a>
<a name="ln115">  struct as_filter *asfilter;</a>
<a name="ln116"> </a>
<a name="ln117">  asfilter = as_filter_new ();</a>
<a name="ln118">  asfilter-&gt;reg = reg;</a>
<a name="ln119">  asfilter-&gt;type = type;</a>
<a name="ln120">  asfilter-&gt;reg_str = XSTRDUP (MTYPE_AS_FILTER_STR, reg_str);</a>
<a name="ln121"> </a>
<a name="ln122">  return asfilter;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">static struct as_filter *</a>
<a name="ln126">as_filter_lookup (struct as_list *aslist, const char *reg_str,</a>
<a name="ln127">		  enum as_filter_type type)</a>
<a name="ln128">{</a>
<a name="ln129">  struct as_filter *asfilter;</a>
<a name="ln130"> </a>
<a name="ln131">  for (asfilter = aslist-&gt;head; asfilter; asfilter = asfilter-&gt;next)</a>
<a name="ln132">    if (strcmp (reg_str, asfilter-&gt;reg_str) == 0)</a>
<a name="ln133">      return asfilter;</a>
<a name="ln134">  return NULL;</a>
<a name="ln135">}</a>
<a name="ln136"> </a>
<a name="ln137">static void</a>
<a name="ln138">as_list_filter_add (struct as_list *aslist, struct as_filter *asfilter)</a>
<a name="ln139">{</a>
<a name="ln140">  asfilter-&gt;next = NULL;</a>
<a name="ln141">  asfilter-&gt;prev = aslist-&gt;tail;</a>
<a name="ln142"> </a>
<a name="ln143">  if (aslist-&gt;tail)</a>
<a name="ln144">    aslist-&gt;tail-&gt;next = asfilter;</a>
<a name="ln145">  else</a>
<a name="ln146">    aslist-&gt;head = asfilter;</a>
<a name="ln147">  aslist-&gt;tail = asfilter;</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">/* Lookup as_list from list of as_list by name. */</a>
<a name="ln151">struct as_list *</a>
<a name="ln152">as_list_lookup (const char *name)</a>
<a name="ln153">{</a>
<a name="ln154">  struct as_list *aslist;</a>
<a name="ln155"> </a>
<a name="ln156">  if (name == NULL)</a>
<a name="ln157">    return NULL;</a>
<a name="ln158"> </a>
<a name="ln159">  for (aslist = as_list_master.num.head; aslist; aslist = aslist-&gt;next)</a>
<a name="ln160">    if (strcmp (aslist-&gt;name, name) == 0)</a>
<a name="ln161">      return aslist;</a>
<a name="ln162"> </a>
<a name="ln163">  for (aslist = as_list_master.str.head; aslist; aslist = aslist-&gt;next)</a>
<a name="ln164">    if (strcmp (aslist-&gt;name, name) == 0)</a>
<a name="ln165">      return aslist;</a>
<a name="ln166"> </a>
<a name="ln167">  return NULL;</a>
<a name="ln168">}</a>
<a name="ln169"> </a>
<a name="ln170">static struct as_list *</a>
<a name="ln171">as_list_new (void)</a>
<a name="ln172">{</a>
<a name="ln173">  return XCALLOC (MTYPE_AS_LIST, sizeof (struct as_list));</a>
<a name="ln174">}</a>
<a name="ln175"> </a>
<a name="ln176">static void</a>
<a name="ln177">as_list_free (struct as_list *aslist)</a>
<a name="ln178">{</a>
<a name="ln179">  if (aslist-&gt;name)</a>
<a name="ln180">    {</a>
<a name="ln181">      free (aslist-&gt;name);</a>
<a name="ln182">      aslist-&gt;name = NULL;</a>
<a name="ln183">    }</a>
<a name="ln184">  XFREE (MTYPE_AS_LIST, aslist);</a>
<a name="ln185">}</a>
<a name="ln186"> </a>
<a name="ln187">/* Insert new AS list to list of as_list.  Each as_list is sorted by</a>
<a name="ln188">   the name. */</a>
<a name="ln189">static struct as_list *</a>
<a name="ln190">as_list_insert (const char *name)</a>
<a name="ln191">{</a>
<a name="ln192">  size_t i;</a>
<a name="ln193">  long number;</a>
<a name="ln194">  struct as_list *aslist;</a>
<a name="ln195">  struct as_list *point;</a>
<a name="ln196">  struct as_list_list *list;</a>
<a name="ln197"> </a>
<a name="ln198">  /* Allocate new access_list and copy given name. */</a>
<a name="ln199">  aslist = as_list_new ();</a>
<a name="ln200">  aslist-&gt;name = strdup (name);</a>
<a name="ln201">  assert (aslist-&gt;name);</a>
<a name="ln202"> </a>
<a name="ln203">  /* If name is made by all digit character.  We treat it as</a>
<a name="ln204">     number. */</a>
<a name="ln205">  for (number = 0, i = 0; i &lt; strlen (name); i++)</a>
<a name="ln206">    {</a>
<a name="ln207">      if (isdigit ((int) name[i]))</a>
<a name="ln208">	number = (number * 10) + (name[i] - '0');</a>
<a name="ln209">      else</a>
<a name="ln210">	break;</a>
<a name="ln211">    }</a>
<a name="ln212"> </a>
<a name="ln213">  /* In case of name is all digit character */</a>
<a name="ln214">  if (i == strlen (name))</a>
<a name="ln215">    {</a>
<a name="ln216">      aslist-&gt;type = ACCESS_TYPE_NUMBER;</a>
<a name="ln217"> </a>
<a name="ln218">      /* Set access_list to number list. */</a>
<a name="ln219">      list = &amp;as_list_master.num;</a>
<a name="ln220"> </a>
<a name="ln221">      for (point = list-&gt;head; point; point = point-&gt;next)</a>
<a name="ln222">	if (atol (point-&gt;name) &gt;= number)</a>
<a name="ln223">	  break;</a>
<a name="ln224">    }</a>
<a name="ln225">  else</a>
<a name="ln226">    {</a>
<a name="ln227">      aslist-&gt;type = ACCESS_TYPE_STRING;</a>
<a name="ln228"> </a>
<a name="ln229">      /* Set access_list to string list. */</a>
<a name="ln230">      list = &amp;as_list_master.str;</a>
<a name="ln231">  </a>
<a name="ln232">      /* Set point to insertion point. */</a>
<a name="ln233">      for (point = list-&gt;head; point; point = point-&gt;next)</a>
<a name="ln234">	if (strcmp (point-&gt;name, name) &gt;= 0)</a>
<a name="ln235">	  break;</a>
<a name="ln236">    }</a>
<a name="ln237"> </a>
<a name="ln238">  /* In case of this is the first element of master. */</a>
<a name="ln239">  if (list-&gt;head == NULL)</a>
<a name="ln240">    {</a>
<a name="ln241">      list-&gt;head = list-&gt;tail = aslist;</a>
<a name="ln242">      return aslist;</a>
<a name="ln243">    }</a>
<a name="ln244"> </a>
<a name="ln245">  /* In case of insertion is made at the tail of access_list. */</a>
<a name="ln246">  if (point == NULL)</a>
<a name="ln247">    {</a>
<a name="ln248">      aslist-&gt;prev = list-&gt;tail;</a>
<a name="ln249">      list-&gt;tail-&gt;next = aslist;</a>
<a name="ln250">      list-&gt;tail = aslist;</a>
<a name="ln251">      return aslist;</a>
<a name="ln252">    }</a>
<a name="ln253"> </a>
<a name="ln254">  /* In case of insertion is made at the head of access_list. */</a>
<a name="ln255">  if (point == list-&gt;head)</a>
<a name="ln256">    {</a>
<a name="ln257">      aslist-&gt;next = list-&gt;head;</a>
<a name="ln258">      list-&gt;head-&gt;prev = aslist;</a>
<a name="ln259">      list-&gt;head = aslist;</a>
<a name="ln260">      return aslist;</a>
<a name="ln261">    }</a>
<a name="ln262"> </a>
<a name="ln263">  /* Insertion is made at middle of the access_list. */</a>
<a name="ln264">  aslist-&gt;next = point;</a>
<a name="ln265">  aslist-&gt;prev = point-&gt;prev;</a>
<a name="ln266"> </a>
<a name="ln267">  if (point-&gt;prev)</a>
<a name="ln268">    point-&gt;prev-&gt;next = aslist;</a>
<a name="ln269">  point-&gt;prev = aslist;</a>
<a name="ln270"> </a>
<a name="ln271">  return aslist;</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274">static struct as_list *</a>
<a name="ln275">as_list_get (const char *name)</a>
<a name="ln276">{</a>
<a name="ln277">  struct as_list *aslist;</a>
<a name="ln278"> </a>
<a name="ln279">  aslist = as_list_lookup (name);</a>
<a name="ln280">  if (aslist == NULL)</a>
<a name="ln281">    {</a>
<a name="ln282">      aslist = as_list_insert (name);</a>
<a name="ln283"> </a>
<a name="ln284">      /* Run hook function. */</a>
<a name="ln285">      if (as_list_master.add_hook)</a>
<a name="ln286">	(*as_list_master.add_hook) ();</a>
<a name="ln287">    }</a>
<a name="ln288"> </a>
<a name="ln289">  return aslist;</a>
<a name="ln290">}</a>
<a name="ln291"> </a>
<a name="ln292">static const char *</a>
<a name="ln293">filter_type_str (enum as_filter_type type)</a>
<a name="ln294">{</a>
<a name="ln295">  switch (type)</a>
<a name="ln296">    {</a>
<a name="ln297">    case AS_FILTER_PERMIT:</a>
<a name="ln298">      return &quot;permit&quot;;</a>
<a name="ln299">    case AS_FILTER_DENY:</a>
<a name="ln300">      return &quot;deny&quot;;</a>
<a name="ln301">    default:</a>
<a name="ln302">      return &quot;&quot;;</a>
<a name="ln303">    }</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">static void</a>
<a name="ln307">as_list_delete (struct as_list *aslist)</a>
<a name="ln308">{</a>
<a name="ln309">  struct as_list_list *list;</a>
<a name="ln310">  struct as_filter *filter, *next;</a>
<a name="ln311"> </a>
<a name="ln312">  for (filter = aslist-&gt;head; filter; filter = next)</a>
<a name="ln313">    {</a>
<a name="ln314">      next = filter-&gt;next;</a>
<a name="ln315">      as_filter_free (filter);</a>
<a name="ln316">    }</a>
<a name="ln317"> </a>
<a name="ln318">  if (aslist-&gt;type == ACCESS_TYPE_NUMBER)</a>
<a name="ln319">    list = &amp;as_list_master.num;</a>
<a name="ln320">  else</a>
<a name="ln321">    list = &amp;as_list_master.str;</a>
<a name="ln322"> </a>
<a name="ln323">  if (aslist-&gt;next)</a>
<a name="ln324">    aslist-&gt;next-&gt;prev = aslist-&gt;prev;</a>
<a name="ln325">  else</a>
<a name="ln326">    list-&gt;tail = aslist-&gt;prev;</a>
<a name="ln327"> </a>
<a name="ln328">  if (aslist-&gt;prev)</a>
<a name="ln329">    aslist-&gt;prev-&gt;next = aslist-&gt;next;</a>
<a name="ln330">  else</a>
<a name="ln331">    list-&gt;head = aslist-&gt;next;</a>
<a name="ln332"> </a>
<a name="ln333">  as_list_free (aslist);</a>
<a name="ln334">}</a>
<a name="ln335"> </a>
<a name="ln336">static int</a>
<a name="ln337">as_list_empty (struct as_list *aslist)</a>
<a name="ln338">{</a>
<a name="ln339">  if (aslist-&gt;head == NULL &amp;&amp; aslist-&gt;tail == NULL)</a>
<a name="ln340">    return 1;</a>
<a name="ln341">  else</a>
<a name="ln342">    return 0;</a>
<a name="ln343">}</a>
<a name="ln344"> </a>
<a name="ln345">static void</a>
<a name="ln346">as_list_filter_delete (struct as_list *aslist, struct as_filter *asfilter)</a>
<a name="ln347">{</a>
<a name="ln348">  if (asfilter-&gt;next)</a>
<a name="ln349">    asfilter-&gt;next-&gt;prev = asfilter-&gt;prev;</a>
<a name="ln350">  else</a>
<a name="ln351">    aslist-&gt;tail = asfilter-&gt;prev;</a>
<a name="ln352"> </a>
<a name="ln353">  if (asfilter-&gt;prev)</a>
<a name="ln354">    asfilter-&gt;prev-&gt;next = asfilter-&gt;next;</a>
<a name="ln355">  else</a>
<a name="ln356">    aslist-&gt;head = asfilter-&gt;next;</a>
<a name="ln357"> </a>
<a name="ln358">  as_filter_free (asfilter);</a>
<a name="ln359"> </a>
<a name="ln360">  /* If access_list becomes empty delete it from access_master. */</a>
<a name="ln361">  if (as_list_empty (aslist))</a>
<a name="ln362">    as_list_delete (aslist);</a>
<a name="ln363"> </a>
<a name="ln364">  /* Run hook function. */</a>
<a name="ln365">  if (as_list_master.delete_hook)</a>
<a name="ln366">    (*as_list_master.delete_hook) ();</a>
<a name="ln367">}</a>
<a name="ln368"> </a>
<a name="ln369">static int</a>
<a name="ln370">as_filter_match (struct as_filter *asfilter, struct aspath *aspath)</a>
<a name="ln371">{</a>
<a name="ln372">  if (bgp_regexec (asfilter-&gt;reg, aspath) != REG_NOMATCH)</a>
<a name="ln373">    return 1;</a>
<a name="ln374">  return 0;</a>
<a name="ln375">}</a>
<a name="ln376"> </a>
<a name="ln377">/* Apply AS path filter to AS. */</a>
<a name="ln378">enum as_filter_type</a>
<a name="ln379">as_list_apply (struct as_list *aslist, void *object)</a>
<a name="ln380">{</a>
<a name="ln381">  struct as_filter *asfilter;</a>
<a name="ln382">  struct aspath *aspath;</a>
<a name="ln383"> </a>
<a name="ln384">  aspath = (struct aspath *) object;</a>
<a name="ln385"> </a>
<a name="ln386">  if (aslist == NULL)</a>
<a name="ln387">    return AS_FILTER_DENY;</a>
<a name="ln388"> </a>
<a name="ln389">  for (asfilter = aslist-&gt;head; asfilter; asfilter = asfilter-&gt;next)</a>
<a name="ln390">    {</a>
<a name="ln391">      if (as_filter_match (asfilter, aspath))</a>
<a name="ln392">	return asfilter-&gt;type;</a>
<a name="ln393">    }</a>
<a name="ln394">  return AS_FILTER_DENY;</a>
<a name="ln395">}</a>
<a name="ln396"> </a>
<a name="ln397">/* Add hook function. */</a>
<a name="ln398">void</a>
<a name="ln399">as_list_add_hook (void (*func) (void))</a>
<a name="ln400">{</a>
<a name="ln401">  as_list_master.add_hook = func;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">/* Delete hook function. */</a>
<a name="ln405">void</a>
<a name="ln406">as_list_delete_hook (void (*func) (void))</a>
<a name="ln407">{</a>
<a name="ln408">  as_list_master.delete_hook = func;</a>
<a name="ln409">}</a>
<a name="ln410"> </a>
<a name="ln411">static int</a>
<a name="ln412">as_list_dup_check (struct as_list *aslist, struct as_filter *new)</a>
<a name="ln413">{</a>
<a name="ln414">  struct as_filter *asfilter;</a>
<a name="ln415"> </a>
<a name="ln416">  for (asfilter = aslist-&gt;head; asfilter; asfilter = asfilter-&gt;next)</a>
<a name="ln417">    {</a>
<a name="ln418">      if (asfilter-&gt;type == new-&gt;type</a>
<a name="ln419">	  &amp;&amp; strcmp (asfilter-&gt;reg_str, new-&gt;reg_str) == 0)</a>
<a name="ln420">	return 1;</a>
<a name="ln421">    }</a>
<a name="ln422">  return 0;</a>
<a name="ln423">}</a>
<a name="ln424"> </a>
<a name="ln425">DEFUN (ip_as_path, ip_as_path_cmd,</a>
<a name="ln426">       &quot;ip as-path access-list WORD (deny|permit) .LINE&quot;,</a>
<a name="ln427">       IP_STR</a>
<a name="ln428">       &quot;BGP autonomous system path filter\n&quot;</a>
<a name="ln429">       &quot;Specify an access list name\n&quot;</a>
<a name="ln430">       &quot;Regular expression access list name\n&quot;</a>
<a name="ln431">       &quot;Specify packets to reject\n&quot;</a>
<a name="ln432">       &quot;Specify packets to forward\n&quot;</a>
<a name="ln433">       &quot;A regular-expression to match the BGP AS paths\n&quot;)</a>
<a name="ln434">{</a>
<a name="ln435">  enum as_filter_type type;</a>
<a name="ln436">  struct as_filter *asfilter;</a>
<a name="ln437">  struct as_list *aslist;</a>
<a name="ln438">  regex_t *regex;</a>
<a name="ln439">  char *regstr;</a>
<a name="ln440"> </a>
<a name="ln441">  /* Check the filter type. */</a>
<a name="ln442">  if (strncmp (argv[1], &quot;p&quot;, 1) == 0)</a>
<a name="ln443">    type = AS_FILTER_PERMIT;</a>
<a name="ln444">  else if (strncmp (argv[1], &quot;d&quot;, 1) == 0)</a>
<a name="ln445">    type = AS_FILTER_DENY;</a>
<a name="ln446">  else</a>
<a name="ln447">    {</a>
<a name="ln448">      vty_out (vty, &quot;filter type must be [permit|deny]%s&quot;, VTY_NEWLINE);</a>
<a name="ln449">      return CMD_WARNING;</a>
<a name="ln450">    }</a>
<a name="ln451"> </a>
<a name="ln452">  /* Check AS path regex. */</a>
<a name="ln453">  regstr = argv_concat(argv, argc, 2);</a>
<a name="ln454"> </a>
<a name="ln455">  regex = bgp_regcomp (regstr);</a>
<a name="ln456">  if (!regex)</a>
<a name="ln457">    {</a>
<a name="ln458">      XFREE (MTYPE_TMP, regstr);</a>
<a name="ln459">      vty_out (vty, &quot;can't compile regexp %s%s&quot;, argv[0],</a>
<a name="ln460">	       VTY_NEWLINE);</a>
<a name="ln461">      return CMD_WARNING;</a>
<a name="ln462">    }</a>
<a name="ln463"> </a>
<a name="ln464">  asfilter = as_filter_make (regex, regstr, type);</a>
<a name="ln465">  </a>
<a name="ln466">  XFREE (MTYPE_TMP, regstr);</a>
<a name="ln467"> </a>
<a name="ln468">  /* Install new filter to the access_list. */</a>
<a name="ln469">  aslist = as_list_get (argv[0]);</a>
<a name="ln470"> </a>
<a name="ln471">  /* Duplicate insertion check. */;</a>
<a name="ln472">  if (as_list_dup_check (aslist, asfilter))</a>
<a name="ln473">    as_filter_free (asfilter);</a>
<a name="ln474">  else</a>
<a name="ln475">    as_list_filter_add (aslist, asfilter);</a>
<a name="ln476"> </a>
<a name="ln477">  return CMD_SUCCESS;</a>
<a name="ln478">}</a>
<a name="ln479"> </a>
<a name="ln480">DEFUN (no_ip_as_path,</a>
<a name="ln481">       no_ip_as_path_cmd,</a>
<a name="ln482">       &quot;no ip as-path access-list WORD (deny|permit) .LINE&quot;,</a>
<a name="ln483">       NO_STR</a>
<a name="ln484">       IP_STR</a>
<a name="ln485">       &quot;BGP autonomous system path filter\n&quot;</a>
<a name="ln486">       &quot;Specify an access list name\n&quot;</a>
<a name="ln487">       &quot;Regular expression access list name\n&quot;</a>
<a name="ln488">       &quot;Specify packets to reject\n&quot;</a>
<a name="ln489">       &quot;Specify packets to forward\n&quot;</a>
<a name="ln490">       &quot;A regular-expression to match the BGP AS paths\n&quot;)</a>
<a name="ln491">{</a>
<a name="ln492">  enum as_filter_type type;</a>
<a name="ln493">  struct as_filter *asfilter;</a>
<a name="ln494">  struct as_list *aslist;</a>
<a name="ln495">  char *regstr;</a>
<a name="ln496">  regex_t *regex;</a>
<a name="ln497"> </a>
<a name="ln498">  /* Lookup AS list from AS path list. */</a>
<a name="ln499">  aslist = as_list_lookup (argv[0]);</a>
<a name="ln500">  if (aslist == NULL)</a>
<a name="ln501">    {</a>
<a name="ln502">      vty_out (vty, &quot;ip as-path access-list %s doesn't exist%s&quot;, argv[0],</a>
<a name="ln503">	       VTY_NEWLINE);</a>
<a name="ln504">      return CMD_WARNING;</a>
<a name="ln505">    }</a>
<a name="ln506"> </a>
<a name="ln507">  /* Check the filter type. */</a>
<a name="ln508">  if (strncmp (argv[1], &quot;p&quot;, 1) == 0)</a>
<a name="ln509">    type = AS_FILTER_PERMIT;</a>
<a name="ln510">  else if (strncmp (argv[1], &quot;d&quot;, 1) == 0)</a>
<a name="ln511">    type = AS_FILTER_DENY;</a>
<a name="ln512">  else</a>
<a name="ln513">    {</a>
<a name="ln514">      vty_out (vty, &quot;filter type must be [permit|deny]%s&quot;, VTY_NEWLINE);</a>
<a name="ln515">      return CMD_WARNING;</a>
<a name="ln516">    }</a>
<a name="ln517">  </a>
<a name="ln518">  /* Compile AS path. */</a>
<a name="ln519">  regstr = argv_concat(argv, argc, 2);</a>
<a name="ln520"> </a>
<a name="ln521">  regex = bgp_regcomp (regstr);</a>
<a name="ln522">  if (!regex)</a>
<a name="ln523">    {</a>
<a name="ln524">      XFREE (MTYPE_TMP, regstr);</a>
<a name="ln525">      vty_out (vty, &quot;can't compile regexp %s%s&quot;, argv[0],</a>
<a name="ln526">	       VTY_NEWLINE);</a>
<a name="ln527">      return CMD_WARNING;</a>
<a name="ln528">    }</a>
<a name="ln529"> </a>
<a name="ln530">  /* Lookup asfilter. */</a>
<a name="ln531">  asfilter = as_filter_lookup (aslist, regstr, type);</a>
<a name="ln532"> </a>
<a name="ln533">  XFREE (MTYPE_TMP, regstr);</a>
<a name="ln534">  bgp_regex_free (regex);</a>
<a name="ln535"> </a>
<a name="ln536">  if (asfilter == NULL)</a>
<a name="ln537">    {</a>
<a name="ln538">      vty_out (vty, &quot;%s&quot;, VTY_NEWLINE);</a>
<a name="ln539">      return CMD_WARNING;</a>
<a name="ln540">    }</a>
<a name="ln541"> </a>
<a name="ln542">  as_list_filter_delete (aslist, asfilter);</a>
<a name="ln543"> </a>
<a name="ln544">  return CMD_SUCCESS;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">DEFUN (no_ip_as_path_all,</a>
<a name="ln548">       no_ip_as_path_all_cmd,</a>
<a name="ln549">       &quot;no ip as-path access-list WORD&quot;,</a>
<a name="ln550">       NO_STR</a>
<a name="ln551">       IP_STR</a>
<a name="ln552">       &quot;BGP autonomous system path filter\n&quot;</a>
<a name="ln553">       &quot;Specify an access list name\n&quot;</a>
<a name="ln554">       &quot;Regular expression access list name\n&quot;)</a>
<a name="ln555">{</a>
<a name="ln556">  struct as_list *aslist;</a>
<a name="ln557"> </a>
<a name="ln558">  aslist = as_list_lookup (argv[0]);</a>
<a name="ln559">  if (aslist == NULL)</a>
<a name="ln560">    {</a>
<a name="ln561">      vty_out (vty, &quot;ip as-path access-list %s doesn't exist%s&quot;, argv[0],</a>
<a name="ln562">	       VTY_NEWLINE);</a>
<a name="ln563">      return CMD_WARNING;</a>
<a name="ln564">    }</a>
<a name="ln565"> </a>
<a name="ln566">  as_list_delete (aslist);</a>
<a name="ln567"> </a>
<a name="ln568">  /* Run hook function. */</a>
<a name="ln569">  if (as_list_master.delete_hook)</a>
<a name="ln570">    (*as_list_master.delete_hook) ();</a>
<a name="ln571"> </a>
<a name="ln572">  return CMD_SUCCESS;</a>
<a name="ln573">}</a>
<a name="ln574"> </a>
<a name="ln575">static void</a>
<a name="ln576">as_list_show (struct vty *vty, struct as_list *aslist)</a>
<a name="ln577">{</a>
<a name="ln578">  struct as_filter *asfilter;</a>
<a name="ln579"> </a>
<a name="ln580">  vty_out (vty, &quot;AS path access list %s%s&quot;, aslist-&gt;name, VTY_NEWLINE);</a>
<a name="ln581"> </a>
<a name="ln582">  for (asfilter = aslist-&gt;head; asfilter; asfilter = asfilter-&gt;next)</a>
<a name="ln583">    {</a>
<a name="ln584">      vty_out (vty, &quot;    %s %s%s&quot;, filter_type_str (asfilter-&gt;type),</a>
<a name="ln585">	       asfilter-&gt;reg_str, VTY_NEWLINE);</a>
<a name="ln586">    }</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">static void</a>
<a name="ln590">as_list_show_all (struct vty *vty)</a>
<a name="ln591">{</a>
<a name="ln592">  struct as_list *aslist;</a>
<a name="ln593">  struct as_filter *asfilter;</a>
<a name="ln594"> </a>
<a name="ln595">  for (aslist = as_list_master.num.head; aslist; aslist = aslist-&gt;next)</a>
<a name="ln596">    {</a>
<a name="ln597">      vty_out (vty, &quot;AS path access list %s%s&quot;, aslist-&gt;name, VTY_NEWLINE);</a>
<a name="ln598"> </a>
<a name="ln599">      for (asfilter = aslist-&gt;head; asfilter; asfilter = asfilter-&gt;next)</a>
<a name="ln600">	{</a>
<a name="ln601">	  vty_out (vty, &quot;    %s %s%s&quot;, filter_type_str (asfilter-&gt;type),</a>
<a name="ln602">		   asfilter-&gt;reg_str, VTY_NEWLINE);</a>
<a name="ln603">	}</a>
<a name="ln604">    }</a>
<a name="ln605"> </a>
<a name="ln606">  for (aslist = as_list_master.str.head; aslist; aslist = aslist-&gt;next)</a>
<a name="ln607">    {</a>
<a name="ln608">      vty_out (vty, &quot;AS path access list %s%s&quot;, aslist-&gt;name, VTY_NEWLINE);</a>
<a name="ln609"> </a>
<a name="ln610">      for (asfilter = aslist-&gt;head; asfilter; asfilter = asfilter-&gt;next)</a>
<a name="ln611">	{</a>
<a name="ln612">	  vty_out (vty, &quot;    %s %s%s&quot;, filter_type_str (asfilter-&gt;type),</a>
<a name="ln613">		   asfilter-&gt;reg_str, VTY_NEWLINE);</a>
<a name="ln614">	}</a>
<a name="ln615">    }</a>
<a name="ln616">}</a>
<a name="ln617"> </a>
<a name="ln618">DEFUN (show_ip_as_path_access_list,</a>
<a name="ln619">       show_ip_as_path_access_list_cmd,</a>
<a name="ln620">       &quot;show ip as-path-access-list WORD&quot;,</a>
<a name="ln621">       SHOW_STR</a>
<a name="ln622">       IP_STR</a>
<a name="ln623">       &quot;List AS path access lists\n&quot;</a>
<a name="ln624">       &quot;AS path access list name\n&quot;)</a>
<a name="ln625">{</a>
<a name="ln626">  struct as_list *aslist;</a>
<a name="ln627"> </a>
<a name="ln628">  aslist = as_list_lookup (argv[0]);</a>
<a name="ln629">  if (aslist)</a>
<a name="ln630">    as_list_show (vty, aslist);</a>
<a name="ln631"> </a>
<a name="ln632">  return CMD_SUCCESS;</a>
<a name="ln633">}</a>
<a name="ln634"> </a>
<a name="ln635">DEFUN (show_ip_as_path_access_list_all,</a>
<a name="ln636">       show_ip_as_path_access_list_all_cmd,</a>
<a name="ln637">       &quot;show ip as-path-access-list&quot;,</a>
<a name="ln638">       SHOW_STR</a>
<a name="ln639">       IP_STR</a>
<a name="ln640">       &quot;List AS path access lists\n&quot;)</a>
<a name="ln641">{</a>
<a name="ln642">  as_list_show_all (vty);</a>
<a name="ln643">  return CMD_SUCCESS;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">static int</a>
<a name="ln647">config_write_as_list (struct vty *vty)</a>
<a name="ln648">{</a>
<a name="ln649">  struct as_list *aslist;</a>
<a name="ln650">  struct as_filter *asfilter;</a>
<a name="ln651">  int write = 0;</a>
<a name="ln652"> </a>
<a name="ln653">  for (aslist = as_list_master.num.head; aslist; aslist = aslist-&gt;next)</a>
<a name="ln654">    for (asfilter = aslist-&gt;head; asfilter; asfilter = asfilter-&gt;next)</a>
<a name="ln655">      {</a>
<a name="ln656">	vty_out (vty, &quot;ip as-path access-list %s %s %s%s&quot;,</a>
<a name="ln657">		 aslist-&gt;name, filter_type_str (asfilter-&gt;type), </a>
<a name="ln658">		 asfilter-&gt;reg_str,</a>
<a name="ln659">		 VTY_NEWLINE);</a>
<a name="ln660">	write++;</a>
<a name="ln661">      }</a>
<a name="ln662"> </a>
<a name="ln663">  for (aslist = as_list_master.str.head; aslist; aslist = aslist-&gt;next)</a>
<a name="ln664">    for (asfilter = aslist-&gt;head; asfilter; asfilter = asfilter-&gt;next)</a>
<a name="ln665">      {</a>
<a name="ln666">	vty_out (vty, &quot;ip as-path access-list %s %s %s%s&quot;,</a>
<a name="ln667">		 aslist-&gt;name, filter_type_str (asfilter-&gt;type), </a>
<a name="ln668">		 asfilter-&gt;reg_str,</a>
<a name="ln669">		 VTY_NEWLINE);</a>
<a name="ln670">	write++;</a>
<a name="ln671">      }</a>
<a name="ln672">  return write;</a>
<a name="ln673">}</a>
<a name="ln674"> </a>
<a name="ln675">static struct cmd_node as_list_node =</a>
<a name="ln676">{</a>
<a name="ln677">  AS_LIST_NODE,</a>
<a name="ln678">  &quot;&quot;,</a>
<a name="ln679">  1</a>
<a name="ln680">};</a>
<a name="ln681"> </a>
<a name="ln682">/* Register functions. */</a>
<a name="ln683">void</a>
<a name="ln684">bgp_filter_init (void)</a>
<a name="ln685">{</a>
<a name="ln686">  install_node (&amp;as_list_node, config_write_as_list);</a>
<a name="ln687"> </a>
<a name="ln688">  install_element (CONFIG_NODE, &amp;ip_as_path_cmd);</a>
<a name="ln689">  install_element (CONFIG_NODE, &amp;no_ip_as_path_cmd);</a>
<a name="ln690">  install_element (CONFIG_NODE, &amp;no_ip_as_path_all_cmd);</a>
<a name="ln691"> </a>
<a name="ln692">  install_element (VIEW_NODE, &amp;show_ip_as_path_access_list_cmd);</a>
<a name="ln693">  install_element (VIEW_NODE, &amp;show_ip_as_path_access_list_all_cmd);</a>
<a name="ln694">}</a>
<a name="ln695"> </a>
<a name="ln696">void</a>
<a name="ln697">bgp_filter_reset (void)</a>
<a name="ln698">{</a>
<a name="ln699">  struct as_list *aslist;</a>
<a name="ln700">  struct as_list *next;</a>
<a name="ln701"> </a>
<a name="ln702">  for (aslist = as_list_master.num.head; aslist; aslist = next)</a>
<a name="ln703">    {</a>
<a name="ln704">      next = aslist-&gt;next;</a>
<a name="ln705">      as_list_delete (aslist);</a>
<a name="ln706">    }</a>
<a name="ln707"> </a>
<a name="ln708">  for (aslist = as_list_master.str.head; aslist; aslist = next)</a>
<a name="ln709">    {</a>
<a name="ln710">      next = aslist-&gt;next;</a>
<a name="ln711">      as_list_delete (aslist);</a>
<a name="ln712">    }</a>
<a name="ln713"> </a>
<a name="ln714">  assert (as_list_master.num.head == NULL);</a>
<a name="ln715">  assert (as_list_master.num.tail == NULL);</a>
<a name="ln716"> </a>
<a name="ln717">  assert (as_list_master.str.head == NULL);</a>
<a name="ln718">  assert (as_list_master.str.tail == NULL);</a>
<a name="ln719">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
