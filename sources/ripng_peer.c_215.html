
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ripng_peer.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* RIPng peer support</a>
<a name="ln2"> * Copyright (C) 2000 Kunihiro Ishiguro &lt;kunihiro@zebra.org&gt;</a>
<a name="ln3"> *</a>
<a name="ln4"> * This file is part of GNU Zebra.</a>
<a name="ln5"> *</a>
<a name="ln6"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln8"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9"> * later version.</a>
<a name="ln10"> *</a>
<a name="ln11"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14"> * General Public License for more details.</a>
<a name="ln15"> *</a>
<a name="ln16"> * You should have received a copy of the GNU General Public License</a>
<a name="ln17"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln18"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln19"> * 02111-1307, USA.  </a>
<a name="ln20"> */</a>
<a name="ln21"> </a>
<a name="ln22">/* RIPng support added by Vincent Jardin &lt;vincent.jardin@6wind.com&gt;</a>
<a name="ln23"> * Copyright (C) 2002 6WIND</a>
<a name="ln24"> */</a>
<a name="ln25"> </a>
<a name="ln26">#include &lt;zebra.h&gt;</a>
<a name="ln27"> </a>
<a name="ln28">#include &quot;if.h&quot;</a>
<a name="ln29">#include &quot;prefix.h&quot;</a>
<a name="ln30">#include &quot;command.h&quot;</a>
<a name="ln31">#include &quot;linklist.h&quot;</a>
<a name="ln32">#include &quot;thread.h&quot;</a>
<a name="ln33">#include &quot;memory.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;ripngd/ripngd.h&quot;</a>
<a name="ln36">#include &quot;ripngd/ripng_nexthop.h&quot;</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">/* Linked list of RIPng peer. */</a>
<a name="ln40">struct list *peer_list;</a>
<a name="ln41"> </a>
<a name="ln42">static struct ripng_peer *</a>
<a name="ln43">ripng_peer_new (void)</a>
<a name="ln44">{</a>
<a name="ln45">  return XCALLOC (MTYPE_RIPNG_PEER, sizeof (struct ripng_peer));</a>
<a name="ln46">}</a>
<a name="ln47"> </a>
<a name="ln48">static void</a>
<a name="ln49">ripng_peer_free (struct ripng_peer *peer)</a>
<a name="ln50">{</a>
<a name="ln51">  XFREE (MTYPE_RIPNG_PEER, peer);</a>
<a name="ln52">}</a>
<a name="ln53"> </a>
<a name="ln54">struct ripng_peer *</a>
<a name="ln55">ripng_peer_lookup (struct in6_addr *addr)</a>
<a name="ln56">{</a>
<a name="ln57">  struct ripng_peer *peer;</a>
<a name="ln58">  struct listnode *node, *nnode;</a>
<a name="ln59"> </a>
<a name="ln60">  for (ALL_LIST_ELEMENTS (peer_list, node, nnode, peer))</a>
<a name="ln61">    {</a>
<a name="ln62">      if (IPV6_ADDR_SAME (&amp;peer-&gt;addr, addr))</a>
<a name="ln63">	return peer;</a>
<a name="ln64">    }</a>
<a name="ln65">  return NULL;</a>
<a name="ln66">}</a>
<a name="ln67"> </a>
<a name="ln68">struct ripng_peer *</a>
<a name="ln69">ripng_peer_lookup_next (struct in6_addr *addr)</a>
<a name="ln70">{</a>
<a name="ln71">  struct ripng_peer *peer;</a>
<a name="ln72">  struct listnode *node, *nnode;</a>
<a name="ln73"> </a>
<a name="ln74">  for (ALL_LIST_ELEMENTS (peer_list, node, nnode, peer))</a>
<a name="ln75">    {</a>
<a name="ln76">      if (addr6_cmp(&amp;peer-&gt;addr, addr) &gt; 0) </a>
<a name="ln77">	return peer;</a>
<a name="ln78">    }</a>
<a name="ln79">  return NULL;</a>
<a name="ln80">}</a>
<a name="ln81"> </a>
<a name="ln82">/* RIPng peer is timeout.</a>
<a name="ln83"> * Garbage collector.</a>
<a name="ln84"> **/</a>
<a name="ln85">static int</a>
<a name="ln86">ripng_peer_timeout (struct thread *t)</a>
<a name="ln87">{</a>
<a name="ln88">  struct ripng_peer *peer;</a>
<a name="ln89"> </a>
<a name="ln90">  peer = THREAD_ARG (t);</a>
<a name="ln91">  listnode_delete (peer_list, peer);</a>
<a name="ln92">  ripng_peer_free (peer);</a>
<a name="ln93"> </a>
<a name="ln94">  return 0;</a>
<a name="ln95">}</a>
<a name="ln96"> </a>
<a name="ln97">/* Get RIPng peer.  At the same time update timeout thread. */</a>
<a name="ln98">static struct ripng_peer *</a>
<a name="ln99">ripng_peer_get (struct in6_addr *addr)</a>
<a name="ln100">{</a>
<a name="ln101">  struct ripng_peer *peer;</a>
<a name="ln102"> </a>
<a name="ln103">  peer = ripng_peer_lookup (addr);</a>
<a name="ln104"> </a>
<a name="ln105">  if (peer)</a>
<a name="ln106">    {</a>
<a name="ln107">      if (peer-&gt;t_timeout)</a>
<a name="ln108">	thread_cancel (peer-&gt;t_timeout);</a>
<a name="ln109">    }</a>
<a name="ln110">  else</a>
<a name="ln111">    {</a>
<a name="ln112">      peer = ripng_peer_new ();</a>
<a name="ln113">      peer-&gt;addr = *addr; /* XXX */</a>
<a name="ln114">      listnode_add_sort (peer_list, peer);</a>
<a name="ln115">    }</a>
<a name="ln116"> </a>
<a name="ln117">  /* Update timeout thread. */</a>
<a name="ln118">  peer-&gt;t_timeout = thread_add_timer (master, ripng_peer_timeout, peer,</a>
<a name="ln119">				      RIPNG_PEER_TIMER_DEFAULT);</a>
<a name="ln120"> </a>
<a name="ln121">  /* Last update time set. */</a>
<a name="ln122">  time (&amp;peer-&gt;uptime);</a>
<a name="ln123">  </a>
<a name="ln124">  return peer;</a>
<a name="ln125">}</a>
<a name="ln126"> </a>
<a name="ln127">void</a>
<a name="ln128">ripng_peer_update (struct sockaddr_in6 *from, u_char version)</a>
<a name="ln129">{</a>
<a name="ln130">  struct ripng_peer *peer;</a>
<a name="ln131">  peer = ripng_peer_get (&amp;from-&gt;sin6_addr);</a>
<a name="ln132">  peer-&gt;version = version;</a>
<a name="ln133">}</a>
<a name="ln134"> </a>
<a name="ln135">void</a>
<a name="ln136">ripng_peer_bad_route (struct sockaddr_in6 *from)</a>
<a name="ln137">{</a>
<a name="ln138">  struct ripng_peer *peer;</a>
<a name="ln139">  peer = ripng_peer_get (&amp;from-&gt;sin6_addr);</a>
<a name="ln140">  peer-&gt;recv_badroutes++;</a>
<a name="ln141">}</a>
<a name="ln142"> </a>
<a name="ln143">void</a>
<a name="ln144">ripng_peer_bad_packet (struct sockaddr_in6 *from)</a>
<a name="ln145">{</a>
<a name="ln146">  struct ripng_peer *peer;</a>
<a name="ln147">  peer = ripng_peer_get (&amp;from-&gt;sin6_addr);</a>
<a name="ln148">  peer-&gt;recv_badpackets++;</a>
<a name="ln149">}</a>
<a name="ln150"> </a>
<a name="ln151">/* Display peer uptime. */</a>
<a name="ln152">static char *</a>
<a name="ln153">ripng_peer_uptime (struct ripng_peer *peer, char *buf, size_t len)</a>
<a name="ln154">{</a>
<a name="ln155">  time_t uptime;</a>
<a name="ln156">  struct tm *tm;</a>
<a name="ln157"> </a>
<a name="ln158">  /* If there is no connection has been done before print `never'. */</a>
<a name="ln159">  if (peer-&gt;uptime == 0)</a>
<a name="ln160">    {</a>
<a name="ln161">      snprintf (buf, len, &quot;never   &quot;);</a>
<a name="ln162">      return buf;</a>
<a name="ln163">    }</a>
<a name="ln164"> </a>
<a name="ln165">  /* Get current time. */</a>
<a name="ln166">  uptime = time (NULL);</a>
<a name="ln167">  uptime -= peer-&gt;uptime;</a>
<a name="ln168">  tm = gmtime (&amp;uptime);</a>
<a name="ln169"> </a>
<a name="ln170">  /* Making formatted timer strings. */</a>
<a name="ln171">#define ONE_DAY_SECOND 60*60*24</a>
<a name="ln172">#define ONE_WEEK_SECOND 60*60*24*7</a>
<a name="ln173"> </a>
<a name="ln174">  if (uptime &lt; ONE_DAY_SECOND)</a>
<a name="ln175">    snprintf (buf, len, &quot;%02d:%02d:%02d&quot;, </a>
<a name="ln176">	      tm-&gt;tm_hour, tm-&gt;tm_min, tm-&gt;tm_sec);</a>
<a name="ln177">  else if (uptime &lt; ONE_WEEK_SECOND)</a>
<a name="ln178">    snprintf (buf, len, &quot;%dd%02dh%02dm&quot;, </a>
<a name="ln179">	      tm-&gt;tm_yday, tm-&gt;tm_hour, tm-&gt;tm_min);</a>
<a name="ln180">  else</a>
<a name="ln181">    snprintf (buf, len, &quot;%02dw%dd%02dh&quot;, </a>
<a name="ln182">	      tm-&gt;tm_yday/7, tm-&gt;tm_yday - ((tm-&gt;tm_yday/7) * 7), tm-&gt;tm_hour);</a>
<a name="ln183">  return buf;</a>
<a name="ln184">}</a>
<a name="ln185"> </a>
<a name="ln186">void</a>
<a name="ln187">ripng_peer_display (struct vty *vty)</a>
<a name="ln188">{</a>
<a name="ln189">  struct ripng_peer *peer;</a>
<a name="ln190">  struct listnode *node, *nnode;</a>
<a name="ln191">#define RIPNG_UPTIME_LEN 25</a>
<a name="ln192">  char timebuf[RIPNG_UPTIME_LEN];</a>
<a name="ln193"> </a>
<a name="ln194">  for (ALL_LIST_ELEMENTS (peer_list, node, nnode, peer))</a>
<a name="ln195">    {</a>
<a name="ln196">      vty_out (vty, &quot;    %s %s%14s %10d %10d %10d      %s%s&quot;, inet6_ntoa (peer-&gt;addr),</a>
<a name="ln197">               VTY_NEWLINE, &quot; &quot;,</a>
<a name="ln198">	       peer-&gt;recv_badpackets, peer-&gt;recv_badroutes,</a>
<a name="ln199">	       ZEBRA_RIPNG_DISTANCE_DEFAULT,</a>
<a name="ln200">	       ripng_peer_uptime (peer, timebuf, RIPNG_UPTIME_LEN),</a>
<a name="ln201">	       VTY_NEWLINE);</a>
<a name="ln202">    }</a>
<a name="ln203">}</a>
<a name="ln204"> </a>
<a name="ln205">static int</a>
<a name="ln206">ripng_peer_list_cmp (struct ripng_peer *p1, struct ripng_peer *p2)</a>
<a name="ln207">{</a>
<a name="ln208">  return addr6_cmp(&amp;p1-&gt;addr, &amp;p2-&gt;addr) &gt; 0;</a>
<a name="ln209">}</a>
<a name="ln210"> </a>
<a name="ln211">void</a>
<a name="ln212">ripng_peer_init ()</a>
<a name="ln213">{</a>
<a name="ln214">  peer_list = list_new ();</a>
<a name="ln215">  peer_list-&gt;cmp = (int (*)(void *, void *)) ripng_peer_list_cmp;</a>
<a name="ln216">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
