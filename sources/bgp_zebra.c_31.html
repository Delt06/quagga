
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_zebra.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* zebra client</a>
<a name="ln2">   Copyright (C) 1997, 98, 99 Kunihiro Ishiguro</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln7">under the terms of the GNU General Public License as published by the</a>
<a name="ln8">Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln9">later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln18">Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln19">Boston, MA 02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;command.h&quot;</a>
<a name="ln24">#include &quot;stream.h&quot;</a>
<a name="ln25">#include &quot;network.h&quot;</a>
<a name="ln26">#include &quot;prefix.h&quot;</a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &quot;sockunion.h&quot;</a>
<a name="ln29">#include &quot;zclient.h&quot;</a>
<a name="ln30">#include &quot;routemap.h&quot;</a>
<a name="ln31">#include &quot;thread.h&quot;</a>
<a name="ln32">#include &quot;filter.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln35">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_nexthop.h&quot;</a>
<a name="ln38">#include &quot;bgpd/bgp_zebra.h&quot;</a>
<a name="ln39">#include &quot;bgpd/bgp_fsm.h&quot;</a>
<a name="ln40">#include &quot;bgpd/bgp_debug.h&quot;</a>
<a name="ln41">#include &quot;bgpd/bgp_mpath.h&quot;</a>
<a name="ln42">#include &quot;bgpd/bgp_nexthop.h&quot;</a>
<a name="ln43">#include &quot;bgpd/bgp_nht.h&quot;</a>
<a name="ln44"> </a>
<a name="ln45">/* All information about zebra. */</a>
<a name="ln46">struct zclient *zclient = NULL;</a>
<a name="ln47">struct in_addr router_id_zebra;</a>
<a name="ln48"> </a>
<a name="ln49">/* Growable buffer for nexthops sent to zebra */</a>
<a name="ln50">struct stream *bgp_nexthop_buf = NULL;</a>
<a name="ln51">struct stream *bgp_ifindices_buf = NULL;</a>
<a name="ln52"> </a>
<a name="ln53">int zclient_num_connects;</a>
<a name="ln54"> </a>
<a name="ln55">/* Router-id update message from zebra. */</a>
<a name="ln56">static int</a>
<a name="ln57">bgp_router_id_update (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln58">    vrf_id_t vrf_id)</a>
<a name="ln59">{</a>
<a name="ln60">  struct prefix router_id;</a>
<a name="ln61"> </a>
<a name="ln62">  zebra_router_id_update_read(zclient-&gt;ibuf,&amp;router_id);</a>
<a name="ln63"> </a>
<a name="ln64">  if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln65">    {</a>
<a name="ln66">      char buf[128];</a>
<a name="ln67">      prefix2str(&amp;router_id, buf, sizeof(buf));</a>
<a name="ln68">      zlog_debug(&quot;Zebra rcvd: router id update %s&quot;, buf);</a>
<a name="ln69">    }</a>
<a name="ln70"> </a>
<a name="ln71">  router_id_zebra = router_id.u.prefix4;</a>
<a name="ln72"> </a>
<a name="ln73">  bgp_router_id_zebra_bump ();</a>
<a name="ln74">  return 0;</a>
<a name="ln75">}</a>
<a name="ln76"> </a>
<a name="ln77">/* Nexthop update message from zebra. */</a>
<a name="ln78">static int</a>
<a name="ln79">bgp_read_nexthop_update (int command, struct zclient *zclient,</a>
<a name="ln80">			 zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln81">{</a>
<a name="ln82">  bgp_parse_nexthop_update();</a>
<a name="ln83">  return 0;</a>
<a name="ln84">}</a>
<a name="ln85"> </a>
<a name="ln86">/* Inteface addition message from zebra. */</a>
<a name="ln87">static int</a>
<a name="ln88">bgp_interface_add (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln89">    vrf_id_t vrf_id)</a>
<a name="ln90">{</a>
<a name="ln91">  struct interface *ifp;</a>
<a name="ln92"> </a>
<a name="ln93">  ifp = zebra_interface_add_read (zclient-&gt;ibuf, vrf_id);</a>
<a name="ln94"> </a>
<a name="ln95">  if (BGP_DEBUG(zebra, ZEBRA) &amp;&amp; ifp)</a>
<a name="ln96">    zlog_debug(&quot;Zebra rcvd: interface add %s&quot;, ifp-&gt;name);</a>
<a name="ln97"> </a>
<a name="ln98">  return 0;</a>
<a name="ln99">}</a>
<a name="ln100"> </a>
<a name="ln101">static int</a>
<a name="ln102">bgp_interface_delete (int command, struct zclient *zclient,</a>
<a name="ln103">		      zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln104">{</a>
<a name="ln105">  struct stream *s;</a>
<a name="ln106">  struct interface *ifp;</a>
<a name="ln107"> </a>
<a name="ln108">  s = zclient-&gt;ibuf;</a>
<a name="ln109">  ifp = zebra_interface_state_read (s, vrf_id);</a>
<a name="ln110">  if (! ifp)</a>
<a name="ln111">    return 0;</a>
<a name="ln112"> </a>
<a name="ln113">  ifp-&gt;ifindex = IFINDEX_INTERNAL;</a>
<a name="ln114"> </a>
<a name="ln115">  if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln116">    zlog_debug(&quot;Zebra rcvd: interface delete %s&quot;, ifp-&gt;name);</a>
<a name="ln117"> </a>
<a name="ln118">  return 0;</a>
<a name="ln119">}</a>
<a name="ln120"> </a>
<a name="ln121">static int</a>
<a name="ln122">bgp_interface_up (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln123">    vrf_id_t vrf_id)</a>
<a name="ln124">{</a>
<a name="ln125">  struct stream *s;</a>
<a name="ln126">  struct interface *ifp;</a>
<a name="ln127">  struct connected *c;</a>
<a name="ln128">  struct listnode *node, *nnode;</a>
<a name="ln129"> </a>
<a name="ln130">  s = zclient-&gt;ibuf;</a>
<a name="ln131">  ifp = zebra_interface_state_read (s, vrf_id);</a>
<a name="ln132"> </a>
<a name="ln133">  if (! ifp)</a>
<a name="ln134">    return 0;</a>
<a name="ln135"> </a>
<a name="ln136">  if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln137">    zlog_debug(&quot;Zebra rcvd: interface %s up&quot;, ifp-&gt;name);</a>
<a name="ln138"> </a>
<a name="ln139">  for (ALL_LIST_ELEMENTS (ifp-&gt;connected, node, nnode, c))</a>
<a name="ln140">    bgp_connected_add (c);</a>
<a name="ln141"> </a>
<a name="ln142">  return 0;</a>
<a name="ln143">}</a>
<a name="ln144"> </a>
<a name="ln145">static int</a>
<a name="ln146">bgp_interface_down (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln147">    vrf_id_t vrf_id)</a>
<a name="ln148">{</a>
<a name="ln149">  struct stream *s;</a>
<a name="ln150">  struct interface *ifp;</a>
<a name="ln151">  struct connected *c;</a>
<a name="ln152">  struct listnode *node, *nnode;</a>
<a name="ln153"> </a>
<a name="ln154">  s = zclient-&gt;ibuf;</a>
<a name="ln155">  ifp = zebra_interface_state_read (s, vrf_id);</a>
<a name="ln156">  if (! ifp)</a>
<a name="ln157">    return 0;</a>
<a name="ln158"> </a>
<a name="ln159">  if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln160">    zlog_debug(&quot;Zebra rcvd: interface %s down&quot;, ifp-&gt;name);</a>
<a name="ln161"> </a>
<a name="ln162">  for (ALL_LIST_ELEMENTS (ifp-&gt;connected, node, nnode, c))</a>
<a name="ln163">    bgp_connected_delete (c);</a>
<a name="ln164"> </a>
<a name="ln165">  /* Fast external-failover */</a>
<a name="ln166">  {</a>
<a name="ln167">    struct listnode *mnode;</a>
<a name="ln168">    struct bgp *bgp;</a>
<a name="ln169">    struct peer *peer;</a>
<a name="ln170"> </a>
<a name="ln171">    for (ALL_LIST_ELEMENTS_RO (bm-&gt;bgp, mnode, bgp))</a>
<a name="ln172">      {</a>
<a name="ln173">	if (CHECK_FLAG (bgp-&gt;flags, BGP_FLAG_NO_FAST_EXT_FAILOVER))</a>
<a name="ln174">	  continue;</a>
<a name="ln175"> </a>
<a name="ln176">	for (ALL_LIST_ELEMENTS (bgp-&gt;peer, node, nnode, peer))</a>
<a name="ln177">	  {</a>
<a name="ln178">            if (peer-&gt;gtsm_hops != 1 &amp;&amp; peer_ttl (peer) != 1)</a>
<a name="ln179">              continue;</a>
<a name="ln180">            if (ifp == peer-&gt;nexthop.ifp)</a>
<a name="ln181">              BGP_EVENT_ADD (peer, BGP_Stop);</a>
<a name="ln182">	  }</a>
<a name="ln183">      }</a>
<a name="ln184">  }</a>
<a name="ln185"> </a>
<a name="ln186">  return 0;</a>
<a name="ln187">}</a>
<a name="ln188"> </a>
<a name="ln189">static int</a>
<a name="ln190">bgp_interface_address_add (int command, struct zclient *zclient,</a>
<a name="ln191">			   zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln192">{</a>
<a name="ln193">  struct connected *ifc;</a>
<a name="ln194"> </a>
<a name="ln195">  ifc = zebra_interface_address_read (command, zclient-&gt;ibuf, vrf_id);</a>
<a name="ln196"> </a>
<a name="ln197">  if (ifc == NULL)</a>
<a name="ln198">    return 0;</a>
<a name="ln199"> </a>
<a name="ln200">  if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln201">    {</a>
<a name="ln202">      char buf[128];</a>
<a name="ln203">      prefix2str(ifc-&gt;address, buf, sizeof(buf));</a>
<a name="ln204">      zlog_debug(&quot;Zebra rcvd: interface %s address add %s&quot;,</a>
<a name="ln205">		 ifc-&gt;ifp-&gt;name, buf);</a>
<a name="ln206">    }</a>
<a name="ln207"> </a>
<a name="ln208">  if (if_is_operative (ifc-&gt;ifp))</a>
<a name="ln209">    bgp_connected_add (ifc);</a>
<a name="ln210"> </a>
<a name="ln211">  return 0;</a>
<a name="ln212">}</a>
<a name="ln213"> </a>
<a name="ln214">static int</a>
<a name="ln215">bgp_interface_address_delete (int command, struct zclient *zclient,</a>
<a name="ln216">			      zebra_size_t length, vrf_id_t vrf_id)</a>
<a name="ln217">{</a>
<a name="ln218">  struct connected *ifc;</a>
<a name="ln219"> </a>
<a name="ln220">  ifc = zebra_interface_address_read (command, zclient-&gt;ibuf, vrf_id);</a>
<a name="ln221"> </a>
<a name="ln222">  if (ifc == NULL)</a>
<a name="ln223">    return 0;</a>
<a name="ln224"> </a>
<a name="ln225">  if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln226">    {</a>
<a name="ln227">      char buf[128];</a>
<a name="ln228">      prefix2str(ifc-&gt;address, buf, sizeof(buf));</a>
<a name="ln229">      zlog_debug(&quot;Zebra rcvd: interface %s address delete %s&quot;,</a>
<a name="ln230">		 ifc-&gt;ifp-&gt;name, buf);</a>
<a name="ln231">    }</a>
<a name="ln232"> </a>
<a name="ln233">  if (if_is_operative (ifc-&gt;ifp))</a>
<a name="ln234">    bgp_connected_delete (ifc);</a>
<a name="ln235"> </a>
<a name="ln236">  connected_free (ifc);</a>
<a name="ln237"> </a>
<a name="ln238">  return 0;</a>
<a name="ln239">}</a>
<a name="ln240"> </a>
<a name="ln241">/* Zebra route add and delete treatment. */</a>
<a name="ln242">static int</a>
<a name="ln243">zebra_read_ipv4 (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln244">    vrf_id_t vrf_id)</a>
<a name="ln245">{</a>
<a name="ln246">  struct stream *s;</a>
<a name="ln247">  struct zapi_ipv4 api;</a>
<a name="ln248">  struct in_addr nexthop;</a>
<a name="ln249">  struct prefix_ipv4 p;</a>
<a name="ln250">  unsigned char plength = 0;</a>
<a name="ln251"> </a>
<a name="ln252">  s = zclient-&gt;ibuf;</a>
<a name="ln253">  nexthop.s_addr = 0;</a>
<a name="ln254"> </a>
<a name="ln255">  /* Type, flags, message. */</a>
<a name="ln256">  api.type = stream_getc (s);</a>
<a name="ln257">  api.flags = stream_getc (s);</a>
<a name="ln258">  api.message = stream_getc (s);</a>
<a name="ln259"> </a>
<a name="ln260">  /* IPv4 prefix. */</a>
<a name="ln261">  memset (&amp;p, 0, sizeof (struct prefix_ipv4));</a>
<a name="ln262">  p.family = AF_INET;</a>
<a name="ln263">  plength = stream_getc (s);</a>
<a name="ln264">  p.prefixlen = MIN(IPV4_MAX_PREFIXLEN, plength);</a>
<a name="ln265">  stream_get (&amp;p.prefix, s, PSIZE (p.prefixlen));</a>
<a name="ln266"> </a>
<a name="ln267">  /* Nexthop, ifindex, distance, metric. */</a>
<a name="ln268">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln269">    {</a>
<a name="ln270">      api.nexthop_num = stream_getc (s);</a>
<a name="ln271">      nexthop.s_addr = stream_get_ipv4 (s);</a>
<a name="ln272">    }</a>
<a name="ln273">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))</a>
<a name="ln274">    {</a>
<a name="ln275">      api.ifindex_num = stream_getc (s);</a>
<a name="ln276">      stream_getl (s); /* ifindex, unused */</a>
<a name="ln277">    }</a>
<a name="ln278">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln279">    api.distance = stream_getc (s);</a>
<a name="ln280">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln281">    api.metric = stream_getl (s);</a>
<a name="ln282">  else</a>
<a name="ln283">    api.metric = 0;</a>
<a name="ln284"> </a>
<a name="ln285">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_TAG))</a>
<a name="ln286">    api.tag = stream_getl (s);</a>
<a name="ln287">  else</a>
<a name="ln288">    api.tag = 0;</a>
<a name="ln289"> </a>
<a name="ln290">  if (command == ZEBRA_IPV4_ROUTE_ADD)</a>
<a name="ln291">    {</a>
<a name="ln292">      if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln293">	{</a>
<a name="ln294">	  char buf[2][INET_ADDRSTRLEN];</a>
<a name="ln295">	  zlog_debug(&quot;Zebra rcvd: IPv4 route add %s %s/%d nexthop %s metric %u tag %d&quot;,</a>
<a name="ln296">		     zebra_route_string(api.type),</a>
<a name="ln297">		     inet_ntop(AF_INET, &amp;p.prefix, buf[0], sizeof(buf[0])),</a>
<a name="ln298">		     p.prefixlen,</a>
<a name="ln299">		     inet_ntop(AF_INET, &amp;nexthop, buf[1], sizeof(buf[1])),</a>
<a name="ln300">		     api.metric,</a>
<a name="ln301">		     api.tag);</a>
<a name="ln302">	}</a>
<a name="ln303">      bgp_redistribute_add ((struct prefix *)&amp;p, &amp;nexthop, NULL,</a>
<a name="ln304">			    api.metric, api.type, api.tag);</a>
<a name="ln305">    }</a>
<a name="ln306">  else</a>
<a name="ln307">    {</a>
<a name="ln308">      if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln309">	{</a>
<a name="ln310">	  char buf[2][INET_ADDRSTRLEN];</a>
<a name="ln311">	  zlog_debug(&quot;Zebra rcvd: IPv4 route delete %s %s/%d &quot;</a>
<a name="ln312">		     &quot;nexthop %s metric %u tag %d&quot;,</a>
<a name="ln313">		     zebra_route_string(api.type),</a>
<a name="ln314">		     inet_ntop(AF_INET, &amp;p.prefix, buf[0], sizeof(buf[0])),</a>
<a name="ln315">		     p.prefixlen,</a>
<a name="ln316">		     inet_ntop(AF_INET, &amp;nexthop, buf[1], sizeof(buf[1])),</a>
<a name="ln317">		     api.metric,</a>
<a name="ln318">		     api.tag);</a>
<a name="ln319">	}</a>
<a name="ln320">      bgp_redistribute_delete((struct prefix *)&amp;p, api.type);</a>
<a name="ln321">    }</a>
<a name="ln322"> </a>
<a name="ln323">  return 0;</a>
<a name="ln324">}</a>
<a name="ln325"> </a>
<a name="ln326">/* Zebra route add and delete treatment. */</a>
<a name="ln327">static int</a>
<a name="ln328">zebra_read_ipv6 (int command, struct zclient *zclient, zebra_size_t length,</a>
<a name="ln329">    vrf_id_t vrf_id)</a>
<a name="ln330">{</a>
<a name="ln331">  struct stream *s;</a>
<a name="ln332">  struct zapi_ipv6 api;</a>
<a name="ln333">  struct in6_addr nexthop;</a>
<a name="ln334">  struct prefix_ipv6 p;</a>
<a name="ln335">  unsigned char plength = 0;</a>
<a name="ln336"> </a>
<a name="ln337">  s = zclient-&gt;ibuf;</a>
<a name="ln338">  memset (&amp;nexthop, 0, sizeof (struct in6_addr));</a>
<a name="ln339"> </a>
<a name="ln340">  /* Type, flags, message. */</a>
<a name="ln341">  api.type = stream_getc (s);</a>
<a name="ln342">  api.flags = stream_getc (s);</a>
<a name="ln343">  api.message = stream_getc (s);</a>
<a name="ln344"> </a>
<a name="ln345">  /* IPv6 prefix. */</a>
<a name="ln346">  memset (&amp;p, 0, sizeof (struct prefix_ipv6));</a>
<a name="ln347">  p.family = AF_INET6;</a>
<a name="ln348">  plength = stream_getc (s);</a>
<a name="ln349">  p.prefixlen = MIN(IPV6_MAX_PREFIXLEN, plength);</a>
<a name="ln350">  stream_get (&amp;p.prefix, s, PSIZE (p.prefixlen));</a>
<a name="ln351"> </a>
<a name="ln352">  /* Nexthop, ifindex, distance, metric. */</a>
<a name="ln353">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP))</a>
<a name="ln354">    {</a>
<a name="ln355">      api.nexthop_num = stream_getc (s);</a>
<a name="ln356">      stream_get (&amp;nexthop, s, 16);</a>
<a name="ln357">    }</a>
<a name="ln358">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_IFINDEX))</a>
<a name="ln359">    {</a>
<a name="ln360">      api.ifindex_num = stream_getc (s);</a>
<a name="ln361">      stream_getl (s); /* ifindex, unused */</a>
<a name="ln362">    }</a>
<a name="ln363">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_DISTANCE))</a>
<a name="ln364">    api.distance = stream_getc (s);</a>
<a name="ln365">  else</a>
<a name="ln366">    api.distance = 0;</a>
<a name="ln367">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_METRIC))</a>
<a name="ln368">    api.metric = stream_getl (s);</a>
<a name="ln369">  else</a>
<a name="ln370">    api.metric = 0;</a>
<a name="ln371"> </a>
<a name="ln372">  if (CHECK_FLAG (api.message, ZAPI_MESSAGE_TAG))</a>
<a name="ln373">    api.tag = stream_getl (s);</a>
<a name="ln374">  else</a>
<a name="ln375">    api.tag = 0;</a>
<a name="ln376"> </a>
<a name="ln377">  /* Simply ignore link-local address. */</a>
<a name="ln378">  if (IN6_IS_ADDR_LINKLOCAL (&amp;p.prefix))</a>
<a name="ln379">    return 0;</a>
<a name="ln380"> </a>
<a name="ln381">  if (command == ZEBRA_IPV6_ROUTE_ADD)</a>
<a name="ln382">    {</a>
<a name="ln383">      if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln384">	{</a>
<a name="ln385">	  char buf[2][INET6_ADDRSTRLEN];</a>
<a name="ln386">	  zlog_debug(&quot;Zebra rcvd: IPv6 route add %s %s/%d nexthop %s metric %u tag %d&quot;,</a>
<a name="ln387">		     zebra_route_string(api.type),</a>
<a name="ln388">		     inet_ntop(AF_INET6, &amp;p.prefix, buf[0], sizeof(buf[0])),</a>
<a name="ln389">		     p.prefixlen,</a>
<a name="ln390">		     inet_ntop(AF_INET, &amp;nexthop, buf[1], sizeof(buf[1])),</a>
<a name="ln391">		     api.metric,</a>
<a name="ln392">		     api.tag);</a>
<a name="ln393">	}</a>
<a name="ln394">      bgp_redistribute_add ((struct prefix *)&amp;p, NULL, &amp;nexthop,</a>
<a name="ln395">			    api.metric, api.type, api.tag);</a>
<a name="ln396">    }</a>
<a name="ln397">  else</a>
<a name="ln398">    {</a>
<a name="ln399">      if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln400">	{</a>
<a name="ln401">	  char buf[2][INET6_ADDRSTRLEN];</a>
<a name="ln402">	  zlog_debug(&quot;Zebra rcvd: IPv6 route delete %s %s/%d &quot;</a>
<a name="ln403">		     &quot;nexthop %s metric %u tag %d&quot;,</a>
<a name="ln404">		     zebra_route_string(api.type),</a>
<a name="ln405">		     inet_ntop(AF_INET6, &amp;p.prefix, buf[0], sizeof(buf[0])),</a>
<a name="ln406">		     p.prefixlen,</a>
<a name="ln407">		     inet_ntop(AF_INET6, &amp;nexthop, buf[1], sizeof(buf[1])),</a>
<a name="ln408">		     api.metric,</a>
<a name="ln409">		     api.tag);</a>
<a name="ln410">	}</a>
<a name="ln411">      bgp_redistribute_delete ((struct prefix *) &amp;p, api.type);</a>
<a name="ln412">    }</a>
<a name="ln413">  </a>
<a name="ln414">  return 0;</a>
<a name="ln415">}</a>
<a name="ln416"> </a>
<a name="ln417">struct interface *</a>
<a name="ln418">if_lookup_by_ipv4 (struct in_addr *addr)</a>
<a name="ln419">{</a>
<a name="ln420">  struct listnode *ifnode;</a>
<a name="ln421">  struct listnode *cnode;</a>
<a name="ln422">  struct interface *ifp;</a>
<a name="ln423">  struct connected *connected;</a>
<a name="ln424">  struct prefix_ipv4 p;</a>
<a name="ln425">  struct prefix *cp; </a>
<a name="ln426">  </a>
<a name="ln427">  p.family = AF_INET;</a>
<a name="ln428">  p.prefix = *addr;</a>
<a name="ln429">  p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln430"> </a>
<a name="ln431">  for (ALL_LIST_ELEMENTS_RO (iflist, ifnode, ifp))</a>
<a name="ln432">    {</a>
<a name="ln433">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, connected))</a>
<a name="ln434">	{</a>
<a name="ln435">	  cp = connected-&gt;address;</a>
<a name="ln436">	    </a>
<a name="ln437">	  if (cp-&gt;family == AF_INET)</a>
<a name="ln438">	    if (prefix_match (cp, (struct prefix *)&amp;p))</a>
<a name="ln439">	      return ifp;</a>
<a name="ln440">	}</a>
<a name="ln441">    }</a>
<a name="ln442">  return NULL;</a>
<a name="ln443">}</a>
<a name="ln444"> </a>
<a name="ln445">struct interface *</a>
<a name="ln446">if_lookup_by_ipv4_exact (struct in_addr *addr)</a>
<a name="ln447">{</a>
<a name="ln448">  struct listnode *ifnode;</a>
<a name="ln449">  struct listnode *cnode;</a>
<a name="ln450">  struct interface *ifp;</a>
<a name="ln451">  struct connected *connected;</a>
<a name="ln452">  struct prefix *cp; </a>
<a name="ln453">  </a>
<a name="ln454">  for (ALL_LIST_ELEMENTS_RO (iflist, ifnode, ifp))</a>
<a name="ln455">    {</a>
<a name="ln456">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, connected))</a>
<a name="ln457">	{</a>
<a name="ln458">	  cp = connected-&gt;address;</a>
<a name="ln459">	    </a>
<a name="ln460">	  if (cp-&gt;family == AF_INET)</a>
<a name="ln461">	    if (IPV4_ADDR_SAME (&amp;cp-&gt;u.prefix4, addr))</a>
<a name="ln462">	      return ifp;</a>
<a name="ln463">	}</a>
<a name="ln464">    }</a>
<a name="ln465">  return NULL;</a>
<a name="ln466">}</a>
<a name="ln467"> </a>
<a name="ln468">struct interface *</a>
<a name="ln469">if_lookup_by_ipv6 (struct in6_addr *addr)</a>
<a name="ln470">{</a>
<a name="ln471">  struct listnode *ifnode;</a>
<a name="ln472">  struct listnode *cnode;</a>
<a name="ln473">  struct interface *ifp;</a>
<a name="ln474">  struct connected *connected;</a>
<a name="ln475">  struct prefix_ipv6 p;</a>
<a name="ln476">  struct prefix *cp; </a>
<a name="ln477">  </a>
<a name="ln478">  p.family = AF_INET6;</a>
<a name="ln479">  p.prefix = *addr;</a>
<a name="ln480">  p.prefixlen = IPV6_MAX_BITLEN;</a>
<a name="ln481"> </a>
<a name="ln482">  for (ALL_LIST_ELEMENTS_RO (iflist, ifnode, ifp))</a>
<a name="ln483">    {</a>
<a name="ln484">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, connected))</a>
<a name="ln485">	{</a>
<a name="ln486">	  cp = connected-&gt;address;</a>
<a name="ln487">	    </a>
<a name="ln488">	  if (cp-&gt;family == AF_INET6)</a>
<a name="ln489">	    if (prefix_match (cp, (struct prefix *)&amp;p))</a>
<a name="ln490">	      return ifp;</a>
<a name="ln491">	}</a>
<a name="ln492">    }</a>
<a name="ln493">  return NULL;</a>
<a name="ln494">}</a>
<a name="ln495"> </a>
<a name="ln496">struct interface *</a>
<a name="ln497">if_lookup_by_ipv6_exact (struct in6_addr *addr)</a>
<a name="ln498">{</a>
<a name="ln499">  struct listnode *ifnode;</a>
<a name="ln500">  struct listnode *cnode;</a>
<a name="ln501">  struct interface *ifp;</a>
<a name="ln502">  struct connected *connected;</a>
<a name="ln503">  struct prefix *cp; </a>
<a name="ln504"> </a>
<a name="ln505">  for (ALL_LIST_ELEMENTS_RO (iflist, ifnode, ifp))</a>
<a name="ln506">    {</a>
<a name="ln507">      for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, connected))</a>
<a name="ln508">	{</a>
<a name="ln509">	  cp = connected-&gt;address;</a>
<a name="ln510">	    </a>
<a name="ln511">	  if (cp-&gt;family == AF_INET6)</a>
<a name="ln512">	    if (IPV6_ADDR_SAME (&amp;cp-&gt;u.prefix6, addr))</a>
<a name="ln513">	      return ifp;</a>
<a name="ln514">	}</a>
<a name="ln515">    }</a>
<a name="ln516">  return NULL;</a>
<a name="ln517">}</a>
<a name="ln518"> </a>
<a name="ln519">static int</a>
<a name="ln520">if_get_ipv6_global (struct interface *ifp, struct in6_addr *addr)</a>
<a name="ln521">{</a>
<a name="ln522">  struct listnode *cnode;</a>
<a name="ln523">  struct connected *connected;</a>
<a name="ln524">  struct prefix *cp; </a>
<a name="ln525">  </a>
<a name="ln526">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, connected))</a>
<a name="ln527">    {</a>
<a name="ln528">      cp = connected-&gt;address;</a>
<a name="ln529">	    </a>
<a name="ln530">      if (cp-&gt;family == AF_INET6)</a>
<a name="ln531">	if (! IN6_IS_ADDR_LINKLOCAL (&amp;cp-&gt;u.prefix6))</a>
<a name="ln532">	  {</a>
<a name="ln533">	    memcpy (addr, &amp;cp-&gt;u.prefix6, IPV6_MAX_BYTELEN);</a>
<a name="ln534">	    return 1;</a>
<a name="ln535">	  }</a>
<a name="ln536">    }</a>
<a name="ln537">  return 0;</a>
<a name="ln538">}</a>
<a name="ln539"> </a>
<a name="ln540">static int</a>
<a name="ln541">if_get_ipv6_local (struct interface *ifp, struct in6_addr *addr)</a>
<a name="ln542">{</a>
<a name="ln543">  struct listnode *cnode;</a>
<a name="ln544">  struct connected *connected;</a>
<a name="ln545">  struct prefix *cp; </a>
<a name="ln546">  </a>
<a name="ln547">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, connected))</a>
<a name="ln548">    {</a>
<a name="ln549">      cp = connected-&gt;address;</a>
<a name="ln550">	    </a>
<a name="ln551">      if (cp-&gt;family == AF_INET6)</a>
<a name="ln552">	if (IN6_IS_ADDR_LINKLOCAL (&amp;cp-&gt;u.prefix6))</a>
<a name="ln553">	  {</a>
<a name="ln554">	    memcpy (addr, &amp;cp-&gt;u.prefix6, IPV6_MAX_BYTELEN);</a>
<a name="ln555">	    return 1;</a>
<a name="ln556">	  }</a>
<a name="ln557">    }</a>
<a name="ln558">  return 0;</a>
<a name="ln559">}</a>
<a name="ln560"> </a>
<a name="ln561">static int</a>
<a name="ln562">if_get_ipv4_address (struct interface *ifp, struct in_addr *addr)</a>
<a name="ln563">{</a>
<a name="ln564">  struct listnode *cnode;</a>
<a name="ln565">  struct connected *connected;</a>
<a name="ln566">  struct prefix *cp;</a>
<a name="ln567"> </a>
<a name="ln568">  for (ALL_LIST_ELEMENTS_RO (ifp-&gt;connected, cnode, connected))</a>
<a name="ln569">    {</a>
<a name="ln570">      cp = connected-&gt;address;</a>
<a name="ln571">      if ((cp-&gt;family == AF_INET) &amp;&amp; !ipv4_martian(&amp;(cp-&gt;u.prefix4)))</a>
<a name="ln572">	  {</a>
<a name="ln573">	    *addr = cp-&gt;u.prefix4;</a>
<a name="ln574">	    return 1;</a>
<a name="ln575">	  }</a>
<a name="ln576">    }</a>
<a name="ln577">  return 0;</a>
<a name="ln578">}</a>
<a name="ln579"> </a>
<a name="ln580">int</a>
<a name="ln581">bgp_nexthop_set (union sockunion *local, union sockunion *remote, </a>
<a name="ln582">		 struct bgp_nexthop *nexthop, struct peer *peer)</a>
<a name="ln583">{</a>
<a name="ln584">  int ret = 0;</a>
<a name="ln585">  struct interface *ifp = NULL;</a>
<a name="ln586"> </a>
<a name="ln587">  memset (nexthop, 0, sizeof (struct bgp_nexthop));</a>
<a name="ln588"> </a>
<a name="ln589">  if (!local)</a>
<a name="ln590">    return -1;</a>
<a name="ln591">  if (!remote)</a>
<a name="ln592">    return -1;</a>
<a name="ln593"> </a>
<a name="ln594">  if (local-&gt;sa.sa_family == AF_INET)</a>
<a name="ln595">    {</a>
<a name="ln596">      nexthop-&gt;v4 = local-&gt;sin.sin_addr;</a>
<a name="ln597">      if (peer-&gt;update_if)</a>
<a name="ln598">        ifp = if_lookup_by_name (peer-&gt;update_if);</a>
<a name="ln599">      else</a>
<a name="ln600">        ifp = if_lookup_by_ipv4_exact (&amp;local-&gt;sin.sin_addr);</a>
<a name="ln601">    }</a>
<a name="ln602">  if (local-&gt;sa.sa_family == AF_INET6)</a>
<a name="ln603">    {</a>
<a name="ln604">      if (IN6_IS_ADDR_LINKLOCAL (&amp;local-&gt;sin6.sin6_addr))</a>
<a name="ln605">	{</a>
<a name="ln606">	  if (peer-&gt;ifname)</a>
<a name="ln607">	    ifp = if_lookup_by_name (peer-&gt;ifname);</a>
<a name="ln608">	}</a>
<a name="ln609">      else if (peer-&gt;update_if)</a>
<a name="ln610">        ifp = if_lookup_by_name (peer-&gt;update_if);</a>
<a name="ln611">      else</a>
<a name="ln612">        ifp = if_lookup_by_ipv6_exact (&amp;local-&gt;sin6.sin6_addr);</a>
<a name="ln613">    }</a>
<a name="ln614"> </a>
<a name="ln615">  if (!ifp)</a>
<a name="ln616">    return -1;</a>
<a name="ln617"> </a>
<a name="ln618">  nexthop-&gt;ifp = ifp;</a>
<a name="ln619"> </a>
<a name="ln620">  /* IPv4 connection. */</a>
<a name="ln621">  if (local-&gt;sa.sa_family == AF_INET)</a>
<a name="ln622">    {</a>
<a name="ln623">      /* IPv6 nexthop*/</a>
<a name="ln624">      ret = if_get_ipv6_global (ifp, &amp;nexthop-&gt;v6_global);</a>
<a name="ln625"> </a>
<a name="ln626">      /* There is no global nexthop. */</a>
<a name="ln627">      if (!ret)</a>
<a name="ln628">	if_get_ipv6_local (ifp, &amp;nexthop-&gt;v6_global);</a>
<a name="ln629">      else</a>
<a name="ln630">	if_get_ipv6_local (ifp, &amp;nexthop-&gt;v6_local);</a>
<a name="ln631">    }</a>
<a name="ln632"> </a>
<a name="ln633">  /* IPv6 connection. */</a>
<a name="ln634">  if (local-&gt;sa.sa_family == AF_INET6)</a>
<a name="ln635">    {</a>
<a name="ln636">      struct interface *direct = NULL;</a>
<a name="ln637"> </a>
<a name="ln638">      /* IPv4 nexthop. */</a>
<a name="ln639">      ret = if_get_ipv4_address(ifp, &amp;nexthop-&gt;v4);</a>
<a name="ln640">      if (!ret &amp;&amp; peer-&gt;local_id.s_addr)</a>
<a name="ln641">	nexthop-&gt;v4 = peer-&gt;local_id;</a>
<a name="ln642"> </a>
<a name="ln643">      /* Global address*/</a>
<a name="ln644">      if (! IN6_IS_ADDR_LINKLOCAL (&amp;local-&gt;sin6.sin6_addr))</a>
<a name="ln645">	{</a>
<a name="ln646">	  memcpy (&amp;nexthop-&gt;v6_global, &amp;local-&gt;sin6.sin6_addr, </a>
<a name="ln647">		  IPV6_MAX_BYTELEN);</a>
<a name="ln648"> </a>
<a name="ln649">	  /* If directory connected set link-local address. */</a>
<a name="ln650">	  direct = if_lookup_by_ipv6 (&amp;remote-&gt;sin6.sin6_addr);</a>
<a name="ln651">	  if (direct)</a>
<a name="ln652">	    if_get_ipv6_local (ifp, &amp;nexthop-&gt;v6_local);</a>
<a name="ln653">	}</a>
<a name="ln654">      else</a>
<a name="ln655">	/* Link-local address. */</a>
<a name="ln656">	{</a>
<a name="ln657">	  ret = if_get_ipv6_global (ifp, &amp;nexthop-&gt;v6_global);</a>
<a name="ln658"> </a>
<a name="ln659">	  /* If there is no global address.  Set link-local address as</a>
<a name="ln660">             global.  I know this break RFC specification... */</a>
<a name="ln661">	  if (!ret)</a>
<a name="ln662">	    memcpy (&amp;nexthop-&gt;v6_global, &amp;local-&gt;sin6.sin6_addr, </a>
<a name="ln663">		    IPV6_MAX_BYTELEN);</a>
<a name="ln664">	  else</a>
<a name="ln665">	    memcpy (&amp;nexthop-&gt;v6_local, &amp;local-&gt;sin6.sin6_addr, </a>
<a name="ln666">		    IPV6_MAX_BYTELEN);</a>
<a name="ln667">	}</a>
<a name="ln668">    }</a>
<a name="ln669"> </a>
<a name="ln670">  if (IN6_IS_ADDR_LINKLOCAL (&amp;local-&gt;sin6.sin6_addr) ||</a>
<a name="ln671">      if_lookup_by_ipv6 (&amp;remote-&gt;sin6.sin6_addr))</a>
<a name="ln672">    peer-&gt;shared_network = 1;</a>
<a name="ln673">  else</a>
<a name="ln674">    peer-&gt;shared_network = 0;</a>
<a name="ln675"> </a>
<a name="ln676">  /* KAME stack specific treatment.  */</a>
<a name="ln677">#ifdef KAME</a>
<a name="ln678">  if (IN6_IS_ADDR_LINKLOCAL (&amp;nexthop-&gt;v6_global)</a>
<a name="ln679">      &amp;&amp; IN6_LINKLOCAL_IFINDEX (nexthop-&gt;v6_global))</a>
<a name="ln680">    {</a>
<a name="ln681">      SET_IN6_LINKLOCAL_IFINDEX (nexthop-&gt;v6_global, 0);</a>
<a name="ln682">    }</a>
<a name="ln683">  if (IN6_IS_ADDR_LINKLOCAL (&amp;nexthop-&gt;v6_local)</a>
<a name="ln684">      &amp;&amp; IN6_LINKLOCAL_IFINDEX (nexthop-&gt;v6_local))</a>
<a name="ln685">    {</a>
<a name="ln686">      SET_IN6_LINKLOCAL_IFINDEX (nexthop-&gt;v6_local, 0);</a>
<a name="ln687">    }</a>
<a name="ln688">#endif /* KAME */</a>
<a name="ln689">  return ret;</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">void</a>
<a name="ln693">bgp_zebra_announce (struct prefix *p, struct bgp_info *info, struct bgp *bgp, safi_t safi)</a>
<a name="ln694">{</a>
<a name="ln695">  int flags;</a>
<a name="ln696">  u_char distance;</a>
<a name="ln697">  struct peer *peer;</a>
<a name="ln698">  struct bgp_info *mpinfo;</a>
<a name="ln699">  size_t oldsize, newsize;</a>
<a name="ln700">  u_int32_t nhcount;</a>
<a name="ln701">  route_tag_t tag = 0;</a>
<a name="ln702"> </a>
<a name="ln703">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln704">    return;</a>
<a name="ln705"> </a>
<a name="ln706">  if (! vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_BGP], VRF_DEFAULT))</a>
<a name="ln707">    return;</a>
<a name="ln708"> </a>
<a name="ln709">  flags = 0;</a>
<a name="ln710">  peer = info-&gt;peer;</a>
<a name="ln711"> </a>
<a name="ln712">  if ((info-&gt;attr-&gt;extra) &amp;&amp; (info-&gt;attr-&gt;extra-&gt;tag != 0))</a>
<a name="ln713">    tag = info-&gt;attr-&gt;extra-&gt;tag;</a>
<a name="ln714"> </a>
<a name="ln715">  if (peer-&gt;sort == BGP_PEER_IBGP || peer-&gt;sort == BGP_PEER_CONFED)</a>
<a name="ln716">    {</a>
<a name="ln717">      SET_FLAG (flags, ZEBRA_FLAG_IBGP);</a>
<a name="ln718">      SET_FLAG (flags, ZEBRA_FLAG_INTERNAL);</a>
<a name="ln719">    }</a>
<a name="ln720"> </a>
<a name="ln721">  if ((peer-&gt;sort == BGP_PEER_EBGP &amp;&amp; peer_ttl (peer) != 1)</a>
<a name="ln722">      || CHECK_FLAG (peer-&gt;flags, PEER_FLAG_DISABLE_CONNECTED_CHECK))</a>
<a name="ln723">    SET_FLAG (flags, ZEBRA_FLAG_INTERNAL);</a>
<a name="ln724"> </a>
<a name="ln725">  nhcount = 1 + bgp_info_mpath_count (info);</a>
<a name="ln726"> </a>
<a name="ln727">  if (p-&gt;family == AF_INET)</a>
<a name="ln728">    {</a>
<a name="ln729">      struct zapi_ipv4 api;</a>
<a name="ln730">      struct in_addr *nexthop;</a>
<a name="ln731"> </a>
<a name="ln732">      /* resize nexthop buffer size if necessary */</a>
<a name="ln733">      if ((oldsize = stream_get_size (bgp_nexthop_buf)) &lt;</a>
<a name="ln734">          (sizeof (struct in_addr *) * nhcount))</a>
<a name="ln735">        {</a>
<a name="ln736">          newsize = (sizeof (struct in_addr *) * nhcount);</a>
<a name="ln737">          newsize = stream_resize (bgp_nexthop_buf, newsize);</a>
<a name="ln738">          if (newsize == oldsize)</a>
<a name="ln739">            {</a>
<a name="ln740">	          zlog_err (&quot;can't resize nexthop buffer&quot;);</a>
<a name="ln741">	          return;</a>
<a name="ln742">            }</a>
<a name="ln743">        }</a>
<a name="ln744">      stream_reset (bgp_nexthop_buf);</a>
<a name="ln745"> </a>
<a name="ln746">      api.vrf_id = VRF_DEFAULT;</a>
<a name="ln747">      api.flags = flags;</a>
<a name="ln748">      nexthop = &amp;info-&gt;attr-&gt;nexthop;</a>
<a name="ln749">      stream_put (bgp_nexthop_buf, &amp;nexthop, sizeof (struct in_addr *));</a>
<a name="ln750">      for (mpinfo = bgp_info_mpath_first (info); mpinfo;</a>
<a name="ln751">	   mpinfo = bgp_info_mpath_next (mpinfo))</a>
<a name="ln752">	{</a>
<a name="ln753">	  nexthop = &amp;mpinfo-&gt;attr-&gt;nexthop;</a>
<a name="ln754">	  stream_put (bgp_nexthop_buf, &amp;nexthop, sizeof (struct in_addr *));</a>
<a name="ln755">	}</a>
<a name="ln756"> </a>
<a name="ln757">      api.type = ZEBRA_ROUTE_BGP;</a>
<a name="ln758">      api.message = 0;</a>
<a name="ln759">      api.safi = safi;</a>
<a name="ln760">      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln761">      api.nexthop_num = nhcount;</a>
<a name="ln762">      api.nexthop = (struct in_addr **)STREAM_DATA (bgp_nexthop_buf);</a>
<a name="ln763">      api.ifindex_num = 0;</a>
<a name="ln764">      SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);</a>
<a name="ln765">      api.metric = info-&gt;attr-&gt;med;</a>
<a name="ln766"> </a>
<a name="ln767">      if (tag)</a>
<a name="ln768">        {</a>
<a name="ln769">          SET_FLAG (api.message, ZAPI_MESSAGE_TAG);</a>
<a name="ln770">          api.tag = tag;</a>
<a name="ln771">        }</a>
<a name="ln772"> </a>
<a name="ln773">      distance = bgp_distance_apply (p, info, bgp);</a>
<a name="ln774"> </a>
<a name="ln775">      if (distance)</a>
<a name="ln776">	{</a>
<a name="ln777">	  SET_FLAG (api.message, ZAPI_MESSAGE_DISTANCE);</a>
<a name="ln778">	  api.distance = distance;</a>
<a name="ln779">	}</a>
<a name="ln780"> </a>
<a name="ln781">      if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln782">	{</a>
<a name="ln783">	  int i;</a>
<a name="ln784">	  char buf[2][INET_ADDRSTRLEN];</a>
<a name="ln785">	  zlog_debug(&quot;Zebra send: IPv4 route add %s/%d nexthop %s metric %u&quot;</a>
<a name="ln786">	             &quot; tag %u count %d&quot;,</a>
<a name="ln787">		     inet_ntop(AF_INET, &amp;p-&gt;u.prefix4, buf[0], sizeof(buf[0])),</a>
<a name="ln788">		     p-&gt;prefixlen,</a>
<a name="ln789">		     inet_ntop(AF_INET, api.nexthop[0], buf[1], sizeof(buf[1])),</a>
<a name="ln790">		     api.metric, api.tag, api.nexthop_num);</a>
<a name="ln791">	  for (i = 1; i &lt; api.nexthop_num; i++)</a>
<a name="ln792">	    zlog_debug(&quot;Zebra send: IPv4 route add [nexthop %d] %s&quot;,</a>
<a name="ln793">		       i, inet_ntop(AF_INET, api.nexthop[i], buf[1],</a>
<a name="ln794">				    sizeof(buf[1])));</a>
<a name="ln795">	}</a>
<a name="ln796"> </a>
<a name="ln797">      zapi_ipv4_route (ZEBRA_IPV4_ROUTE_ADD, zclient, </a>
<a name="ln798">                       (struct prefix_ipv4 *) p, &amp;api);</a>
<a name="ln799">    }</a>
<a name="ln800"> </a>
<a name="ln801">  /* We have to think about a IPv6 link-local address curse. */</a>
<a name="ln802">  if (p-&gt;family == AF_INET6)</a>
<a name="ln803">    {</a>
<a name="ln804">      ifindex_t ifindex;</a>
<a name="ln805">      struct in6_addr *nexthop;</a>
<a name="ln806">      struct zapi_ipv6 api;</a>
<a name="ln807">      int valid_nh_count = 0;</a>
<a name="ln808"> </a>
<a name="ln809">      /* resize nexthop buffer size if necessary */</a>
<a name="ln810">      if ((oldsize = stream_get_size (bgp_nexthop_buf)) &lt;</a>
<a name="ln811">          (sizeof (struct in6_addr *) * nhcount))</a>
<a name="ln812">        {</a>
<a name="ln813">          newsize = (sizeof (struct in6_addr *) * nhcount);</a>
<a name="ln814">          newsize = stream_resize (bgp_nexthop_buf, newsize);</a>
<a name="ln815">          if (newsize == oldsize)</a>
<a name="ln816">            {</a>
<a name="ln817">              zlog_err (&quot;can't resize nexthop buffer&quot;);</a>
<a name="ln818">              return;</a>
<a name="ln819">            }</a>
<a name="ln820">        }</a>
<a name="ln821">      stream_reset (bgp_nexthop_buf);</a>
<a name="ln822"> </a>
<a name="ln823">      /* resize ifindices buffer size if necessary */</a>
<a name="ln824">      if ((oldsize = stream_get_size (bgp_ifindices_buf)) &lt;</a>
<a name="ln825">          (sizeof (unsigned int) * nhcount))</a>
<a name="ln826">        {</a>
<a name="ln827">          newsize = (sizeof (unsigned int) * nhcount);</a>
<a name="ln828">          newsize = stream_resize (bgp_ifindices_buf, newsize);</a>
<a name="ln829">          if (newsize == oldsize)</a>
<a name="ln830">            {</a>
<a name="ln831">              zlog_err (&quot;can't resize nexthop buffer&quot;);</a>
<a name="ln832">              return;</a>
<a name="ln833">            }</a>
<a name="ln834">        }</a>
<a name="ln835">      stream_reset (bgp_ifindices_buf);</a>
<a name="ln836"> </a>
<a name="ln837">      ifindex = 0;</a>
<a name="ln838">      nexthop = NULL;</a>
<a name="ln839"> </a>
<a name="ln840">      assert (info-&gt;attr-&gt;extra);</a>
<a name="ln841">      </a>
<a name="ln842">      /* Only global address nexthop exists. */</a>
<a name="ln843">      if (info-&gt;attr-&gt;extra-&gt;mp_nexthop_len == 16)</a>
<a name="ln844">	nexthop = &amp;info-&gt;attr-&gt;extra-&gt;mp_nexthop_global;</a>
<a name="ln845">      </a>
<a name="ln846">      /* If both global and link-local address present. */</a>
<a name="ln847">      if (info-&gt;attr-&gt;extra-&gt;mp_nexthop_len == 32)</a>
<a name="ln848">	{</a>
<a name="ln849">	  /* Workaround for Cisco's nexthop bug.  */</a>
<a name="ln850">	  if (IN6_IS_ADDR_UNSPECIFIED (&amp;info-&gt;attr-&gt;extra-&gt;mp_nexthop_global)</a>
<a name="ln851">	      &amp;&amp; peer-&gt;su_remote-&gt;sa.sa_family == AF_INET6)</a>
<a name="ln852">	    nexthop = &amp;peer-&gt;su_remote-&gt;sin6.sin6_addr;</a>
<a name="ln853">	  else</a>
<a name="ln854">	    nexthop = &amp;info-&gt;attr-&gt;extra-&gt;mp_nexthop_local;</a>
<a name="ln855"> </a>
<a name="ln856">	  if (info-&gt;peer-&gt;nexthop.ifp)</a>
<a name="ln857">	    ifindex = info-&gt;peer-&gt;nexthop.ifp-&gt;ifindex;</a>
<a name="ln858">	}</a>
<a name="ln859"> </a>
<a name="ln860">      if (nexthop == NULL)</a>
<a name="ln861">	return;</a>
<a name="ln862"> </a>
<a name="ln863">      if (!ifindex)</a>
<a name="ln864">	{</a>
<a name="ln865">	  if (info-&gt;peer-&gt;ifname)</a>
<a name="ln866">	    ifindex = ifname2ifindex (info-&gt;peer-&gt;ifname);</a>
<a name="ln867">	  else if (info-&gt;peer-&gt;nexthop.ifp)</a>
<a name="ln868">	    ifindex = info-&gt;peer-&gt;nexthop.ifp-&gt;ifindex;</a>
<a name="ln869">	}</a>
<a name="ln870">      stream_put (bgp_nexthop_buf, &amp;nexthop, sizeof (struct in6_addr *));</a>
<a name="ln871">      stream_put (bgp_ifindices_buf, &amp;ifindex, sizeof (unsigned int));</a>
<a name="ln872">      valid_nh_count++;</a>
<a name="ln873"> </a>
<a name="ln874">      for (mpinfo = bgp_info_mpath_first (info); mpinfo;</a>
<a name="ln875">           mpinfo = bgp_info_mpath_next (mpinfo))</a>
<a name="ln876">	{</a>
<a name="ln877">	  ifindex = 0;</a>
<a name="ln878"> </a>
<a name="ln879">          /* Only global address nexthop exists. */</a>
<a name="ln880">          if (mpinfo-&gt;attr-&gt;extra-&gt;mp_nexthop_len == 16)</a>
<a name="ln881">              nexthop = &amp;mpinfo-&gt;attr-&gt;extra-&gt;mp_nexthop_global;</a>
<a name="ln882"> </a>
<a name="ln883">          /* If both global and link-local address present. */</a>
<a name="ln884">	  if (mpinfo-&gt;attr-&gt;extra-&gt;mp_nexthop_len == 32)</a>
<a name="ln885">            {</a>
<a name="ln886">              /* Workaround for Cisco's nexthop bug.  */</a>
<a name="ln887">              if (IN6_IS_ADDR_UNSPECIFIED (&amp;mpinfo-&gt;attr-&gt;extra-&gt;mp_nexthop_global)</a>
<a name="ln888">                  &amp;&amp; mpinfo-&gt;peer-&gt;su_remote-&gt;sa.sa_family == AF_INET6)</a>
<a name="ln889">                {</a>
<a name="ln890">		  nexthop = &amp;mpinfo-&gt;peer-&gt;su_remote-&gt;sin6.sin6_addr;</a>
<a name="ln891">                }</a>
<a name="ln892">              else</a>
<a name="ln893">                {</a>
<a name="ln894">		  nexthop = &amp;mpinfo-&gt;attr-&gt;extra-&gt;mp_nexthop_local;</a>
<a name="ln895">	        }</a>
<a name="ln896"> </a>
<a name="ln897">              if (mpinfo-&gt;peer-&gt;nexthop.ifp)</a>
<a name="ln898">                {</a>
<a name="ln899">                  ifindex = mpinfo-&gt;peer-&gt;nexthop.ifp-&gt;ifindex;</a>
<a name="ln900">                }</a>
<a name="ln901">            }</a>
<a name="ln902"> </a>
<a name="ln903">	  if (nexthop == NULL)</a>
<a name="ln904">	    {</a>
<a name="ln905">	      continue;</a>
<a name="ln906">	    }</a>
<a name="ln907"> </a>
<a name="ln908">          if (!ifindex)</a>
<a name="ln909">	    {</a>
<a name="ln910">	      if (mpinfo-&gt;peer-&gt;ifname)</a>
<a name="ln911">                {</a>
<a name="ln912">		  ifindex = if_nametoindex (mpinfo-&gt;peer-&gt;ifname);</a>
<a name="ln913">		}</a>
<a name="ln914">	      else if (mpinfo-&gt;peer-&gt;nexthop.ifp)</a>
<a name="ln915">		{</a>
<a name="ln916">		  ifindex = mpinfo-&gt;peer-&gt;nexthop.ifp-&gt;ifindex;</a>
<a name="ln917">		}</a>
<a name="ln918">	    }</a>
<a name="ln919"> </a>
<a name="ln920">	  if (ifindex == 0)</a>
<a name="ln921">	    {</a>
<a name="ln922">	      continue;</a>
<a name="ln923">	    }</a>
<a name="ln924"> </a>
<a name="ln925">          stream_put (bgp_nexthop_buf, &amp;nexthop, sizeof (struct in6_addr *));</a>
<a name="ln926">          stream_put (bgp_ifindices_buf, &amp;ifindex, sizeof (unsigned int));</a>
<a name="ln927">          valid_nh_count++;</a>
<a name="ln928">	}</a>
<a name="ln929"> </a>
<a name="ln930">      /* Make Zebra API structure. */</a>
<a name="ln931">      api.vrf_id = VRF_DEFAULT;</a>
<a name="ln932">      api.flags = flags;</a>
<a name="ln933">      api.type = ZEBRA_ROUTE_BGP;</a>
<a name="ln934">      api.message = 0;</a>
<a name="ln935">      api.safi = safi;</a>
<a name="ln936">      SET_FLAG (api.message, ZAPI_MESSAGE_NEXTHOP);</a>
<a name="ln937">      api.nexthop_num = valid_nh_count;</a>
<a name="ln938">      api.nexthop = (struct in6_addr **)STREAM_DATA (bgp_nexthop_buf);</a>
<a name="ln939">      SET_FLAG (api.message, ZAPI_MESSAGE_IFINDEX);</a>
<a name="ln940">      api.ifindex_num = valid_nh_count;</a>
<a name="ln941">      api.ifindex = (ifindex_t *)STREAM_DATA (bgp_ifindices_buf);</a>
<a name="ln942">      SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);</a>
<a name="ln943">      api.metric = info-&gt;attr-&gt;med;</a>
<a name="ln944"> </a>
<a name="ln945">      distance = ipv6_bgp_distance_apply (p, info, bgp);</a>
<a name="ln946"> </a>
<a name="ln947">      if (distance)</a>
<a name="ln948">        {</a>
<a name="ln949">          SET_FLAG (api.message, ZAPI_MESSAGE_DISTANCE);</a>
<a name="ln950">          api.distance = distance;</a>
<a name="ln951">        }</a>
<a name="ln952">      </a>
<a name="ln953">      if (tag)</a>
<a name="ln954">	{</a>
<a name="ln955">	  SET_FLAG (api.message, ZAPI_MESSAGE_TAG);</a>
<a name="ln956">	  api.tag = tag;</a>
<a name="ln957">	}</a>
<a name="ln958"> </a>
<a name="ln959">      if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln960">	{</a>
<a name="ln961">	  char buf[2][INET6_ADDRSTRLEN];</a>
<a name="ln962">	  zlog_debug(&quot;Zebra send: IPv6 route add %s/%d nexthop %s metric %u&quot;</a>
<a name="ln963">                     &quot; tag %u&quot;,</a>
<a name="ln964">		     inet_ntop(AF_INET6, &amp;p-&gt;u.prefix6, buf[0], sizeof(buf[0])),</a>
<a name="ln965">		     p-&gt;prefixlen,</a>
<a name="ln966">		     inet_ntop(AF_INET6, nexthop, buf[1], sizeof(buf[1])),</a>
<a name="ln967">		     api.metric, api.tag);</a>
<a name="ln968">	}</a>
<a name="ln969"> </a>
<a name="ln970">      zapi_ipv6_route (ZEBRA_IPV6_ROUTE_ADD, zclient, </a>
<a name="ln971">                       (struct prefix_ipv6 *) p, &amp;api);</a>
<a name="ln972">    }</a>
<a name="ln973">}</a>
<a name="ln974"> </a>
<a name="ln975">void</a>
<a name="ln976">bgp_zebra_withdraw (struct prefix *p, struct bgp_info *info, safi_t safi)</a>
<a name="ln977">{</a>
<a name="ln978">  int flags;</a>
<a name="ln979">  struct peer *peer;</a>
<a name="ln980"> </a>
<a name="ln981">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln982">    return;</a>
<a name="ln983"> </a>
<a name="ln984">  if (! vrf_bitmap_check (zclient-&gt;redist[ZEBRA_ROUTE_BGP], VRF_DEFAULT))</a>
<a name="ln985">    return;</a>
<a name="ln986"> </a>
<a name="ln987">  peer = info-&gt;peer;</a>
<a name="ln988">  flags = 0;</a>
<a name="ln989"> </a>
<a name="ln990">  if (peer-&gt;sort == BGP_PEER_IBGP)</a>
<a name="ln991">    {</a>
<a name="ln992">      SET_FLAG (flags, ZEBRA_FLAG_INTERNAL);</a>
<a name="ln993">      SET_FLAG (flags, ZEBRA_FLAG_IBGP);</a>
<a name="ln994">    }</a>
<a name="ln995"> </a>
<a name="ln996">  if ((peer-&gt;sort == BGP_PEER_EBGP &amp;&amp; peer_ttl (peer) != 1)</a>
<a name="ln997">      || CHECK_FLAG (peer-&gt;flags, PEER_FLAG_DISABLE_CONNECTED_CHECK))</a>
<a name="ln998">    SET_FLAG (flags, ZEBRA_FLAG_INTERNAL);</a>
<a name="ln999"> </a>
<a name="ln1000">  if (p-&gt;family == AF_INET)</a>
<a name="ln1001">    {</a>
<a name="ln1002">      struct zapi_ipv4 api;</a>
<a name="ln1003"> </a>
<a name="ln1004">      api.vrf_id = VRF_DEFAULT;</a>
<a name="ln1005">      api.flags = flags;</a>
<a name="ln1006"> </a>
<a name="ln1007">      api.type = ZEBRA_ROUTE_BGP;</a>
<a name="ln1008">      api.message = 0;</a>
<a name="ln1009">      api.safi = safi;</a>
<a name="ln1010">      api.nexthop_num = 0;</a>
<a name="ln1011">      api.ifindex_num = 0;</a>
<a name="ln1012">      SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);</a>
<a name="ln1013">      api.metric = info-&gt;attr-&gt;med;</a>
<a name="ln1014"> </a>
<a name="ln1015">      if ((info-&gt;attr-&gt;extra) &amp;&amp; (info-&gt;attr-&gt;extra-&gt;tag != 0))</a>
<a name="ln1016">        {</a>
<a name="ln1017">          SET_FLAG(api.message, ZAPI_MESSAGE_TAG);</a>
<a name="ln1018">          api.tag = info-&gt;attr-&gt;extra-&gt;tag;</a>
<a name="ln1019">        }</a>
<a name="ln1020"> </a>
<a name="ln1021">      if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln1022">	{</a>
<a name="ln1023">	  char buf[2][INET_ADDRSTRLEN];</a>
<a name="ln1024">	  zlog_debug(&quot;Zebra send: IPv4 route delete %s/%d metric %u tag %d&quot;,</a>
<a name="ln1025">		     inet_ntop(AF_INET, &amp;p-&gt;u.prefix4, buf[0], sizeof(buf[0])),</a>
<a name="ln1026">		     p-&gt;prefixlen,</a>
<a name="ln1027">		     api.metric,</a>
<a name="ln1028">		     api.tag);</a>
<a name="ln1029">	}</a>
<a name="ln1030"> </a>
<a name="ln1031">      zapi_ipv4_route (ZEBRA_IPV4_ROUTE_DELETE, zclient, </a>
<a name="ln1032">                       (struct prefix_ipv4 *) p, &amp;api);</a>
<a name="ln1033">    }</a>
<a name="ln1034"> </a>
<a name="ln1035">  /* We have to think about a IPv6 link-local address curse. */</a>
<a name="ln1036">  if (p-&gt;family == AF_INET6)</a>
<a name="ln1037">    {</a>
<a name="ln1038">      struct zapi_ipv6 api;</a>
<a name="ln1039">      </a>
<a name="ln1040">      api.vrf_id = VRF_DEFAULT;</a>
<a name="ln1041">      api.flags = flags;</a>
<a name="ln1042">      api.type = ZEBRA_ROUTE_BGP;</a>
<a name="ln1043">      api.message = 0;</a>
<a name="ln1044">      api.safi = safi;</a>
<a name="ln1045">      api.nexthop_num = 0;</a>
<a name="ln1046">      api.ifindex_num = 0;</a>
<a name="ln1047">      SET_FLAG (api.message, ZAPI_MESSAGE_METRIC);</a>
<a name="ln1048">      api.metric = info-&gt;attr-&gt;med;</a>
<a name="ln1049"> </a>
<a name="ln1050">      if ((info-&gt;attr-&gt;extra) &amp;&amp; (info-&gt;attr-&gt;extra-&gt;tag != 0))</a>
<a name="ln1051">        {</a>
<a name="ln1052">          SET_FLAG(api.message, ZAPI_MESSAGE_TAG);</a>
<a name="ln1053">          api.tag = info-&gt;attr-&gt;extra-&gt;tag;</a>
<a name="ln1054">        }</a>
<a name="ln1055"> </a>
<a name="ln1056">      if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln1057">	{</a>
<a name="ln1058">	  char buf[2][INET6_ADDRSTRLEN];</a>
<a name="ln1059">	  zlog_debug(&quot;Zebra send: IPv6 route delete %s/%d metric %u tag %d&quot;,</a>
<a name="ln1060">		     inet_ntop(AF_INET6, &amp;p-&gt;u.prefix6, buf[0], sizeof(buf[0])),</a>
<a name="ln1061">		     p-&gt;prefixlen,</a>
<a name="ln1062">		     api.metric,</a>
<a name="ln1063">		     api.tag);</a>
<a name="ln1064">	}</a>
<a name="ln1065"> </a>
<a name="ln1066">      zapi_ipv6_route (ZEBRA_IPV6_ROUTE_DELETE, zclient, </a>
<a name="ln1067">                       (struct prefix_ipv6 *) p, &amp;api);</a>
<a name="ln1068">    }</a>
<a name="ln1069">}</a>
<a name="ln1070"> </a>
<a name="ln1071">/* Other routes redistribution into BGP. */</a>
<a name="ln1072">int</a>
<a name="ln1073">bgp_redistribute_set (struct bgp *bgp, afi_t afi, int type)</a>
<a name="ln1074">{</a>
<a name="ln1075">  /* Set flag to BGP instance. */</a>
<a name="ln1076">  bgp-&gt;redist[afi][type] = 1;</a>
<a name="ln1077"> </a>
<a name="ln1078">  /* Return if already redistribute flag is set. */</a>
<a name="ln1079">  if (vrf_bitmap_check (zclient-&gt;redist[type], VRF_DEFAULT))</a>
<a name="ln1080">    return CMD_WARNING;</a>
<a name="ln1081"> </a>
<a name="ln1082">  vrf_bitmap_set (zclient-&gt;redist[type], VRF_DEFAULT);</a>
<a name="ln1083"> </a>
<a name="ln1084">  /* Return if zebra connection is not established. */</a>
<a name="ln1085">  if (zclient-&gt;sock &lt; 0)</a>
<a name="ln1086">    return CMD_WARNING;</a>
<a name="ln1087"> </a>
<a name="ln1088">  if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln1089">    zlog_debug(&quot;Zebra send: redistribute add %s&quot;, zebra_route_string(type));</a>
<a name="ln1090">    </a>
<a name="ln1091">  /* Send distribute add message to zebra. */</a>
<a name="ln1092">  zebra_redistribute_send (ZEBRA_REDISTRIBUTE_ADD, zclient, type, VRF_DEFAULT);</a>
<a name="ln1093"> </a>
<a name="ln1094">  return CMD_SUCCESS;</a>
<a name="ln1095">}</a>
<a name="ln1096"> </a>
<a name="ln1097">/* Redistribute with route-map specification.  */</a>
<a name="ln1098">int</a>
<a name="ln1099">bgp_redistribute_rmap_set (struct bgp *bgp, afi_t afi, int type, </a>
<a name="ln1100">                           const char *name)</a>
<a name="ln1101">{</a>
<a name="ln1102">  if (bgp-&gt;rmap[afi][type].name</a>
<a name="ln1103">      &amp;&amp; (strcmp (bgp-&gt;rmap[afi][type].name, name) == 0))</a>
<a name="ln1104">    return 0;</a>
<a name="ln1105"> </a>
<a name="ln1106">  if (bgp-&gt;rmap[afi][type].name)</a>
<a name="ln1107">    free (bgp-&gt;rmap[afi][type].name);</a>
<a name="ln1108">  bgp-&gt;rmap[afi][type].name = strdup (name);</a>
<a name="ln1109">  bgp-&gt;rmap[afi][type].map = route_map_lookup_by_name (name);</a>
<a name="ln1110"> </a>
<a name="ln1111">  return 1;</a>
<a name="ln1112">}</a>
<a name="ln1113"> </a>
<a name="ln1114">/* Redistribute with metric specification.  */</a>
<a name="ln1115">int</a>
<a name="ln1116">bgp_redistribute_metric_set (struct bgp *bgp, afi_t afi, int type,</a>
<a name="ln1117">			     u_int32_t metric)</a>
<a name="ln1118">{</a>
<a name="ln1119">  if (bgp-&gt;redist_metric_flag[afi][type]</a>
<a name="ln1120">      &amp;&amp; bgp-&gt;redist_metric[afi][type] == metric)</a>
<a name="ln1121">    return 0;</a>
<a name="ln1122"> </a>
<a name="ln1123">  bgp-&gt;redist_metric_flag[afi][type] = 1;</a>
<a name="ln1124">  bgp-&gt;redist_metric[afi][type] = metric;</a>
<a name="ln1125"> </a>
<a name="ln1126">  return 1;</a>
<a name="ln1127">}</a>
<a name="ln1128"> </a>
<a name="ln1129">/* Unset redistribution.  */</a>
<a name="ln1130">int</a>
<a name="ln1131">bgp_redistribute_unset (struct bgp *bgp, afi_t afi, int type)</a>
<a name="ln1132">{</a>
<a name="ln1133">  /* Unset flag from BGP instance. */</a>
<a name="ln1134">  bgp-&gt;redist[afi][type] = 0;</a>
<a name="ln1135"> </a>
<a name="ln1136">  /* Unset route-map. */</a>
<a name="ln1137">  if (bgp-&gt;rmap[afi][type].name)</a>
<a name="ln1138">    free (bgp-&gt;rmap[afi][type].name);</a>
<a name="ln1139">  bgp-&gt;rmap[afi][type].name = NULL;</a>
<a name="ln1140">  bgp-&gt;rmap[afi][type].map = NULL;</a>
<a name="ln1141"> </a>
<a name="ln1142">  /* Unset metric. */</a>
<a name="ln1143">  bgp-&gt;redist_metric_flag[afi][type] = 0;</a>
<a name="ln1144">  bgp-&gt;redist_metric[afi][type] = 0;</a>
<a name="ln1145"> </a>
<a name="ln1146">  /* Return if zebra connection is disabled. */</a>
<a name="ln1147">  if (! vrf_bitmap_check (zclient-&gt;redist[type], VRF_DEFAULT))</a>
<a name="ln1148">    return CMD_WARNING;</a>
<a name="ln1149">  vrf_bitmap_unset (zclient-&gt;redist[type], VRF_DEFAULT);</a>
<a name="ln1150"> </a>
<a name="ln1151">  if (bgp-&gt;redist[AFI_IP][type] == 0 </a>
<a name="ln1152">      &amp;&amp; bgp-&gt;redist[AFI_IP6][type] == 0 </a>
<a name="ln1153">      &amp;&amp; zclient-&gt;sock &gt;= 0)</a>
<a name="ln1154">    {</a>
<a name="ln1155">      /* Send distribute delete message to zebra. */</a>
<a name="ln1156">      if (BGP_DEBUG(zebra, ZEBRA))</a>
<a name="ln1157">	zlog_debug(&quot;Zebra send: redistribute delete %s&quot;,</a>
<a name="ln1158">		   zebra_route_string(type));</a>
<a name="ln1159">      zebra_redistribute_send (ZEBRA_REDISTRIBUTE_DELETE, zclient, type,</a>
<a name="ln1160">                               VRF_DEFAULT);</a>
<a name="ln1161">    }</a>
<a name="ln1162">  </a>
<a name="ln1163">  /* Withdraw redistributed routes from current BGP's routing table. */</a>
<a name="ln1164">  bgp_redistribute_withdraw (bgp, afi, type);</a>
<a name="ln1165"> </a>
<a name="ln1166">  return CMD_SUCCESS;</a>
<a name="ln1167">}</a>
<a name="ln1168"> </a>
<a name="ln1169">void</a>
<a name="ln1170">bgp_zclient_reset (void)</a>
<a name="ln1171">{</a>
<a name="ln1172">  zclient_reset (zclient);</a>
<a name="ln1173">}</a>
<a name="ln1174"> </a>
<a name="ln1175">static void</a>
<a name="ln1176">bgp_zebra_connected (struct zclient *zclient)</a>
<a name="ln1177">{</a>
<a name="ln1178">  zclient_num_connects++;</a>
<a name="ln1179">  zclient_send_requests (zclient, VRF_DEFAULT);</a>
<a name="ln1180">}</a>
<a name="ln1181"> </a>
<a name="ln1182">void</a>
<a name="ln1183">bgp_zebra_init (struct thread_master *master)</a>
<a name="ln1184">{</a>
<a name="ln1185">  zclient_num_connects = 0;</a>
<a name="ln1186"> </a>
<a name="ln1187">  /* Set default values. */</a>
<a name="ln1188">  zclient = zclient_new (master);</a>
<a name="ln1189">  zclient_init (zclient, ZEBRA_ROUTE_BGP);</a>
<a name="ln1190">  zclient-&gt;zebra_connected = bgp_zebra_connected;</a>
<a name="ln1191">  zclient-&gt;router_id_update = bgp_router_id_update;</a>
<a name="ln1192">  zclient-&gt;interface_add = bgp_interface_add;</a>
<a name="ln1193">  zclient-&gt;interface_delete = bgp_interface_delete;</a>
<a name="ln1194">  zclient-&gt;interface_address_add = bgp_interface_address_add;</a>
<a name="ln1195">  zclient-&gt;interface_address_delete = bgp_interface_address_delete;</a>
<a name="ln1196">  zclient-&gt;ipv4_route_add = zebra_read_ipv4;</a>
<a name="ln1197">  zclient-&gt;ipv4_route_delete = zebra_read_ipv4;</a>
<a name="ln1198">  zclient-&gt;interface_up = bgp_interface_up;</a>
<a name="ln1199">  zclient-&gt;interface_down = bgp_interface_down;</a>
<a name="ln1200">  zclient-&gt;ipv6_route_add = zebra_read_ipv6;</a>
<a name="ln1201">  zclient-&gt;ipv6_route_delete = zebra_read_ipv6;</a>
<a name="ln1202">  zclient-&gt;nexthop_update = bgp_read_nexthop_update;</a>
<a name="ln1203"> </a>
<a name="ln1204">  bgp_nexthop_buf = stream_new(BGP_NEXTHOP_BUF_SIZE);</a>
<a name="ln1205">  bgp_ifindices_buf = stream_new(BGP_IFINDICES_BUF_SIZE);</a>
<a name="ln1206">}</a>
<a name="ln1207"> </a>
<a name="ln1208">void</a>
<a name="ln1209">bgp_zebra_destroy(void)</a>
<a name="ln1210">{</a>
<a name="ln1211">  if (zclient == NULL)</a>
<a name="ln1212">    return;</a>
<a name="ln1213">  zclient_stop(zclient);</a>
<a name="ln1214">  zclient_free(zclient);</a>
<a name="ln1215">  zclient = NULL;</a>
<a name="ln1216">}</a>
<a name="ln1217"> </a>
<a name="ln1218">int</a>
<a name="ln1219">bgp_zebra_num_connects(void)</a>
<a name="ln1220">{</a>
<a name="ln1221">  return zclient_num_connects;</a>
<a name="ln1222">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="790"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v614/" target="_blank">V614</a> Potentially uninitialized variable 'api.tag' used. Consider checking the sixth actual argument of the 'zlog_debug' function.</p></div>
<div class="balloon" rel="967"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v614/" target="_blank">V614</a> Potentially uninitialized variable 'api.tag' used. Consider checking the sixth actual argument of the 'zlog_debug' function.</p></div>
<div class="balloon" rel="1028"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v614/" target="_blank">V614</a> Potentially uninitialized variable 'api.tag' used. Consider checking the fifth actual argument of the 'zlog_debug' function.</p></div>
<div class="balloon" rel="1063"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v614/" target="_blank">V614</a> Potentially uninitialized variable 'api.tag' used. Consider checking the fifth actual argument of the 'zlog_debug' function.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
