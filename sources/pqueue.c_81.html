
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pqueue.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* Priority queue functions.</a>
<a name="ln2">   Copyright (C) 2003 Yasuhiro Ohara</a>
<a name="ln3"> </a>
<a name="ln4">This file is part of GNU Zebra.</a>
<a name="ln5"> </a>
<a name="ln6">GNU Zebra is free software; you can redistribute it and/or modify</a>
<a name="ln7">it under the terms of the GNU General Public License as published</a>
<a name="ln8">by the Free Software Foundation; either version 2, or (at your</a>
<a name="ln9">option) any later version.</a>
<a name="ln10"> </a>
<a name="ln11">GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln12">WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln13">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln14">General Public License for more details.</a>
<a name="ln15"> </a>
<a name="ln16">You should have received a copy of the GNU General Public License</a>
<a name="ln17">along with GNU Zebra; see the file COPYING.  If not, write to the</a>
<a name="ln18">Free Software Foundation, Inc., 59 Temple Place - Suite 330,</a>
<a name="ln19">Boston, MA 02111-1307, USA.  */</a>
<a name="ln20"> </a>
<a name="ln21">#include &lt;zebra.h&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;memory.h&quot;</a>
<a name="ln24">#include &quot;pqueue.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">/* priority queue using heap sort */</a>
<a name="ln27"> </a>
<a name="ln28">/* pqueue-&gt;cmp() controls the order of sorting (i.e, ascending or</a>
<a name="ln29">   descending). If you want the left node to move upper of the heap</a>
<a name="ln30">   binary tree, make cmp() to return less than 0.  for example, if cmp</a>
<a name="ln31">   (10, 20) returns -1, the sorting is ascending order. if cmp (10,</a>
<a name="ln32">   20) returns 1, the sorting is descending order. if cmp (10, 20)</a>
<a name="ln33">   returns 0, this library does not do sorting (which will not be what</a>
<a name="ln34">   you want).  To be brief, if the contents of cmp_func (left, right)</a>
<a name="ln35">   is left - right, dequeue () returns the smallest node.  Otherwise</a>
<a name="ln36">   (if the contents is right - left), dequeue () returns the largest</a>
<a name="ln37">   node.  */</a>
<a name="ln38"> </a>
<a name="ln39">#define DATA_SIZE (sizeof (void *))</a>
<a name="ln40">#define PARENT_OF(x) ((x - 1) / 2)</a>
<a name="ln41">#define LEFT_OF(x)  (2 * x + 1)</a>
<a name="ln42">#define RIGHT_OF(x) (2 * x + 2)</a>
<a name="ln43">#define HAVE_CHILD(x,q) (x &lt; (q)-&gt;size / 2)</a>
<a name="ln44"> </a>
<a name="ln45">void</a>
<a name="ln46">trickle_up (int index, struct pqueue *queue)</a>
<a name="ln47">{</a>
<a name="ln48">  void *tmp;</a>
<a name="ln49"> </a>
<a name="ln50">  /* Save current node as tmp node.  */</a>
<a name="ln51">  tmp = queue-&gt;array[index];</a>
<a name="ln52"> </a>
<a name="ln53">  /* Continue until the node reaches top or the place where the parent</a>
<a name="ln54">     node should be upper than the tmp node.  */</a>
<a name="ln55">  while (index &gt; 0 &amp;&amp;</a>
<a name="ln56">         (*queue-&gt;cmp) (tmp, queue-&gt;array[PARENT_OF (index)]) &lt; 0)</a>
<a name="ln57">    {</a>
<a name="ln58">      /* actually trickle up */</a>
<a name="ln59">      queue-&gt;array[index] = queue-&gt;array[PARENT_OF (index)];</a>
<a name="ln60">      if (queue-&gt;update != NULL)</a>
<a name="ln61">	(*queue-&gt;update) (queue-&gt;array[index], index);</a>
<a name="ln62">      index = PARENT_OF (index);</a>
<a name="ln63">    }</a>
<a name="ln64"> </a>
<a name="ln65">  /* Restore the tmp node to appropriate place.  */</a>
<a name="ln66">  queue-&gt;array[index] = tmp;</a>
<a name="ln67">  if (queue-&gt;update != NULL)</a>
<a name="ln68">    (*queue-&gt;update) (tmp, index);</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">void</a>
<a name="ln72">trickle_down (int index, struct pqueue *queue)</a>
<a name="ln73">{</a>
<a name="ln74">  void *tmp;</a>
<a name="ln75">  int which;</a>
<a name="ln76"> </a>
<a name="ln77">  /* Save current node as tmp node.  */</a>
<a name="ln78">  tmp = queue-&gt;array[index];</a>
<a name="ln79"> </a>
<a name="ln80">  /* Continue until the node have at least one (left) child.  */</a>
<a name="ln81">  while (HAVE_CHILD (index, queue))</a>
<a name="ln82">    {</a>
<a name="ln83">      /* If right child exists, and if the right child is more proper</a>
<a name="ln84">         to be moved upper.  */</a>
<a name="ln85">      if (RIGHT_OF (index) &lt; queue-&gt;size &amp;&amp;</a>
<a name="ln86">          (*queue-&gt;cmp) (queue-&gt;array[LEFT_OF (index)],</a>
<a name="ln87">                         queue-&gt;array[RIGHT_OF (index)]) &gt; 0)</a>
<a name="ln88">        which = RIGHT_OF (index);</a>
<a name="ln89">      else</a>
<a name="ln90">        which = LEFT_OF (index);</a>
<a name="ln91"> </a>
<a name="ln92">      /* If the tmp node should be upper than the child, break.  */</a>
<a name="ln93">      if ((*queue-&gt;cmp) (queue-&gt;array[which], tmp) &gt; 0)</a>
<a name="ln94">        break;</a>
<a name="ln95"> </a>
<a name="ln96">      /* Actually trickle down the tmp node.  */</a>
<a name="ln97">      queue-&gt;array[index] = queue-&gt;array[which];</a>
<a name="ln98">       if (queue-&gt;update != NULL)</a>
<a name="ln99">	 (*queue-&gt;update) (queue-&gt;array[index], index);</a>
<a name="ln100">      index = which;</a>
<a name="ln101">    }</a>
<a name="ln102"> </a>
<a name="ln103">  /* Restore the tmp node to appropriate place.  */</a>
<a name="ln104">  queue-&gt;array[index] = tmp;</a>
<a name="ln105">  if (queue-&gt;update != NULL)</a>
<a name="ln106">    (*queue-&gt;update) (tmp, index);</a>
<a name="ln107">}</a>
<a name="ln108"> </a>
<a name="ln109">struct pqueue *</a>
<a name="ln110">pqueue_create (void)</a>
<a name="ln111">{</a>
<a name="ln112">  struct pqueue *queue;</a>
<a name="ln113"> </a>
<a name="ln114">  queue = XCALLOC (MTYPE_PQUEUE, sizeof (struct pqueue));</a>
<a name="ln115"> </a>
<a name="ln116">  queue-&gt;array = XCALLOC (MTYPE_PQUEUE_DATA, </a>
<a name="ln117">                          DATA_SIZE * PQUEUE_INIT_ARRAYSIZE);</a>
<a name="ln118">  queue-&gt;array_size = PQUEUE_INIT_ARRAYSIZE;</a>
<a name="ln119"> </a>
<a name="ln120">  /* By default we want nothing to happen when a node changes. */</a>
<a name="ln121">  queue-&gt;update = NULL;</a>
<a name="ln122">  return queue;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">void</a>
<a name="ln126">pqueue_delete (struct pqueue *queue)</a>
<a name="ln127">{</a>
<a name="ln128">  XFREE (MTYPE_PQUEUE_DATA, queue-&gt;array);</a>
<a name="ln129">  XFREE (MTYPE_PQUEUE, queue);</a>
<a name="ln130">}</a>
<a name="ln131"> </a>
<a name="ln132">static int</a>
<a name="ln133">pqueue_expand (struct pqueue *queue)</a>
<a name="ln134">{</a>
<a name="ln135">  void **newarray;</a>
<a name="ln136"> </a>
<a name="ln137">  newarray = XCALLOC (MTYPE_PQUEUE_DATA, queue-&gt;array_size * DATA_SIZE * 2);</a>
<a name="ln138">  if (newarray == NULL)</a>
<a name="ln139">    return 0;</a>
<a name="ln140"> </a>
<a name="ln141">  memcpy (newarray, queue-&gt;array, queue-&gt;array_size * DATA_SIZE);</a>
<a name="ln142"> </a>
<a name="ln143">  XFREE (MTYPE_PQUEUE_DATA, queue-&gt;array);</a>
<a name="ln144">  queue-&gt;array = newarray;</a>
<a name="ln145">  queue-&gt;array_size *= 2;</a>
<a name="ln146"> </a>
<a name="ln147">  return 1;</a>
<a name="ln148">}</a>
<a name="ln149"> </a>
<a name="ln150">void</a>
<a name="ln151">pqueue_enqueue (void *data, struct pqueue *queue)</a>
<a name="ln152">{</a>
<a name="ln153">  if (queue-&gt;size + 2 &gt;= queue-&gt;array_size &amp;&amp; ! pqueue_expand (queue))</a>
<a name="ln154">    return;</a>
<a name="ln155"> </a>
<a name="ln156">  queue-&gt;array[queue-&gt;size] = data;</a>
<a name="ln157">  if (queue-&gt;update != NULL)</a>
<a name="ln158">    (*queue-&gt;update) (data, queue-&gt;size);</a>
<a name="ln159">  trickle_up (queue-&gt;size, queue);</a>
<a name="ln160">  queue-&gt;size ++;</a>
<a name="ln161">}</a>
<a name="ln162"> </a>
<a name="ln163">void *</a>
<a name="ln164">pqueue_dequeue (struct pqueue *queue)</a>
<a name="ln165">{</a>
<a name="ln166">  void *data = queue-&gt;array[0];</a>
<a name="ln167">  queue-&gt;array[0] =  queue-&gt;array[--queue-&gt;size];</a>
<a name="ln168">  trickle_down (0, queue);</a>
<a name="ln169">  return data;</a>
<a name="ln170">}</a>
<a name="ln171"> </a>
<a name="ln172">void</a>
<a name="ln173">pqueue_remove_at (int index, struct pqueue *queue)</a>
<a name="ln174">{</a>
<a name="ln175">  queue-&gt;array[index] = queue-&gt;array[--queue-&gt;size];</a>
<a name="ln176"> </a>
<a name="ln177">  if (index &gt; 0</a>
<a name="ln178">      &amp;&amp; (*queue-&gt;cmp) (queue-&gt;array[index],</a>
<a name="ln179">                        queue-&gt;array[PARENT_OF(index)]) &lt; 0)</a>
<a name="ln180">    {</a>
<a name="ln181">      trickle_up (index, queue);</a>
<a name="ln182">    }</a>
<a name="ln183">  else</a>
<a name="ln184">    {</a>
<a name="ln185">      trickle_down (index, queue);</a>
<a name="ln186">    }</a>
<a name="ln187">}</a>

</code></pre>
<div class="balloon" rel="7"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
