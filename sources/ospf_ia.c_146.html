
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ospf_ia.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * OSPF inter-area routing.</a>
<a name="ln3"> * Copyright (C) 1999, 2000 Alex Zinin, Toshiaki Takada</a>
<a name="ln4"> *</a>
<a name="ln5"> * This file is part of GNU Zebra.</a>
<a name="ln6"> *</a>
<a name="ln7"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln8"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln9"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln10"> * later version.</a>
<a name="ln11"> *</a>
<a name="ln12"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln13"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln14"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln15"> * General Public License for more details.</a>
<a name="ln16"> *</a>
<a name="ln17"> * You should have received a copy of the GNU General Public License</a>
<a name="ln18"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln19"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln20"> * 02111-1307, USA.</a>
<a name="ln21"> */</a>
<a name="ln22"> </a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;thread.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;hash.h&quot;</a>
<a name="ln29">#include &quot;linklist.h&quot;</a>
<a name="ln30">#include &quot;prefix.h&quot;</a>
<a name="ln31">#include &quot;table.h&quot;</a>
<a name="ln32">#include &quot;log.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;ospfd/ospfd.h&quot;</a>
<a name="ln35">#include &quot;ospfd/ospf_interface.h&quot;</a>
<a name="ln36">#include &quot;ospfd/ospf_ism.h&quot;</a>
<a name="ln37">#include &quot;ospfd/ospf_asbr.h&quot;</a>
<a name="ln38">#include &quot;ospfd/ospf_lsa.h&quot;</a>
<a name="ln39">#include &quot;ospfd/ospf_lsdb.h&quot;</a>
<a name="ln40">#include &quot;ospfd/ospf_neighbor.h&quot;</a>
<a name="ln41">#include &quot;ospfd/ospf_nsm.h&quot;</a>
<a name="ln42">#include &quot;ospfd/ospf_spf.h&quot;</a>
<a name="ln43">#include &quot;ospfd/ospf_route.h&quot;</a>
<a name="ln44">#include &quot;ospfd/ospf_ase.h&quot;</a>
<a name="ln45">#include &quot;ospfd/ospf_abr.h&quot;</a>
<a name="ln46">#include &quot;ospfd/ospf_ia.h&quot;</a>
<a name="ln47">#include &quot;ospfd/ospf_dump.h&quot;</a>
<a name="ln48"> </a>
<a name="ln49">static struct ospf_route *</a>
<a name="ln50">ospf_find_abr_route (struct route_table *rtrs, </a>
<a name="ln51">                     struct prefix_ipv4 *abr,</a>
<a name="ln52">                     struct ospf_area *area)</a>
<a name="ln53">{</a>
<a name="ln54">  struct route_node *rn;</a>
<a name="ln55">  struct ospf_route *or;</a>
<a name="ln56">  struct listnode *node;</a>
<a name="ln57"> </a>
<a name="ln58">  if ((rn = route_node_lookup (rtrs, (struct prefix *) abr)) == NULL)</a>
<a name="ln59">    return NULL;</a>
<a name="ln60"> </a>
<a name="ln61">  route_unlock_node (rn);</a>
<a name="ln62"> </a>
<a name="ln63">  for (ALL_LIST_ELEMENTS_RO ((struct list *) rn-&gt;info, node, or))</a>
<a name="ln64">    if (IPV4_ADDR_SAME (&amp;or-&gt;u.std.area_id, &amp;area-&gt;area_id) </a>
<a name="ln65">        &amp;&amp; (or-&gt;u.std.flags &amp; ROUTER_LSA_BORDER))</a>
<a name="ln66">      return or;</a>
<a name="ln67"> </a>
<a name="ln68">  return NULL;</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">static void</a>
<a name="ln72">ospf_ia_network_route (struct ospf *ospf, struct route_table *rt,</a>
<a name="ln73">		       struct prefix_ipv4 *p, struct ospf_route *new_or,</a>
<a name="ln74">		       struct ospf_route *abr_or)</a>
<a name="ln75">{</a>
<a name="ln76">  struct route_node *rn1;</a>
<a name="ln77">  struct ospf_route *or;</a>
<a name="ln78"> </a>
<a name="ln79">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln80">    zlog_debug (&quot;ospf_ia_network_route(): processing summary route to %s/%d&quot;, </a>
<a name="ln81">	       inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln82"> </a>
<a name="ln83">  /* Find a route to the same dest */</a>
<a name="ln84">  if ((rn1 = route_node_lookup (rt, (struct prefix *) p)))</a>
<a name="ln85">    {</a>
<a name="ln86">      int res;</a>
<a name="ln87"> </a>
<a name="ln88">      route_unlock_node (rn1);</a>
<a name="ln89"> </a>
<a name="ln90">      if ((or = rn1-&gt;info))</a>
<a name="ln91">	{</a>
<a name="ln92">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln93">	    zlog_debug (&quot;ospf_ia_network_route(): &quot;</a>
<a name="ln94">		       &quot;Found a route to the same network&quot;);</a>
<a name="ln95">	  /* Check the existing route. */</a>
<a name="ln96">	  if ((res = ospf_route_cmp (ospf, new_or, or)) &lt; 0)</a>
<a name="ln97">	    {</a>
<a name="ln98">	      /* New route is better, so replace old one. */</a>
<a name="ln99">	      ospf_route_subst (rn1, new_or, abr_or);</a>
<a name="ln100">	    }</a>
<a name="ln101">	  else if (res == 0)</a>
<a name="ln102">	    {</a>
<a name="ln103">	      /* New and old route are equal, so next hops can be added. */</a>
<a name="ln104">	      route_lock_node (rn1);</a>
<a name="ln105">	      ospf_route_copy_nexthops (or, abr_or-&gt;paths);</a>
<a name="ln106">	      route_unlock_node (rn1);</a>
<a name="ln107"> </a>
<a name="ln108">	      /* new route can be deleted, because existing route has been updated. */</a>
<a name="ln109">	      ospf_route_free (new_or);</a>
<a name="ln110">	    }</a>
<a name="ln111">	  else</a>
<a name="ln112">	    {</a>
<a name="ln113">	      /* New route is worse, so free it. */</a>
<a name="ln114">	      ospf_route_free (new_or);</a>
<a name="ln115">	      return;</a>
<a name="ln116">	    }</a>
<a name="ln117">	} /* if (or)*/</a>
<a name="ln118">    } /*if (rn1)*/</a>
<a name="ln119">  else</a>
<a name="ln120">    { /* no route */</a>
<a name="ln121">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln122">	zlog_debug (&quot;ospf_ia_network_route(): add new route to %s/%d&quot;,</a>
<a name="ln123">		   inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln124">      ospf_route_add (rt, p, new_or, abr_or);</a>
<a name="ln125">    }</a>
<a name="ln126">}</a>
<a name="ln127"> </a>
<a name="ln128">static void</a>
<a name="ln129">ospf_ia_router_route (struct ospf *ospf, struct route_table *rtrs,</a>
<a name="ln130">		      struct prefix_ipv4 *p,</a>
<a name="ln131">                      struct ospf_route *new_or, struct ospf_route *abr_or)</a>
<a name="ln132">{</a>
<a name="ln133">  struct ospf_route *or = NULL;</a>
<a name="ln134">  struct route_node *rn;</a>
<a name="ln135">  int ret;</a>
<a name="ln136"> </a>
<a name="ln137">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln138">    zlog_debug (&quot;ospf_ia_router_route(): considering %s/%d&quot;, </a>
<a name="ln139">	       inet_ntoa (p-&gt;prefix), p-&gt;prefixlen);</a>
<a name="ln140">  /* Find a route to the same dest */</a>
<a name="ln141">  rn = route_node_get (rtrs, (struct prefix *) p);</a>
<a name="ln142">   </a>
<a name="ln143">  if (rn-&gt;info == NULL)</a>
<a name="ln144">    /* This is a new route */</a>
<a name="ln145">    rn-&gt;info = list_new ();</a>
<a name="ln146">  else</a>
<a name="ln147">    {</a>
<a name="ln148">      struct ospf_area *or_area;</a>
<a name="ln149">      or_area = ospf_area_lookup_by_area_id (ospf, new_or-&gt;u.std.area_id);</a>
<a name="ln150">      assert (or_area);</a>
<a name="ln151">      /* This is an additional route */</a>
<a name="ln152">      route_unlock_node (rn);</a>
<a name="ln153">      or = ospf_find_asbr_route_through_area (rtrs, p, or_area);</a>
<a name="ln154">    }</a>
<a name="ln155"> </a>
<a name="ln156">  if (or)</a>
<a name="ln157">    {</a>
<a name="ln158">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln159">	zlog_debug (&quot;ospf_ia_router_route(): &quot;</a>
<a name="ln160">		   &quot;a route to the same ABR through the same area exists&quot;);</a>
<a name="ln161">      /* New route is better */</a>
<a name="ln162">      if ((ret = ospf_route_cmp (ospf, new_or, or)) &lt; 0)</a>
<a name="ln163">	{</a>
<a name="ln164">	  listnode_delete (rn-&gt;info, or);</a>
<a name="ln165">	  ospf_route_free (or);</a>
<a name="ln166">	  /* proceed down */</a>
<a name="ln167">	}</a>
<a name="ln168">      /* Routes are the same */</a>
<a name="ln169">      else if (ret == 0)</a>
<a name="ln170">	{</a>
<a name="ln171">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln172">	    zlog_debug (&quot;ospf_ia_router_route(): merging the new route&quot;);</a>
<a name="ln173"> </a>
<a name="ln174">	  ospf_route_copy_nexthops (or, abr_or-&gt;paths);</a>
<a name="ln175">	  ospf_route_free (new_or);</a>
<a name="ln176">	  return;</a>
<a name="ln177">	}</a>
<a name="ln178">      /* New route is worse */</a>
<a name="ln179">      else</a>
<a name="ln180">	{</a>
<a name="ln181">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln182">	    zlog_debug (&quot;ospf_ia_router_route(): skipping the new route&quot;);</a>
<a name="ln183">	  ospf_route_free (new_or);</a>
<a name="ln184">	  return;</a>
<a name="ln185">	}</a>
<a name="ln186">    }</a>
<a name="ln187"> </a>
<a name="ln188">  ospf_route_copy_nexthops (new_or, abr_or-&gt;paths);</a>
<a name="ln189"> </a>
<a name="ln190">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln191">    zlog_debug (&quot;ospf_ia_router_route(): adding the new route&quot;); </a>
<a name="ln192"> </a>
<a name="ln193">  listnode_add (rn-&gt;info, new_or);</a>
<a name="ln194">}</a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">static int</a>
<a name="ln198">process_summary_lsa (struct ospf_area *area, struct route_table *rt,</a>
<a name="ln199">		     struct route_table *rtrs, struct ospf_lsa *lsa)</a>
<a name="ln200">{</a>
<a name="ln201">  struct ospf *ospf = area-&gt;ospf;</a>
<a name="ln202">  struct ospf_area_range *range;</a>
<a name="ln203">  struct ospf_route *abr_or, *new_or;</a>
<a name="ln204">  struct summary_lsa *sl;</a>
<a name="ln205">  struct prefix_ipv4 p, abr;</a>
<a name="ln206">  u_int32_t metric;</a>
<a name="ln207"> </a>
<a name="ln208">  if (lsa == NULL)</a>
<a name="ln209">    return 0;</a>
<a name="ln210"> </a>
<a name="ln211">  sl = (struct summary_lsa *) lsa-&gt;data;</a>
<a name="ln212"> </a>
<a name="ln213">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln214">    zlog_debug (&quot;process_summary_lsa(): LS ID: %s&quot;, inet_ntoa (sl-&gt;header.id));</a>
<a name="ln215"> </a>
<a name="ln216">  metric = GET_METRIC (sl-&gt;metric);</a>
<a name="ln217">   </a>
<a name="ln218">  if (metric == OSPF_LS_INFINITY)</a>
<a name="ln219">    return 0;</a>
<a name="ln220"> </a>
<a name="ln221">  if (IS_LSA_MAXAGE (lsa))</a>
<a name="ln222">    return 0;</a>
<a name="ln223"> </a>
<a name="ln224">  if (ospf_lsa_is_self_originated (area-&gt;ospf, lsa))</a>
<a name="ln225">    return 0;</a>
<a name="ln226"> </a>
<a name="ln227">  p.family = AF_INET;</a>
<a name="ln228">  p.prefix = sl-&gt;header.id;</a>
<a name="ln229">   </a>
<a name="ln230">  if (sl-&gt;header.type == OSPF_SUMMARY_LSA)</a>
<a name="ln231">    p.prefixlen = ip_masklen (sl-&gt;mask);</a>
<a name="ln232">  else</a>
<a name="ln233">    p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln234">      </a>
<a name="ln235">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln236"> </a>
<a name="ln237">  if (sl-&gt;header.type == OSPF_SUMMARY_LSA &amp;&amp;</a>
<a name="ln238">      (range = ospf_area_range_match_any (ospf, &amp;p)) &amp;&amp;</a>
<a name="ln239">      ospf_area_range_active (range))</a>
<a name="ln240">    return 0;</a>
<a name="ln241"> </a>
<a name="ln242">  /* XXX: This check seems dubious to me. If an ABR has already decided</a>
<a name="ln243">   * to consider summaries received in this area, then why would one wish</a>
<a name="ln244">   * to exclude default? </a>
<a name="ln245">   */</a>
<a name="ln246">  if (IS_OSPF_ABR(ospf) &amp;&amp; </a>
<a name="ln247">      ospf-&gt;abr_type != OSPF_ABR_STAND &amp;&amp;</a>
<a name="ln248">      area-&gt;external_routing != OSPF_AREA_DEFAULT &amp;&amp;</a>
<a name="ln249">      p.prefix.s_addr == OSPF_DEFAULT_DESTINATION &amp;&amp;</a>
<a name="ln250">      p.prefixlen == 0)</a>
<a name="ln251">    return 0; /* Ignore summary default from a stub area */</a>
<a name="ln252"> </a>
<a name="ln253">  abr.family = AF_INET;</a>
<a name="ln254">  abr.prefix = sl-&gt;header.adv_router;</a>
<a name="ln255">  abr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln256">  apply_mask_ipv4 (&amp;abr);</a>
<a name="ln257"> </a>
<a name="ln258">  abr_or = ospf_find_abr_route (rtrs, &amp;abr, area);</a>
<a name="ln259"> </a>
<a name="ln260">  if (abr_or == NULL)</a>
<a name="ln261">    return 0;</a>
<a name="ln262"> </a>
<a name="ln263">  new_or = ospf_route_new ();</a>
<a name="ln264">  new_or-&gt;type = OSPF_DESTINATION_NETWORK;</a>
<a name="ln265">  new_or-&gt;id = sl-&gt;header.id;</a>
<a name="ln266">  new_or-&gt;mask = sl-&gt;mask;</a>
<a name="ln267">  new_or-&gt;u.std.options = sl-&gt;header.options;</a>
<a name="ln268">  new_or-&gt;u.std.origin = (struct lsa_header *) sl;</a>
<a name="ln269">  new_or-&gt;cost = abr_or-&gt;cost + metric;</a>
<a name="ln270">  new_or-&gt;u.std.area_id = area-&gt;area_id;</a>
<a name="ln271">  new_or-&gt;u.std.external_routing = area-&gt;external_routing;</a>
<a name="ln272">  new_or-&gt;path_type = OSPF_PATH_INTER_AREA;</a>
<a name="ln273"> </a>
<a name="ln274">  if (sl-&gt;header.type == OSPF_SUMMARY_LSA)</a>
<a name="ln275">    ospf_ia_network_route (ospf, rt, &amp;p, new_or, abr_or);</a>
<a name="ln276">  else </a>
<a name="ln277">    {</a>
<a name="ln278">      new_or-&gt;type = OSPF_DESTINATION_ROUTER;</a>
<a name="ln279">      new_or-&gt;u.std.flags = ROUTER_LSA_EXTERNAL;</a>
<a name="ln280">      ospf_ia_router_route (ospf, rtrs, &amp;p, new_or, abr_or);</a>
<a name="ln281">    }</a>
<a name="ln282"> </a>
<a name="ln283">  return 0;</a>
<a name="ln284">}</a>
<a name="ln285"> </a>
<a name="ln286">static void</a>
<a name="ln287">ospf_examine_summaries (struct ospf_area *area,</a>
<a name="ln288">			struct route_table *lsdb_rt,</a>
<a name="ln289">                        struct route_table *rt,</a>
<a name="ln290">                        struct route_table *rtrs)</a>
<a name="ln291">{</a>
<a name="ln292">  struct ospf_lsa *lsa;</a>
<a name="ln293">  struct route_node *rn;</a>
<a name="ln294"> </a>
<a name="ln295">  LSDB_LOOP (lsdb_rt, rn, lsa)</a>
<a name="ln296">    process_summary_lsa (area, rt, rtrs, lsa);</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">int</a>
<a name="ln300">ospf_area_is_transit (struct ospf_area *area)</a>
<a name="ln301">{</a>
<a name="ln302">  return (area-&gt;transit == OSPF_TRANSIT_TRUE) ||</a>
<a name="ln303">    ospf_full_virtual_nbrs(area); /* Cisco forgets to set the V-bit :( */</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">static void</a>
<a name="ln307">ospf_update_network_route (struct ospf *ospf,</a>
<a name="ln308">			   struct route_table *rt, </a>
<a name="ln309">                           struct route_table *rtrs,</a>
<a name="ln310">                           struct summary_lsa *lsa,</a>
<a name="ln311">                           struct prefix_ipv4 *p,</a>
<a name="ln312">                           struct ospf_area *area)</a>
<a name="ln313">{</a>
<a name="ln314">  struct route_node *rn;</a>
<a name="ln315">  struct ospf_route *or, *abr_or, *new_or;</a>
<a name="ln316">  struct prefix_ipv4 abr;</a>
<a name="ln317">  u_int32_t cost;</a>
<a name="ln318"> </a>
<a name="ln319">  abr.family = AF_INET;</a>
<a name="ln320">  abr.prefix =lsa-&gt;header.adv_router;</a>
<a name="ln321">  abr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln322">  apply_mask_ipv4 (&amp;abr);</a>
<a name="ln323"> </a>
<a name="ln324">  abr_or = ospf_find_abr_route (rtrs, &amp;abr, area);</a>
<a name="ln325"> </a>
<a name="ln326">  if (abr_or == NULL)</a>
<a name="ln327">    {</a>
<a name="ln328">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln329">	zlog_debug (&quot;ospf_update_network_route(): can't find a route to the ABR&quot;);</a>
<a name="ln330">      return;</a>
<a name="ln331">    }</a>
<a name="ln332"> </a>
<a name="ln333">  cost = abr_or-&gt;cost + GET_METRIC (lsa-&gt;metric);</a>
<a name="ln334"> </a>
<a name="ln335">  rn = route_node_lookup (rt, (struct prefix *) p);</a>
<a name="ln336"> </a>
<a name="ln337">  if (! rn)</a>
<a name="ln338">    {</a>
<a name="ln339">      if (ospf-&gt;abr_type != OSPF_ABR_SHORTCUT)</a>
<a name="ln340">        return; /* Standard ABR can update only already installed</a>
<a name="ln341">                   backbone paths                                       */</a>
<a name="ln342">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln343">	zlog_debug (&quot;ospf_update_network_route(): &quot;</a>
<a name="ln344">		   &quot;Allowing Shortcut ABR to add new route&quot;);</a>
<a name="ln345">      new_or = ospf_route_new ();</a>
<a name="ln346">      new_or-&gt;type = OSPF_DESTINATION_NETWORK;</a>
<a name="ln347">      new_or-&gt;id = lsa-&gt;header.id;</a>
<a name="ln348">      new_or-&gt;mask = lsa-&gt;mask;</a>
<a name="ln349">      new_or-&gt;u.std.options = lsa-&gt;header.options;</a>
<a name="ln350">      new_or-&gt;u.std.origin = (struct lsa_header *) lsa;</a>
<a name="ln351">      new_or-&gt;cost = cost;</a>
<a name="ln352">      new_or-&gt;u.std.area_id = area-&gt;area_id;</a>
<a name="ln353">      new_or-&gt;u.std.external_routing = area-&gt;external_routing;</a>
<a name="ln354">      new_or-&gt;path_type = OSPF_PATH_INTER_AREA;</a>
<a name="ln355">      ospf_route_add (rt, p, new_or, abr_or);</a>
<a name="ln356"> </a>
<a name="ln357">      return;</a>
<a name="ln358">    }</a>
<a name="ln359">  else</a>
<a name="ln360">    {</a>
<a name="ln361">      route_unlock_node (rn);</a>
<a name="ln362">      if (rn-&gt;info == NULL)</a>
<a name="ln363">        return;</a>
<a name="ln364">    }</a>
<a name="ln365"> </a>
<a name="ln366">  or = rn-&gt;info;</a>
<a name="ln367"> </a>
<a name="ln368">  if (or-&gt;path_type != OSPF_PATH_INTRA_AREA &amp;&amp;</a>
<a name="ln369">      or-&gt;path_type != OSPF_PATH_INTER_AREA)</a>
<a name="ln370">    {</a>
<a name="ln371">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln372">	zlog_debug (&quot;ospf_update_network_route(): ERR: path type is wrong&quot;);</a>
<a name="ln373">      return;</a>
<a name="ln374">    }</a>
<a name="ln375"> </a>
<a name="ln376">  if (ospf-&gt;abr_type == OSPF_ABR_SHORTCUT)</a>
<a name="ln377">    {</a>
<a name="ln378">      if (or-&gt;path_type == OSPF_PATH_INTRA_AREA &amp;&amp;</a>
<a name="ln379">	  !OSPF_IS_AREA_ID_BACKBONE (or-&gt;u.std.area_id))</a>
<a name="ln380">	{</a>
<a name="ln381">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln382">	    zlog_debug (&quot;ospf_update_network_route(): Shortcut: &quot;</a>
<a name="ln383">		       &quot;this intra-area path is not backbone&quot;);</a>
<a name="ln384">	  return;</a>
<a name="ln385">	}</a>
<a name="ln386">    }</a>
<a name="ln387">  else   /* Not Shortcut ABR */</a>
<a name="ln388">    {</a>
<a name="ln389">      if (!OSPF_IS_AREA_ID_BACKBONE (or-&gt;u.std.area_id))</a>
<a name="ln390">	{</a>
<a name="ln391">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln392">	    zlog_debug (&quot;ospf_update_network_route(): &quot;</a>
<a name="ln393">		       &quot;route is not BB-associated&quot;);</a>
<a name="ln394">	  return; /* We can update only BB routes */</a>
<a name="ln395">	}</a>
<a name="ln396">    }</a>
<a name="ln397"> </a>
<a name="ln398">  if (or-&gt;cost &lt; cost)</a>
<a name="ln399">    {</a>
<a name="ln400">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln401">	zlog_debug (&quot;ospf_update_network_route(): new route is worse&quot;);</a>
<a name="ln402">      return;</a>
<a name="ln403">    }</a>
<a name="ln404"> </a>
<a name="ln405">  if (or-&gt;cost == cost)</a>
<a name="ln406">    {</a>
<a name="ln407">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln408">	zlog_debug (&quot;ospf_update_network_route(): &quot;</a>
<a name="ln409">		   &quot;new route is same distance, adding nexthops&quot;);</a>
<a name="ln410">      ospf_route_copy_nexthops (or, abr_or-&gt;paths);</a>
<a name="ln411">    }</a>
<a name="ln412"> </a>
<a name="ln413">  if (or-&gt;cost &gt; cost)</a>
<a name="ln414">    {</a>
<a name="ln415">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln416">	zlog_debug (&quot;ospf_update_network_route(): &quot;</a>
<a name="ln417">		   &quot;new route is better, overriding nexthops&quot;);</a>
<a name="ln418">      ospf_route_subst_nexthops (or, abr_or-&gt;paths);</a>
<a name="ln419">      or-&gt;cost = cost;</a>
<a name="ln420"> </a>
<a name="ln421">      if ((ospf-&gt;abr_type == OSPF_ABR_SHORTCUT) &amp;&amp;</a>
<a name="ln422">	  !OSPF_IS_AREA_ID_BACKBONE (or-&gt;u.std.area_id))</a>
<a name="ln423">	{</a>
<a name="ln424">	  or-&gt;path_type = OSPF_PATH_INTER_AREA;</a>
<a name="ln425">	  or-&gt;u.std.area_id = area-&gt;area_id;</a>
<a name="ln426">	  or-&gt;u.std.external_routing = area-&gt;external_routing;</a>
<a name="ln427">          /* Note that we can do this only in Shortcut ABR mode,</a>
<a name="ln428">             because standard ABR must leave the route type and area</a>
<a name="ln429">             unchanged</a>
<a name="ln430">          */</a>
<a name="ln431">        }</a>
<a name="ln432">    }</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">static void</a>
<a name="ln436">ospf_update_router_route (struct ospf *ospf,</a>
<a name="ln437">			  struct route_table *rtrs, </a>
<a name="ln438">                          struct summary_lsa *lsa,</a>
<a name="ln439">                          struct prefix_ipv4 *p,</a>
<a name="ln440">                          struct ospf_area *area)</a>
<a name="ln441">{</a>
<a name="ln442">  struct ospf_route *or, *abr_or, *new_or;</a>
<a name="ln443">  struct prefix_ipv4 abr;</a>
<a name="ln444">  u_int32_t cost;</a>
<a name="ln445"> </a>
<a name="ln446">  abr.family = AF_INET;</a>
<a name="ln447">  abr.prefix = lsa-&gt;header.adv_router;</a>
<a name="ln448">  abr.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln449">  apply_mask_ipv4 (&amp;abr);</a>
<a name="ln450"> </a>
<a name="ln451">  abr_or = ospf_find_abr_route (rtrs, &amp;abr, area);</a>
<a name="ln452"> </a>
<a name="ln453">  if (abr_or == NULL)</a>
<a name="ln454">    {</a>
<a name="ln455">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln456">	zlog_debug (&quot;ospf_update_router_route(): can't find a route to the ABR&quot;);</a>
<a name="ln457">      return;</a>
<a name="ln458">    }</a>
<a name="ln459"> </a>
<a name="ln460">  cost = abr_or-&gt;cost + GET_METRIC (lsa-&gt;metric);</a>
<a name="ln461"> </a>
<a name="ln462">  /* First try to find a backbone path,</a>
<a name="ln463">     because standard ABR can update only BB-associated paths */</a>
<a name="ln464"> </a>
<a name="ln465">  if ((ospf-&gt;backbone == NULL) &amp;&amp;</a>
<a name="ln466">      (ospf-&gt;abr_type != OSPF_ABR_SHORTCUT))</a>
<a name="ln467">     return; /* no BB area, not Shortcut ABR, exiting */</a>
<a name="ln468">  </a>
<a name="ln469">  /* find the backbone route, if possible */</a>
<a name="ln470">  if ((ospf-&gt;backbone == NULL)</a>
<a name="ln471">      || !(or = ospf_find_asbr_route_through_area (rtrs, p, ospf-&gt;backbone)))</a>
<a name="ln472">    {</a>
<a name="ln473">      if (ospf-&gt;abr_type != OSPF_ABR_SHORTCUT)</a>
<a name="ln474"> </a>
<a name="ln475">         /* route to ASBR through the BB not found</a>
<a name="ln476">            the router is not Shortcut ABR, exiting */</a>
<a name="ln477"> </a>
<a name="ln478">          return;</a>
<a name="ln479">      else</a>
<a name="ln480">	/* We're a Shortcut ABR*/</a>
<a name="ln481">	{</a>
<a name="ln482">	  /* Let it either add a new router or update the route</a>
<a name="ln483">	     through the same (non-BB) area. */</a>
<a name="ln484"> </a>
<a name="ln485">	  new_or = ospf_route_new ();</a>
<a name="ln486">	  new_or-&gt;type = OSPF_DESTINATION_ROUTER;</a>
<a name="ln487">	  new_or-&gt;id = lsa-&gt;header.id;</a>
<a name="ln488">	  new_or-&gt;mask = lsa-&gt;mask;</a>
<a name="ln489">	  new_or-&gt;u.std.options = lsa-&gt;header.options;</a>
<a name="ln490">	  new_or-&gt;u.std.origin = (struct lsa_header *)lsa;</a>
<a name="ln491">	  new_or-&gt;cost = cost;</a>
<a name="ln492">	  new_or-&gt;u.std.area_id = area-&gt;area_id;</a>
<a name="ln493">	  new_or-&gt;u.std.external_routing = area-&gt;external_routing;</a>
<a name="ln494">	  new_or-&gt;path_type = OSPF_PATH_INTER_AREA;</a>
<a name="ln495">	  new_or-&gt;u.std.flags = ROUTER_LSA_EXTERNAL;</a>
<a name="ln496">	  ospf_ia_router_route (ospf, rtrs, p, new_or, abr_or);</a>
<a name="ln497"> </a>
<a name="ln498">          return;</a>
<a name="ln499">        }</a>
<a name="ln500">    }</a>
<a name="ln501"> </a>
<a name="ln502">  /* At this point the &quot;or&quot; is always bb-associated */</a>
<a name="ln503"> </a>
<a name="ln504">  if (!(or-&gt;u.std.flags &amp; ROUTER_LSA_EXTERNAL))</a>
<a name="ln505">    {</a>
<a name="ln506">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln507">	zlog_debug (&quot;ospf_upd_router_route(): the remote router is not an ASBR&quot;);</a>
<a name="ln508">      return;</a>
<a name="ln509">    }</a>
<a name="ln510"> </a>
<a name="ln511">  if (or-&gt;path_type != OSPF_PATH_INTRA_AREA &amp;&amp;</a>
<a name="ln512">      or-&gt;path_type != OSPF_PATH_INTER_AREA)</a>
<a name="ln513">    return;</a>
<a name="ln514"> </a>
<a name="ln515">  if (or-&gt;cost &lt; cost)</a>
<a name="ln516">    return;</a>
<a name="ln517"> </a>
<a name="ln518">  else if (or-&gt;cost == cost)</a>
<a name="ln519">    ospf_route_copy_nexthops (or, abr_or-&gt;paths);</a>
<a name="ln520"> </a>
<a name="ln521">  else if (or-&gt;cost &gt; cost)</a>
<a name="ln522">    {</a>
<a name="ln523">      ospf_route_subst_nexthops (or, abr_or-&gt;paths);</a>
<a name="ln524">      or-&gt;cost = cost;</a>
<a name="ln525"> </a>
<a name="ln526">      /* Even if the ABR runs in Shortcut mode, we can't change</a>
<a name="ln527">         the path type and area, because the &quot;or&quot; is always bb-associated</a>
<a name="ln528">         at this point and even Shortcut ABR can't change these attributes */</a>
<a name="ln529">    }</a>
<a name="ln530">}</a>
<a name="ln531"> </a>
<a name="ln532">static int</a>
<a name="ln533">process_transit_summary_lsa (struct ospf_area *area, struct route_table *rt,</a>
<a name="ln534">			     struct route_table *rtrs, struct ospf_lsa *lsa)</a>
<a name="ln535">{</a>
<a name="ln536">  struct ospf *ospf = area-&gt;ospf;</a>
<a name="ln537">  struct summary_lsa *sl;</a>
<a name="ln538">  struct prefix_ipv4 p;</a>
<a name="ln539">  u_int32_t metric;</a>
<a name="ln540"> </a>
<a name="ln541">  if (lsa == NULL)</a>
<a name="ln542">    return 0;</a>
<a name="ln543"> </a>
<a name="ln544">  sl = (struct summary_lsa *) lsa-&gt;data;</a>
<a name="ln545"> </a>
<a name="ln546">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln547">    zlog_debug (&quot;process_transit_summaries(): LS ID: %s&quot;,</a>
<a name="ln548">	       inet_ntoa (lsa-&gt;data-&gt;id));</a>
<a name="ln549">  metric = GET_METRIC (sl-&gt;metric);</a>
<a name="ln550">   </a>
<a name="ln551">  if (metric == OSPF_LS_INFINITY)</a>
<a name="ln552">    {</a>
<a name="ln553">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln554">	zlog_debug (&quot;process_transit_summaries(): metric is infinity, skip&quot;);</a>
<a name="ln555">      return 0;</a>
<a name="ln556">    }</a>
<a name="ln557"> </a>
<a name="ln558">  if (IS_LSA_MAXAGE (lsa))</a>
<a name="ln559">    {</a>
<a name="ln560">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln561">	zlog_debug (&quot;process_transit_summaries(): This LSA is too old&quot;);</a>
<a name="ln562">      return 0;</a>
<a name="ln563">    }</a>
<a name="ln564"> </a>
<a name="ln565">  if (ospf_lsa_is_self_originated (area-&gt;ospf, lsa))</a>
<a name="ln566">    { </a>
<a name="ln567">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln568">	zlog_debug (&quot;process_transit_summaries(): This LSA is mine, skip&quot;);</a>
<a name="ln569">      return 0;</a>
<a name="ln570">    }</a>
<a name="ln571"> </a>
<a name="ln572">  p.family = AF_INET;</a>
<a name="ln573">  p.prefix = sl-&gt;header.id;</a>
<a name="ln574">   </a>
<a name="ln575">  if (sl-&gt;header.type == OSPF_SUMMARY_LSA)</a>
<a name="ln576">    p.prefixlen = ip_masklen (sl-&gt;mask);</a>
<a name="ln577">  else</a>
<a name="ln578">    p.prefixlen = IPV4_MAX_BITLEN;</a>
<a name="ln579">      </a>
<a name="ln580">  apply_mask_ipv4 (&amp;p);</a>
<a name="ln581"> </a>
<a name="ln582">  if (sl-&gt;header.type == OSPF_SUMMARY_LSA)</a>
<a name="ln583">    ospf_update_network_route (ospf, rt, rtrs, sl, &amp;p, area);</a>
<a name="ln584">  else</a>
<a name="ln585">    ospf_update_router_route (ospf, rtrs, sl, &amp;p, area);</a>
<a name="ln586"> </a>
<a name="ln587">  return 0;</a>
<a name="ln588">}</a>
<a name="ln589"> </a>
<a name="ln590">static void</a>
<a name="ln591">ospf_examine_transit_summaries (struct ospf_area *area,</a>
<a name="ln592">				struct route_table *lsdb_rt,</a>
<a name="ln593">                                struct route_table *rt,</a>
<a name="ln594">                                struct route_table *rtrs)</a>
<a name="ln595">{</a>
<a name="ln596">  struct ospf_lsa *lsa;</a>
<a name="ln597">  struct route_node *rn;</a>
<a name="ln598"> </a>
<a name="ln599">  LSDB_LOOP (lsdb_rt, rn, lsa)</a>
<a name="ln600">    process_transit_summary_lsa (area, rt, rtrs, lsa);</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">void</a>
<a name="ln604">ospf_ia_routing (struct ospf *ospf,</a>
<a name="ln605">		 struct route_table *rt,</a>
<a name="ln606">                 struct route_table *rtrs)</a>
<a name="ln607">{</a>
<a name="ln608">  struct ospf_area * area;</a>
<a name="ln609"> </a>
<a name="ln610">  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln611">    zlog_debug (&quot;ospf_ia_routing():start&quot;);</a>
<a name="ln612"> </a>
<a name="ln613">  if (IS_OSPF_ABR (ospf))</a>
<a name="ln614">    {</a>
<a name="ln615">      struct listnode *node; </a>
<a name="ln616">      struct ospf_area *area;</a>
<a name="ln617"> </a>
<a name="ln618">      switch (ospf-&gt;abr_type)</a>
<a name="ln619">        {</a>
<a name="ln620">        case OSPF_ABR_STAND:</a>
<a name="ln621">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln622">	    zlog_debug (&quot;ospf_ia_routing():Standard ABR&quot;);</a>
<a name="ln623"> </a>
<a name="ln624">          if ((area = ospf-&gt;backbone))</a>
<a name="ln625">            {</a>
<a name="ln626">              struct listnode *node;</a>
<a name="ln627"> </a>
<a name="ln628">	      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln629">		{</a>
<a name="ln630">		  zlog_debug (&quot;ospf_ia_routing():backbone area found&quot;);</a>
<a name="ln631">		  zlog_debug (&quot;ospf_ia_routing():examining summaries&quot;);</a>
<a name="ln632">		}</a>
<a name="ln633"> </a>
<a name="ln634">              OSPF_EXAMINE_SUMMARIES_ALL (area, rt, rtrs);</a>
<a name="ln635"> </a>
<a name="ln636">	      for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln637">                if (area != ospf-&gt;backbone)</a>
<a name="ln638">                  if (ospf_area_is_transit (area))</a>
<a name="ln639">                    OSPF_EXAMINE_TRANSIT_SUMMARIES_ALL (area, rt, rtrs);</a>
<a name="ln640">            }</a>
<a name="ln641">          else</a>
<a name="ln642">	    if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln643">	      zlog_debug (&quot;ospf_ia_routing():backbone area NOT found&quot;);</a>
<a name="ln644">          break;</a>
<a name="ln645">        case OSPF_ABR_IBM:</a>
<a name="ln646">        case OSPF_ABR_CISCO:</a>
<a name="ln647">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln648">	    zlog_debug (&quot;ospf_ia_routing():Alternative Cisco/IBM ABR&quot;);</a>
<a name="ln649">          area = ospf-&gt;backbone; /* Find the BB */</a>
<a name="ln650"> </a>
<a name="ln651">          /* If we have an active BB connection */</a>
<a name="ln652">          if (area &amp;&amp; ospf_act_bb_connection (ospf))</a>
<a name="ln653">            {</a>
<a name="ln654">	      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln655">		{</a>
<a name="ln656">		  zlog_debug (&quot;ospf_ia_routing(): backbone area found&quot;);</a>
<a name="ln657">		  zlog_debug (&quot;ospf_ia_routing(): examining BB summaries&quot;);</a>
<a name="ln658">		}</a>
<a name="ln659"> </a>
<a name="ln660">              OSPF_EXAMINE_SUMMARIES_ALL (area, rt, rtrs);</a>
<a name="ln661"> </a>
<a name="ln662">	      for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln663">                if (area != ospf-&gt;backbone)</a>
<a name="ln664">                  if (ospf_area_is_transit (area))</a>
<a name="ln665">                    OSPF_EXAMINE_TRANSIT_SUMMARIES_ALL (area, rt, rtrs);</a>
<a name="ln666">            }</a>
<a name="ln667">          else</a>
<a name="ln668">            { /* No active BB connection--consider all areas */</a>
<a name="ln669">	      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln670">		zlog_debug (&quot;ospf_ia_routing(): &quot;</a>
<a name="ln671">			   &quot;Active BB connection not found&quot;);</a>
<a name="ln672">	      for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln673">                OSPF_EXAMINE_SUMMARIES_ALL (area, rt, rtrs);</a>
<a name="ln674">            }</a>
<a name="ln675">          break;</a>
<a name="ln676">        case OSPF_ABR_SHORTCUT:</a>
<a name="ln677">	  if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln678">	    zlog_debug (&quot;ospf_ia_routing():Alternative Shortcut&quot;);</a>
<a name="ln679">          area = ospf-&gt;backbone; /* Find the BB */</a>
<a name="ln680"> </a>
<a name="ln681">          /* If we have an active BB connection */</a>
<a name="ln682">          if (area &amp;&amp; ospf_act_bb_connection (ospf))</a>
<a name="ln683">            {</a>
<a name="ln684">	      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln685">		{</a>
<a name="ln686">		  zlog_debug (&quot;ospf_ia_routing(): backbone area found&quot;);</a>
<a name="ln687">		  zlog_debug (&quot;ospf_ia_routing(): examining BB summaries&quot;);</a>
<a name="ln688">		}</a>
<a name="ln689">              OSPF_EXAMINE_SUMMARIES_ALL (area, rt, rtrs);</a>
<a name="ln690">            }</a>
<a name="ln691"> </a>
<a name="ln692">	  for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln693">            if (area != ospf-&gt;backbone)</a>
<a name="ln694">              if (ospf_area_is_transit (area) ||</a>
<a name="ln695">                  ((area-&gt;shortcut_configured != OSPF_SHORTCUT_DISABLE) &amp;&amp;</a>
<a name="ln696">                  ((ospf-&gt;backbone == NULL) ||</a>
<a name="ln697">                  ((area-&gt;shortcut_configured == OSPF_SHORTCUT_ENABLE) &amp;&amp;</a>
<a name="ln698">                  area-&gt;shortcut_capability))))</a>
<a name="ln699">                OSPF_EXAMINE_TRANSIT_SUMMARIES_ALL (area, rt, rtrs);</a>
<a name="ln700">          break;</a>
<a name="ln701">        default:</a>
<a name="ln702">          break;</a>
<a name="ln703">        }</a>
<a name="ln704">    }</a>
<a name="ln705">  else </a>
<a name="ln706">    {</a>
<a name="ln707">      struct listnode *node;</a>
<a name="ln708"> </a>
<a name="ln709">      if (IS_DEBUG_OSPF_EVENT)</a>
<a name="ln710">	zlog_debug (&quot;ospf_ia_routing():not ABR, considering all areas&quot;);</a>
<a name="ln711"> </a>
<a name="ln712">      for (ALL_LIST_ELEMENTS_RO (ospf-&gt;areas, node, area))</a>
<a name="ln713">        OSPF_EXAMINE_SUMMARIES_ALL (area, rt, rtrs);</a>
<a name="ln714">    }</a>
<a name="ln715">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
