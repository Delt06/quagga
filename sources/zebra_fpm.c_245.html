
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>zebra_fpm.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> * Main implementation file for interface to Forwarding Plane Manager.</a>
<a name="ln3"> *</a>
<a name="ln4"> * Copyright (C) 2012 by Open Source Routing.</a>
<a name="ln5"> * Copyright (C) 2012 by Internet Systems Consortium, Inc. (&quot;ISC&quot;)</a>
<a name="ln6"> *</a>
<a name="ln7"> * This file is part of GNU Zebra.</a>
<a name="ln8"> *</a>
<a name="ln9"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln10"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln11"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln12"> * later version.</a>
<a name="ln13"> *</a>
<a name="ln14"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln15"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln16"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln17"> * General Public License for more details.</a>
<a name="ln18"> *</a>
<a name="ln19"> * You should have received a copy of the GNU General Public License</a>
<a name="ln20"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln21"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln22"> * 02111-1307, USA.</a>
<a name="ln23"> */</a>
<a name="ln24"> </a>
<a name="ln25">#include &lt;zebra.h&gt;</a>
<a name="ln26"> </a>
<a name="ln27">#include &quot;log.h&quot;</a>
<a name="ln28">#include &quot;stream.h&quot;</a>
<a name="ln29">#include &quot;thread.h&quot;</a>
<a name="ln30">#include &quot;network.h&quot;</a>
<a name="ln31">#include &quot;command.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;zebra/rib.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;fpm/fpm.h&quot;</a>
<a name="ln36">#include &quot;zebra_fpm.h&quot;</a>
<a name="ln37">#include &quot;zebra_fpm_private.h&quot;</a>
<a name="ln38"> </a>
<a name="ln39">/*</a>
<a name="ln40"> * Interval at which we attempt to connect to the FPM.</a>
<a name="ln41"> */</a>
<a name="ln42">#define ZFPM_CONNECT_RETRY_IVL   5</a>
<a name="ln43"> </a>
<a name="ln44">/*</a>
<a name="ln45"> * Sizes of outgoing and incoming stream buffers for writing/reading</a>
<a name="ln46"> * FPM messages.</a>
<a name="ln47"> */</a>
<a name="ln48">#define ZFPM_OBUF_SIZE (2 * FPM_MAX_MSG_LEN)</a>
<a name="ln49">#define ZFPM_IBUF_SIZE (FPM_MAX_MSG_LEN)</a>
<a name="ln50"> </a>
<a name="ln51">/*</a>
<a name="ln52"> * The maximum number of times the FPM socket write callback can call</a>
<a name="ln53"> * 'write' before it yields.</a>
<a name="ln54"> */</a>
<a name="ln55">#define ZFPM_MAX_WRITES_PER_RUN 10</a>
<a name="ln56"> </a>
<a name="ln57">/*</a>
<a name="ln58"> * Interval over which we collect statistics.</a>
<a name="ln59"> */</a>
<a name="ln60">#define ZFPM_STATS_IVL_SECS        10</a>
<a name="ln61"> </a>
<a name="ln62">/*</a>
<a name="ln63"> * Structure that holds state for iterating over all route_node</a>
<a name="ln64"> * structures that are candidates for being communicated to the FPM.</a>
<a name="ln65"> */</a>
<a name="ln66">typedef struct zfpm_rnodes_iter_t_</a>
<a name="ln67">{</a>
<a name="ln68">  rib_tables_iter_t tables_iter;</a>
<a name="ln69">  route_table_iter_t iter;</a>
<a name="ln70">} zfpm_rnodes_iter_t;</a>
<a name="ln71"> </a>
<a name="ln72">/*</a>
<a name="ln73"> * Statistics.</a>
<a name="ln74"> */</a>
<a name="ln75">typedef struct zfpm_stats_t_ {</a>
<a name="ln76">  unsigned long connect_calls;</a>
<a name="ln77">  unsigned long connect_no_sock;</a>
<a name="ln78"> </a>
<a name="ln79">  unsigned long read_cb_calls;</a>
<a name="ln80"> </a>
<a name="ln81">  unsigned long write_cb_calls;</a>
<a name="ln82">  unsigned long write_calls;</a>
<a name="ln83">  unsigned long partial_writes;</a>
<a name="ln84">  unsigned long max_writes_hit;</a>
<a name="ln85">  unsigned long t_write_yields;</a>
<a name="ln86"> </a>
<a name="ln87">  unsigned long nop_deletes_skipped;</a>
<a name="ln88">  unsigned long route_adds;</a>
<a name="ln89">  unsigned long route_dels;</a>
<a name="ln90"> </a>
<a name="ln91">  unsigned long updates_triggered;</a>
<a name="ln92">  unsigned long redundant_triggers;</a>
<a name="ln93">  unsigned long non_fpm_table_triggers;</a>
<a name="ln94"> </a>
<a name="ln95">  unsigned long dests_del_after_update;</a>
<a name="ln96"> </a>
<a name="ln97">  unsigned long t_conn_down_starts;</a>
<a name="ln98">  unsigned long t_conn_down_dests_processed;</a>
<a name="ln99">  unsigned long t_conn_down_yields;</a>
<a name="ln100">  unsigned long t_conn_down_finishes;</a>
<a name="ln101"> </a>
<a name="ln102">  unsigned long t_conn_up_starts;</a>
<a name="ln103">  unsigned long t_conn_up_dests_processed;</a>
<a name="ln104">  unsigned long t_conn_up_yields;</a>
<a name="ln105">  unsigned long t_conn_up_aborts;</a>
<a name="ln106">  unsigned long t_conn_up_finishes;</a>
<a name="ln107"> </a>
<a name="ln108">} zfpm_stats_t;</a>
<a name="ln109"> </a>
<a name="ln110">/*</a>
<a name="ln111"> * States for the FPM state machine.</a>
<a name="ln112"> */</a>
<a name="ln113">typedef enum {</a>
<a name="ln114"> </a>
<a name="ln115">  /*</a>
<a name="ln116">   * In this state we are not yet ready to connect to the FPM. This</a>
<a name="ln117">   * can happen when this module is disabled, or if we're cleaning up</a>
<a name="ln118">   * after a connection has gone down.</a>
<a name="ln119">   */</a>
<a name="ln120">  ZFPM_STATE_IDLE,</a>
<a name="ln121"> </a>
<a name="ln122">  /*</a>
<a name="ln123">   * Ready to talk to the FPM and periodically trying to connect to</a>
<a name="ln124">   * it.</a>
<a name="ln125">   */</a>
<a name="ln126">  ZFPM_STATE_ACTIVE,</a>
<a name="ln127"> </a>
<a name="ln128">  /*</a>
<a name="ln129">   * In the middle of bringing up a TCP connection. Specifically,</a>
<a name="ln130">   * waiting for a connect() call to complete asynchronously.</a>
<a name="ln131">   */</a>
<a name="ln132">  ZFPM_STATE_CONNECTING,</a>
<a name="ln133"> </a>
<a name="ln134">  /*</a>
<a name="ln135">   * TCP connection to the FPM is up.</a>
<a name="ln136">   */</a>
<a name="ln137">  ZFPM_STATE_ESTABLISHED</a>
<a name="ln138"> </a>
<a name="ln139">} zfpm_state_t;</a>
<a name="ln140"> </a>
<a name="ln141">/*</a>
<a name="ln142"> * Message format to be used to communicate with the FPM.</a>
<a name="ln143"> */</a>
<a name="ln144">typedef enum</a>
<a name="ln145">{</a>
<a name="ln146">  ZFPM_MSG_FORMAT_NONE,</a>
<a name="ln147">  ZFPM_MSG_FORMAT_NETLINK,</a>
<a name="ln148">  ZFPM_MSG_FORMAT_PROTOBUF,</a>
<a name="ln149">} zfpm_msg_format_e;</a>
<a name="ln150">/*</a>
<a name="ln151"> * Globals.</a>
<a name="ln152"> */</a>
<a name="ln153">typedef struct zfpm_glob_t_</a>
<a name="ln154">{</a>
<a name="ln155"> </a>
<a name="ln156">  /*</a>
<a name="ln157">   * True if the FPM module has been enabled.</a>
<a name="ln158">   */</a>
<a name="ln159">  int enabled;</a>
<a name="ln160"> </a>
<a name="ln161">  /*</a>
<a name="ln162">   * Message format to be used to communicate with the fpm.</a>
<a name="ln163">   */</a>
<a name="ln164">  zfpm_msg_format_e message_format;</a>
<a name="ln165"> </a>
<a name="ln166">  struct thread_master *master;</a>
<a name="ln167"> </a>
<a name="ln168">  zfpm_state_t state;</a>
<a name="ln169"> </a>
<a name="ln170">  in_addr_t   fpm_server;</a>
<a name="ln171">  /*</a>
<a name="ln172">   * Port on which the FPM is running.</a>
<a name="ln173">   */</a>
<a name="ln174">  int fpm_port;</a>
<a name="ln175"> </a>
<a name="ln176">  /*</a>
<a name="ln177">   * List of rib_dest_t structures to be processed</a>
<a name="ln178">   */</a>
<a name="ln179">  TAILQ_HEAD (zfpm_dest_q, rib_dest_t_) dest_q;</a>
<a name="ln180"> </a>
<a name="ln181">  /*</a>
<a name="ln182">   * Stream socket to the FPM.</a>
<a name="ln183">   */</a>
<a name="ln184">  int sock;</a>
<a name="ln185"> </a>
<a name="ln186">  /*</a>
<a name="ln187">   * Buffers for messages to/from the FPM.</a>
<a name="ln188">   */</a>
<a name="ln189">  struct stream *obuf;</a>
<a name="ln190">  struct stream *ibuf;</a>
<a name="ln191"> </a>
<a name="ln192">  /*</a>
<a name="ln193">   * Threads for I/O.</a>
<a name="ln194">   */</a>
<a name="ln195">  struct thread *t_connect;</a>
<a name="ln196">  struct thread *t_write;</a>
<a name="ln197">  struct thread *t_read;</a>
<a name="ln198"> </a>
<a name="ln199">  /*</a>
<a name="ln200">   * Thread to clean up after the TCP connection to the FPM goes down</a>
<a name="ln201">   * and the state that belongs to it.</a>
<a name="ln202">   */</a>
<a name="ln203">  struct thread *t_conn_down;</a>
<a name="ln204"> </a>
<a name="ln205">  struct {</a>
<a name="ln206">    zfpm_rnodes_iter_t iter;</a>
<a name="ln207">  } t_conn_down_state;</a>
<a name="ln208"> </a>
<a name="ln209">  /*</a>
<a name="ln210">   * Thread to take actions once the TCP conn to the FPM comes up, and</a>
<a name="ln211">   * the state that belongs to it.</a>
<a name="ln212">   */</a>
<a name="ln213">  struct thread *t_conn_up;</a>
<a name="ln214"> </a>
<a name="ln215">  struct {</a>
<a name="ln216">    zfpm_rnodes_iter_t iter;</a>
<a name="ln217">  } t_conn_up_state;</a>
<a name="ln218"> </a>
<a name="ln219">  unsigned long connect_calls;</a>
<a name="ln220">  time_t last_connect_call_time;</a>
<a name="ln221"> </a>
<a name="ln222">  /*</a>
<a name="ln223">   * Stats from the start of the current statistics interval up to</a>
<a name="ln224">   * now. These are the counters we typically update in the code.</a>
<a name="ln225">   */</a>
<a name="ln226">  zfpm_stats_t stats;</a>
<a name="ln227"> </a>
<a name="ln228">  /*</a>
<a name="ln229">   * Statistics that were gathered in the last collection interval.</a>
<a name="ln230">   */</a>
<a name="ln231">  zfpm_stats_t last_ivl_stats;</a>
<a name="ln232"> </a>
<a name="ln233">  /*</a>
<a name="ln234">   * Cumulative stats from the last clear to the start of the current</a>
<a name="ln235">   * statistics interval.</a>
<a name="ln236">   */</a>
<a name="ln237">  zfpm_stats_t cumulative_stats;</a>
<a name="ln238"> </a>
<a name="ln239">  /*</a>
<a name="ln240">   * Stats interval timer.</a>
<a name="ln241">   */</a>
<a name="ln242">  struct thread *t_stats;</a>
<a name="ln243"> </a>
<a name="ln244">  /*</a>
<a name="ln245">   * If non-zero, the last time when statistics were cleared.</a>
<a name="ln246">   */</a>
<a name="ln247">  time_t last_stats_clear_time;</a>
<a name="ln248"> </a>
<a name="ln249">} zfpm_glob_t;</a>
<a name="ln250"> </a>
<a name="ln251">static zfpm_glob_t zfpm_glob_space;</a>
<a name="ln252">static zfpm_glob_t *zfpm_g = &amp;zfpm_glob_space;</a>
<a name="ln253"> </a>
<a name="ln254">static int zfpm_read_cb (struct thread *thread);</a>
<a name="ln255">static int zfpm_write_cb (struct thread *thread);</a>
<a name="ln256"> </a>
<a name="ln257">static void zfpm_set_state (zfpm_state_t state, const char *reason);</a>
<a name="ln258">static void zfpm_start_connect_timer (const char *reason);</a>
<a name="ln259">static void zfpm_start_stats_timer (void);</a>
<a name="ln260"> </a>
<a name="ln261">/*</a>
<a name="ln262"> * zfpm_thread_should_yield</a>
<a name="ln263"> */</a>
<a name="ln264">static inline int</a>
<a name="ln265">zfpm_thread_should_yield (struct thread *t)</a>
<a name="ln266">{</a>
<a name="ln267">  return thread_should_yield (t);</a>
<a name="ln268">}</a>
<a name="ln269"> </a>
<a name="ln270">/*</a>
<a name="ln271"> * zfpm_state_to_str</a>
<a name="ln272"> */</a>
<a name="ln273">static const char *</a>
<a name="ln274">zfpm_state_to_str (zfpm_state_t state)</a>
<a name="ln275">{</a>
<a name="ln276">  switch (state)</a>
<a name="ln277">    {</a>
<a name="ln278"> </a>
<a name="ln279">    case ZFPM_STATE_IDLE:</a>
<a name="ln280">      return &quot;idle&quot;;</a>
<a name="ln281"> </a>
<a name="ln282">    case ZFPM_STATE_ACTIVE:</a>
<a name="ln283">      return &quot;active&quot;;</a>
<a name="ln284"> </a>
<a name="ln285">    case ZFPM_STATE_CONNECTING:</a>
<a name="ln286">      return &quot;connecting&quot;;</a>
<a name="ln287"> </a>
<a name="ln288">    case ZFPM_STATE_ESTABLISHED:</a>
<a name="ln289">      return &quot;established&quot;;</a>
<a name="ln290"> </a>
<a name="ln291">    default:</a>
<a name="ln292">      return &quot;unknown&quot;;</a>
<a name="ln293">    }</a>
<a name="ln294">}</a>
<a name="ln295"> </a>
<a name="ln296">/*</a>
<a name="ln297"> * zfpm_get_time</a>
<a name="ln298"> */</a>
<a name="ln299">static time_t</a>
<a name="ln300">zfpm_get_time (void)</a>
<a name="ln301">{</a>
<a name="ln302">  struct timeval tv;</a>
<a name="ln303"> </a>
<a name="ln304">  if (quagga_gettime (QUAGGA_CLK_MONOTONIC, &amp;tv) &lt; 0)</a>
<a name="ln305">    zlog_warn (&quot;FPM: quagga_gettime failed!!&quot;);</a>
<a name="ln306"> </a>
<a name="ln307">  return tv.tv_sec;</a>
<a name="ln308">}</a>
<a name="ln309"> </a>
<a name="ln310">/*</a>
<a name="ln311"> * zfpm_get_elapsed_time</a>
<a name="ln312"> *</a>
<a name="ln313"> * Returns the time elapsed (in seconds) since the given time.</a>
<a name="ln314"> */</a>
<a name="ln315">static time_t</a>
<a name="ln316">zfpm_get_elapsed_time (time_t reference)</a>
<a name="ln317">{</a>
<a name="ln318">  time_t now;</a>
<a name="ln319"> </a>
<a name="ln320">  now = zfpm_get_time ();</a>
<a name="ln321"> </a>
<a name="ln322">  if (now &lt; reference)</a>
<a name="ln323">    {</a>
<a name="ln324">      assert (0);</a>
<a name="ln325">      return 0;</a>
<a name="ln326">    }</a>
<a name="ln327"> </a>
<a name="ln328">  return now - reference;</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">/*</a>
<a name="ln332"> * zfpm_is_table_for_fpm</a>
<a name="ln333"> *</a>
<a name="ln334"> * Returns TRUE if the the given table is to be communicated to the</a>
<a name="ln335"> * FPM.</a>
<a name="ln336"> */</a>
<a name="ln337">static inline int</a>
<a name="ln338">zfpm_is_table_for_fpm (struct route_table *table)</a>
<a name="ln339">{</a>
<a name="ln340">  rib_table_info_t *info;</a>
<a name="ln341"> </a>
<a name="ln342">  info = rib_table_info (table);</a>
<a name="ln343"> </a>
<a name="ln344">  /*</a>
<a name="ln345">   * We only send the unicast tables in the main instance to the FPM</a>
<a name="ln346">   * at this point.</a>
<a name="ln347">   */</a>
<a name="ln348">  if (info-&gt;zvrf-&gt;vrf_id != 0)</a>
<a name="ln349">    return 0;</a>
<a name="ln350"> </a>
<a name="ln351">  if (info-&gt;safi != SAFI_UNICAST)</a>
<a name="ln352">    return 0;</a>
<a name="ln353"> </a>
<a name="ln354">  return 1;</a>
<a name="ln355">}</a>
<a name="ln356"> </a>
<a name="ln357">/*</a>
<a name="ln358"> * zfpm_rnodes_iter_init</a>
<a name="ln359"> */</a>
<a name="ln360">static inline void</a>
<a name="ln361">zfpm_rnodes_iter_init (zfpm_rnodes_iter_t *iter)</a>
<a name="ln362">{</a>
<a name="ln363">  memset (iter, 0, sizeof (*iter));</a>
<a name="ln364">  rib_tables_iter_init (&amp;iter-&gt;tables_iter);</a>
<a name="ln365"> </a>
<a name="ln366">  /*</a>
<a name="ln367">   * This is a hack, but it makes implementing 'next' easier by</a>
<a name="ln368">   * ensuring that route_table_iter_next() will return NULL the first</a>
<a name="ln369">   * time we call it.</a>
<a name="ln370">   */</a>
<a name="ln371">  route_table_iter_init (&amp;iter-&gt;iter, NULL);</a>
<a name="ln372">  route_table_iter_cleanup (&amp;iter-&gt;iter);</a>
<a name="ln373">}</a>
<a name="ln374"> </a>
<a name="ln375">/*</a>
<a name="ln376"> * zfpm_rnodes_iter_next</a>
<a name="ln377"> */</a>
<a name="ln378">static inline struct route_node *</a>
<a name="ln379">zfpm_rnodes_iter_next (zfpm_rnodes_iter_t *iter)</a>
<a name="ln380">{</a>
<a name="ln381">  struct route_node *rn;</a>
<a name="ln382">  struct route_table *table;</a>
<a name="ln383"> </a>
<a name="ln384">  while (1)</a>
<a name="ln385">    {</a>
<a name="ln386">      rn = route_table_iter_next (&amp;iter-&gt;iter);</a>
<a name="ln387">      if (rn)</a>
<a name="ln388">	return rn;</a>
<a name="ln389"> </a>
<a name="ln390">      /*</a>
<a name="ln391">       * We've made our way through this table, go to the next one.</a>
<a name="ln392">       */</a>
<a name="ln393">      route_table_iter_cleanup (&amp;iter-&gt;iter);</a>
<a name="ln394"> </a>
<a name="ln395">      while ((table = rib_tables_iter_next (&amp;iter-&gt;tables_iter)))</a>
<a name="ln396">	{</a>
<a name="ln397">	  if (zfpm_is_table_for_fpm (table))</a>
<a name="ln398">	    break;</a>
<a name="ln399">	}</a>
<a name="ln400"> </a>
<a name="ln401">      if (!table)</a>
<a name="ln402">	return NULL;</a>
<a name="ln403"> </a>
<a name="ln404">      route_table_iter_init (&amp;iter-&gt;iter, table);</a>
<a name="ln405">    }</a>
<a name="ln406"> </a>
<a name="ln407">  return NULL;</a>
<a name="ln408">}</a>
<a name="ln409"> </a>
<a name="ln410">/*</a>
<a name="ln411"> * zfpm_rnodes_iter_pause</a>
<a name="ln412"> */</a>
<a name="ln413">static inline void</a>
<a name="ln414">zfpm_rnodes_iter_pause (zfpm_rnodes_iter_t *iter)</a>
<a name="ln415">{</a>
<a name="ln416">  route_table_iter_pause (&amp;iter-&gt;iter);</a>
<a name="ln417">}</a>
<a name="ln418"> </a>
<a name="ln419">/*</a>
<a name="ln420"> * zfpm_rnodes_iter_cleanup</a>
<a name="ln421"> */</a>
<a name="ln422">static inline void</a>
<a name="ln423">zfpm_rnodes_iter_cleanup (zfpm_rnodes_iter_t *iter)</a>
<a name="ln424">{</a>
<a name="ln425">  route_table_iter_cleanup (&amp;iter-&gt;iter);</a>
<a name="ln426">  rib_tables_iter_cleanup (&amp;iter-&gt;tables_iter);</a>
<a name="ln427">}</a>
<a name="ln428"> </a>
<a name="ln429">/*</a>
<a name="ln430"> * zfpm_stats_init</a>
<a name="ln431"> *</a>
<a name="ln432"> * Initialize a statistics block.</a>
<a name="ln433"> */</a>
<a name="ln434">static inline void</a>
<a name="ln435">zfpm_stats_init (zfpm_stats_t *stats)</a>
<a name="ln436">{</a>
<a name="ln437">  memset (stats, 0, sizeof (*stats));</a>
<a name="ln438">}</a>
<a name="ln439"> </a>
<a name="ln440">/*</a>
<a name="ln441"> * zfpm_stats_reset</a>
<a name="ln442"> */</a>
<a name="ln443">static inline void</a>
<a name="ln444">zfpm_stats_reset (zfpm_stats_t *stats)</a>
<a name="ln445">{</a>
<a name="ln446">  zfpm_stats_init (stats);</a>
<a name="ln447">}</a>
<a name="ln448"> </a>
<a name="ln449">/*</a>
<a name="ln450"> * zfpm_stats_copy</a>
<a name="ln451"> */</a>
<a name="ln452">static inline void</a>
<a name="ln453">zfpm_stats_copy (const zfpm_stats_t *src, zfpm_stats_t *dest)</a>
<a name="ln454">{</a>
<a name="ln455">  memcpy (dest, src, sizeof (*dest));</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">/*</a>
<a name="ln459"> * zfpm_stats_compose</a>
<a name="ln460"> *</a>
<a name="ln461"> * Total up the statistics in two stats structures ('s1 and 's2') and</a>
<a name="ln462"> * return the result in the third argument, 'result'. Note that the</a>
<a name="ln463"> * pointer 'result' may be the same as 's1' or 's2'.</a>
<a name="ln464"> *</a>
<a name="ln465"> * For simplicity, the implementation below assumes that the stats</a>
<a name="ln466"> * structure is composed entirely of counters. This can easily be</a>
<a name="ln467"> * changed when necessary.</a>
<a name="ln468"> */</a>
<a name="ln469">static void</a>
<a name="ln470">zfpm_stats_compose (const zfpm_stats_t *s1, const zfpm_stats_t *s2,</a>
<a name="ln471">		    zfpm_stats_t *result)</a>
<a name="ln472">{</a>
<a name="ln473">  const unsigned long *p1, *p2;</a>
<a name="ln474">  unsigned long *result_p;</a>
<a name="ln475">  int i, num_counters;</a>
<a name="ln476"> </a>
<a name="ln477">  p1 = (const unsigned long *) s1;</a>
<a name="ln478">  p2 = (const unsigned long *) s2;</a>
<a name="ln479">  result_p = (unsigned long *) result;</a>
<a name="ln480"> </a>
<a name="ln481">  num_counters = (sizeof (zfpm_stats_t) / sizeof (unsigned long));</a>
<a name="ln482"> </a>
<a name="ln483">  for (i = 0; i &lt; num_counters; i++)</a>
<a name="ln484">    {</a>
<a name="ln485">      result_p[i] = p1[i] + p2[i];</a>
<a name="ln486">    }</a>
<a name="ln487">}</a>
<a name="ln488"> </a>
<a name="ln489">/*</a>
<a name="ln490"> * zfpm_read_on</a>
<a name="ln491"> */</a>
<a name="ln492">static inline void</a>
<a name="ln493">zfpm_read_on (void)</a>
<a name="ln494">{</a>
<a name="ln495">  assert (!zfpm_g-&gt;t_read);</a>
<a name="ln496">  assert (zfpm_g-&gt;sock &gt;= 0);</a>
<a name="ln497"> </a>
<a name="ln498">  THREAD_READ_ON (zfpm_g-&gt;master, zfpm_g-&gt;t_read, zfpm_read_cb, 0,</a>
<a name="ln499">		  zfpm_g-&gt;sock);</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">/*</a>
<a name="ln503"> * zfpm_write_on</a>
<a name="ln504"> */</a>
<a name="ln505">static inline void</a>
<a name="ln506">zfpm_write_on (void)</a>
<a name="ln507">{</a>
<a name="ln508">  assert (!zfpm_g-&gt;t_write);</a>
<a name="ln509">  assert (zfpm_g-&gt;sock &gt;= 0);</a>
<a name="ln510"> </a>
<a name="ln511">  THREAD_WRITE_ON (zfpm_g-&gt;master, zfpm_g-&gt;t_write, zfpm_write_cb, 0,</a>
<a name="ln512">		   zfpm_g-&gt;sock);</a>
<a name="ln513">}</a>
<a name="ln514"> </a>
<a name="ln515">/*</a>
<a name="ln516"> * zfpm_read_off</a>
<a name="ln517"> */</a>
<a name="ln518">static inline void</a>
<a name="ln519">zfpm_read_off (void)</a>
<a name="ln520">{</a>
<a name="ln521">  THREAD_READ_OFF (zfpm_g-&gt;t_read);</a>
<a name="ln522">}</a>
<a name="ln523"> </a>
<a name="ln524">/*</a>
<a name="ln525"> * zfpm_write_off</a>
<a name="ln526"> */</a>
<a name="ln527">static inline void</a>
<a name="ln528">zfpm_write_off (void)</a>
<a name="ln529">{</a>
<a name="ln530">  THREAD_WRITE_OFF (zfpm_g-&gt;t_write);</a>
<a name="ln531">}</a>
<a name="ln532"> </a>
<a name="ln533">/*</a>
<a name="ln534"> * zfpm_conn_up_thread_cb</a>
<a name="ln535"> *</a>
<a name="ln536"> * Callback for actions to be taken when the connection to the FPM</a>
<a name="ln537"> * comes up.</a>
<a name="ln538"> */</a>
<a name="ln539">static int</a>
<a name="ln540">zfpm_conn_up_thread_cb (struct thread *thread)</a>
<a name="ln541">{</a>
<a name="ln542">  struct route_node *rnode;</a>
<a name="ln543">  zfpm_rnodes_iter_t *iter;</a>
<a name="ln544">  rib_dest_t *dest;</a>
<a name="ln545"> </a>
<a name="ln546">  assert (zfpm_g-&gt;t_conn_up);</a>
<a name="ln547">  zfpm_g-&gt;t_conn_up = NULL;</a>
<a name="ln548"> </a>
<a name="ln549">  iter = &amp;zfpm_g-&gt;t_conn_up_state.iter;</a>
<a name="ln550"> </a>
<a name="ln551">  if (zfpm_g-&gt;state != ZFPM_STATE_ESTABLISHED)</a>
<a name="ln552">    {</a>
<a name="ln553">      zfpm_debug (&quot;Connection not up anymore, conn_up thread aborting&quot;);</a>
<a name="ln554">      zfpm_g-&gt;stats.t_conn_up_aborts++;</a>
<a name="ln555">      goto done;</a>
<a name="ln556">    }</a>
<a name="ln557"> </a>
<a name="ln558">  while ((rnode = zfpm_rnodes_iter_next (iter)))</a>
<a name="ln559">    {</a>
<a name="ln560">      dest = rib_dest_from_rnode (rnode);</a>
<a name="ln561"> </a>
<a name="ln562">      if (dest)</a>
<a name="ln563">	{</a>
<a name="ln564">	  zfpm_g-&gt;stats.t_conn_up_dests_processed++;</a>
<a name="ln565">	  zfpm_trigger_update (rnode, NULL);</a>
<a name="ln566">	}</a>
<a name="ln567"> </a>
<a name="ln568">      /*</a>
<a name="ln569">       * Yield if need be.</a>
<a name="ln570">       */</a>
<a name="ln571">      if (!zfpm_thread_should_yield (thread))</a>
<a name="ln572">	continue;</a>
<a name="ln573"> </a>
<a name="ln574">      zfpm_g-&gt;stats.t_conn_up_yields++;</a>
<a name="ln575">      zfpm_rnodes_iter_pause (iter);</a>
<a name="ln576">      zfpm_g-&gt;t_conn_up = thread_add_background (zfpm_g-&gt;master,</a>
<a name="ln577">						 zfpm_conn_up_thread_cb,</a>
<a name="ln578">						 0, 0);</a>
<a name="ln579">      return 0;</a>
<a name="ln580">    }</a>
<a name="ln581"> </a>
<a name="ln582">  zfpm_g-&gt;stats.t_conn_up_finishes++;</a>
<a name="ln583"> </a>
<a name="ln584"> done:</a>
<a name="ln585">  zfpm_rnodes_iter_cleanup (iter);</a>
<a name="ln586">  return 0;</a>
<a name="ln587">}</a>
<a name="ln588"> </a>
<a name="ln589">/*</a>
<a name="ln590"> * zfpm_connection_up</a>
<a name="ln591"> *</a>
<a name="ln592"> * Called when the connection to the FPM comes up.</a>
<a name="ln593"> */</a>
<a name="ln594">static void</a>
<a name="ln595">zfpm_connection_up (const char *detail)</a>
<a name="ln596">{</a>
<a name="ln597">  assert (zfpm_g-&gt;sock &gt;= 0);</a>
<a name="ln598">  zfpm_read_on ();</a>
<a name="ln599">  zfpm_write_on ();</a>
<a name="ln600">  zfpm_set_state (ZFPM_STATE_ESTABLISHED, detail);</a>
<a name="ln601"> </a>
<a name="ln602">  /*</a>
<a name="ln603">   * Start thread to push existing routes to the FPM.</a>
<a name="ln604">   */</a>
<a name="ln605">  assert (!zfpm_g-&gt;t_conn_up);</a>
<a name="ln606"> </a>
<a name="ln607">  zfpm_rnodes_iter_init (&amp;zfpm_g-&gt;t_conn_up_state.iter);</a>
<a name="ln608"> </a>
<a name="ln609">  zfpm_debug (&quot;Starting conn_up thread&quot;);</a>
<a name="ln610">  zfpm_g-&gt;t_conn_up = thread_add_background (zfpm_g-&gt;master,</a>
<a name="ln611">					     zfpm_conn_up_thread_cb, 0, 0);</a>
<a name="ln612">  zfpm_g-&gt;stats.t_conn_up_starts++;</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">/*</a>
<a name="ln616"> * zfpm_connect_check</a>
<a name="ln617"> *</a>
<a name="ln618"> * Check if an asynchronous connect() to the FPM is complete.</a>
<a name="ln619"> */</a>
<a name="ln620">static void</a>
<a name="ln621">zfpm_connect_check ()</a>
<a name="ln622">{</a>
<a name="ln623">  int status;</a>
<a name="ln624">  socklen_t slen;</a>
<a name="ln625">  int ret;</a>
<a name="ln626"> </a>
<a name="ln627">  zfpm_read_off ();</a>
<a name="ln628">  zfpm_write_off ();</a>
<a name="ln629"> </a>
<a name="ln630">  slen = sizeof (status);</a>
<a name="ln631">  ret = getsockopt (zfpm_g-&gt;sock, SOL_SOCKET, SO_ERROR, (void *) &amp;status,</a>
<a name="ln632">		    &amp;slen);</a>
<a name="ln633"> </a>
<a name="ln634">  if (ret &gt;= 0 &amp;&amp; status == 0)</a>
<a name="ln635">    {</a>
<a name="ln636">      zfpm_connection_up (&quot;async connect complete&quot;);</a>
<a name="ln637">      return;</a>
<a name="ln638">    }</a>
<a name="ln639"> </a>
<a name="ln640">  /*</a>
<a name="ln641">   * getsockopt() failed or indicated an error on the socket.</a>
<a name="ln642">   */</a>
<a name="ln643">  close (zfpm_g-&gt;sock);</a>
<a name="ln644">  zfpm_g-&gt;sock = -1;</a>
<a name="ln645"> </a>
<a name="ln646">  zfpm_start_connect_timer (&quot;getsockopt() after async connect failed&quot;);</a>
<a name="ln647">  return;</a>
<a name="ln648">}</a>
<a name="ln649"> </a>
<a name="ln650">/*</a>
<a name="ln651"> * zfpm_conn_down_thread_cb</a>
<a name="ln652"> *</a>
<a name="ln653"> * Callback that is invoked to clean up state after the TCP connection</a>
<a name="ln654"> * to the FPM goes down.</a>
<a name="ln655"> */</a>
<a name="ln656">static int</a>
<a name="ln657">zfpm_conn_down_thread_cb (struct thread *thread)</a>
<a name="ln658">{</a>
<a name="ln659">  struct route_node *rnode;</a>
<a name="ln660">  zfpm_rnodes_iter_t *iter;</a>
<a name="ln661">  rib_dest_t *dest;</a>
<a name="ln662"> </a>
<a name="ln663">  assert (zfpm_g-&gt;state == ZFPM_STATE_IDLE);</a>
<a name="ln664"> </a>
<a name="ln665">  assert (zfpm_g-&gt;t_conn_down);</a>
<a name="ln666">  zfpm_g-&gt;t_conn_down = NULL;</a>
<a name="ln667"> </a>
<a name="ln668">  iter = &amp;zfpm_g-&gt;t_conn_down_state.iter;</a>
<a name="ln669"> </a>
<a name="ln670">  while ((rnode = zfpm_rnodes_iter_next (iter)))</a>
<a name="ln671">    {</a>
<a name="ln672">      dest = rib_dest_from_rnode (rnode);</a>
<a name="ln673"> </a>
<a name="ln674">      if (dest)</a>
<a name="ln675">	{</a>
<a name="ln676">	  if (CHECK_FLAG (dest-&gt;flags, RIB_DEST_UPDATE_FPM))</a>
<a name="ln677">	    {</a>
<a name="ln678">	      TAILQ_REMOVE (&amp;zfpm_g-&gt;dest_q, dest, fpm_q_entries);</a>
<a name="ln679">	    }</a>
<a name="ln680"> </a>
<a name="ln681">	  UNSET_FLAG (dest-&gt;flags, RIB_DEST_UPDATE_FPM);</a>
<a name="ln682">	  UNSET_FLAG (dest-&gt;flags, RIB_DEST_SENT_TO_FPM);</a>
<a name="ln683"> </a>
<a name="ln684">	  zfpm_g-&gt;stats.t_conn_down_dests_processed++;</a>
<a name="ln685"> </a>
<a name="ln686">	  /*</a>
<a name="ln687">	   * Check if the dest should be deleted.</a>
<a name="ln688">	   */</a>
<a name="ln689">	  rib_gc_dest(rnode);</a>
<a name="ln690">	}</a>
<a name="ln691"> </a>
<a name="ln692">      /*</a>
<a name="ln693">       * Yield if need be.</a>
<a name="ln694">       */</a>
<a name="ln695">      if (!zfpm_thread_should_yield (thread))</a>
<a name="ln696">	continue;</a>
<a name="ln697"> </a>
<a name="ln698">      zfpm_g-&gt;stats.t_conn_down_yields++;</a>
<a name="ln699">      zfpm_rnodes_iter_pause (iter);</a>
<a name="ln700">      zfpm_g-&gt;t_conn_down = thread_add_background (zfpm_g-&gt;master,</a>
<a name="ln701">						   zfpm_conn_down_thread_cb,</a>
<a name="ln702">						   0, 0);</a>
<a name="ln703">      return 0;</a>
<a name="ln704">    }</a>
<a name="ln705"> </a>
<a name="ln706">  zfpm_g-&gt;stats.t_conn_down_finishes++;</a>
<a name="ln707">  zfpm_rnodes_iter_cleanup (iter);</a>
<a name="ln708"> </a>
<a name="ln709">  /*</a>
<a name="ln710">   * Start the process of connecting to the FPM again.</a>
<a name="ln711">   */</a>
<a name="ln712">  zfpm_start_connect_timer (&quot;cleanup complete&quot;);</a>
<a name="ln713">  return 0;</a>
<a name="ln714">}</a>
<a name="ln715"> </a>
<a name="ln716">/*</a>
<a name="ln717"> * zfpm_connection_down</a>
<a name="ln718"> *</a>
<a name="ln719"> * Called when the connection to the FPM has gone down.</a>
<a name="ln720"> */</a>
<a name="ln721">static void</a>
<a name="ln722">zfpm_connection_down (const char *detail)</a>
<a name="ln723">{</a>
<a name="ln724">  if (!detail)</a>
<a name="ln725">    detail = &quot;unknown&quot;;</a>
<a name="ln726"> </a>
<a name="ln727">  assert (zfpm_g-&gt;state == ZFPM_STATE_ESTABLISHED);</a>
<a name="ln728"> </a>
<a name="ln729">  zlog_info (&quot;connection to the FPM has gone down: %s&quot;, detail);</a>
<a name="ln730"> </a>
<a name="ln731">  zfpm_read_off ();</a>
<a name="ln732">  zfpm_write_off ();</a>
<a name="ln733"> </a>
<a name="ln734">  stream_reset (zfpm_g-&gt;ibuf);</a>
<a name="ln735">  stream_reset (zfpm_g-&gt;obuf);</a>
<a name="ln736"> </a>
<a name="ln737">  if (zfpm_g-&gt;sock &gt;= 0) {</a>
<a name="ln738">    close (zfpm_g-&gt;sock);</a>
<a name="ln739">    zfpm_g-&gt;sock = -1;</a>
<a name="ln740">  }</a>
<a name="ln741"> </a>
<a name="ln742">  /*</a>
<a name="ln743">   * Start thread to clean up state after the connection goes down.</a>
<a name="ln744">   */</a>
<a name="ln745">  assert (!zfpm_g-&gt;t_conn_down);</a>
<a name="ln746">  zfpm_debug (&quot;Starting conn_down thread&quot;);</a>
<a name="ln747">  zfpm_rnodes_iter_init (&amp;zfpm_g-&gt;t_conn_down_state.iter);</a>
<a name="ln748">  zfpm_g-&gt;t_conn_down = thread_add_background (zfpm_g-&gt;master,</a>
<a name="ln749">					       zfpm_conn_down_thread_cb, 0, 0);</a>
<a name="ln750">  zfpm_g-&gt;stats.t_conn_down_starts++;</a>
<a name="ln751"> </a>
<a name="ln752">  zfpm_set_state (ZFPM_STATE_IDLE, detail);</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">/*</a>
<a name="ln756"> * zfpm_read_cb</a>
<a name="ln757"> */</a>
<a name="ln758">static int</a>
<a name="ln759">zfpm_read_cb (struct thread *thread)</a>
<a name="ln760">{</a>
<a name="ln761">  size_t already;</a>
<a name="ln762">  struct stream *ibuf;</a>
<a name="ln763">  uint16_t msg_len;</a>
<a name="ln764">  fpm_msg_hdr_t *hdr;</a>
<a name="ln765"> </a>
<a name="ln766">  zfpm_g-&gt;stats.read_cb_calls++;</a>
<a name="ln767">  assert (zfpm_g-&gt;t_read);</a>
<a name="ln768">  zfpm_g-&gt;t_read = NULL;</a>
<a name="ln769"> </a>
<a name="ln770">  /*</a>
<a name="ln771">   * Check if async connect is now done.</a>
<a name="ln772">   */</a>
<a name="ln773">  if (zfpm_g-&gt;state == ZFPM_STATE_CONNECTING)</a>
<a name="ln774">    {</a>
<a name="ln775">      zfpm_connect_check();</a>
<a name="ln776">      return 0;</a>
<a name="ln777">    }</a>
<a name="ln778"> </a>
<a name="ln779">  assert (zfpm_g-&gt;state == ZFPM_STATE_ESTABLISHED);</a>
<a name="ln780">  assert (zfpm_g-&gt;sock &gt;= 0);</a>
<a name="ln781"> </a>
<a name="ln782">  ibuf = zfpm_g-&gt;ibuf;</a>
<a name="ln783"> </a>
<a name="ln784">  already = stream_get_endp (ibuf);</a>
<a name="ln785">  if (already &lt; FPM_MSG_HDR_LEN)</a>
<a name="ln786">    {</a>
<a name="ln787">      ssize_t nbyte;</a>
<a name="ln788"> </a>
<a name="ln789">      nbyte = stream_read_try (ibuf, zfpm_g-&gt;sock, FPM_MSG_HDR_LEN - already);</a>
<a name="ln790">      if (nbyte == 0 || nbyte == -1)</a>
<a name="ln791">	{</a>
<a name="ln792">	  zfpm_connection_down (&quot;closed socket in read&quot;);</a>
<a name="ln793">	  return 0;</a>
<a name="ln794">	}</a>
<a name="ln795"> </a>
<a name="ln796">      if (nbyte != (ssize_t) (FPM_MSG_HDR_LEN - already))</a>
<a name="ln797">	goto done;</a>
<a name="ln798"> </a>
<a name="ln799">      already = FPM_MSG_HDR_LEN;</a>
<a name="ln800">    }</a>
<a name="ln801"> </a>
<a name="ln802">  stream_set_getp (ibuf, 0);</a>
<a name="ln803"> </a>
<a name="ln804">  hdr = (fpm_msg_hdr_t *) stream_pnt (ibuf);</a>
<a name="ln805"> </a>
<a name="ln806">  if (!fpm_msg_hdr_ok (hdr))</a>
<a name="ln807">    {</a>
<a name="ln808">      zfpm_connection_down (&quot;invalid message header&quot;);</a>
<a name="ln809">      return 0;</a>
<a name="ln810">    }</a>
<a name="ln811"> </a>
<a name="ln812">  msg_len = fpm_msg_len (hdr);</a>
<a name="ln813"> </a>
<a name="ln814">  /*</a>
<a name="ln815">   * Read out the rest of the packet.</a>
<a name="ln816">   */</a>
<a name="ln817">  if (already &lt; msg_len)</a>
<a name="ln818">    {</a>
<a name="ln819">      ssize_t nbyte;</a>
<a name="ln820"> </a>
<a name="ln821">      nbyte = stream_read_try (ibuf, zfpm_g-&gt;sock, msg_len - already);</a>
<a name="ln822"> </a>
<a name="ln823">      if (nbyte == 0 || nbyte == -1)</a>
<a name="ln824">	{</a>
<a name="ln825">	  zfpm_connection_down (&quot;failed to read message&quot;);</a>
<a name="ln826">	  return 0;</a>
<a name="ln827">	}</a>
<a name="ln828"> </a>
<a name="ln829">      if (nbyte != (ssize_t) (msg_len - already))</a>
<a name="ln830">	goto done;</a>
<a name="ln831">    }</a>
<a name="ln832"> </a>
<a name="ln833">  zfpm_debug (&quot;Read out a full fpm message&quot;);</a>
<a name="ln834"> </a>
<a name="ln835">  /*</a>
<a name="ln836">   * Just throw it away for now.</a>
<a name="ln837">   */</a>
<a name="ln838">  stream_reset (ibuf);</a>
<a name="ln839"> </a>
<a name="ln840"> done:</a>
<a name="ln841">  zfpm_read_on ();</a>
<a name="ln842">  return 0;</a>
<a name="ln843">}</a>
<a name="ln844"> </a>
<a name="ln845">/*</a>
<a name="ln846"> * zfpm_writes_pending</a>
<a name="ln847"> *</a>
<a name="ln848"> * Returns TRUE if we may have something to write to the FPM.</a>
<a name="ln849"> */</a>
<a name="ln850">static int</a>
<a name="ln851">zfpm_writes_pending (void)</a>
<a name="ln852">{</a>
<a name="ln853"> </a>
<a name="ln854">  /*</a>
<a name="ln855">   * Check if there is any data in the outbound buffer that has not</a>
<a name="ln856">   * been written to the socket yet.</a>
<a name="ln857">   */</a>
<a name="ln858">  if (stream_get_endp (zfpm_g-&gt;obuf) - stream_get_getp (zfpm_g-&gt;obuf))</a>
<a name="ln859">    return 1;</a>
<a name="ln860"> </a>
<a name="ln861">  /*</a>
<a name="ln862">   * Check if there are any prefixes on the outbound queue.</a>
<a name="ln863">   */</a>
<a name="ln864">  if (!TAILQ_EMPTY (&amp;zfpm_g-&gt;dest_q))</a>
<a name="ln865">    return 1;</a>
<a name="ln866"> </a>
<a name="ln867">  return 0;</a>
<a name="ln868">}</a>
<a name="ln869"> </a>
<a name="ln870">/*</a>
<a name="ln871"> * zfpm_encode_route</a>
<a name="ln872"> *</a>
<a name="ln873"> * Encode a message to the FPM with information about the given route.</a>
<a name="ln874"> *</a>
<a name="ln875"> * Returns the number of bytes written to the buffer. 0 or a negative</a>
<a name="ln876"> * value indicates an error.</a>
<a name="ln877"> */</a>
<a name="ln878">static inline int</a>
<a name="ln879">zfpm_encode_route (rib_dest_t *dest, struct rib *rib, char *in_buf,</a>
<a name="ln880">		   size_t in_buf_len, fpm_msg_type_e *msg_type)</a>
<a name="ln881">{</a>
<a name="ln882">  size_t len;</a>
<a name="ln883">  int cmd;</a>
<a name="ln884">  len = 0;</a>
<a name="ln885"> </a>
<a name="ln886">  *msg_type = FPM_MSG_TYPE_NONE;</a>
<a name="ln887"> </a>
<a name="ln888">  switch (zfpm_g-&gt;message_format) {</a>
<a name="ln889"> </a>
<a name="ln890">  case ZFPM_MSG_FORMAT_PROTOBUF:</a>
<a name="ln891">#ifdef HAVE_PROTOBUF</a>
<a name="ln892">    len = zfpm_protobuf_encode_route (dest, rib, (uint8_t *) in_buf,</a>
<a name="ln893">				      in_buf_len);</a>
<a name="ln894">    *msg_type = FPM_MSG_TYPE_PROTOBUF;</a>
<a name="ln895">#endif</a>
<a name="ln896">    break;</a>
<a name="ln897"> </a>
<a name="ln898">  case ZFPM_MSG_FORMAT_NETLINK:</a>
<a name="ln899">#ifdef HAVE_NETLINK</a>
<a name="ln900">    *msg_type = FPM_MSG_TYPE_NETLINK;</a>
<a name="ln901">    cmd = rib ? RTM_NEWROUTE : RTM_DELROUTE;</a>
<a name="ln902">    len = zfpm_netlink_encode_route (cmd, dest, rib, in_buf, in_buf_len);</a>
<a name="ln903">    assert(fpm_msg_align(len) == len);</a>
<a name="ln904">    *msg_type = FPM_MSG_TYPE_NETLINK;</a>
<a name="ln905">#endif /* HAVE_NETLINK */</a>
<a name="ln906">    break;</a>
<a name="ln907"> </a>
<a name="ln908">  default:</a>
<a name="ln909">    break;</a>
<a name="ln910">  }</a>
<a name="ln911"> </a>
<a name="ln912">  return len;</a>
<a name="ln913"> </a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">/*</a>
<a name="ln917"> * zfpm_route_for_update</a>
<a name="ln918"> *</a>
<a name="ln919"> * Returns the rib that is to be sent to the FPM for a given dest.</a>
<a name="ln920"> */</a>
<a name="ln921">struct rib *</a>
<a name="ln922">zfpm_route_for_update (rib_dest_t *dest)</a>
<a name="ln923">{</a>
<a name="ln924">  struct rib *rib;</a>
<a name="ln925"> </a>
<a name="ln926">  RIB_DEST_FOREACH_ROUTE (dest, rib)</a>
<a name="ln927">    {</a>
<a name="ln928">      if (!CHECK_FLAG (rib-&gt;status, RIB_ENTRY_SELECTED_FIB))</a>
<a name="ln929">	continue;</a>
<a name="ln930"> </a>
<a name="ln931">      return rib;</a>
<a name="ln932">    }</a>
<a name="ln933"> </a>
<a name="ln934">  /*</a>
<a name="ln935">   * We have no route for this destination.</a>
<a name="ln936">   */</a>
<a name="ln937">  return NULL;</a>
<a name="ln938">}</a>
<a name="ln939"> </a>
<a name="ln940">/*</a>
<a name="ln941"> * zfpm_build_updates</a>
<a name="ln942"> *</a>
<a name="ln943"> * Process the outgoing queue and write messages to the outbound</a>
<a name="ln944"> * buffer.</a>
<a name="ln945"> */</a>
<a name="ln946">static void</a>
<a name="ln947">zfpm_build_updates (void)</a>
<a name="ln948">{</a>
<a name="ln949">  struct stream *s;</a>
<a name="ln950">  rib_dest_t *dest;</a>
<a name="ln951">  unsigned char *buf, *data, *buf_end;</a>
<a name="ln952">  size_t msg_len;</a>
<a name="ln953">  size_t data_len;</a>
<a name="ln954">  fpm_msg_hdr_t *hdr;</a>
<a name="ln955">  struct rib *rib;</a>
<a name="ln956">  int is_add, write_msg;</a>
<a name="ln957">  fpm_msg_type_e msg_type;</a>
<a name="ln958"> </a>
<a name="ln959">  s = zfpm_g-&gt;obuf;</a>
<a name="ln960"> </a>
<a name="ln961">  assert (stream_empty (s));</a>
<a name="ln962"> </a>
<a name="ln963">  do {</a>
<a name="ln964"> </a>
<a name="ln965">    /*</a>
<a name="ln966">     * Make sure there is enough space to write another message.</a>
<a name="ln967">     */</a>
<a name="ln968">    if (STREAM_WRITEABLE (s) &lt; FPM_MAX_MSG_LEN)</a>
<a name="ln969">      break;</a>
<a name="ln970"> </a>
<a name="ln971">    buf = STREAM_DATA (s) + stream_get_endp (s);</a>
<a name="ln972">    buf_end = buf + STREAM_WRITEABLE (s);</a>
<a name="ln973"> </a>
<a name="ln974">    dest = TAILQ_FIRST (&amp;zfpm_g-&gt;dest_q);</a>
<a name="ln975">    if (!dest)</a>
<a name="ln976">      break;</a>
<a name="ln977"> </a>
<a name="ln978">    assert (CHECK_FLAG (dest-&gt;flags, RIB_DEST_UPDATE_FPM));</a>
<a name="ln979"> </a>
<a name="ln980">    hdr = (fpm_msg_hdr_t *) buf;</a>
<a name="ln981">    hdr-&gt;version = FPM_PROTO_VERSION;</a>
<a name="ln982"> </a>
<a name="ln983">    data = fpm_msg_data (hdr);</a>
<a name="ln984"> </a>
<a name="ln985">    rib = zfpm_route_for_update (dest);</a>
<a name="ln986">    is_add = rib ? 1 : 0;</a>
<a name="ln987"> </a>
<a name="ln988">    write_msg = 1;</a>
<a name="ln989"> </a>
<a name="ln990">    /*</a>
<a name="ln991">     * If this is a route deletion, and we have not sent the route to</a>
<a name="ln992">     * the FPM previously, skip it.</a>
<a name="ln993">     */</a>
<a name="ln994">    if (!is_add &amp;&amp; !CHECK_FLAG (dest-&gt;flags, RIB_DEST_SENT_TO_FPM))</a>
<a name="ln995">      {</a>
<a name="ln996">	write_msg = 0;</a>
<a name="ln997">	zfpm_g-&gt;stats.nop_deletes_skipped++;</a>
<a name="ln998">      }</a>
<a name="ln999"> </a>
<a name="ln1000">    if (write_msg) {</a>
<a name="ln1001">      data_len = zfpm_encode_route (dest, rib, (char *) data, buf_end - data,</a>
<a name="ln1002">				    &amp;msg_type);</a>
<a name="ln1003"> </a>
<a name="ln1004">      assert (data_len);</a>
<a name="ln1005">      if (data_len)</a>
<a name="ln1006">	{</a>
<a name="ln1007">	  hdr-&gt;msg_type = msg_type;</a>
<a name="ln1008">	  msg_len = fpm_data_len_to_msg_len (data_len);</a>
<a name="ln1009">	  hdr-&gt;msg_len = htons (msg_len);</a>
<a name="ln1010">	  stream_forward_endp (s, msg_len);</a>
<a name="ln1011"> </a>
<a name="ln1012">	  if (is_add)</a>
<a name="ln1013">	    zfpm_g-&gt;stats.route_adds++;</a>
<a name="ln1014">	  else</a>
<a name="ln1015">	    zfpm_g-&gt;stats.route_dels++;</a>
<a name="ln1016">	}</a>
<a name="ln1017">    }</a>
<a name="ln1018"> </a>
<a name="ln1019">    /*</a>
<a name="ln1020">     * Remove the dest from the queue, and reset the flag.</a>
<a name="ln1021">     */</a>
<a name="ln1022">    UNSET_FLAG (dest-&gt;flags, RIB_DEST_UPDATE_FPM);</a>
<a name="ln1023">    TAILQ_REMOVE (&amp;zfpm_g-&gt;dest_q, dest, fpm_q_entries);</a>
<a name="ln1024"> </a>
<a name="ln1025">    if (is_add)</a>
<a name="ln1026">      {</a>
<a name="ln1027">	SET_FLAG (dest-&gt;flags, RIB_DEST_SENT_TO_FPM);</a>
<a name="ln1028">      }</a>
<a name="ln1029">    else</a>
<a name="ln1030">      {</a>
<a name="ln1031">	UNSET_FLAG (dest-&gt;flags, RIB_DEST_SENT_TO_FPM);</a>
<a name="ln1032">      }</a>
<a name="ln1033"> </a>
<a name="ln1034">    /*</a>
<a name="ln1035">     * Delete the destination if necessary.</a>
<a name="ln1036">     */</a>
<a name="ln1037">    if (rib_gc_dest (dest-&gt;rnode))</a>
<a name="ln1038">      zfpm_g-&gt;stats.dests_del_after_update++;</a>
<a name="ln1039"> </a>
<a name="ln1040">  } while (1);</a>
<a name="ln1041"> </a>
<a name="ln1042">}</a>
<a name="ln1043"> </a>
<a name="ln1044">/*</a>
<a name="ln1045"> * zfpm_write_cb</a>
<a name="ln1046"> */</a>
<a name="ln1047">static int</a>
<a name="ln1048">zfpm_write_cb (struct thread *thread)</a>
<a name="ln1049">{</a>
<a name="ln1050">  struct stream *s;</a>
<a name="ln1051">  int num_writes;</a>
<a name="ln1052"> </a>
<a name="ln1053">  zfpm_g-&gt;stats.write_cb_calls++;</a>
<a name="ln1054">  assert (zfpm_g-&gt;t_write);</a>
<a name="ln1055">  zfpm_g-&gt;t_write = NULL;</a>
<a name="ln1056"> </a>
<a name="ln1057">  /*</a>
<a name="ln1058">   * Check if async connect is now done.</a>
<a name="ln1059">   */</a>
<a name="ln1060">  if (zfpm_g-&gt;state == ZFPM_STATE_CONNECTING)</a>
<a name="ln1061">    {</a>
<a name="ln1062">      zfpm_connect_check ();</a>
<a name="ln1063">      return 0;</a>
<a name="ln1064">    }</a>
<a name="ln1065"> </a>
<a name="ln1066">  assert (zfpm_g-&gt;state == ZFPM_STATE_ESTABLISHED);</a>
<a name="ln1067">  assert (zfpm_g-&gt;sock &gt;= 0);</a>
<a name="ln1068"> </a>
<a name="ln1069">  num_writes = 0;</a>
<a name="ln1070"> </a>
<a name="ln1071">  do</a>
<a name="ln1072">    {</a>
<a name="ln1073">      int bytes_to_write, bytes_written;</a>
<a name="ln1074"> </a>
<a name="ln1075">      s = zfpm_g-&gt;obuf;</a>
<a name="ln1076"> </a>
<a name="ln1077">      /*</a>
<a name="ln1078">       * If the stream is empty, try fill it up with data.</a>
<a name="ln1079">       */</a>
<a name="ln1080">      if (stream_empty (s))</a>
<a name="ln1081">	{</a>
<a name="ln1082">	  zfpm_build_updates ();</a>
<a name="ln1083">	}</a>
<a name="ln1084"> </a>
<a name="ln1085">      bytes_to_write = stream_get_endp (s) - stream_get_getp (s);</a>
<a name="ln1086">      if (!bytes_to_write)</a>
<a name="ln1087">	break;</a>
<a name="ln1088"> </a>
<a name="ln1089">      bytes_written = write (zfpm_g-&gt;sock, STREAM_PNT (s), bytes_to_write);</a>
<a name="ln1090">      zfpm_g-&gt;stats.write_calls++;</a>
<a name="ln1091">      num_writes++;</a>
<a name="ln1092"> </a>
<a name="ln1093">      if (bytes_written &lt; 0)</a>
<a name="ln1094">	{</a>
<a name="ln1095">	  if (ERRNO_IO_RETRY (errno))</a>
<a name="ln1096">	    break;</a>
<a name="ln1097"> </a>
<a name="ln1098">	  zfpm_connection_down (&quot;failed to write to socket&quot;);</a>
<a name="ln1099">	  return 0;</a>
<a name="ln1100">	}</a>
<a name="ln1101"> </a>
<a name="ln1102">      if (bytes_written != bytes_to_write)</a>
<a name="ln1103">	{</a>
<a name="ln1104"> </a>
<a name="ln1105">	  /*</a>
<a name="ln1106">	   * Partial write.</a>
<a name="ln1107">	   */</a>
<a name="ln1108">	  stream_forward_getp (s, bytes_written);</a>
<a name="ln1109">	  zfpm_g-&gt;stats.partial_writes++;</a>
<a name="ln1110">	  break;</a>
<a name="ln1111">	}</a>
<a name="ln1112"> </a>
<a name="ln1113">      /*</a>
<a name="ln1114">       * We've written out the entire contents of the stream.</a>
<a name="ln1115">       */</a>
<a name="ln1116">      stream_reset (s);</a>
<a name="ln1117"> </a>
<a name="ln1118">      if (num_writes &gt;= ZFPM_MAX_WRITES_PER_RUN)</a>
<a name="ln1119">	{</a>
<a name="ln1120">	  zfpm_g-&gt;stats.max_writes_hit++;</a>
<a name="ln1121">	  break;</a>
<a name="ln1122">	}</a>
<a name="ln1123"> </a>
<a name="ln1124">      if (zfpm_thread_should_yield (thread))</a>
<a name="ln1125">	{</a>
<a name="ln1126">	  zfpm_g-&gt;stats.t_write_yields++;</a>
<a name="ln1127">	  break;</a>
<a name="ln1128">	}</a>
<a name="ln1129">    } while (1);</a>
<a name="ln1130"> </a>
<a name="ln1131">  if (zfpm_writes_pending ())</a>
<a name="ln1132">      zfpm_write_on ();</a>
<a name="ln1133"> </a>
<a name="ln1134">  return 0;</a>
<a name="ln1135">}</a>
<a name="ln1136"> </a>
<a name="ln1137">/*</a>
<a name="ln1138"> * zfpm_connect_cb</a>
<a name="ln1139"> */</a>
<a name="ln1140">static int</a>
<a name="ln1141">zfpm_connect_cb (struct thread *t)</a>
<a name="ln1142">{</a>
<a name="ln1143">  int sock, ret;</a>
<a name="ln1144">  struct sockaddr_in serv;</a>
<a name="ln1145"> </a>
<a name="ln1146">  assert (zfpm_g-&gt;t_connect);</a>
<a name="ln1147">  zfpm_g-&gt;t_connect = NULL;</a>
<a name="ln1148">  assert (zfpm_g-&gt;state == ZFPM_STATE_ACTIVE);</a>
<a name="ln1149"> </a>
<a name="ln1150">  sock = socket (AF_INET, SOCK_STREAM, 0);</a>
<a name="ln1151">  if (sock &lt; 0)</a>
<a name="ln1152">    {</a>
<a name="ln1153">      zfpm_debug (&quot;Failed to create socket for connect(): %s&quot;, strerror(errno));</a>
<a name="ln1154">      zfpm_g-&gt;stats.connect_no_sock++;</a>
<a name="ln1155">      return 0;</a>
<a name="ln1156">    }</a>
<a name="ln1157"> </a>
<a name="ln1158">  set_nonblocking(sock);</a>
<a name="ln1159"> </a>
<a name="ln1160">  /* Make server socket. */</a>
<a name="ln1161">  memset (&amp;serv, 0, sizeof (serv));</a>
<a name="ln1162">  serv.sin_family = AF_INET;</a>
<a name="ln1163">  serv.sin_port = htons (zfpm_g-&gt;fpm_port);</a>
<a name="ln1164">#ifdef HAVE_STRUCT_SOCKADDR_IN_SIN_LEN</a>
<a name="ln1165">  serv.sin_len = sizeof (struct sockaddr_in);</a>
<a name="ln1166">#endif /* HAVE_STRUCT_SOCKADDR_IN_SIN_LEN */</a>
<a name="ln1167">  if (!zfpm_g-&gt;fpm_server)</a>
<a name="ln1168">    serv.sin_addr.s_addr = htonl (INADDR_LOOPBACK);</a>
<a name="ln1169">  else </a>
<a name="ln1170">    serv.sin_addr.s_addr = (zfpm_g-&gt;fpm_server);</a>
<a name="ln1171"> </a>
<a name="ln1172">  /*</a>
<a name="ln1173">   * Connect to the FPM.</a>
<a name="ln1174">   */</a>
<a name="ln1175">  zfpm_g-&gt;connect_calls++;</a>
<a name="ln1176">  zfpm_g-&gt;stats.connect_calls++;</a>
<a name="ln1177">  zfpm_g-&gt;last_connect_call_time = zfpm_get_time ();</a>
<a name="ln1178"> </a>
<a name="ln1179">  ret = connect (sock, (struct sockaddr *) &amp;serv, sizeof (serv));</a>
<a name="ln1180">  if (ret &gt;= 0)</a>
<a name="ln1181">    {</a>
<a name="ln1182">      zfpm_g-&gt;sock = sock;</a>
<a name="ln1183">      zfpm_connection_up (&quot;connect succeeded&quot;);</a>
<a name="ln1184">      return 1;</a>
<a name="ln1185">    }</a>
<a name="ln1186"> </a>
<a name="ln1187">  if (errno == EINPROGRESS)</a>
<a name="ln1188">    {</a>
<a name="ln1189">      zfpm_g-&gt;sock = sock;</a>
<a name="ln1190">      zfpm_read_on ();</a>
<a name="ln1191">      zfpm_write_on ();</a>
<a name="ln1192">      zfpm_set_state (ZFPM_STATE_CONNECTING, &quot;async connect in progress&quot;);</a>
<a name="ln1193">      return 0;</a>
<a name="ln1194">    }</a>
<a name="ln1195"> </a>
<a name="ln1196">  zlog_info (&quot;can't connect to FPM %d: %s&quot;, sock, safe_strerror (errno));</a>
<a name="ln1197">  close (sock);</a>
<a name="ln1198"> </a>
<a name="ln1199">  /*</a>
<a name="ln1200">   * Restart timer for retrying connection.</a>
<a name="ln1201">   */</a>
<a name="ln1202">  zfpm_start_connect_timer (&quot;connect() failed&quot;);</a>
<a name="ln1203">  return 0;</a>
<a name="ln1204">}</a>
<a name="ln1205"> </a>
<a name="ln1206">/*</a>
<a name="ln1207"> * zfpm_set_state</a>
<a name="ln1208"> *</a>
<a name="ln1209"> * Move state machine into the given state.</a>
<a name="ln1210"> */</a>
<a name="ln1211">static void</a>
<a name="ln1212">zfpm_set_state (zfpm_state_t state, const char *reason)</a>
<a name="ln1213">{</a>
<a name="ln1214">  zfpm_state_t cur_state = zfpm_g-&gt;state;</a>
<a name="ln1215"> </a>
<a name="ln1216">  if (!reason)</a>
<a name="ln1217">    reason = &quot;Unknown&quot;;</a>
<a name="ln1218"> </a>
<a name="ln1219">  if (state == cur_state)</a>
<a name="ln1220">    return;</a>
<a name="ln1221"> </a>
<a name="ln1222">  zfpm_debug(&quot;beginning state transition %s -&gt; %s. Reason: %s&quot;,</a>
<a name="ln1223">	     zfpm_state_to_str (cur_state), zfpm_state_to_str (state),</a>
<a name="ln1224">	     reason);</a>
<a name="ln1225"> </a>
<a name="ln1226">  switch (state) {</a>
<a name="ln1227"> </a>
<a name="ln1228">  case ZFPM_STATE_IDLE:</a>
<a name="ln1229">    assert (cur_state == ZFPM_STATE_ESTABLISHED);</a>
<a name="ln1230">    break;</a>
<a name="ln1231"> </a>
<a name="ln1232">  case ZFPM_STATE_ACTIVE:</a>
<a name="ln1233">     assert (cur_state == ZFPM_STATE_IDLE ||</a>
<a name="ln1234">	     cur_state == ZFPM_STATE_CONNECTING);</a>
<a name="ln1235">    assert (zfpm_g-&gt;t_connect);</a>
<a name="ln1236">    break;</a>
<a name="ln1237"> </a>
<a name="ln1238">  case ZFPM_STATE_CONNECTING:</a>
<a name="ln1239">    assert (zfpm_g-&gt;sock);</a>
<a name="ln1240">    assert (cur_state == ZFPM_STATE_ACTIVE);</a>
<a name="ln1241">    assert (zfpm_g-&gt;t_read);</a>
<a name="ln1242">    assert (zfpm_g-&gt;t_write);</a>
<a name="ln1243">    break;</a>
<a name="ln1244"> </a>
<a name="ln1245">  case ZFPM_STATE_ESTABLISHED:</a>
<a name="ln1246">    assert (cur_state == ZFPM_STATE_ACTIVE ||</a>
<a name="ln1247">	    cur_state == ZFPM_STATE_CONNECTING);</a>
<a name="ln1248">    assert (zfpm_g-&gt;sock);</a>
<a name="ln1249">    assert (zfpm_g-&gt;t_read);</a>
<a name="ln1250">    assert (zfpm_g-&gt;t_write);</a>
<a name="ln1251">    break;</a>
<a name="ln1252">  }</a>
<a name="ln1253"> </a>
<a name="ln1254">  zfpm_g-&gt;state = state;</a>
<a name="ln1255">}</a>
<a name="ln1256"> </a>
<a name="ln1257">/*</a>
<a name="ln1258"> * zfpm_calc_connect_delay</a>
<a name="ln1259"> *</a>
<a name="ln1260"> * Returns the number of seconds after which we should attempt to</a>
<a name="ln1261"> * reconnect to the FPM.</a>
<a name="ln1262"> */</a>
<a name="ln1263">static long</a>
<a name="ln1264">zfpm_calc_connect_delay (void)</a>
<a name="ln1265">{</a>
<a name="ln1266">  time_t elapsed;</a>
<a name="ln1267"> </a>
<a name="ln1268">  /*</a>
<a name="ln1269">   * Return 0 if this is our first attempt to connect.</a>
<a name="ln1270">   */</a>
<a name="ln1271">  if (zfpm_g-&gt;connect_calls == 0)</a>
<a name="ln1272">    {</a>
<a name="ln1273">      return 0;</a>
<a name="ln1274">    }</a>
<a name="ln1275"> </a>
<a name="ln1276">  elapsed = zfpm_get_elapsed_time (zfpm_g-&gt;last_connect_call_time);</a>
<a name="ln1277"> </a>
<a name="ln1278">  if (elapsed &gt; ZFPM_CONNECT_RETRY_IVL) {</a>
<a name="ln1279">    return 0;</a>
<a name="ln1280">  }</a>
<a name="ln1281"> </a>
<a name="ln1282">  return ZFPM_CONNECT_RETRY_IVL - elapsed;</a>
<a name="ln1283">}</a>
<a name="ln1284"> </a>
<a name="ln1285">/*</a>
<a name="ln1286"> * zfpm_start_connect_timer</a>
<a name="ln1287"> */</a>
<a name="ln1288">static void</a>
<a name="ln1289">zfpm_start_connect_timer (const char *reason)</a>
<a name="ln1290">{</a>
<a name="ln1291">  long delay_secs;</a>
<a name="ln1292"> </a>
<a name="ln1293">  assert (!zfpm_g-&gt;t_connect);</a>
<a name="ln1294">  assert (zfpm_g-&gt;sock &lt; 0);</a>
<a name="ln1295"> </a>
<a name="ln1296">  assert(zfpm_g-&gt;state == ZFPM_STATE_IDLE ||</a>
<a name="ln1297">	 zfpm_g-&gt;state == ZFPM_STATE_ACTIVE ||</a>
<a name="ln1298">	 zfpm_g-&gt;state == ZFPM_STATE_CONNECTING);</a>
<a name="ln1299"> </a>
<a name="ln1300">  delay_secs = zfpm_calc_connect_delay();</a>
<a name="ln1301">  zfpm_debug (&quot;scheduling connect in %ld seconds&quot;, delay_secs);</a>
<a name="ln1302"> </a>
<a name="ln1303">  THREAD_TIMER_ON (zfpm_g-&gt;master, zfpm_g-&gt;t_connect, zfpm_connect_cb, 0,</a>
<a name="ln1304">		   delay_secs);</a>
<a name="ln1305">  zfpm_set_state (ZFPM_STATE_ACTIVE, reason);</a>
<a name="ln1306">}</a>
<a name="ln1307"> </a>
<a name="ln1308">/*</a>
<a name="ln1309"> * zfpm_is_enabled</a>
<a name="ln1310"> *</a>
<a name="ln1311"> * Returns TRUE if the zebra FPM module has been enabled.</a>
<a name="ln1312"> */</a>
<a name="ln1313">static inline int</a>
<a name="ln1314">zfpm_is_enabled (void)</a>
<a name="ln1315">{</a>
<a name="ln1316">  return zfpm_g-&gt;enabled;</a>
<a name="ln1317">}</a>
<a name="ln1318"> </a>
<a name="ln1319">/*</a>
<a name="ln1320"> * zfpm_conn_is_up</a>
<a name="ln1321"> *</a>
<a name="ln1322"> * Returns TRUE if the connection to the FPM is up.</a>
<a name="ln1323"> */</a>
<a name="ln1324">static inline int</a>
<a name="ln1325">zfpm_conn_is_up (void)</a>
<a name="ln1326">{</a>
<a name="ln1327">  if (zfpm_g-&gt;state != ZFPM_STATE_ESTABLISHED)</a>
<a name="ln1328">    return 0;</a>
<a name="ln1329"> </a>
<a name="ln1330">  assert (zfpm_g-&gt;sock &gt;= 0);</a>
<a name="ln1331"> </a>
<a name="ln1332">  return 1;</a>
<a name="ln1333">}</a>
<a name="ln1334"> </a>
<a name="ln1335">/*</a>
<a name="ln1336"> * zfpm_trigger_update</a>
<a name="ln1337"> *</a>
<a name="ln1338"> * The zebra code invokes this function to indicate that we should</a>
<a name="ln1339"> * send an update to the FPM about the given route_node.</a>
<a name="ln1340"> */</a>
<a name="ln1341">void</a>
<a name="ln1342">zfpm_trigger_update (struct route_node *rn, const char *reason)</a>
<a name="ln1343">{</a>
<a name="ln1344">  rib_dest_t *dest;</a>
<a name="ln1345">  char buf[PREFIX_STRLEN];</a>
<a name="ln1346"> </a>
<a name="ln1347">  /*</a>
<a name="ln1348">   * Ignore if the connection is down. We will update the FPM about</a>
<a name="ln1349">   * all destinations once the connection comes up.</a>
<a name="ln1350">   */</a>
<a name="ln1351">  if (!zfpm_conn_is_up ())</a>
<a name="ln1352">    return;</a>
<a name="ln1353"> </a>
<a name="ln1354">  dest = rib_dest_from_rnode (rn);</a>
<a name="ln1355"> </a>
<a name="ln1356">  /*</a>
<a name="ln1357">   * Ignore the trigger if the dest is not in a table that we would</a>
<a name="ln1358">   * send to the FPM.</a>
<a name="ln1359">   */</a>
<a name="ln1360">  if (!zfpm_is_table_for_fpm (rib_dest_table (dest)))</a>
<a name="ln1361">    {</a>
<a name="ln1362">      zfpm_g-&gt;stats.non_fpm_table_triggers++;</a>
<a name="ln1363">      return;</a>
<a name="ln1364">    }</a>
<a name="ln1365"> </a>
<a name="ln1366">  if (CHECK_FLAG (dest-&gt;flags, RIB_DEST_UPDATE_FPM)) {</a>
<a name="ln1367">    zfpm_g-&gt;stats.redundant_triggers++;</a>
<a name="ln1368">    return;</a>
<a name="ln1369">  }</a>
<a name="ln1370"> </a>
<a name="ln1371">  if (reason)</a>
<a name="ln1372">    {</a>
<a name="ln1373">      zfpm_debug (&quot;%s triggering update to FPM - Reason: %s&quot;,</a>
<a name="ln1374">		  prefix2str (&amp;rn-&gt;p, buf, sizeof(buf)), reason);</a>
<a name="ln1375">    }</a>
<a name="ln1376"> </a>
<a name="ln1377">  SET_FLAG (dest-&gt;flags, RIB_DEST_UPDATE_FPM);</a>
<a name="ln1378">  TAILQ_INSERT_TAIL (&amp;zfpm_g-&gt;dest_q, dest, fpm_q_entries);</a>
<a name="ln1379">  zfpm_g-&gt;stats.updates_triggered++;</a>
<a name="ln1380"> </a>
<a name="ln1381">  /*</a>
<a name="ln1382">   * Make sure that writes are enabled.</a>
<a name="ln1383">   */</a>
<a name="ln1384">  if (zfpm_g-&gt;t_write)</a>
<a name="ln1385">    return;</a>
<a name="ln1386"> </a>
<a name="ln1387">  zfpm_write_on ();</a>
<a name="ln1388">}</a>
<a name="ln1389"> </a>
<a name="ln1390">/*</a>
<a name="ln1391"> * zfpm_stats_timer_cb</a>
<a name="ln1392"> */</a>
<a name="ln1393">static int</a>
<a name="ln1394">zfpm_stats_timer_cb (struct thread *t)</a>
<a name="ln1395">{</a>
<a name="ln1396">  assert (zfpm_g-&gt;t_stats);</a>
<a name="ln1397">  zfpm_g-&gt;t_stats = NULL;</a>
<a name="ln1398"> </a>
<a name="ln1399">  /*</a>
<a name="ln1400">   * Remember the stats collected in the last interval for display</a>
<a name="ln1401">   * purposes.</a>
<a name="ln1402">   */</a>
<a name="ln1403">  zfpm_stats_copy (&amp;zfpm_g-&gt;stats, &amp;zfpm_g-&gt;last_ivl_stats);</a>
<a name="ln1404"> </a>
<a name="ln1405">  /*</a>
<a name="ln1406">   * Add the current set of stats into the cumulative statistics.</a>
<a name="ln1407">   */</a>
<a name="ln1408">  zfpm_stats_compose (&amp;zfpm_g-&gt;cumulative_stats, &amp;zfpm_g-&gt;stats,</a>
<a name="ln1409">		      &amp;zfpm_g-&gt;cumulative_stats);</a>
<a name="ln1410"> </a>
<a name="ln1411">  /*</a>
<a name="ln1412">   * Start collecting stats afresh over the next interval.</a>
<a name="ln1413">   */</a>
<a name="ln1414">  zfpm_stats_reset (&amp;zfpm_g-&gt;stats);</a>
<a name="ln1415"> </a>
<a name="ln1416">  zfpm_start_stats_timer ();</a>
<a name="ln1417"> </a>
<a name="ln1418">  return 0;</a>
<a name="ln1419">}</a>
<a name="ln1420"> </a>
<a name="ln1421">/*</a>
<a name="ln1422"> * zfpm_stop_stats_timer</a>
<a name="ln1423"> */</a>
<a name="ln1424">static void</a>
<a name="ln1425">zfpm_stop_stats_timer (void)</a>
<a name="ln1426">{</a>
<a name="ln1427">  if (!zfpm_g-&gt;t_stats)</a>
<a name="ln1428">    return;</a>
<a name="ln1429"> </a>
<a name="ln1430">  zfpm_debug (&quot;Stopping existing stats timer&quot;);</a>
<a name="ln1431">  THREAD_TIMER_OFF (zfpm_g-&gt;t_stats);</a>
<a name="ln1432">}</a>
<a name="ln1433"> </a>
<a name="ln1434">/*</a>
<a name="ln1435"> * zfpm_start_stats_timer</a>
<a name="ln1436"> */</a>
<a name="ln1437">void</a>
<a name="ln1438">zfpm_start_stats_timer (void)</a>
<a name="ln1439">{</a>
<a name="ln1440">  assert (!zfpm_g-&gt;t_stats);</a>
<a name="ln1441"> </a>
<a name="ln1442">  THREAD_TIMER_ON (zfpm_g-&gt;master, zfpm_g-&gt;t_stats, zfpm_stats_timer_cb, 0,</a>
<a name="ln1443">		   ZFPM_STATS_IVL_SECS);</a>
<a name="ln1444">}</a>
<a name="ln1445"> </a>
<a name="ln1446">/*</a>
<a name="ln1447"> * Helper macro for zfpm_show_stats() below.</a>
<a name="ln1448"> */</a>
<a name="ln1449">#define ZFPM_SHOW_STAT(counter)						\</a>
<a name="ln1450">  do {									\</a>
<a name="ln1451">    vty_out (vty, &quot;%-40s %10lu %16lu%s&quot;, #counter, total_stats.counter,	\</a>
<a name="ln1452">	     zfpm_g-&gt;last_ivl_stats.counter, VTY_NEWLINE);		\</a>
<a name="ln1453">  } while (0)</a>
<a name="ln1454"> </a>
<a name="ln1455">/*</a>
<a name="ln1456"> * zfpm_show_stats</a>
<a name="ln1457"> */</a>
<a name="ln1458">static void</a>
<a name="ln1459">zfpm_show_stats (struct vty *vty)</a>
<a name="ln1460">{</a>
<a name="ln1461">  zfpm_stats_t total_stats;</a>
<a name="ln1462">  time_t elapsed;</a>
<a name="ln1463"> </a>
<a name="ln1464">  vty_out (vty, &quot;%s%-40s %10s     Last %2d secs%s%s&quot;, VTY_NEWLINE, &quot;Counter&quot;,</a>
<a name="ln1465">	   &quot;Total&quot;, ZFPM_STATS_IVL_SECS, VTY_NEWLINE, VTY_NEWLINE);</a>
<a name="ln1466"> </a>
<a name="ln1467">  /*</a>
<a name="ln1468">   * Compute the total stats up to this instant.</a>
<a name="ln1469">   */</a>
<a name="ln1470">  zfpm_stats_compose (&amp;zfpm_g-&gt;cumulative_stats, &amp;zfpm_g-&gt;stats,</a>
<a name="ln1471">		      &amp;total_stats);</a>
<a name="ln1472"> </a>
<a name="ln1473">  ZFPM_SHOW_STAT (connect_calls);</a>
<a name="ln1474">  ZFPM_SHOW_STAT (connect_no_sock);</a>
<a name="ln1475">  ZFPM_SHOW_STAT (read_cb_calls);</a>
<a name="ln1476">  ZFPM_SHOW_STAT (write_cb_calls);</a>
<a name="ln1477">  ZFPM_SHOW_STAT (write_calls);</a>
<a name="ln1478">  ZFPM_SHOW_STAT (partial_writes);</a>
<a name="ln1479">  ZFPM_SHOW_STAT (max_writes_hit);</a>
<a name="ln1480">  ZFPM_SHOW_STAT (t_write_yields);</a>
<a name="ln1481">  ZFPM_SHOW_STAT (nop_deletes_skipped);</a>
<a name="ln1482">  ZFPM_SHOW_STAT (route_adds);</a>
<a name="ln1483">  ZFPM_SHOW_STAT (route_dels);</a>
<a name="ln1484">  ZFPM_SHOW_STAT (updates_triggered);</a>
<a name="ln1485">  ZFPM_SHOW_STAT (non_fpm_table_triggers);</a>
<a name="ln1486">  ZFPM_SHOW_STAT (redundant_triggers);</a>
<a name="ln1487">  ZFPM_SHOW_STAT (dests_del_after_update);</a>
<a name="ln1488">  ZFPM_SHOW_STAT (t_conn_down_starts);</a>
<a name="ln1489">  ZFPM_SHOW_STAT (t_conn_down_dests_processed);</a>
<a name="ln1490">  ZFPM_SHOW_STAT (t_conn_down_yields);</a>
<a name="ln1491">  ZFPM_SHOW_STAT (t_conn_down_finishes);</a>
<a name="ln1492">  ZFPM_SHOW_STAT (t_conn_up_starts);</a>
<a name="ln1493">  ZFPM_SHOW_STAT (t_conn_up_dests_processed);</a>
<a name="ln1494">  ZFPM_SHOW_STAT (t_conn_up_yields);</a>
<a name="ln1495">  ZFPM_SHOW_STAT (t_conn_up_aborts);</a>
<a name="ln1496">  ZFPM_SHOW_STAT (t_conn_up_finishes);</a>
<a name="ln1497"> </a>
<a name="ln1498">  if (!zfpm_g-&gt;last_stats_clear_time)</a>
<a name="ln1499">    return;</a>
<a name="ln1500"> </a>
<a name="ln1501">  elapsed = zfpm_get_elapsed_time (zfpm_g-&gt;last_stats_clear_time);</a>
<a name="ln1502"> </a>
<a name="ln1503">  vty_out (vty, &quot;%sStats were cleared %lu seconds ago%s&quot;, VTY_NEWLINE,</a>
<a name="ln1504">	   (unsigned long) elapsed, VTY_NEWLINE);</a>
<a name="ln1505">}</a>
<a name="ln1506"> </a>
<a name="ln1507">/*</a>
<a name="ln1508"> * zfpm_clear_stats</a>
<a name="ln1509"> */</a>
<a name="ln1510">static void</a>
<a name="ln1511">zfpm_clear_stats (struct vty *vty)</a>
<a name="ln1512">{</a>
<a name="ln1513">  if (!zfpm_is_enabled ())</a>
<a name="ln1514">    {</a>
<a name="ln1515">      vty_out (vty, &quot;The FPM module is not enabled...%s&quot;, VTY_NEWLINE);</a>
<a name="ln1516">      return;</a>
<a name="ln1517">    }</a>
<a name="ln1518"> </a>
<a name="ln1519">  zfpm_stats_reset (&amp;zfpm_g-&gt;stats);</a>
<a name="ln1520">  zfpm_stats_reset (&amp;zfpm_g-&gt;last_ivl_stats);</a>
<a name="ln1521">  zfpm_stats_reset (&amp;zfpm_g-&gt;cumulative_stats);</a>
<a name="ln1522"> </a>
<a name="ln1523">  zfpm_stop_stats_timer ();</a>
<a name="ln1524">  zfpm_start_stats_timer ();</a>
<a name="ln1525"> </a>
<a name="ln1526">  zfpm_g-&gt;last_stats_clear_time = zfpm_get_time();</a>
<a name="ln1527"> </a>
<a name="ln1528">  vty_out (vty, &quot;Cleared FPM stats%s&quot;, VTY_NEWLINE);</a>
<a name="ln1529">}</a>
<a name="ln1530"> </a>
<a name="ln1531">/*</a>
<a name="ln1532"> * show_zebra_fpm_stats</a>
<a name="ln1533"> */</a>
<a name="ln1534">DEFUN (show_zebra_fpm_stats,</a>
<a name="ln1535">       show_zebra_fpm_stats_cmd,</a>
<a name="ln1536">       &quot;show zebra fpm stats&quot;,</a>
<a name="ln1537">       SHOW_STR</a>
<a name="ln1538">       &quot;Zebra information\n&quot;</a>
<a name="ln1539">       &quot;Forwarding Path Manager information\n&quot;</a>
<a name="ln1540">       &quot;Statistics\n&quot;)</a>
<a name="ln1541">{</a>
<a name="ln1542">  zfpm_show_stats (vty);</a>
<a name="ln1543">  return CMD_SUCCESS;</a>
<a name="ln1544">}</a>
<a name="ln1545"> </a>
<a name="ln1546">/*</a>
<a name="ln1547"> * clear_zebra_fpm_stats</a>
<a name="ln1548"> */</a>
<a name="ln1549">DEFUN (clear_zebra_fpm_stats,</a>
<a name="ln1550">       clear_zebra_fpm_stats_cmd,</a>
<a name="ln1551">       &quot;clear zebra fpm stats&quot;,</a>
<a name="ln1552">       CLEAR_STR</a>
<a name="ln1553">       &quot;Zebra information\n&quot;</a>
<a name="ln1554">       &quot;Clear Forwarding Path Manager information\n&quot;</a>
<a name="ln1555">       &quot;Statistics\n&quot;)</a>
<a name="ln1556">{</a>
<a name="ln1557">  zfpm_clear_stats (vty);</a>
<a name="ln1558">  return CMD_SUCCESS;</a>
<a name="ln1559">}</a>
<a name="ln1560"> </a>
<a name="ln1561">/*</a>
<a name="ln1562"> * update fpm connection information </a>
<a name="ln1563"> */</a>
<a name="ln1564">DEFUN ( fpm_remote_ip, </a>
<a name="ln1565">        fpm_remote_ip_cmd,</a>
<a name="ln1566">        &quot;fpm connection ip A.B.C.D port &lt;1-65535&gt;&quot;,</a>
<a name="ln1567">        &quot;fpm connection remote ip and port\n&quot;</a>
<a name="ln1568">        &quot;Remote fpm server ip A.B.C.D\n&quot;</a>
<a name="ln1569">        &quot;Enter ip &quot;)</a>
<a name="ln1570">{</a>
<a name="ln1571"> </a>
<a name="ln1572">   in_addr_t fpm_server;</a>
<a name="ln1573">   uint32_t port_no;</a>
<a name="ln1574"> </a>
<a name="ln1575">   fpm_server = inet_addr (argv[0]);</a>
<a name="ln1576">   if (fpm_server == INADDR_NONE)</a>
<a name="ln1577">     return CMD_ERR_INCOMPLETE;</a>
<a name="ln1578"> </a>
<a name="ln1579">   port_no = atoi (argv[1]);</a>
<a name="ln1580">   if (port_no &lt; TCP_MIN_PORT || port_no &gt; TCP_MAX_PORT)</a>
<a name="ln1581">     return CMD_ERR_INCOMPLETE;</a>
<a name="ln1582"> </a>
<a name="ln1583">   zfpm_g-&gt;fpm_server = fpm_server;</a>
<a name="ln1584">   zfpm_g-&gt;fpm_port = port_no;</a>
<a name="ln1585"> </a>
<a name="ln1586"> </a>
<a name="ln1587">   return CMD_SUCCESS;</a>
<a name="ln1588">}</a>
<a name="ln1589"> </a>
<a name="ln1590">DEFUN ( no_fpm_remote_ip, </a>
<a name="ln1591">        no_fpm_remote_ip_cmd,</a>
<a name="ln1592">        &quot;no fpm connection ip A.B.C.D port &lt;1-65535&gt;&quot;,</a>
<a name="ln1593">        &quot;fpm connection remote ip and port\n&quot;</a>
<a name="ln1594">        &quot;Connection\n&quot;</a>
<a name="ln1595">        &quot;Remote fpm server ip A.B.C.D\n&quot;</a>
<a name="ln1596">        &quot;Enter ip &quot;)</a>
<a name="ln1597">{</a>
<a name="ln1598">   if (zfpm_g-&gt;fpm_server != inet_addr (argv[0]) || </a>
<a name="ln1599">              zfpm_g-&gt;fpm_port !=  atoi (argv[1]))</a>
<a name="ln1600">       return CMD_ERR_NO_MATCH;</a>
<a name="ln1601"> </a>
<a name="ln1602">   zfpm_g-&gt;fpm_server = FPM_DEFAULT_IP;</a>
<a name="ln1603">   zfpm_g-&gt;fpm_port = FPM_DEFAULT_PORT;</a>
<a name="ln1604"> </a>
<a name="ln1605">   return CMD_SUCCESS;</a>
<a name="ln1606">}</a>
<a name="ln1607"> </a>
<a name="ln1608"> </a>
<a name="ln1609">/*</a>
<a name="ln1610"> * zfpm_init_message_format</a>
<a name="ln1611"> */</a>
<a name="ln1612">static inline void</a>
<a name="ln1613">zfpm_init_message_format (const char *format)</a>
<a name="ln1614">{</a>
<a name="ln1615">  int have_netlink, have_protobuf;</a>
<a name="ln1616"> </a>
<a name="ln1617">  have_netlink = have_protobuf = 0;</a>
<a name="ln1618"> </a>
<a name="ln1619">#ifdef HAVE_NETLINK</a>
<a name="ln1620">  have_netlink = 1;</a>
<a name="ln1621">#endif</a>
<a name="ln1622"> </a>
<a name="ln1623">#ifdef HAVE_PROTOBUF</a>
<a name="ln1624">  have_protobuf = 1;</a>
<a name="ln1625">#endif</a>
<a name="ln1626"> </a>
<a name="ln1627">  zfpm_g-&gt;message_format = ZFPM_MSG_FORMAT_NONE;</a>
<a name="ln1628"> </a>
<a name="ln1629">  if (!format)</a>
<a name="ln1630">    {</a>
<a name="ln1631">      if (have_netlink)</a>
<a name="ln1632">	{</a>
<a name="ln1633">	  zfpm_g-&gt;message_format = ZFPM_MSG_FORMAT_NETLINK;</a>
<a name="ln1634">	}</a>
<a name="ln1635">      else if (have_protobuf)</a>
<a name="ln1636">	{</a>
<a name="ln1637">	  zfpm_g-&gt;message_format = ZFPM_MSG_FORMAT_PROTOBUF;</a>
<a name="ln1638">	}</a>
<a name="ln1639">      return;</a>
<a name="ln1640">    }</a>
<a name="ln1641"> </a>
<a name="ln1642">  if (!strcmp (&quot;netlink&quot;, format))</a>
<a name="ln1643">    {</a>
<a name="ln1644">      if (!have_netlink)</a>
<a name="ln1645">	{</a>
<a name="ln1646">	  zlog_err (&quot;FPM netlink message format is not available&quot;);</a>
<a name="ln1647">	  return;</a>
<a name="ln1648">	}</a>
<a name="ln1649">      zfpm_g-&gt;message_format = ZFPM_MSG_FORMAT_NETLINK;</a>
<a name="ln1650">      return;</a>
<a name="ln1651">    }</a>
<a name="ln1652"> </a>
<a name="ln1653">  if (!strcmp (&quot;protobuf&quot;, format))</a>
<a name="ln1654">    {</a>
<a name="ln1655">      if (!have_protobuf)</a>
<a name="ln1656">	{</a>
<a name="ln1657">	  zlog_err (&quot;FPM protobuf message format is not available&quot;);</a>
<a name="ln1658">	  return;</a>
<a name="ln1659">	}</a>
<a name="ln1660">      zfpm_g-&gt;message_format = ZFPM_MSG_FORMAT_PROTOBUF;</a>
<a name="ln1661">      return;</a>
<a name="ln1662">    }</a>
<a name="ln1663"> </a>
<a name="ln1664">  zlog_warn (&quot;Unknown fpm format '%s'&quot;, format);</a>
<a name="ln1665">}</a>
<a name="ln1666"> </a>
<a name="ln1667">/**</a>
<a name="ln1668"> * fpm_remote_srv_write </a>
<a name="ln1669"> *</a>
<a name="ln1670"> * Module to write remote fpm connection </a>
<a name="ln1671"> *</a>
<a name="ln1672"> * Returns ZERO on success.</a>
<a name="ln1673"> */</a>
<a name="ln1674"> </a>
<a name="ln1675">int fpm_remote_srv_write (struct vty *vty )</a>
<a name="ln1676">{</a>
<a name="ln1677">   struct in_addr in;</a>
<a name="ln1678"> </a>
<a name="ln1679">   in.s_addr = zfpm_g-&gt;fpm_server;</a>
<a name="ln1680"> </a>
<a name="ln1681">   if (zfpm_g-&gt;fpm_server != FPM_DEFAULT_IP || </a>
<a name="ln1682">          zfpm_g-&gt;fpm_port != FPM_DEFAULT_PORT)</a>
<a name="ln1683">      vty_out (vty,&quot;fpm connection ip %s port %d%s&quot;, inet_ntoa (in),zfpm_g-&gt;fpm_port,VTY_NEWLINE);</a>
<a name="ln1684"> </a>
<a name="ln1685">   return 0;</a>
<a name="ln1686">}</a>
<a name="ln1687"> </a>
<a name="ln1688"> </a>
<a name="ln1689">/**</a>
<a name="ln1690"> * zfpm_init</a>
<a name="ln1691"> *</a>
<a name="ln1692"> * One-time initialization of the Zebra FPM module.</a>
<a name="ln1693"> *</a>
<a name="ln1694"> * @param[in] port port at which FPM is running.</a>
<a name="ln1695"> * @param[in] enable TRUE if the zebra FPM module should be enabled</a>
<a name="ln1696"> * @param[in] format to use to talk to the FPM. Can be 'netink' or 'protobuf'.</a>
<a name="ln1697"> *</a>
<a name="ln1698"> * Returns TRUE on success.</a>
<a name="ln1699"> */</a>
<a name="ln1700">int</a>
<a name="ln1701">zfpm_init (struct thread_master *master, int enable, uint16_t port,</a>
<a name="ln1702">	   const char *format)</a>
<a name="ln1703">{</a>
<a name="ln1704">  static int initialized = 0;</a>
<a name="ln1705"> </a>
<a name="ln1706">  if (initialized) {</a>
<a name="ln1707">    return 1;</a>
<a name="ln1708">  }</a>
<a name="ln1709"> </a>
<a name="ln1710">  initialized = 1;</a>
<a name="ln1711"> </a>
<a name="ln1712">  memset (zfpm_g, 0, sizeof (*zfpm_g));</a>
<a name="ln1713">  zfpm_g-&gt;master = master;</a>
<a name="ln1714">  TAILQ_INIT(&amp;zfpm_g-&gt;dest_q);</a>
<a name="ln1715">  zfpm_g-&gt;sock = -1;</a>
<a name="ln1716">  zfpm_g-&gt;state = ZFPM_STATE_IDLE;</a>
<a name="ln1717"> </a>
<a name="ln1718">  zfpm_stats_init (&amp;zfpm_g-&gt;stats);</a>
<a name="ln1719">  zfpm_stats_init (&amp;zfpm_g-&gt;last_ivl_stats);</a>
<a name="ln1720">  zfpm_stats_init (&amp;zfpm_g-&gt;cumulative_stats);</a>
<a name="ln1721"> </a>
<a name="ln1722">  install_element (ENABLE_NODE, &amp;show_zebra_fpm_stats_cmd);</a>
<a name="ln1723">  install_element (ENABLE_NODE, &amp;clear_zebra_fpm_stats_cmd);</a>
<a name="ln1724">  install_element (CONFIG_NODE, &amp;fpm_remote_ip_cmd);</a>
<a name="ln1725">  install_element (CONFIG_NODE, &amp;no_fpm_remote_ip_cmd);</a>
<a name="ln1726"> </a>
<a name="ln1727">  zfpm_init_message_format(format);</a>
<a name="ln1728"> </a>
<a name="ln1729">  /*</a>
<a name="ln1730">   * Disable FPM interface if no suitable format is available.</a>
<a name="ln1731">   */</a>
<a name="ln1732">  if (zfpm_g-&gt;message_format == ZFPM_MSG_FORMAT_NONE)</a>
<a name="ln1733">      enable = 0;</a>
<a name="ln1734"> </a>
<a name="ln1735">  zfpm_g-&gt;enabled = enable;</a>
<a name="ln1736"> </a>
<a name="ln1737">  if (!enable) {</a>
<a name="ln1738">    return 1;</a>
<a name="ln1739">  }</a>
<a name="ln1740"> </a>
<a name="ln1741">  if (!zfpm_g-&gt;fpm_server)</a>
<a name="ln1742">     zfpm_g-&gt;fpm_server = FPM_DEFAULT_IP;</a>
<a name="ln1743"> </a>
<a name="ln1744">  if (!port)</a>
<a name="ln1745">    port = FPM_DEFAULT_PORT;</a>
<a name="ln1746"> </a>
<a name="ln1747">  zfpm_g-&gt;fpm_port = port;</a>
<a name="ln1748"> </a>
<a name="ln1749">  zfpm_g-&gt;obuf = stream_new (ZFPM_OBUF_SIZE);</a>
<a name="ln1750">  zfpm_g-&gt;ibuf = stream_new (ZFPM_IBUF_SIZE);</a>
<a name="ln1751"> </a>
<a name="ln1752">  zfpm_start_stats_timer ();</a>
<a name="ln1753">  zfpm_start_connect_timer (&quot;initialized&quot;);</a>
<a name="ln1754"> </a>
<a name="ln1755">  return 1;</a>
<a name="ln1756">}</a>

</code></pre>
<div class="balloon" rel="10"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="904"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1048/" target="_blank">V1048</a> The '* msg_type' variable was assigned the same value.</p></div>
<div class="balloon" rel="1005"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'data_len' is always true.</p></div>
<div class="balloon" rel="1631"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'have_netlink' is always true.</p></div>
<div class="balloon" rel="1644"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!have_netlink' is always false.</p></div>
<div class="balloon" rel="1655"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression '!have_protobuf' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
