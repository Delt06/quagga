
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>test_main.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* main routine.</a>
<a name="ln2"> * Copyright (C) 1997, 98 Kunihiro Ishiguro</a>
<a name="ln3"> *</a>
<a name="ln4"> * GNU Zebra is free software; you can redistribute it and/or modify it</a>
<a name="ln5"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln6"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln7"> * later version.</a>
<a name="ln8"> *</a>
<a name="ln9"> * GNU Zebra is distributed in the hope that it will be useful, but</a>
<a name="ln10"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln11"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln12"> * General Public License for more details.</a>
<a name="ln13"> *</a>
<a name="ln14"> * You should have received a copy of the GNU General Public License</a>
<a name="ln15"> * along with GNU Zebra; see the file COPYING.  If not, write to the Free</a>
<a name="ln16"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln17"> * 02111-1307, USA.  </a>
<a name="ln18"> */</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;zebra.h&gt;</a>
<a name="ln21"> </a>
<a name="ln22">#include &lt;lib/version.h&gt;</a>
<a name="ln23">#include &quot;getopt.h&quot;</a>
<a name="ln24">#include &quot;command.h&quot;</a>
<a name="ln25">#include &quot;thread.h&quot;</a>
<a name="ln26">#include &quot;filter.h&quot;</a>
<a name="ln27">#include &quot;memory.h&quot;</a>
<a name="ln28">#include &quot;prefix.h&quot;</a>
<a name="ln29">#include &quot;log.h&quot;</a>
<a name="ln30">#include &quot;privs.h&quot;</a>
<a name="ln31">#include &quot;sigevent.h&quot;</a>
<a name="ln32">#include &quot;vrf.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34">#include &quot;zebra/rib.h&quot;</a>
<a name="ln35">#include &quot;zebra/zserv.h&quot;</a>
<a name="ln36">#include &quot;zebra/debug.h&quot;</a>
<a name="ln37">#include &quot;zebra/router-id.h&quot;</a>
<a name="ln38">#include &quot;zebra/interface.h&quot;</a>
<a name="ln39"> </a>
<a name="ln40">/* Zebra instance */</a>
<a name="ln41">struct zebra_t zebrad =</a>
<a name="ln42">{</a>
<a name="ln43">  .rtm_table_default = 0,</a>
<a name="ln44">};</a>
<a name="ln45"> </a>
<a name="ln46">/* process id. */</a>
<a name="ln47">pid_t pid;</a>
<a name="ln48"> </a>
<a name="ln49">/* zebra_rib's workqueue hold time. Private export for use by test code only */</a>
<a name="ln50">extern int rib_process_hold_time;</a>
<a name="ln51"> </a>
<a name="ln52">/* Pacify zclient.o in libzebra, which expects this variable. */</a>
<a name="ln53">struct thread_master *master;</a>
<a name="ln54"> </a>
<a name="ln55">/* Command line options. */</a>
<a name="ln56">struct option longopts[] = </a>
<a name="ln57">{</a>
<a name="ln58">  { &quot;batch&quot;,       no_argument,       NULL, 'b'},</a>
<a name="ln59">  { &quot;daemon&quot;,      no_argument,       NULL, 'd'},</a>
<a name="ln60">  { &quot;config_file&quot;, required_argument, NULL, 'f'},</a>
<a name="ln61">  { &quot;help&quot;,        no_argument,       NULL, 'h'},</a>
<a name="ln62">  { &quot;vty_addr&quot;,    required_argument, NULL, 'A'},</a>
<a name="ln63">  { &quot;vty_port&quot;,    required_argument, NULL, 'P'},</a>
<a name="ln64">  { &quot;version&quot;,     no_argument,       NULL, 'v'},</a>
<a name="ln65">  { &quot;rib_hold&quot;,	   required_argument, NULL, 'r'},</a>
<a name="ln66">  { 0 }</a>
<a name="ln67">};</a>
<a name="ln68"> </a>
<a name="ln69">zebra_capabilities_t _caps_p [] = </a>
<a name="ln70">{</a>
<a name="ln71">  ZCAP_NET_ADMIN,</a>
<a name="ln72">  ZCAP_SYS_ADMIN,</a>
<a name="ln73">  ZCAP_NET_RAW,</a>
<a name="ln74">};</a>
<a name="ln75"> </a>
<a name="ln76">/* Default configuration file path. */</a>
<a name="ln77">char config_default[] = SYSCONFDIR DEFAULT_CONFIG_FILE;</a>
<a name="ln78"> </a>
<a name="ln79">/* Process ID saved for use by init system */</a>
<a name="ln80">const char *pid_file = PATH_ZEBRA_PID;</a>
<a name="ln81"> </a>
<a name="ln82">/* Help information display. */</a>
<a name="ln83">static void</a>
<a name="ln84">usage (char *progname, int status)</a>
<a name="ln85">{</a>
<a name="ln86">  if (status != 0)</a>
<a name="ln87">    fprintf (stderr, &quot;Try `%s --help' for more information.\n&quot;, progname);</a>
<a name="ln88">  else</a>
<a name="ln89">    {    </a>
<a name="ln90">      printf (&quot;Usage : %s [OPTION...]\n\n&quot;\</a>
<a name="ln91">	      &quot;Daemon which manages kernel routing table management and &quot;\</a>
<a name="ln92">	      &quot;redistribution between different routing protocols.\n\n&quot;\</a>
<a name="ln93">	      &quot;-b, --batch        Runs in batch mode\n&quot;\</a>
<a name="ln94">	      &quot;-d, --daemon       Runs in daemon mode\n&quot;\</a>
<a name="ln95">	      &quot;-f, --config_file  Set configuration file name\n&quot;\</a>
<a name="ln96">	      &quot;-A, --vty_addr     Set vty's bind address\n&quot;\</a>
<a name="ln97">	      &quot;-P, --vty_port     Set vty's port number\n&quot;\</a>
<a name="ln98">	      &quot;-r, --rib_hold	  Set rib-queue hold time\n&quot;\</a>
<a name="ln99">              &quot;-v, --version      Print program version\n&quot;\</a>
<a name="ln100">	      &quot;-h, --help         Display this help and exit\n&quot;\</a>
<a name="ln101">	      &quot;\n&quot;\</a>
<a name="ln102">	      &quot;Report bugs to %s\n&quot;, progname, ZEBRA_BUG_ADDRESS);</a>
<a name="ln103">    }</a>
<a name="ln104"> </a>
<a name="ln105">  exit (status);</a>
<a name="ln106">}</a>
<a name="ln107"> </a>
<a name="ln108">static ifindex_t test_ifindex = 0;</a>
<a name="ln109"> </a>
<a name="ln110">/* testrib commands */</a>
<a name="ln111">DEFUN (test_interface_state,</a>
<a name="ln112">       test_interface_state_cmd,</a>
<a name="ln113">       &quot;state (up|down)&quot;,</a>
<a name="ln114">       &quot;configure interface\n&quot;</a>
<a name="ln115">       &quot;up\n&quot;</a>
<a name="ln116">       &quot;down\n&quot;)</a>
<a name="ln117">{</a>
<a name="ln118">  struct interface *ifp;</a>
<a name="ln119">  if (argc &lt; 1)</a>
<a name="ln120">    return CMD_WARNING;</a>
<a name="ln121">  </a>
<a name="ln122">  ifp = vty-&gt;index;</a>
<a name="ln123">  if (ifp-&gt;ifindex == IFINDEX_INTERNAL)</a>
<a name="ln124">    {</a>
<a name="ln125">      ifp-&gt;ifindex = ++test_ifindex;</a>
<a name="ln126">      ifp-&gt;mtu = 1500;</a>
<a name="ln127">      ifp-&gt;flags = IFF_BROADCAST|IFF_MULTICAST;</a>
<a name="ln128">    }</a>
<a name="ln129">  </a>
<a name="ln130">  switch (argv[0][0])</a>
<a name="ln131">    {</a>
<a name="ln132">      case 'u':</a>
<a name="ln133">        SET_FLAG (ifp-&gt;flags, IFF_UP);</a>
<a name="ln134">        if_add_update (ifp);</a>
<a name="ln135">        printf (&quot;up\n&quot;);</a>
<a name="ln136">        break;</a>
<a name="ln137">      case 'd':</a>
<a name="ln138">        UNSET_FLAG (ifp-&gt;flags, IFF_UP);</a>
<a name="ln139">        if_delete_update (ifp);</a>
<a name="ln140">        printf (&quot;down\n&quot;);</a>
<a name="ln141">        break;</a>
<a name="ln142">      default:</a>
<a name="ln143">        return CMD_WARNING;</a>
<a name="ln144">    }</a>
<a name="ln145">  return CMD_SUCCESS;</a>
<a name="ln146">}</a>
<a name="ln147"> </a>
<a name="ln148">static void</a>
<a name="ln149">test_cmd_init (void)</a>
<a name="ln150">{</a>
<a name="ln151">  install_element (INTERFACE_NODE, &amp;test_interface_state_cmd);</a>
<a name="ln152">}</a>
<a name="ln153"> </a>
<a name="ln154">/* SIGHUP handler. */</a>
<a name="ln155">static void </a>
<a name="ln156">sighup (void)</a>
<a name="ln157">{</a>
<a name="ln158">  zlog_info (&quot;SIGHUP received&quot;);</a>
<a name="ln159"> </a>
<a name="ln160">  /* Reload of config file. */</a>
<a name="ln161">  ;</a>
<a name="ln162">}</a>
<a name="ln163"> </a>
<a name="ln164">/* SIGINT handler. */</a>
<a name="ln165">static void</a>
<a name="ln166">sigint (void)</a>
<a name="ln167">{</a>
<a name="ln168">  zlog_notice (&quot;Terminating on signal&quot;);</a>
<a name="ln169"> </a>
<a name="ln170">  exit (0);</a>
<a name="ln171">}</a>
<a name="ln172"> </a>
<a name="ln173">/* SIGUSR1 handler. */</a>
<a name="ln174">static void</a>
<a name="ln175">sigusr1 (void)</a>
<a name="ln176">{</a>
<a name="ln177">  zlog_rotate (NULL);</a>
<a name="ln178">}</a>
<a name="ln179"> </a>
<a name="ln180">struct quagga_signal_t zebra_signals[] =</a>
<a name="ln181">{</a>
<a name="ln182">  { </a>
<a name="ln183">    .signal = SIGHUP, </a>
<a name="ln184">    .handler = &amp;sighup,</a>
<a name="ln185">  },</a>
<a name="ln186">  {</a>
<a name="ln187">    .signal = SIGUSR1,</a>
<a name="ln188">    .handler = &amp;sigusr1,</a>
<a name="ln189">  },</a>
<a name="ln190">  {</a>
<a name="ln191">    .signal = SIGINT,</a>
<a name="ln192">    .handler = &amp;sigint,</a>
<a name="ln193">  },</a>
<a name="ln194">  {</a>
<a name="ln195">    .signal = SIGTERM,</a>
<a name="ln196">    .handler = &amp;sigint,</a>
<a name="ln197">  },</a>
<a name="ln198">};</a>
<a name="ln199"> </a>
<a name="ln200">/* Callback upon creating a new VRF. */</a>
<a name="ln201">static int</a>
<a name="ln202">zebra_vrf_new (vrf_id_t vrf_id, void **info)</a>
<a name="ln203">{</a>
<a name="ln204">  struct zebra_vrf *zvrf = *info;</a>
<a name="ln205"> </a>
<a name="ln206">  if (! zvrf)</a>
<a name="ln207">    {</a>
<a name="ln208">      zvrf = zebra_vrf_alloc (vrf_id);</a>
<a name="ln209">      *info = (void *)zvrf;</a>
<a name="ln210">    }</a>
<a name="ln211"> </a>
<a name="ln212">  return 0;</a>
<a name="ln213">}</a>
<a name="ln214"> </a>
<a name="ln215">/* Callback upon enabling a VRF. */</a>
<a name="ln216">static int</a>
<a name="ln217">zebra_vrf_enable (vrf_id_t vrf_id, void **info)</a>
<a name="ln218">{</a>
<a name="ln219">  struct zebra_vrf *zvrf = (struct zebra_vrf *) (*info);</a>
<a name="ln220"> </a>
<a name="ln221">  assert (zvrf);</a>
<a name="ln222"> </a>
<a name="ln223">  kernel_init (zvrf);</a>
<a name="ln224">  route_read (zvrf);</a>
<a name="ln225"> </a>
<a name="ln226">  return 0;</a>
<a name="ln227">}</a>
<a name="ln228"> </a>
<a name="ln229">/* Callback upon disabling a VRF. */</a>
<a name="ln230">static int</a>
<a name="ln231">zebra_vrf_disable (vrf_id_t vrf_id, void **info)</a>
<a name="ln232">{</a>
<a name="ln233">  struct zebra_vrf *zvrf = (struct zebra_vrf *) (*info);</a>
<a name="ln234">  struct listnode *list_node;</a>
<a name="ln235">  struct interface *ifp;</a>
<a name="ln236"> </a>
<a name="ln237">  assert (zvrf);</a>
<a name="ln238"> </a>
<a name="ln239">  rib_close_table (zvrf-&gt;table[AFI_IP][SAFI_UNICAST]);</a>
<a name="ln240">  rib_close_table (zvrf-&gt;table[AFI_IP6][SAFI_UNICAST]);</a>
<a name="ln241"> </a>
<a name="ln242">  for (ALL_LIST_ELEMENTS_RO (vrf_iflist (vrf_id), list_node, ifp))</a>
<a name="ln243">    {</a>
<a name="ln244">      int operative = if_is_operative (ifp);</a>
<a name="ln245">      UNSET_FLAG (ifp-&gt;flags, IFF_UP);</a>
<a name="ln246">      if (operative)</a>
<a name="ln247">        if_down (ifp);</a>
<a name="ln248">    }</a>
<a name="ln249"> </a>
<a name="ln250">  kernel_terminate (zvrf);</a>
<a name="ln251"> </a>
<a name="ln252">  return 0;</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">/* Zebra VRF initialization. */</a>
<a name="ln256">static void</a>
<a name="ln257">zebra_vrf_init (void)</a>
<a name="ln258">{</a>
<a name="ln259">  vrf_add_hook (VRF_NEW_HOOK, zebra_vrf_new);</a>
<a name="ln260">  vrf_add_hook (VRF_ENABLE_HOOK, zebra_vrf_enable);</a>
<a name="ln261">  vrf_add_hook (VRF_DISABLE_HOOK, zebra_vrf_disable);</a>
<a name="ln262">  vrf_init ();</a>
<a name="ln263">}</a>
<a name="ln264"> </a>
<a name="ln265">/* Main startup routine. */</a>
<a name="ln266">int</a>
<a name="ln267">main (int argc, char **argv)</a>
<a name="ln268">{</a>
<a name="ln269">  char *p;</a>
<a name="ln270">  char *vty_addr = NULL;</a>
<a name="ln271">  int vty_port = 0;</a>
<a name="ln272">  int batch_mode = 0;</a>
<a name="ln273">  int daemon_mode = 0;</a>
<a name="ln274">  char *config_file = NULL;</a>
<a name="ln275">  char *progname;</a>
<a name="ln276"> </a>
<a name="ln277">  /* Set umask before anything for security */</a>
<a name="ln278">  umask (0027);</a>
<a name="ln279"> </a>
<a name="ln280">  /* preserve my name */</a>
<a name="ln281">  progname = ((p = strrchr (argv[0], '/')) ? ++p : argv[0]);</a>
<a name="ln282"> </a>
<a name="ln283">  zlog_default = openzlog (progname, ZLOG_ZEBRA,</a>
<a name="ln284">			   LOG_CONS|LOG_NDELAY|LOG_PID, LOG_DAEMON);</a>
<a name="ln285"> </a>
<a name="ln286">  while (1) </a>
<a name="ln287">    {</a>
<a name="ln288">      int opt;</a>
<a name="ln289">  </a>
<a name="ln290">      opt = getopt_long (argc, argv, &quot;bdf:hA:P:r:v&quot;, longopts, 0);</a>
<a name="ln291"> </a>
<a name="ln292">      if (opt == EOF)</a>
<a name="ln293">	break;</a>
<a name="ln294"> </a>
<a name="ln295">      switch (opt) </a>
<a name="ln296">	{</a>
<a name="ln297">	case 0:</a>
<a name="ln298">	  break;</a>
<a name="ln299">	case 'b':</a>
<a name="ln300">	  batch_mode = 1;</a>
<a name="ln301">	case 'd':</a>
<a name="ln302">	  daemon_mode = 1;</a>
<a name="ln303">	  break;</a>
<a name="ln304">	case 'f':</a>
<a name="ln305">	  config_file = optarg;</a>
<a name="ln306">	  break;</a>
<a name="ln307">	case 'A':</a>
<a name="ln308">	  vty_addr = optarg;</a>
<a name="ln309">	  break;</a>
<a name="ln310">	case 'P':</a>
<a name="ln311">	  /* Deal with atoi() returning 0 on failure, and zebra not</a>
<a name="ln312">	     listening on zebra port... */</a>
<a name="ln313">	  if (strcmp(optarg, &quot;0&quot;) == 0) </a>
<a name="ln314">	    {</a>
<a name="ln315">	      vty_port = 0;</a>
<a name="ln316">	      break;</a>
<a name="ln317">	    } </a>
<a name="ln318">	  vty_port = atoi (optarg);</a>
<a name="ln319">	  break;</a>
<a name="ln320">	case 'r':</a>
<a name="ln321">	  rib_process_hold_time = atoi(optarg);</a>
<a name="ln322">	  break;</a>
<a name="ln323">	case 'v':</a>
<a name="ln324">	  print_version (progname);</a>
<a name="ln325">	  exit (0);</a>
<a name="ln326">	  break;</a>
<a name="ln327">	case 'h':</a>
<a name="ln328">	  usage (progname, 0);</a>
<a name="ln329">	  break;</a>
<a name="ln330">	default:</a>
<a name="ln331">	  usage (progname, 1);</a>
<a name="ln332">	  break;</a>
<a name="ln333">	}</a>
<a name="ln334">    }</a>
<a name="ln335">  </a>
<a name="ln336">  /* port and conf file mandatory */</a>
<a name="ln337">  if (!vty_port || !config_file)</a>
<a name="ln338">    {</a>
<a name="ln339">      fprintf (stderr, &quot;Error: --vty_port and --config_file arguments&quot;</a>
<a name="ln340">                       &quot; are both required\n&quot;);</a>
<a name="ln341">      usage (progname, 1);</a>
<a name="ln342">    }</a>
<a name="ln343">  </a>
<a name="ln344">  /* Make master thread emulator. */</a>
<a name="ln345">  zebrad.master = thread_master_create ();</a>
<a name="ln346"> </a>
<a name="ln347">  /* Vty related initialize. */</a>
<a name="ln348">  signal_init (zebrad.master, array_size(zebra_signals), zebra_signals);</a>
<a name="ln349">  cmd_init (1);</a>
<a name="ln350">  vty_init (zebrad.master);</a>
<a name="ln351">  memory_init ();</a>
<a name="ln352">  zebra_debug_init ();</a>
<a name="ln353">  zebra_if_init ();</a>
<a name="ln354">  test_cmd_init ();</a>
<a name="ln355"> </a>
<a name="ln356">  /* Zebra related initialize. */</a>
<a name="ln357">  rib_init ();</a>
<a name="ln358">  access_list_init ();</a>
<a name="ln359"> </a>
<a name="ln360">  /* Make kernel routing socket. */</a>
<a name="ln361">  zebra_vrf_init ();</a>
<a name="ln362">  zebra_vty_init();</a>
<a name="ln363"> </a>
<a name="ln364">  /* Configuration file read*/</a>
<a name="ln365">  vty_read_config (config_file, config_default);</a>
<a name="ln366"> </a>
<a name="ln367">  /* Clean up rib. */</a>
<a name="ln368">  rib_weed_tables ();</a>
<a name="ln369"> </a>
<a name="ln370">  /* Exit when zebra is working in batch mode. */</a>
<a name="ln371">  if (batch_mode)</a>
<a name="ln372">    exit (0);</a>
<a name="ln373"> </a>
<a name="ln374">  /* Daemonize. */</a>
<a name="ln375">  if (daemon_mode &amp;&amp; daemon (0, 0) &lt; 0)</a>
<a name="ln376">    {</a>
<a name="ln377">      perror(&quot;daemon start failed&quot;);</a>
<a name="ln378">      exit (1);</a>
<a name="ln379">    }</a>
<a name="ln380"> </a>
<a name="ln381">  /* Needed for BSD routing socket. */</a>
<a name="ln382">  pid = getpid ();</a>
<a name="ln383"> </a>
<a name="ln384">  /* Make vty server socket. */</a>
<a name="ln385">  vty_serv_sock (vty_addr, vty_port, &quot;/tmp/test_zebra&quot;);</a>
<a name="ln386"> </a>
<a name="ln387">  /* Print banner. */</a>
<a name="ln388">  zlog_notice (&quot;Zebra %s starting: vty@%d&quot;, QUAGGA_VERSION, vty_port);</a>
<a name="ln389"> </a>
<a name="ln390">  thread_main (zebrad.master);</a>
<a name="ln391"> </a>
<a name="ln392">  /* Not reached... */</a>
<a name="ln393">  return 0;</a>
<a name="ln394">}</a>

</code></pre>
<div class="balloon" rel="5"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
