
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bgp_mpath.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* $QuaggaId: Format:%an, %ai, %h$ $</a>
<a name="ln2"> *</a>
<a name="ln3"> * BGP Multipath</a>
<a name="ln4"> * Copyright (C) 2010 Google Inc.</a>
<a name="ln5"> *</a>
<a name="ln6"> * This file is part of Quagga</a>
<a name="ln7"> *</a>
<a name="ln8"> * Quagga is free software; you can redistribute it and/or modify it</a>
<a name="ln9"> * under the terms of the GNU General Public License as published by the</a>
<a name="ln10"> * Free Software Foundation; either version 2, or (at your option) any</a>
<a name="ln11"> * later version.</a>
<a name="ln12"> *</a>
<a name="ln13"> * Quagga is distributed in the hope that it will be useful, but</a>
<a name="ln14"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln15"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln16"> * General Public License for more details.</a>
<a name="ln17"> *</a>
<a name="ln18"> * You should have received a copy of the GNU General Public License</a>
<a name="ln19"> * along with Quagga; see the file COPYING.  If not, write to the Free</a>
<a name="ln20"> * Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA</a>
<a name="ln21"> * 02111-1307, USA.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">#include &lt;zebra.h&gt;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;command.h&quot;</a>
<a name="ln27">#include &quot;prefix.h&quot;</a>
<a name="ln28">#include &quot;linklist.h&quot;</a>
<a name="ln29">#include &quot;sockunion.h&quot;</a>
<a name="ln30">#include &quot;memory.h&quot;</a>
<a name="ln31">#include &quot;filter.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#include &quot;bgpd/bgpd.h&quot;</a>
<a name="ln34">#include &quot;bgpd/bgp_table.h&quot;</a>
<a name="ln35">#include &quot;bgpd/bgp_route.h&quot;</a>
<a name="ln36">#include &quot;bgpd/bgp_attr.h&quot;</a>
<a name="ln37">#include &quot;bgpd/bgp_debug.h&quot;</a>
<a name="ln38">#include &quot;bgpd/bgp_aspath.h&quot;</a>
<a name="ln39">#include &quot;bgpd/bgp_community.h&quot;</a>
<a name="ln40">#include &quot;bgpd/bgp_ecommunity.h&quot;</a>
<a name="ln41">#include &quot;bgpd/bgp_lcommunity.h&quot;</a>
<a name="ln42">#include &quot;bgpd/bgp_mpath.h&quot;</a>
<a name="ln43"> </a>
<a name="ln44">bool</a>
<a name="ln45">bgp_mpath_is_configured_sort (struct bgp *bgp, bgp_peer_sort_t sort,</a>
<a name="ln46">                              afi_t afi, safi_t safi)</a>
<a name="ln47">{</a>
<a name="ln48">  struct bgp_maxpaths_cfg *cfg = &amp;bgp-&gt;maxpaths[afi][safi];</a>
<a name="ln49"> </a>
<a name="ln50">  /* XXX: BGP_DEFAULT_MAXPATHS is 1, and this test only seems to make sense</a>
<a name="ln51">   * if if it stays 1, so not sure the DEFAULT define is that useful.</a>
<a name="ln52">   */</a>
<a name="ln53">  switch (sort)</a>
<a name="ln54">    {</a>
<a name="ln55">      case BGP_PEER_IBGP:</a>
<a name="ln56">        return cfg-&gt;maxpaths_ibgp != BGP_DEFAULT_MAXPATHS;</a>
<a name="ln57">      case BGP_PEER_EBGP:</a>
<a name="ln58">        return cfg-&gt;maxpaths_ebgp != BGP_DEFAULT_MAXPATHS;</a>
<a name="ln59">      default:</a>
<a name="ln60">        return false;</a>
<a name="ln61">    }</a>
<a name="ln62">}</a>
<a name="ln63"> </a>
<a name="ln64">bool</a>
<a name="ln65">bgp_mpath_is_configured (struct bgp *bgp, afi_t afi, safi_t safi)</a>
<a name="ln66">{</a>
<a name="ln67">  return bgp_mpath_is_configured_sort (bgp, BGP_PEER_IBGP, afi, safi)</a>
<a name="ln68">         || bgp_mpath_is_configured_sort (bgp, BGP_PEER_EBGP, afi, safi);</a>
<a name="ln69">}</a>
<a name="ln70"> </a>
<a name="ln71">/*</a>
<a name="ln72"> * bgp_maximum_paths_set</a>
<a name="ln73"> *</a>
<a name="ln74"> * Record maximum-paths configuration for BGP instance</a>
<a name="ln75"> */</a>
<a name="ln76">int</a>
<a name="ln77">bgp_maximum_paths_set (struct bgp *bgp, afi_t afi, safi_t safi,</a>
<a name="ln78">                       int peertype, u_int16_t maxpaths)</a>
<a name="ln79">{</a>
<a name="ln80">  if (!bgp || (afi &gt;= AFI_MAX) || (safi &gt;= SAFI_MAX))</a>
<a name="ln81">    return -1;</a>
<a name="ln82"> </a>
<a name="ln83">  switch (peertype)</a>
<a name="ln84">    {</a>
<a name="ln85">    case BGP_PEER_IBGP:</a>
<a name="ln86">      bgp-&gt;maxpaths[afi][safi].maxpaths_ibgp = maxpaths;</a>
<a name="ln87">      break;</a>
<a name="ln88">    case BGP_PEER_EBGP:</a>
<a name="ln89">      bgp-&gt;maxpaths[afi][safi].maxpaths_ebgp = maxpaths;</a>
<a name="ln90">      break;</a>
<a name="ln91">    default:</a>
<a name="ln92">      return -1;</a>
<a name="ln93">    }</a>
<a name="ln94"> </a>
<a name="ln95">  return 0;</a>
<a name="ln96">}</a>
<a name="ln97"> </a>
<a name="ln98">/*</a>
<a name="ln99"> * bgp_maximum_paths_unset</a>
<a name="ln100"> *</a>
<a name="ln101"> * Remove maximum-paths configuration from BGP instance</a>
<a name="ln102"> */</a>
<a name="ln103">int</a>
<a name="ln104">bgp_maximum_paths_unset (struct bgp *bgp, afi_t afi, safi_t safi,</a>
<a name="ln105">                         int peertype)</a>
<a name="ln106">{</a>
<a name="ln107">  if (!bgp || (afi &gt;= AFI_MAX) || (safi &gt;= SAFI_MAX))</a>
<a name="ln108">    return -1;</a>
<a name="ln109"> </a>
<a name="ln110">  switch (peertype)</a>
<a name="ln111">    {</a>
<a name="ln112">    case BGP_PEER_IBGP:</a>
<a name="ln113">      bgp-&gt;maxpaths[afi][safi].maxpaths_ibgp = BGP_DEFAULT_MAXPATHS;</a>
<a name="ln114">      break;</a>
<a name="ln115">    case BGP_PEER_EBGP:</a>
<a name="ln116">      bgp-&gt;maxpaths[afi][safi].maxpaths_ebgp = BGP_DEFAULT_MAXPATHS;</a>
<a name="ln117">      break;</a>
<a name="ln118">    default:</a>
<a name="ln119">      return -1;</a>
<a name="ln120">    }</a>
<a name="ln121"> </a>
<a name="ln122">  return 0;</a>
<a name="ln123">}</a>
<a name="ln124"> </a>
<a name="ln125">/*</a>
<a name="ln126"> * bgp_info_nexthop_cmp</a>
<a name="ln127"> *</a>
<a name="ln128"> * Compare the nexthops of two paths. Return value is less than, equal to,</a>
<a name="ln129"> * or greater than zero if bi1 is respectively less than, equal to,</a>
<a name="ln130"> * or greater than bi2.</a>
<a name="ln131"> */</a>
<a name="ln132">static int</a>
<a name="ln133">bgp_info_nexthop_cmp (struct bgp_info *bi1, struct bgp_info *bi2)</a>
<a name="ln134">{</a>
<a name="ln135">  struct attr_extra *ae1, *ae2;</a>
<a name="ln136">  int compare;</a>
<a name="ln137"> </a>
<a name="ln138">  ae1 = bi1-&gt;attr-&gt;extra;</a>
<a name="ln139">  ae2 = bi2-&gt;attr-&gt;extra;</a>
<a name="ln140"> </a>
<a name="ln141">  compare = IPV4_ADDR_CMP (&amp;bi1-&gt;attr-&gt;nexthop, &amp;bi2-&gt;attr-&gt;nexthop);</a>
<a name="ln142"> </a>
<a name="ln143">  if (!compare &amp;&amp; ae1 &amp;&amp; ae2)</a>
<a name="ln144">    {</a>
<a name="ln145">      if (ae1-&gt;mp_nexthop_len == ae2-&gt;mp_nexthop_len)</a>
<a name="ln146">        {</a>
<a name="ln147">          switch (ae1-&gt;mp_nexthop_len)</a>
<a name="ln148">            {</a>
<a name="ln149">            case 4:</a>
<a name="ln150">            case 12:</a>
<a name="ln151">              compare = IPV4_ADDR_CMP (&amp;ae1-&gt;mp_nexthop_global_in,</a>
<a name="ln152">                                       &amp;ae2-&gt;mp_nexthop_global_in);</a>
<a name="ln153">              break;</a>
<a name="ln154">            case 16:</a>
<a name="ln155">              compare = IPV6_ADDR_CMP (&amp;ae1-&gt;mp_nexthop_global,</a>
<a name="ln156">                                       &amp;ae2-&gt;mp_nexthop_global);</a>
<a name="ln157">              break;</a>
<a name="ln158">            case 32:</a>
<a name="ln159">              compare = IPV6_ADDR_CMP (&amp;ae1-&gt;mp_nexthop_global,</a>
<a name="ln160">                                       &amp;ae2-&gt;mp_nexthop_global);</a>
<a name="ln161">              if (!compare)</a>
<a name="ln162">                compare = IPV6_ADDR_CMP (&amp;ae1-&gt;mp_nexthop_local,</a>
<a name="ln163">                                         &amp;ae2-&gt;mp_nexthop_local);</a>
<a name="ln164">              break;</a>
<a name="ln165">            }</a>
<a name="ln166">        }</a>
<a name="ln167"> </a>
<a name="ln168">      /* This can happen if one IPv6 peer sends you global and link-local</a>
<a name="ln169">       * nexthops but another IPv6 peer only sends you global</a>
<a name="ln170">       */</a>
<a name="ln171">      else if (ae1-&gt;mp_nexthop_len == 16 || ae1-&gt;mp_nexthop_len == 32)</a>
<a name="ln172">        {</a>
<a name="ln173">          compare = IPV6_ADDR_CMP (&amp;ae1-&gt;mp_nexthop_global,</a>
<a name="ln174">                                   &amp;ae2-&gt;mp_nexthop_global);</a>
<a name="ln175">          if (!compare)</a>
<a name="ln176">            {</a>
<a name="ln177">              if (ae1-&gt;mp_nexthop_len &lt; ae2-&gt;mp_nexthop_len)</a>
<a name="ln178">                compare = -1;</a>
<a name="ln179">              else</a>
<a name="ln180">                compare = 1;</a>
<a name="ln181">            }</a>
<a name="ln182">        }</a>
<a name="ln183">    }</a>
<a name="ln184"> </a>
<a name="ln185">  return compare;</a>
<a name="ln186">}</a>
<a name="ln187"> </a>
<a name="ln188">/*</a>
<a name="ln189"> * bgp_info_mpath_cmp</a>
<a name="ln190"> *</a>
<a name="ln191"> * This function determines our multipath list ordering. By ordering</a>
<a name="ln192"> * the list we can deterministically select which paths are included</a>
<a name="ln193"> * in the multipath set. The ordering also helps in detecting changes</a>
<a name="ln194"> * in the multipath selection so we can detect whether to send an</a>
<a name="ln195"> * update to zebra.</a>
<a name="ln196"> *</a>
<a name="ln197"> * The order of paths is determined first by received nexthop, and then</a>
<a name="ln198"> * by peer address if the nexthops are the same.</a>
<a name="ln199"> */</a>
<a name="ln200">static int</a>
<a name="ln201">bgp_info_mpath_cmp (void *val1, void *val2)</a>
<a name="ln202">{</a>
<a name="ln203">  struct bgp_info *bi1, *bi2;</a>
<a name="ln204">  int compare;</a>
<a name="ln205"> </a>
<a name="ln206">  bi1 = val1;</a>
<a name="ln207">  bi2 = val2;</a>
<a name="ln208"> </a>
<a name="ln209">  compare = bgp_info_nexthop_cmp (bi1, bi2);</a>
<a name="ln210"> </a>
<a name="ln211">  if (!compare)</a>
<a name="ln212">    compare = sockunion_cmp (bi1-&gt;peer-&gt;su_remote, bi2-&gt;peer-&gt;su_remote);</a>
<a name="ln213"> </a>
<a name="ln214">  return compare;</a>
<a name="ln215">}</a>
<a name="ln216"> </a>
<a name="ln217">/*</a>
<a name="ln218"> * bgp_mp_list_init</a>
<a name="ln219"> *</a>
<a name="ln220"> * Initialize the mp_list, which holds the list of multipaths</a>
<a name="ln221"> * selected by bgp_best_selection</a>
<a name="ln222"> */</a>
<a name="ln223">void</a>
<a name="ln224">bgp_mp_list_init (struct list *mp_list)</a>
<a name="ln225">{</a>
<a name="ln226">  assert (mp_list);</a>
<a name="ln227">  memset (mp_list, 0, sizeof (struct list));</a>
<a name="ln228">  mp_list-&gt;cmp = bgp_info_mpath_cmp;</a>
<a name="ln229">}</a>
<a name="ln230"> </a>
<a name="ln231">/*</a>
<a name="ln232"> * bgp_mp_list_clear</a>
<a name="ln233"> *</a>
<a name="ln234"> * Clears all entries out of the mp_list</a>
<a name="ln235"> */</a>
<a name="ln236">void</a>
<a name="ln237">bgp_mp_list_clear (struct list *mp_list)</a>
<a name="ln238">{</a>
<a name="ln239">  assert (mp_list);</a>
<a name="ln240">  list_delete_all_node (mp_list);</a>
<a name="ln241">}</a>
<a name="ln242"> </a>
<a name="ln243">/*</a>
<a name="ln244"> * bgp_mp_list_add</a>
<a name="ln245"> *</a>
<a name="ln246"> * Adds a multipath entry to the mp_list</a>
<a name="ln247"> */</a>
<a name="ln248">void</a>
<a name="ln249">bgp_mp_list_add (struct list *mp_list, struct bgp_info *mpinfo)</a>
<a name="ln250">{</a>
<a name="ln251">  assert (mp_list &amp;&amp; mpinfo);</a>
<a name="ln252">  listnode_add_sort (mp_list, mpinfo);</a>
<a name="ln253">}</a>
<a name="ln254"> </a>
<a name="ln255">/*</a>
<a name="ln256"> * bgp_info_mpath_new</a>
<a name="ln257"> *</a>
<a name="ln258"> * Allocate and zero memory for a new bgp_info_mpath element</a>
<a name="ln259"> */</a>
<a name="ln260">static struct bgp_info_mpath *</a>
<a name="ln261">bgp_info_mpath_new (void)</a>
<a name="ln262">{</a>
<a name="ln263">  struct bgp_info_mpath *new_mpath;</a>
<a name="ln264">  new_mpath = XCALLOC (MTYPE_BGP_MPATH_INFO, sizeof (struct bgp_info_mpath));</a>
<a name="ln265">  return new_mpath;</a>
<a name="ln266">}</a>
<a name="ln267"> </a>
<a name="ln268">/*</a>
<a name="ln269"> * bgp_info_mpath_free</a>
<a name="ln270"> *</a>
<a name="ln271"> * Release resources for a bgp_info_mpath element and zero out pointer</a>
<a name="ln272"> */</a>
<a name="ln273">void</a>
<a name="ln274">bgp_info_mpath_free (struct bgp_info_mpath **mpath)</a>
<a name="ln275">{</a>
<a name="ln276">  if (mpath &amp;&amp; *mpath)</a>
<a name="ln277">    {</a>
<a name="ln278">      if ((*mpath)-&gt;mp_attr)</a>
<a name="ln279">        bgp_attr_unintern (&amp;(*mpath)-&gt;mp_attr);</a>
<a name="ln280">      XFREE (MTYPE_BGP_MPATH_INFO, *mpath);</a>
<a name="ln281">      *mpath = NULL;</a>
<a name="ln282">    }</a>
<a name="ln283">}</a>
<a name="ln284"> </a>
<a name="ln285">/*</a>
<a name="ln286"> * bgp_info_mpath_get</a>
<a name="ln287"> *</a>
<a name="ln288"> * Fetch the mpath element for the given bgp_info. Used for</a>
<a name="ln289"> * doing lazy allocation.</a>
<a name="ln290"> */</a>
<a name="ln291">static struct bgp_info_mpath *</a>
<a name="ln292">bgp_info_mpath_get (struct bgp_info *binfo)</a>
<a name="ln293">{</a>
<a name="ln294">  struct bgp_info_mpath *mpath;</a>
<a name="ln295">  if (!binfo-&gt;mpath)</a>
<a name="ln296">    {</a>
<a name="ln297">      mpath = bgp_info_mpath_new();</a>
<a name="ln298">      if (!mpath)</a>
<a name="ln299">        return NULL;</a>
<a name="ln300">      binfo-&gt;mpath = mpath;</a>
<a name="ln301">      mpath-&gt;mp_info = binfo;</a>
<a name="ln302">    }</a>
<a name="ln303">  return binfo-&gt;mpath;</a>
<a name="ln304">}</a>
<a name="ln305"> </a>
<a name="ln306">/*</a>
<a name="ln307"> * bgp_info_mpath_enqueue</a>
<a name="ln308"> *</a>
<a name="ln309"> * Enqueue a path onto the multipath list given the previous multipath</a>
<a name="ln310"> * list entry</a>
<a name="ln311"> */</a>
<a name="ln312">static void</a>
<a name="ln313">bgp_info_mpath_enqueue (struct bgp_info *prev_info, struct bgp_info *binfo)</a>
<a name="ln314">{</a>
<a name="ln315">  struct bgp_info_mpath *prev, *mpath;</a>
<a name="ln316"> </a>
<a name="ln317">  prev = bgp_info_mpath_get (prev_info);</a>
<a name="ln318">  mpath = bgp_info_mpath_get (binfo);</a>
<a name="ln319">  if (!prev || !mpath)</a>
<a name="ln320">    return;</a>
<a name="ln321"> </a>
<a name="ln322">  mpath-&gt;mp_next = prev-&gt;mp_next;</a>
<a name="ln323">  mpath-&gt;mp_prev = prev;</a>
<a name="ln324">  if (prev-&gt;mp_next)</a>
<a name="ln325">    prev-&gt;mp_next-&gt;mp_prev = mpath;</a>
<a name="ln326">  prev-&gt;mp_next = mpath;</a>
<a name="ln327"> </a>
<a name="ln328">  SET_FLAG (binfo-&gt;flags, BGP_INFO_MULTIPATH);</a>
<a name="ln329">}</a>
<a name="ln330"> </a>
<a name="ln331">/*</a>
<a name="ln332"> * bgp_info_mpath_dequeue</a>
<a name="ln333"> *</a>
<a name="ln334"> * Remove a path from the multipath list</a>
<a name="ln335"> */</a>
<a name="ln336">void</a>
<a name="ln337">bgp_info_mpath_dequeue (struct bgp_info *binfo)</a>
<a name="ln338">{</a>
<a name="ln339">  struct bgp_info_mpath *mpath = binfo-&gt;mpath;</a>
<a name="ln340">  if (!mpath)</a>
<a name="ln341">    return;</a>
<a name="ln342">  if (mpath-&gt;mp_prev)</a>
<a name="ln343">    mpath-&gt;mp_prev-&gt;mp_next = mpath-&gt;mp_next;</a>
<a name="ln344">  if (mpath-&gt;mp_next)</a>
<a name="ln345">    mpath-&gt;mp_next-&gt;mp_prev = mpath-&gt;mp_prev;</a>
<a name="ln346">  mpath-&gt;mp_next = mpath-&gt;mp_prev = NULL;</a>
<a name="ln347">  UNSET_FLAG (binfo-&gt;flags, BGP_INFO_MULTIPATH);</a>
<a name="ln348">}</a>
<a name="ln349"> </a>
<a name="ln350">/*</a>
<a name="ln351"> * bgp_info_mpath_next</a>
<a name="ln352"> *</a>
<a name="ln353"> * Given a bgp_info, return the next multipath entry</a>
<a name="ln354"> */</a>
<a name="ln355">struct bgp_info *</a>
<a name="ln356">bgp_info_mpath_next (struct bgp_info *binfo)</a>
<a name="ln357">{</a>
<a name="ln358">  if (!binfo-&gt;mpath || !binfo-&gt;mpath-&gt;mp_next)</a>
<a name="ln359">    return NULL;</a>
<a name="ln360">  return binfo-&gt;mpath-&gt;mp_next-&gt;mp_info;</a>
<a name="ln361">}</a>
<a name="ln362"> </a>
<a name="ln363">/*</a>
<a name="ln364"> * bgp_info_mpath_first</a>
<a name="ln365"> *</a>
<a name="ln366"> * Given bestpath bgp_info, return the first multipath entry.</a>
<a name="ln367"> */</a>
<a name="ln368">struct bgp_info *</a>
<a name="ln369">bgp_info_mpath_first (struct bgp_info *binfo)</a>
<a name="ln370">{</a>
<a name="ln371">  return bgp_info_mpath_next (binfo);</a>
<a name="ln372">}</a>
<a name="ln373"> </a>
<a name="ln374">/*</a>
<a name="ln375"> * bgp_info_mpath_count</a>
<a name="ln376"> *</a>
<a name="ln377"> * Given the bestpath bgp_info, return the number of multipath entries</a>
<a name="ln378"> */</a>
<a name="ln379">u_int32_t</a>
<a name="ln380">bgp_info_mpath_count (struct bgp_info *binfo)</a>
<a name="ln381">{</a>
<a name="ln382">  if (!binfo-&gt;mpath)</a>
<a name="ln383">    return 0;</a>
<a name="ln384">  return binfo-&gt;mpath-&gt;mp_count;</a>
<a name="ln385">}</a>
<a name="ln386"> </a>
<a name="ln387">/*</a>
<a name="ln388"> * bgp_info_mpath_count_set</a>
<a name="ln389"> *</a>
<a name="ln390"> * Sets the count of multipaths into bestpath's mpath element</a>
<a name="ln391"> */</a>
<a name="ln392">static void</a>
<a name="ln393">bgp_info_mpath_count_set (struct bgp_info *binfo, u_int32_t count)</a>
<a name="ln394">{</a>
<a name="ln395">  struct bgp_info_mpath *mpath;</a>
<a name="ln396">  if (!count &amp;&amp; !binfo-&gt;mpath)</a>
<a name="ln397">    return;</a>
<a name="ln398">  mpath = bgp_info_mpath_get (binfo);</a>
<a name="ln399">  if (!mpath)</a>
<a name="ln400">    return;</a>
<a name="ln401">  mpath-&gt;mp_count = count;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">/*</a>
<a name="ln405"> * bgp_info_mpath_attr</a>
<a name="ln406"> *</a>
<a name="ln407"> * Given bestpath bgp_info, return aggregated attribute set used</a>
<a name="ln408"> * for advertising the multipath route</a>
<a name="ln409"> */</a>
<a name="ln410">struct attr *</a>
<a name="ln411">bgp_info_mpath_attr (struct bgp_info *binfo)</a>
<a name="ln412">{</a>
<a name="ln413">  if (!binfo-&gt;mpath)</a>
<a name="ln414">    return NULL;</a>
<a name="ln415">  return binfo-&gt;mpath-&gt;mp_attr;</a>
<a name="ln416">}</a>
<a name="ln417"> </a>
<a name="ln418">/*</a>
<a name="ln419"> * bgp_info_mpath_attr_set</a>
<a name="ln420"> *</a>
<a name="ln421"> * Sets the aggregated attribute into bestpath's mpath element</a>
<a name="ln422"> */</a>
<a name="ln423">static void</a>
<a name="ln424">bgp_info_mpath_attr_set (struct bgp_info *binfo, struct attr *attr)</a>
<a name="ln425">{</a>
<a name="ln426">  struct bgp_info_mpath *mpath;</a>
<a name="ln427">  if (!attr &amp;&amp; !binfo-&gt;mpath)</a>
<a name="ln428">    return;</a>
<a name="ln429">  mpath = bgp_info_mpath_get (binfo);</a>
<a name="ln430">  if (!mpath)</a>
<a name="ln431">    return;</a>
<a name="ln432">  mpath-&gt;mp_attr = attr;</a>
<a name="ln433">}</a>
<a name="ln434"> </a>
<a name="ln435">/*</a>
<a name="ln436"> * bgp_info_mpath_update</a>
<a name="ln437"> *</a>
<a name="ln438"> * Compare and sync up the multipath list with the mp_list generated by</a>
<a name="ln439"> * bgp_best_selection</a>
<a name="ln440"> */</a>
<a name="ln441">void</a>
<a name="ln442">bgp_info_mpath_update (struct bgp_node *rn, struct bgp_info *new_best,</a>
<a name="ln443">                       struct bgp_info *old_best, struct list *mp_list,</a>
<a name="ln444">                        afi_t afi, safi_t safi)</a>
<a name="ln445">{</a>
<a name="ln446">  u_int16_t maxpaths, mpath_count, old_mpath_count;</a>
<a name="ln447">  struct listnode *mp_node, *mp_next_node;</a>
<a name="ln448">  struct bgp_info *cur_mpath, *new_mpath, *next_mpath, *prev_mpath;</a>
<a name="ln449">  int mpath_changed, debug;</a>
<a name="ln450">  char pfx_buf[INET6_ADDRSTRLEN], nh_buf[2][INET6_ADDRSTRLEN];</a>
<a name="ln451">  struct bgp_maxpaths_cfg *mpath_cfg = NULL;</a>
<a name="ln452"> </a>
<a name="ln453">  mpath_changed = 0;</a>
<a name="ln454">  maxpaths = BGP_DEFAULT_MAXPATHS;</a>
<a name="ln455">  mpath_count = 0;</a>
<a name="ln456">  cur_mpath = NULL;</a>
<a name="ln457">  old_mpath_count = 0;</a>
<a name="ln458">  prev_mpath = new_best;</a>
<a name="ln459">  mp_node = listhead (mp_list);</a>
<a name="ln460"> </a>
<a name="ln461">  debug = BGP_DEBUG (events, EVENTS);</a>
<a name="ln462"> </a>
<a name="ln463">  if (debug)</a>
<a name="ln464">    prefix2str (&amp;rn-&gt;p, pfx_buf, sizeof (pfx_buf));</a>
<a name="ln465"> </a>
<a name="ln466">  if (new_best)</a>
<a name="ln467">    {</a>
<a name="ln468">      mpath_cfg = &amp;new_best-&gt;peer-&gt;bgp-&gt;maxpaths[afi][safi];</a>
<a name="ln469">      mpath_count++;</a>
<a name="ln470">      if (new_best != old_best)</a>
<a name="ln471">        bgp_info_mpath_dequeue (new_best);</a>
<a name="ln472">      maxpaths = (new_best-&gt;peer-&gt;sort == BGP_PEER_IBGP) ?</a>
<a name="ln473">        mpath_cfg-&gt;maxpaths_ibgp : mpath_cfg-&gt;maxpaths_ebgp;</a>
<a name="ln474">    }</a>
<a name="ln475"> </a>
<a name="ln476">  if (old_best)</a>
<a name="ln477">    {</a>
<a name="ln478">      cur_mpath = bgp_info_mpath_first (old_best);</a>
<a name="ln479">      old_mpath_count = bgp_info_mpath_count (old_best);</a>
<a name="ln480">      bgp_info_mpath_count_set (old_best, 0);</a>
<a name="ln481">      bgp_info_mpath_dequeue (old_best);</a>
<a name="ln482">    }</a>
<a name="ln483"> </a>
<a name="ln484">  /*</a>
<a name="ln485">   * We perform an ordered walk through both lists in parallel.</a>
<a name="ln486">   * The reason for the ordered walk is that if there are paths</a>
<a name="ln487">   * that were previously multipaths and are still multipaths, the walk</a>
<a name="ln488">   * should encounter them in both lists at the same time. Otherwise</a>
<a name="ln489">   * there will be paths that are in one list or another, and we</a>
<a name="ln490">   * will deal with these separately.</a>
<a name="ln491">   *</a>
<a name="ln492">   * Note that new_best might be somewhere in the mp_list, so we need</a>
<a name="ln493">   * to skip over it</a>
<a name="ln494">   */</a>
<a name="ln495">  while (mp_node || cur_mpath)</a>
<a name="ln496">    {</a>
<a name="ln497">      /*</a>
<a name="ln498">       * We can bail out of this loop if all existing paths on the</a>
<a name="ln499">       * multipath list have been visited (for cleanup purposes) and</a>
<a name="ln500">       * the maxpath requirement is fulfulled</a>
<a name="ln501">       */</a>
<a name="ln502">      if (!cur_mpath &amp;&amp; (mpath_count &gt;= maxpaths))</a>
<a name="ln503">        break;</a>
<a name="ln504"> </a>
<a name="ln505">      mp_next_node = mp_node ? listnextnode (mp_node) : NULL;</a>
<a name="ln506">      next_mpath = cur_mpath ? bgp_info_mpath_next (cur_mpath) : NULL;</a>
<a name="ln507"> </a>
<a name="ln508">      /*</a>
<a name="ln509">       * If equal, the path was a multipath and is still a multipath.</a>
<a name="ln510">       * Insert onto new multipath list if maxpaths allows.</a>
<a name="ln511">       */</a>
<a name="ln512">      if (mp_node &amp;&amp; (listgetdata (mp_node) == cur_mpath))</a>
<a name="ln513">        {</a>
<a name="ln514">          list_delete_node (mp_list, mp_node);</a>
<a name="ln515">          bgp_info_mpath_dequeue (cur_mpath);</a>
<a name="ln516">          if ((mpath_count &lt; maxpaths) &amp;&amp;</a>
<a name="ln517">              bgp_info_nexthop_cmp (prev_mpath, cur_mpath))</a>
<a name="ln518">            {</a>
<a name="ln519">              bgp_info_mpath_enqueue (prev_mpath, cur_mpath);</a>
<a name="ln520">              prev_mpath = cur_mpath;</a>
<a name="ln521">              mpath_count++;</a>
<a name="ln522">            }</a>
<a name="ln523">          else</a>
<a name="ln524">            {</a>
<a name="ln525">              mpath_changed = 1;</a>
<a name="ln526">              if (debug)</a>
<a name="ln527">                zlog_debug (&quot;%s remove mpath nexthop %s peer %s&quot;, pfx_buf,</a>
<a name="ln528">                            inet_ntop (AF_INET, &amp;cur_mpath-&gt;attr-&gt;nexthop,</a>
<a name="ln529">                                       nh_buf[0], sizeof (nh_buf[0])),</a>
<a name="ln530">                            sockunion2str (cur_mpath-&gt;peer-&gt;su_remote,</a>
<a name="ln531">                                           nh_buf[1], sizeof (nh_buf[1])));</a>
<a name="ln532">            }</a>
<a name="ln533">          mp_node = mp_next_node;</a>
<a name="ln534">          cur_mpath = next_mpath;</a>
<a name="ln535">          continue;</a>
<a name="ln536">        }</a>
<a name="ln537"> </a>
<a name="ln538">      if (cur_mpath &amp;&amp; (!mp_node ||</a>
<a name="ln539">                        (bgp_info_mpath_cmp (cur_mpath,</a>
<a name="ln540">                                             listgetdata (mp_node)) &lt; 0)))</a>
<a name="ln541">        {</a>
<a name="ln542">          /*</a>
<a name="ln543">           * If here, we have an old multipath and either the mp_list</a>
<a name="ln544">           * is finished or the next mp_node points to a later</a>
<a name="ln545">           * multipath, so we need to purge this path from the</a>
<a name="ln546">           * multipath list</a>
<a name="ln547">           */</a>
<a name="ln548">          bgp_info_mpath_dequeue (cur_mpath);</a>
<a name="ln549">          mpath_changed = 1;</a>
<a name="ln550">          if (debug)</a>
<a name="ln551">            zlog_debug (&quot;%s remove mpath nexthop %s peer %s&quot;, pfx_buf,</a>
<a name="ln552">                        inet_ntop (AF_INET, &amp;cur_mpath-&gt;attr-&gt;nexthop,</a>
<a name="ln553">                                   nh_buf[0], sizeof (nh_buf[0])),</a>
<a name="ln554">                        sockunion2str (cur_mpath-&gt;peer-&gt;su_remote,</a>
<a name="ln555">                                       nh_buf[1], sizeof (nh_buf[1])));</a>
<a name="ln556">          cur_mpath = next_mpath;</a>
<a name="ln557">        }</a>
<a name="ln558">      else</a>
<a name="ln559">        {</a>
<a name="ln560">          /*</a>
<a name="ln561">           * If here, we have a path on the mp_list that was not previously</a>
<a name="ln562">           * a multipath (due to non-equivalance or maxpaths exceeded),</a>
<a name="ln563">           * or the matching multipath is sorted later in the multipath</a>
<a name="ln564">           * list. Before we enqueue the path on the new multipath list,</a>
<a name="ln565">           * make sure its not on the old_best multipath list or referenced</a>
<a name="ln566">           * via next_mpath:</a>
<a name="ln567">           * - If next_mpath points to this new path, update next_mpath to</a>
<a name="ln568">           *   point to the multipath after this one</a>
<a name="ln569">           * - Dequeue the path from the multipath list just to make sure</a>
<a name="ln570">           */</a>
<a name="ln571">          new_mpath = listgetdata (mp_node);</a>
<a name="ln572">          list_delete_node (mp_list, mp_node);</a>
<a name="ln573">          if ((mpath_count &lt; maxpaths) &amp;&amp; (new_mpath != new_best) &amp;&amp;</a>
<a name="ln574">              bgp_info_nexthop_cmp (prev_mpath, new_mpath))</a>
<a name="ln575">            {</a>
<a name="ln576">              if (new_mpath == next_mpath)</a>
<a name="ln577">                next_mpath = bgp_info_mpath_next (new_mpath);</a>
<a name="ln578">              bgp_info_mpath_dequeue (new_mpath);</a>
<a name="ln579"> </a>
<a name="ln580">              bgp_info_mpath_enqueue (prev_mpath, new_mpath);</a>
<a name="ln581">              prev_mpath = new_mpath;</a>
<a name="ln582">              mpath_changed = 1;</a>
<a name="ln583">              mpath_count++;</a>
<a name="ln584">              if (debug)</a>
<a name="ln585">                zlog_debug (&quot;%s add mpath nexthop %s peer %s&quot;, pfx_buf,</a>
<a name="ln586">                            inet_ntop (AF_INET, &amp;new_mpath-&gt;attr-&gt;nexthop,</a>
<a name="ln587">                                       nh_buf[0], sizeof (nh_buf[0])),</a>
<a name="ln588">                            sockunion2str (new_mpath-&gt;peer-&gt;su_remote,</a>
<a name="ln589">                                           nh_buf[1], sizeof (nh_buf[1])));</a>
<a name="ln590">            }</a>
<a name="ln591">          mp_node = mp_next_node;</a>
<a name="ln592">        }</a>
<a name="ln593">    }</a>
<a name="ln594"> </a>
<a name="ln595">  if (new_best)</a>
<a name="ln596">    {</a>
<a name="ln597">      bgp_info_mpath_count_set (new_best, mpath_count-1);</a>
<a name="ln598">      if (mpath_changed || (bgp_info_mpath_count (new_best) != old_mpath_count))</a>
<a name="ln599">        SET_FLAG (new_best-&gt;flags, BGP_INFO_MULTIPATH_CHG);</a>
<a name="ln600">    }</a>
<a name="ln601">}</a>
<a name="ln602"> </a>
<a name="ln603">/*</a>
<a name="ln604"> * bgp_mp_dmed_deselect</a>
<a name="ln605"> *</a>
<a name="ln606"> * Clean up multipath information for BGP_INFO_DMED_SELECTED path that</a>
<a name="ln607"> * is not selected as best path</a>
<a name="ln608"> */</a>
<a name="ln609">void</a>
<a name="ln610">bgp_mp_dmed_deselect (struct bgp_info *dmed_best)</a>
<a name="ln611">{</a>
<a name="ln612">  struct bgp_info *mpinfo, *mpnext;</a>
<a name="ln613"> </a>
<a name="ln614">  if (!dmed_best)</a>
<a name="ln615">    return;</a>
<a name="ln616"> </a>
<a name="ln617">  for (mpinfo = bgp_info_mpath_first (dmed_best); mpinfo; mpinfo = mpnext)</a>
<a name="ln618">    {</a>
<a name="ln619">      mpnext = bgp_info_mpath_next (mpinfo);</a>
<a name="ln620">      bgp_info_mpath_dequeue (mpinfo);</a>
<a name="ln621">    }</a>
<a name="ln622"> </a>
<a name="ln623">  bgp_info_mpath_count_set (dmed_best, 0);</a>
<a name="ln624">  UNSET_FLAG (dmed_best-&gt;flags, BGP_INFO_MULTIPATH_CHG);</a>
<a name="ln625">  assert (bgp_info_mpath_first (dmed_best) == 0);</a>
<a name="ln626">}</a>
<a name="ln627"> </a>
<a name="ln628">/*</a>
<a name="ln629"> * bgp_info_mpath_aggregate_update</a>
<a name="ln630"> *</a>
<a name="ln631"> * Set the multipath aggregate attribute. We need to see if the</a>
<a name="ln632"> * aggregate has changed and then set the ATTR_CHANGED flag on the</a>
<a name="ln633"> * bestpath info so that a peer update will be generated. The</a>
<a name="ln634"> * change is detected by generating the current attribute,</a>
<a name="ln635"> * interning it, and then comparing the interned pointer with the</a>
<a name="ln636"> * current value. We can skip this generate/compare step if there</a>
<a name="ln637"> * is no change in multipath selection and no attribute change in</a>
<a name="ln638"> * any multipath.</a>
<a name="ln639"> */</a>
<a name="ln640">void</a>
<a name="ln641">bgp_info_mpath_aggregate_update (struct bgp_info *new_best,</a>
<a name="ln642">                                 struct bgp_info *old_best)</a>
<a name="ln643">{</a>
<a name="ln644">  struct bgp_info *mpinfo;</a>
<a name="ln645">  struct aspath *aspath;</a>
<a name="ln646">  struct aspath *asmerge;</a>
<a name="ln647">  struct attr *new_attr, *old_attr;</a>
<a name="ln648">  u_char origin, attr_chg;</a>
<a name="ln649">  struct community *community, *commerge;</a>
<a name="ln650">  struct ecommunity *ecomm, *ecommerge;</a>
<a name="ln651">  struct lcommunity *lcomm, *lcommerge;</a>
<a name="ln652">  struct attr_extra *ae;</a>
<a name="ln653">  struct attr attr = { 0 };</a>
<a name="ln654"> </a>
<a name="ln655">  if (old_best &amp;&amp; (old_best != new_best) &amp;&amp;</a>
<a name="ln656">      (old_attr = bgp_info_mpath_attr (old_best)))</a>
<a name="ln657">    {</a>
<a name="ln658">      bgp_attr_unintern (&amp;old_attr);</a>
<a name="ln659">      bgp_info_mpath_attr_set (old_best, NULL);</a>
<a name="ln660">    }</a>
<a name="ln661"> </a>
<a name="ln662">  if (!new_best)</a>
<a name="ln663">    return;</a>
<a name="ln664"> </a>
<a name="ln665">  if (!bgp_info_mpath_count (new_best))</a>
<a name="ln666">    {</a>
<a name="ln667">      if ((new_attr = bgp_info_mpath_attr (new_best)))</a>
<a name="ln668">        {</a>
<a name="ln669">          bgp_attr_unintern (&amp;new_attr);</a>
<a name="ln670">          bgp_info_mpath_attr_set (new_best, NULL);</a>
<a name="ln671">          SET_FLAG (new_best-&gt;flags, BGP_INFO_ATTR_CHANGED);</a>
<a name="ln672">        }</a>
<a name="ln673">      return;</a>
<a name="ln674">    }</a>
<a name="ln675"> </a>
<a name="ln676">  /*</a>
<a name="ln677">   * Bail out here if the following is true:</a>
<a name="ln678">   * - MULTIPATH_CHG bit is not set on new_best, and</a>
<a name="ln679">   * - No change in bestpath, and</a>
<a name="ln680">   * - ATTR_CHANGED bit is not set on new_best or any of the multipaths</a>
<a name="ln681">   */</a>
<a name="ln682">  if (!CHECK_FLAG (new_best-&gt;flags, BGP_INFO_MULTIPATH_CHG) &amp;&amp;</a>
<a name="ln683">      (old_best == new_best))</a>
<a name="ln684">    {</a>
<a name="ln685">      attr_chg = 0;</a>
<a name="ln686"> </a>
<a name="ln687">      if (CHECK_FLAG (new_best-&gt;flags, BGP_INFO_ATTR_CHANGED))</a>
<a name="ln688">        attr_chg = 1;</a>
<a name="ln689">      else</a>
<a name="ln690">        for (mpinfo = bgp_info_mpath_first (new_best); mpinfo;</a>
<a name="ln691">             mpinfo = bgp_info_mpath_next (mpinfo))</a>
<a name="ln692">          {</a>
<a name="ln693">            if (CHECK_FLAG (mpinfo-&gt;flags, BGP_INFO_ATTR_CHANGED))</a>
<a name="ln694">              {</a>
<a name="ln695">                attr_chg = 1;</a>
<a name="ln696">                break;</a>
<a name="ln697">              }</a>
<a name="ln698">          }</a>
<a name="ln699"> </a>
<a name="ln700">      if (!attr_chg)</a>
<a name="ln701">        {</a>
<a name="ln702">          assert (bgp_info_mpath_attr (new_best));</a>
<a name="ln703">          return;</a>
<a name="ln704">        }</a>
<a name="ln705">    }</a>
<a name="ln706"> </a>
<a name="ln707">  bgp_attr_dup (&amp;attr, new_best-&gt;attr);</a>
<a name="ln708"> </a>
<a name="ln709">  /* aggregate attribute from multipath constituents */</a>
<a name="ln710">  aspath = aspath_dup (attr.aspath);</a>
<a name="ln711">  origin = attr.origin;</a>
<a name="ln712">  community = attr.community ? community_dup (attr.community) : NULL;</a>
<a name="ln713">  ae = attr.extra;</a>
<a name="ln714">  ecomm = (ae &amp;&amp; ae-&gt;ecommunity) ? ecommunity_dup (ae-&gt;ecommunity) : NULL;</a>
<a name="ln715"> </a>
<a name="ln716">  lcomm = (ae &amp;&amp; ae-&gt;lcommunity) ? lcommunity_dup (ae-&gt;lcommunity) : NULL;</a>
<a name="ln717"> </a>
<a name="ln718">  for (mpinfo = bgp_info_mpath_first (new_best); mpinfo;</a>
<a name="ln719">       mpinfo = bgp_info_mpath_next (mpinfo))</a>
<a name="ln720">    {</a>
<a name="ln721">      asmerge = aspath_aggregate_mpath (aspath, mpinfo-&gt;attr-&gt;aspath);</a>
<a name="ln722">      aspath_free (aspath);</a>
<a name="ln723">      aspath = asmerge;</a>
<a name="ln724"> </a>
<a name="ln725">      if (origin &lt; mpinfo-&gt;attr-&gt;origin)</a>
<a name="ln726">        origin = mpinfo-&gt;attr-&gt;origin;</a>
<a name="ln727"> </a>
<a name="ln728">      if (mpinfo-&gt;attr-&gt;community)</a>
<a name="ln729">        {</a>
<a name="ln730">          if (community)</a>
<a name="ln731">            {</a>
<a name="ln732">              commerge = community_merge (community, mpinfo-&gt;attr-&gt;community);</a>
<a name="ln733">              community = community_uniq_sort (commerge);</a>
<a name="ln734">              community_free (commerge);</a>
<a name="ln735">            }</a>
<a name="ln736">          else</a>
<a name="ln737">            community = community_dup (mpinfo-&gt;attr-&gt;community);</a>
<a name="ln738">        }</a>
<a name="ln739"> </a>
<a name="ln740">      ae = mpinfo-&gt;attr-&gt;extra;</a>
<a name="ln741">      if (ae &amp;&amp; ae-&gt;ecommunity)</a>
<a name="ln742">        {</a>
<a name="ln743">          if (ecomm)</a>
<a name="ln744">            {</a>
<a name="ln745">              ecommerge = ecommunity_merge (ecomm, ae-&gt;ecommunity);</a>
<a name="ln746">              ecomm = ecommunity_uniq_sort (ecommerge);</a>
<a name="ln747">              ecommunity_free (&amp;ecommerge);</a>
<a name="ln748">            }</a>
<a name="ln749">          else</a>
<a name="ln750">            ecomm = ecommunity_dup (ae-&gt;ecommunity);</a>
<a name="ln751">        }</a>
<a name="ln752"> </a>
<a name="ln753">      if (ae &amp;&amp; ae-&gt;lcommunity)</a>
<a name="ln754">        {</a>
<a name="ln755">          if (lcomm)</a>
<a name="ln756">            {</a>
<a name="ln757">              lcommerge = lcommunity_merge (lcomm, ae-&gt;lcommunity);</a>
<a name="ln758">              lcomm = lcommunity_uniq_sort (lcommerge);</a>
<a name="ln759">              lcommunity_free (&amp;lcommerge);</a>
<a name="ln760">            }</a>
<a name="ln761">          else</a>
<a name="ln762">            lcomm = lcommunity_dup (ae-&gt;lcommunity);</a>
<a name="ln763">        }</a>
<a name="ln764">    }</a>
<a name="ln765"> </a>
<a name="ln766">  attr.aspath = aspath;</a>
<a name="ln767">  attr.origin = origin;</a>
<a name="ln768">  if (community)</a>
<a name="ln769">    {</a>
<a name="ln770">      attr.community = community;</a>
<a name="ln771">      attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_COMMUNITIES);</a>
<a name="ln772">    }</a>
<a name="ln773">  if (ecomm)</a>
<a name="ln774">    {</a>
<a name="ln775">      ae = bgp_attr_extra_get (&amp;attr);</a>
<a name="ln776">      ae-&gt;ecommunity = ecomm;</a>
<a name="ln777">      attr.flag |= ATTR_FLAG_BIT (BGP_ATTR_EXT_COMMUNITIES);</a>
<a name="ln778">    }</a>
<a name="ln779"> </a>
<a name="ln780">  /* Zap multipath attr nexthop so we set nexthop to self */</a>
<a name="ln781">  attr.nexthop.s_addr = 0;</a>
<a name="ln782">  if (attr.extra)</a>
<a name="ln783">    memset (&amp;attr.extra-&gt;mp_nexthop_global, 0, sizeof (struct in6_addr));</a>
<a name="ln784"> </a>
<a name="ln785">  /* TODO: should we set ATOMIC_AGGREGATE and AGGREGATOR? */</a>
<a name="ln786"> </a>
<a name="ln787">  new_attr = bgp_attr_intern (&amp;attr);</a>
<a name="ln788">  bgp_attr_extra_free (&amp;attr);</a>
<a name="ln789"> </a>
<a name="ln790">  if (new_attr != bgp_info_mpath_attr (new_best))</a>
<a name="ln791">    {</a>
<a name="ln792">      if ((old_attr = bgp_info_mpath_attr (new_best)))</a>
<a name="ln793">        bgp_attr_unintern (&amp;old_attr);</a>
<a name="ln794">      bgp_info_mpath_attr_set (new_best, new_attr);</a>
<a name="ln795">      SET_FLAG (new_best-&gt;flags, BGP_INFO_ATTR_CHANGED);</a>
<a name="ln796">    }</a>
<a name="ln797">  else</a>
<a name="ln798">    bgp_attr_unintern (&amp;new_attr);</a>
<a name="ln799">}</a>

</code></pre>
<div class="balloon" rel="9"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>
<div class="balloon" rel="505"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v547/" target="_blank">V547</a> Expression 'mp_node' is always true.</p></div>
<div class="balloon" rel="512"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'next_mpath' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
